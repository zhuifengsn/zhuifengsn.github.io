<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a8dcc0936480a07ed965d934bd70325/" rel="bookmark">
			linux操作系统下图书管理系统的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统要求链接： https://blog.csdn.net/keyboardnobug/article/details/107184607​​​​​​ 话不多说，直接先放上同学们最需要的代码，再听我解释其中的工作原理。 main.cpp #include &lt;iostream&gt; #include"user.h" #include"books.h" using namespace std; int main() { userControl uc; uc.loadFromFile("user.txt"); uc.login(); } user.h #ifndef USER_H_INCLUDED #define USER_H_INCLUDED #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;list&gt; #include &lt;fstream&gt; using namespace std; class user { private: string ac; string name; string ps; double sf; public: user(); user(string,string,string,double); void setv(); void resisginv(); void setps(){cin&gt;&gt;ps;} void setac(){cin&gt;&gt;ac;} void setname(){cin&gt;&gt;name;} void setsf(){cin&gt;&gt;sf;} void display(); string getac(){return ac;} string getname(){return name;} string getps(){return ps;} double getsf(){return sf;} }; class userControl { private: list&lt;user&gt; listur; int ac; public: userControl(int); void deletes(); void loadFromFile(string filename); void display(); void input(); void resisgin(); void Sort(); void writeToFile(string filename); void login(); void change(); }; #endif // USER_H_INCLUDED user.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a8dcc0936480a07ed965d934bd70325/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aded3c50da4fad9cdc0d931cb5843c8d/" rel="bookmark">
			生产环境部署与协同开发 Docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Docker介绍和安装 1.1 什么是docker Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。
logo解释：
标志是一头鲸鱼携带着一堆容器。它正在向您发送这些信息的途中。Docker直译过来是码头工人，然而Docker给人的第一感觉是容器，容器技术英译为Linux Container， Container的直译有集装箱，容器两个意思。
什么是"集装箱技术" 我们都知道码头里的集装箱是运载货物用的，它是一种按规格标准化的钢制箱子。集装箱的特色，在于其格式划一，并可以层层重叠， 集装箱与集装箱之间互不影响于是乎，IT领域借鉴了这一理念，大家就在想，有没有可能大家 只需要关注程序本身?
我们都知道码头里的集装箱是运载货物用的，它是一种按规格标准化的钢制箱子。集装箱的特色， 「在于其格式划一，并可以层层重叠， 集装箱与集装箱之间互不影响」
Docker是一个开源的应用容器引擎，开发者可以打包他们的应用及依赖到一个可移植的容器中，发布到流行的Linux机器上，也可实现虚拟化。
重心：
Docker其实就是可以打包程序和运行环境，把环境和程序一起发布的容器。
1.2 为什么要使用Docker Docker容器虚拟化的好处 开发者需要能方便高效构建应用，并且任何时间任何地点都可以获取。就比如我在本地将jdk和tomcat打包直接放到阿里云平台上，就不需要在阿里云上配置环境了。这样可以节省时间和降低风险，提高开发效率。
Docker在开发和运维中的优势 对开发和运维( DevOps)人员来说，可能最梦寐以求的就是一次性地创建或配置，可以在任意环境、任意时间让应用正常地运行。而Docker恰恰是可以实现这一终极目标的瑞士军刀。
优势：
更快速的交付和部署更高效的资源利用更轻松的迁移和扩展更简单的更新管理 Docker与虚拟机比较 作为一种轻量级的虚拟化方式，Docker在运行应用上跟传统的虚拟机方式相比具有显著优势。
特性容器虚拟机启动速度秒级分钟级磁盘使用一般为MB一般为GB性能接近原生弱于系统支持量单机支持上千个容器一般几十个隔离性完全隔离完全隔离 1.3 虚拟化与Docker 虚拟化技术是一个通用的概念,在不同领域有不同的理解。在计算领域，一般指的是计算虚拟化或通常说的服务器虚拟化。
简单的说，「虚拟化」，顾名思义，就是「虚拟」的，是「假」的，是形而上的，是观念上、逻辑上的划分。
举栗说明
假设你现在手头上有一套房子，并且你要把它给租出去，租金的市场价是2000元/月。那么有没有办法把它租得更贵，获得6000元的租金呢？你想到了两个办法：
找一个不差钱的傻X租户，让他每月交6000元，但是这种人不大好找。 把房子拆成4个小房子租给4个单身狗，租金为1500元/人/月。 这些房子其实就是一些电脑资源，例如服务器啊、内存啊、网络啊等等。虚拟化技术就是将一套房子划分为4个功能完善的小房子，提高资源的使用效率。
虚拟化分类：
完全虚拟化（VMware）硬件辅助虚拟化部分虚拟化超虚拟机化操作系统虚拟化 (docker) 什么是物理机 什么是虚拟机 什么是Docker 1.4 Docker的核心概念 Docker技术的三大核心概念，分别是：
镜像（Image）容器 (Container)仓库 (Repository) Docker镜像 当我们使用 Docker 运行一个应用程序的时候，我们需要首先定义一个 Docker 镜像。Docker 镜像是一个只读模板，包含运行应用程序所需的所有内容，例如代码、库文件、运行环境等等。也可以把它看作是一个容易复制和分享的“快照”。
Docker 镜像是由一个或多个文件系统层构成，每个文件系统层都包含着一个应用程序运行所需的不同部分。例如一个镜像可能包含操作系统，另一个镜像可能只包含 Django 应用程序及其依赖项。这些文件系统层会形成一个完整镜像，供 Docker 环境使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aded3c50da4fad9cdc0d931cb5843c8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94629c8b3d634cda703c6c51679512fd/" rel="bookmark">
			OpenCV Mat类基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCv2.X采用全新的图像数据结构Mat代替C接口cvMat和IplImage。全新Mat类不需要我们手动为其开辟空间，也不需要立即释放内存空间，它能够自动管理内存。Mat类由矩阵头和指向存储所有像素值的矩阵的指针构成。Mat类表示一个n维的密集数值单通道或多通道数组，它可用于存储实数或复数值的向量和矩阵、灰度或彩色图像等。
Mat类 class CV_EXPORTS Mat { public: int flags; //标志位 int dims; //数组的维数 int rows, cols; //行和列的数量 uchar* data; //指向数据的指针 int* refcount; //指针的引用计数器，当阵列指向用户分配的数据时，指针为NULL }; Mat类常用的构造方法
无参数构造方法 Mat::Mat() 指定类型的二维数组，创建行数为rows，列数为cols，类型为type的图像 Mat::Mat(int rows,int cols,int type); 创建大小为size,类型为type的图像 Mat::Mat(Size size,int type) 指定类型的二维数组，并指定初始化值。创建行数为rows，列数为cols，类型为type的图像，并将所有元素初始化为值s Mat::Mat(int rows,int cols,int type,const Scalar&amp;s); m和新对象共用图像数据,将m赋值给新创建的对象，此操作不会对图像数据进行复制，m和新对象共用图像数据。 Mat::Mat(const Mat&amp; m) 对上面的几种构造函数应用举例
#include&lt;opencv2/imgproc/imgproc.hpp&gt; #include&lt;opencv2/highgui/highgui.hpp&gt; #include&lt;iostream&gt; using namespace std; using namespace cv; int main() { Mat img1; //创建无初始化矩阵 Mat img2(6, 6, CV_8UC1); //创建6行6列类型为8位单通道矩阵 Mat img3(Size(7, 7), CV_8UC3); //创建大小为7*7类型为8位3通道矩阵 Mat img4(8, 8, CV_32FC2, Scalar(1, 3)); //创建一个用1+3j填充的8*8复矩阵 Mat img5(Size(9, 9), CV_8UC3, Scalar(1, 2, 3));//创建大小为9*9类型的8位3通道矩阵 Mat img6(img2);//将img2的值赋给img6，共用数据图像 cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94629c8b3d634cda703c6c51679512fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f9aa68fb1a7d55008c3bc8d15c12726/" rel="bookmark">
			基于图像识别框架Airtest的Windows项目自动化测试实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面
本次分享的内容是基于Airtest实现Windows应用的自动化测试，内容大纲：
Airtest框架介绍：Airtest适用项目、Airtest特点、Airtest的优势
Airtest框架组成、原理
Airtest环境搭建及IDE的简单使用
Airtest开展Windows应用自动化测试实践：连接Windows应用Windows常用API编写测试代码设计测试用例运行效果查看测试报告
总结与思考
一、Airtest框架介绍
1.Airtest介绍
Airtest是网易出品的一款基于图像识别和Poco控件识别的一款UI自动化测试工具。这个框架设计来源于新颖的图形脚本语言Sikuli，关于Sikuli框架可见上一篇分享《基于Sikuli GUI图像识别框架的PC客户端自动化测试实践》。和Sikuli框架的原理一样，用户不需要一行行的去写代码，而是用屏幕截屏的方式，用截出来的图形摆列组合成神器的程序，这是Airtest的一部分。另外，Airtest也可以基于poco这个UI控件搜索框架，通过控件的名称、id之类的来定位目标控件，原理类似于 appium。官网：airtest.netease.com/
2.Airtest适用项目
游戏
Android
iOS
Web
Windows
3.Airtest特点 跨平台易操作可扩展支持GUI编辑器 4.Airtest的优势 相比于其他的自动化测试框架，Airtest主要有如下两个优势：
大幅度降低自动化脚本的编写和维护成本 解决游戏测试的痛点 二、Airtest框架组成、原理 1.Airtest框架组成 Airtest：是一个跨平台的、基于图像识别的UI自动化测试框架，适用于游戏和App，支持平台有Windows、 Android和iOS；
Poco：是一款基于UI控件识别的自动化测试框架，目前支持Unity3D/cocos2dx/Android原生app/iOS原生app/ 微信小程序，也可以在其他引擎中自行接入poco-sdk来使用；
AirtestIDE：跨平台的UI自动化测试编辑器，内置了Airtest和Poco的相关插件功能，能够快速简单地 编写Airtest和Poco代码；
AirLab：真机自动化云测试平台，目前提供了TOP100手机兼容性测试、海外云真机兼容性测试等服务；
2.Airtest工作原理
三、Airtest环境搭建及IDE的简单使用
官方文档：airtest.doc.io.netease.com/IDEdocs/get…
1.下载安装
1）安装python
由于Airtest框架是基于python语言开发，本地需要搭建python相关环境，建议使用python3
Python 下载地址：www.python.org/downloads/
2）下载AirtestIDE客户端
AirtestIDE客户端下载：airtest.netease.com
Windows系统用户在官网上下载对应32位或是64位版本的zip包，解压后得到AirtestIDE文件夹，双击AirtestIDE/AirtestIDE.exe即可启动
2.Airtest IDE使用 1）生成报告
Airtest运行完成后，会自动生成一份报告，通过下图按钮可以查看，点击后会自动启动浏览器查看报告
2）图片/代码模式切换
Airtest IDE中右键，即可两种模式相互切换
切换后的效果如下：
四、Airtest开展Windows应用自动化测试实践 1.连接Windows应用 连接Windows应用有三种方法，分别是：
1）通过搜索窗口连接
设备窗-Windows窗口连接-搜索窗口，选择窗口后，点击连接
2）通过句柄连接
（由于句柄容易发生变化，因此不推荐此连接方式）：下图的67330即为企业微信的句柄
3）通过正则匹配应用应用标题进行连接
if not cli_setup: auto_setup(__file__, logdir=True, devices=["Windows:///?title_re=.*阅云*"]) 复制代码 2.Windows常用API
官方文档：airtest.readthedocs.io/zh_CN/lates…
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f9aa68fb1a7d55008c3bc8d15c12726/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7939c0b5a1b89f68d54f99b716d9cb69/" rel="bookmark">
			【Linux】常见基本指令（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见基本指令 1、ls2、pwd3、cd4、touch5、mkdir6、rmdir7、rm 1、ls 功能：对于目录，该命令列出该目录下的所有子目录与文件。对于文件，将列出文件名以及其他信息。
语法： ls [选项] [目录或文件]
注意：如果不写目录或文件，会默认列出当前目录或文件的内容。
例1：
例2：
其中，ls -l可以缩写成 l l，它们的效果是一样的：
2、pwd 功能：显示用户当前所在的工作目录。
语法：pwd
例1：
3、cd 功能：改变工作目录。将当前工作目录改变到指定的目录下。
语法：cd 目录名
例1：
需要注意的是，cd 后面不一定要跟目录名，下列是几个常用的且不需要在cd 后加目录名的指令。
例2：
（1）cd .. 返回上级目录
（2）cd /root/test1/mk/ 绝对路径 注意：cd 后面的路径都必须是目录，不能是文件。如下：
（3）cd ../test2/ 相对路径
（4）cd - 返回最近访问的目录
（5）跳转到当前用户的家目录
cd $HOME
cd ~ cd 注意：
root用户：cd ~ 相当于 cd /root
普通用户：cd ~ 相当于 cd /home/用户名
4、touch 功能：修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，会建立一个新的文件。
语法:touch [选项]...文件...
例1：
例2：
例3：
例5：
注意：touch 文件 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7939c0b5a1b89f68d54f99b716d9cb69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37183e0d34ed2fd0526ac311128a4f10/" rel="bookmark">
			简单谈谈对springcloud的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.初始springcloud 很庆幸做的第一个项目就是关于关于springcloud的，同行的同学有的还只是做SSM而已。然后第二个遇到的大项目是springcloud alibaba系列的。为了而对springcloud有一定的理解，当然我们需要做一些铺垫。
2.学习基础 现在网上一堆关于springcloud的基础，本人当时做的还是关于springcloud旧的那一套，也就是以Eureka为注册中心的那一套springcloud。所以我们要去springcloud官网，当然用Google翻译去看中文的springcloud也没啥的，毕竟学技术。然后个人觉得一个是关注springcloud的发展历程，以及一些关于版本的说明，比如说以前的springcloud版本演变，什么时候发生了版本命名变化？springboot版本和springcloud配合使用有什么讲究？springcloud的基本组件有什么？springcloud各个组件之间大概如何通信？哪些组件不再维护了，哪些组件可以和新一代的组件混用？所有这些都需要去粗略地了解一下，当然你可以说我能做项目就行，但是有些知识你不去自己总结形成系统化认知，久了可能自己也忘了。初始springcloud后，我们要想想现在国内去"IOE"化口号喊得这么响，我们国家有没有自己的springcloud呢？当然有，springcloud alibaba。对于springcloud alibaba这一套相关的微服务框架我们又可以继续学习一下，相对于Eureka为注册中心的Nacos有什么优势？还有就是哪些组件可以继续沿用，如gateway?然后就要进一步了解分布式调度平台，为什么要用？如何构建？如何应用？还有springcloud stream？为什么要用这个，不直接用rabbit mq之类的mq?还有就是为什么要用springcloud seata?等等还有很多相关的，都值得我们学习。 3.进一步了解springcloud 这也是我一直在探索的事情，为什么大家要用springcloud，拆分springcloud应用这么难，这个社会上又那么少springcloud应用都挂在一个注册中心nacos上。要是真有这么多个微服务同时运行，那么我们应该如何进行服务治理？要是再复杂一点，微服务遇到不同的异构系统应该如何交互？这些都是值得我们去学习和探究的，当然这是一篇随便聊聊的文章，希望能打开你对springcloud的兴趣盒子。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77b18b4e38308fdbbe29a2756d8027da/" rel="bookmark">
			DM5加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MD5加密 概述 MD5（Message Digest Algorithm 5）是一种常用的哈希函数，能够将任意长度的消息压缩成一个128位的哈希值。它由Ronald Rivest在1991年设计，其设计目标是用来取代较早的MD4算法。
MD5算法通过多次处理分组数据来生成哈希值。在处理之前，会先对输入数据进行填充以满足长度要求。然后会对每个512位的分组进行64轮的计算，其中每轮都涉及到几个步骤，包括轮函数、置换、加法运算等。最终，经过这些计算得到的哈希值就是由16进制表示的32个字符组成的字符串，共128位。
MD5算法被广泛应用于数字签名、文件校验和、安全认证等领域。不过由于现代计算机的计算速度越来越快，MD5算法已经被证明存在一定的安全漏洞，不再适合用于一些需要高强度安全保护的场景中。
主要特点 MD5是一种消息摘要算法，具有以下主要特点：
不可逆性：对于不同的输入，其输出是唯一的，无法反向计算出原始数据。固定输出长度：无论输入长度如何，MD5算法的输出都是固定的128位（16字节）长度。高度散列性：即使输入数据只有微小的变化，也会导致输出结果的巨大变化，因此MD5算法可以保证数据完整性。高效性：对于给定的输入数据，MD5算法能够快速地计算出固定长度的输出结果。抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。弱抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。强抗碰撞：想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的。 然而，MD5已经被证明存在安全漏洞，因此在现代加密领域中，建议使用更强大的哈希函数，如SHA-256、SHA-512等。
md5的用途 MD5（Message-Digest Algorithm 5）是一种加密算法，用于将任意长度的消息转换成一个128位的摘要。它的主要应用包括以下几个方面：
数字签名：数字签名常用于证明某个文档或文件确实来自于指定的发送者，并且在传输过程中未被篡改。使用MD5可以生成签名，以验证数据的完整性。消息认证：MD5还可用于验证消息的真实性和完整性。例如，在通信过程中，可以使用MD5来检验数据是否被篡改了。密码加密：在用户注册时，可以将其密码使用MD5进行加密，并将加密后的密码存储在数据库中。这样，在用户登录时，只需要将其提供的密码再次加密并与数据库中存储的信息进行比较即可。文件校验：MD5还可用于校验文件的完整性，通过比较两个文件的MD5值，可以判断它们是否相同。在下载文件等场景中，也常用MD5来确保文件的完整性。 MD5加密算法原理及实现： 其基本原理是将任意长度的消息（input）通过一系列复杂的算法处理，产生一个固定长度的输出（digest）。这个过程是不可逆的，也就是说，无法通过摘要还原出原始的消息。
具体地，MD5算法包括以下四个步骤：
填充：如果输入的消息长度不足512位，MD5会在末尾添加0和一些填充位，使其长度为512的倍数。填充的最后64位记录消息的长度。初始化：MD5算法会初始化一个缓存区，用于存储中间计算结果。该缓存区由四个32位寄存器组成，分别用于存储上一次处理后的结果。处理：MD5算法将输入消息分成若干个512位的块，每个块进行以下四个步骤的运算： 消息扩展：将512位块扩展至624位。初始值加入：将四个32位寄存器的结果加入到624位块的前面，作为初始值。迭代压缩：对扩展后的624位块进行连续四轮迭代压缩，每轮包含16个操作，共64个操作。更新结果：将每轮迭代后的四个寄存器的结果更新到缓存区中。 输出：当所有的消息块处理完成后，MD5算法输出128位的摘要结果，即四个32位寄存器的结果按照规定顺序拼接而成。 在实现上，MD5算法可以使用各种编程语言和工具进行开发。例如，在Python中，可以使用hashlib模块提供的md5函数进行加密。下面是一个简单的示例：
import hashlib message = "Hello, world!" digest = hashlib.md5(message.encode()).hexdigest() # 将输入转为bytes类型，并计算MD5摘要 print("MD5摘要：", digest) 这段代码将字符串"Hello, world!"进行MD5加密，并输出其摘要值。
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;openssl/md5.h&gt; int main(int argc, char *argv[]) { if (argc != 2) { fprintf(stderr, "Usage: %s &lt;string&gt;\n", argv[0]); return 1; } unsigned char result[MD5_DIGEST_LENGTH]; MD5((const unsigned char*)argv[1], strlen(argv[1]), result); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77b18b4e38308fdbbe29a2756d8027da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b59ff177f67089e85430e9ec4b3f86e5/" rel="bookmark">
			Java使用Thumbnails进行文件压缩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java使用Thumbnails进行文件压缩 前言所需依赖主要代码 前言 Thumbnails是一个图片处理库，它可以对图片进行压缩、裁剪、缩放等操作。在进行文件压缩时，可以使用Thumbnails来压缩图片文件。
所需依赖 &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-mock --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-mock&lt;/artifactId&gt; &lt;version&gt;2.0.8&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 文件压缩 --&gt; &lt;dependency&gt; &lt;groupId&gt;net.coobird&lt;/groupId&gt; &lt;artifactId&gt;thumbnailator&lt;/artifactId&gt; &lt;version&gt;0.4.18&lt;/version&gt; &lt;/dependency&gt; 主要代码 /** * 文件压缩--得到File * @param tempPath 临时文件目录 * @param multipartFile 要压缩的文件 * @param width 压缩后的宽 * @param height 压缩后的高 * @return java.io.File */ public static File compressFile(String tempPath, MultipartFile multipartFile, int width, int height) throws IOException { //确保此路径下有 temp.jpg文件 File file = new File(tempPath+"/temp.jpg"); Thumbnails.of(multipartFile.getInputStream()).size(width,height).toFile(file); return file; } /** * * 文件压缩--转成MultipartFile * @param tempPath 临时文件目录 * @param multipartFile 要压缩的文件 * @param width 压缩后的宽 * @param height 压缩后的高 * @return org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b59ff177f67089e85430e9ec4b3f86e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38fe4efc100ead2f74e3fbf251b1119d/" rel="bookmark">
			安装OpenWrt到电脑，安装包选哪个？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://downloads.openwrt.org/releases/22.03.5/targets/x86/
releases发行，targets目标；
——————————————
64：具有64位功能的计算机；
generic：一般的，通用的，仅32位计算机，奔腾4及以上，i586 Linux；
legacy：遗留的，停产的，奔腾4之前的，i386 Linux；
geode：为AMD公司的geode处理器定制的；
——————————————
squashfs：一种只读压缩文件系统，该磁盘映像使用传统布局，包括一个只读分区和一个读写分区，读写分区大小受限，可恢复出厂设置；
ext4：一种linux文件系统，该磁盘映像使用单个读写ext4分区，可以扩大分区，不可恢复出厂设置；
Combined：组合的，包括bootloader、kernel、rootfs
efi：UEFI底层系统，使用GPT分区表。区别于传统的BIOS，使用MBR分区表
bootloader：引导程序
kernel：Linux内核
rootfs：openwrt根系统
——————————————
OpenWRT使用MTD来标记Flash的每个分区，方便使用名称来操作分区；
1.u-boot(mtd0)，该分区存放引导程序bootloader；
2.kernel(mtd1)，该分区存放Linux内核；
3.rootfs(mtd2)，该分区分成两部分，一部分使用SquashFS文件系统，挂载到/rom，为只读部分，包括一些基础的文件和一些默认配置文件，另一部分为mtd3；
4.rootfs_data (mtd3)，该分区使用JFFS2文件系统，为可写部分，包括可以更改的配置文件、安装的软件包等；
5.art (mtd4)，该分区用于存储wifi的校准数据；
6.firmware (mtd5)，该分区包含分区mtd1和mtd2。
资料参考一：OpenWrt 相关文件系统简介 - OpenWrt开发者之家
资料参考二：x86-64--PC设备安装openwrt - 哔哩哔哩
参考资料三：原版Openwrt在x86平台上的安装和配置以及常用插件安装 - 哔哩哔哩
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a42025ca875e82a435ebe695cc0d282e/" rel="bookmark">
			提取文件夹内所有文件名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何将一个文件夹内的所有文件名字提取出来？像这样：
只需要简单的一行代码即可：
DIR *.* /b &gt;LIST.TXT
这是计算机的DOS语言，“DIR”意为遍历，即让计算机扫描一遍该文件夹内所有文件；
“*.*”意为任意格式的文件（如果想要特定格式的文件修改后缀即可，如*.pdf）；
“/b”表示使用空格式，即只显示文件名与目录名，不显示文件的其他信息及dir命令本身应显示的所有信息；
“&gt;LSIT.txt”意为将扫描到的文件名储存到名为“LIST”的txt文件中，由于文件夹中没有这个文件，系统将会自动新建一个。
具体的应用方面，需要先新建一个txt文件，在里面输入上述一行代码，然后关闭，将后缀的“.txt”改为“.bat”，然后把这个工具放到任何一个想要扫描文件名的文件夹里，双击运行就可以了。
如果实在不想操作，可以直接去主页自取。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97c543076018e8f67da73e23386133ea/" rel="bookmark">
			浅析kubernates的pv和pvc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概要名词解释什么是Pod什么是StorgeClass静态PV和动态PVPV和PVC的生命周期 PVC ， PV和 StorageClass的关系小结 概要 最近，在看许多Kubenates的相关文章的时候，了解到了一个概念，是我之前不清楚的。–PV&amp;PVC 。那么今天就总结下这几天的收获。
在总结之前我先解释下PV和PVC是什么意思。
PV：Persistent VolumePVC：Persistent Volume Claim 【通俗字面理解】
从英文的解释上看，大致可以理解为PV就是一个持久化的卷；PVC就是PV的声明
【docker层面理解】
谈到卷，相信学习过docker的小伙伴并不陌生。Volume用于持久化数据的一种机制。那么就可以把PV看做成docker里的卷，那么PVC又怎么理解呢？就是用于统一调用管理PV的。
【官方解释】
PV :持久化卷的意思，是对底层的共享存储的一种抽象
PVC（Persistent Volume Claim）：是持久卷请求于存储需求的一种声明(PVC其实就是用户向kubernetes系统发出的一种资源需求申请。)
这里还需要明确几个职责：
存储：存储工程师维护PV： kubernetes管理员维护PVC：kubernetes用户维护 所以kubernates引入了pvc的概念后，用户就很好的能够使资源的利用率达到最高
名词解释 上面在简单的了解了什么是PV和PVC之后，接下来根据上图所示，介绍几个概念。
概述：
什么是Pod什么是StorageClass静态PV和动态PVPV和PVC的生命周期 什么是Pod Pod是kubernetes中最小的资源管理组件，Pod也是最小化运行容器化应用的资源对象。
大家都知道，docker是利用生成镜像在容器里运行的工具。
kubernates则是通过Pod承载容器进行运行的工具。
在k8s里一个Pod可以运行一个容器，也可以运行多个容器。不过最常用的是单个容器。
什么是StorgeClass 在上图种，我们可以看到Pod与我们的PVC进行绑定，换言之，Pod消耗的是PVC。然后PVC请求PV资源，而PV资源必须要是管理员事先创建好的。
这样一来就会存在一个问题，当我们的Pod请求的资源没有相应的PV去与PVC匹配的时候，这个时候就必须要管理员手动创建PV。二者之间必然会存在一定的误差，这个时候就引入了StorgeClass
可用于将存储资源定义为具有显着特性的类别（Class）而不是具体的PV，用户通过PVC直接向意向的类别发出申请，匹配由管理员事先创建的PV，或者由其按需为用户动态创建PV，这样做甚至免去了需要事先创建PV的过程。
静态PV和动态PV 在了解了StorgeClass机制后，我们就很好的理解什么是静态PV和动态PV
【静态】：
需要我们自己去手动创建，业务少的情况下可以用手动创建。
【动态】：
根据 yaml 文件里面的参数自动创建合适的 pv，业务量大或者静态 pv 无法满足需求的时候需要动态创建 pv。
PV和PVC的生命周期 其实不论是PV还是PVC，他们之间的关联关系都遵循着一个统一的生命周期：
资源创建–&gt;资源绑定–&gt;资源使用–&gt;资源释放–&gt;资源回收。这么一个生命周期。
【资源创建】
由管理员静态创建PV，或者由PVC动态创建PV。
【资源绑定】
由PVC根据Pod所需要的资源大小以及读取模式绑定PV。PV一旦被绑定，就被该Pod独占。
【资源使用】
PV一旦被PVC绑定，那么Pod就可以像使用Volume一样根据PVC的定义消耗PVC，进而PVC消耗PV
【资源释放】
用户删除PVC来释放PV
当存储资源使用完毕后，用户可以删除PVC，与该PVC绑定的PV将会被标记为“已释放”，但还不能立刻与其他的PVC进行绑定，通过之前PVC写入的数据可能还被留在存储设备上，只有在清除之后该PV才能再次使用
【资源回收】
Kubernetes根据PV设置的回收策略进行资源的回收
对于PV，管理员可以设定回收策略，用于设置与之绑定的PVC释放资源之后如何处理遗留数据的问题，只有PV的存储空间完成回收，才能供新的PVC绑定和使用
PVC ， PV和 StorageClass的关系 PVC 描述的** 是 Pod 想要使用的持久化存储的属性** 。比如存储的大小、读写权限等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97c543076018e8f67da73e23386133ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c15585845bad1456e0802420bd106a9/" rel="bookmark">
			C语言课程设计——职工信息管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		职工信息管理系统 1、目的： （1）要求学生达到熟练掌握C语言的基本知识和技能；
（2）基本掌握结构化程序设计的基本思路和方法；
（3）能够利用所学的基本知识和技能，解决简单的C语言模块化程序设计问题。
2、基本要求： （1）要求利用结构化的方法以及C的模块化编程思想来完成系统的设计；
（2）要求在设计的过程中，建立清晰的函数层次；要分析和定义各个结构体，每个结构体中要有各自的属性和对应的处理函数；要求功能分解来实现系统功能，编制相应的函数。
（3）在系统的设计中，要有清晰的界面设计，同时采用文件进行读写操作。
3、创新要求： 在基本要求达到后，可进行创新设计。 通过做职工信息管理系统，其他的管理系统同样也可以做，比如高校水电管理系统，学生成绩管理系统，图书管理系统，通讯录管理系统，天气管理系统等等，后续陆续编写。 1.实现显示功能，显示职工信息。 2.实现增加功能，增加职工信息。 3.实现删除功能，删除职工信息。 4.实现查询功能，查询职工信息。 5.实现修改功能，修改职工信息。 6.退出管理系统。 局部代码 增加 删除 修改 查找 //增加职工信息 void input() { int i; int flag;//标记工号是否已存在 char c; //指令Y?N read(); //输入数据前先将文件中原有的数据读入 do { flag = 0; printf("\t\t请输入职工的工号: \n\t\t"); scanf("%s",work[n].ID); for(i = 0 ; i &lt; n ; i ++) { if(strcmp(work[i].ID,work[n].ID) == 0) { flag = 1; break; } } if(flag) { printf("该工号已存在！\n\n"); printf("\t\t是否继续输入?(Y/N): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c15585845bad1456e0802420bd106a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58a854e35dfd0fc78ffa11d87a7eee55/" rel="bookmark">
			离线装docker和相关应用保姆级教程——以安装docker-jupyter/notebook为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 背景 有时候，客户是行政或者事业单位，对数据基础设施的安全性极高，导致必须被驻派到现场部署，而由于现场没有任何外网，下载任何东西只能靠自己的流量，或者前一天下载好来，一种比较合适的做法是将应用打包成一个docker，然后带过去现场，此教程将一步一步教你如何离线安装docker，并且如何一步一步安装你想要的相关应用。
docker的作用：免去了部署应用相关环境的困扰，并且可以部署多个应用互不影响，在一台机器上加快部署多个应用。
1 确定机器型号 你需要让现场人员运行下面这个命令：
cat /etc/os-release 根据上图可以确定机器的架构为Centos linux7，为arm指令集架构。
2 下载docker包 先去这里选择属于你的机器类型：链接: 镜像下载
根据上图，我选择的是：为了实现在这台机器上安装docker这个目标，我们必须在这个界面上下载以下组件，注意版本号一定要一致：
3 安装到docker 想办法将文件传输到该机器：如使用MobaXterm学习版、U盘拷贝等方法，具体方法步骤自行百度。下面是我将我的所有安装文件，放到该目录下然后在终端输入cd /home/hhl/docker安装文件/继续输入：sudo yum install ./*等待安装完毕即可。 4 启动docker 启动docker服务：systemctl start docker设置开机自动启动：systemctl enable docker测试：docker version，必须出现如下客户端和服务器的版本信息才算安装成功：
5 离线安装应用 这里以一个jupyter notebook环境安装为例，展示一下离线安装应用的流程。具体如何操作需要根据你自己需要的应用灵活贯通！
当你在自己公司有网络的时候，使用vm16安装一台虚拟机，需要和你在现场的机器型号一致。
然后安装好docker，直接输入sudo yum install docker-ce可以实现自动联网安装，然后按照上一步“4 启动docker”验证即可。
然后输入sudo docker search jupyter，获取下图的这个下载量最高的镜像名字“jupyter/scipy-notebook”
输入sudo docker pull jupyter/scipy-notebook，拉取这个镜像。等待拉取完毕，然后使用sudo docker images，可以发现已经存在了这个镜像：
输入 docker run -it -p 8888:8888 -v 宿主机某路径:容器中路径 容器id ，运行jupyter notebook进行测试。注意：此处的只有“宿主机某路径”需要你自己自定义——输入你虚拟机上面的某个路径，你使用notebook编程时候需要用到什么数据文件也要放到里面去，这样你用notebook的时候才能使用；容器中的路径取决于镜像说明；容器id上图有，自己填上去即可。例如本jupyter notebook：docker run -it -p 8888:8888 -v /home/notebook:/home/jovyan bcf091d6ab66
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58a854e35dfd0fc78ffa11d87a7eee55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e51d3dc605ef3950138afc52a41b4dbf/" rel="bookmark">
			Airtest笔记（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人学习笔记（整理不易，有帮助点个赞）
笔记目录：学习笔记目录_pytest和unittest、airtest_weixin_42717928的博客-CSDN博客
目录
一：简单了解
二：工具下载安装
三：了解工具使用
1）实时坐标、相对坐标
2）手机屏幕显示效果
3）兼容模式
4）代码补全
5）安卓小助手
6）生成报告
四：连接设备
1）Android
2）Windows窗口
3）模拟器连接
4）无线连接
5）IOS
五：简单熟悉
1）基于图像识别(airtest)
2）基于UI控件搜索（poco）
六：语法简单熟悉
1）touch
2)swipe
3）text
4）keyevent
5）断言
七：其他了解（注：学习的时候看到路径都是/，但我用\也可以）
1）使用airtest命令运行脚本
2）使用本地python运行脚本
3）命令参数（更多参考：Airtest — airtest 文档）
4）生成报告（更多参数：Airtest — airtest 文档）
5）airtest使用PYTHON代码生成报告
一：简单了解 Airtest：是一个跨平台的、基于图像识别的UI自动化测试框架，适用于游戏和App，支持平台有Windows、Android和iOS。
Poco：是一款基于UI控件识别的自动化测试框架，目前支持Unity3D/cocos2dx-*/Android原生app/iOS原生app/微信小程序，也可以在其他引擎中自行接入poco-sdk来使用。
AirtestIDE：跨平台的UI自动化测试编辑器，内置了Airtest和Poco的相关插件功能，能够使用它快速简单地编写Airtest和Poco代码。
二：工具下载安装 Airtest的官网：http://airtest.netease.com/
目前有Windows和Mac两个版本的客户端
下载最新版本
下载其他版本
安装python环境，我用的是3.6，当时学的时候3.8还未支持。
帮助文档：欢迎使用 - Airtest Project Docs
三：了解工具使用 1）实时坐标、相对坐标 两个都勾选就是开了相对坐标（格式是(0, 0) 到 (1, 1)），以避免跨分辨率的操作点超出屏幕的问题
2）手机屏幕显示效果 数字越大，清晰度越高。默认为800
3）兼容模式 4）代码补全 用本地的会更好
5）安卓小助手 连接设备后
快捷键 unlock 解锁、power 电源键 、snapshot 截图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e51d3dc605ef3950138afc52a41b4dbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94f85fef33b9a4bc1100e565af17fe1c/" rel="bookmark">
			关于Spring框架中StringUtils常用/易误用方法解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring 框架给我们提供的StringUtils是我们判断字符串常用的方法,
但是有很多人一直非空判断很混乱,下面做一下总结
汇总 StringUtils.isEmpty(null) = true StringUtils.isEmpty("") = true StringUtils.isEmpty(" ") = false //注意在 StringUtils 中空格作非空处理 StringUtils.isEmpty(" ") = false StringUtils.isEmpty("bob") = false StringUtils.isEmpty(" bob ") = false StringUtils.hasText(null) = false; StringUtils.hasText("") = false; StringUtils.hasText(" ") = false; StringUtils.hasText("12345") = true; StringUtils.hasText(" 12345 ") = true; StringUtils.hasLength(null) = false; StringUtils.hasLength("") = false; StringUtils.hasLength(" ") = true; StringUtils.hasLength("Hello") = true; //是否包含空白字符 StringUtils.containsWhitespace(null)=false; StringUtils.containsWhitespace("")=false; StringUtils.containsWhitespace("a")=false; StringUtils.containsWhitespace("abc")=false; StringUtils.containsWhitespace("abc")=false; StringUtils.containsWhitespace(" ")=true; StringUtils.containsWhitespace(" a"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94f85fef33b9a4bc1100e565af17fe1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c115ae284dd9b8579ca4078451889236/" rel="bookmark">
			数据结构 顺序队列的表示和实现 C语言版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#define _CRT_SECURE_NO_WARNINGS 1 #include&lt;stdio.h&gt; #include&lt;malloc.h&gt; #define ERROR 0 #define OK 1 #define MAXQSIZE 20 typedef int QElemType; /*队列元素类型，以整型为例实现*/ typedef struct { QElemType* base; //指向循环队列的存储空间 int front; //队头指针 int rear; //队尾指针 }SqQueue; //初始化队列 int InitQueue(SqQueue* Q) { Q-&gt;base = (QElemType*)malloc(MAXQSIZE * sizeof(QElemType)); if (!Q-&gt;base) return ERROR; //申请存储空间失败 Q-&gt;front = Q-&gt;rear = 0; //设置队头队尾指针 return OK; } //求队长 int QueueLength(SqQueue Q) { return(Q.rear - Q.front + MAXQSIZE) % MAXQSIZE; } //入队 int EnQueue(SqQueue* Q, QElemType e) { if ((Q-&gt;rear + 1) % MAXQSIZE == Q-&gt;front) //判断对是否已满 return ERROR; Q-&gt;base[Q-&gt;rear] = e; //元素e入队 Q-&gt;rear = (Q-&gt;rear + 1) % MAXQSIZE; //修改队尾指针 return OK; } //出队 int DeQueue(SqQueue* Q, QElemType* e) { if (Q-&gt;front == Q-&gt;rear) return ERROR; //判断队空 *e = Q-&gt;base[Q-&gt;front]; //*e返回队头元素值 Q-&gt;front = (Q-&gt;front + 1) % MAXQSIZE; //修改队头指针 return OK; } //判队空 int QueueEmpty(SqQueue* Q) { if (Q-&gt;front == Q-&gt;rear) return OK; else return ERROR; }/*QueueEmpty*/ //取队头 int GetHead(SqQueue* Q, QElemType* e) { if (Q-&gt;front == Q-&gt;rear) return ERROR; *e = Q-&gt;base[Q-&gt;front]; return OK; } //销毁队列 int DestroyQueue(SqQueue* Q) { if (Q-&gt;base) { Q-&gt;rear = Q-&gt;front = 0; free(Q-&gt;base); } return OK; } //打印队列元素 void Print(SqQueue Q) { int len = QueueLength(Q); for (int i = 0; i &lt; len; i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c115ae284dd9b8579ca4078451889236/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71245403612a3fcbd62f16223c77eb80/" rel="bookmark">
			Operating System Not Found解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在VM虚拟机中安装Linux系统（Ubuntu22.04、Kali linux等）时会碰到的一种情况：
如果你确实是在虚拟机里面的话，这种情况实际上是由于虚拟机没有遍历找到目标镜像文件，解决方案：
在左上角菜单栏中找到目标系统邮件打开上图中的设置，在设备中找到CD/DVD（SATA）选项，一般出现operating system就是连接那里使用了使用物理驱动器，需要选择使用ISO镜像，然后点击浏览，找到你的目标ISO镜像文件的绝对路径。
找到之后，在设备状态中将已连接和启动时两个选项都勾上问题就可以迎刃而解。
如图：我已成功在VMWare中安装Ubuntu22.04操作系统：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/540b11e379913cc9b896c5f849e0b29c/" rel="bookmark">
			jupyter 访问远程服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器 服务器环境 Ubuntu 20.04
软件安装和配置 安装 jupyter, jupyter-notebook
pip install jupyter jupyter-book 修改 jupyter_notebook_config.py
vi ~/.jupyter/jupyter_notebook_config.py 在文件最后，添加上下面语句
# 允许通过任意绑定服务器的ip访问 c.NotebookApp.ip = '*' # 用于访问的端口 c.NotebookApp.port = 8888 #注意这里与前面开出的容器端口要一致 # 不自动打开浏览器 c.NotebookApp.open_browser = False #允许远程访问 c.NotebookApp.allow_remote_access = True # 登录密码获得的乱序秘钥复制到‘’内 c.NotebookApp.password = u'' 启动 jupyter jupyter notebook -ip 0.0.0.0 --allow-root --port 8888 --no-browser 这样，远程服务器安装和配置就已经完成。
To access the notebook, open this file in a browser: file:///home/xxxx/.local/share/jupyter/runtime/nbserver-3325393-open.html Or copy and paste one of these URLs: http://AAAAAA:8888/?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/540b11e379913cc9b896c5f849e0b29c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a01400b70cf87aedee9645e90ab0a8c/" rel="bookmark">
			在pycharm运行chatGPT聊天机器人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.准备一个OPENAI的API_KEY。 2.在pycharm中新建一个GPT-3.5.py： import openai # 填入你的api_key openai.api_key = "" models = openai.Model.list() # 定义API参数 params = {'role': "user", "content": ''} # 定义循环 while True: # 获取用户输入 user_input = input("请输入您的消息：") if user_input.lower() == "quit": break # 更新API参数 params["content"] = user_input # 发送请求到API #response = requests.get(url, params=params) completion = openai.ChatCompletion.create(model="gpt-3.5-turbo", messages=[ params]) print(completion.choices[0].message.content) 3.首先科学上网，之后运行调试。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05b28e980e65aa6c171b527dd8e227d6/" rel="bookmark">
			java前端：删除数组中指定元素的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		删除数组中指定元素的方法 情况一：如果去除指定元素在数组中不是连续出现方法一：使用添加元素的方法.push（）;方法二：使用.splice(); 情况二：如果去除指定元素在数组中连续出现几个，不进行处理会存在删漏掉的情况方法一：使用添加元素的方法.push（）;方法二：使用.splice()，使用倒序遍历;方法三：强力推荐这个方法 情况一：如果去除指定元素在数组中不是连续出现 比如数组 arr = [8,0,11,0,2,0,66];
方法一：使用添加元素的方法.push（）; var arr = [8, 0, 11, 0, 2, 0, 66]; var newArry = []; for (var i = 0; i &lt; arr.length; i++) { if (arr[i] != 0) { newArry.push(arr[i]); } } console.log(newArry); 方法二：使用.splice(); var arr = [8, 0, 11, 0, 2, 0, 66]; for (var i = 0; i &lt; arr.length; i++) { if (arr[i] == 0) { arr.splice(i, 1); } } console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05b28e980e65aa6c171b527dd8e227d6/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/34/">«</a>
	<span class="pagination__item pagination__item--current">35/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/36/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>