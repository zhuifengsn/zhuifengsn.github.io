<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4eb89e2f8a980c2a975033628df7eb8/" rel="bookmark">
			傻瓜式git管理。全平台，全编译器通用。github desktop&#43;vscode
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言Github desktop资源地址推荐理由操作介绍打开界面介绍Github账号登录Github仓库导入 从零开始新建Gitee仓库登录或注册gitee仓库Gitee新建仓库输入仓库名，添加gitignore,Readme什么是.gitignore什么是README 新建仓库效果github desktop使用新建本地仓库推送拉取远程修改如何解决冲突什么时候会出现冲突解决方案1：更新本地仓库解决方案2，合并冲突 为什么我要推荐vscode来解决冲突 前言 git版本管理是每个程序员必学的知识，就算不打算团队合作，重要的代码保留也是非常重要的。git可视化管理工具有很多，例如github desktop,source tree,TortoiseGit。我这里推荐github desktop，github出品的软件，特点是傻瓜式操作
Github desktop 资源地址 github软件下载
推荐理由 我们小白需要的是什么？就是简单的代码管理仓库。别和我说git init ,git push ,git pull。我都不会，我顺序一敲错就报错。我就想简单推送个代码而已。什么分支，合并，拉取，提交。我只要能把代码传上去就成功！
操作介绍 软件外形
强烈建议锁定到任务栏
打开界面介绍 左侧是我们的仓库添加记录，会显示最近的仓库和其它仓库
Github账号登录 file-&gt;option-&gt;Accounts 里面进行登录
有什么用呢？就是能直接导入github上面你自己的仓库
注意：github desktop只支持github的登录,其它仓库无法登录，但是会记录你的账户信息，不用再次输入
Github仓库导入 从零开始新建Gitee仓库 因为国内的网络原因，我们连接github的网络不稳定，网速较低。所以我推荐使用gitee，国内的github来作为仓库。
登录或注册gitee仓库 gitee支持github登录
Gitee新建仓库 输入仓库名，添加gitignore,Readme 输入中文仓库名会自动转化为英文仓库名
什么是.gitignore git会对比文件，将新增，删除，修改的文件存入暂存区。但是有些文件，例如运行的临时缓存,输出文件，第三方代码。这些文件并不需要，或者可以快速安装。我们就需要新建.gitignore。
.gitignore语法介绍
但是面对纯小白，我建议直接搜，例如我用的是viusal sutido ，我就添加visual studio对应的.gitignore就行了
也可以在github desktop里面右键忽略
什么是README README.md就是项目的文档介绍，使用的是markdown语法。markdown语法是标记性语法，有一定学习成本，程序员用的比较多。因为markdown本身就是字符，通过编译器实现字体字号，标题，列表等效果。除了常用的文字处理，markdown还支持流程图，超链接，自动生成目录等功能。
markdown语法
markdown编辑器推荐: Typore
新建仓库效果 github desktop使用 新建本地仓库 复制项目url
这里我推荐新建一个空白文件夹，最好是英文，但是我英语不好，就新建中文了
点击clone
下载成功页面
本地仓库
界面介绍
推送 想要推送首先先要本地仓库进行修改，修改了才能推送。
在仓库里面新建文件test.txt，里面输入初始化test
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4eb89e2f8a980c2a975033628df7eb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15926b80713a86e719d5864638570a9b/" rel="bookmark">
			【C数据结构】顺序表的基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、顺序表的定义2、顺序表初始化3、顺序表的扩容4、顺序表的插入4.1、头插4.2、尾插4.3、按位插入 5、顺序表的删除5.1、头删5.2、尾删5.3、按位删除 6、顺序表的查找6.1、按值查找6.2、按位查找 7、求顺序表长度8、顺序表的打印9、顺序表的销毁10、完整代码10.1、SeqList.h10.2、SeqList.c10.3、test.c 1、顺序表的定义 使用结构体来构造顺序表的结构。
typedef struct SeqList { SLDataType* arr;//顺序表的数据元素存储空间 int size;//顺序表的当前数据个数 int capacity;//顺序表的最大容量 }SL; 2、顺序表初始化 使用动态分配构造一个空的顺序表，即顺序表最开始的模样。
void SLInit(SL* p)//初始化 { p-&gt;arr = (SLDataType*)malloc(sizeof(SLDataType) * Init_CAPACITY);//动态开辟一块空间给arr if (p == NULL) { perror("malloc fail"); return; } p-&gt;size = 0; p-&gt;capacity = Init_CAPACITY; } 3、顺序表的扩容 当我们的顺序表容量不够用时，这时我们需要扩容，扩容可以使顺序表变得更灵活。
void SLCheckCapacity(SL* p) { assert(p);//assert是断言操作，我们要确保指针p不为NULL。如p==NULL,assert就会将其报错，并且不在往后操作。 if (p-&gt;capacity == p-&gt;size )//扩容条件：数据元素个数==最大容量 { SLDataType* tmp = (SLDataType*)realloc(p-&gt;arr, sizeof(SLDataType) * p-&gt;capacity * 2);//再次动态开辟新的空间 //realloc（需改变内存大小的指针名，新大小） if (tmp == NULL) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15926b80713a86e719d5864638570a9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d123dd77ca5a77be5a13aeadd427a6a/" rel="bookmark">
			Latex学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、TeXLive下载与安装 1.TeXLive通过官网下载会比较慢，这里推荐通过中国科学技术大学开源软件镜像站进行下载，下载链接可点击此处（ http://mirrors.ustc.edu.cn/CTAN/systems/texlive/Images/）或者通过清华大学开源软件镜像站进行下载，下载链接可点击此处（https://mirrors.tuna.tsinghua.edu.cn/ctan/systems/texlive/Images/ ），然后选择 texlive2019.iso 下载即可。
2.texlive2019.iso下载完毕后，如果系统有DVD驱动器则双击打开ISO镜像即可（如果没有则使用解压软件把ISO镜像解压），然后双击 install-tl-advanced.bat 进行安装（以管理员身份运行，注意解压后不要把文件夹放在中文目录下）。
点击安装，就直接进行安装，进行等待，时间有点长。
至此安装完成。
安装结束后，可以在cmd中进行测试，来判断是否安装成功。
二、TeXstudio的安装 直接去官网下载（需要科学上网）。下面介绍不用科学上网，百度搜索TeXstudio，一步一步按下面操作。单击Portable (.zip)，下载安装包文件，下载完成后将文件解压到有磁盘目录。
双击解压目录中的texstudio.exe，即可打开软件。
参考链接：
LaTeX学习：Texlive 2019和TeX studio的安装及使用
LaTeX学习系列之---TeX环境的搭建（这个里面有如何注册overleaf账号）
三、记录 1.要输出%，应该输入\%
2.Latex入门篇之论文排版
3.20201207--cvpr或Springer等期刊会议论文latex排版过程中遇到的常见问题
4.Latex: 使 tabular 居中
{ \centering \begin{tabular} ... \end{tabular} } \begin{center} \begin{tabular} ... \end{tabular} \end{center} latex 如何让表格中的字体居中显示
文件头使用\usepackage{makecell}，利用tabular环境 \begin{tabular}{|c|c|} \hline \makecell[l]{left} &amp; \makecell[l]{left} \\ \hline \makecell[c]{centercentercenter} &amp; \makecell[c]{centercentercenter} \\ \hline \makecell[r]{right} &amp; \makecell[r]{right} \\ \hline \end{tabular} 5.LaTeX算法排版
四、问题 1.[LaTeX]warning: ‘h‘ float specifier changed to ‘ht‘
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d123dd77ca5a77be5a13aeadd427a6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/178b185d7ca2ac01a74dc81152b16092/" rel="bookmark">
			今天面了个字节跳动拿35K出来的测试，真是砂纸擦屁股，给我露了一手啊
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今年的春招已经结束，很多小伙伴收获不错，拿到了心仪的 offer。
各大论坛和社区里也看见不少小伙伴慷慨地分享了常见的面试题和八股文，为此咱这里也统一做一次大整理和大归类，这也算是划重点了。
俗话说得好，他山之石，可以攻玉，多看多借鉴还是有帮助的，这次腾讯也在疯狂招人！肝完这份八股文，38K 妥了！
盘里头是一整套软件测试面试必备文档PDF，看完之后直接给我老哥给跪了…这下面试稳了。
内容涵盖：包括测试理论、Linux基础、MySQL基础、Web测试、接口测试、App测试、管理工具、Python基础、Selenium相关、性能测试、LordRunner相关等… 质量非常高，需要的文末可自行领取！！
全网首发-涵盖16个技术栈
第一部分，测试理论（测试基础+需求分析+测试模型+测试计划+测试策略+测试案例等等）第二部分，Linux（ Linux基础+Linux练习题）第三部分，MySQL（基础知识+查询练习+万年学生表经典面试题汇总+数据库企业真题）第四部分，Web测试第五部分，API测试第六部分，App测试第七部分，管理工具第八部分，Python基础（Python基础+编程题+集合+函数+Python特性等等）第九部分，Selenium相关第十部分，性能测试第十一部分，LordRunner相关第十二部分，计算机网络第十三部分，组成原理第十四部分，数据结构与算法第十五部分，逻辑题第十六部分，人力资源 软件测试基础 软件测试的步骤是什么?如何录制测试脚本?应该考虑进行如何测试的测试方法怎样估计测试工作量?测试设计的问题当测试过程发生错误时，有哪几种解决办法?测试执行的问题测试评估的目标如何提高测试?C/S模式的优点和缺点B/S模式的优点和缺点… Linux grep和find的区别? grep 都有哪些用法?查看IP地址?创建和删除一个多级目录?在当前用户家目录中查找haha.txt文件?如何查询出tomcat的进程并杀掉这个进程，写出linux命令?动态查看日志文件?查看系統硬盘空间的命令?查看当前机器listen 的所有端口?… Python 统计python源代码文件中代码行数，去除注释，空行，进行输出?python调用cmd并返回结果?冒泡排序1,2,3,4 这4个数字，能组成多少个互不相同的且无重复的三位数，都是多少?请用 python 打印出 10000 以内的对称数（对称数特点：数字左右对称，如：1,2,11,121,1221 等）给定一个整数 N，和一个 0-9 的数 K，要求返回 0-N 中数字 K 出现的次数判断 101-200 之间有多少个素数，并输出所有的素数一个输入三角形的函数，输入后输出是否能组成三角形，三角形类型，请用等价类- 划分法设计测试用例… MySQL 你用的Mysql是哪个引擎，各引擎之间有什么区别?如何对查询命令进行优化?数据库的优化?Sql注入是如何产“生的，如何防止?NoSQL和关系数据库的区别?MySQL与MongoDB本质之间最基本的差别是什么Mysql数据库中怎么实现分页?Mysql数据库的操作?优化数据库?提高数据库的性能?什么是数据的完整性?… Web Web测试和app测试区别？WEB测试环境搭建和测试方法WEB测试教程WEB测试要点及基本方法Web测试页面总结… 接口测试 什么是接口如果模块请求http改为了https,测试方案应该如何制定，修改?常用HTTP 协议调试代理I具有什么?详细说明抓取HTTPS协议的设置过程?描述TCP/IP协议的层次结构，以及每一-层中重要协议jmeter,一个接口的响应结果如下:接口产生的垃圾数据如何清理依赖第三方的接口如何处理测试的数据你放在哪?什么是数据驱动，如何参数化?… 性能测试 你认为性能测试的目的是什么?做好性能测试的工作的关键是什么?服务端性能分析都从哪些角度来进行?如何理解压力测试，负裁测试以及性能测试?如何判断是否有内存泄漏及关注的指标?描述软件产“生内存泄露的原因以及检查方式。(可以结合- 种开发语言进行描述)简述什么是值传递，什么是地址传递，两者区别是什么?什么是系统瓶颈?… selenium 如何开展自动化测试框架的构建?如何设计自动化测试用例:webdriver如何开启和退出一个浏览器?什么是自动化测试框架?Selenium是什么，流行的版本有哪些?你如何从命令行启动Selenium RC?在我的机器端口4444不是免费的。我怎样才能使用另一个端口?什么是Selenium Server,它与Selenium Hub有什么不同?你如何从Selenium连接到数据库?你如何验证多个页面上存在的一个对象?XPath中使用单斜杠和双斜杠有什么区别?如何编写SeleniumIDE/ RC的用户扩展?如何在页面加载成功后验证元素的存在?你对Selenium Grid有什么了解?它提供了什么功能?如何从你的Java Class启动Selenium服务器?Selenium中有哪些验证点?什么是XPath?什么时候应该在Selenium中使用XPath? …
计算机与网络 一台计算机的IP是192.168.10.71子网掩码255.255.255.64与192.168.10.201 …请简述DNS、活动目录、域的概念。10M兆宽带是什么意思?理论下载速度是多少?什么是IP地址?OSI七层网络模型的划分?TCP和UDP有什么不同?HTTP属于哪一层的协议?HTTP和HTTPS的区别?cookies和session的区别?HTTP的get请求和post请求的区别?HTTP1.0和HTTP1.1有什么区别TCP的连接建立过程，以及断开过程?客户端使用DHCP获取IP的过程?写出某个网段的网络地址和广播地址?… 人力资源 你的测试职业发展是什么？你自认为做测试的优势在哪里？你找工作时，最重要的考虑因素为何？为什么我们应该录取你？请谈谈你个人的最大特色。一个测试工程师应具备那些素质和技能？还有问一下你是怎样保证软件质量的，也就是说你觉得怎样才能最大限度地保证软件质量？为什么选择测试这行？如果我雇用你，你能给部门带来什么贡献？… 最后 这份文档，对于想从事【软件测试】的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴我走过了最艰难的路程，希望也能帮助到你！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6f3b121eaf6aea31144cc8ae17dbfba/" rel="bookmark">
			数据库基础——9.聚合函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章来讲一下数据库中的聚合函数
目录
1. 聚合函数介绍
1.1 AVG和SUM函数
1.2 MIN和MAX函数 1.3 COUNT函数 2. GROUP BY
2.1 基本使用
2.2 使用多个列分组 2.3 GROUP BY中使用WITH ROLLUP 3. HAVING
3.1 基本使用
3.2 WHERE和HAVING的对比 4. SELECT的执行过程
4.1 查询的结构
4.2 SELECT执行顺序
4.3 SQL 的执行原理 我们上一章讲到了 SQL 单行函数。实际上 SQL 函数还有一类，叫做聚合（或聚集、分组）函数，它是对 一组数据进行汇总的函数，输入的是一组数据的集合，输出的是单个值。
1. 聚合函数介绍 什么是聚合函数？ 聚合函数作用于一组数据，并对一组数据返回一个值。
聚合函数类型： AVG() SUM() MAX() MIN() COUNT() 聚合函数语法：
注意：聚合函数不能嵌套调用。比如不能出现类似“AVG(SUM(字段名称))”形式的调用。 1.1 AVG和SUM函数 可以对数值型数据使用AVG（求均值）和 SUM（求和）函数。
例：SELECT AVG(salary), MAX(salary),MIN(salary), SUM(salary) FROM employees WHERE job_id LIKE '%REP%';
1.2 MIN和MAX函数 可以对任意数据类型的数据使用 MIN（最小值）和 MAX（最大值）函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6f3b121eaf6aea31144cc8ae17dbfba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e11831d57029eb001e2c1138beeac88/" rel="bookmark">
			css制作的漂亮的3D产品展示卡片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS制作的漂亮的3D产品展示卡片，是一种新颖而富有视觉冲击力的展示方式。它让产品得以以更加鲜明生动的方式呈现在用户面前，同时也能提高用户对产品的认知和兴趣度。以下是本款产品的几个特点：
1. 用户体验舒适：这款产品采用CSS技术，能够轻松实现3D效果，让用户用最少的操作享受最佳的视觉体验。
2. 适用范围广：无论是产品展示、产品介绍还是线上商品销售，都能够借助这款产品来更好地展示产品。
3. 支持多种设备：本产品兼容性强，不仅支持电脑端、移动端等多种设备，也能够兼容主流浏览器。
4. 自定义设置丰富：通过自定义设置，可以实现应用场景多样的产品展示效果，不仅可以设置展示方向、角度、大小等参数，还可以自定义图片展示方式、切换效果等等。
在线购物是现在的主流，而产品展示是吸引用户关注的重要因素。本款产品能够有力地帮助在线商家展示优质产品，吸引用户的兴趣和关注，提高用户购买产品的信心。顾客将更加了解产品详情，从而提升购买意愿和消费者满意度。
总之，CSS制作的漂亮的3D产品展示卡片是一项非常实用的产品，适用于多种场景。无论是网站还是在线商店，都能够很好的借助这款产品，展示和推销优质产品，吸引用户关注和购买。
效果demo
图片效果
代码分享
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;3d Card Effect&lt;/title&gt; &lt;link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500&amp;display=swap" rel="stylesheet"&gt; &lt;link rel="stylesheet" href="./style.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;div class="card"&gt; &lt;div class="sneaker"&gt; &lt;div class="circle"&gt;&lt;/div&gt; &lt;img src="./adidas.png" alt="adidas"&gt; &lt;/div&gt; &lt;div class="info"&gt; &lt;h1 class="title"&gt;Adidas ZX&lt;/h1&gt; &lt;h3&gt;FUTURE-READY TRAINERS WITH WRAPPED BOOST FOR EXCEPTION COMFORT.&lt;/h3&gt; &lt;div class="sizes"&gt; &lt;button&gt;39&lt;/button&gt; &lt;button&gt;40&lt;/button&gt; &lt;button class="active"&gt;42&lt;/button&gt; &lt;button&gt;44&lt;/button&gt; &lt;/div&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e11831d57029eb001e2c1138beeac88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8676da6bae34934247a2c4ded30be07/" rel="bookmark">
			C语言字符串分割的两种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、利用strtok()函数进行分割
函数头文件#iinclude&lt;string.h&gt;
函数原型：char *strtok(char s[], const char *delim);s[]是原字符串，delim为分隔符
返回：字符串拆分后的首地址。 “拆分”:将分割字符用 '\0’替换
特性：
1）strtok拆分字符串是直接在 原串 上操作，所以要求参1必须，可读可写（char *str = “www.baidu.com” 不行！！！）
2）第一次拆分，参1 传待拆分的原串。 第1+ 次拆分时，参1传 NULL.
void test01() { //1.使用strtok()实现分割 char str[] = "hello,world hello"; char* str1 = strtok(str, " ,"); printf("%s\n", str1); while (str1 != NULL) { str1 = strtok(NULL, " ,"); if(NULL == str1) break; printf("%s\n", str1); } } 二、利用正则表达式实现。
函数原型：int sscanf (char *str, char * format [, argument, …]);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8676da6bae34934247a2c4ded30be07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83f81bb71d94957dd0a9e555581d26ae/" rel="bookmark">
			矩阵键盘的扫描
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		矩阵键盘_按行扫描: ​​​​​​​ 需要扫描第一行,把第一行P17给GND,其余行给VCC也就是0111判断P13~10是否被按下,按下则为0,来达到扫描一行按键的作用.重复上面的操作直到所有行全部被扫描完成,就可以判断矩阵键盘中那个按键被按下了 矩阵键盘_按列扫描: ​​​​​​​ 与上面的过程基本一样,只是行列互换了而已
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b044060f6d2ce2c676681fafa80de50/" rel="bookmark">
			谷歌浏览器安装easyscholar插件 显示“该页面不能安装扩展程序”的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接拖文件进页面会显示“该页面不能安装扩展程序”（大意）的弹窗
挂上梯子重试，问题解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20e4fc129a309e9e110e3a50efa5f00e/" rel="bookmark">
			PostgreSQL中使用窗口sum()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目的，在编写sql脚本中，希望获取销售组织每个月的销售数量，和截止该月的累积销售数据
刚开始写的逻辑如下：
select calmonth,level1,level2, sum(amount) as amount sum(amount) over (PARTITION BY level1,level2 ORDER BY calmonth ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as acc_amount from B where level2 in ('东北运营中心','华南运营中心') group by calmonth,level1,level2 这个会爆以下问题：
SQL 错误 [42601]: ERROR: syntax error at or near “sum”¶ Position: 1796
最终发现原来是在使用窗口函数的使用，sum(amount) 代表的是一个分组字段，需要在sum一遍
修改后的逻辑如下：
select calmonth,level1,level2, sum(amount) as amount sum(sum(amount)) over (PARTITION BY level1,level2 ORDER BY calmonth ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as acc_amount from B where level2 in ('东北运营中心','华南运营中心') group by calmonth,level1,level2 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcc998387d5cee7e4aac1a13f7d3c2e0/" rel="bookmark">
			从零开始开发自己的chatgpt平台 之 SSE（Server-Sent Events)客户端和服务端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：如果你认为本文对你有帮助，请点一下关注，后面会有更多人工智能方面的文章。
文章目录 前言一、SSE是什么？二、SSE服务端三、客户端四、SSE双向通信总结 如果有问题可以联系我**：https://gitee.com/xiaoyuren/gpt3
前言 我们都知道chatgpt官方是流式（stream）传输，也就是打字机的效果，当我们打开openai的官方网址
使用chatgpt对话时 我们会发现他并不是使用websocket实现的。分析一下他的代码发现 他是使用SSE
技术实现的打字机效果。
一、SSE是什么？ SSE 技术（Server-Sent Events，服务器推送事件）是一种用于在 Web 应用程序中实现实时通信的技
术。与 WebSocket 技术相比，SSE 更加简单，适用于单向通信场景，可以实现服务器向客户端的实时
推送。下面来看下SSE具体是怎么实现的。
在使用 SSE 技术时，客户端通过建立与服务器的 HTTP 连接来监听事件流。当服务器有事件需要推送
时，它会以文本格式发送到客户端，客户端则可以通过监听 message 事件来接收这些事件。这种方式
可以实现类似聊天室、实时股票价格更新、天气预报等应用程序的实时通信。
在 OpenAI 的官方网站中，他们使用了 SSE 技术来实现 ChatGPT 的打字机效果。当我们在输入框中输
入文字时，ChatGPT 会实时生成相应的回复，并以文本格式通过 SSE 传输到客户端，客户端则可以将
这些回复实时展示在界面上。
通过使用 SSE 技术，OpenAI 实现了一种简单而高效的实时通信方式，使得 ChatGPT 在 Web 环境下
具有了良好的用户体验。
二、SSE服务端 代码如下（示例）：
from aiohttp import web from aiohttp_sse import sse_response async def push_messages(request): param_value = request.query.get('param') print(param_value) async with sse_response(request) as resp: await resp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcc998387d5cee7e4aac1a13f7d3c2e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61ef003f649090e6a9f530db1b9525b4/" rel="bookmark">
			拟合是什么意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在机器学习和统计学中，“拟合”（Fitting）是指使用模型来适应数据的过程。它表示通过对模型参数进行调整，使模型能够最好地拟合给定的数据集。
当我们说一个模型"拟合"了数据时，意味着该模型通过学习数据的模式和结构，能够产生与实际观测数据相匹配的预测结果。拟合的目标是使模型的预测值与实际观测值尽可能接近。
在训练过程中，模型通过优化算法（如梯度下降）调整其参数，以最小化损失函数或目标函数。通过反复迭代优化算法，模型不断调整参数，以便更好地拟合训练数据。
在回归问题中，拟合通常指的是通过拟合函数来逼近实际数据的分布趋势。模型的拟合质量可以使用各种评估指标（如均方误差、平均绝对误差等）来衡量。
在分类问题中，拟合指的是通过学习训练数据中的模式和特征，构建一个能够对新样本进行正确分类的模型。拟合的质量可以使用准确率、精确率、召回率等指标进行评估。
总而言之，"拟合"是指通过调整模型参数使其与给定数据集相匹配的过程，以获得较好的预测能力和泛化能力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7e0d26c0249e80f86b391e2c10f2859/" rel="bookmark">
			Ubuntu22.04 下使用 Conda 安装 tensorflow-gpu 版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境 同上篇。
操作系统：Ubuntu 22.04
显卡：A100
Conda 安装 tensorflow-gpu 按照 tensorflow 官网说法，需要用户源码级编译 tensorflow-gpu，这个太累了，还是偷懒使用 conda 包管理安装。
创建虚拟环境 conda create -n tensorflow python=3.8 激活虚拟环境 conda activate tensorflow 使用 conda 安装 tensorflow-gpu 不要使用 pip 安装 特别注意，不要使用 pip install --upgrade tensorflow-gpu==2.4。
至少我这里安装的版本是错误的，显示没有 libcudart.so.11.0
&gt;&gt;&gt; import tensorflow as tf 2023-05-22 21:52:56.234235: W tensorflow/stream_executor/platform/default/dso_loader.cc:60] Could not load dynamic library 'libcudart.so.11.0'; dlerror: libcudart.so.11.0: cannot open shared object file: No such file or directory 2023-05-22 21:52:56.234290: I tensorflow/stream_executor/cuda/cudart_stub.cc:29] Ignore above cudart dlerror if you do not have a GPU set up on your machine.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7e0d26c0249e80f86b391e2c10f2859/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d47477e83789291126bef440067af2f/" rel="bookmark">
			三维视觉之数字图像处理基础（六） 图像频域滤波
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像频域滤波 1 傅里叶基础 任何可积的函数都可以被展开成正弦函数的形式。
1.1 傅里叶级数 上图c称为频谱图。
三角函数系及其正交性：0，1，cos，sinx，cos2x，sin2x，...，cosnx，sinnx... 在区间[-π,π]上正交，即三角函数系中的任何两个不同的函数的乘积在[-π,π]上的积分为0。
正交性证明：
用微分的思想拆解函数（微元函数）：
设f(x)在区间[a,b]上有定义，且f(x)为微元函数，则：
即：当Δx→0时，函数f(x)在区间[a,b]上的每个点可以构成n维向量F。这时函数f(x)与向量F等价。所以：
这样看来，如有两个这样的函数f(x),g(x)，其在区间[a,b]上正交。就有：两个函数在[a,b]上每一个点的函数值的乘积之和为0。所以：
积化和差公式展开。
由于正交性，所以sinnx和coskx乘积的积分为0。
1.2 傅里叶变换 傅里叶级数的频谱是离散的，傅里叶变换是连续的
1.3 离散傅里叶变换 1.3.1 采样（Sampling） 如下图所示，低于奈奎斯特采样率时，在很函数以及图像之中均出线混淆的问题。
带限函数：对于以原点为中心的有限区间（带宽）[-T，T]外的频率值，傅里叶变换为零的函数f(t)。
1.3.2 卷积定理 对于具有连续变量t的两个连续函数f(t)和h(t)的卷积：
令f(t)、h(t)、f(t)*h(t)、f(t)·h(t)的傅里叶变换分别为F(u)、H(u)、G(u)、J(u),可以证明：
在一个域上的乘积等于另一个域上的卷积：在时域上的卷积等于频率上的乘积，在时域上的乘积等于频域的卷积。
G(u)=F(u)·H(u) J(u)=F(u)H(u)
1.3.3 狄拉克(Dirac)函数 将三种无法处理的信号转换成第四种信号：抽样定理：一个域的离散化等于另一个域的周期化
上述图像中，第一三行频域图表示了频域的离散化，对应的时域里面的图像，为周期化；第二四行的时域图，表示了时域的离散化，对应的频域图里面表现了周期化。
1.3.4 有限长傅里叶分析 对于频域内周期且连续的信号，不需要处理太多周期，只对其中的一个周期进行分析处理
如上图所示：第一幅图里面对输入信号采样，采样率为1000Hz，有两个频率（50/80）叠加噪声组合而成，第二幅图为离散的傅里叶变换之后，得到的频谱图可以有效的定位，可以明确的分辨出50和80Hz的信号。
关键词：提取频谱特征
1.4 快速傅里叶变换 1.4.1 快速傅里叶变换概念 1965年，库利和图基的快速算法几经验证，形成了一套高效运算方法，这就是现在的FFT。这种算法使DFT的运算效率得到了极大的提高，并降低了DFT运算带来的累计量化误差
FFTW世界上最快的傅里叶变换库。
Cooley-Tukey提出的FFT算法的基本思想：
将长序列DFT分解为短序列的DFT：
利用旋转因子ω的周期性、对称性、可约性：
如何将旋转因子的特性应用于FFT中：时域抽取法
1.4.2 时域抽取法 将DFT公式中的项目在时域上重新分组，这样就叫做时域抽取，除此之外还有频率抽取法。
上述推导过程可以划分成下面的图：
1.4.2 快速傅里叶变换的计算量分析 FFT计算量分析：将计算过程分解了三次，分解中的每一次进行四次的复数乘法运算，(上面第二个图)自左向右分解的第一次，两个之间进行一次运算得：N/2；乘法运算的时间远大于加法运算的时间，所以计算量分析过程只考虑乘法。
随着点数的增加，FFT相对DFT越快。
1.5 二维离散傅里叶变换 二维离散傅里叶变换主要针对图像进行：
因为傅里叶变换之后的数字是虚数，所以可以有函数的幅度谱、相位角（虚部与实部的夹角），二维的DFT满足线性、比例、平移、卷积、旋转的关系。
由于图像是离散信号，所以其对应的频谱图为周期信号。
如一维情况，二维傅里叶变换及其反变换在u方向和v方向是无限周期，会造成频谱图的低频部分位于频谱图的四周(如案例1图b所示)，为了方便观测，需将其进行中心化(案例1d所示)，即将F(u,v)变换到F(u-M/2,v-N/2)，只需要对图像乘以(-1)^(x+y)，就可以进行中心化和去中心化
实例分析1：
实例分析2：
如下面案例所示：A上图为渐变的图像，竖直方向像素值统一，其频谱图有三个明显的点，如A下图所示，中间点较为明亮对应图片的直流分量（平均值），左右两个点较暗对应正弦波的频率，B图同理，频率越高两点离中心点的距离越远。C图只保留低频部分，删除高频部分；D为保留高频部分，删除低频部分。这也就是频域滤波的原理。
实例分析3：幅度谱和相位谱的重要性（作用）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d47477e83789291126bef440067af2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90e949303bff7270277b1dcb798c7ed2/" rel="bookmark">
			Docker启动Centos7容器，并在容器中安装Docker，且开启SSH
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 启动配置centos7 容器前言启动centos7 容器进入刚刚创建的容器安装 net-tools 工具更新yum包安装docker所需要的依赖包配置yum源安装docker设置docker为开机自启测试docker 开启 ssh 服务安装所需软件启动ssh服务修改sshd配置文件设置root用户的密码使用连接工具连接刚刚的centos容器 启动配置centos7 容器 前言 此处我的需求是，在docker中启动centos7容器，并在容器中安装docker，支持ssh远程连接。如果你不需要在容器中安装docker，则可以只看第一部分的前两段，分别为: 启动centos7 容器和进入刚刚创建的容器，然后直接跳过安装docker阶段，直接去看开启 ssh 服务即可。
启动centos7 容器 [root@localhost /]# docker run -d -i -t --name centos7 --restart=always --privileged=true -p 10722:22 centos:7 /usr/sbin/init 进入刚刚创建的容器 [root@localhost /]# docker exec -it centos7 bash 安装 net-tools 工具 # 此工具是为了在容器内能查询ip地址，可不装 [root@b744f9eecda3 /]# yum install net-tools 更新yum包 [root@b744f9eecda3 /]# yum update 安装docker所需要的依赖包 [root@b744f9eecda3 /]# yum install -y yum-utils device-mapper-persistent-data lvm2 配置yum源 [root@b744f9eecda3 /]# yum-config-manager --add-repo http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90e949303bff7270277b1dcb798c7ed2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf945f01d7db46f7c607a27841c4a27c/" rel="bookmark">
			基于R语言的因子分析（附代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、因子分析数学推导 用少数几个不可观测的随机变量（因子）去描述许多随机变量之间的协方差关系。主义因子分析可以视作主成分分析的一种推广，但因子是不可观察且不必是相互正交的变量。其基本思想是：根据相关性大小将变量分组，每组变量代表一个基本结构，反映观测到的相关性。R型因子分析可以用来研究变量之间的相关关系，Q型因子分析研究样品之间的相关关系，二者知识形式上的不同数学处理上是一样的，本文以R型因子为例展开说明。
1.1正交因子模型 假定P维期望为,协方差矩阵为的随机变量X线性地依赖于少数几个不可观测的随机变量(公因子)和附加的方差源(特殊因子，误差)，那么因子模型可表作
其中为数学期望，为第i个变量在第j个因子上的载荷。
当以下条件成立时，我们称该模型为正交因子模型（F为公因子构成矩阵）：且
可推导知，
也就是Xi有m个公因子和一个特殊因子构成。公因子的贡献总和称为共同度，特殊因子的方差贡献为特殊度。注意到，在非退化的情况下模型是不唯一的（缺少约束时模型是不可识别的）。
1.2 因子模型的估计 建立因子模型首先要估计载荷矩阵和特殊方差，常用的估计方法有主成分发、主因子法和最大似然法。
1.2.1 主成分法 设为的特征值，为对应的标准正交化特征向量。这里可以对随机变量的协方差矩阵进行分解，并且假定特殊因子是可以在分解过程中忽略的。在实际中，常用样本的协方差矩阵来代替，考虑到变量的量纲差别，往往需要将数据标准化，这样求得的样本方差-协方差矩阵就是原来数据的相关系数矩阵R，并对R进行以上操作。而后根据各特征值的占比和阈值进行比较取定公因子。
1.2.2 主因子法 作R的约相关矩阵并对此进行估计，具体过程不在文本赘述，其和主成分法的不同是：特殊方差汗的估计在不同步骤进行。如果我们希望求得拟合程度更高的节，可以采用迭代的方法，即将上一步中的特殊方差作为下一步的初始估计。
1.2.3极大似然法 在模型假定下计算似然函数，记其极大似然估计为
注意对极大似然解，当因子数增加时，愿挨银子的估计载荷以及对x的贡献度发生改变，区别于前两种方法。
1.3因子正交旋转 满足方差结构的因子模型并不唯一，模型的公因子和载荷矩阵不唯一，并且公因子和因子载荷矩阵作正交变换后并不改变公共度，乘因子载荷的正交变换和伴随的因子正交变换为因子正交旋转，从而得到更简单的结构。
1.4因子得分 因子得分即对公因子的估计
1.4.1加权最小二乘法 先将因子模型改写为后经过变化并由最小二乘法可得的估计。是集中通常用它们的某种估计来代替。
1.4.2回归法 在正交因子模型中假设服从元正态分布，用回归预测的方法估计。
1.4.3综合因子得分 以各因子的方差贡献率为权重，由各因子的下行组合得到综合评价指标函数：
二、案例分析 ####导入数据 安装相应库############### setwd('C:/Users/myq20170530/data') data&lt;-read.csv('eg6.1.csv',header = 1) data&lt;-scale(data)##数据标准化处理 cor(data) ##观察各个变量之间的相关程度 install.packages('psych')##笔者mvstats库无法下载故而用psych代替 library('psych') install.packages('GPArotation') library('GPArotation') ####用主成分分析和极大似然法进行因子分析########## fa(data,nfactors=2,fm='ml',rotate = 'none') &gt;Factor Analysis using method = ml Call: fa(r = data, nfactors = 2, rotate = "none", fm = "ml") Standardized loadings (pattern matrix) based upon correlation matrix ML1 ML2 h2 u2 com x1 -0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf945f01d7db46f7c607a27841c4a27c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7826bde7301c57552ca190cbccaa05da/" rel="bookmark">
			PROJ.4学习--(1)地图投影
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
PROJ是由大量的基础投影库构成。这里主要讨论学习PROJ库的相关参数。
这里大部分是讲如何将3D坐标系投影到2D平面上。投影时，涉及到基准线，单位，比例英子，偏移量，轴转换等。
很多实际操作中却涉及到3D坐标系转换为其他3D坐标系（下一篇更新）。
参数列表
下面是可以应用于大多数坐标系定义的PROJ参数列表。此表不尝试描述特定于特定投影类型的参数。
参数描述 +a 椭球体长半轴长度 +axis 轴防线 +b 椭球体短半轴长度 +ellps 椭球体名称，在cmd中输入：proj -le 查看支持哪些椭球体 +k 比例系数（比例因子），旧版本，不赞成使用 +k_0 比例系数（比例因子） +lat_0 维度起点 +lon_0 中央经线 +lon_wrap 中央经线的包装参数（详见下面的说明） +no_defs 不要使用proj库中的缺省定义文件。
在linux中路径为：/usr/share/proj/proj_def.dat
windows中为安装路径下的：E:\SvnWorkspace\LY_WEB_GIS\branches\Documents\ms4w-mapserver-for-wimdows\release-1911-x64-gdal-2-3-3-mapserver-7-2-1\bin\proj\SHARE\proj_def.dat
标红处是我安装MapServer是自带安装Proj的路径
+over 允许经度输出在-180到180范围之外，禁用wrapping(详见下面的说明) +pm 备用本初子午线(通常是一个城市名称，见下文) +proj 投影名称，在cmd中输入：proj -l 查看数据支持 +units 水平单位，meters（米）、 US survey feet, etc（英尺等 us-ft）. +vunits 垂直单位 +x_0 东（伪）偏移量 +y_0 北（伪）偏移量 units
可以使用+units关键字指定水平单位，该关键字具有单位的符号名称(如：+units=us-ft)。另外换算单位米可以用+to_meter关键字（如：美国一英尺为0.304800609601219米）。
在cmd中输入： cs2cs -lu 或者 proj -lu 查看PROJ支持的单位。
下面来了解一下 +to_meter 关键字的使用
#在cmd中输入： cs2cs +proj=merc +lat_ts=56.5 +ellps=GRS80 +to +proj=utm +zone=32 +units=km #再输入参数 1699741.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7826bde7301c57552ca190cbccaa05da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7de17248dcdc61b082e273891638fb80/" rel="bookmark">
			SQL优化15个技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 避免使用 select *
写sql语句时，为了方便，喜欢直接使用 select *，一次性查出表中所有列的数据。
反例：
select * from user where id=1; 在实际业务场景中，可能我们真正需要使用的只有其中一两列。查了很多数据，但是不用，白白浪费了数据库资源，比如：内存或者cpu。
此外，多查出来的数据，通过网络IO传输的过程中，也会增加数据传输的时间。
还有一个最重要的问题是： select * 不会走覆盖索引，会出现大量的 回表 操作，而从导致查询sql的性能很低。
那么，如何优化呢？
正例：
select name, age from user where id = 1; sql语句查询时，只查需要用到的列，多余的列根本无需查出来。
2、用 union all 代替 union
我们都知道sql语句使用 union 关键字后，可以获取排重后的数据。
而如果使用 union all 关键字，可以获取所有数据，包含重复的数据。
反例：
(select * from user where id=1) union (select * from user where id=2); 排重的过程需要遍历、排序和比较，它更耗时，更消耗 cpu资源。
所以如果能用 union all 的时候，尽量不用union。
正例：
(select * from user where id=1) union all (select * from user where id=2); 除非是有些特殊的场景，比如 union all 之后，结果集中出现了重复数据，而业务场景中是不允许产生重复数据的，这时可以使用 union。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7de17248dcdc61b082e273891638fb80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1d0921c2f943845334413c25202b758/" rel="bookmark">
			为什么spring要使用三级缓存？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题 spring使用三级缓存处理了循环依赖问题，并且第三级缓存中的对象工厂getObject()的时候会牵扯到AOP，一般来说，getObject()之后就会放到二级缓存中。
那么，为什么不能去掉三级缓存，每次都创建好代理版本放到二级缓存中完事？
AOP代理的两个时机 getObject()的时候在SmartInstanitiaionAwareBeanPostProcessor里面代理初始化的时候使用BeanPostProcessor的回调代理 解释 getObject会被调到的情况，只能是存在循环依赖的情况：
即，A工厂放入三级缓存，A准备属性注入B，B工厂放入三级缓存，B raw bean准备属性注入A，找到三级缓存中的A工厂，调用getObject。
工厂其实包括两个东西，一个是raw bean，一个是lambda表达式，里面会有个特殊的postProcessor进行AOP代理。
如果不存在循环依赖，则A的属性赋值过程中都不会间接调用到getObject方法，那么就往下走去到初始化阶段里面使用BeanPostProcessor的回调进行动态代理。
不存在循环依赖的情况下，A在缓存中位置的变化是：先进入三级缓存，然后装配B，接着进入初始化阶段，之后直接进入一级缓存。存在循环依赖的情况下，A在缓存中位置的变化是：先进入三级缓存，然后装配B，接着被B调用工厂方法，提前AOP，进入二级缓存，之后再装配一级缓存中的B，自身完整赋值好了，就进入一级缓存。 不知道从哪里看见的，说是Spring设计初衷就是要Bean完全属性赋值完成之后再进行AOP(对应生命周期是初始化阶段)，因此，初始化阶段会有BeanPostProcessor的回调方法进行AOP代理，此时的target都是赋值完整的target。
但是在存在循环依赖的时候，这个设计初衷就被打破了。
举个例子，仅考虑2个对象AB的相互依赖，AB都有代理逻辑。
实例化后的『A原始Bean』装配B =&gt; 实例化后的『B原始Bean』装配A，那么这个时候装配的A必须进行代理，否则装配的就是原始A了！所以B调用了A工厂的getObject提前进行代理，然后注入到B中，B就可以顺利属性赋值完成，然后进入初始化阶段，B在初始化阶段进行AOP。
既然A提前代理了，当A到初始化阶段再次碰到代理逻辑怎么办？
实际上会判断下是否已经提前代理过了，如果代理过了，初始化阶段的代理逻辑就不做了，用之前的代理Bean作为结果。
总结 一级缓存：代理过 &amp; 属性赋值 完成的Bean （注意，仅指自身属性赋值完整，属性的属性有没有赋值不管）
二级缓存：提前代理好了 &amp; 属性未完全赋值
三级缓存：对象工厂，包含提前代理的逻辑
能否把二三级合并？每次都提前判断是否代理再放到二级缓存中？
可以，但是这样做彻底违背了Spring初衷，因为这样做的话，所有代理都提前到了初始化阶段前面做。能否全部合并？每次都代理好放入一级缓存中？
可以，但是第一：违反了Spring属性赋值后代理的初衷，第二：第一级缓存中不仅存在属性赋值完成的，还存在属性未完整赋值的，属于是结构比较混乱，为了逻辑清晰，Spring选择把半成品和完成品分开。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc3986e4888d5798aeaa1a9e855316f4/" rel="bookmark">
			三维视觉之数字图像处理基础（五） 图像几何变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像几何变换 1 图像几何变换模型 刚性变换有三个参数：旋转角度θ、平移向量（tx，ty），刚性变换不改变图像内部结构的长度和角度。
相似变换有四个参数：旋转角度θ、平移向量（tx，ty）、尺度变换参数s。相当于图像的旋转平移缩放变换组合。
仿射变换有六个参数：线性变换参数abcd，平移向量（tx，ty）。会改变目标结构的长度，也会改变角度，但是原有结构里面平行关系的结构会的到保持，例如上图平行四边形，平行的边依然保持平行。
仿射变换参数求解：
例子：
投影变换（透视变换）：有8个自由度，经常应用于图像拼接，用相机拍摄后的图片就存在透视变换。
2 图像插值 为什么需要图像插值？：图像旋转或者缩放之后，对于坐标位置(x,y),x、y不是整数，如何获取(x,y)处的图像灰度值？
2.1 一维线性插值 2.2 双线性插值 在水平和竖直方向做两次线性插值。
上图，从左向右为：6464像素的图像、最近邻差值后512512像素的图像、双线性插值512*512像素的图像
3 应用举例 3.1 无人机图像拼接 图像拼接可以将无人机获得的多张图像拼接成视场更大的图像，以获得更好的整体感知效果。随着待拼接的图像数量的增加，普通的基于两两配准的图像拼接方法得到的拼接结果变形会越来越严重（几何配准的累计误差、场景非平面等因素）。
为了得到好的拼接结果，通常需要引入GPS/IMU、GCP等信息获取相机姿态；或者利用卫星图像作为基准图像，把拼接图像与参考图像配准后，叠加在参考图像上。
如果这些信息都不可用，对于成百上千的待拼接图像，如何获得良好的拼接结果？
图像变换为投影变换，拼接目标函数的数据项表示配准的特征点之间的距离（越小越好）；正则项为了保持图像变换尽量为刚性变换的模型，所以g和h要尽量为0，这样abcd趋向一个刚性变换(整个变换矩阵趋向于一个旋转矩阵)，由旋转矩阵可得：正则项的前三项表示相互正交且模为1。
拼接流程：
1、对多幅输入的图像进行特征提取和匹配，上图用到sift特征提取。
2、初始化特征变换，初始化为了效率，采用仿射变形参数
3、全局优化，
4、特征融合，消除拼接缝
随机采样一致性算法（RANSAC）
模型参数拟合时，数据中经常会有噪声。
RANSAC算法思想：
进行K次采样，根据模型获得的支持度参数，将点进行分类：
此时的模型，获得了最大的支持度，支持这个模型的点称为“内点”。用所有的内点，重新拟合一个参数，作为最终的拟合参数。
RANSAC算法是一个鲁棒的参数拟合算法
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/35/">«</a>
	<span class="pagination__item pagination__item--current">36/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/37/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>