<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b39fdbc9ed31faf54019601005ce234/" rel="bookmark">
			ESP32 使用 OLED
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（后续更新，文中用到的工具见原文：https://blog.iyatt.com/?p=11915）
1 环境 1.1 硬件 ESP32-WROOM-32
128x64 OLED（IIC）
1.2 软件 Arduino IDE 2.2.1
esp32 2.0.14（开发板）
Adafruit_SSD1306 2.5.7 ：https://github.com/adafruit/Adafruit_SSD1306 （依赖库：
Adafruit_BusIO 1.14.5 ：https://github.com/adafruit/Adafruit_BusIO
Adafruit-GFX-Library 1.11.9 ：https://github.com/adafruit/Adafruit-GFX-Library
）
注：如果是在 Arduino IDE 中安装，会自动提示依赖库安装，如果是从 GitHub 下载离线包，就要手动分别安装。
2 接线 2.1 默认 使用 Wire 库时，ESP32 的默认引脚对应（下面探索就使用这个默认的）
21 - SDA22 - SCL 2.2 自定义 方法一
Wire.setPins(int sda, int scl); Wire.begin(); 方法二
bool begin(int sda, int scl, uint32_t frequency=0); 3 探索 3.1 确定 IIC 地址 SSD1306 驱动的 OLED 的 IIC 地址要么是 0x3D，要么就是 0x3C，其实两选一试也行，这里提供了一份代码，会进行遍历测试可用的设备的地址。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b39fdbc9ed31faf54019601005ce234/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f22d805b09b7d07e0ca824c967ab92e/" rel="bookmark">
			Ubuntu系统下使用apt-get安装Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下Ubuntu20.04 64位系统下使用apt-get安装Redis
首先检查一下系统是否安装过redis
whereis redis myw@myw-K84HR:~$ whereis redis redis: myw@myw-K84HR:~$ 更新软件包
sudo apt-get update -y 安装redis
sudo apt-get install redis-server -y myw@myw-K84HR:~$ sudo apt-get update -y 命中:1 http://security.ubuntu.com/ubuntu jammy-security InRelease 命中:2 http://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy InRelease 命中:3 http://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-updates InRelease 命中:4 http://mirrors.tuna.tsinghua.edu.cn/ubuntu jammy-backports InRelease 正在读取软件包列表... 完成 myw@myw-K84HR:~$ sudo apt-get install redis-server 正在读取软件包列表... 完成 正在分析软件包的依赖关系树... 完成 正在读取状态信息... 完成 将会同时安装下列软件： libjemalloc2 liblua5.1-0 liblzf1 lua-bitop lua-cjson redis-tools 建议安装： ruby-redis 下列【新】软件包将被安装： libjemalloc2 liblua5.1-0 liblzf1 lua-bitop lua-cjson redis-server redis-tools 升级了 0 个软件包，新安装了 7 个软件包，要卸载 0 个软件包，有 49 个软件包未被升级。 需要下载 1,273 kB 的归档。 解压缩后会消耗 5,725 kB 的额外空间。 您希望继续执行吗？ [Y/n] y 获取:1 http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f22d805b09b7d07e0ca824c967ab92e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d87b3bb931bf3c432af927332a342f1d/" rel="bookmark">
			深度学习中的epoch与batch_size关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Epoch（周期）：
Epoch 是指整个训练数据集被神经网络完整地遍历一次的次数。
在每个 epoch 中，模型会一次又一次地使用数据集中的不同样本进行训练，以更新模型的权重。
通常，一个 epoch 包含多个迭代（iterations），每个迭代是一次权重更新的过程。
训练多个 epoch 的目的是让模型不断地学习，提高性能，直到收敛到最佳性能或达到停止条件。
二、Batch Size（批大小）：
Batch size 指的是每次模型权重更新时所使用的样本数。
通过将训练数据分成小批次，可以实现并行计算，提高训练效率。
较大的 batch size 可能会加速训练，但可能需要更多内存和计算资源。较小的 batch size 可能更适合小型数据集或资源受限的情况。
常见的 batch size 值通常是 32、64、128 等。
三、如何理解它们的关系：
在训练过程中，每个 epoch 包含多个 batch，而 batch size 决定了每个 batch 中包含多少样本。
在每个 epoch 开始时，数据集会被随机划分为多个 batch，然后模型使用这些 batch 逐一进行前向传播和反向传播，从而更新权重。
一次 epoch 完成后，数据集会被重新随机划分为新的 batch，这个过程会重复多次，直到完成指定数量的 epoch 或达到停止条件。
总之，epoch 控制了整个训练的迭代次数，而 batch size 决定了每次迭代中处理的样本数量。这两个参数的选择取决于你的任务和资源，通常需要进行调优以获得最佳性能。
————————————————
版权声明：本文为CSDN博主「码农研究僧」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_47872288/article/details/133925235
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7169390ecb0833c65cc3c6578b00a403/" rel="bookmark">
			非常全面的12种js数组去重的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 数组去重，可以说是一个比较常见的面试题，今天来盘点一下都有哪些方法可以实现数组去重。
方法1、双重for循环 这是一个最笨的方法，双重循环。
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
var arr = [1, 2, 3,4 ,5,6, 4, 3, 8, 1]
// 数组去重：
// 方法1： 双重for 循环
function newArrFn (arr) {
// 创建一个新的空数组
let newArr = []
for(let i = 0;i&lt;arr.length;i++){
// 设置一个开关，如果是true，就存进去，不是就不存
let flag = true
for(let j = 0;j&lt;newArr.length;j++){
// 原数组和新数组作比较，如果一致，开关变为 false
arr[i] === newArr[j] ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7169390ecb0833c65cc3c6578b00a403/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c120a8f5f66b4cc714ef2f845a2b895c/" rel="bookmark">
			校园教务管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学年论文（课程设计）
题目： 信息管理系统 校园教务管理系统
摘要：数据库技术是现代信息科学与技术的重要组成部分，是计算机数据处理与信息管理系统的核心，随着计算机技术的发展，数据库技术已经成为网络信息化的基础。本教务管理系统就是让教务人员从繁重的工作中解放出来，使他们在使用一个软件之后能极容易的对所有教务工作进行管理。
Key words:数据库；java；教务管理；图形化设计界面
目　录
1　功能需求.......................................1
1.1　课题介绍......................................1
1.2　工具与知识.............．．．．．.................．．．1
1.3　功能任务.............．．．．．.................．．．1
2　概要设计.............．．．．．．．．．．．.............2
2.1 流程图.............．．．．．．．．．．．．．．．．...．．．．2
3　详细设计与实验.............．．．．．．．．．．．.........4
3.1　java文件定义及功能 ．．．．．．．．．．．．．．4
3.2主界面描述．．．．．．．．．．．．．．．．．．．．．4
3.2.1登陆界面．．．．．．．．．．．．．．．．．．．．．4
3.2.2学生端界面．．．．．．．．．．．．．．．．．．．．4
3.2.3 教师端界面．．．．．．．．．．．．．．．．．．．．．．10
3.2.4 管理员界面．．．．．．．．．．．．．．．．．．．．．．12
4　测试结果..................．．．．．．．．．．．24
4.1 登录界面测试......................．．．．．．．．．．．．．24
4.2学生界面测试......................．．．．．．．．．．25
4.3教师界面测试......................．．．．．．．．．．28
4.4 管理员界面测试......................．．．．．．．．．．30
5　总结...................．．．．．．．．．．．．．．．．．．．．．36
参考文献....................．．．．．．．．．．．．．．．．．．．．37
附录....................．．．．．．．．．．．．．．．．．38 1 功能需求 课题介绍 在现代，高科技的飞跃发展，人们工作习惯的改变和电脑的普及，怎样提高工作效率是人们首先考虑的问题，教务管理是一个非常繁琐与复杂的一项工作，对于学校而言，应该运用一些本地资源提高管理力度，提高工作效率。
教务管理系统是一个复杂的计算机网络信息系统，满足各类高校对现在和将来对信息资源采集，存储，处理，组织，管理和利用的需求，实现信息资源的集中管理和统一调度。为信息交流、教务管理提供一个便捷的电子化手段。
工具与知识 工具：MySQL数据库，IntelliJ IDEA 。
MySQL是一个关系型数据库管理系统，关联数据库将数据库保存在不同的表中，而不是把所有数据放在一个大仓库中，增加了速度和灵活性。MySQL所使用的SQL语言是访问数据库的最常用标准化语言。
IDEA，全称IntelliJ IDEA，是 Java 语言的集成开发环境， IDEA 在业界被公认为是最好的 java 开发工具之一，一旦用上了就会上瘾。尤其在智能代码助手、代码自动提示、重构、 J2EE 支持、 Ant、 JUnit、 CVS 整合、代码审查、创新的 GUI 设计等方面的功能可以说是超常的。强大的整合能力。比如： Git、 Maven、 Spring 等 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c120a8f5f66b4cc714ef2f845a2b895c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ad024d6710b062e70e48263492627b2/" rel="bookmark">
			springboot整合shiro实现认证和授权功能（非常详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Shiro和Spring Security应该是我们比较常用的权限框架了，这篇文章教大家怎么通过springboot整合shiro从零开始搭建一个包含权限控制的后台管理系统。
目录
第一步：创建springboot项目
第二步：添加maven的依赖
第三步：修改配置文件
第四步：创建数据库表
第五步：创建表user对应类
第六步：创建UserRealm
第七步：创建Shiro配置类
第八步：实现登录功能
控制器层
业务层
UserRealm
持久层
第九步：测试登录功能
login.html
login.js
home.html
ShiroConfig.java
第十步：实现授权功能
UserRealm.java
UserController.java
/html/home.html 自定义过滤器实现鉴权
ShiroConfig.java
第十一步：测试鉴权功能
第一步：创建springboot项目 通过IntelliJ IDEA创建一个springboot项目，这里的项目就命名为springboot-shiro
第二步：添加maven的依赖 修改pom.xml，添加相关的maven依赖
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.9&lt;/version&gt; &lt;relativePath /&gt; &lt;/parent&gt; &lt;groupId&gt;cn.edu.sgu.www&lt;/groupId&gt; &lt;artifactId&gt;springboot-shiro&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot-shiro&lt;/name&gt; &lt;description&gt;Spring Boot整合Shiro权限认证框架&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;shiro.version&gt;1.3.2&lt;/shiro.version&gt; &lt;mysql.version&gt;8.0.28&lt;/mysql.version&gt; &lt;druid.version&gt;1.1.21&lt;/druid.version&gt; &lt;lombok.version&gt;1.18.22&lt;/lombok.version&gt; &lt;fastjson.version&gt;2.0.8&lt;/fastjson.version&gt; &lt;mybatis.version&gt;2.2.2&lt;/mybatis.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ad024d6710b062e70e48263492627b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6494646d6a8afb1932051266b180ebd/" rel="bookmark">
			OpenCV介绍及安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.OpenCV简介
2.OpenCV安装
3.检查OpenCV是否安装成功
4.OpenCV模块
5.学习技巧
1.OpenCV简介 OpenCV（Open Source Computer Vision Library）是一个基于开源发行的跨平台计算机视觉库，主要用于图像处理、计算机视觉和机器学习等领域，实现了图像处理和计算机视觉方面的很多通用算法，已成为计算机视觉领域最有力的研究工具。在这里我们要区分图像处理和计算机视觉两个概念：图像处理侧重于“处理”图像–如增强，还原，去噪，分割等等；而计算机视觉重点在于使用计算机来模拟人的视觉，因此模拟才是计算机视觉领域的最终目标。
OpenCV-Python库提供了大量的函数和类，用于图像加载、保存、显示、绘制、变换、滤波、特征检测、视频处理等。它支持多种图像格式，包括常见的JPEG、PNG、BMP等，也支持通过摄像头或视频文件获取实时视频流。OpenCV-Python还提供了一些机器学习算法的实现，如人脸识别、目标检测、图像分类等。
OpenCV用C++语言编写，它具有C ++，Python，Java和MATLAB接口，并支持Windows，Linux，Android和Mac OS， 如今也提供对于C#、Ch、Ruby，GO的支持。
OpenCV最初于1999年由Intel公司的俄罗斯一团队发起建立，并于2000年以BSD许可证的形式发布，如今由Willow Garage公司提供支持。到目前（2023年9月）最新是4.x版本。
2.OpenCV安装 因为本文学习主要是使用OpenCV提供的python接口，所以这里也是仅介绍python版OpenCV的安装。python安装opencv，需要使用以下安装命令：
#安装OpenCV的python库： pip install opencv-python #安装指定的OpenCV版本： pip install opencv-python==3.4.2.16 #使用国内镜像源安装： pip install opencv-python==3.4.2.16 -i https://pypi.tuna.tsinghua.edu.cn/simple 说明：
opencv-python表示python版的opencv接口模块，使得开发者可以使用Python进行图像处理和计算机视觉的开发工作。。 opencv-python需要依赖numpy库，pip install numpy。 3.安装指定版本opencv-python==3.4.2.16，因为此版本之后，一些经典算法被申请了专利，做了很大限制。
4.python版本：建议用python 3.7或者3.6版本，高于3.7可能无法使用安装opencv-python==3.4.2.16版本。
5.如果要用到SIFT和SURF等进行特征提取时，还需要安装：
pip install opencv-contrib-python==3.4.2.16 3.检查OpenCV是否安装成功 import cv2 # 导入图片 img = cv2.imread('close.png') cv2.imshow('image', img) # 按任意键，关闭弹框 cv2.waitKey(0) cv2.destroyAllWindows() 使用该代码读取一张图像，能正确显示即表示安装成功。 4.OpenCV模块 OpenCV有很多模块，最基本的模块core、hightgui、imgproc。模块分布如下所示：
core模块：实现了最核心的数据结构及基本算法，如绘图函数、数组操作相关函数等。
highgui模块：实现了视频与图像的提取、显示和存储等。
imgproc模块：实现了图像处理的基础方法，包括图像滤波、图像的几何变换、平滑、阈值分割、形态学处理、边缘检测、目标检测、运动分析和对象跟踪等。
进阶高层次的方向，opencv也有相关的模块：
feature2d模块：用于提取图像特征以及特征匹配，nonfree（非免费即收费）模块实现了一些专利算法，如sift特征。而opencv-python==3.4.2.16版本，都是免费模块，没有收费模块。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6494646d6a8afb1932051266b180ebd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d6ba99beb8db6056feb9fc3cc62d30f/" rel="bookmark">
			计算机组成原理(全)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第一章 概述
1.1 计算机系统结构
1.1.1 冯诺依曼（普林斯顿）结构
1.1.2 现代计算机
1.2 计算机各硬件组成
1.3 计算机硬件指标
第二章 总线
2.1 总线分类
2.1.1 片内总线
2.1.2 系统总线
2.1.3 通信总线
2.2 总线结构
2.2.1 单总线结构
2.2.2 双总线结构
2.2.3 三总线结构 2.2.4 多总线结构
2.3 总线判优控制***
2.3.1 链式查询
2.3.2 计数器定时查询
2.3.3 独立请求方式
2.4 总线通信控制
2.4.1 同步通信
2.4.2 异步通信
2.4.3 半同步通信***
2.4.4 分离式通信***
第三章 存储系统
3.1 主存储器
3.1.1 存储器分类
3.1.2 译码驱动方式
3.1.3 随机存储器与只读存储器
3.1.4 动态RAM刷新
3.2 存储器与CPU的连接
3.2.1 位扩展
3.2.2 字扩展
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d6ba99beb8db6056feb9fc3cc62d30f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fc630fd43d7171608872fc884907a04/" rel="bookmark">
			kali liunx安装后的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更新系统和软件包
1 sudo apt update 2 sudo apt upgrade 修改软件源
1 sudo nano /etc/apt/sources.list 将原有的内容替换以下内容
1 deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib 2 deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib 3 contrib non-free 更新系统缓存
1 sudo apt update 2 sudo apt upgrade 安装更新后所需的软件
1 sudo apt install kali-grant-ed 1 sudo apt full-upgrade 更新系统内核
1 sudo apt install liunx-heoders-$(uname -r) 安装常用工具
1 sudo apt install git python3 python3-pip 安装网络工具
1 sudo apt install wireshork mmap 安装开发工具
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fc630fd43d7171608872fc884907a04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bb148617d47eaf868b0bad7af1a00a1/" rel="bookmark">
			迷你主机安装openwrt软路由系统（附启动盘制作教程&#43;ISO、IMG镜像文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前在迷你主机上刷了一个openwrt的软路由，安装过程分享给大家，镜像文件在文章末尾~
一般需要做软路由系统的机器，是需要至少两个网口的，一个做wan口，一个做lan口
由于其他因素，不能直接将openwrt直接安装在硬盘里，所以先将openwrt软路由这个系统安装在U盘上面，然后再将镜像文件写在本地的硬盘中
环境准备：
物理机一台（干净的环境）
一个U盘（做启动盘使用）
openwrt的镜像文件（.img后缀的文件）
1、先去下载一个balenaEtcher写盘工具，直接点击Download下载，然后选择下载的位置，这个.exe的运行程序是可以直接使用的，不需要安装
2、打开写盘工具，先选择openwrt.img的镜像文件
3、 接下来选择U盘的盘符，来制作启动U盘，这个盘符一定要确认清楚，千万不能错
4、选择完镜像和盘符后，就直接制作启动了
这里要等几分钟，正在制作启动盘 如果 这两个都是绿色的，说明写盘成功（如果有红色的，需要排查一下是什么问题导致的报错）
写成功后，文件资源管理器弹出需要格式化一下这个U盘，直接点击取消就好了 ，到这一步，启动U盘就制作成功了
5、接下来开始安装操作openwrt操作系统
一般情况下，如果机器的本地硬盘没有操作系统，那插上了启动盘后会默认从启动U盘来启动，当然也有一些特殊情况，需要调整BIOS的启动顺序，将第一启动项调整成自己的U盘启动盘，不通品牌、配置的机器进入BIOS的按键不一样，根据自己的实际情况在百度查一下
如下图：启动盘的启动项排在第二个，将它调整成第一个就好了#1的启动项调成AI MASS Strong
然后按F10保存并退出，系统就默认从启动盘启动了
6、当从启动盘启动后，安装完系统，到这里需要按几下回车，直接就可以进入系统了
不同的系统镜像、固件，默认的ip地址都不台一样，根据自己的网络环境来更改IP地址
vim /etc/'config/network #更改网卡的配置文件
找到lan口设置，将192.168.1.1改成自己网络环境内的IP地址，我这边是100的网段，改为192.168.100.189
ifup etho #更新网络配置
然后使用局域网内的电脑ping一下openwrt，或使用openwrt系统ping一下网关，看看是否正常两边都可以通，网络环境是正常的，接下来直接登录浏览器，通过Web界面来管理
默认用户名：root
默认密码：password
由于系统是在U盘中运行的，也就是说把U盘拔掉，系统就崩掉了，所以需要将U盘的系统写入到本地的硬盘中
可以直接将img文件通过Web界面上传到系统中
也可以通过scp的方式来上传
举例：
dd if=/dev/zero of=/dev/sda #格式化磁盘
dd if=/cdrom/op.img of=/dev/sda #将img文件写入到硬盘中
/cdrom/op.img是镜像的位置（如果你将镜像上传在了/opt/openwrt.img这里就改为/opt/openwrt.img）
确定完成以后，重启系统将U盘拔出即可
再次启动系统，系统就是在本地的硬盘中运行了，你学废了吗？？？
iso+img镜像文件--永久有效
链接：https://pan.baidu.com/s/1h71rXETVwjcraMbnXZdZtw 提取码：AK47
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d74956d3cba038a010d97cf39990d30/" rel="bookmark">
			面试之 mysql 、Redis基础笔记 笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础篇：MYSQL总结_helloworld-CSDN博客
目录
ACID 并发事务带来的问题：
事务的隔离级别：
索引
1、myIsam
2、innoDB
为什么inonDB必须要创建索引、且整形自增主键：
sql分析工具：
一、expalin
单表索引优化：
两表索引优化：
三表索引优化： 什么是覆盖索引：
索引失效：
二、show profile
ACID A Atomicity 原子性：对数据的修改，要么都成功要么都不成功 C Consisent 一致性：在事务的开始和结束时，数据都必须保持一致，如：数据库金额字段累计200w，对于转账可以转来转去 但总金额200w是不会变化的I Isolation 隔离性：事务和事务之间是互相隔离、不可见的状态D Durable持久性： 事务完成后，保存到磁盘上 并发事务带来的问题： （可重复读）更新丢失：A对数据data修改，B也对data修改，B修改的结果覆盖了A修改的结果（两个事务彼此之间不知道对方的存在，事务提交后，后面事务修改的数据覆盖前事务）脏读：A读到了B修改后的数据但该数据还没提交，如果B事务回滚，那A读到的就不对不可重复读：A读取数据data,再次读时发现data改变了（因为B已完成修改了数据）。幻读：A读到了B新增的数据。如：A查询符合条件的是10条，再次查询发现能查出11条 事务的隔离级别： mysql默认可重复读
级别脏读 不可重复读幻读未提交读Read uncommitted是是是已提交读 Read committed否是是可重复度 Repeatable read否否是可序列号 Serializble否否否 我们来看看在不同的隔离级别下，事务 A 会有哪些不同的返回结果，也就是图里面 V1、V2、V3 的返回值分别是什么。
若隔离级别是“读未提交”， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。
若隔离级别是“读提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。若隔离级别是“可重复读”，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d74956d3cba038a010d97cf39990d30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b164d2d294206e8cbcd4143de4c7e271/" rel="bookmark">
			python &#43; mongodb使用入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近用了下mongodb ，简单做个记录：
1.启动系统mongo服务 mongod -f mongod.conf 其中 mongod.conf 是配置文件，示例如下：
dbpath=/youpath/data/db #数据库保存位置 logpath=/youpath/data/mongod.log #日志 logappend=true fork=true #后台 2. 如何使用 python 创建一个名为 ‘mydatabase‘ 的数据库，并在该数据库里面建一个子库 “mycollection”： 实际上用mongo命令创建数据库和子库也比较简单：
use mydatabase db.createCollection("mycollection") show dbs 使用Python创建如下， 示例 python test.py
from pymongo import MongoClient # 连接到MongoDB数据库 client = MongoClient('mongodb://localhost:27017/') # 创建一个新的数据库 db = client['mydatabase'] # 创建一个新的集合 collection = db['mycollection'] # 插入数据 data = { 'name': 'John', 'age': 30, 'city': 'New York' } result = collection.insert_one(data) # 打印插入的数据的ID print('Inserted data ID:', result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b164d2d294206e8cbcd4143de4c7e271/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78df8e4815f8b5af106d4a18a55a103e/" rel="bookmark">
			【Web系列二十七】Vue实现dom元素拖拽并限制移动范围
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
需求
拖拽功能封装
使用拖拽功能
vite-env.d.ts
main.ts
test.vue
需求 dom元素拖拽并限制在父组件范围内
拖拽功能封装 export const initVDrag = (vue) =&gt; { vue.directive('drag', (el) =&gt; { const oDiv = el // 当前元素 oDiv.onmousedown = (e) =&gt; { let target = oDiv while ( window.getComputedStyle(target).position !== 'absolute' &amp;&amp; target !== document.body ) { target = target.parentElement } let parent = target.parentNode document.onselectstart = () =&gt; { return false } if (!target.getAttribute('init_x')) { target.setAttribute('init_x', target.offsetLeft) target.setAttribute('init_y', target.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78df8e4815f8b5af106d4a18a55a103e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7ac5c9e3bf94057cfa3af86ce416554/" rel="bookmark">
			回调报错----mongoose连接数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 const mongoose=require('mongoose') mongoose.connect('mongodb://127.0.0.1:27017/bilibili') mongoose.connection.once('open',()=&gt;{console.log('连接成功');}) mongoose.connection.once('error',()=&gt;{console.log('连接失败');}) mongoose.connection.once('close',()=&gt;{console.log('取消连接');}) const bookSchema = mongoose.Schema({ name: String, age: Number, id: Number, }); // 创建模型对象 let bookModel = mongoose.model("书籍", bookSchema); //集合名称与结构对象 // 新增 bookModel.create( { name: "小红", age: 10, id: 1, }, (err,data)=&gt;{ if(err){ console.log(err); return; } console.log(data) } ) 运行 报Model.create() no longer accepts a callback'
不能使用回调，可使用then或者catch
// 新增 bookModel.create( { name: "小红", age: 10, id: 1, } ).then(data=&gt;{ console.log(data); }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70ee0b9f9a63385fd951850384b38b4f/" rel="bookmark">
			未来必备！2023年15款最强大的自动化UI测试工具盘点，让你的测试游刃有余！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Web 开发行业正在不断发展，许多最佳自动化 UI 测试工具可用于测试基于 Web 的项目，以确保它没有错误并且每个用户都可以轻松访问。这些工具可帮助您测试您的 Web 项目并使其完全兼容用户端的要求和需求。
UI 自动化测试工具可测试基于 Web 的应用程序或软件的完整 GUI 验证、功能和可用性。它们经过测试以满足最终用户或应用程序/软件的要求，以确保它们完全提供应开发的功能并为用户提供最佳的用户体验。
对 UI 自动化测试工具的需求可确保软件/应用程序的 Web 层或 UI 无错误且易于访问，并且在处理某些事件操作时不会出现任何用户体验缺陷和延迟。通过网站UI测试，您还可以确保您的网站阻止所有加载缓慢、无响应、糟糕的导航、过时的设计、糟糕的内容结构以及音频和视频功能的阻塞性使用。
在这篇关于最佳自动化 UI 测试工具的文章中，让我们看看什么是 UI 测试、执行 UI 测试时面临的挑战，以及如何使用最佳 UI 自动化测试工具克服这些挑战。
一、什么是 UI 测试? 由于当今社会的大多数人严重依赖互联网来完成日常任务，因此这些交互必须是无缝且令人满意的。
UI 测试可确保您的网站外观和运行正常。它有助于确保它易于使用并适用于不同的网络浏览器和计算机。UI 测试是确保您的网站用户友好且与不同浏览器和操作系统兼容的绝佳方法。通过自动化 GUI 测试，您可以确保您的用户获得无错误的体验。您还可以通过包含回归测试来添加到您的测试套件中，这可确保在对代码进行更改时不会重新引入错误。
UI测试需要集成各种工具和方法来创建有效的网站UI测试计划。因此，如果您正在执行 GUI 测试，此UI 测试清单可以帮助您节省大量时间。
二、执行 UI 测试时面临的挑战 在本节中，我们将讨论 UI 自动化测试挑战以及如何克服它们并将其用于下一个测试项目。
以下是一些主要且最常面临的 UI 自动化测试挑战：
1、频繁更改用户界面
UI测试是确保我们产品功能质量的重要组成部分。这会显着影响开发团队的效率和有效性，特别是当 UI 经常更改时。处理 UI 中的频繁更改的主要挑战是我们必须确保所有测试都适应新的更改。由于我们使用多种浏览器(IE、Firefox、Chrome、Safari、Opera)，因此我们的测试有许多可能的配置(不同的分辨率、不同的浏览器)。我们还需要检查代码库的每次更改后测试是否仍然正确运行。
2、检测跨浏览器兼容性问题
由于复杂 Web 应用程序的存在，UI 测试传统上是一项艰巨的任务。浏览器之间存在重大兼容性问题，需要更仔细的测试过程。由于每个浏览器都以自己的方式解释 HTML、CSS 和 JS，因此会出现许多问题。UI测试主要侧重于检测跨浏览器兼容性问题，以便为Web应用程序提供最佳的用户体验。
3、选择正确的 UI 测试自动化工具
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70ee0b9f9a63385fd951850384b38b4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9679ce14c01793dbad63eb7fe97443cc/" rel="bookmark">
			【C语言】结构体&#43;位段&#43;枚举&#43;联合(2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是苏貝，本篇博客带大家了解结构体和位段以及枚举，如果你觉得我写的还不错的话，可以给我一个赞👍吗，感谢❤️
这是这个系列的第二篇，上一篇详细介绍了结构体的基本知识，详情请点击
目录 一.结构体1.1 结构体内存对齐1.2 修改默认对齐数1.3 结构体传参 二. 位段2.1 什么是位段2.2 位段的内存分配2.3 位段的跨平台问题 三. 枚举3.1 枚举类型的定义3.2 枚举的使用3.3 枚举的优点 四. 联合（共用体）4.1 联合类型的定义4.2 联合的特点4.3 联合的应用4.4 联合大小的计算 一.结构体 1.1 结构体内存对齐 现在大家应该都已经掌握了结构体的基本使用了，现在我们深入讨论一个问题：计算结构体的大小。这也是一个特别热门的考点： 结构体内存对齐
在正式讲解内存对齐之前，先用下面的代码来引入。你觉得答案是什么？
struct S1 { char a; char b; int c; }; struct S2 { char a; int c; char b; }; int main() { printf("%d\n", sizeof(struct S1)); printf("%d\n", sizeof(struct S2)); return 0; } 你可以看见，答案居然不一样，可是两个结构体的成员是一样的呀，只是三个成员变量的顺序不同罢了。那我们现在就用可以计算结构体成员相较于起始位置的偏移量的宏offsetof
offserof括号里面的第一个参数是结构体类型，第二个是结构体成员。头文件：&lt;stddef.h&gt;
#include&lt;stdio.h&gt; #include&lt;stddef.h&gt; struct S1 { char c1; char c2; int i; }; struct S2 { char c1; int i; char c2; }; int main() { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9679ce14c01793dbad63eb7fe97443cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13e438824ef055c12eb442ce67d94a24/" rel="bookmark">
			数据结构(全)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 第一章 绪 论
1.1 数据结构的基本概念
1.2 数据结构的三要素
1.2.1 数据的逻辑结构
1.2.2 数据的存储（物理）结构：
1.2.3 数据的运算
1.3 算法的基本概念
第二章 线性表
2.1 线性表的存储结构
2.2 顺序表与链表的比较
2.3 栈
2.4 队列
2.4 数组与特殊矩阵
2.5 串
第三章 树和二叉树
3.1 树和森林
3.1.1 树的基本术语
3.1.2 树的性质
3.1.3 树与森林的遍历
3.1.4 树的存储结构
3.1.5 树转二叉树
3.2 二叉树
3.2.1 二叉树的性质
3.2.4 线索二叉树
3.3 哈夫曼树和哈夫曼编码
第四章 图
4.1 图的基本概念
4.2 图的存储结构 4.3 最小生成树
4.3.1 Prim算法
4.3.2 Kruskal 算法（克鲁斯卡尔）
4.4 最短路径
4.5 有向⽆环图（DAG）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13e438824ef055c12eb442ce67d94a24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0ce548ad060974ed6dcea928660d2bf/" rel="bookmark">
			王道操作系统大题汇总（纯手写版，思路过程详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 前言：一、计算机系统概述二、进程与线程三、内存管理四、文件管理五、输入/输出（I/0）管理 前言： 本文为笔者自用操作系统大题复习，大家可以作为学习的参考，文章只收录操作系统常考大题，重点大题，并非王道的每道大题都进行收录，相信读者在认真学习后一定有所收获，与君共同进步。
一、计算机系统概述 库函数是语言或应用程序的一部分，可以运行在用户空间中。而系统调用是操作系统的一部分，是内核为用户提供的程序接口，运行在内核空间中，而且许多库函数都会使用系统调用来实现功能。未使用系统调用的库函数，其执行效率往往比系统调用的高。因为使用系统调用时，需要上下文的切换及状态的转换（用户态——&gt;核心态）
批处理操作系统：用户脱机使用计算机，作业成批处理的，系统内多道程序并发执行，交互能力差
分时操作系统：可以让多个用户同时使用计算机，人机交互性较强，具有每个用户独立使用计算机的独占性，系统响应及时
实时操作系统：能够对控制对象做出及时反应，可靠性高，但资源利用率低
二、进程与线程 这题标准答案省去了两个mutex，因为它的p排序比较巧妙，它那个顺序能保证不加mutex也不会死锁，但是你如果对p顺序不是那么敏感就我这样写，把资源为1的都加mutex互斥一下，也是正确的，下面是王道助教对本解法正确的认可。
三、内存管理 固定分区：有内部碎片
动态分区：有外部碎片
ps：页表一般都是在主存里面的，如果出现了页表不在主存就涉及缺页中断了。
缺页中断发生，你就需要访问外存，然后把外存的页往里面调用。
调用又分两种情况，内存空间还够，直接调进来。
内存不够了，就把内存里面一共页掉出去，把外存需要的页调进来。
然后题目中也有时候会出现页号大于给定上限的情况，这个时候就是越界中断，又是另一种情况。
建议读者把基本分页和请求分页那块知识学好再来做题，不然你会相当痛苦。
（什么苟劈关联存储器，就是一个快表罢了）
四、文件管理 连续分配：
优点——可以随机访问（磁盘），访问速度快
缺点——需要连续的存储空间，容易产生碎片，降低磁盘空间利用率，不利于文件的扩充
链接分配：
优点——不要求连续的存储空间，能有效的利用磁盘，易于扩充。
缺点——只能顺序访问，不能随机访问。另外，链接指针占了一部分空间，降低了存储效率
索引分配：
优点：既支持顺序访问，又支持随机访问，查找效率高，便于文件删除。
缺点：索引表会占据一部分空间。
五、输入/输出（I/0）管理 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a6becf4c143405874dc2a637d8511af/" rel="bookmark">
			SQL Server Count()函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SQL Server Count()函数 SQL Server COUNT() 是一个聚合函数，它返回在集合中找到的项目数。
COUNT() 函数语法：
COUNT([ALL | DISTINCT ] expression) ALL 指示COUNT() 函数应用于所有值。ALL是默认值。返回非NULL值的数量（包括重复值，不包括空值）DISTINCT 指示COUNT() 函数返回唯一的非NULL值的数量。（不包括重复值，不包括空值）excepress 是除 image,text,ntext之外的任何类型的表达式。注意：不能在表达式中使用子查询或聚合函数。 COUNT() 函数还有另外一种形式：
COUNT(*) 在这种形式中，COUNT( * ) 返回指定表中的行数。 COUNT( * )不支持DISTINCT并且不带参数。它分别统计每一行，并包含NULL值的行。
COUNT(*) 计算集合中的项目数，它包括NULL和重复值。COUNT( ALL expression)计算集合中每行的表达式，并返回非NULL值的数量。COUNT(DISTINCT expression)计算集合中每行的表达式，并返回唯一的非NULL空值的数量。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38fdf94b41f5cebaa92fbf070f06c1d1/" rel="bookmark">
			实验二 单链表的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1．实验性质：设计性实验
2．要求：
（1）编程实现单链表的以下基本操作：建立单链表，查找单链表，插入单链表，删除单链表。
（2）采用单链表结构编程实现：两个有序单链表的归并运算。
3．目的：
（1）掌握线性表的链式存储结构；
（2）掌握单链表及其基本操作的实现。
实验步骤 编写一个提示信息输入的函数，在main函数中调用提示信息。定义单链表函数体。单链表初始化。根据需要的内容编写相应的函数体。通过函数调用，将所需的内容展示出来。调整代码，尽可能向所需内容靠近。 实验记录 先定义一个单链表并进行初始化
#define OK 1 #define ERROR 0 using namespace std; typedef int ElemType; //定义数据类型，相当于给int取别名为ElemType typedef struct LNode //定义单链表 { ElemType data; struct LNode *next; }LNode,*LinkList; typedef int Status; //定义数据类型，相当于给int取别名为Status Status InitList(LinkList &amp;L) //单链表初始化 { L = new LNode; L-&gt;next=NULL; //头指针为空 return OK; } 1. 查找单链表
LinkList p; //定义一个新的指针p LNode *LocateElem(LinkList L,ElemType e) //查找单链表 { p=L-&gt;next; while(p &amp;&amp; p-&gt;data != e) p=p-&gt;next; cout &lt;&lt; e &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38fdf94b41f5cebaa92fbf070f06c1d1/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/22/">«</a>
	<span class="pagination__item pagination__item--current">23/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/24/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>