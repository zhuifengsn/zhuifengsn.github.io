<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/855cfb435ba2112c773976a84a85a3b9/" rel="bookmark">
			修改文件格式（查看文件拓展名）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多时候我们直接把txt文件重命名为xxx.c或者别的文件格式，文件类型依然会是txt，文件名并不会变成我们想要的xxx.c，而是xxx.c.txt，也就是下面这个样子
给大家介绍2种方法去解决这个问题
目录
1.另存为新格式
2.显示文件拓展名
1.另存为新格式 不重命名，而是点开txt文件
选择另存为
把保存类型选择“所有文件”，然后保存
文件类型修改成功：
2.显示文件拓展名 除了上面那种方法，还有一种一劳永逸的方法，就是显示出文件拓展名，这样就可以直接重命名
首先点击文件资源管理器——
点击“查看”——“选项”
进入文件夹选项，点击查看，把“隐藏已知文件夹扩展名”给取消勾选
这个时候我们再看文件，就可以看见文件后缀，可以直接重命名修改更改文件类型
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0741be1a2572bb03b0b0a4dba8a85696/" rel="bookmark">
			【CSS】3D卡片效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果 index.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt; Document &lt;/title&gt; &lt;link type="text/css" rel="styleSheet" href="index.css" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="card"&gt; &lt;img src="cover1.jpg" class="cover" /&gt; &lt;img src="title1.png" class="title" /&gt; &lt;img src="hero1.png" class="hero" /&gt; &lt;/div&gt; &lt;div class="card"&gt; &lt;img src="cover2.jpg" class="cover" /&gt; &lt;img src="title2.png" class="title" /&gt; &lt;img src="hero2.png" class="hero" /&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; index.css * { margin: 0; padding: 0; box-sizing: border-box; } body{ width: 100vw; height: 100vh; margin: 0; /* 弹性盒 */ display: flex; /* 水平居中 */ justify-content: center; /* 垂直居中 */ align-items: center; /* backgroud: #191c29 */ background: #fff; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0741be1a2572bb03b0b0a4dba8a85696/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f686f56dbea5a356b6eddf50e9d58b2/" rel="bookmark">
			vue跳转到新的页面之后，不让其回退的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 直接把代码复制进去，方可实现！
created(){ // 跳转到登录界面之后，不让其回退。就直接添加下面这段代码即可实现 history.pushState(null, null, document.URL); window.addEventListener("popstate", function () { history.pushState(null, null, document.URL); }); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de651091e496121783be871cc748b45d/" rel="bookmark">
			docker生产环境架设步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 安装docker和下载docker镜像等完成前置工作。
YUM安装Docker引擎服务；
yum install docker* -y
查看Docker软件是否安装；
rpm -qa|grep docker
启动Docker引擎服务；
service docker restart
systemctl restart docker.service
查看Docker引擎服务进程；
ps -ef|grep docker
如果出错要更换yum源，阿里云测试的不行，要换清华源:
该文件夹只提供 CentOS 7 与 8，架构仅为 x86_64 ，如果需要较早版本的 CentOS，请参考 centos-vault 的帮助，若需要其他架构，请参考 centos-altarch 的帮助。
建议先备份 /etc/yum.repos.d/ 内的文件。
然后编辑 /etc/yum.repos.d/ 中的相应文件，在 mirrorlist= 开头行前面加 # 注释掉；并将 baseurl= 开头行取消注释（如果被注释的话）。 对于 CentOS 7 ，请把该行内的域名（例如mirror.centos.org）替换为 mirrors.tuna.tsinghua.edu.cn。 对于 CentOS 8 ，请把 mirror.centos.org/$contentdir 替换为 mirrors.tuna.tsinghua.edu.cn/centos。
yum makecache
2、镜像源要改国内163的快
#从docker官网仓库搜索tomcat|nginx|redis镜像；
docker search tomcat
docker search nginx
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de651091e496121783be871cc748b45d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4507ce4e2209cf7a8164727d9649291f/" rel="bookmark">
			docker启动报错：Cannot connect to the Docker daemon
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Couldn’t connect to Docker daemon at http+docker://localunixsocket - is it running? 解决方式：正确的是将当前用户加入docker组解决步骤 sudo groupadd docker #添加docker用户组 sudo gpasswd -a $USER docker #将登陆用户加入到docker用户组中 newgrp docker #更新用户组 docker ps #测试docker命令是否可以使用sudo正常使用 sudo service docker start sudo systemctl enable docker #开机启动 Cannot connect to the Docker daemon at unix:///var/run/docker.sock 设置 daemon.json，没有的话创建，位置/etc/docker\daemon.json，设置为国内源 # 中科大镜像 { "registry-mirrors": ["https://docker.mirrors.ustc.edu.cn"] } 重新加载 cd /var/lib rm docker dockerd --config-file /etc/docker/daemon.json systemctl daemon-reload 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8483a3f320608eb48eb545fe2d22d212/" rel="bookmark">
			解决vue项目中出现webpack＜5的问题！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误如下：
解决方法：
先安装一下模块：
npm install node-polyfill-webpack-plugin 然后打开vue.config.js文件：引入和配置如下代码即可解决。注意要写在module.exports里面
// 引入此模块来解决webpack&lt;5的那个烦人的错误！ const NodePolyfillPlugin = require('node-polyfill-webpack-plugin') module.exports = defineConfig({ //引入完毕后， 配置上 : 下面的代码！ configureWebpack: { plugins: [new NodePolyfillPlugin()], } }) 然后再次运行项目，就解决了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4925e8bbf33847240a4047ba3f223f87/" rel="bookmark">
			WindowsServer 离线安装Docker&amp;端口映射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、二、使用步骤1. 三、端口映射 提示：以下是本篇文章正文内容，下面案例可供参考
一、 因服务器在省，无法变更服务器。
二、使用步骤 1. 下载ee版本的Windows Server,地址如下：
https://download.docker.com/components/engine/windows-server/19.03/docker-19.03.3.zip 将下载后的文件解压拷贝到如下目录
C:\Program Files\Docker 配置daemon.json文件
创建 C:\ProgramData\Docker\config 目录，在config目录下创建 daemon.json 文件，其内容可为
{ "insecure-registries":[] } 添加上面目录到系统环境变量Path
在服务器管理器里添加角色和功能选项下的功能菜单选择容器，安装后需要重启服务器。
将docker注册为服务
dockerd --register-service 三、端口映射 查看所有映射 netsh interface portproxy show all 添加映射
将所有ip的8080端口映射到本地80端口 netsh interface portproxy add v4tov4 listenaddress=* listenport=8080 connectaddress=127.0.0.1 connectport=80 netsh interface portproxy add v4tov4 listenaddress=133.0.132.* listenport=500* connectaddress=*.0.*.20 connectport=18801 注意: 添加映射需要管理员权限,需要修改防火墙
注意: listenaddress=*删除效果是一样的
注意: 添加其它ip必须要listenaddress=ip
删除映射 netsh interface portproxy delete v4tov4 listenaddress=* listenport=8080 注意: listenaddress=*删除效果是一样的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4925e8bbf33847240a4047ba3f223f87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e77bf8873a57c2e18e282b59f361e2d6/" rel="bookmark">
			C&#43;&#43;中函数返回引用，及问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
函数返回值 返回引用 （**）
C++基础知识 - 函数返回引用深度解析
关于函数调用返回引用错误并且每次调用不一致的分析与解决
将引用作为函数返回值的格式、好处和规则
实用经验 45 禁止函数返回局部变量的引用
---------------------------------------------------------
（1）返回的是一个引用类型，也就是返回值是绑定在该临时变量上， 一旦该临时变量被销毁，就会导致返回的引用变量是一个不可预估的数值。
所以正确的做法是，将该函数的返回类型定义为一个const变量。
const TSize TComPointCloud::getNumPoint() const
{
return m_pos.size();
}
这样函数调用返回类型是一个变量，也就是将 该变量复制给 另外一个变量之后 被销毁，因为是复制，两个变量之间是相互独立的。
（2）如果一个函数返回的类型为引用，那么，
返回的引用会绑定到该函数的返回 return value; (变量value 就会绑定到 返回引用变量，一旦该返回变量value被销毁，那么，返回的引用 就会绑定到 被销毁的变量，这个值是不确定的，这也就是每次调用时都会看到不同结果的原因)
===================================
实用经验 45 禁止函数返回局部变量的引用 请谨记
函数返回时，保证返回数据超出函数范围后依然有效。像返回局部变量的引入就是不靠谱的事情。函数返回时，返回new生成的对象，同样不是一个可取的方法。因为这样的代码层次混乱，会让代码上层使用人员苦不堪言。 实用经验 45 禁止函数返回局部变量的引用_@一鸣惊人的博客-CSDN博客
将引用作为函数返回值的格式、好处和规则 格式： 类型标识符 &amp;函数名（形参列表及类型说明）{//函数体}
好处： 在内存中不产生返回值的副本（返回一个局部变量的引用是不可取的，因为随着局部变量生存周期的结束，相应的引用也会失效，产生runtime error）
注意： 不能返回局部变量的引用，局部变量会在函数返回后被销毁。不能返回函数内部new分配的内存的引用，虽然不存在局部变量的被动销毁问题，但是函数返回的引用只是作为一个临时变量出现，并没有被赋予一个实际的变量，导致引用所指向的空间无法释放。可以返回类成员的引用，但最好是const，主要原因是当对象的属性与某种业务规则相关联的时候，其赋值常常与某些其它属性或者对象的状态相关联，因此有必要将赋值操作封装在一个业务规则中，如果其它对象可以获得该属性的非常量引用（或指针），那么对于该属性的单纯赋值就会破坏业务规则的完整性。流操作符重载返回值申明为“引用”的作用：&lt;&lt;和&gt;&gt;常常希望被连续使用，因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选方案包括：返回一个流对象和返回一个流对象指针。返回一个流对象，程序必须重新构造一个新的流对象，两个&lt;&lt;操作符实际上是针对了不同对象；返回一个流对象指针，并不能连续使用&lt;&lt;操作符。返回一个流对象引用则是唯一选择。 转载于:https://www.cnblogs.com/yingl/p/5815554.html
关于函数调用返回引用错误并且每次调用不一致的分析与解决 引用与指针的区别 1.引用不能为空，不存在空引用，但是指针却可以存在空指针，这就意味着我们拿到一个引用时不需要判断引用是否为空，但是如果拿到的是一个指针，则需要判断指针是否为空之后再进行指针的进一步操作。
2、引用一旦建立，将一直效忠于他，不能再引用。
引用与变量的区别 1.如果将一个变量绑定到一个引用上，那么如果这个引用发生改变，它所指向的变量也会发生改变。（这点非常重要，特别是在函数调用时，经常将函数的形参设计为引用类型，来达到形参发生改变实参改变的目的）；
2.如果一个函数返回的类型为引用，那么，
返回的引用会绑定到该函数的返回 return value; (变量value 就会绑定到返回引用变量，一旦该返回变量value被销毁，那么返回的引用就会绑定到被销毁的变量，这个值是不确定的，这也就是每次调用时都会看到不同结果的原因)
例如：函数getNumPoint的主要功能是返回变量m_pos的长度，但是该函数最终返回的类型是const 引用类型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e77bf8873a57c2e18e282b59f361e2d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e342d2b67897162190f829c6948ae68/" rel="bookmark">
			R语言进行因子分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在R语言中，可以使用factanal函数来进行因子分析（Factor Analysis）。因子分析是一种降维技术，用于将多个观测变量转换为较少的无关因子，以便更好地理解数据的结构和隐含关系。
以下是一个因子分析的简单示例：
步骤1：准备数据
首先，我们创建一个虚拟的数据集，其中包含多个观测变量。在这个示例中，我们假设有三个观测变量（V1、V2、V3）。
# 创建虚拟数据集 set.seed(123) # 设置随机种子，保证结果可复现 data &lt;- data.frame( V1 = rnorm(100), V2 = rnorm(100), V3 = rnorm(100), V4 = rnorm(100), V5= rnorm(100), ) 步骤2：进行因子分析
使用factanal函数来进行因子分析：
# 因子分析 factor_result &lt;- factanal(data, factors = 2, rotation = "varimax") 在上述代码中，factors = 2参数表示要提取2个因子，rotation = "varimax"参数表示使用Varimax旋转方法来简化因子载荷矩阵。
步骤3：查看结果
来查看因子分析的结果：
# 查看因子分析结果 factor_result 输出因子分析的结果，包括因子载荷矩阵、因子方差解释比例、因子的共同度等信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd6fa15f6fd85cf6866cbc7e4a15c5f9/" rel="bookmark">
			Linux network 重启报错：Failed to start LSB: Bring up/dow....
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux network 重启报错：Failed to start LSB: Bring up/dow…
1. 错误信息如下： [root@localhost network-scripts]# service network start
Starting network (via systemctl): Job for network. service failed because the control process exited with error code. See "systemctl status network.service" and "journalctl -xe" for details. [FAILED] [root@localhost network-scripts]# systemctl status network.service
主要错误信息为：Failed to start LSB: Bring up/dow…
● network.service - LSB: Bring up/down networking Loaded: loaded (/etc/rc.d/init.d/network; bad; vendor preset: disabled) Active: failed (Result: exit-code) since Fri 2023-07-28 22:14:24 PDT; 18s ago Docs: man:systemd-sysv-generator(8) Process: 3042 ExecStop=/etc/rc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd6fa15f6fd85cf6866cbc7e4a15c5f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76003185cc0fcd8f22e23f2ebc533da5/" rel="bookmark">
			Spring之IoC源码分析及设计思想(一)——BeanFactory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于Spring的IOC Spring 是一个开源的 Java 平台，它提供了一种简化应用程序开发的框架。它是一个分层的框架，包括两个主要的内核：控制反转（IOC）和面向切面编程（AOP）。IOC 允许应用程序将组件之间的依赖关系交给框架来管理，从而实现松耦合；而 AOP 则允许应用程序以声明式的方式实现横切关注点，如日志、事务、安全等。
Spring 的 IOC（Inversion of Control）是其核心特性之一，它允许应用程序将组件之间的依赖关系交给框架来管理，从而实现松耦合。 在传统的程序设计中，对象之间的依赖关系是由程序代码直接控制的，而在 IOC 的思想下，对象之间的依赖关系是由 Spring 容器控制的，程序代码只需要声明依赖关系，而不需要直接创建或管理对象。换言之，当我们通过配置声明好对象之间的依赖后，Spring容器会根据我们的配置帮我们创建对象实例并完成对象中各个成员变量的装配，而不需要我们手动创建或者查找各个对象实例来进行组装。我们可以认为IOC与JNDI相反——后者从容器中主动查找依赖(所需要的对象)，而前者在容器初始化某个对象时不等对象请求就主动将依赖传递给它。
IOC的底层采用了工厂模式，所有的Bean(对象实例)都将由BeanFactory也就是Bean工厂来完成实例化，且实例化后理论上都需要被注册到容器中，由容器负责Bean的生命周期的管理(Bean的创建、依赖装配、初始化、销毁)。 开发者只需要按照Spring约定好的方式提供Bean的定义信息(主要以XML配置和注解配置为主，有时候也可以在运行期间通过某些方式实时提供)即可，Bean工厂会根据这些Bean定义来完成Bean的生成。因此，对Bean工厂的认识与理解正是认识SpringIOC的关键(Bean工厂是SpringIOC的逻辑实现)。
从片面的角度上来说，我们可以认为Spring就是一个针对Bean生命周期进行管理的容器。
关于BeanFactory 前面提到Bean工厂是SpringIOC的逻辑实现，因此正确理解Bean工厂正是认识SpringIOC的关键(这里的Bean工厂并不指的是BeanFactory接口，而是包含BeanFactory接口在内的一整套类与接口的实现)。下图是Bean工厂的实现类图：
从整个类图来看，我们可以发现所有的接口与类最终汇聚到了DefaultListableBeanFactory上了。DefaultListableBeanFactory这个类包含了SpringIOC完整的逻辑实现，是Spring默认的BeanFactory实现。事实上，在我们使用Spring时最熟悉的ClassPathXmlApplicationContext与FileSystemXmlApplicationContext两个类都是通过DefaultListableBeanFactory来实现SpringIOC的功能。具体源码可见下图：
在图中我们可以看到ApplicationContext的getBean逻辑正是调用了DefaultListableBeanFactory来实现的Bean的获取。其中AbstractApplicationContext正是前面提到的ClassPathXmlApplicationContext与FileSystemXmlApplicationContext的高层父类。
因此，我们对于SpringIOC的源码和分析只需要局限于DefaultListableBeanFactory即可。DefaultListableBeanFactory已经封装了SpringIOC中对Bean操作的完整逻辑。从前面第一张图(Bean工厂的实现类图)可以看到，在DefaultListableBeanFactory之上有着大量的接口和类，组成了非常复杂的类继承结构。但是其中最顶层的接口就只有BeanFactory、AliasRegistry以及SingletonBeanRegistry。三者分别赋予了Bean工厂不同的能力。而从DefaultListableBeanFactory的类名来看，也可以发现Spring对它的定义就是一个BeanFactory。本文主要讨论BeanFactory接口在SpringIOC设计中所承担的职责与角色，而不着重于类图中其他类与接口的能力。
BeanFactory接口 BeanFactory接口是Spring定义的顶层接口，被定义为是Bean容器的客户端视图。即我们对Bean容器中Bean的获取可以通过BeanFactory接口来实现，而不需要关心其获取逻辑。换句话说，BeanFactory接口赋予了Bean容器向外提供Bean的能力。下图是BeanFactory接口中定义的方法列表：
从图中看，我们能够发现BeanFactory接口中差不多有近一半的方法都是以getBean为名通过Bean名称、Bean类型去获取符合条件的Bean实例。至于剩下的基本也都是与Bean及其特性相关的操作，比如是否包含Bean、判断Bean是单例Bean还是原型Bean、类型是否匹配、获取Bean的类型和别名等。
因此，我们也能够确认BeanFactory接口确实与之前所说一致，是一个被设计用来访问Bean容器中Bean实例的客户端视图，定义了实现该接口的类获取Bean的能力。
本章不谈具体的实现逻辑，因为IOC的实现是一个复杂的过程，在不了解Spring设计意图的前提下盲目去讨论其直接实现类AbstractBeanFactory的实现逻辑会容易让人迷茫，因为其中参杂着其他许多类与接口的部分。相信跟着源码debug过的同学深有体会。其中Bean的缓存是由DefaultSingletonRegistry实现的，Bean的构建和装配等逻辑又是由AbstractAutowireCapableBeanFactory类实现的，这些部分的逻辑又被嵌入在获取Bean的逻辑中，所以通过debug去追溯源码执行逻辑的方式并不可取。
接口方法说明 下面提供对BeanFactory中函数的简单说明，可看可不看。因为大概的作用在前面已经点的差不多了，有了解的同学可以不用看这部分。
Object getBean(String name) throws BeansException; 根据name或者alias获取容器中的Bean
&lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException; 通过传入的name查找到Bean然后转成requiredType的类型，如果找不到会抛出 NoSuchBeanDefinitionException.
如果转化类型失败会抛出BeanNotOfRequiredTypeException.
Object getBean(String name, Object... args) throws BeansException; 返回一个实例，该实例可以是指定bean的共享或独立的。
允许指定显式构造函数自变量/工厂方法自变量，并覆盖Bean定义中指定的默认自变量（如果有） 。
注意，如果Bean已经被创建了，那么通过这个方式就无法将参数放进去了。
&lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException; 根据类型查找Bean，如果找不到Bean会抛出 NoSuchBeanDefinitionException;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76003185cc0fcd8f22e23f2ebc533da5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ff304d9e49e4b0b9d19dc2be8a05bbd/" rel="bookmark">
			【C&#43;&#43;11】——右值引用、移动语义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 基本概念
1.1 左值与左值引用
1.2 右值和右值引用
1.3 左值引用与右值引用
2. 右值引用实用场景和意义
2.1 左值引用的使用场景
2.2 左值引用的短板
2.3 右值引用和移动语义
2.3.1 移动构造
2.3.2 移动赋值
2.3.3 编译器做的优化
2.3.4 总结
2.4 右值引用引用左值
2.5 右值引用的其他场景（插入接口）
3. 完美转发
3.1 万能引用&amp;&amp;
3.2 forward完美转发在传参的过程中保留对象原生类型属性
3.3 完美转发的使用场景
1. 基本概念 传统的C++语法中就有引用的语法，而C++11中新增了的右值引用语法特性，所以从现在开始我们之前学习的引用就叫做左值引用。无论左值引用还是右值引用，都是给对象取别名。
1.1 左值与左值引用 左值：
左值是一个表示数据的表达式(如变量名或解引用的指针)，有如下特性：
我们可以获取它的地址+可以对它赋值（不一定能赋值，但一定能取地址）；左值可以出现赋值符号的左边，右值不能出现在赋值符号左边；定义时const修饰符后的左值，不能给他赋值，但是可以取它的地址。 左值引用：
左值引用就是给左值的引用，给左值取别名。 int main() { // 以下的p、b、c、*p都是左值 int* p = new int(0); int b = 1; const int c = 2; // 以下几个是对上面左值的左值引用 int*&amp; rp = p; int&amp; rb = b; const int&amp; rc = c; int&amp; pvalue = *p; return 0; } 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ff304d9e49e4b0b9d19dc2be8a05bbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6be1ecaf0959402dd18d4a2f7cc0d4d0/" rel="bookmark">
			C&#43;&#43;444444
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：本文章主要用于个人复习，追求简洁，感谢大家的参考、交流和搬运，后续可能会继续修改和完善。
因为是个人复习，会有部分压缩和省略。
一、默认成员函数 当类里面成员函数什么都不写的时候，编译器会自动生成6个默认成员函数
六个成员函数包括：
构造函数（主要完成初始化工作）
析构函数（主要完成清理工作）
拷贝构造（视同同类对象初始化创建对象）
赋值重载（主要是把一个对象赋值给另一个对象）
取地址重载（主要是普通对象和const对象取地址，这两个很少需要自己实现）
默认成员函数对于内置类型成员不处理，对于自定义类型成员，它会去调用它的构造函数、析构函数
我们主要探讨前四个
1.构造函数（主要完成初始化工作） 构造函数完成的是对象的初始化，对象实例化时自动调用，这样就保证对象一定初始化。
构造函数没有返回值，没有返回值和void不一样，void是返回值为空
因为我们有时候可能会忘记调用初始化函数，C++为了解决这个问题，引入了构造函数来初始化，构造函数不可能没有调用，因为它是一个特殊的成员函数，其特征如下：
1.函数名与类名相同
2.无返回值
3.对象实例化时编译器自动调用对应的构造函数（保证了对象一定会初始化）
4.构造函数可以重载（我们就可以有多种初始化方式）
给一个全缺省的初始化是最好的
注意：调试的时候，只能看当前作用域里的变量
当全缺省构造函数和无任何参数的构造函数同时存在时，编译会出错，因为无法判断是要调用哪一个构造函数。语法上是可以的，但是实际使用时是不可以的。
我们不写，编译器会生成一个构造函数，我们写了编译器就不会生成了。所以说构造函数是默认构造函数
虽然构造函数进行初始化，但是它不会把值初始为0，而是随机值
对于内置类型（基本类型）语言原生定义的类型，如char、int、double、指针等等编译器不会初始化为0。对于自定义类型：class、struct等定义的类型，编译器回去调用它们的默认构造函数初始化为0。构造函数还是自己写靠谱，绝大多数情况下，默认构造函数并不行
默认构造函数：我们不写，编译器自动生成，我们写了，编译器自动生成。这个理解有一些地方不对
1.我们不写，编译器默认生成的
2.我们自己写的无参的
3.我们写的全缺省（最推荐）
总结：不用传参就可以调用的构造函数
大多数情况下，都是我们自己写构造函数初始化，建议写一个全缺省的构造函数，这种方式能适应各种场景
编译器默认生成的并不是什么都不做，而是有区分的。
class Date { private: int _year; int _month; int _day; }; int main() { Date d1(2022,5,15);//可以 Date d2;//可以 Date d3();//不可以，未调用原型函数。没有调用到构造函数，对象没有被构造出来 return 0; } 那么我们如何验证呢？如下：
class Date { public: void Print() { cout &lt;&lt; "cout" &lt;&lt; endl; } private: int _year; int _month; int _day; }; int main() { Date d1(2022,5,15);//可以 Date d2;//可以 Date d3();//不可以，未调用原型函数。没有调用到构造函数，对象没有被构造出来 d1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6be1ecaf0959402dd18d4a2f7cc0d4d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cbbd317942bf0a50b3a344027e02c22/" rel="bookmark">
			如何自定下载文件名？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、通常下载文件我们直接通过打开此链接，即可下载，但这种文件名，我们无法自定义，多数是通过后端来控制（即采用链接最后面那一串为文件名）
window.open(url, '__blank') 2、同域名情况下，我们也可以通过a标签的download属性来自定义下载文件名（通常情况存储文件和自身网址不是统一域名）
let a = document.createElement('a') a.href = url a.download = `${name}${+new Date()}.csv` // 生成点击 a.click() 3、不同域名下，前端可以通过将链接转为文件流后，再来自定义下载文件名
var x = new XMLHttpRequest() x.open("GET", '文件url', true) x.responseType = 'blob' x.onload=function(e) { //会创建一个 DOMString，其中包含一个表示参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的URL 对象表示指定的 File 对象或 Blob 对象。 var url = window.URL.createObjectURL(x.response) var a = document.createElement('a') a.href = url a.download = '自定义文件名' a.click() } x.send() 小插曲：如何让文件直接下载，而不是打开？
// a表示当前a标签元素，url为当前下载链接 a.setAttribute('href', data:text/plain;base64,${btoa(url)})
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dba9a6d429fea36c26043e21f22f8c16/" rel="bookmark">
			Linux解决 Failed to restart NetworkManager.service: Unit not found问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决“Failed to restart NetworkManager.service: Unit not found.”问题的步骤 如果你遇到了“Failed to restart NetworkManager.service: Unit not found.”的错误信息，不要担心！这个问题很常见，并且很容易解决。下面是解决这个问题的步骤，让我来一步一步地教给你。
步骤概览 以下是解决问题的步骤概览：
步骤描述步骤 1检查NetworkManager是否已安装步骤 2安装NetworkManager步骤 3启动NetworkManager服务 现在让我们逐个解释每个步骤，并提供相应的代码示例。
步骤 1：检查NetworkManager是否已安装 首先，我们需要确保NetworkManager已经安装在系统上。你可以使用以下命令来检查NetworkManager的安装情况：
sudo systemctl status NetworkManager 上述命令将显示NetworkManager服务的状态。如果服务已安装，则可以继续执行下一步。否则，你需要安装NetworkManager。
步骤 2：安装NetworkManager 如果在步骤 1 中发现NetworkManager未安装，你可以使用以下命令安装NetworkManager：
sudo apt-get install network-manager 上述命令将下载并安装NetworkManager软件包。根据你的系统，可能需要输入你的密码来确认安装。安装完成后，重启系统。
步骤 3：启动NetworkManager服务 如果NetworkManager已安装，但仍出现“Failed to restart NetworkManager.service: Unit not found.”的错误信息，那么很可能是因为NetworkManager服务尚未启动。你可以使用以下命令来启动NetworkManager服务：
sudo systemctl start NetworkManager 上述命令将启动NetworkManager服务。如果服务已成功启动，你可以使用以下命令来检查其状态：
sudo systemctl status NetworkManager 现在，如果一切正常，你应该看到NetworkManager服务已处于运行状态，并且不再出现“Unit not found.”的错误信息。
结论 通过按照上述步骤，你应该能够解决“Failed to restart NetworkManager.service: Unit not found.”的问题。首先，确保NetworkManager已经安装，如果没有安装，使用适当的命令进行安装。然后，启动NetworkManager服务，并确认其状态。这样，你就能够成功解决这个问题了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f537d31382ff7a3cc99e0db2175d1c30/" rel="bookmark">
			JAVA解析HL7报文数据V24
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、HL7测试工具 测试工具用到了7Edit，使用可参考7Edit解析工具的使用(二)_hl7格式工具_WW大魔王的博客-CSDN博客
2、用到的Jar包 &lt;!-- https://mvnrepository.com/artifact/ca.uhn.hapi/hapi-base --&gt; &lt;dependency&gt; &lt;groupId&gt;ca.uhn.hapi&lt;/groupId&gt; &lt;artifactId&gt;hapi-base&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/ca.uhn.hapi/hapi-structures-v24 --&gt; &lt;dependency&gt; &lt;groupId&gt;ca.uhn.hapi&lt;/groupId&gt; &lt;artifactId&gt;hapi-structures-v24&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;/dependency&gt; 3、JAVA解析Demo 3.1 简单的Demo 下面的demo中，需要注意几点：
1、换行要使用\r不能使用\n
2、每个段前面的第一个属性为段名，使用message.get()时，会自动匹配到对应段的实体类，如下面访问MFI段，没有对应实体类的段使用通用的类GenericSegment类进行解析如示例中的Z2B段。
import ca.uhn.hl7v2.HL7Exception; import ca.uhn.hl7v2.model.GenericSegment; import ca.uhn.hl7v2.model.Message; import ca.uhn.hl7v2.model.v24.segment.MFI; import ca.uhn.hl7v2.parser.PipeParser; /** * @author 崔 * @version 0.0.1 * @Date 2023/7/26 18:45 */ public class HL7ParserExample { public static void main(String[] args) throws HL7Exception { // 示例HL7 XML消息 String hl7XML = "MSH|^~\\&amp;|HIS^1|MediInfo|MediII^1|MediInfo|20180417152317||MFN^Z2B^MFN_Z2B|39a3d175f5034a2a9d41d35c911d0562|P|2.4\r" + "MFI|Z2B||UPD|||AL\r" + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f537d31382ff7a3cc99e0db2175d1c30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eee42c6dd020c451aa1aeb72a71c3618/" rel="bookmark">
			java篇 类的进阶0x0C：枚举类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 枚举类语法简单版本复杂版本构造方法与实例的关系枚举成员实例的创建时机枚举成员与构造方法枚举成员传入参数的作用枚举成员的比较 常用方法 枚举类 枚举在曰常生活中很常见，例如一个人的性别只能是“男”或者“女”，一周的星期只能是 7 天中的一个等。类似这种当一个变量有几种固定可能的取值时，就可以将它定义为枚举类型。
枚举可以用来定义固定类别的实例。枚举（enum） 本质上就是一种特殊的类（class），但枚举类不能被继承，所有枚举类都继承自 java.lang.Enum 抽象类，并实现了 java.lang.Serializable 和 java.lang.Comparable 两个接口。
语法 简单版本 访问修饰符 enum 名称{ 成员1,成员2,成员3,...成员n;	// 以逗号分隔，以分号结束。（如果只有成员，没有添加方法，最后一个成员后可以不加符号，或以逗号结束也可以，不会报错） } // 任意两个枚举成员不能具有相同的名称 // 枚举成员是常量（系统会自动添加 public static final），不可被改变。 // 枚举成员实际上就是枚举类的实例，枚举类是不允许在类的外面去创建实例（new 一个实例）的，都是放到枚举类自己内部来创建实例。 最简单的例子：
public enum SimpleCategory { SPRING, SUMMER, autumn, Winter; } // 调用类 public class TestUse { public static void main(String[] args) { System.out.println(SimpleCategory.SPRING); // SPRING System.out.println(SimpleCategory.SUMMER); // SUMMER System.out.println(SimpleCategory.autumn); // autumn System.out.println(SimpleCategory.Winter); // Winter System.out.println(SimpleCategory.SPRING.name()); // SPRING System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eee42c6dd020c451aa1aeb72a71c3618/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8539618bc892c59594e866fc0ab3888/" rel="bookmark">
			.NET各版本支持的操作系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		借助虚拟机和测试机，检测各版本操作系统对.NET的支持情况。
安装操作系统后，实测安装相应运行时并能够运行星尘代理为通过。
测试平台：VMware Workstation
镜像来源：MSDN I Tell You
参考：
.NET Framework 版本和依赖关系.NET Framework 系统要求 WinXP系列 系统
.NET2.0 SP2
.NET3.5 SP1
.NET4.0
.NET4.5
NativeAOT
WindowXP Professional
失败。要求SP2
失败。要求SP2
失败。系统不支持
失败
失败
WindowXP Professional SP2
支持。kb893803
支持
支持
失败
失败
WindowXP Professional SP3
支持
支持
支持
失败
失败
WindowXP Home
失败。要求SP2
失败。要求SP2
失败。系统不支持
失败
失败
WindowXP Home SP3
支持
支持
支持
失败
失败
Windows 2000 Professional
Windows 2003
Windows 2003 R2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8539618bc892c59594e866fc0ab3888/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4a5330183b5e1bb6b77d1d8d817a343/" rel="bookmark">
			Linux CentOS快速安装VNC并开启服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是在 CentOS 上安装并开启 VNC 服务的步骤：
安装 VNC 服务器软件包。运行以下命令： sudo yum install tigervnc-server 输出
$ sudo yum install tigervnc-server Loaded plugins: fastestmirror, langpacks Repository 'epel' is missing name in configuration, using id Loading mirror speeds from cached hostfile * base: centos.mirror.far.fi * epel: epel.mirror.serveriai.lt * extras: centos.mirror.far.fi * updates: centos.mirror.far.fi Resolving Dependencies --&gt; Running transaction check ---&gt; Package tigervnc-server.x86_64 0:1.8.0-25.el7_9 will be installed --&gt; Finished Dependency Resolution Dependencies Resolved =================================================================================================================================================================== Package Arch Version Repository Size =================================================================================================================================================================== Installing: tigervnc-server x86_64 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4a5330183b5e1bb6b77d1d8d817a343/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caa2862cad329102ce7fb159a341e8cd/" rel="bookmark">
			TCP连接的三次握手过程（SYN报文的学习）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SYN报文的全称是"SYNchronize"报文。在TCP协议中，SYN是一个标志位（Flag），用于在建立TCP连接时进行同步步骤。TCP是一种面向连接的协议，建立连接时需要进行"三次握手"过程，而SYN报文在这个过程中起着关键的作用。
在进行TCP连接时的三次握手过程如下：
第一步（客户端发送SYN）：客户端向服务器发送一个带有SYN标志的TCP报文，该报文中不包含实际数据，只有TCP头部，用于通知服务器客户端想要建立连接。
第二步（服务器发送SYN+ACK）：服务器收到客户端的SYN报文后，会回复一个带有SYN和ACK（确认）标志的TCP报文。这个报文也不包含实际数据，只有TCP头部，用于告知客户端服务器接收到了连接请求，并表示自己也想要建立连接。
第三步（客户端发送ACK）：最后，客户端收到服务器的SYN+ACK报文后，会发送一个带有ACK标志的TCP报文给服务器，这个报文也不包含实际数据，只有TCP头部。服务器收到这个报文后，连接就建立起来了，双方可以开始进行数据传输。
整个三次握手过程就是通过SYN报文来确保客户端和服务器之间的连接同步建立的。这种同步建立连接的过程可以有效地确保数据的可靠传输和连接的稳定性。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/30/">«</a>
	<span class="pagination__item pagination__item--current">31/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/32/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>