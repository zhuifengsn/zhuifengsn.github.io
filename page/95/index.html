<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50af0b88be1f8273ac588ee7ebba4711/" rel="bookmark">
			cpp 运算符与结合性速记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cpp 运算符与结合性速记 元其二一移
大等位逻三
赋逗，其三赋
解释如下：
优先级分为15级：
1：（谐音 元）
[] 数组下标(元素下标)
() 圆括号
. -&gt; 成员
2：其他
- 负号 (type) 类型强转
++ 自增 -- 自减
* 取值 &amp; 取地址
! 逻辑非 ~ 按位取反
sizeof 长度(字节数）
3：二（级）
/ 除 * 乘 % 取模
4：一（级）
+ 加法 -减法
5：(位)移
&lt;&lt; 左移 &gt;&gt; 右移
6：大小
&gt;大于 &gt;= 大于等于
&lt;小于 &lt;= 小于等于
7：等于
== 等于 != 不等于
8：位(运算)
&amp; 按位与
^ 按位异或
| 按位或
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50af0b88be1f8273ac588ee7ebba4711/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e8b9cb5ee7bc21004491f4186944cc3/" rel="bookmark">
			VMware虚拟化客户机安装vmtools软件提示需要安装补丁KB2919335
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMware的esxi版本6.5以上安装不是最新版的操作系统需要安装KB2919335的补丁才能安装vmwaretools。
针对Windows Server 2012 需要打补丁，安装最新版的操作系统例如Windows Server 2019不需要。
打了补丁之后才能安装vmtools或者vmrc工具。
先安装这个KB2919442补丁
微软下载链接地址:https://www.microsoft.com/zh-cn/download/details.aspx?id=42135
然后安装KB2919335
微软官方下载地址:https://www.microsoft.com/zh-cn/download/details.aspx?id=42135
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/620a2869095a1a6dead0d806edff6b7e/" rel="bookmark">
			GTest基础学习-06-第6个单元测试-接口测试(类型参数驱动)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面的文章学习了使用gtest进行函数级的测试和类级的测试，这篇来学习如何通过gtest来测试接口。这个接口我们在prime_table.h中，接口的头和实现部分都放置同一个文件，这个文件也在sample文件夹下。这篇学习第6个单元测试，介绍如何测试一个接口有多种实现，而且没种实现都要单元测试，做到测试代码不重复。本篇新引入了几个宏，有一些模板函数的思想，加上新的测试宏，看起来有费劲，不易理解和掌握。这个知识点比前面学习都要高级的特性和复杂。
1.代码准备
prime_table.h代码
#ifndef GTEST_SAMPLES_PRIME_TABLES_H_ #define GTEST_SAMPLES_PRIME_TABLES_H_ #include &lt;algorithm&gt; // prime table 接口 class PrimeTable { public: virtual ~PrimeTable() {} // 只有n是素数返回true virtual bool IsPrime(int n) const = 0; // 返回比P大的最小的素数 // 如果下一个素数超出表的容量，就返回-1 virtual int GetNextPrime(int p) const = 0; }; // 实现 #1 实时计算素数 class OnTheFlyPrimeTable : public PrimeTable { public: bool IsPrime(int n) const override { if (n &lt;= 1) return false; for (int i = 2; i*i &lt;= n; i++) { if ((n % i) == 0) return false; } return true; } int GetNextPrime(int p) const override { for (int n = p + 1; n &gt; 0; n++) { if (IsPrime(n)) return n; } return -1; } }; // 实现 #2 预计算素数并存储结果到一个数组 class PreCalculatedPrimeTable : public PrimeTable { public: // max用来指定素数表最大数 explicit PreCalculatedPrimeTable(int max) : is_prime_size_(max + 1), is_prime_(new bool[max + 1]) { CalculatePrimesUpTo(max); } ~PreCalculatedPrimeTable() override { delete[] is_prime_; } bool IsPrime(int n) const override { return 0 &lt;= n &amp;&amp; n &lt; is_prime_size_ &amp;&amp; is_prime_[n]; } int GetNextPrime(int p) const override { for (int n = p + 1; n &lt; is_prime_size_; n++) { if (is_prime_[n]) return n; } return -1; } private: void CalculatePrimesUpTo(int max) { ::std::fill(is_prime_, is_prime_ + is_prime_size_, true); is_prime_[0] = is_prime_[1] = false; // 检查每一个候选的素数 (我们知道2是素数中唯一的偶数 for (int i = 2; i*i &lt;= max; i += i % 2 + 1) { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/620a2869095a1a6dead0d806edff6b7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c6c3f47047088d8f61d2fc42b324404/" rel="bookmark">
			hdu 2074 叠框（排版题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		叠筐 Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 32762 Accepted Submission(s): 8674
Problem Description 需要的时候，就把一个个大小差一圈的筐叠上去，使得从上往下看时，边筐花色交错。这个工作现在要让计算机来完成，得看你的了。 Input 输入是一个个的三元组，分别是，外筐尺寸n（n为满足0&lt;n&lt;80的奇整数），中心花色字符，外筐花色字符，后二者都为ASCII可见字符； Output 输出叠在一起的筐图案，中心花色与外筐花色字符从内层起交错相叠，多筐相叠时，最外筐的角总是被打磨掉。叠筐与叠筐之间应有一行间隔。 Sample Input 11 B A 5 @ W Sample Output AAAAAAAAA ABBBBBBBBBA ABAAAAAAABA ABABBBBBABA ABABAAABABA ABABABABABA ABABAAABABA ABABBBBBABA ABAAAAAAABA ABBBBBBBBBA AAAAAAAAA @@@ @WWW@ @W@W@ @WWW@ @@@ Author qianneng Source 浙江工业大学网络选拔赛 Recommend linle | We have carefully selected several similar problems for you: 2072 2091 1096 1093 1092 题目的主要考点在于排版，这里如果直接输出的话由于两种字符串交替，相当麻烦，因此采用先排版，再输出的方法（详细讲解见王道机试指南）。 处理的时候先按照每层循环，从外向内，然后每层分为上下左右四条直线进行循环。 #include&lt;iostream&gt; #include&lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c6c3f47047088d8f61d2fc42b324404/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f63f0b928de74ee598354ee347e8525/" rel="bookmark">
			遗传算法的Python实现（非线性函数优化问题为例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、遗传算法（GA）介绍 遗传算法（Genetic Algorithm，GA）最早是由美国的 John holland于20世纪70年代提出,该算法是根据大自然中生物体进化规律而设计提出的，是一种通过模拟自然进化过程搜索最优解的方法。
该算法通过数学的方式,利用计算机仿真运算,将问题的求解过程转换成类似生物进化中的染色体基因的交叉、变异等过程。在求解较为复杂的组合优化问题时,相对一些常规的优化算法,通常能够较快地获得较好的优化结果。遗传算法已被人们广泛地应用于组合优化、机器学习、信号处理、自适应控制和人工生命等领域。
（一）遗传算法流程： （二）基本操作： （1）编码
用于将要解答的问题编码成染色体信息，便于后续运算编码方式： 位串编码（二进制/Gray编码，存在搜索效率低的问题）实数编码（较为常用） （2）适应度函数的尺度变换
欺骗问题：函数值之间的差异太小，导致过早收敛解决方案：尺度变换 线性变换（f’ = af + b）幂函数变换（f’ = f ^ k）指数变换（f’ = e ^ (-af)） （3）选择
根据适应度进行染色体串的选择，适应度越高的染色体串被选上的概率越大（不是一定选上，可以解决牛顿下降法容易收敛到局部最优的缺点）个体选择的概率分配方法 适应度比例（蒙特卡洛法）：个体适应度 / 总体适应度之和排序法：分为线性排序和指数排序，后者可以扩大排名在前和在后的个体间的差距 （4）交叉
对两条染色体进行交叉操作基本的交叉算子 一点交叉：选择一个位点，将两条染色体在该位点后的片段进行交叉两点/多点交叉：选择多个位点，将位点间的片段进行交叉部分匹配交叉：用于旅行商问题等 （5）变异
对染色体的某个基因进行变异变异方式 位点变异：某个/每个位点以一定概率变异逆转变异：随机选两点，将两点间的基因逆序插入变异：随机选一个基因插入随机的插入点间互换变异：随机选两个基因进行简单互换移动变异：将某个基因向左/右移动随机位数 2、Python实现（非线性函数最优化问题为例） （1）定义适应度函数
import math def func(x, y): num = 6.452 * (x + 0.125 * y) * (math.cos(x) - math.cos(2 * y)) ** 2 den = math.sqrt(0.8 + (x - 4.2) ** 2 + 2 * (y - 7) ** 2) return num / den + 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f63f0b928de74ee598354ee347e8525/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53a75ac8fb9b19b2921a915163de89f1/" rel="bookmark">
			GTest基础学习-05-第5个单元测试-父test fixture和子test fixture的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇来学习Gtest官方示例中的第5个，为什么直接跳过第4个，因为第四个是测试一个简单的计数器，看了下单元测试内容，没有新的知识点，就一个TEST,里面使用了连续3 4个EXPECT_TRUE断言宏。完全没有任何新的知识点，就不再介绍第4个例子，直接来看第五个。第五个是介绍test fixture可以通过继承使用父类中的测试夹具。
1.场景
这个例子教我们如何在多个测试用例中复用测试夹具：通过派生子夹具。当你定义好了一个测试夹具，你指定一个测试用例使用这个测试夹具。一个测试夹具只能被一个测试用例使用。某些时候，更多的测试用例希望使用相同或有一点不同的测试夹具。例如，你可能想要确保GUI库的所有测试都不会泄漏系统资源，例如字体和画笔。在Gtest中，你可以这样做，把共享逻辑放入一个超类的测试夹具中。每个测试用例使用到的测试夹具从这个超类中派生。
不同的测试用例如果是共同的数据和逻辑，直接从父类继承就好，如果有需要不同的，可以通过重写父类的SetUp()或者TearDown()方法。
2.第5个示例
第五个示例没有单独的头文件和实现文件，测试文件都是测试sample01和sample03中的内容。
TestSample05.cpp
#include &lt;limits.h&gt; #include &lt;time.h&gt; #include "gtest/gtest.h" #include "sample01.h" #include "sample03.h" namespace { // 在这次示例中, 我们要确保每个测试必须在5秒内结束 //如果有超过5秒，我们把这个测试判为失败 // // 我们把在测试夹具中计算代码运行时间叫做"QuickTest". QuickTest 被设计为一个超夹具类，这样其他夹具可以从这个类派生. // // 之后，我们将从QuickTest派生多个测试夹具类 class QuickTest : public testing::Test { protected: // 提醒一下：SetUp() 是在一个test执行之前就会执行 // 这是一个好地方去记录开始时间 void SetUp() override { start_time_ = time(nullptr); } // TearDown() 是在每个测试执行结束之后才会被执行. // 这里我们检查下这个测试是不是运行太慢（大于5秒） void TearDown() override { // 当测试结束获取结束时间 const time_t end_time = time(nullptr); // 断言测试运行没有超过5秒.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53a75ac8fb9b19b2921a915163de89f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec76cbf8e7437b4535dfc11a10214beb/" rel="bookmark">
			GTest基础学习-04-第3个单元测试-测试夹具test fixture
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇来学习一下Gtest中更高级一些的特性test fixture，测试夹具的基本上使用。什么的场景需要使用到测试夹具呢？测试夹具是哪个宏，这篇来学习这个主题。
1.什么叫test fixture
什么是测试夹具，这个概念在任何xUnit系列的单元测试框架都会出现。一般是指，所有的测试用例都可以共享的步骤，例如初始化和事后清理操作，能提供这个功能的对象叫test fixture。
在test fixture是这样使用的，我们需要单独写一个类并且继承testing::Test，如果有必要都需要实现SetUp()和TearDown()函数，当然这两个至少有一个需要实现，不然我们不会去使用test fixture这个功能。在SetUp()函数中一般写一些初始化操作，例如测试对象的创建，对象的成员变量的初始化等，在TearDown()一般用来集中清除资源操作，例如销毁在SetUp()中创建的被测试对象。
2.测试夹具使用
sample03.h代码
#ifndef GTEST_SAMPLES_SAMPLE03_INL_H_ #define GTEST_SAMPLES_SAMPLE03_INL_H_ #include &lt;stddef.h&gt; // Queue类是一个简单的队列，内部是基于单链表实现 // // 元素数据类型必须支持拷贝构造 template &lt;typename E&gt; // E 是元素的类型。使用了模板类 class Queue; // QueueNode 是Queue对象中的一个结点, 存储元素E和指向下一个结点的指针 template &lt;typename E&gt; // E 是元素的类型。使用了模板类 class QueueNode { friend class Queue&lt;E&gt;; public: // 获取结点中的元素 const E&amp; element() const { return element_; } // 获取下一个结点 QueueNode* next() { return next_; } const QueueNode* next() const { return next_; } private: // 创建一个结点，元素是参数element，下一个结点的指针设置为NULL explicit QueueNode(const E&amp; an_element) : element_(an_element), next_(nullptr) {} // 这里禁用默认的赋值操作和构造 const QueueNode&amp; operator = (const QueueNode&amp;); QueueNode(const QueueNode&amp;); E element_; QueueNode* next_; }; template &lt;typename E&gt; // E 是可以任意类型 class Queue { public: // 创建一个空的队列 Queue() : head_(nullptr), last_(nullptr), size_(0) {} // 析构函数 清空队列 ~Queue() { Clear(); } // 清空队列函数 void Clear() { if (size_ &gt; 0) { // 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec76cbf8e7437b4535dfc11a10214beb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/501170a1d530233f00de9792357cd8ea/" rel="bookmark">
			PTA 检查密码（java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1081 检查密码 (15分) 本题要求你帮助某网站的用户注册模块写一个密码合法性检查的小功能。该网站要求用户设置的密码必须由不少于6个字符组成，并且只能有英文字母、数字和小数点 .，还必须既有字母也有数字。
输入格式： 输入第一行给出一个正整数 N（≤ 100），随后 N 行，每行给出一个用户设置的密码，为不超过 80 个字符的非空字符串，以回车结束。
输出格式： 对每个用户的密码，在一行中输出系统反馈信息，分以下5种：
如果密码合法，输出Your password is wan mei.；
如果密码太短，不论合法与否，都输出Your password is tai duan le.；
如果密码长度合法，但存在不合法字符，则输出Your password is tai luan le.；
如果密码长度合法，但只有字母没有数字，则输出Your password needs shu zi.；
如果密码长度合法，但只有数字没有字母，则输出Your password needs zi mu.。
输入样例： 5
123s
zheshi.wodepw
1234.5678
WanMei23333
pass*word.6
输出样例： Your password is tai duan le.
Your password needs shu zi.
Your password needs zi mu.
Your password is wan mei.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/501170a1d530233f00de9792357cd8ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d92b94055a9e69895382a183551a61aa/" rel="bookmark">
			A*搜索算法的Python实现（八数码为例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、A*搜索算法介绍 A*搜寻算法，俗称A星算法，作为启发式搜索算法中的一种，这是一种在图形平面上，有多个节点的路径，求出最低通过成本的算法。常用于游戏中的NPC的移动计算，或线上游戏的BOT的移动计算上。
算法核心：
A*算法最为核心的部分，就在于它的一个估值函数的设计上：
f(n)=g(n)+h(n)
其中f(n)是每个可能试探点的估值，它有两部分组成：
g(n)：表示从起始搜索点到当前点的代价（通常用某结点在搜索树中的深度来表示）。h(n)：表示启发式搜索中最为重要的一部分，即当前结点到目标结点的估值，h(n)设计的好坏，直接影响着具有此种启发式函数的启发式算法的是否能称为A*算法。 一种具有f(n)=g(n)+h(n)策略的启发式算法能成为A*算法的充分条件是：
1、搜索树上存在着从起始点到终了点的最优路径。
2、问题域是有限的。
3、所有结点的子结点的搜索代价值&gt;0。
4、h(n)=&lt;h*(n) （h*(n)为实际问题的代价值）。
当此四个条件都满足时，一个具有f(n)=g(n)+h(n)策略的启发式算法能成为A*算法，并一定能找到最优解。
算法流程：
首先将起始结点S放入OPEN表，CLOSE表置空，算法开始时：
1、如果OPEN表不为空，从表头取一个结点n，如果为空算法失败。
2、n是目标解吗？是，找到一个解（继续寻找，或终止算法）。
3、将n的所有后继结点展开，就是从n可以直接关联的结点（子结点），如果不在CLOSE表中，就将它们放入OPEN表，并把S放入CLOSE表，同时计算每一个后继结点的估价值f(n)，将OPEN表按f(x)排序，最小的放在表头，重复算法，回到1
2、Python实现（以八数码为例） 首先定义初始数码状态与目标数码状态：
a = [[1, 3, 4], [2, 6, 0], [7, 5, 8]] b = [[3, 0, 2], [6, 1, 5], [8, 7, 4]] 需要注意的是，初始状态与目标状态序列的逆序对数需要同奇偶，例如a的逆序对数为4，b为10，同为偶，这样可以保证有解。然后我们定义AStar类，在初始化函数中接受S0（初始状态）和G（目标状态），获取行列等信息，然后初始化g(n)、访问过的节点数nodes以及open表和close表。
class AStar: def __init__(self, S0, G): self.S0 = S0 self.G = G self.max_row = len(S0) self.max_col = len(S0[0]) self.gn = 0 self.nodes = 0 self.close_list = {'Sn': [S0], 'gn': [0], 'hn': [self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d92b94055a9e69895382a183551a61aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67ceb0e09dbc17061318d035cbec8eeb/" rel="bookmark">
			查询水果价格 (15分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定四种水果，分别是苹果（apple）、梨（pear）、桔子（orange）、葡萄（grape），单价分别对应为3.00元/公斤、2.50元/公斤、4.10元/公斤、10.20元/公斤。
首先在屏幕上显示以下菜单：
[1] apple
[2] pear
[3] orange
[4] grape
[0] exit
用户可以输入编号1~4查询对应水果的单价。当连续查询次数超过5次时，程序应自动退出查询；不到5次而用户输入0即退出；输入其他编号，显示价格为0。
输入格式:
输入在一行中给出用户连续输入的若干个编号。
输出格式:
首先在屏幕上显示菜单。然后对应用户的每个输入，在一行中按格式“price = 价格”输出查询结果，其中价格保留两位小数。当用户连续查询次数超过5次、或主动输入0时，程序结束。
输入样例1:
3 -1 0 2
输出样例1:
[1] apple
[2] pear
[3] orange
[4] grape
[0] exit
price = 4.10
price = 0.00
输入样例2:
1 2 3 3 4 4 5 6 7 8
输出样例2:
[1] apple
[2] pear
[3] orange
[4] grape
[0] exit
price = 3.00
price = 2.50
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67ceb0e09dbc17061318d035cbec8eeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14c528a77c309dd6a20843094af7fe48/" rel="bookmark">
			ClickHouse &amp; OLAP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		install docker installconnect by DBeaver connect error: cannot create driver instance 原因：DBeaver下载ClickHouse驱动失败解决方法：增加国内源的maven地址。窗口-&gt;首选项-&gt;DBeaver-&gt;驱动 -&gt; Maven。添加阿里云的maven地址http://maven.aliyun.com/nexus/content/groups/public/，并将其移到最上面，再次下载ok
语法 SQL语法官网文档 数据同步 MySQL 数据库同步 clickhouse创建db clickhouse db
CREATE database test_db;clickhouse db of MySQL engin
CREATE DATABASE db_name ENGINE = MySQL('ip:port', 'db_name', 'user_name', 'passwd') clickhouse创建table。查看clickhouse数据类型：select * from system.data_type_families where case_insensitive=1;同步
insert into test_db.test select * from mysql_db.test1 t优势 操作简单外表 劣势 当MySQL表数据量比较大时，很容易出现timeout无法增量导入数据在复杂查询中，特别是有JOIN的情况下，访问外表是相当慢的，甚至不可能完成 基于Altinity的工具 安装clickhouse-mysql: pip install clickhouse-mysql同步：cmd 或 shell下执行 clickhouse-mysql --src-host=mysql_ip --src-port=mysql_port --src-user=mysql_user --src-password=mysql_pwd --migrate-table --src-schema=mysql_schema --src-tables=mysql_table --src-tables-where-clauses="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14c528a77c309dd6a20843094af7fe48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ed50e44e88efafd2447ca2d9bcd87f6/" rel="bookmark">
			树莓派利用socket传图到pc端（Python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.PC作为socket的服务器端： import socket import os import sys import struct def socket_service(): try: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) #IP地址留空默认是本机IP地址 s.bind(('', 8088)) s.listen(7) except socket.error as msg: print(msg) sys.exit(1) print("连接开启，等待传图...") while True: sock, addr = s.accept() deal_data(sock, addr) s.close() def deal_data(sock, addr): print("成功连接上 {0}".format(addr)) while True: fileinfo_size = struct.calcsize('128sl') buf = sock.recv(fileinfo_size) if buf: filename, filesize = struct.unpack('128sl', buf) fn = filename.decode().strip('\x00') #PC端图片保存路径 new_filename = os.path.join('C:/Users/user/Desktop', fn) recvd_size = 0 fp = open(new_filename, 'wb') while not recvd_size == filesize: if filesize - recvd_size &gt; 1024: data = sock.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ed50e44e88efafd2447ca2d9bcd87f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f1dc44507734eaf4f46633381d08d53/" rel="bookmark">
			树莓派上设置程序开机自启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：向rc.local文件添加启动代码 修改rc.local文件：
sudo nano /etc/rc.local 在打开的rc.local找到exit 0，在exit 0 之前添加一行代码：
#双引号里面是程序的路径 su pi -c "exec /home/pi/test.sh" ctrl+x，再点y保存退出，然后在终端输入：sudo reboot ,重启系统测试。执行这段代码时是使用root用户权限的，注意当前的用户权限，以免因权限问题导致脚本执行失败。
方法二：将程序作为服务启动 在/etc/init.d/目录下新建一个服务脚本文件：
#start_test是启动服务文件的名称，自定义 sudo nano /etc/init.d/start_test #!/bin/bash ### BEGIN INIT INFO # Provides: Auto_Start_Test # Required-Start: $remote_fs # Required-Stop: $remote_fs # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 # Short-Description: Auto Start Test # Descrption: This service is used to test auto start service ### END INIT INFO case "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f1dc44507734eaf4f46633381d08d53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc653e84d3b4e70a579fbcc75873aec7/" rel="bookmark">
			bootargs和bootcmd含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 bootargs=console=ttySAC2,115200 root=/dev/mmcblk0p2 rw init=/linuxrc rootfstype=ext3 console=ttySAC2 控制台是串口2 115200 波特率是115200 root=/dev/mmcblk0p2 根文件系统在SD卡端口0设备第二分区 rw 根文件系统为可读可写 init=/linuxrc linux进程1（init进程）路径 rootfstype=ext3 根文件系统的类型是ext3 bootcmd=movi read kernel 30008000; bootm 30008000 bootcmd=movi read kernel 30008000 将kernel读取到0x30008000地址处 bootm 30008000 从0x30008000地址处启动内核 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ace3e95cc4a08541b858f58362e9174/" rel="bookmark">
			Linux Centos7安装Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 Redis 5 一、安装gcc依赖
由于 redis 是用 C 语言开发，安装之前必先确认是否安装 gcc 环境（gcc -v），如果没有安装，执行以下命令进行安装
[root@localhost local]# yum install -y gcc
二、下载并解压安装包
[root@localhost local]# wget http://download.redis.io/releases/redis-5.0.3.tar.gz
[root@localhost local]# tar -zxvf redis-5.0.3.tar.gz
三、cd切换到redis解压目录下，执行编译
[root@localhost local]# cd redis-5.0.3
[root@localhost redis-5.0.3]# make
四、安装并指定安装目录
[root@localhost redis-5.0.3]# make install PREFIX=/usr/local/redis
五、启动服务
5.1前台启动
[root@localhost redis-5.0.3]# cd /usr/local/redis/bin/
[root@localhost bin]# ./redis-server
5.2后台启动
从 redis 的源码目录中复制 redis.conf 到 redis 的安装目录
[root@localhost bin]# cp /usr/local/redis-5.0.3/redis.conf /usr/local/redis/bin/
修改 redis.conf 文件，把 daemonize no 改为 daemonize yes
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ace3e95cc4a08541b858f58362e9174/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3dc875f7dc806d6cc68007b7f7fc23a/" rel="bookmark">
			docker部署项目时 时间相差8小时问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用镜像创建容器的时候加上
-v /etc/localtime:/etc/localtime -v /etc/timezone:/etc/timezone&gt; 复制代码
表示启用宿主机的时区， 问题解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6c65bbdfbb462ecdd93594b488036dd/" rel="bookmark">
			Transactional注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加readonly=true 在一个事物里如果有多个查询sql，可能出现前后查询的数据不一至，如果添加redonly=true，就可以避免这种情况
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b48afe75157ac25445fef003b1673a01/" rel="bookmark">
			js实现绑定多个按钮并当点击某个按钮时改按钮颜色改变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;script&gt; var btns = document.getElementsByTagName('button'); for (var i = 0; i &lt; btns.length; i++) { btns[i].onclick=function () { console.log(i); for (var j=0;j&lt;btns.length;++j){ btns[j].style.backgroundColor=''; } this.style.backgroundColor='pink'; } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28e6bc153be0637bd9cdd5d28bd10bac/" rel="bookmark">
			pandas中Dataframe索引.ix,.iloc,.loc的使用以及区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pandas中Dataframe索引.ix,.iloc,.loc的使用以及区别
https://blog.csdn.net/qq1483661204/article/details/77587881
Pandas——loc、iloc、ix 函数区别
https://blog.csdn.net/u012736685/article/details/86610946
https://lavi-liu.blog.csdn.net/article/details/78241530
pandas学习笔记5—DataFrame数据筛选loc，iloc，ix，at，iat
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4014089775f26a85dfa82667c36698d/" rel="bookmark">
			【MySQL】如何将csv文件导入到mysql数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【MySQL】如何将csv文件导入到mysql数据库
转自:https://blog.csdn.net/unsicherheit/article/details/89712797
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/94/">«</a>
	<span class="pagination__item pagination__item--current">95/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/96/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>