<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f32782fb5035aab8ed6bb747a17d11e/" rel="bookmark">
			Android Studio初学者实例：SharedPreferences 登录/注册模块实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该实验是紧接上一期使用SP登录、记住密码的实验，主要实现是除了上次登陆以外，登录以后在主界面有一系列假数据，可以通过右上角进行排序选择，以下是实验效果：
示例：好友名排序效果
首先是登陆界面以及逻辑代码，在逻辑代码中实现记住密码（勾选选择框后）
activity_login3.xml
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#E6E6E6" android:orientation="vertical" android:padding="10dp"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginTop="15dp" android:background="@android:color/white" android:orientation="horizontal"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:padding="10dp" android:text="账号:" android:textColor="#000" android:textSize="20sp" /&gt; &lt;EditText android:id="@+id/et_account" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginLeft="5dp" android:background="@null" android:padding="10dp" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginTop="10dp" android:background="@android:color/white" android:orientation="horizontal"&gt; &lt;TextView android:id="@+id/tv_password" android:layout_width="wrap_content" android:layout_height="wrap_content" android:padding="10dp" android:text="密码:" android:textColor="#000" android:textSize="20sp" /&gt; &lt;EditText android:id="@+id/et_password" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginLeft="5dp" android:background="@null" android:inputType="textPassword" android:padding="10dp" /&gt; &lt;/LinearLayout&gt; &lt;CheckBox android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="记住密码" android:id="@+id/cb"/&gt; &lt;LinearLayout android:layout_width="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f32782fb5035aab8ed6bb747a17d11e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b25333d6d5bad72766b9f5187651e4a7/" rel="bookmark">
			WPF Dispatcher使用invoke，程序进入死锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两个后台线程中使用同一个Dispatcher invoke进行dialog展示，其中dialog中设置定时关闭窗口，这时会导致进入死锁状态
调用dialog代码：
Dispatcher dispatcher = Application.Current.Dispatcher; Task.Run(() =&gt; { dispatcher.Invoke(() =&gt; { _dialogService.ShowDialog("VerifyDialog", new DialogParameters(), null); }); }); Task.Run(() =&gt; { dispatcher.Invoke(() =&gt; { _dialogService.ShowDialog("VerifyDialog", new DialogParameters(), null); }); }); dialog定时关闭代码：
public async void AutoCloseDialog() { await Task.Delay(1000); RequestClose?.Invoke(new DialogResult(ButtonResult.None)); } Dispatcher 改成InvokeAsync并等待无效果，同样会进入死锁
Dispatcher dispatcher = Application.Current.Dispatcher; Task.Run(() =&gt; { dispatcher.InvokeAsync(() =&gt; { _dialogService.ShowDialog("VerifyDialog", new DialogParameters(), null); }).Wait(); }); Task.Run(() =&gt; { dispatcher.InvokeAsync(() =&gt; { _dialogService.ShowDialog("VerifyDialog", new DialogParameters(), null); }).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b25333d6d5bad72766b9f5187651e4a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abac7b32cd2e0e01c55aa48c79ec7714/" rel="bookmark">
			2023年Redis面试题（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 redis基础redis 中的数据类型有哪些为什么说redis能够快速执行 2 Redis中的五种数据结构string (字符串)list (列表)set (集合)hash (哈希)zset (有序集合) 3 Redis的持久化Redis 的持久化机制Redis 持久化方案的建议Redis 持久化方案的优缺点 4 缓存穿透、缓存击穿、缓存雪崩解决方案缓存穿透缓存击穿缓存雪崩 5 Redis 的集群模式主从复制哨兵模式 6 Redis分布式锁使用过Redis分布式锁么，它是什么回事？红锁 7 一些问题内存淘汰机制Redis 和 Mysql 的数据不一致怎么办Redis常见性能问题和解决方案：mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？项目中有没有用Redis事务布隆过滤器redis 跳表原理一致性hash算法 8 参考 1 redis基础 redis 中的数据类型有哪些 Redis 有 5 种基础数据结构，分别为：string (字符串)、list (列表)、set (集合)、hash (哈希) 和 zset (有序集合)。
Redis 的列表相当于 Java 语言里面的 LinkedList，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)，这点让人非常意外。 当列表弹出了最后一个元素之后，该数据结构自动被删除，内存被回收。
Redis 的哈希相当于 Java 语言里面的 HashMap，它是无序字典。内部实现结构上同 Java 的 HashMap 也是一致的，同样的数组 + 链表二维结构。第一维 hash 的数组位置碰撞时，就会将碰撞的元素使用链表串接起来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abac7b32cd2e0e01c55aa48c79ec7714/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e449277236cdc396970867888150fba4/" rel="bookmark">
			互联网公司mysql采用读已提交的隔离级别原因(详细)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4开始我们的内容，相信大家一定遇到过下面的一个面试场景：
面试官：“讲讲mysql有几个事务隔离级别？”
你：“读未提交，读已提交，可重复读，串行化四个！默认是可重复读”
面试官：“为什么mysql选可重复读作为默认的隔离级别？”
(你面露苦色，不知如何回答！)
面试官:"你们项目中选了哪个隔离级别？为什么？"
你：“当然是默认的可重复读，至于原因。。呃。。。”
(然后你就可以回去等通知了！)
对于这个问题 我是用ChatGPT3.5版本的进行咨询了一下:
得到的回复是：
互联网公司采用“读已提交”（read committed）隔离级别的原因有以下几点：
1：保证数据一致性和可靠性：在多用户并发访问数据库时，不同用户可能会同时对同一条数据进行读写操作。如果隔离级别过低，会导致脏读、不可重复读或幻读等数据不一致问题。而“读已提交”隔离级别可以避免这些问题的发生，保证数据的一致性和可靠性。
2：提高并发性能：互联网公司通常面临高并发的情况，如果采用较高的隔离级别（如可重复读或串行化），则会限制并发性能。而“读已提交”隔离级别相对较低，可以提高并发性能。
3：支持实时性要求高的业务场景：互联网公司往往需要支持实时性要求高的业务场景，比如在线支付等。采用“读已提交”隔离级别可以保证事务的及时提交和读取，实现实时性要求高的业务场景。
4：减少锁竞争：采用“读已提交”隔离级别可以减少锁的竞争，提高查询效率。
综上所述，“读已提交”隔离级别可以满足互联网公司高并发、实时性要求高以及数据一致性和可靠性等多重需求，因此被广泛采用。
当然这也只是一个很官方的回答，下面是我查询到的一些解答！！！ 这个是有历史原因的，当然要从我们的主从复制开始讲起了！
主从复制，是基于什么复制的？
是基于binlog复制的！这里不想去搬binlog的概念了，就简单理解为binlog是一个记录数据库更改的文件吧～
binlog有几种格式？
OK，三种，分别是
statement:记录的是修改SQL语句row：记录的是每行实际数据的变更mixed：statement和row模式的混合 那Mysql在5.0这个版本以前，binlog只支持STATEMENT这种格式！而这种格式在读已提交(Read Commited)这个隔离级别下主从复制是有bug的，因此Mysql将可重复读(Repeatable Read)作为默认的隔离级别！
接下来，就要说说当binlog为STATEMENT格式，且隔离级别为读已提交(Read Commited)时，有什么bug呢？如下图所示，在主(master)上执行如下事务
此时在主(master)上执行下列语句
select * from test； 输出如下:
+---+ | b | +---+ | 3 | +---+ 1 row in set 但是，你在此时在从(slave)上执行该语句，得出输出如下:
Empty set 这样，你就出现了主从不一致性的问题！原因其实很简单，就是在master上执行的顺序为先删后插！而此时binlog为STATEMENT格式，它记录的顺序为先插后删！从(slave)同步的是binglog，因此从机执行的顺序和主机不一致！就会出现主从不一致！
如何解决 解决方案有两种！
(1)隔离级别设为可重复读(Repeatable Read),在该隔离级别下引入间隙锁。当Session 1执行delete语句时，会锁住间隙。那么，Ssession 2执行插入语句就会阻塞住！
(2)将binglog的格式修改为row格式，此时是基于行的复制，自然就不会出现sql执行顺序不一样的问题！奈何这个格式在mysql5.1版本开始才引入。因此由于历史原因，mysql将默认的隔离级别设为可重复读(Repeatable Read)，保证主从复制不出问题！
那么，当我们了解完mysql选可重复读(Repeatable Read)作为默认隔离级别的原因后，接下来我们将其和读已提交(Read Commited)进行对比，来说明为什么在互联网项目为什么将隔离级别设为读已提交(Read Commited)！
对比 ok，我们先明白一点！项目中是不用读未提交(Read UnCommitted)和串行化(Serializable)两个隔离级别，原因有二
采用读未提交(Read UnCommitted),一个事务读到另一个事务未提交读数据，这个不用多说吧，从逻辑上都说不过去！采用串行化(Serializable)，每个次读操作都会加锁，快照读失效，一般是使用mysql自带分布式事务功能时才使用该隔离级别！(笔者从未用过mysql自带的这个功能，因为这是XA事务，是强一致性事务，性能不佳！互联网的分布式方案，多采用最终一致性的事务解决方案！) 也就是说，我们该纠结都只有一个问题，究竟隔离级别是用读已经提交呢还是可重复读？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e449277236cdc396970867888150fba4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbf27157ba3e471741260af501ef72d5/" rel="bookmark">
			MacOS中Notion挂代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原理 Notion mac端的桌面应用程序属于electron程序
参考 How do I get system wide proxy settings and apply the same for my electron app?
只需要启动的时候加入--proxy-server=[host:port]就可以使用代理。
操作步骤 1. 进入到Notion的启动文件目录 法1：在应用程序中右击Notion显示包内容，进入Contents/MacOS
法2：直接cd cd /Applications/Notion.app/Contents/MacOS
2. 将原来的Notion启动文件改名 mv Notion Notion_ 3. 重新创建一个Notion文件 vim Notion 写入以下内容
#!/bin/bash cd /Applications/Notion.app/Contents/MacOS ./Notion_ --proxy-server="127.0.0.1:7890" 4. 赋予执行权限 chmod +x Notion 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b09c0277511ae8419cdeab160091ecdb/" rel="bookmark">
			HarmonyOS应用开发者基础认证考试(90分过)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此博文为HarmonyOS应用开发者基础认证考试的最后的大考，要求100分取得90分方可获取证书、现将考试的题库进行分享，希望能帮到大家。但是需要注意的是，题库会不定时的进行题目删减，但是大概的内容是不会进行改变的。真心希望这篇博文能帮助到大家！！！
判断题 1.Ability是系统调度应用的最小单元，是能够完成一个独立功能的组件。一个应用可以包含一个或多个Ability。(正确)
2.Tabs组件仅可包含子组件TabsContent，每一个页签对应一个内容视图即TabContet组件。(正确)
3.使用http模块发起网络请求时，必须要使用on(‘headersReceive’）订阅请求头，请求才会成功。(错误)
4.Web组件对于所有的网页都可以使用zoom(factor: number)方法进行缩放。(错误)
5.首选项preferences是以Key-Value形式存储数据，其中Key是可以重复。(错误)
6.每一个自定义组件都有自己的生命周期。(正确)
7.在Column和Row容器组件中，justifyContent用于设置子组件在主轴方向上的对齐格式，alignItems用于设置子组件在交叉轴方向上的对齐格式。(正确)
8.@CustomDialog装饰器用于装饰自定义弹窗组件，使得弹窗可以动态设置内容及样式。(正确)
9.所有使用@Component修饰的自定义组件都支持onPageShow，onBackPress和onPageHide生命周期函数。(错误)
10.Video组件可以支持本地视频路径和网络路径播放。播放网络视频时，需要申请权限ohos.permission.INTERNET。(正确)
11.每调用一次router.pushUrl()方法，默认情况下，页面栈数量会加1，页面栈支持的最大页面数量为32。(正确)
单选题 12.使用Image组件加载网络图片需要如下哪种权限？(B)
A. ohos.permission.READ_MEDIA
B. ohos.permission.INTERNET
C. ohos.permission.GET_NETWORK_INFO
D. ohos.permission.DISTRIBUTED_DATASYNC
13.下面哪个方法，可以跳转到一个新页面，并销毁当前页面。(B)
A. router.pushUrl()
B. router.replaceUrl()
C. router.back()
D. router.clear()
14.用哪一种装饰器修饰的组件可作为页面入口组件？(B)
A. @Component
B. @Entry
C. @Preview
D. @Builder
15.下列哪种组合方式不能实现子组件从父子组件之间双向数据同步。(D)
A. @State和@Link
B. @Provide和@Consume
C. @Observed和@ObjectLink
D. @State和@Prop
16.关于容器组件Row和Column，下面说法错误的是：(D)
A. Column容器的主轴是垂直方向，交叉轴是水平方向；Row容器的主轴是水平方向，交叉轴是垂直方向。
B. 主轴和交叉轴始终是相互垂直的，Row和Column主轴的方向不一样。
C. Column的子组件在主轴方向上的对齐使用justifyContent属性来设置，其参数类型是FlexAlign。
D. Row的子组件在交叉轴方向上的对齐方式使用alignItems属性来设置，其参数类型为HorizontalAlign。
17.首选项preferences值的存储支持哪些数据类型？(D)
A. 数字型
B. 字符型
C. 布尔型
D. 数字型、字符型、布尔型以及这3种类型的数组类型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b09c0277511ae8419cdeab160091ecdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fcde6b2ef0807b212bc625a42ba8906/" rel="bookmark">
			给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一种是递归法：
public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); inorder(root, res); return res; } private void inorder(TreeNode root, List&lt;Integer&gt; res) { if (root == null) { return; } inorder(root.left, res); res.add(root.val); inorder(root.right, res); } 一种是迭代法：
public List&lt;Integer&gt; inorderTraversal(TreeNode root) { List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode curr = root; while (curr != null || !stack.isEmpty()) { while (curr != null) { stack.push(curr); curr = curr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fcde6b2ef0807b212bc625a42ba8906/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e49c902f8da83cc04b9786e1f6356893/" rel="bookmark">
			Linux系统优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、系统启动流程 1.centos6
centos6开机启动流程，传送门
2.centos7启动流程
二、系统启动运行级别
2.1 什么是运行级别
运行级别：指操作系统当前正在运行的功能级别；
[root@web01 ~]# ll /usr/lib/systemd/system lrwxrwxrwx. 1 root root 15 Aug 2 18:19 runlevel0.target -&gt; poweroff.target # 关机 lrwxrwxrwx. 1 root root 13 Aug 2 18:19 runlevel1.target -&gt; rescue.target # 单用户模式(修改密码) lrwxrwxrwx. 1 root root 17 Aug 2 18:19 runlevel2.target -&gt; multi-user.target lrwxrwxrwx. 1 root root 17 Aug 2 18:19 runlevel3.target -&gt; multi-user.target # 字符界面（最多的） lrwxrwxrwx. 1 root root 17 Aug 2 18:19 runlevel4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e49c902f8da83cc04b9786e1f6356893/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc665d967f9f8bf674a46e5d15563099/" rel="bookmark">
			HC小区物业管理系统部署过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文只部署了管理后台的前后端，小程序什么的没弄。
一、下载源码 MicroCommunity后台，clone后进入项目目录执行bash changeBootEnvLinux.sh，使用SpringBoot模式启动，然后mvn clean package，下载依赖。
MicroCommunity前端，clone后进入项目目录，修改app.js
app.use('/callComponent', proxy('http://127.0.0.1:8008', opts)); app.use('/app', proxy('http://127.0.0.1:8008', opts)); 二、docker安装数据库 2.1 mysql5.6安装 作者推荐mysql5.6，这边就用这个版本
docker pull mysql:5.6 docker run --name hc_mysql_5.6 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6 mysqld --lower_case_table_names=1 上面设置lower_case_tables_names是大小写不敏感，参考了链接，如果不设置，后续会出问题。
接着navicat就可以使用root和123456登录进去了。
2.2 redis安装 docker pull redis docker run --name hc_redis -p 6379:6379 --requirepass hc -d redis 三、载入mysql数据 ${后端项目的根目录}/docs/db中有两个sql文件
3.1 新建数据库 新建两个数据库
hc_communityTT 3.2 载入数据 用vscode打开hc_community.sql，把utf8mb4_0900_ai_ci替换为utf8mb4_general_ci，然后把这个sql载入到hc_community中。把TT.sql载入到TT中去。 3.3 创建user CREATE USER 'hc_community'@'%' IDENTIFIED BY 'hc_community@12345678'; CREATE USER 'TT'@'%' IDENTIFIED BY 'TT@12345678'; grant all PRIVILEGES on hc_community.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc665d967f9f8bf674a46e5d15563099/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b64cf02164c8ec10d0e6dee1c1bdccd/" rel="bookmark">
			RabbitMQ实现延迟消息居然如此简单，整个插件就完事了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RabbitMQ实现延迟消息的方式有两种，一种是使用死信队列实现，另一种是使用延迟插件实现。死信队列实现我们以前曾经讲过这次我们讲个更简单的，使用延迟插件实现。
插件安装
首先我们需要下载并安装RabbitMQ的延迟插件。
去RabbitMQ的官网下载插件，插件地址：https://www.rabbitmq.com/community-plugins.html
直接搜索rabbitmq_delayed_message_exchange即可找到我们需要下载的插件，下载和RabbitMQ配套的版本，不要弄错；
​
编辑
添加图片注释，不超过 140 字（可选）
将插件文件复制到RabbitMQ安装目录的plugins目录下；
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
进入RabbitMQ安装目录的sbin目录下，使用如下命令启用延迟插件；
rabbitmq-plugins enable rabbitmq_delayed_message_exchange
启用插件成功后就可以看到如下信息，之后重新启动RabbitMQ服务即可。
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
实现延迟消息
接下来我们需要在SpringBoot中实现延迟消息功能，这次依然沿用商品下单的场景。比如说有个用户下单了，他60分钟不支付订单，订单就会被取消，这就是一个典型的延迟消息使用场景。
首先我们需要在pom.xml文件中添加AMQP相关依赖；
&lt;!--消息队列相关依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt;
之后在application.yml添加RabbitMQ的相关配置；
spring: rabbitmq: host: localhost # rabbitmq的连接地址 port: 5672 # rabbitmq的连接端口号 virtual-host: /mall # rabbitmq的虚拟host username: mall # rabbitmq的用户名 password: mall # rabbitmq的密码 publisher-confirms: true #如果对异步消息需要回调必须设置为true
接下来创建RabbitMQ的Java配置，主要用于配置交换机、队列和绑定关系；
/** * 消息队列配置 * Created by macro on 2018/9/14.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b64cf02164c8ec10d0e6dee1c1bdccd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/859beae485c2cd3737a04f335dddd44d/" rel="bookmark">
			C&#43;&#43; 常用类型（auto、类型转换、decltype）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 类型转换 1.1 string转换成int、double、float等类型 基于c++11标准，&lt;string&gt;中已经封装好了对应的转换方法
#include&lt;string&gt; using namespace std;//添加名称空间 string d="123"; double num=stod(d);//string 转换double int num=stoi(d);//string 转换成int float num=stof(d);//string 转换成float long num=stol(d);//string 转换成long 2 auto C++ 引入auto 和decltype关键字实现类型推导。在C++11标准的语法中，auto被定义为自动推断变量的类型。auto可以在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型。
2.1使用原则 auto声明的变量必须要初始化，否则编译器不能判断变量的类型。这类似于const关键字。auto不能被声明为返回值，auto不能作为形参，auto不能被修饰为模板参数。 2.2 应用举例 int x = 0; auto * a = &amp;x;// a -&gt; int * ,auto 被推导为int auto b = &amp;x;// b -&gt; int * ,auto 被推导为int* auto &amp; c = x;// c -&gt; int &amp; ,auto 被推导为int auto d = c;//d -&gt; int,auto 被推导为int 当表达式是一个引用类型时，auto会把引用类型抛弃，直接推导成原始类型int const auto e = x; // e -&gt; const int ,auto 被推导为int auto f = e; // f -&gt; int ,auto 被推导为int,当表达式带有const属性时，auto会把const属性抛弃 const auto&amp; g = x;//g -&gt; const int&amp; ,auto 被推导为int 当auto 和引用结合时，auto的推导结果将保留表达式const属性 auto&amp; h = g;// h -&gt; const int&amp; ,auto 被推导为const int （1）在不声明为引用或指针时，auto会忽略等号右边的引用类型和const 和volatile限定。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/859beae485c2cd3737a04f335dddd44d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6e0739e6bdc9cc6748ef2eeea3bb9f4/" rel="bookmark">
			WB_BF项目问题说明以及探究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我就现在WB_BF项目群里面提到的“根据测试脚本运行日志来看，bf运行了约31小时后又开始出现了api调用返回nginx的错误信息。之后，bf客户端也无法打开。”问题做一下说明，今天早上我在机器上复现了这一问题。针对于api调用会返回nginx的错误信息以及bf客户端无法打开的情况。
现在写一下排除问题的过程：
首先检查数据库字段的问题：
首先确保bf server启动正常，在服务均正常运行的情况下，在终端中输入命令：
docker ps -a 查看当前运行的服务，并找到brainframedatabase：
输入命令：
docker exec -it &lt;数据库名称&gt; bash 进入到brainframe_database_1数据库中 ：
进入之后输入命令：
psql -d brainframe -U user 列出字段表，输入命令\d：
检测total_count、zone_alarm_count_condition、zone_alarm_rate_condition这三个表中的最大值，我这里没有数据，你们提取出来后查一下表中的最大值，进行数据库错误的排查，如图：
然后说一下bf server无法正常启动的问题：
情况一： 首先，当brainframe sever无法正常打开的情况下，可以通过重启的方式尝试进行解决，在终端中输入brainframe compose down命令，关闭server有关服务：
然后输入命令sudo brainframe compose up -d命令尝试恢复bf server：
或者直接输入命令 brainframe compose restart：
情况二： 当上述操作遇到了障碍，某个服务出现了error的情况，通过docker ps命令查看服务是否都正常，如果出现了问题，下面是一个简单分析问题的过程：
像之前在群中提到的可通过：
docker ps 命令来进行服务是否运行正常的判断，如果bf客户端起不来，会显示原因，或者直接就会在客户端中进行显示，如图：
这就是一个典型的bf无法启动的例子，问题的指向为 Port 80端口的冲突问题，具体在这里体现：
我们首先就将问题定位在了端口的问题上。
然后执行重启操作，发现问题在Creating brainframe_http_proxy_1上，并显示出端口已被占用。
可以通过命令过滤出正在使用80端口的应用程序，选择卸载或者杀死进程都可以，只要能让bf服务启动起来就好，
再说回WB_BF群里面提到的504 Gateway Time-out的问题：
根据群里面发的图片：
问题定位在504 gateway，504gateway错误的原因比较多，上面说的，首先我们可以重新启动服务。
第二种方案就是将nginx代理的配置超时时间调长，我不太了解brainframe api调用的一些详细内容，但是我认为可以看一下前段调用接口是否设置了time out？ 接口的504报错需要优化接口性能，短期内不可行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9801f7f97d6acb34de648b0fb9a4d62/" rel="bookmark">
			源码级别讲解 redis 底层数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis 底层数据结构 Redis作为Key-Value存储系统，数据结构如下：
Redis没有表的概念，Redis实例所对应的db以编号区分，db本身就是key的命名空间。
比如：user:1000作为key值，表示在user这个命名空间下id为1000的元素，类似于user表的id=1000的 行。
1. RedisDB结构 Redis中存在“数据库”的概念，该结构由redis.h中的redisDb定义。 当redis 服务器初始化时，会预先分配 16 个数据库 所有数据库保存到结构 redisServer 的一个成员 redisServer.db 数组中 redisClient中存在一个名叫db的指针指向当前使用的数据库。
RedisDB结构体源码：
typedef struct redisDb { int id; //id是数据库序号，为0-15（默认Redis有16个数据库） long avg_ttl; //存储的数据库对象的平均ttl（time to live），用于统计 dict *dict; //存储数据库所有的key-value dict *expires; //存储key的过期时间 dict *blocking_keys;//blpop 存储阻塞key和客户端对象 dict *ready_keys;//阻塞后push 响应阻塞客户端 存储阻塞后push的key和客户端对象 dict *watched_keys;//存储watch监控的的key和客户端对象 } redisDb; id
id是数据库序号，为0-15（默认Redis有16个数据库）
dict
存储数据库所有的key-value，后面要详细讲解
expires
存储key的过期时间，后面要详细讲解
2. RedisObject结构 Value是一个对象。RedisObject 有五种对象：字符串对象(String)、列表对象(List)、哈希对象(Hash)、集合对象(Set)和有序集合对象(ZSet)。
2.1 结构信息概览 typedef struct redisObject { unsigned type:4;//类型 五种对象类型 unsigned encoding:4;//编码 void *ptr;//指向底层实现数据结构的指针 //.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9801f7f97d6acb34de648b0fb9a4d62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4517020e78cd2ee33ccf5a0af7c7703/" rel="bookmark">
			基于单片机的数字频率计设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数字频率计概述
数字频率计是计算机、通讯设备、音频视频等科研生产领域不可缺少的测量仪器。它是一种用十进制数字显示被测信号频率的数字测量仪器。它的基本功能是测量正弦信号，方波信号及其他各种单位时间内变化的物理量。在进行模拟、数字电路的设计、安装、调试过程中，由于其使用十进制数显示，测量迅速，精确度高，显示直观，经常要用到频率计。
本数字频率计将采用定时、计数的方法测量频率，采用一个1602A LCD显示器动态显示6位数。测量范围从1Hz—10kHz的正弦波、方波、三角波，时基宽度为1us,10us,100us,1ms。用单片机实现自动测量功能。
基本设计原理是直接用十进制数字显示被测信号频率的一种测量装置。它以测量周期的方法对正弦波、方波、三角波的频率进行自动的测量。
频率测量仪的设计思路与频率的计算
频率测量仪的设计思路主要是：对信号分频，测量一个或几个被测量信号周期中已知标准频率信号的周期个数，进而测量出该信号频率的大小，其原理如下图所示。
频率测量原理
若被测量信号的周期为，分频数m1，分频后信号的周期为T，则：T=m1Tx 。由图可知： T=NT0 （注：T0为标准信号的周期，所以T为分频后信号的周期，则可以算出被测量信号的频率f。）
由于单片机系统的标准频率比较稳定，而是系统标准信号频率的误差，通常情况下很小；而系统的量化误差小于1，所以由式T=NT0可知，频率测量的误差主要取决于N值的大小，N值越大，误差越小，测量的精度越高。
基本设计原理
基本设计原理是直接用十进制数字显示被测信号频率的一种测量装置。它以测量周期的方法对正弦波、方波、三角波的频率进行自动的测量。
所谓“频率”，就是周期性信号在单位时间（1s）内变化的次数。若在一定时间间隔T内测得这个周期性信号的重复变化次数N，则其频率可表示为f=N/T。其中脉冲形成电路的作用是将被测信号变成脉冲信号，其重复频率等于被测频率fx。时间基准信号发生器提供标准的时间脉冲信号，若其周期为1s，则门控电路的输出信号持续时间亦准确地等于1s。闸门电路由标准秒信号进行控制，当秒信号来到时，闸门开通，被测脉冲信号通过闸门送到计数译码显示电路。秒信号结束时闸门关闭，计数器停止计数。由于计数器计得的脉冲数N是在1秒时间内的累计数，所以被测频率fx=NHz。
数字频率计（低频）的硬件结构设计
系统硬件的构成
本频率计的数据采集系统主要元器件是单片机AT89C51，由它完成对待测信号频率的计数和结果显示等功能，外部还要有分频器、显示器等器件。可分为以下几个模块：放大整形模块、秒脉冲产生模块、换档模拟转换模块、单片机系统、LCD显示模块。如下图所示：
系统工作原理图
该系统工作的总原理图如下图所示：
数字频率计系统工作原理图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15f39d865c38dc6067c785da9b05782e/" rel="bookmark">
			学会python可以做什么工作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python可以做：1、Web开发；2、数据科学研究；3、网络爬虫；4、嵌入式应用开发；5、游戏开发；6、桌面应用开发。python是一种动态的、面向对象的脚本语言，有着简单易学、速度快、易于维护等特点。
1、Web开发：结合python、html、css、javascript、数据库等开发一个网站。
2、数据科学
数据科学，包括了机器学习，数据分析和数据可视化。
将Python用于机器学习：可以研究人工智能、机器人、语言识别、图像识别、自然语言处理和专家系统等
将Python用于数据分析/可视化：大数据分析等等
3、网络爬虫
网络爬虫又称网络蜘蛛，是指按照某种规则在网络上爬取所需内容的脚本程序。众所周知，每个网页通常包含其他网页的入口，网络爬虫则通过一个网址依次进入其他网址获取所需内容。
在爬虫领域，Python是必不可少的一部分。将网络一切数据作为资源，通过自动化程序进行有针对性的数据采集以及处理。
4、自动化运维
随着技术的进步、业务需求的快速增长，一个运维人员通常要管理上百、上千台服务器，运维工作也变的重复、繁杂。把运维工作自动化，能够把运维人员从服务器的管理中解放出来，让运维工作变得简单、快速、准确。
5、嵌入式应用开发
6、游戏开发
7、桌面应用开发
学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后给大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
如果需要可以点击链接免费领取或者滑到最后扫描二v码
👉[CSDN大礼包：《python学习路线&amp;全套学习资料》免费分享]（安全链接，放心点击）
👉Python学习大纲👈
Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
👉Python实战案例👈
光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
温馨提示：篇幅有限，已打包文件夹，获取方式在：文末
👉Python书籍和视频合集👈
如果需要可以点击链接免费领取或者滑到最后扫描二v码
👉[CSDN大礼包：《python学习路线&amp;全套学习资料》免费分享]（安全链接，放心点击）
👉Python面试刷题👈
👉Python副业兼职路线👈
这份完整版的Python全套学习资料已经上传CSDN，朋友们如果需要可以点击链接免费领取或者保存图片到wx扫描二v码免费领取【保证100%免费】
👉[CSDN大礼包：《python学习路线&amp;全套学习资料》免费分享]（安全链接，放心点击）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd396f41d405925a3324a3b03326bb02/" rel="bookmark">
			Visual Studio 2019离线安装包获取和安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 介绍Visual Studio 2019离线安装方法和配置及注意事项
关键词 VS2019 离线安装
Visual Studio 2019版本与以往的2015、2013、2012版本不同，采用了新的模块化安装方法。微软官方也并未提供ISO镜像，根据官方提供的离线下载方案（docs.microsoft.com/en-us/visua… Studio的脱机安装说明。
一、官网下载所需要的版本的安装包获取程序： www.visualstudio.com/zh-hans/dow…
三个版本，对应文件名称为：
社区版：vs_Community.exe
专业版：vs_Professional.exe
企业版：vs_Enterprise.exe
二、命令行获取安装包 1）打开下载文件所在文件夹，按住Shift并鼠标右键点击空白处，点击【在此处打开命令行窗口（W）】：
1）根据自己所需要的版本，输入以下命令（空格为英文空格）：（红色部分为下载目录，可自己选择，注意：目录不能包含空格）
社区版：vs_community.exe --layout G:\VS2017社区版Offline
专业版：vs_professional.exe --layout G:\VS2017专业版Offline
企业版：vs_enterprise.exe --layout G:\VS2017企业版Offline
稍等片刻，进入下载页面：
进程自动创建文件夹，并将下载文件放到该文件夹下：
若想要某种语言的离线文件，在命令后添加lang 命令即可，如：
vs_professional.exe --layout G:\VS2017专业版Offline --lang zh-CN
常用语言：
英语（美国）：en-US
中文：zh-CN（简体），zh-TW（繁体）
中文加英文： --lang zh-CN en-US
命令参数详解请访问官网： docs.microsoft.com/en-us/visua…
三、安装 1）打开刚刚存放离线文件的路径，然后找到certificates文件夹并打开，依次安装该文件夹下的软件证书。双击证书并根据提示安装就行了。
2）运行离线目录下的安装程序（vs_xxx.exe）：
稍等片刻，进入安装界面：
选择自己所需要安装的模块，选择安装目录，点击右下角安装即可。（注意不要全选了，全选会占用几十个G的空间，而且会占用很大一部分C盘空间，选择自己需要的模块即可。）
四、更新离线文件包 1）官网下载最新的在线安装执行文件，下载地址：www.visualstudio.com/zh-hans/dow…
2）按步骤执行下载离线安装文件的步骤，注意：--layout后的下载文件夹路径必须是旧版本离线文件存储的路径（如果你之前下载好没移动过那就是之前的下载路径），执行命令后安装程序会扫描已有文件并下载更新文件和新增文件。
3）更新完成后再次执行离线文件夹根目录下的安装程序进行软件更新，或者在Visual Studio中直接检查更新（注意：无需重新导入证书除非有新证书被下载）。 原文链接：blog.csdn.net/WU9797/arti…
根据微软官方文档说明：（以下是官方文档）
我们将Visual Studio 2019设计为可以在各种网络和计算机配置中正常运行。虽然我们建议您尝试使用Visual Studio Web安装程序（这是一个小文件，并且可以使您始终了解所有最新的修补程序和功能），但我们知道您可能无法使用。
例如，您的互联网连接可能不可靠，或者带宽较低。如果是这样，您有几个选择：您可以使用新的“全部下载然后安装”功能在安装之前下载文件，或者可以使用命令行创建文件的本地缓存。
注意
如果您是企业管理员，希望对从Internet进行防火墙保护的客户端工作站网络执行Visual Studio部署，请参阅创建Visual Studio网络安装和安装Visual Studio脱机安装页面所需的证书。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd396f41d405925a3324a3b03326bb02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8161f8fa33410de04c66a170e8bc7cb7/" rel="bookmark">
			手把手教你使用gtest写单元测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开源框架：gtest，它主要用于写单元测试，检查真自己的程序是否符合预期行为。这不是QA（测试工程师）才学的，也是每个优秀后端开发codoer的必备技能。
本期博文内容及使用的demo，参考：
Googletest Basic Guide[1]
Googletest Samples [2]
构建依赖环境 按照惯例，先介绍下怎么基于CMakeLists.txt构建依赖环境。
由于Google没有为googletest/samples中的samples写CMakeLists.txt，因此，gtest从github克隆下来后，也无法直接运行这些samples。
为方便大家跟着本文一起实践，获得更好的学习体验，在后台回复「gtest」即可获取我配置好的gtest压缩包。
当前目录结构如下：
$ tree -L 2 demo ├── CMakeLists.txt ├── build # 空的文件夹 ├── include │ ├── CMakeLists.txt │ ├── gflags │ └── googletest ├── main.cc └── my_gtest_demo_1.cc 然后，在demo/build路径下，执行命令：
$ cmake .. &amp;&amp; make -j 4 这些samples生成的可执行文件都在demo/build/bin路径下。
这样，就介绍完前提准备，下面开始进入正题。
assertion 在gtest中，是通过断言（assertion）来判断代码实现的功能是否符合预期。断言的结果分为success、non-fatal failture和fatal failture。
根据断言失败的种类，gtest提供了两种断言函数：
success：即断言成功，程序的行为符合预期，程序继续向下允许。
non-fatal failure：即断言失败，但是程序没有直接crash，而是继续向下运行。 gtest提供了宏函数EXPECT_XXX(expected, actual)：如果condition(expected, actual)返回false，则EXPECT_XXX产生的就是non-fatal failure错误，并显示相关错误。
fatal failure：断言失败，程序直接crash，后续的测试案例不会被运行。 gtest提供了宏函数ASSERT_XXX(expected, actual)。 在写单元测试时，更加倾向于使用EXPECT_XXX，因为ASSERT_XXX是直接crash退出的，可能会导致一些内存、文件资源没有释放，因此可能会引入一些bug。
具体的EXPECT_XXX、ASSERT_XXX函数及其判断条件，如下两个表。
表1 一元比较
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8161f8fa33410de04c66a170e8bc7cb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48319e437ed4c8d8ce4008adb0c65b11/" rel="bookmark">
			三维视觉之数字图像处理基础（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三维视觉原理：图像形成、颜色模型、图像质量评价 声明：该部分内容为观看3D视觉开发者社区相关教学视频的学习记录文本，仅供自己学习记录和个人复习使用，感兴趣的人可以去相关网站观看相关教学视频，网址：https://developer.orbbec.com.cn/v/lecture?tid=26&amp;cid=28 1.图像形成 1.1 图像的简单模型 图像的简单模型可以表示为: f(x,y)表示图像的亮度，这与光源的入射分量和反射分量相关，入射分量取决于光源（平行光源、点光源），反射分量取决于成像物体的表面特征。
常用的
1.2 平行光源模型（朗伯面假设） 其中：*I*代表图片的亮度，E代表，r物体表面的反射率（透射率），n为物体表面点的法线方向，v物体表面的法线方向与光源方向的夹角，&lt;n,v&gt;代表两个参数的点积（垂直数值为0）。
1.3 点光源模型（朗伯面假设） ||lij||³表示光随光传播距离的衰减，衰减关系为平方的倒数，此处为何为三次方？待解决？
2 颜色模型 2.1 数字图像的表示 注意：左上角为原点
2.2 颜色模型 2.2.1 RGB彩色模型 每一种颜色都是0-255，可以表示256³种颜色
应用于图像显示、图像打印
2.2.2 HSI彩色模型 HSI〔Hue-Saturation-Intensity(Lightness),HSI或HSL〕颜色模型用H、S、I三参数描述颜色特性，其中H定义颜色的频率，称为色调；S表示颜色的深浅程度，称为饱和度；I表示强度或亮度。
RGB到HSI模型的推导：
将RGB模型旋转变换，白色在上黑色在下，之后有一任意平面与黑白两点形成的轴线垂直所截取得六边形或三角形的截面。
HSI转换为RGB：
3 数字图像的质量 3.1 分辨率 分辨率是指纵横向上的像素点数，决定图像的大小
左侧图片为不同分辨率图片，右侧为不同分辨率图片相同尺寸对比图。
3.2 灰度等级 一般图像为模拟图像（可以理解为由线条和颜色块组成的图像，是连续性的模拟量），图像数字化处理就是图像在空间坐标和光强度上进行离散化处理，分割成一个个称为像素的小区域， 空间坐标的离散化——图像采样；对光强（幅度）做离散化处理——灰度级量化（取整），8比特256个灰度等级。 彩色图像不同灰度等级下的对比：
3.3 对比度 一幅图像中灰度反差的大小。例如：亮的地方很亮，暗的地方很暗，即认为有一个比较好的对比度。例如下图，左边图片对比度较好。 3.4 清晰度 清晰度相关的主要因素有：亮度、对比度、分辨率、细微层次、颜色饱和度。 亮度变化：（亮度降低前后对比） 上图，左侧图片亮度适中，右侧曝光严重，大多数像素值为255
对比度：前后变化见3.3
分辨率低，丢失细节
细微层次：（调焦的影响，没对好焦距，图像细节模糊）
颜色饱和度：
3.5 对比度和饱和度的区别 一、主体区别
1、对比度：指的是最高亮度和最低亮度的比值。当图像对比度越高时，那么图像明暗差异越明显。
2、饱和度：指的是色彩的纯正程度。当图像的饱和度越高时，那么图像色彩越鲜艳。
二、特点区别
1、对比度：图像色彩差异范围越大代表对比度越大，反之则代表对比度越小。当对比度达到120:1时，就可容易地显示生动、丰富的色彩；而当对比度高达300:1时，便可支持各阶的颜色。
2、饱和度：饱和度取决于该色中含色成分和消色成分(灰色)的比例。含色成分越大，饱和度越大；消色成分越大，饱和度越小。
三、作用区别
1、对比度：对比度越大，图像越清晰醒目，色彩也越鲜明艳丽；反之，则会让整个画面都灰蒙蒙的。高对比度对于图像的清晰度、细节表现、灰度层次表现都有很大帮助。
2、饱和度：色度由光度线强弱和在不同波长的强度分布有关。最高的色度一般由单波长的强光达到，在波长分布不变的情况下，光强度越弱则色度越低。
上图为：原图、原图降低对比度、原图降低饱和度
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/560037a4f194621a1156bc93f09854a5/" rel="bookmark">
			什么是TCP/IP模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TCP/IP模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议。
基于TCP/IP的参考模型将协议分成5个层次，分别是物理层、链路层、网络层、传输层和应用层。 下图表示TCP/IP模型与OSI模型各层的对照关系。
从传输层开始以下都在内核中。
TCP/IP 各层协议
TCP/IP协议被称为传输控制协议/互联网协议，又称网络通讯协议(Transmission Control Protocol)。是由网络层的IP协议和传输层的TCP协议组成，是一个很大的协议集合。
物理层 和 数据链路层 没有定义任何特定协议，支持所有的标准和专用的协议。
网络层定义了网络互联也就是IP协议，主要包括IP、ARP、RARP、ICMP、IGMP。
传输层 定义了TCP和UDP(User Datagram Protocol)，我们会后面重点介绍一下TCP协议。
应用层 定义了HTTP(超文本传输协议)、FTP(文件传输协议)、DNS(域名系统)等协议
TCP/IP协议族按照层次由上到下，层层包装。最上面是应用层，这里面有http、ftp等我们熟知的协议。而第二层则是传输层，著名的TCP和UDP就是在这个层次。第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其它的数据以确定传输的目标。第四层是数据链路层，这个层次是为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/639dae48ec9163f44d6460df11db02ff/" rel="bookmark">
			液晶显示控制驱动器HD61202介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		液晶显示控制驱动器HD61202的特点
HD61202液晶显示控制驱动器是一种带有驱动输出的图形液晶显示控制器，它可直接与8位微处理器相连，它可与HD61203配合对液晶屏进行行、列驱动。HD61202是一种带有列驱动输出的液晶显示控制器，它可与行驱动器HD61203配合使用，组成液晶显示驱动控制系统。
(1) 内藏64×64=4096位显示RAM，RAM中每位数据对应LCD屏上一个点的亮、暗状态；
(2) HD61202是列驱动器，具有64路列驱动输出；
(3) HD61202读、写操作时序与68系列微处理器相符，因此它可直接与68系列微处理器接口相连；
(4) HD61202的占空比为1/32～1/64。
液晶显示控制驱动器HD61202的引脚功能
HD61202的引脚功能如下表所示。
HD61202的引脚功能
液晶显示控制驱动器HD61202的指令系统
HD61202的指令系统比较简单，总共只有七种。现分别介绍如下。
1、显示开/关指令
当DBO=1时，LCD显示RAM中的内容；DBO=0时，关闭显示。
2、显示起始行（ROW）设置指令
该指令设置了对应液晶屏最上一行的显示RAM的行号，有规律的改变显示起始行，可以使LCD实现显示滚屏的效果。
3、页(PAGE)置指令
显示RAM共64行，分8页，每页8行。
4、列地址（Y Address）设置指令
设置了页地址和列地址，就唯一确定了显示RAM中的一个单元，这样MPU就可以用读、写指令读出该单元中的内容或向该单元写进一个字节数据。
5、读状态指令
该指令用来查询HD61202的状态，各参量含义如下：
BUSY：　1-内部在工作 0-正常状态
ON/OFF：1-显示关闭 0-显示打开
REST： 1-复位状态 0-正常状态
在BUSY和REST状态时，除读状态指令外，其它指令均不对HD61202产生作用。在对HD61202操作之前要查询BUSY状态，以确定是否可以对HD61202进行操作。
6、写数据指令
7、读数据指令
读、写数据指令每执行完一次读、写操作，列地址就自动增一，必须注意的是，进行读操作之前，必须有一次空读操作，紧接着再读才会读出所要读的单元中的数据。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/36/">«</a>
	<span class="pagination__item pagination__item--current">37/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/38/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>