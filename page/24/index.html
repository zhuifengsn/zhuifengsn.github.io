<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d4df12cb15ee4dbf5857db17c241322/" rel="bookmark">
			影视类短视频怎么做伪原创
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		影视类短视频怎么做伪原创？带着这个问题，今天详细介绍下短视频伪原创的方法和技巧。
随着短视频的兴起，越来越多的人开始关注如何制作高质量的影视类短视频。然而，由于版权和创意的限制，许多人可能会面临无法获取足够素材或创意的问题。在这种情况下，伪原创成为了一种可行的解决方案。本文将详细介绍如何制作伪原创的影视类短视频。
一、获取素材影视剪辑怎样才是原创
首先，你需要获取一些与你的主题相关的素材。这可以包括电影、电视剧、综艺节目、纪录片等影视作品，以及图片、音频和文字等其他类型的素材。你可以通过搜索引擎、视频网站、版权网站等途径获取这些素材。
二、剪辑和拼接短视频一键制作伪原创
在获取到足够的素材后，你需要进行剪辑和拼接。这个过程中，你可以使用视频剪辑软件（如Adobe Premiere Pro、Final Cut Pro等）来对素材进行剪辑、调色、音效等处理，以便更好地表达你的主题。
三、添加字幕和特效影视视频怎么剪辑才是原创
为了更好地传达你的信息，你需要在视频中添加字幕和特效。字幕可以包括对话、旁白、标题等，而特效则可以包括转场、滤镜、音效等。这些都可以通过视频剪辑软件来实现。
四、声音处理视频如何伪原创
在制作伪原创的影视类短视频时，声音处理也是一个非常重要的环节。你可以使用音频编辑软件（如Audacity、Adobe Audition等）来对音频进行降噪、均衡、混响等处理，以便更好地配合视频内容。
五、发布和推广
完成以上步骤后，你就可以发布你的伪原创影视类短视频了。你可以选择在各大短视频平台上发布，也可以选择在自己的网站或社交媒体上发布。在发布后，你可以通过社交媒体、搜索引擎和其他渠道来推广你的视频，以便获得更多的曝光和观众。
需要注意的是，虽然伪原创在一定程度上可以解决创意和素材不足的问题，但过度使用可能会侵犯他人的版权和知识产权。因此，在制作伪原创的影视类短视频时，你应该注意合理使用素材和创意，避免侵犯他人的版权和知识产权。同时，你也应该尊重原创作者的劳动成果，尽可能地使用正版素材和创意。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f4b2c16f85c40d4c3af77766e7813e2/" rel="bookmark">
			SpringBoot 整合 Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot 整合 Redis、Redis可视化工具、
前言
Redis的简介
Redis 使用场景
一、下载安装Redis（解压在文件夹内即可）
二、启动Redis（双击）
三、可视化工具下载（自用）
四、SpringBoot整合Redis
步骤①：引入Maven
步骤②：配置yml文件
步骤③：Redis序列化配置
步骤④：测试类实验
总结
前言 Redis的简介 简单来说 redis 就是一个数据库，不过与传统数据库不同的是 redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向。另外，redis 也经常用来做分布式锁。
Redis 使用场景 缓存，顾名思义，就是把数据存放在缓冲区，当查找数据时，首先会在缓存中进行查找，如果存在，就获取；否则就访问数据库。频繁的从缓存中读取数据，减少访问数据库的次数，可以提高运行效率。
一、下载安装Redis（解压在文件夹内即可） 官方下载地址（Windows下载zip结尾）：
https://github.com/MicrosoftArchive/redis/releases
蓝奏云下载地址（自用5.0版本）:
https://wwep.lanzoul.com/b058mwq1a
密码:6yur
二、启动Redis（双击） redis-server.exe
三、可视化工具下载（自用） AnotherRedisDesktopManager 发行版 - Gitee.com 蓝奏云下载地址：
https://wwep.lanzoul.com/b058mwqva
密码:6cpt
四、SpringBoot整合Redis 步骤①：引入Maven &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 步骤②：配置yml文件 spring: # Mysql配置 datasource: driver-class-name: com.mysql.cj.jdbc.Driver username: # 用户名 password: # 密码 url: jdbc:mysql://localhost:3306/tools?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=UTF-8 data: redis: # Redis服务器地址 host: localhost # Redis服务器端口号 port: 6379 # 使用的数据库索引，默认是0 database: 0 #连接超时事件毫秒 timeout: 18000 lettuce: pool: #连接池最大连接数 max-active: 20 #最大阻塞等待时间 max-idle: 5 #连接池最小空闲连接 min-idle: 0 步骤③：Redis序列化配置 /** * @Author：龙抬头 * @Date：2023/11/19 15:51 * @Description： Redis序列化配置 */ @Configuration// 该注解表示该类为springboot的配置类，会被自动解析，本类为固定写法 public class RedisConfig { @Bean// 将该方法的返回值加入到容器 public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory){ // 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f4b2c16f85c40d4c3af77766e7813e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d9748835b8df6c88b965d05c2fdcd99/" rel="bookmark">
			强化学习中的 AC（Actor-Critic）、A2C（Advantage Actor-Critic）和A3C（Asynchronous Advantage Actor-Critic）算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 AC算法A2C算法A3C算法 AC算法 AC（Actor-Critic）算法是强化学习中的一种基本方法，它结合了策略梯度方法和价值函数方法的优点。在 Actor-Critic 算法中，有两个主要的组成部分：演员（Actor）和评论家（Critic）。以下是 AC 算法的关键要素和工作原理：
演员（Actor）:
演员负责根据当前状态选择动作。它通常采用策略函数 π(a|s) 来表示在给定状态 s 下采取动作 a 的概率。演员的目标是学习一种策略，以最大化长期的累积奖励。 评论家（Critic）:
评论家评估演员采取的动作有多好，它使用价值函数 V(s) 或 Q(s, a) 来衡量在状态 s 或在状态 s 下采取动作 a 的预期回报。评论家的目标是准确预测未来的回报，以指导演员的决策。 训练过程:
演员根据当前策略选择动作，环境根据这一动作返回新的状态和奖励。评论家根据奖励和新状态来评估这一动作的价值，并提供反馈给演员。演员根据评论家的反馈通过策略梯度方法调整其策略，以提高未来动作的预期回报。 算法特点:
平衡探索与利用：AC 算法通过持续更新策略来平衡探索（探索新动作）和利用（重复已知的好动作）。减少方差：由于评论家的引导，演员的策略更新更加稳定，减少了策略梯度方法中的方差。适用性：AC 算法适用于离散和连续动作空间，可以处理复杂的决策问题。 AC 算法是 A2C 和 A3C 算法的基础，它通过结合策略梯度和价值函数方法，为更高级的算法提供了一个坚实的基础。尽管 AC 算法在某些情况下可能不如其变体（如 A2C、A3C）高效，但它仍是理解和研究强化学习的一个重要起点。
A2C算法 强化学习中的 A2C（Advantage Actor-Critic）算法是一种结合了演员-评论家（Actor-Critic）框架和优势函数（Advantage Function）的方法。这种算法在处理决策问题时，能够有效地平衡探索（exploration）和利用（exploitation）的策略。以下是 A2C 算法的关键要素和运作机制：
演员-评论家框架（Actor-Critic Framework）:
演员（Actor）: 负责根据当前状态选择动作。它通常由一个神经网络实现，输出一个动作概率分布。评论家（Critic）: 评估演员选定的动作好坏。它通常也由一个神经网络实现，输出当前状态或动作的价值估计。 优势函数（Advantage Function）:
优势函数 A(s, a) = Q(s, a) - V(s) 表示在状态 s 下采取动作 a 相对于平均水平的优势。其中，Q(s, a) 是动作价值函数，表示在状态 s 下采取动作 a 的预期回报；V(s) 是状态价值函数，表示在状态 s 的预期回报。使用优势函数而不是简单的回报差异，有助于减少方差，加快学习过程。 学习过程:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d9748835b8df6c88b965d05c2fdcd99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06efddcfa88c55c2824914b8e0eb72bd/" rel="bookmark">
			Ubuntu18.04安装opencv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 参考这条博客
先在opencv下载opencv包(18.04最好是3.x版本)
git clone -b 3.4.16 https://github.com/opencv/opencv.git 再在opencv_contrib下载对应的版本放入opencv内
cd opencv git clone -b 3.4 https://github.com/opencv/opencv_contrib.git 安装依赖:
sudo apt-get install build-essential sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev 在opencv文件夹里新建build文件并进入,cmake
sudo cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local .. 编译
sudo make -j8 或者 sudo make -j4 安装
sudo make install 添加路径
sudo gedit /etc/ld.so.conf /usr/loacal/lib sudo ldconfig 配置环境
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06efddcfa88c55c2824914b8e0eb72bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b52d62f82764293625d848c24c4f7c39/" rel="bookmark">
			Jmeter —— 接口测试参数化后循环断言不同内容的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 各位小伙伴在做接口自动化有没遇到过这样的问题，CSV文件参数化测试数据后，只能通过人工的的方法去查看结果，不懂写代码去循环断言返回的结果。今天我们来学习一下，不用写代码，就用响应断言，怎么实现循环断言不同的内容吧！
一：参数化接口测试数据
注意：csv文档参数化，里面有多少条数据，就要在线程组里循环多少次，不然就只执行一次
二：添加配置元件-计数器
关于计数器
Starting Value：给定计数器的初始值
递增：每次循环迭代后，给计数器增加的值
Maximum Value：计数器的最大值，如果超过最大值，会重新设置为初始值，非必填项
数字格式：可选格式，比如填写000，格式化为001，002；比如填写0，格式化为1，2；
引用名称：引用变量，可以在其他元素中引用该值，形式：${引用名称}
与每用户独立的跟踪计数器：
不勾选，即全局计数器的，比如用户#1 获取值为1，用户#2获取值还是为1；
勾选，即独立的，则每个用户有自己的值：比如用户#1 获取值为1，用户#2获取值为2。
每次迭代复原计数器：只有当勾选了，与每用户独立的跟踪计数器时才可用；勾选此选项后，则每次线程组迭代，都会重置计数器的值，当线程组是在一个循环控制器内时比较有用。
拼接函数，嵌套变量
这个是jmeter自带的函数，可以用用这个函数进行字符串的拼接，或者是变量中再嵌套变量。
Name of variable：引用的变量名
默认值：非必填参数，填写了之后，当你引用变量失败后，就会填充该默认值
现在我也找了很多测试的朋友，做了一个分享技术的交流群，共享了很多我们收集的技术文档和视频教程。 如果你不想再体验自学时找不到资源，没人解答问题，坚持几天便放弃的感受 可以加入我们一起交流。而且还有很多在自动化，性能，安全，测试开发等等方面有一定建树的技术大牛 分享他们的经验，还会分享很多直播讲座和技术沙龙 可以免费学习！划重点！开源的！！！ qq群号：110685036【暗号：csdn999】 三：设置断言内容-添加用户定义的变量
这里有一个非常重要的点就是我们要把需要断言的内容给设置成变量，因为只有这样，我们才能循环取值，做循环断言
四：添加JSON提取器，提取接口返回进行判断的数据
五：添加响应断言，进行结果判断
六：添加查看结果树，进行循环断言
通过断言得知，有一条用例执行失败了，因为返回的respCode是3100，而响应断言我设置的是3104
至此，我们就完全可以用响应断言，实现循环断言了，这也是以后要用工具做自动化的一个必不可少的步骤哦！！！
最后感谢每一个认真阅读我文章的人，看着粉丝一路的上涨和关注，礼尚往来总是要有的，虽然不是什么很值钱的东西，如果你用得到的话可以直接拿走！
软件测试面试文档 我们学习必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有字节大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4060f3df185e44db9140d6e6116daa46/" rel="bookmark">
			开源计算机视觉库OpenCV详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、概述
2、OpenCV详细介绍
2.1、OpenCV的起源
2.2、OpenCV开发语言
2.3、OpenCV的应用领域
3、OpenCV模块划分
4、OpenCV源码文件结构
4.1、根目录介绍
4.2、常用模块介绍
4.3、CUDA加速模块
5、OpenCV配置以及Visual Studio使用OpenCV
6、关于Lena图片
7、OpenCV和OpenGL的区别
8、OpenCV与YOLO的区别
9、OpenGL与DirectX的区别
VC++常用功能开发汇总（专栏文章列表，欢迎订阅，持续更新...）https://blog.csdn.net/chenlycly/article/details/124272585C++软件异常排查从入门到精通系列教程（专栏文章列表，欢迎订阅，持续更新...）https://blog.csdn.net/chenlycly/article/details/125529931C++软件分析工具案例集锦（专栏文章正在更新中...）https://blog.csdn.net/chenlycly/category_12279968.html
C/C++基础与进阶https://blog.csdn.net/chenlycly/category_11931267.html
1、概述 在计算机视觉项目的开发中，OpenCV作为最大众的开源库，拥有了丰富的常用图像处理函数库，采用C/C++语言编写，可以运行在Linux/Windows/Mac等操作系统上，能够快速的实现一些图像处理和识别的任务。此外，OpenCV还提供了java、python、cuda等的使用接口、机器学习的基础算法调用，从而使得图像处理和图像分析变得更加易于上手，让开发人员更多的精力花在算法的设计上。
本文将主要介绍OpenCV开发的一些基础知识、入门上手的方法与步骤等。
在这里，给大家重点推荐一下我的两个热门畅销专栏：
专栏1：（该专栏订阅量接近350个，有很强的实战参考价值，广受好评！）
C++软件异常排查从入门到精通系列教程（专栏文章列表，欢迎订阅，持续更新...）https://blog.csdn.net/chenlycly/article/details/125529931
本专栏根据近几年C++软件异常排查的项目实践，系统地总结了引发C++软件异常的常见原因以及排查C++软件异常的常用思路与方法，详细讲述了C++软件的调试方法与手段，以图文并茂的方式给出具体的实战问题分析实例，带领大家逐步掌握C++软件调试与异常排查的相关技术，适合基础进阶和想做技术提升的相关C++开发人员！
专栏中的文章都是通过项目实战总结出来的，有很强的实战参考价值！专栏文章还在持续更新中，预计文章篇数能更新到200篇以上！
专栏2： C/C++基础与进阶（专栏文章，持续更新中...）https://blog.csdn.net/chenlycly/category_11931267.html
以多年的开发实战为基础，总结并讲解一些的C/C++基础与进阶内容，以图文并茂的方式对相关知识点进行详细地展开与阐述！专栏涉及了C/C++领域的多个方面的内容，同时给出C/C++及网络方面的常见笔试面试题，并详细讲述Visual Studio常用调试手段与技巧！
2、OpenCV详细介绍 2.1、OpenCV的起源 OpenCV诞生于Intel研究中心，其目的是为了促进CPU密集型应用。为了达到这一目的，Intel启动了多个项目，包括实时光线追踪和三维显示墙。一个在Intel工作的OpenCV作者在访问一些大学时，注意到许多顶尖大学中的研究组(如MIT媒体实验室)拥有很好的内部使用的开放计算机视觉库-- (在学生们之间互相传播的代码)，这会帮助一个新生从高的起点开始他/她的计算机视觉研究。这样一个新生可以在以前的基础上继续开始研究，而不用从底层写基本函数。
因此，OpenCV的目的是开发一个普遍可用的计算机视觉库。在Intel的性能库团队的帮助下 ，OpenCV实现了一些核心代码以及算法，并发给Intel俄罗斯的库团队。这就是OpenCV的诞生之地：在与软件性能库团队的合作下，它开始于Intel的研究中心，并在俄罗斯得到实现和优化。
俄罗斯团队的主要负责人是Vadim Pisarevsky，他负责管理项目、写代码并优化OpenCV的大部分代码，在OpenCV中很大一部分功劳都属于他。跟他一起，Victor Eruhimov帮助开发了早期的架构，Valery Kuriakin管理俄罗斯实验室并提供了很大的支持。在开始时，OpenCV有以下三大目标：
1）为基本的视觉应用提供开放且优化的源代码，以促进视觉研究的发展。能有效地避免“闭门造车”。
2）通过提供一个通用的架构来传播视觉知识，开发者可以在这个架构上继续开展工作，所以代码应该是非常易读的且可改写。
3）本库采用的协议不要求商业产品继续开放代码，这使得可移植的、性能被优化的代码可以自由获取，可以促进基于视觉的商业应用的发展。
这些目标说明了OpenCV的起缘。计算机视觉应用的发展会增加对快速处理器的需求。与单独销售软件相比，促进处理器的升级会为Intel带来更多收入。这也许是为什么这个开放且免费的库出现在一家硬件生产企业中，而不是在一家软件公司中。从某种程度上说，在一家硬件公司里，在软件方面会有更多创新的空间。 2.2、OpenCV开发语言 OpenCV的全称是：Open Source Computer Vision Library。OpenCV是一个基于BSD许可（开源）发行的跨平台计算机视觉库，可以运行在Linux、Windows、Android和Mac OS操作系统上。它轻量级而且高效——由一系列C函数和少量C++类构成，同时提供了Python、Ruby、MATLAB等语言的接口，实现了图像处理和计算机视觉方面的很多通用算法。
OpenCV用C++语言编写，它的主要接口也是C++语言，但是依然保留了大量的C语言接口。该库也有大量的Python, Java and MATLAB/OCTAVE (版本2.5)的接口。这些语言的API接口函数可以通过在线文档获得。如今也提供对于C#,Ch, Ruby的支持。
2.3、OpenCV的应用领域 OpenCV是一个用于图像处理、分析、机器视觉方面的开源函数库。 无论你是做科学研究，还是商业应用，OpenCV都可以作为你理想的工具库，因为，对于这两者，它完全是免费的。同时，由于计算机视觉与机器学习密不可分，该库也包含了比较常用的一些机器学习算法。或许，很多人知道图像识别、机器视觉在安防领域有所应用。但很少有人知道，在航拍图片、街道图片（例如google street view）中，要严重依赖于机器视觉的摄像头标定、图像融合等技术。
近年来，在入侵检测、特定目标跟踪、目标检测、人脸检测、人脸识别、人脸跟踪等领域，OpenCV可谓大显身手，而这些，仅仅是其应用的冰山一角。如今，来自世界各地的各大公司、科研机构的研究人员，共同维护支持着OpenCV的开源库开发。这些公司和机构包括：微软，IBM，索尼、西门子、google、intel、斯坦福、MIT、CMU、剑桥。
计算机视觉市场巨大而且持续增长，且这方面没有标准API，如今的计算机视觉软件大概有以下三种：
1）研究代码（慢，不稳定，独立并与其他库不兼容）
2）耗费很高的商业化工具（比如Halcon, MATLAB+Simulink）
3）依赖硬件的一些特别的解决方案（比如视频监控，制造控制系统，医疗设备）这是如今的现状。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4060f3df185e44db9140d6e6116daa46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b087e0e60d1bc23811c1cb924784542/" rel="bookmark">
			bug:gcc编译器警报warning: ‘xxx’ is used uninitialized in this function [-Wuninitialized]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		警报原因：指针没有指向可用的内存地址或没有分配地址 我在main中定义了结构体指针在没有分配内存或者指向某个地址的情况下，将其作为实参传给了函数后出现以上警报，使用指针时要注意分配内存，或者不要轻易使用指针
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45f93773ebe4958caa433b96b584f20b/" rel="bookmark">
			SQL Server去除字符串空格的ltrim() 和 rtrim()函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SQL Server去除字符串空格的ltrim() 和 rtrim()函数 SQL Server并不提供trim()函数去除字符串两边空格，只提供了去除字符串左边空格ltrim()函数和去除右边字符串空格rtrim()函数，但是只要将这两个函数配合使用，就能达到去除字符串两端空格的效果。
ltrim()函数的使用：
select ltrim（' aa '） 去除item_no字段内左边的空格：
update t_bd_item_info20231115 set item_no = ltrim(item_no) where item_subno = '0002' rtrim()函数的使用：
select ltrim(' aa ') 去除item_no字段内右边的空格：
update t_bd_item_info20231115 set item_no = rtrim(item_no) where item_subno = '0002' ltrim()函数和rtrim()函数配合使用：
select rtrim(ltrim(' aa ')) 去除item_no字段内左边右边的空格：
update t_bd_item_info20231115 set item_no = rtrim(ltrim(item_no)) where item_subno = '0002' 也可以用replace()函数来去除所有空格：
select replace(' aa ',' ','') 去除item_no字段内左边右边的空格：
update t_bd_item_info20231115 set item_no = replace(item_no,' ','') where item_subno = '0002' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1961855a31db31fdf1945171ee6f8a7d/" rel="bookmark">
			SQL Server中substring的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 @SQL Server中substring的用法
SQL中的substring函数是用来截取一个栏位资料中的其中一部分。
例如，我们需要将字符串’abdcsef’中的‘abd’给提取出来，则可用substring 来实现：
select substring('abdcsef',1,3) 结果为 'abd' 括号中数字’1’表示截取的起始位置是从该字符串的第一个字符开始，'3’表示截取后得到的字符串长度为3个字符。
货号等于自编码（从第2位开始，长度为4）
select * into t_bd_item_info20231115 from t_bd_item_info select item_no = substring(item_subno,2,4) ,* from t_bd_item_info20231115 where item_no = '00002' update t_bd_item_info20231115 set item_no = substring(item_subno,2,4) where item_no = '00002' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7eaef12ef4dca4a196bcb9c95c74296/" rel="bookmark">
			短视频伪原创处理软件【一键快速原创】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、短视频伪原创处理软件的发展背景
随着短视频的兴起，越来越多的创作者和内容生产者开始涉足短视频领域。然而，制作高质量的短视频需要大量的创意和素材，同时还需要投入大量的时间和精力。为了解决这个问题，短视频伪原创处理软件应运而生。这些软件可以帮助用户快速地创建出具有吸引力和独特性的短视频，大大提高了内容生产效率。
二、短视频伪原创处理软件的种类
小狗伪原创 小狗伪原创是一款专业的伪原创工具，可以帮助用户快速地创建出高质量的短视频。它采用了先进的自然语言处理技术，可以快速地分析和处理文本内容，并将其转化为短视频形式。此外，小狗伪原创还支持多种视频格式和输出方式，可以满足用户不同的需求。
今日头条AI伪原创工具 今日头条AI伪原创工具是一款基于人工智能技术的伪原创工具。它可以通过对大量文本和图像素材的分析和处理，快速地生成具有吸引力和独特性的短视频。此外，今日头条AI伪原创工具还支持多种社交媒体平台的发布，可以方便地将短视频分享给更多的用户。
手机剪映伪原创教程 手机剪映是一款流行的视频编辑软件，它提供了丰富的视频编辑功能和素材库。在制作短视频时，我们可以使用手机剪映提供的伪原创功能来快速地创建出具有个性和吸引力的短视频。此外，手机剪映还提供了详细的伪原创教程和视频编辑技巧，可以帮助用户更好地掌握视频制作技能。
三、短视频伪原创处理软件的未来趋势和发展方向
随着人工智能技术的不断发展和应用，短视频伪原创处理软件将会更加智能化和高效化。未来，这些软件将会具备更加丰富的功能和更加强大的处理能力，可以帮助用户更加快速地创建出高质量的短视频内容。同时，随着社交媒体平台的不断发展和普及，短视频伪原创处理软件也将会更加注重社交媒体平台的发布和分享功能，方便用户将短视频分享给更多的观众。
四、短视频伪原创处理软件的优缺点和使用建议
优点：短视频伪原创处理软件可以帮助用户快速地创建出高质量的短视频内容，提高内容生产效率，同时还可以方便地将短视频分享到多个社交媒体平台，扩大影响力。缺点：由于这些软件采用了人工智能技术，可能会出现一些语法错误和语义不准确的问题，需要用户进行手动修正。此外，这些软件也需要一定的学习和掌握时间。使用建议：在使用短视频伪原创处理软件时，建议先了解软件的基本功能和使用方法，再结合自己的需求进行选择和使用。同时，还需要注重保护知识产权和尊重原创精神，避免侵犯他人的权益和版权。 五、短视频伪原创处理软件的实际应用案例
小狗伪原创的实际应用案例 小狗伪原创曾被广泛应用于短视频制作中，某短视频创作者利用小狗伪原创工具，将一篇较长的文章转化为短视频形式，并成功吸引了大量用户的关注和点赞。该创作者表示，小狗伪原创工具的操作简单，处理速度快，且输出的短视频质量较高，对于提高内容生产效率非常有帮助。
今日头条AI伪原创工具的实际应用案例 某新闻客户端利用今日头条AI伪原创工具，快速生成了大量新闻报道的短视频。这些短视频采用了人工智能技术，自动分析和处理文本内容，并生成具有吸引力的视频画面。这些短视频在各大社交媒体平台上获得了广泛的传播和关注，大大提高了该新闻客户端的影响力和用户黏性。
手机剪映伪原创教程的实际应用案例 某视频编辑爱好者通过手机剪映伪原创教程，学习到了如何将长视频剪辑成短视频，并通过添加背景音乐、特效等手段，使短视频更具吸引力和个性化。该爱好者表示，手机剪映提供的伪原创教程非常实用，不仅提高了她的视频制作技能，还让她在朋友中获得了更多的赞誉和认可。
六、总结与展望
短视频伪原创处理软件为内容生产者和创作者提供了强大的支持和帮助，使得他们能够更加快速、高效地创建出吸引人的短视频内容。然而，随着技术的不断发展和应用，我们也需要关注和思考伪原创的边界和规范问题。如何在尊重原创精神的同时，发挥伪原创的优势和价值，是我们需要深入探讨的问题。未来，我们期待看到更多的创新和突破，在保护知识产权的同时，推动短视频产业的健康、快速发展。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c31e6eb70ffebec8cd4084a3c860c5e9/" rel="bookmark">
			Python 项目转化为so文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考博客 https://blog.csdn.net/ctwy291314/article/details/88849139
仅记为备忘，侵权立删！
核心代码如下： ''' Created on 2019年3月27日 @author: hylink ''' #-* -coding: UTF-8 -* - """ 执行前提： 系统安装python-devel 和 gcc Python安装cython 编译整个当前目录： python py-setup.py 编译某个文件夹： python py-setup.py BigoModel 生成结果： 目录 build 下 生成完成后： 启动文件还需要py/pyc担当，须将启动的py/pyc拷贝到编译目录并删除so文件 """ import sys, os, shutil, time from distutils.core import setup from Cython.Build import cythonize starttime = time.time() currdir = os.path.abspath('.') parentpath = sys.argv[1] if len(sys.argv)&gt;1 else "" setupfile= os.path.join(os.path.abspath('.'), __file__) build_dir = "build" build_tmp_dir = build_dir + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c31e6eb70ffebec8cd4084a3c860c5e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a5d7ca09fc60bf629b677287b66f2aa/" rel="bookmark">
			【前端异常】JavaScript错误处理：分析 Uncaught(in promise) error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 一、Promise是什么二、什么是 Uncaught(in promise) error三、解决方案3.1 使用catch方法处理Promise的错误3.2 使用 async/await 处理Promise的错误3.3 全局异常处理 四、结论 在开发过程中，JavaScript的错误处理是一个老生常谈的话题。当应用程序发生未捕获的异常时，Uncaught(in promise) error是其中最常见的错误类型。这篇文章将从多个方面详细阐述这种错误类型的原因与解决方案。
一、Promise是什么 Promise是一种用于异步编程的原生JavaScript对象。它提供了一种处理异步操作结果的方式，Promise表示一个异步任务的延迟状态。
new Promise((resolve, reject) =&gt; { // 异步操作 if (success) { resolve(result); } else { reject(error); } }).then((result) =&gt; { // 处理异步操作结果（成功后的） }).catch((error) =&gt; { // 处理异步操作错误（有异常的） }); Promise构造函数接收一个执行函数作为参数，并在异步操作完成后调用resolve或reject方法。
然后，我们可以使用then和catch方法处理相应的结果或错误。如果Promise的状态变为resolved，then方法被调用。否则，如果状态变为rejected，catch方法被调用。
下面是我项目中 index.js 中使用的方式：
export function addAlarmRule(data) { return request({ url: '/device/rule', method: 'post', data: data }); } index.vue 代码中使用的方式如下：
/** 提交按钮 */ submitForm: function() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a5d7ca09fc60bf629b677287b66f2aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88b05bf26fbd611fda0a418790271f12/" rel="bookmark">
			Eelasticsearch字段数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		映射的数据类型也就是es支持的数据类型，与Mysql中的数据类相似。但是具体的类型和MYSQL中有所区别，最主要的区别就在于ES中支持分词的数据类型，如：Text类型，可分词类型是用于支持全问检索的，这也是Es的核心的功能
数字类型 long integer short byte double float half_float scaled_float unsigned_long
基本数据类型 binary ：Base64字符串二进制类型boolean:布尔类型alias:字段别名 KeyWords keyWords:适用于索引结构化的字段，可以用于过滤，排序，聚合。KeyWords类型的字段只能通过精确搜索到。如ID，姓名这类字段应使用KeyWordsconstant_keyword:始终包含想通值的关键字字段wildcard：可正对类似grep的 3) Dates（时间类型）：包括date和 date_nanos
​ 4) alias：为现有字段定义别名。
​ 5) binary（二进制）：binary
​ 6) range（区间类型）：integer_range、float_range、long_range、double_range、date_range
​ 7) text：当一个字段是要被全文搜索的，比如Email内容、产品描述，这些字段应该使用text类型。设置text类型以后，字段内容会被分析，在生成倒排索 引以前，字符串会被分析器分成一个一个词项。text类型的字段不用于排序，很少用于聚合。（解释一下为啥不会为text创建正排索引：大量堆空间，尤其是 在加载高基数text字段时。字段数据一旦加载到堆中，就在该段的生命周期内保持在那里。同样，加载字段数据是一个昂贵的过程，可能导致用户遇到延迟问 题。这就是默认情况下禁用字段数据的原因）
​ ② 对象关系类型：
​ 1) object：用于单个JSON对象
​ 2) nested：用于JSON对象数组
​ 3) flattened：允许将整个JSON对象索引为单个字段。
​ ③ 结构化类型：
​ 1) geo-point：纬度/经度积分
​ 2) geo-shape：用于多边形等复杂形状
​ 3) point：笛卡尔坐标点
​ 2) shape：笛卡尔任意几何图形
​ ④ 特殊类型：
​ 1) IP地址：ip 用于IPv4和IPv6地址
​ 2) completion：提供自动完成建议
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88b05bf26fbd611fda0a418790271f12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee577ac3a0c13f8149055fff97e7dc7b/" rel="bookmark">
			Linux 常用命令指南 - vino命令 vnc服务端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 常用命令指南 - vino命令 vnc服务端 文章目录 Linux 常用命令指南 - vino命令 vnc服务端一、vino 是什么？二、vino 使用场景2.1 vino 安装2.2 vino 启动服务端2.3 vino 服务端配置 三、总结 一、vino 是什么？ vino 是linux上一个用于远程桌面连接的 VNC 服务端。
二、vino 使用场景 2.1 vino 安装 ubuntu 环境安装 vino :
$ sudo apt install vino $ sudo apt install dconf-editor # 非必需，查看gsettings 软件包 2.2 vino 启动服务端 查看 vino 服务配置 /usr/lib/systemd/user/vino-server.service 内容如下：
[Unit] Description=Vino VNC Server [Server] Type=dbus BusName=org.gnome.Vino ExecStart=/usr/lib/vino/vino-server Restart=on-abnormal 可通过 systemctl 命令启动：
$ systemctl --user restart vino-server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee577ac3a0c13f8149055fff97e7dc7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4fa167a1ef4d7225114ce0db2270a9f/" rel="bookmark">
			node插件MongoDB（四）—— 库mongoose 操作文档使用（新增、删除、更新、查看文档）（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言（1）问题：安装的mongoose 库版本不应该过高导致的问题（2）重新安装低版本 一、插入文档1. 代码2. node终端效果3. 使用mongo.exe查询数据库的内容 二、删除文档1. 删除一条2. 批量删除3. 代码 三、修改文档1. 修改一条2. 批量修改 四、查看文档1. 查看一条（findOne）2. 查看所有（find ）（1）查看所有符合条件的数据（2）查看所有数据 前言 （1）问题：安装的mongoose 库版本不应该过高导致的问题 比如我默认安装8.0的版本就会报下面的错误
throw new MongooseError(‘Model.create() no longer accepts a callback’); MongooseError: Model.create() no longer accepts a callback
（2）重新安装低版本 npm i mongoose@6.8.0 package.json 如下图
一、插入文档 1. 代码 // 1:安装并导入mongoose const mongoose = require('mongoose') mongoose.set('strictQuery', true); // 解决终端警告的问题 // 2: 连接 mongodb 服务 // mongodb: 表示mongodb 服务，而不是http服务 // 27017 表示端口号 // test 表示数据库名 mongoose.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4fa167a1ef4d7225114ce0db2270a9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6648d39ebc983e40b33fb1b42c09191/" rel="bookmark">
			[前端]浏览器警告：Failed to resolve component: xxxIf this is a native custom element, make sure to exclude
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你在做前端时，发现图表在浏览器显示时，浏览器控制台警告为：Failed to resolve component: xxx
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.
中文翻译为：未能解析组件：xxxx如果这是一个本地自定义的元素，请确保从组件解析中排除他
原因：
这个组件没有进行注册
解决：
1.setup 拼写错误
例子：
应改改为：setup 多多注意单词拼写
2.引用某些组件时没有加花括号
正确写法
3.components 多写 或者 忘记加括号
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c1602600ad8f60fffa336fe1d74d485/" rel="bookmark">
			自然语言处理（一）：RNN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		「循环神经网络」（Recurrent Neural Network，RNN）是一个非常经典的面向序列的模型，可以对自然语言句子或是其他时序信号进行建模。进一步讲，它只有一个物理RNN单元，但是这个RNN单元可以按照时间步骤进行展开，在每个时间步骤接收当前时间步的输入和上一个时间步的输出，然后进行计算得出本时间步的输出。
Why CNN 需要固定长度的输入、输出，RNN 的输入和输出可以是不定长且不等长的 CNN 只有 one-to-one 一种结构，而 RNN 有多种结构，如下图： Model 简单模型示例
循环神经网络的隐藏层的值s不仅仅取决于当前这次的输入x，还取决于上一次隐藏层的值s。「权重矩阵」 W就是「隐藏层」上一次的值作为这一次的输入的权重。
RNN时间线展开 时刻的输入，不仅是 ，还应该包括上一个时刻所计算的 。
使用公式表示 示例 下面我们举个例子来讨论一下，如图所示，假设我们现在有这样一句话：”我爱人工智能”，经过分词之后变成”我，爱，人工，智能”这4个单词，RNN会根据这4个单词的时序关系进行处理，在第1个时刻处理单词”我”，第2个时刻处理单词”爱”，依次类推。
从图上可以看出，RNN在每个时刻 均会接收两个输入，一个是当前时刻的单词 ，一个是来自上一个时刻的输出 ，经过计算后产生当前时刻的输出 。例如在第2个时刻，它的输入是”爱”和 ，它的输出是 ；在第3个时刻，它的输入是”人工”和 , 输出是 ，依次类推，直到处理完最后一个单词。
总结一下，RNN会从左到右逐词阅读这个句子，并不断调用一个相同的RNN Cell来处理时序信息，每阅读一个单词，RNN首先将本时刻 的单词 和这个模型内部记忆的「状态向量」 融合起来，形成一个带有最新记忆的状态向量 。
「Tip」：当RNN读完最后一个单词后，那RNN就已经读完了整个句子，一般可认为最后一个单词输出的状态向量能够表示整个句子的语义信息，即它是整个句子的语义向量，这是一个常用的想法。 Code 数据准备 import torch
import torch.nn as nn
import numpy as np
torch.manual_seed(0) # 设置随机种子以实现可重复性
seq_length = 5
input_size = 1
hidden_size = 10
output_size = 1
batch_size = 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c1602600ad8f60fffa336fe1d74d485/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3536d54ef8b5b8c5b493d3c9a13eea63/" rel="bookmark">
			【WinForm详细教程八】WinForm中的TreeView控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 `TreeView` 基本的知识属性方法事件 `TreeView` 案例演示案例一：案例二：【WinForm详细教程】源代码获取方式 TreeView 控件 用于展示分层数据，它以树形结构展示信息，每个节点可以有一个或多个子节点。TreeView 控件允许用户以可展开和可折叠的形式查看复杂的层次信息。
TreeView 基本的知识 属性 Nodes: 一个 TreeNodeCollection，包含控件的根节点。SelectedNode: 获取或设置当前选中的 TreeNode。CheckBoxes: 确定是否在每个树节点旁边显示复选框。ShowPlusMinus: 确定是否显示用于展开和折叠树节点的加号和减号。ShowLines: 确定是否显示树节点之间的连接线。 方法 BeginUpdate(): 暂停绘制控件，可以用于在添加大量节点时避免重绘，提高性能。EndUpdate(): 恢复正常绘制控件，与 BeginUpdate() 配对使用。CollapseAll(): 折叠所有的树节点。ExpandAll(): 展开所有的树节点。GetNodeAt(): 返回位于指定点的 TreeNode。 事件 AfterCheck / BeforeCheck: 在节点的复选框被用户选中或取消选中之后/之前发生。AfterSelect / BeforeSelect: 在选择某个节点之后/之前发生。AfterCollapse / BeforeCollapse: 在节点被折叠之后/之前发生。AfterExpand / BeforeExpand: 在节点被展开之后/之前发生。NodeMouseClick: 当鼠标单击 TreeNode 时发生。 节点介绍 - TreeNode
Name: 节点的唯一标识符。Text: 节点显示的文本。Nodes: 子节点的集合。 动态加载菜单表
数据库中存储节点与子节点的关系，但层次关系不明显。动态加载数据到 TreeView 控件的流程： 从数据库获取表数据。使用递归方法创建节点，并添加到 TreeView。调用方法在 TreeView 中创建并显示层次结构数据。 TreeView 节点的勾选处理
当父节点勾选或取消勾选时，所有子节点状态跟随变化。任一子节点勾选，父节点也应勾选。所有子节点都未勾选，父节点也不勾选。 TreeView 案例演示 案例一： namespace WinFormsTest { public partial class frmTreeView : Form { public frmTreeView() { InitializeComponent(); } private void frmTreeView_Load(object sender, EventArgs e) { TreeView fileTree = new TreeView(); // 单独设置 Width 和 Height fileTree.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3536d54ef8b5b8c5b493d3c9a13eea63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a83e23e4921b1bbda5a68b6eebb477f8/" rel="bookmark">
			【java学习笔记2】数组-移除元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
注意事项 数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。 思路 1. 暴力破解 发现需要删除的元素val，则该元素之后的所有元素依次向前移动（覆盖）。
需要两层循环完成，时间复杂度为O()，空间复杂度为O(n)。
2. 双指针法 双指针法：通过两个不同的指针，在一个for循环下完成两个for循环的工作。
时间复杂度：O(n)
空间复杂度：O(1)
快慢指针法： 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组慢指针：指向更新 新数组下标的位置 快慢指针初始值为0，快指针遍历原数组，如果遍历到的数组元素不等于val，则将该元素覆盖慢指针指向的位置。直到快指针将原数组遍历完成，此时原数组已经完成了元素移除。慢指针的值为新数组长度（因为最后一次还进行了一次慢指针++）。
相向双指针法： 左指针：初始值为0右指针：从数组最后一个元素开始，遍历到从右向左第一个不是val的元素的位置 left指针遍历到val值的位置，将right指针指向的元素覆盖度left位置，right向前移动一位，left继续遍历，直到left=right。此时原数组已经完成了元素移除。left值为新数组长度。
参考文献 代码随想录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aba5e21864c1ad52808aed556d5e8f9/" rel="bookmark">
			Java8强大的新特性 —— “Stream API”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是Stream API？ Java Stream API是Java 8中引入的一个重要功能，它允许开发者以声明性方式处理数据集合，使代码更加简洁、可读性更好，同时还提供了并行操作的能力，从而能够更有效地利用多核处理器。
Stream API的核心概念是Stream，它是处理数据的一种抽象方式。Stream可以看作是数据流，它可以从数据源获取数据，然后通过一系列的处理步骤，将数据转换或过滤成所需的结果。这个处理过程是声明性的，意味着开发者只需要关注数据的处理逻辑，而不必关心具体的实现细节。
Stream API的优点主要表现在以下几个方面：
简洁的代码：使用Stream API可以让代码更加简洁，因为许多复杂的操作都可以通过一条简单的Stream表达式来实现。例如，要过滤出一个列表中的偶数并求平方，使用传统的Java代码可能需要多行代码来实现，而使用Stream API只需要一条简单的链式调用即可。易于阅读和理解：Stream API的代码结构清晰，易于阅读和理解。通过链式调用，可以很清楚地看到数据的处理过程和结果。并行操作：Stream API支持并行操作，这意味着可以同时处理多个数据项，从而充分利用多核处理器的能力。这有助于提高程序的执行效率。函数式编程风格：Stream API引入了函数式编程的思想，允许开发者使用高阶函数和lambda表达式来处理数据。这使得代码更加灵活和可重用。 Stream到底是什么呢？为什么要使用Stream API？
是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。 “集合讲的是存储数据，Stream讲的是计算数据！”实际开发中，项目中多数数据源都来自于Mysql，Oracle等。但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据就需要Java层面去处理。Stream能帮我们更高效率处理数据计算。 并行流
并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。相比较串行的流，并行的流可以很大程度上提高程序的执行效率。Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与顺序流之间进行切换。 注意：
Stream 自己不会存储元素。Stream 不会改变源对象。相反，它的方法都会返回一个持有结果的新Stream。Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。 Java IO 流和 Stream API的关系？
Java IO 流主要用于文件的读写操作，它以字节流和字符流为基础，分别用于处理字节数据和字符数据。IO 流提供了一种顺序访问数据的方式，可以从输入流中读取数据，或者将数据写入输出流。它以一种同步的方式进行操作，适用于处理大规模的数据。Stream API是一种用于处理集合数据的高级抽象概念，它提供了一种流式处理的方式，能够对集合中的元素进行过滤、映射、排序、归约等操作。Stream API的目的是为了提供一种更加简洁、灵活和并行的集合操作方式。与传统的集合操作方式相比，Stream API的优势在于可以通过链式调用方法，以一种声明性的方式对集合进行处理。因此，Java IO 流和 Stream API是两种不同的数据处理方式，它们没有直接的关系。但是，它们可以相互配合使用，例如使用IO 流读取文件数据，然后使用Stream API对数据进行处理和分析 二、Stream 操作的三个步骤 创建Stream
一个数据源（如：集合、数组），获取一个流
中间操作
一个中间操作链，对数据源的数据进行处理。
终止操作(终端操作)
一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用
说明Stream 操作是延迟执行的。一次性的。（执行终止操作时才执行中间操作）
图示：
1. 创建Stream 1.1 方式一：通过集合 Java8 中的 Collection 接口被扩展，提供了两个获取流的方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5aba5e21864c1ad52808aed556d5e8f9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/23/">«</a>
	<span class="pagination__item pagination__item--current">24/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/25/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>