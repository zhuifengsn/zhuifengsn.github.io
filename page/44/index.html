<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce5112dfbafe5d8a103b3220cbb4f844/" rel="bookmark">
			Redis底层数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、什么是Redis二、底层数据结构有哪些三、Redis进阶 - 数据结构：底层数据结构详解1.简单动态字符串 - sds（1）SDS 定义（2）为什么使用SDS（3）空间预分配补进一步理解（4）小结 2.压缩列表 - ZipList（1）ziplist结构（2）Entry结构（3）为什么ZipList特别省内存（4）ziplist的缺点 3.快表 - QuickList（1）quicklist结构（2）quicklist内存布局图（3）quicklist更多额外信息 4.字典/哈希表 - Dict（1）数据结构（2）一些要点 5.整数集 - IntSet（1）intset结构（2）内存布局图（3）整数集合的升级 6.跳表 - ZSkipList（1）什么是跳跃表（2）Redis跳跃表的设计（3）为什么不用平衡树或者哈希表 7.参考文章 总结 前言 Redis 是一个数据结构服务器。Redis 的核心是提供一组原生数据类型，可帮助您解决各种各样的问题，从缓存到队列再到事件处理。下面是每种数据类型的简短描述，以及更广泛的概述。
一、什么是Redis REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库。
Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。
Redis 通常被称为数据结构数据库，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets)和有序集合(sorted sets)等类型。
Redis 是一种开源（BSD 许可）内存数据结构存储，用作数据库、缓存、消息代理和流引擎。Redis 提供数据结构，例如 字符串、散列、列表、集合、带范围查询的排序集合、位图、hyperloglogs、地理空间索引和流。Redis 具有内置复制、Lua 脚本、LRU 逐出、事务和不同级别的磁盘持久性，并通过Redis Sentinel和Redis Cluster 的自动分区提供高可用性。
您可以对这些类型运行原子操作，例如附加到字符串；递增哈希中的值；将元素推入列表；计算集合交集、并集和差集；或获得排序集中排名最高的成员。
为了获得最佳性能，Redis 使用内存中的数据集。根据您的用例，Redis 可以通过定期将数据集转储到磁盘或通过将每个命令附加到基于磁盘的日志来持久保存您的数据。如果您只需要功能丰富的联网内存缓存，也可以禁用持久性。
Redis 支持异步复制，具有快速非阻塞同步和自动重新连接，并在网络拆分时进行部分重新同步。
您可以从大多数编程语言中使用 Redis 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce5112dfbafe5d8a103b3220cbb4f844/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a50766678165f5cfcf8732db1c8aa14/" rel="bookmark">
			@Autowired和@Resource到底有什么区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Autowired 和 @Resource 都是 Spring/Spring Boot 项目中，用来进行依赖注入的注解。它们都提供了将依赖对象注入到当前对象的功能，但二者却有众多不同，并且这也是常见的面试题之一，所以我们今天就来盘它。 @Autowired 和 @Resource 的区别主要体现在以下 5 点：
来源不同；
依赖查找的顺序不同；
支持的参数不同；
依赖注入的用法不同；
编译器 IDEA 的提示不同。
1.来源不同 @Autowired 和 @Resource 来自不同的“父类”，其中 @Autowired 是 Spring 定义的注解，而 @Resource 是 Java 定义的注解，它来自于 JSR-250（Java 250 规范提案）。
小知识：JSR 是 Java Specification Requests 的缩写，意思是“Java 规范提案”。任何人都可以提交 JSR 给 Java 官方，但只有最终确定的 JSR，才会以 JSR-XXX 的格式发布，如 JSR-250，而被发布的 JSR 就可以看作是 Java 语言的规范或标准。 2.依赖查找顺序不同 依赖注入的功能，是通过先在 Spring IoC 容器中查找对象，再将对象注入引入到当前类中。而查找有分为两种实现：按名称（byName）查找或按类型（byType）查找，其中 @Autowired 和 @Resource 都是既使用了名称查找又使用了类型查找，但二者进行查找的顺序却截然相反。
2.1 @Autowired 查找顺序 @Autowired 是先根据类型（byType）查找，如果存在多个 Bean 再根据名称（byName）进行查找，它的具体查找流程如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a50766678165f5cfcf8732db1c8aa14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98da20f83fa26ee620f411e9403d64bb/" rel="bookmark">
			软件测试面试必杀篇：【2023软件测试面试八股文宝典】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		800道软件测试面试真题，高清打印版打包带走，横扫软件测试面试高频问题，涵盖测试理论、Linux、MySQL、Web测试、接口测试、App测试、Python、Selenium、性能测试、LordRunner、计算机网络、数据结构与算法、逻辑思维、人力资源等模块面试题，命中率杠杠的，绝对是测试人的福音，面试者的最强武器。
PS：加上参考答案有几十万字，答案就没有全部放上来了，高清打印版本超过400多页，留言直接获取
1 测试理论 1.1 测试基础
什么是软件测试？软件测试的目的？软件测试的目标软件测试的原则测试的工作流程测试工程师的职责软件都有多少种分类？软件的分类测试的主要方面 10、 软件测试的对象
11、 什么是“测试案例”？
12、 怎么编写案例？
13、 软件测试的两种方法
14、 测试结束的标准是什么？
15、 软件的生命周期
16、 什么是软件的生命周期？
17、 软件测试按过程分为三个步骤
18、 面向对象的设计如何影响测试？
19、 软件带来错误的原因很多。主要的原因有哪些？
20、 做好软件测试的一些关键点
21、 软件测试的步骤是什么？
22、 如何录制测试脚本？
23、 应该考虑进行如何测试的测试方法
24、 怎样估计测试工作量？
25、 测试设计的问题
26、 当测试过程发生错误时，有哪几种解决办法？
27、 测试执行的问题
28、 测试评估的目标
29、 如何提高测试？
30、 C/S 模式的优点和缺点
31、 B/S 模式的优点和缺点
32、 测试结束的标准是什么?
33、 怎么才能够全面的测试到每一个点？
34、 开发与测试的关系
35、 怎么和开发沟通
36、 测试过程
37、 测试出口准则
38、 测试完成标准
39、 测试活动中统计了哪些数据？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98da20f83fa26ee620f411e9403d64bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d539b2122c72ff6905482abf80fd605d/" rel="bookmark">
			MySQL安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、认识MySQL
二、为什么要选用MySQL
三、关于MySQL8.0
四、安装步骤
一、认识MySQL
1、MySQL是一个开放源码的关系型数据库管理系统，将数据保存再不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。
2、MySQL支持大型的数据库。可以处理拥有上万条记录的大型数据库。
3、MySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持 4GB ，64位系统支持最大的表文件为 8TB。
4、MySQL使用标准的SQL数据语言形式。
5、MySQL可以允许运行于多个系统上，并支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP和Ruby等。
二、为什么要选用MySQL 1、开放源代码，使用成本低。
2、性能卓越，服务稳定。
3、软件体积小，使用简单，并且易于维护。
4、历史悠久，社区用户非常活跃，遇到问题可以寻求帮助。
5、许多互联网公司在用，经过了时间的验证。
6、MySQL由于其体积小、速度快、总体拥有成本低，可处理上千万条记录的大型数据库，尤其是开放源码这一特点，使得很多互联网公司、中小型网站选择了MySQL作为网站数据库（Facebook，Twitter，YouTube，阿里巴巴/蚂蚁金服，去哪儿，美团外卖，腾讯）。
三、关于MySQL8.0 MySQL从5.7版本直接跳跃发布了8.0版本 ，可见这是一个令人兴奋的里程碑版本。MySQL 8版本在功能上做了显著的改进与增强，开发者对MySQL的源代码进行了重构，最突出的一点是多MySQL Optimizer优化器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。
四、安装步骤 第一步、进入官网https://www.mysql.com/
第二步：进入如下页面
第三步：进入如下页面
第四步：下载分为两种情况（下载时要选好下载路径）
4.1、下载最新版，进行如下操作，直接进行第五步
4.2、选择历史版本下载，进行如下操作，直接进行第五步
第五步：到下载好的路径下，双击 ，选择运行
第六步：如图，点击next
第七步：
第八步： 第九步：
第十步： 第十一步：
第十二步：选择ok
第十三步：
第十四步：
第十五步：
第十六步：
第十七步：
第十八步：
第十九步：
第二十步：
第二十一步：
第二十二步：
第二十三步：
第二十四步： 第二十五步：
第二十六步：
第二十七步：
第二十八步：
第二十九步： 打开cmd,进行如下操作，可正常运行，就代表着安装成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03a30fa6037a6bd240af15b4ff73ce50/" rel="bookmark">
			数据库调优策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库其他调优策略 一、数据库调优的措施1.1 调优的目标1.2 如何定位调优问题1.3 调优的维度和步骤 二、优化MySQL服务器2.1 优化服务器硬件2.2 优化MySQL的参数 三、优化数据库结构3.1 拆分表：冷热数据分离3.2 增加中间表3.3 增加冗余字段3.4 优化数据类型3.5 优化插入记录的速度3.5.1 MyISAM引擎的表3.5.2 InnoDB引擎的表 3.6 使用非空约束3.7 分析表、检查表与优化表3.7.1 分析表3.7.2 检查表3.7.3 优化表 3.8 小结 四、大表优化4.1 限定查询的范围4.2 读/写分离4.3 垂直拆分4.4 水平拆分 一、数据库调优的措施 1.1 调优的目标 尽可能节省系统资源，以便系统可以提供更大负荷的服务。（吞吐量更大）合理的结构设计和参数调整，以提高用户操作响应的速度。（响应速度更快）减少系统的瓶颈，提供MySQL数据库整体的性能。 1.2 如何定位调优问题 随着用户量的不断增加，以及应用程序复杂度的提升，我们很难用“更快”去定义数据库调优的目标，因为用户在不同时间段访问服务器遇到的瓶颈不同，比如双十一促销的时候会带来大规模的并发访问；用户在进行不同业务操作的时候，数据库的事务处理和SQL查询都会有所不同。因此我们需要更精细的定位，去确定调优的目标。
如何确定呢，一般有以下几种方式：
用户的反馈（主要）：用户是我们的服务对象，因此他们的反馈是最直接的。虽然他们不会直接提出技术建议，但是有些问题往往是用户第一时间发现的。我们要重视用户的反馈，找到和数据相关的问题。日志分析（主要）：我们可以通过查看数据库日志和操作系统日志等方式找出异常情况，通过它们来定位遇到的问题。服务器资源使用监控：通过监控服务器CPU、内存、I/O等使用情况，可以实时了解服务器的性能使用，与历史情况进行对比。数据库内部状况监控：在数据库的监控中，活动会话（Active Session）监控是一个重要的指标。通过它，你可以清楚地了解数据库当前是否处于非常繁忙的状态，是否存在SQL堆积等。其他：除了活动会话监控以外，我们也可以对事务、锁等待等进行监控，这些都可以帮助我们对数据库的运行状态由更全面的认识。 1.3 调优的维度和步骤 我们需要调优的对象是整个数据库管理系统，它不仅包括SQL查询，还包括数据库的部署配置、架构等。从这个角度来说，我们思考的维度就不仅仅局限在SQL优化上。通过以下步骤进行梳理：
第一步：选择适合的DBMS
如果对事务性处理以及安全性要求高的话，可以选择商业的数据库产品。这些数据库在事务处理和查询性能上都比较强。比如采用SQL Server、Oracle，那么单表存储上亿条数据是没有问题的。如果数据表设计得好，即使不采用分库分表的方式，查询效率也不差。
除此以外，你也可以采用开源的MySQL进行存储，它有很多存储引擎可以选择，如果进行事务处理的话可以选择InnoDB，非事务处理可以选择MyISAM。
NoSQL阵营包括键值型数据库、文档型数据库、搜索引擎、列式存储和图形数据库。这些数据库的优缺点和使用场景各有不同，比如列式存储数据库可以大幅度降低系统的I/O，适合分布式文件系统，但如果数据需要频繁地增删改，那么列式存储就不适用了。
DBMS的选择关系到了后面的整个设计过程，所以第一步就是选择适合的DBMS。 如果已经确定好了DBMS，那么这步可以跳过。
第二步：优化表设计
数据表的设计方式直接影响了后续的SQL查询语句。RDBMS中，每个对象都可以定义为一张表，表与表之间的关系代表了对象之间的关系。如果用的是MySQL，我们还可以根据不同表的使用需求，选择不同的存储引擎。除此之外，还有一些优化的原则可以参考：
表结构要尽量遵循三范式的原则。这样可以让数据结构更加清晰规范，减少冗余字段，同时也减少了在更新，插入和删除数据时等异常情况的发生。如果查询应用比较多，尤其是需要进行多表联查的时候，可以采用反范式进行优化。反范式采用空间换时间的方式，通过增加冗余字段来提高查询效率。表字段的数据类型选择，关系到了查询效率的高低以及存储空间的大小。一般来说，如果字段可以采用数值类型就不要采用字符类型；字符长度要尽可能设计得短一些。针对字符类型来说，当确定字符长度固定时，就可以采用CHAR类型；当长度不固定时，通常采用VARCHAR类型。 数据表的结构设计很基础，也很关键。好的表结构可以在业务发展和用户量增加的情况下依然发挥作用，不好的表结构设计会让数据表变的非常臃肿，查询效率也会降低。
第三步：优化逻辑查询
当我们建立好数据表之后，就可以对数据表进行增删改查的操作了。这时我们首先需要考虑的是逻辑查询优化。
SQL查询优化可以分为逻辑查询优化和物理查询优化。逻辑查询优化就是通过改变SQL语句的内容让SQL进行效率更高效，采用的方式是对SQL语句进行等价交换，对查询进行重写。
SQL的查询重写包括了子查询优化、等价谓词重写、视图重写、条件简化、连续消除和嵌套连接消除等。
第四步：优化物理查询
物理查询优化是在确定了逻辑查询优化之后，采用物理优化技术（比如索引等），通过技术代价模型对各种可能的访问路径进行估算，从而找到执行方式中代价最小的作为执行计划。在这个部分中，我们需要掌握的重点是对索引的创建和使用。
但索引不是万能的，我们需要根据实际情况来创建索引。SQL查询时需要对不同的数据表进行查询，因此在物理查询优化阶段也需要确定这些查询所采用的路径，具体的情况包括：
1. 单表扫描：对于单表扫描来说，我们可以全表扫描所有的数据，也可以局部扫描。
2. 两张表的连接：常用的连接方式包括了嵌套循环连接、HASH连接和合并连接。
3. 多张表的连接：多张数据表进行连接的时候，顺序很重要，因为不同的连接路径查询的效率不同，搜索空间也会不同。我们在进行多表连接的时候，搜索空间可能会达到很高的数据量级，巨大的搜索空间显然会占用更多的资源，因此我们需要通过调整连接顺序，将搜索空间调整在一个可接受的范围内。
第五步：使用Redis或Memcached作为缓存
除了可以对SQL本身进行优化以外，我们还可以请外援提升查询的效率。
因为数据都是存放到数据库中，我们需要从数据库层中取出数据放到内存中进行业务逻辑的操作。当用户量增大的时候，如果频繁的进行数据查询，会消耗数据库的很多资源。如果我们将常用的数据直接放到内存中，就会大幅提升查询的效率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03a30fa6037a6bd240af15b4ff73ce50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32b05afa274364783a6c188e65568bcb/" rel="bookmark">
			【MySQL】聚合函数和GROUP BY
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、聚合函数2、GROUP BY3、HAVING4、练习 1、聚合函数 聚合函数作用于一组数据，并对一组数据返回一个值。聚合函数类型：AVG()、SUM()、MAX()、MIN()、COUNT()。不能在 WHERE 子句中使用聚合函数。 SELECT AVG(salary), MAX(salary), MIN(salary),SUM(salary) FROM employees WHERE job_id LIKE '%REP%'; SELECT COUNT(*) FROM employees; # 107 -- COUNT(expr) 返回expr不为空的记录总数。 SELECT COUNT(commission_pct) FROM employees; # 35 可以对数值型数据使用AVG 和 SUM 函数。可以对任意数据类型的数据使用 MIN 和 MAX 函数。COUNT(*)返回表中记录总数，适用于任意数据类型。COUNT(expr) 返回expr不为空的记录总数。用count(*)，count(1)，count(列名)对于MyISAM引擎的表是没有区别的，引擎内部有一计数器在维护着行数。不能使用 count(列名)来替代 count() ， count() 是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。 2、GROUP BY 可以使用GROUP BY子句将表中的数据分成若干组WHERE一定放在FROM后面包含在 GROUP BY 子句中的列不必包含在SELECT 列表中 SELECT department_id, AVG(salary) FROM employees GROUP BY department_id; SELECT AVG(salary) FROM employees GROUP BY department_id; # 使用多个列分组 SELECT department_id dp_id, job_id, SUM(salary) FROM employees GROUP BY dp_id, job_id; 使用WITH ROLLUP 关键字之后，在所有查询出的分组记录之后增加一条记录，计算查询出的所有记录的总和，即统计记录数量。ROLLUP和ORDER BY是互相排斥的。当使用ROLLUP时，不能同时使用ORDER BY子句进行结果排序。 SELECT department_id, AVG(salary) FROM employees WHERE department_id &gt; 60 GROUP BY department_id WITH ROLLUP; 3、HAVING HAVING子句用于过滤分组行已经被分组。使用了聚合函数满足HAVING 子句中条件的分组将被显示。HAVING 不能单独使用，必须要跟 GROUP BY 一起使用。可以在一个查询里面同时使用 WHERE 和 HAVING。包含分组统计函数的条件用 HAVING，普通条件用 WHERE。 SELECT department_id, MAX(salary) FROM employees GROUP BY department_id HAVING MAX(salary) &gt; 1000; WHERE和HAVING的对比
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32b05afa274364783a6c188e65568bcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3e2a1a2290cc6a094aeb483f228d5f8/" rel="bookmark">
			离线部署docker与镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		离线部署docker与镜像 1.离线部署docker 1).在docker官网上下载，合适的安装文件 本次使用的是“docker-20.10.9.tgz ”
下载地址：https://download.docker.com/linux/static/stable/x86_64/
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-sum2WqKk-1657604295167)(C:\Users\roysi\AppData\Roaming\Typora\typora-user-images\image-20220622085832540.png)]
2).上传安装包 上传docker安装包，本次上传至“/opt/”文件夹下
3).执行 tar xzvf docker-20.10.9.tgz 命令，解压安装包。 [root@node01 opt]# tar xzvf docker-20.10.9.tar docker/ docker/containerd-shim-runc-v2 docker/dockerd docker/docker-proxy docker/ctr docker/docker docker/runc docker/containerd-shim docker/docker-init docker/containerd 4).进入docker目录，将目录下的所有文件拷贝至“/usr/bin/” [root@node01 opt]# cd docker [root@node01 docker]# cp * /usr/bin 5).自定义服务 执行“vim /etc/systemd/system/docker.service”命令，然后在文件中添加以下内容，然后按“esc”，退出编辑状态，输入“：qw”退出文件编辑。
[Unit] Description=Docker Application Container Engine Documentation=https://docs.docker.com After=network-online.target firewalld.service Wants=network-online.target [Service] Type=notify ExecStart=/usr/bin/dockerd ExecReload=/bin/kill -s HUP $MAINPID LimitNOFILE=infinity LimitNPROC=infinity TimeoutStartSec=0 Delegate=yes KillMode=process Restart=on-failure StartLimitBurst=3 StartLimitInterval=60s [Install] WantedBy=multi-user.target 6).给文件增加可执行权限 chmod +x /etc/systemd/system/docker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3e2a1a2290cc6a094aeb483f228d5f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/585e50b1b2368b1d1b6d6db39fd2089a/" rel="bookmark">
			@Autowired报错Could not autowire. No beans of ‘XXX‘ type found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一、背景：二、原因：三、解决方法：四、@Autowired和@Resource的区别：五、总结 一、背景： IDEA中使用@Autowired报错Could not autowire. No beans of 'XXX' type found，错误大致意思为：没有匹配到类型为XXX的bean。
二、原因： 个人觉得，注入controller的service虽然一般来说我们都是注入一个接口，但是该接口有实现类，并且使用@Service进行关联，所以注入类型应该也可以视为一个类，但是mybatis仅需提供Dao接口，也就是说，注入service的dao只是一个接口，而没有实现类，虽然mybatis能够通过Dao接口和xml文件实现与数据库的操作，但是@Autowired并没有这个识别功能，可能它就认为你类型不匹配，无法使用通过类型注入的方法。
三、解决方法： 在相应mapper中加上@Component注解检查service层有没有加入@service注解，若无则加上使用@resource注解代替@Autowired注解@Autowired(required = false) 设置required 属性值为 false，错误提示消失。在相应的dao层加入@Repository注解 四、@Autowired和@Resource的区别： @Resource和@Autowired注解都是用来实现依赖注入的。只是@AutoWried按by type自动注入，而@Resource默认按byName自动注入。@AutoWried基于spring的注解org.springframework.beans.factory.annotation.Autowired,它默认是按类型进行的装配的。任何给定bean类只有一个构造函数（最大值）可以声明这个注释，并将'required'参数设置为true，表示构造函数在用作Spring bean时要自动装配。如果多个非必需构造函数声明了注释，则它们将被视为自动装配的候选者。将选择具有最大数量的依赖项的构造函数，这些构造函数可以通过匹配Spring容器中的bean来满足。如果不能满足任何候选者，则将使用主要/默认构造函数（如果存在）。如果一个类只声明一个构造函数开头，它将始终被使用，即使没有注释。带注释的构造函数不必是公共的。@Resource是基于j2ee的注解(可以减少了与spring的耦合)（JDK1.6以上支持）默认是按名字进行注解。注释标记应用程序所需的资源。此注释可以应用于应用程序组件类，或者该组件类的字段或方法。如果将该注释应用于一个字段或方法，那么初始化应用程序组件时容器将把所请求资源的一个实例注入其中。如果将该注释应用于组件类，则该注释将声明一个应用程序在运行时将查找的资源。即使此注释没有被标记为 Inherited，部署工具仍然需要检查任意组件类的所有超类，以发现这些超类中所有使用此注释的地方。所有此类注释实例都指定了应用程序组件所需的资源。注意，此注释可能出现在超类的 private 字段和方法上；在这种情况下容器也需要执行注入操作。 五、总结 本文简单讲述了@Autowired报错Could not autowire. No beans of 'XXX' type found的原因以及解决办法欢迎大家提出建议以及批评，有任何问题可以私信 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7562ba05e7eaa2c72130b5b2ed42c3e7/" rel="bookmark">
			requestAnimationFrame
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		requestAnimationFrame requestAnimationFrame是什么 参数是一个回调函数，该回调函数会在浏览器下一次重绘之前执行。回调函数执行次数通常与浏览器屏幕刷新次数相匹配，目前一般是1s刷新60次。当requestAnimationFrame() 运行在后台标签页或者隐藏的 里时，requestAnimationFrame() 会被暂停调用以提升性能和电池寿命。比如浏览器tab切换的时候，会停止刷新。调用会执行一次。如果不断更新下一帧动画，那么回调函数自身必须再次调用 window.requestAnimationFrame() 为什么要引入reuestAnimationFrame 之前进行定时，或者间隔操作，会使用setTimeout和setIntervel,但是这两个都是内置函数，里面包裹的回调函数终究是等在主函数和微服务运行完之后再执行的，则主函数和微服务的运行事件如果过长，是会堵塞这两个函数运行的。requstAnimationFrame是在渲染进程中运行的，js的运行不会堵塞该回调函数的运行，则相对不会有那么长的延迟时间。 语法 window.requestAnimationFrame(callback);
callback：该回调函数会被传入DOMHighResTimeStamp参数，该参数与performance.now()的返回值相同，它表示requestAnimationFrame() 开始去执行回调函数的时刻。 基本使用 &lt;div class="wrapper"&gt; &lt;div class="btn-wrapper"&gt; &lt;button class="start"&gt;开始&lt;/button&gt; &lt;button class="stop"&gt;停止&lt;/button&gt; &lt;/div&gt; &lt;div class="box"&gt;盒子&lt;/div&gt; &lt;/div&gt; &lt;script&gt; let timer = null; let count = 0; let dom = { start: document.querySelector(".start"), stop: document.querySelector(".stop"), box: document.querySelector(".box"), }; function step() { if (count &gt; 200) { window.cancelAnimationFrame(timer); return; } dom.box.style.transform = `translateX(${count++}px)`; timer = window.requestAnimationFrame(step); } dom.start.addEventListener("click", () =&gt; { timer = window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7562ba05e7eaa2c72130b5b2ed42c3e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4264e147476e15d7284d8d75772b154a/" rel="bookmark">
			springboot：如何实现拦截器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Spring Boot中，可以通过实现HandlerInterceptor接口来实现拦截器。
以下是一个简单的示例：
@Component public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //在请求处理之前进行调用（Controller方法调用之前） System.out.println("请求路径：" + request.getRequestURI()); return true; //如果返回false，请求将会被拦截 } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { //请求处理之后进行调用，但是在视图被渲染之前（Controller方法调用之后） } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { //在整个请求结束之后被调用，也就是在DispatcherServlet 渲染了对应的视图之后执行（主要是用于清理资源等工作） } } 在上述代码中，MyInterceptor类实现了HandlerInterceptor接口，并重写了其中的preHandle、postHandle和afterCompletion方法，分别表示在请求处理之前、请求处理之后和整个请求结束之后的操作。
方法的详解
返回值类型方法声明描述Booleanpublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)该方法在控制器处理请求方法前执行，其返回值表示是否中断后续操作，返回true表示继续向下执行，返回false表示中断后续操作voidpublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)该方法在控制器处理请求方法调用之后，解析视图之前执行，可以通过此方法对请求域中的模型和视图做进一步修改voidpublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)该方法在视图渲染结束后执行，可以通过此方法实现资源清理，记录日志信息等工作。 最后，通过将MyInterceptor类注入到Spring Boot中，即可实现拦截器功能。例如，在Spring Boot的WebMvcConfigurer配置类中，通过addInterceptors方法添加拦截器：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4264e147476e15d7284d8d75772b154a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17f1d7a64442cda6863a4251c2eaf2ee/" rel="bookmark">
			ingress
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ingress为Kubernetes集群中的服务提供了入口，可以提供负载均衡、SSL终止和基于名称的虚拟主机，在生产环境中常用的Ingress有Treafik、Nginx、HAProxy、Istio等。在Kubernetesv 1.1版中添加的Ingress用于从集群外部到集群内部Service的HTTP和HTTPS路由，流量从Internet到Ingress再到Services最后到Pod上，通常情况下，Ingress部署在所有的Node节点上。Ingress可以配置提供服务外部访问的URL、负载均衡、终止SSL，并提供基于域名的虚拟主机。但Ingress不会暴露任意端口或协议。
[root@k8s-master ~]# wget https://github.com/kubernetes/ingress-nginx/blob/ingress-nginx-3.4.0/deploy/static/provider/baremetal/deploy.yaml #修改deploy.yaml [root@k8s-master ~]# cat deploy.yaml | grep image: image: registry.cn-hangzhou.aliyuncs.com/k8sos/ingress-controller:v0.48.1 # 修改这个 image: docker.io/jettech/kube-webhook-certgen:v1.3.0 image: docker.io/jettech/kube-webhook-certgen:v1.3.0 ③ # 应用创建名称空间资源 [root@k8s-master ~]# kubectl apply -f deploy.yaml ③ # 查看ingress-nginx命名空间下的镜像(命名空间可以随便定义 namespace是指定名称空间的) [root@k8s-master ~]# kubectl get pods -n ingress-nginx NAME READY STATUS RESTARTS AGE ingress-nginx-admission-create-x9md8 0/1 Completed 0 20m ingress-nginx-admission-patch-vvrks 0/1 Completed 2 20m ingress-nginx-controller-749c575f56-sgttt 1/1 Running 0 20m ④ # 指定名称空间查看pod的状态 [root@k8s-master ~]# kubectl describe pod -n ingress-nginx ingress-nginx-controller-749c575f56-sgttt ⑤ # 查看svc资源的信息，看到ingress端口号80/443(公司内有钱可以买弹性公网IP使用) [root@k8s-master ~]# kubectl get svc -n ingress-nginx NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE ingress-nginx-controller NodePort 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17f1d7a64442cda6863a4251c2eaf2ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b8f9a6e29ac43d56f90d5836180243a/" rel="bookmark">
			计算机三级数据库 填空题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机三级 数据库 IDEF0需求建模方法由箭头和（活动/方框/矩形）两种元素构成。、从安全性角度考虑，防火墙技术是用来保证数据库应用系统的（网络）环境安全的。在UML的状态机图中，状态之间的转移是由（事件）驱动的。在一个SELECT语句中，GROUP BY子句的逻辑执行顺序在ORDER BY子句之（前）。在一个T-SQL语言中，如果要将T1表中的全部数据复制到T2表中，T2表目前还不存在，可使用语句： SELECT * （INTO） T2 FROM T1 设有表Student(Sno,Sname)、SC(Sno,Cno,Grade)，现要查询没选C01课程的学生姓名，请补全下列语句： SELECT Sname FROM Student WHERE NOT （EXIXTS）( SELECT * FROM SC WHERE Cno = 'C01' AND Student.Sno = SC.Sno) 在SQL Server 2008中，若要提取游标cur1当前行指针所指的前一行数据，使用的选项是：FETCH （PRIOR） FROM cur1在SQL Server 2008中，若要删除U1架构，使用的语句是： SCHEMA U1 (DROP) SCHEMA U1 在SQL Server 2008中，有两种身份验证模式，一种是混合身份验证模式，另一种是(windows)身份验证模式(物化/索引)视图是包含查询结果的数据库对象，其数据不是在视图使用时才读取而是预先计算的。为了提高数据库性能，在销售单据表中增加"总价"字段（由表中"单价"×"数量"计算而来），此种数据库优化方法被称为增加（派生/导出）冗余列方法在数据库动态转储机制中，一般需要使用（日志）文件才能将数据库恢复到某一时刻的正确状态。分布式数据库系统的恢复控制采用的最典型策略是基于（2/二）阶段的提交协议。时间序列分析也可以称为数据演变分析，它能描述行为随（时间）变化的对象的规律或趋势，并对其进行建模。在关联规则挖掘中，关联规则的成立与否一般用（支持）度和置信度两个指标进行描述。数据库完整性约束条件的作用对象分为列、元组和（关系/表）三种级别。建立在主码属性上的索引称作（主）索引。在UML图中，描述系统中硬件和软件的物理配置情况和系统体系结构的图称为（部署/配置）图。在一个SELECT语句中，HAVING子句的逻辑执行顺序在WHERE子句之（后）在T-SQL语言中，如果要将T1表中的全部数据复制到T2表中，T2表已存在，可使用语句： （INSERT / INSERT INTO） T2 SELECT * FROM T1 在SQL Server 2008中，设要在销售表上定义一个更新操作的后触发器。请补全下列语句： CREATE TRIGGER tri_sales ON 销售表 (FOR/AFTER) UPDATE ... ... 在SQL Server 2008中，判断游标提取状态的全局变量是:@@（FETCH_STATUS）在SQL Server 2008中，若要将DB1数据库完整备份到BK设备上，请补全下列语句：(BACKUP) DATABASE DB1 TO BK在SQL Server 2008中，系统管理员角色是（sysadmin）在对表进行（垂直）分割后，如果需要查询原表的全部数据，需要使用join操作。将经常一起使用的多个表中的数据行按照其公共列值存储在一起，这种表存储方法为（聚集/cluster）在SQL Server 2008中，使用T-SQL语句进行数据库备份操作，需要使用（DIFFERENTIAL）关键词指定该备份为差异备份在分布式数据库中，将某一关系从行（元组）的角度依据一定条件划分为不同的片断，这种分片方法称为（水平）分片法。在数据仓库中，元数据一般分成技术元数据和（业务）元数据。在数据仓库的导出数据或物化视图（实视图）的维护策略中，只在用户查询时发现数据已经过期才进行更新的策略称为（延时/延期/推迟）维护策略。如果数据文件中的每个查找码值在索引文件中都对应一个索引记录，则称该索引为（稠密）索引。在三层浏览器/服务器体系结构的数据库应用系统中，触发器是在（数据库/database/DB）服务器上执行的。UML图中，用于表达系统中不同的包、命名空间或不同的项目间彼此关系的图称为（包/package）图。在SELECT语句中，用于进行分组的子句是（GROUP BY）SQL Server 2008提供了4个排名函数，其中（RANK/ROW_NUMBER）函数返回结果集中每行数据在每个分区内的排名，并且每个分区内的排名从1开始，但排名中间数值可能有间断。设有表Student(Sno,Sname, Sdept)，现要查询与"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b8f9a6e29ac43d56f90d5836180243a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/164d0cd831d958ddea00602fa38474b7/" rel="bookmark">
			springboot：如何实现过滤器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Spring Boot中实现过滤器有两种方式，一种是通过实现javax.servlet.Filter接口，另一种是通过实现org.springframework.web.filter.OncePerRequestFilter抽象类。下面分别介绍这两种方式的实现方法。
实现javax.servlet.Filter接口 首先，创建一个类并实现javax.servlet.Filter接口，并实现其中的doFilter方法。例如，我们创建一个LogFilter类来记录请求日志：
import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import java.io.IOException; public class LogFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { // 初始化 } @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest httpRequest = (HttpServletRequest) request; String requestURI = httpRequest.getRequestURI(); System.out.println("请求：" + requestURI); chain.doFilter(request, response); } @Override public void destroy() { // 销毁 } } 然后，在Spring Boot应用程序中注册这个过滤器。在Spring Boot中，可以通过创建一个FilterRegistrationBean对象来注册过滤器。例如，我们在MyApplication类中注册LogFilter：
import org.springframework.boot.SpringApplication; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/164d0cd831d958ddea00602fa38474b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e18f1e60a34ab7dfab8edc8dae0e6d68/" rel="bookmark">
			springboot：如何扩展springmvc的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Spring Boot中，可以通过继承WebMvcConfigurerAdapter类并重写其中的方法来扩展Spring MVC的配置。
以下是一个简单的示例：
@Configuration public class WebMvcConfig extends WebMvcConfigurerAdapter { //添加自定义的拦截器 @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new MyInterceptor()).addPathPatterns("/**"); super.addInterceptors(registry); } //自定义消息转换器 @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { converters.add(new MyMessageConverter()); super.configureMessageConverters(converters); } //静态资源处理 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler("/static/**").addResourceLocations("classpath:/static/"); super.addResourceHandlers(registry); } //跨域支持 @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping("/**") .allowedOrigins("*") .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS") .allowCredentials(false) .maxAge(3600); super.addCorsMappings(registry); } } 在上述代码中，WebMvcConfig类继承了WebMvcConfigurerAdapter类，重写了其中的addInterceptors、configureMessageConverters、addResourceHandlers和addCorsMappings方法，分别实现了添加自定义拦截器、自定义消息转换器、静态资源处理和跨域支持等功能。
最后，通过将WebMvcConfig类注入到Spring Boot中，即可将其配置应用到Spring MVC中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc9d9a0c7eddbdc58da7d12308ccc647/" rel="bookmark">
			Spring解决循环依赖为什么需要三级缓存？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 什么是循环依赖呢？我们抛开Spring这个框架来聊下什么是循环依赖，循环依赖可能在我们平时的开发过程中是属于比较常见的。Spring容器最大的功能就是对bean的生命周期进行管理，每个bean在创建的过程中，需要得到一个完整的bean需要对bean的所有属性进行赋值，如果两个bean出现了相互依赖的情况，如果Spring没有处理循环依赖，那么出现的结果就是在bean的创建过程中出现相互依赖，导致这个bean永远无法创建出来，则就导致一直在相互创建，那么Spring是如何来解决循环依赖的呢？
什么情况下会循环依赖 1.先看如下demo: B和A相互循环依赖
@Component public class B { @Autowired private A a; } @Component public class A { @Autowired private B b; } 启动项目：结果没有报错。 2.加入异步逻辑修改 @Component public class A { @Autowired private B b; @Async public void test(){ } } @Component public class B { @Autowired private A a; } @EnableAsync public class App { public static void main(String[] args) { ApplicationContext ctx = new AnnotationConfigApplicationContext(App.class); } } 启动后 ：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc9d9a0c7eddbdc58da7d12308ccc647/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae6a6ba59e899829e5baa1ad89240822/" rel="bookmark">
			0303泰勒公式-微分中值定理与导数的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 引入2 泰勒中值定理2.1 泰勒多项式3.2 泰勒中值定理13.3 泰勒中值定理22.4 误差估计 4 麦克劳林公式5 常见麦克劳林公式6 泰勒公式相关例题6.1 将函数展成指定的泰勒公式6.1.1 公式法6.1.2 间接展法（变量替换） 6.2 利用泰勒公式求极限6.3 确定无穷小的阶数6.4 求 f ( n ) ( x 0 ) f^{(n)}(x_0) f(n)(x0​)即 f ( x ) f(x) f(x)的n阶导在某一点的值6.5 证明题 7 后记 1 引入 对于一些复杂函数，我们希望用一些简单的函数（幂函数-多项式函数）来近似表达。
前面我们在学习微分时，有 f ( x ) = f ( x 0 ) + f ′ ( x 0 ) ( x − x 0 ) + o ( x − x 0 ) f(x)=f(x_0)+f^{'}(x_0)(x-x_0)+o(x-x_0) f(x)=f(x0​)+f′(x0​)(x−x0​)+o(x−x0​)（误差）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae6a6ba59e899829e5baa1ad89240822/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c869607bbc6dd344b66c984b0b75f43/" rel="bookmark">
			RAID 0 1 5 10特点和区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、RAID 是什么？？二、RAID 有哪些？三.区别 总结 前言 RAID有多种整合方式，主要有：RAID 0 1 5 10 ，不同的RAID是否有不同的功能，用什么区别？
一、RAID 是什么？？ RAID（Redundant Array of Independent Disks，独立冗余磁盘阵列）
简称为「磁盘阵列」，其实就是用多个独立的磁盘组成在一起形成一个大的磁盘系统，从而实现比单块磁盘更好的存储性能和更高的可靠性。
集中管理思想：资源整合，用统一标准进行管理
RAID 技术通过把多个硬盘设备组合成一个容量更大、安全性更好的磁盘阵列，并把数据切割成多个区段后分别存放在各个不同的物理硬盘设备上，然后利用分散读写技术来提升磁盘阵列整体的性能，同时把多个重要数据的副本同步到不同的物理硬盘设备上，从而起到了非常好的数据冗余备份效果。
任何事物都有它的两面性。
RAID 技术确实具有非常好的数据冗余备份功能，但是它也相应地提高了成本支出。
就像原本我们只有一个电话本，但是为了避免遗失，我们把联系人号码信息写成了两份，自然要为此多买一个电话本，这也就相应地提升了成本支出。RAID 技术的设计初衷是减少因为采购硬盘设备带来的费用支出，但是与数据本身的价值相比较，现代企业更看重的则是 RAID 技术所具备的冗余备份机制以及带来的硬盘吞吐量的提升。
也就是说，RAID 不仅降低了硬盘设备损坏后丢失数据的几率，还提升了硬盘设备的读写速度，所以它在绝大多数运营商或大中型企业中得到了广泛部署和应用。
1.1基本作用
基本作用：网站数据量很大的时候，单块盘装不下了，购买多块盘，又不想单个存放数据，就需要把所有硬盘整合成一个大磁盘，再在这个大磁盘上在分区（虚拟磁盘）放数据。另外一个功能，多块磁盘放在一起可以有冗余（备份）。
1.2特点（和硬盘做对比）
相同之处：组成的磁盘组就像是一个硬盘，用户可以对它进行分区，格式化等等。总之，对磁盘阵列的操作与单个硬盘一模一样。
不同之处：磁盘阵列的存储速度要比单个硬盘高很多，而且可以提供自动数据备份。数据备份的功能是在用户数据一旦发生损坏后，利用备份信息可以使损坏数据得以恢复，从而保障了用户数据的安全性。
二、RAID 有哪些？ RAID方案常见的可以分为：
RAID0RAID1RAID5RAID10 1.1 RAID 0
RAID 0 技术把多块物理硬盘设备（至少两块）通过硬件或软件的方式串联在一起，组成一个大的卷组，并将数据依次写入各个物理硬盘中。这样一来，在最理想的状态下，硬盘设备的读写性能会提升数倍，但是若任意一块硬盘发生故障，将导致整个系统的数据都受到破坏。
RAID 0 技术能够有效地提升硬盘数据的吞吐速度，但是不具备数据备份和错误修复能力。
1.2 RAID 1
RAID 1 技术示意图中可以看到，它是把两块以上的硬盘设备进行绑定，
在写入数据时，是将数据同时写入到多块硬盘设备上（可以将其视为数据的镜像或备份）。当其中某一块硬盘发生故障后，一般会立即自动以热交换的方式来恢复数据的正常使用。
RAID 1 技术虽然十分注重数据的安全性，但是因为是在多块硬盘设备中写入了相同的数据，因此硬盘设备的利用率得以下降。从理论上来说，图 7-2 所示的硬盘空间的真实可用率只有 50%.
由 3 块硬盘设备组成的 RAID 1 磁盘阵列的可用率只有 33%左右；以此类推。而且，由于需要把数据同时写入到两块以上的硬盘设备，这无疑也在一定程度上增大了系统计算功能的负载。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c869607bbc6dd344b66c984b0b75f43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9430a4c932694522d17e23fd4e066a58/" rel="bookmark">
			psycopg2 使用 executemany 新增数据 爆 can‘t adapt type ‘numpy.int64‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用psycopg2将一下DataFrame的数据，插入到PostgreSQL的某个模式中，具体方法如下：
import numpy as np import pandas as pd import psycopg2 # 根据传入的DataFrame和数据表名，在xxx模式中新建表以及插入数据 # 默认新建的表字段类型全是int，插入数据类型均为s def inert_data(origin_table,mysql_table): # 获取数据中列名，便于数据的导入 create_column = '(' column_type = '' for i in origin_table.columns: #建表字段的数据类型 create_column = create_column + i + ' int' + ',' column_type = column_type + '%s' + ',' create_column = create_column[:-1] +')' column_type = column_type[:-1] print('create_column: '+ create_column) print('column_type: '+column_type) print() # 数据库连接 db = psycopg2.connect(dbname='xxx',user='xxx',password='xxx',host='xxx',port=8000,\ options="-c search_path=xxx,public") # 创建游标对象 cursor = db.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9430a4c932694522d17e23fd4e066a58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6a338feca2d0426e917e1ec4af19c41/" rel="bookmark">
			在什么场景下使用多线程技术？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）阻塞。
一旦系统中出现了阻塞现象，则可以根据实际情况来使用多线程技术提高运行效率。
2）依赖。
业务分为两个执行过程，分别是A和B。当A业务发生阻塞情况时，B业务的执行不依赖A业务的执行结果，这时可以使用多线程技术来提高运行效率；如果B业务的执行依赖A业务的执行结果，则可以不使用多线程技术，按顺序进行业务的执行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f5ddff1b4e4d4ba8d3ff9f0b05d9d9f/" rel="bookmark">
			SpringBoot整合Swagger
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、swagger介绍
二、springboot集成swagger
1、创建一个springboot-web项目
2、导入相关依赖
3、编写一个Hellow工程
4、配置swagger ---&gt;config
5、启动springboot工程
6、配置swagger信息
7、配置swagger扫描接口
8、如何设置Swagger在生产环境中使用，在发布的时候不使用?
9、配置API文档分组
10、实体类配置
一、swagger介绍 swagger是一个接口文档生成工具，同时提供接口测试调用的辅助功能。
RestFul Api文档在线自动生成工具=&gt;Api文档与API定义同步更新
直接运行，可以在线测试API接口;
支持多种语言: (Java，Php....)
官网：API Documentation &amp; Design Tools for Teams | Swagger
二、springboot集成swagger 1、创建一个springboot-web项目 2、导入相关依赖 &lt;!--swagger 相关依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--swagger-ui.html模式 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--doc.html模式 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt; &lt;version&gt;1.9.2&lt;/version&gt; &lt;/dependency&gt; 3、编写一个Hellow工程 4、配置swagger ---&gt;config @Configuration @EnableSwagger2 //开启swagger public class SwaggerConfig { } 5、启动springboot工程 启动后访问：
http://localhost:8080/swagger-ui.html
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f5ddff1b4e4d4ba8d3ff9f0b05d9d9f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/43/">«</a>
	<span class="pagination__item pagination__item--current">44/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/45/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>