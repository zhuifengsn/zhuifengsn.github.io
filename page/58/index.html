<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88bcf94b57cc1a33e1af50ad044ff07b/" rel="bookmark">
			JAVA解决端口被占用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：win + R 输入cmd 打开运行窗口
第二步：查看占用端口号的进程号（xxx为端口号）
netstat -nao|findstr xxx 第三步：杀死该进程（xxx为上一步查出来的进程号）
taskkill /pid xxx -f 有时候用idea开发时遇到项目没有关闭，软件意外关停的问题，导致重新启动项目时出现端口号被占用的情况，用本方法可以很好的解决这个问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/931ce30352a443ee06e4d9594fa6de7d/" rel="bookmark">
			ApiFox设置获取token
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作步骤 1)添加全局变量、参数
在右上角环境中配置详细信息：全局参数填写参数名以及默认值
{{token}}，并且在全局变量中也可以填写token值。优先级就很高了。
接着在全局变量中也填写对应的本地值。
2)在登录接口运行中添加后置操作 选择提取变量，将token填入，并且根据登录接口返回的数据结构获取对应的token。例如我这里就是data.token。
添加完毕后，就会把登录接口返回的token数据填充到全局变量和全局参数中。但至此还不能实现：登录过后，其他的接口都可以调用了。要执行第3步。
特别注意：后置操作不是在接口文档中保存的，所以获取token的后置操作要保存用例，下次运行用例才能将token填充到全局变量中去。
3)在项目概览中添加Auth
点击项目概览，下方有Auth，目前我使用过API Key 和 Bearer Token。效果都一样，也是将{{token}}填入就好了，这样就是动态的获取全局变量中的token。
4)测试效果 首先是不登录时，调用其他接口的返回状态：
因为之前登陆过，但是token过期了，所以会提示token过期的信息。然后再执行一次登录接口，再观察控制台结果：在控制台可以很清晰的看到全局变量重新填充了。
然后回到其他接口调用：没有发生拦截，成功的执行了接口。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8303c9389cf4ed411753ab3acb29affc/" rel="bookmark">
			win7电脑开机后找不到explorer. exe怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑进入系统后提示windows找不到explorer.exe怎么办?电脑进入系统只有背景壁纸，并且提示无法找到explorer.exe，该如何解决?请看下文介绍。
Ghost Win7 64位旗舰版
电脑找不到explorer. exe怎么办
1、按下“win+R”打开运行输入regedit。
2、 依次打开：HKEY_LOCAL_MACHINE\SOFTWARE\—&gt;Microsoft\Windows NT\CurrentVersion\—&gt;Image File Execution Options\Explorer.exe，
然后将Explorer.exe项删除。
3、按下“ctrl+alt+del”打开任务管理器。
4、点击“文件”选择“运行新任务”。
5、输入【cmd /k copy c:\windows\system32\dllcache\explorer.exe c:\windows】命令点击“确定”。
6、再次运行命令explorer即可。
以上就是给各位小伙伴带来的windows找不到文件explorer.exe解决方法的所有内容，希望你们会喜欢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f33ffbcd9f24943baa3ef7cdfe2f60fb/" rel="bookmark">
			SQL知识梳理（四）数据类型及数据处理函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据类型及数据处理函数 一、数据类型1、数值型1.INTEGER2.DECIMAL3.FLOAT/DOUBLE(REAL) 2、文本型（区分大小写）1.CHAR2.VARCHAR 3、日期型date/time/datetime/timestamp 二、数据处理（函数）1、数值型处理函数（参数为数值型）2、文本型处理函数（参数为文本型）3、日期型处理函数(参数为日期型) 一、数据类型 1、数值型 1.INTEGER 定义：整数，只能储存整数
用法：INTEGER, INTEGER(10),其中10为数字最大宽度
2.DECIMAL 定义：定点型，储存固定位数的小数
用法：DECIMAL(M,D)
M-整个数字最长位数，默认10
D-小数部分位数，默认0
例，DECIMAL(10,2)的含义是：小数部分2位，整数部分 8位（10- 2），如果多出位数会四舍五入，短了小数点用0补齐；
注意：DECIMAL适用场景是精确计算，比如金额等；如果用float会丢失精度，原因在于二进制要想表示十进制的数就会存在误差，比如用二进制来表示0.1,根本无法精确表示,但是这不是bug,是个feature，标准就是这样定的。（详细原因参考https://blog.csdn.net/u011305680/article/details/80264508）
3.FLOAT/DOUBLE(REAL) 定义：浮点型，储存不固定位数的小数
用法：FLOAT/DOUBLE(REAL)
2、文本型（区分大小写） 1.CHAR 定义：定长字符串
用法：CHAR(10)
2.VARCHAR 定义：可变长字符串
用法：VARCHAR(100)
注意：此处的长度单位为字符个数，而不是字节的长度；
两者的区别：CHAR型不足位的时候要补空位；VARCHAR是动态分配，不存在不足位。
3、日期型 date/time/datetime/timestamp 注：如果定义一个字段为timestamp，这个字段里的时间数据会随其他字段修改的时候自动刷新，所以这个数据类型的字段可以存放这条记录最后被修改的时间。
二、数据处理（函数） 函数表达式 = 函数名 + （参数）
1、数值型处理函数（参数为数值型） 1.绝对值函数 ABS ABS (-3) = 3
2.平方根函数 SQRT SQRT (4) = 2
3.指数函数 EXP EXP (4) = e^4
4.四舍五入函数 ROUND ROUND (1.234, 2) = 1.23
5.圆周率函数 PI PI () = π
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f33ffbcd9f24943baa3ef7cdfe2f60fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1d21a0e687361445835663890e77ff1/" rel="bookmark">
			操作系统PV操作-王道课后第9题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如下图所示，三个合作进程P1，P2，P3，它们都需要通过同一设备输入各自的数据a,b,c，该输入设备必须互斥的使用，而且其第一个数据必须由P1进程读取，第二个数据必须由P2进程读取，第三个数据必须由p3进程读取。然后，三个进程分别对输入数据进行下列计算： 思考： 输入操作是互斥的，读取输入设备是非互斥的。
P1，P2之间有同步关系。
P2、P3之间有同步关系。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37b52b3a2f8c896f82016175125ca500/" rel="bookmark">
			网站使用SSL证书的重要性,教你几个步骤在华为云从HTTP变HTTPS,结合WAF增强网站的安全性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么需要 SSL 证书 网站需要 SSL 证书来确保用户数据的安全，验证网站的所有权，防止攻击者创建虚假网站版本，以及将信任传达给用户。
如果网站要求用户登录、输入个人详细信息（例如其信用卡号）或查看机密信息（例如，健康福利或财务信息），则必须对数据保密。SSL 证书有助于保持在线互动的私密性，并向用户保证该网站是真实可靠的，可以与其共享私密信息。
与企业更相关的事实是，HTTPS Web 地址需要 SSL 证书。HTTPS 是 HTTP 的安全形式，这意味着 HTTPS 网站的流量通过 SSL 进行了加密。大多数浏览器将 HTTP 网站（没有 SSL 证书的网站）标记为“不安全”。这向用户发出了一个明确的信号，即该网站可能不值得信任，这有助于敦促尚未迁移到 HTTPS 的企业执行迁移。
SSL 证书有助于保护信息，例如：
登录凭据
信用卡交易或银行账户信息
个人身份信息 - 例如全名、地址、出生日期或电话号码
法律文档和合同
病历
专有信息
简单来说就是:用户访问网站的时候HTTP传输的数据都是明文显示,中间攻击者抓包可以直观的看到所有数据,对于会员网站电商网站这种有重要客户信息的站点,这样传输非常容易泄露数据,所以经过SSL证书加密连接,中间传输的数据都经过加密处理,即使被中间人攻击抓包也无法识别数据.
但是现实场景,随着技术的发达,攻击者的技术也更高级,即使有了SSL证书有时候也无法防范攻击者多样类型的攻击.所以今天给需要的读者推荐的最佳时间场景式是:WAF(WEB防火墙)+HTTPS,来保护Web服务安全稳定.
接下来有六个步骤来介绍: 在华为云配置HTTP到HTTPS的转换和web防火墙的应用
华为云有一整套解决方案：
1.域名购买认证，服务器IP购买和ICP备案，SSL证书的申请，WEB防火墙的购买，以上做完就可以结合使用了。
以下介绍详细的操作步骤：
步骤一:购买SSL证书 华为云云证书管理服务提供多个品牌和类型的证书，您可以根据需求购买SSL证书。
根据自己的网站类型和使用场景来选择证书。
举例：个人或者小型企业就是DV和泛域名类型的，默认有效期最低是一年，过期续费。
步骤二：申请SSL证书和域名验证 成功购买证书后，您需要申请证书，即为证书绑定域名或IP、填写证书申请人的详细信息并提交审核。所有信息通过审核后，证书颁发机构才签发证书,查看下边华为云链接有申请的详细步骤.
步骤三:域名验证 证书提交申请后，您需要进行域名授权验证。按照CA中心的规范，如果您申请了SSL证书，您必须配合完成域名验证来证明您对所申请绑定的域名的所有权。
当您按照要求正确配置域名验证信息，待域名授权验证完成，CA系统中心审核通过后，才会签发证书。
步骤四：配置网站接入WAF防护 WAF防护就是防护更高级的攻击，包含网站的安全，通过对HTTP(S)请求进行检测，识别并阻断SQL注入、跨站脚本攻击、网页木马上传、命令/代码注入、文件包含、敏感文件访问、第三方应用漏洞攻击、CC攻击、恶意爬虫扫描、跨站请求伪造等攻击，保护Web服务安全稳定。
在WAF管理控制台将网站添加并接入WAF，即可启用WAF。启用之后，您网站所有的公网流量都会先经过WAF，恶意攻击流量在WAF上被检测过滤，而正常流量返回给源站IP，从而确保源站IP安全、稳定、可用。
WAF云模式可以防护通过域名访问的Web应用/网站，包括华为云、非华为云或线下的域名。
步骤五：配置证书到WAF，网站走HTTPS 您可以通过上传证书，将证书上传到WAF，使防护网站直接选择上传的证书。
步骤六：当网站接入WAF,配置WAF的规则 网站已接入Web应用防火墙（Web Application Firewall，简称WAF）进行安全防护后，您可以通过设置源站服务器的访问控制策略，只放行WAF回源IP段，防止黑客获取您的源站IP后绕过WAF直接攻击源站。
查看回源IP
添加入方向规则，源IP输入WAF的回源IP。
ELB负载均衡设置访问规则，只允许WAF回源IP访问。
WAF引擎检测机制 以上配置是最基础的WAF结合SSL证书的场景，还有更多的场景。
DDoS高防+WAF联动 WAF+HSS企业主机安全网页防篡改联动 “CDN+WAF”联动，提升网站防护能力和访问速度 以上就是SSL证书和WAF使用场景和使用详细操作方法，需要的朋友可以收藏备用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4da9246d69dd48d42955bf439908bc08/" rel="bookmark">
			配置（config.txt文件）改变树莓派VNC的分辨率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、（说明一下我遇到的情况） 打开终端，使用下面命令打开系统设置工具。
然而Display OPtions下只有Resolution并没有VNC Resolution。
所以无法通过设置VNC Resolution改变分辨率。
sudo raspi-config 2、（我是如何改变VNC分辨率的） 方法：配置/boot/config.txt文件。
参考链接：树莓派配置VNC服务+固定树莓派分辨率 - gftz_hww - 博客园
具体操作：
（1）使用树莓派自带代码编辑器geany打开/boot/config.txt文件。
sudo geany /boot/config.txt （2）语句位置在28、29行。将hdmi_group、hdmi_mode前的#去掉。
新添语句：hdmi_ignore_edid=0xa500080
# uncomment to force a specific HDMI mode (this will force VGA) hdmi_group=2 hdmi_mode=83 #//hdmi_mode=83表示分辨率为 1600x900 60Hz 16:9 reduced blanking hdmi_ignore_edid=0xa500080 #原本没有，新添加的语句(命令树莓派不检测HDMI设备的任何信息，只按照我们指定的分辨率输出) 具体的hdmi_group、hdmi_mode配置项可以参考树莓派官网链接：
参考链接：Raspberry Pi Documentation - The config.txt file
部分配置如下图（第一列的数字是hdmi_mode的值）：
（3）最后别忘记ctrl+s保存文件，命令终端输入reboot等待重新载入桌面即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36ae8fc135cb9e2b6bb88c54ed4ef7f4/" rel="bookmark">
			1.单例模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计模式 设计模式之单例模式在android中的应用 设计模式之单例模式 //单例 //饿汉 public class Singleton { private static Singleton instance = new Singleton(); private Singleton() {}; public static Singleton getInstance() return instance; } //懒汉 线程不安全 public class Singleton { private static Singleton instance; private Singleton() {}; public static Singleton getInstance() { if (instance == null) instance = new Singleton(); return instance; } } //懒汉线程安全 public class Singleton { private static Singleton instance; private Singleton() {}; private static synchronized Singleton getInstance() { if (instance == null) instance = new Singleton(); return instance; } } //双重检查模式DCL public class Singleton { private static Singleton instance; private Singleton() {}; private static Singleton getInstance() { if (instance == null) { synchronized (Singleton.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36ae8fc135cb9e2b6bb88c54ed4ef7f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e29941750a28ed198370b753bd5ff270/" rel="bookmark">
			k8s部署spark集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、构建打包镜像
打包镜像相关文件地址:链接：https://pan.baidu.com/s/1OoBuEVcCNjsYZKqBTCMWaw
提取码：ct16
进入目录，执行
docker build . -t wyx/spark:2.4.4
2、推送镜像到镜像仓库
进入harbor界面，项目-新建项目-新建wyxx项目
docker tag dc45b9403697 10.0.3.47:5000/wyx/spark:2.4.4
docker push 10.0.3.47:5000/wyx/spark:2.4.4
输出以下代表成功命令
基于kubernetes部署的两种方式
直接使用kubernetes作为集群管理器(Cluster Manager)，类似与mesos和yarn，使用方式可以看running-on-kubernetes。但是这个部署方式，一是还不成熟，不推荐在生产环境使用。第二是要求k8s版本大于1.6，但我这边版本1.5.1，线上在用，不太想升级，而spark只是想搭起来玩玩…
第二种方式是standalone的方式，即便是不用集群也能很方便的用sbin下的脚本来部署，不过使用k8s有几个好处，一个是提高机器使用率。这边的k8s集群大部分是在白天使用，晚上空闲，刚好能拿来跑数据。二是方便一键扩容，一键升级，能复用本身在k8s集群上做好的监控以及日志收集
以下内容主要依据github 上k8s example中spark的例子
https://github.com/kubernetes/examples/blob/master/staging/spark/README.md
1、namespace
为了方便管理，还是新建一个namespace，将所有的相关的都放在这个namespace下，方便资源管理。
apiVersion: v1
kind: Namespace
metadata:
name: “spark-cluster”
labels:
name: “spark-cluster”
kubectl create -f namespace-spark-cluster.yaml 新建一个名为spark-cluster的namespace。
2、构建spark-master-controller.yaml
kind: ReplicationController
apiVersion: v1
metadata:
name: spark-master-controller
spec:
replicas: 1
selector:
component: spark-master
template:
metadata:
labels:
component: spark-master
spec:
hostname: spark-master-hostname
subdomain: spark-master-headless
containers:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e29941750a28ed198370b753bd5ff270/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c23dc7c0a3887890116677108c0ab499/" rel="bookmark">
			c&#43;&#43;运算符优先级归纳
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++一共有 18个优先级，运算中按优先级进行性计算，当优先级相同时，根据结合性规则来决定。
结合性：
1.从左到右（L-R）：操作数和操作符结合的顺序大部分是从左到右结合性的，例如（）、单独的算术运算符
2.从右到左（R-L）：最典型的是赋值运算符，当赋值符号与算术运算符结合后 ，整体也是R-L。另一个最常用的就是逻辑非运算符 “！”。
在使用的时候，如果不确定，或者运算符太多，就按照自己的思路用括号隔开。
因为在程序中，正确性&gt;可读性&gt;简洁性，万万不可本末倒置
优先级1 优先级2 平时常用的最高优先级操作符是从左向右结合的一批操作符，操作数和操作符结合的顺序是从左到右。包括：函数调用、数组下标、取成员、类型转换、后置运算符等。
优先级3 此优先级都是一元运算符（单目运算符），从右向做结合。
优先级4 类成员指针运算符
优先级5 算术运算符中的乘(*)、除(/)、取余(%)
优先级6 算术运算符中的加、减
优先级7 移位运算符
优先级8 比较运算符
优先级9 比较运算符
优先级10、11、12 按位运算符
优先级13、14 逻辑运算符
这里注意，逻辑非！的优先级是3级，比逻辑与和逻辑或高很多，在混合使用的时候注意结合顺序。 &amp;&amp;和||都是短路运算：&amp;&amp;前面的表达式结果为假时，不会再进行后面表达式的运算；||前面的表达式结果为真时，后面的表达式不会运算。
优先级15 三目条件运算符
注意：三目条件运算符是短路运算。条件？A:B; 如果条件为真就执行A（B表达式不会执行，不会进行计算），否则就执行B（A表达式不会执行，不会进行计算）
优先级16 赋值运算符
优先级17 优先级18 逗号运算符
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cc5589e50b72afc7704a6264857b8fd/" rel="bookmark">
			架构思维-学习整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、学习blog Redis系列4：高可用之Sentinel(哨兵模式） - Hello-Brand - 博客园
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdb3d2514d1076bfd892ab49f174a3ea/" rel="bookmark">
			LCD12864显示屏原理及使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.芯片简介 LCD12864液晶显示模块是 128×64点阵的汉字图形型液晶显示模块，可显示汉字及图形，内置 8192个中文汉字（16X16 点阵）（需带有字库的型号才能显示中文）、128 个字符（8X16 点阵）及 64X256 点阵显示 RAM（GDRAM）。可与 CPU 直接接口，提供两种界面来连接微处理机：8-位并行及串行两种连接方式。具有多种功能：光标显示、画面移位、睡眠模式等。
主要特点如下
逻辑工作电压(VDD)：4.5～5.5V；
背光源电压 ：4.5～5.5V；
工作温度(Ta)：0～60℃(常温) / -20～75℃（宽温）；
显示角度：6：00 钟直视；
与 MCU 接口：8位或3位串行模式；
2. LCD12864引脚定义 3.LCD12864并行控制 （1）读操作时序如图
（2）写操作时序如图
（3）与MCU连接原理图
并行模式，除电源外，需要将模块的CS、SCLK、SID、DB0-DB7引脚一一与单片机连接，PSB接VCC（接地为串行模式，接VCC为并行模式），RST接VCC（低电平复位）；
（4）并行模式驱动程序
LCD12864.h
#ifndef __LCD12864_H #define __LCD12864_H //---包含头文件---// #include&lt;reg51.h&gt; //---重定义关键词---// #ifndef uchar #define uchar unsigned char #endif #ifndef uint #define uint unsigned int #endif //---定义使用的IO口---// #define LCD12864_DATAPORT P0 //数据IO口 sbit LCD12864_RS = P2^6; //（数据命令）寄存器选择输入 sbit LCD12864_RW = P2^5; //液晶读/写控制 sbit LCD12864_EN = P2^7; //液晶使能控制 sbit LCD12864_PSB = P3^2; //串/并方式控制 sbit LCD12864_RST = P3^4; //复位端 //---声明全局函数---// void LCD12864_Delay1ms(uint c); uchar LCD12864_Busy(void); void LCD12864_WriteCmd(uchar cmd); void LCD12864_WriteData(uchar dat); void LCD12864_Init(); void LCD12864_ClearScreen(void); void LCD12864_SetWindow(uchar x, uchar y,uchar *word); #endif LCD12864.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdb3d2514d1076bfd892ab49f174a3ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7849dfb7b44d31ca3bbd59178f5e70d3/" rel="bookmark">
			LCD1602显示屏原理及使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.芯片简介 LCD1602显示屏为字符显示屏，显示字符为16*2。采用 LCD 显示一个字符时比较复杂，因为一个字符由 6×8 或 8×8 点阵组成，既要找到和显示屏幕上某几个位置对应的显示 RAM 区的 8 字节，还要使每字节的不同位为“1”，其它的为“0”，为“1”的点亮，为“0”的不亮。这样一来就组成某个字符。但由于内带字符发生器的控制器来说，显示字符就比较简单了，可以让控制器工作在文本方式，根据在 LCD1602上开始显示的行列号及每行的列数找出显示 RAM 对应的地址，设立光标，在此送上该字符对应的代码即可。
主要特点如下
显示容量为16×2个字符；
芯片工作电压为4.5～5.5V，最佳工作电压为5.0V；
工作电流为2.0mA（5.0V）；
字符尺寸为2.95×4.35（W×H）mm。
2. 24C02引脚定义 VSS(1)：显示屏电源地；
VDD(2)：显示屏电源；
V0(3)：V0为液晶显示器对比度调整端；
RS(4)：寄存器选择，高电平时选择数据寄存器、低电平时选择指令寄存器；
RW(5)：读写信号线，高电平时进行读操作，低电平时进行写操作。当RS和RW共同为低电平时可以写入指令或者显示地址，当RS为低电平RW为高电平时可以读忙信号，当RS为高电平RW为低电平时可以写入数据；
EN(6)：使能端，当E端由高电平跳变成低电平时，液晶模块执行命令；
D0-D7(7-14):8位双向数据线；
A(15)：背光正极；
K(16)：背光负极；
3.LCD1602控制时序 （1）读操作时序如图：
（2）写操作时序如图
4.LCD1602驱动程序 （1）LCD1602.h
#ifndef __LCD1602_H__ #define __LCD1602_H__ #include&lt;reg52.h&gt; sbit LCD1602_RS = P2^6; sbit LCD1602_RW = P2^5; sbit LCD1602_E = P2^7; #define LCD1602_Data P0 void delay_50us_1602(unsigned int t); void LCD1602_write_com(unsigned char com); void LCD1602_write_data(unsigned int dat); void LCD1602_init(void); /******************************************* 函数名称：Disp_ZF 功 能：控制液晶显示字符 参 数：addr--显示位置的首地址 pt--指向显示数据的指针 num--显示字符个数 返回值 ：无 ********************************************/ void LCD1602_Disp_ZF(unsigned char addr,const unsigned char * pt,unsigned char num); #endif （2）LCD1602.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7849dfb7b44d31ca3bbd59178f5e70d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5baf709e656fe500d5b160c77c7e817/" rel="bookmark">
			rocketmq启动配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、设置runserver.sh 和runbroker.sh jvm 参数大小（原因是你的主机可能没有那么大的内存如测试修改：
set "JAVA_OPT=%JAVA_OPT% -server -Xms256m -Xmx512m -Xmn256m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=128m"
2、修改broker.conf 新增注册中的nameserver的地址
如测试修改：
//定义服务地址，主存地址
namesrvAddr=127.0.0.1:9876
3、执行nameserv启动
mqnamesrv ‐n 127.0.0.1:9876
4、执行broker 启动注册
mqbroker ‐n 127.0.0.1:9876 ‐c conf/broker.conf autoCre
ateTopicEnable=true
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cc645002e1229607b7c85caba9121ab/" rel="bookmark">
			ADC0832芯片原理及使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.芯片简介
ADC0832是一种 8 位分辨率、250KHZ转换频率、双通道 A/D 转换芯片。其内部电源输入与参考电压的复用，使得芯片的模拟电压输入在 0~5V 之间。芯片转换时间仅为 32μS，据有双数据输出可作为数据校验，以减少数据误差，转换速度快且稳定性能强。由于它体积小，兼容性强，性价比高而深受单片机爱好者及企业欢迎，其目前已经有很高的普及率。
主要特点如下
8 位分辨率，双通道 A/D 转换；
输入输出电平与 TTL/CMOS 相兼容；
5V 电源供电时输入电压在 0~5V 之间；
功耗仅为 15mW，工作频率为 250KHZ，转换时间为 32μS；
2.ADC0832引脚定义
CS：片选使能，低电平芯片使能
CH0：模拟输入通道0，或作为IN+/-使用；
CH1：模拟输入通道1，或作为IN+/-使用；
GND：芯片参考零电位（地）；
DI ：数据信号输入，选择通道控制；
DO ：数据信号输出，转换数据输出；
CLK：芯片时钟输入；
Vcc/REF：芯片电源；
3.ADC0832控制时序
ADC0832控制时序如图，ADC0832驱动程序是基于以下时序图来编程；
4.ADC0832驱动程序
/****************************************************************************函数功能:AD转换子程序入口参数:CH出口参数:dat****************************************************************************/unsigned char A_D(unsigned char CH){ unsigned char i,test,adval; unsigned char dat = 0; //AD值 adval = 0x00; test = 0x00; Clk = 0; //初始化 DATI = 1; _nop_(); CS = 0; _nop_(); Clk = 1; _nop_(); if ( CH == 0x00 ) //通道选择 { Clk = 0; DATI = 1; //通道0的第一位 _nop_(); Clk = 1; _nop_(); Clk = 0; DATI = 0; //通道0的第二位 _nop_(); Clk = 1; _nop_(); } else { Clk = 0; DATI = 1; //通道1的第一位 _nop_(); Clk = 1; _nop_(); Clk = 0; DATI = 1; //通道1的第二位 _nop_(); Clk = 1; _nop_(); } Clk = 0; DATI = 1; for( i = 0;i &lt; 8;i++ ) //读取前8位的值 { _nop_(); adval &lt;&lt;= 1; Clk = 1; _nop_(); Clk = 0; if (DATO) adval |= 0x01; else adval |= 0x00; } for (i = 0; i &lt; 8; i++) //读取后8位的值 { test &gt;&gt;= 1; if (DATO) test |= 0x80; else test |= 0x00; _nop_(); Clk = 1; _nop_(); Clk = 0; } if (adval == test) //比较前8位与后8位的值，如果不相同舍去。若一直出现显示为零，请将该行去掉 dat = test; nop_(); CS = 1; //释放ADC0832 DATO = 1; Clk = 1; return dat;} 如需资料可在该账号下载频道下载，或关注公众号-单片机实例设计，发送“ADC0832”获取。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ca0ff2b0d6175dd31d213bc99208911/" rel="bookmark">
			WPF DataGrid 展示数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DataGrid 经常用作数据的展示，例如：
1. UI设计 &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height="Auto"&gt;&lt;/RowDefinition&gt; &lt;RowDefinition Height="*"&gt;&lt;/RowDefinition&gt; &lt;/Grid.RowDefinitions&gt; &lt;!--Row0--&gt; &lt;TextBlock Grid.Row="0" HorizontalAlignment="Center" Foreground="Green" FontStyle="Italic" FontSize="25"&gt; Using DataGrid Control Show Data &lt;/TextBlock&gt; &lt;DataGrid Grid.Row="1" Margin="5" AutoGenerateColumns="False" x:Name="simpleDemoDataGrid" HorizontalGridLinesBrush="LightGreen" CanUserAddRows="False" IsReadOnly="True" VerticalGridLinesBrush="Black"&gt; &lt;DataGrid.Columns&gt; &lt;DataGridTextColumn Header="ID" Binding="{Binding ID}" Width="50"/&gt; &lt;DataGridTextColumn Header="Name" Binding="{Binding Name}" Width="100"/&gt; &lt;DataGridTextColumn Header="PhoneNumber" Binding="{Binding PhoneNumber}" Width="120"/&gt; &lt;DataGridTextColumn Header="Address" Binding="{Binding Address}" Width="200"/&gt; &lt;/DataGrid.Columns&gt; &lt;/DataGrid&gt; &lt;/Grid&gt; 2. 后台代码 /// &lt;summary&gt; /// MainWindow.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ca0ff2b0d6175dd31d213bc99208911/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8631a03e9c1a363d1161ca2651409bf/" rel="bookmark">
			iOS底层 Runtime深入理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Runtime是近年来面试遇到的一个高频方向，也是我们平时开发中或多或少接触的一个领域，那么什么是runtime呢？它又可以用来做什么呢？
什么是Runtime？平时项目中有用过么？
OC是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行OC的动态性就是由Runtime来支撑和实现的，Runtime是一套C语言的API，封装了很多动 态性相关的函数平时编写的OC代码，底层都是转换成了Runtime API进行调用 具体应用
利用关联对象（AssociatedObject）给分类添加属性遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档）交换方法实现（交换系统的方法）利用消息转发机制解决方法找不到的异常问题 详解isa 我们在研究对象的本质的时候提到过isa，当时说的是isa是个指针，存储的是个类对象或者元类对象的地址。
实例对象的isa指向类对象类对象的isa指向元类对象 确实，在arm64架构(真机环境)前，isa单纯的就是一个指针，里面存储着类对象或者元类对象地址，但是arm64架构后，系统对isa指针进行了优化，我们在源码中可以探其结构：
可以看到，isa是个isa_t类型的数据，我们在点进去看一下isa_t是什么数据：
isa_t是个union结构，里面包含了一个结构体，结构体里面是个宏ISA_BITFIELD，我们看看这个宏是什么？
也就是这个结构体里面包含很多东西，但是究竟是什么东西要根据系统来确定。
那么在arm64架构下，isa指针的真实结构是：
在我们具体分析isa内部各个参数分别代表什么之前，我们需要弄清楚这个union是什么呢？我们看着这个union和结构体的结构很像，这两者的区别如下↓↓
union：共用体，顾名思义，就是多个成员共用一块内存。在编译时会选取成员中长度最长的来声明。共用体内存=MAX（各变量）struct：结构体，每个成员都是独立的一块内存。 结构的内存=sizeof（各变量之和）+内存对齐 也就是说，union共用体内所有的变量，都用同一块内存，而struct结构体内的变量是各个变量有各个变量自己的内存，举例说明：
我们分别定义了一个共用体test1和一个结构体test2，里面都各自有八个char变量，打印出来各自占用内存我们发现共用体只占用了1个内存，而结构体占用了8个内存.
其实结构体占用8个内存很好理解，8个char变量，每个char占用一个，所以是8；而union共用体为什么只占用一个呢？这是因为他们共享同一个内存存储东西，他们的内存结构是这样的：
我们看到te就一个内存空间，也就是所有的公用体成员公用一个空间，并且同一时间只能存储其中一个成员变量的值，这一点我们可以打断点或打印进行确认：
我们发现，第一次打印的时候，bdf这些值都是1的打印出来都是0，这是因为当te.g = ‘0’，执行完后，这个内存存储的是g的值0，所以访问的时候打印结果都是0。第二次打印同理，te.h执行完内存中存储的是1，再访问这块内存那么得到的结果都会是1。所以我们从这也可以看出
union共用体就是系统分配一个内存供里面的成员共同使用，某一时间只能存储其中某一个变量的值，这样做相比结构体而言可以很大程度的节省内存空间。
既然我们已经知道isa_t使用共用体的原因是为了最大限度节省内存空间，那么各个成员后面的数字代表什么呢？这就涉及到了位域.
我们看到union共用体为了节省空间是不断的进行值覆盖操作，也就是新值覆盖旧值，结合位域的话可以更大限度的节约内存空间还不用覆盖旧值。我们都知道一个字节是8个bit位，所以位域的作用就是将字节这个内存单位缩小为bit位来存储东西。我们把上面这个union共用体加上位域：
上面这段代码的意思就是，abcdefgh这八个char变量不再是不停地覆盖旧值操作了，而是将一个字节分成8个bit位，每个变量一个bit位，按照顺序从右到左一次排列。
我们都知道char变量占用一个字节，一个字节有8个bit位，也就是char变量有8位，那么te和te2的内存结构如下所示：
这个结构我们也可以通过打印来验证：te占用一个字节位置，内存地址对应的值是0xaa，转换成二进制正好是10101010，也就是a~h存储的值。
我们可以看到，现在是将一个字节中的8个bit位分别让给8个char变量存储数据，所以这些char变量存储的数据不是0就是1，可以看出来这种方式非常省内存空间，将一个字节分成8个bit位存储东西，物尽其用。
所以我们根据isa_t结构体中的所占用bit位加起来=64可以得知isa指针占用8个字节空间。
虽然位域极大限度的节省了内存空间，但是现在面临着一个问题，那就是如何给这些变量赋值或者取值呢?
普通结构体中因为每个变量都有自己的内存地址，所以直接根据地址读取值即可， 但是union共用体中是大家共用同一个内存地址，只是分布在不同的bit位上，所以是没有办法通过内存地址读取值的，那么这就用到了位运算符，我们需要知道以下几个概念：
&amp;：按位与，同真为真，其余为假
|：按位或，有真则真，全假则假
&lt;&lt;：左移，表示左移动一位 （默认是00000001 那么1&lt;&lt;1 则变成了00000010 1&lt;&lt;2就是00000100）
~：按位取反
掩码 : 一般把用来进行按位与(&amp;)运算来取出相应的值的值称之为掩码(Mask)。如 #define TallMask 0b00000100 ：TallMask就是用来取出右边第三个bit位数据的掩码
好，那么我们来看下这些运算符是怎么可以做到取值赋值的呢？比如说我们上面的te共用体内有8个char，要是我们想出去char b的值怎么取呢？这就用到了&amp;：
按位与&amp;上 1&lt;&lt;1 就可以取出b位的值了，b是1那么结果就是1，b是0那么结果就是0；
同理，当我们为f设置值的时候，也是类似的操作，就是在改变f的值的同时不影响其他值,这里我们要看赋的值是0还是1，不同值操作不同:
所以，这就是共同体中取值赋值的操作流程，那么我们接下来回到isa指针这个结构体中，看一下它里面的各个成员以及怎么取赋值的↓↓
/*nonpointer 0，代表普通的指针，存储着Class、Meta-Class对象的内存地址 1，代表优化过，使用位域存储更多的信息 */ uintptr_t nonpointer : 1; \ /*has_assoc:是否有设置过关联对象，如果没有，释放时会更快*/ uintptr_t has_assoc : 1; \ /*是否有C++的析构函数（.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8631a03e9c1a363d1161ca2651409bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51421729a0454b3ff584183b2173f1c7/" rel="bookmark">
			细聊init进程和Linux系统启动流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、关于init进程二、Linux系统启动流程 一、关于init进程 系统某些程序退出的时候是可以将它重启的；
它可以产生新的进程；
它是由内核启动的；
它的进程号是1；
它是所有进程的祖先。
二、Linux系统启动流程 我们在PC上启动Windows 系统时，都知道有个东西叫BIOS（基本输入输出系统），我们Linux下也有个类似的东西，叫做U-Boot，其功能和BIOS类似，检查CPU、内存、硬盘、鼠标等设备有没有准备好，这一检查过程叫做POST，检查完后，就会去HDD（硬盘）、SDD、USB等地方寻找系统启动了。
那做嵌入式开发的时候，系统的启动流程又是怎么样的呢？
其实和Windows的情况类似，不过它的系统是放到Nandflash里面的，所有的程序都应该是放到内存中去的，启动系统之前也要做一些相应的初始化，这就需要一个启动程序Boatloader，常见的Boatloader是U-boot。
SRAM是由晶体管组成的，不用初始化，速度高，但是价格贵，面积大，一般用cache中，DRAM的话用电容充放电，用的话，CPU上有DRAM控制器才能用DRAM，DRAM控制器里面都是寄存器。
SDRAM和DDRAM又有什么区别呢？
这里以A5核的处理器为例
它其实有三级的boatloader的，它不止U-boot这个程序
第一级：RomBOOT，它是出厂固化到CPU内部的，ROM为只读存储器的意思。
第二级：为Bootstrap，其在CPU的SRAM进行运行引导，然后初始化SDRAM。
第三级：U-boot，初始化SDRAM完成后，就可以将U-boot程序搬移到SDRAM运行启动了。
不过前两级我们可以屏蔽不做考虑。
启动U-boot
关于U-boot的命令
敲boot命令启动系统
我在做4G模块的项目用的就是树莓派Linux内核的协议栈
所以Linux内核就是提供这些基础的驱动
这就是Linux内核启动的流程了，在最后，我们可以看到内核创建的第一个进程为init进程，这也是为什么init进程为所有进程的祖先的 缘故。
在用户应用程序里面，可以使用fork()函数创建子线程，可以使用exec系列的函数执行程序。
在用户应用程序，如果使用了一个野指针，会出现段错误，进程退出。
而在内核驱动使用了野指针，就会出现Kernel panic的情况，内核死掉，上层应用程序就跑不了了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5279b9d25fbc9d5ea659d57eef5c255e/" rel="bookmark">
			springboot：跨域支持Cors
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：实现WebMvcConfigurer，重写addCorsMappings方法 这种方式是全局设置
@ConditionalOnClass(WebMvcConfigurer.class) @Configuration @ConditionalOnWebApplication @ServletComponentScan @Slf4j public class WebAutoConfiguration implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping("/**") .allowedHeaders("*") //是否发送Cookie信息 .allowCredentials(true) .allowedMethods("POST","GET","PUT","DELETE","OPTIONS") //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息） //	.exposedHeaders("*") .allowedOrigins("*"); } } 方法二：在Controller中添加@CrossOrigin注解 该方式，只支持springframework4.2以后
加在类上，则该类所有Controller接口都支持
加在方法上，只支持该方法
注解详情
// // Source code recreated from a .class file by IntelliJ IDEA // (powered by Fernflower decompiler) // package org.springframework.web.bind.annotation; import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; import org.springframework.core.annotation.AliasFor; @Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5279b9d25fbc9d5ea659d57eef5c255e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f96df72449ad5a5cf2e699ac72f9456d/" rel="bookmark">
			Linux系列之比较命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Linux中有两个比较命令，它们分别是 comm 和 diff ，在比较文本文件的版本时通常很有用。本文介绍它们的区别和简单用法。
comm命令 该命令对两个文本文件进行比较，并显示每个文件独有的行和它们共有的行。
假设我们有两个文件：
~~java思维导图获取路径~~
当我们运行 comm file1.txt file2.txt 时，我们会得到：
在我看来， comm 的输出有些难看，但它是三列。请原谅我糟糕的线条：
第一列包含第一个文件参数特有的行，第二列包含第二个文件参数特有的行，第三列包含两个文件共有的行。
我们可以通过使用选项 -n ，来选择隐藏指定的列，其中 n 可以是1、2或3。假设我们只想输出两个文件共有的行，我们可以使用 comm -12 file1.txt file2.txt 。
diff命令 diff 是一个更加复杂的工具。它支持多种输出格式，并有能力一次处理大量的文本文件集。 diff 经常被用来创建 diff 文件（补丁），这些文件被 path 等程序用来将一个或多个文件的一个版本转换成另一个版本。让我们在之前的两个文件上运行 diff ： diff file1.txt file2.txt 。
这是默认的输出样式。在该格式中，每组变化之前都有一个变化命令，以 range operation range 的形式描述将第一个文件转换为第二个文件所需的位置和变化类型。
首先来看：
1d0 &lt; a 这告诉我们必须删除 file1 的第一行，也就是带a的那一行。
接下来看：
4a4 &gt; e 这告诉我们，我们必须在第一个文件里添加一行，在第四行的位置。然后告诉我们在哪一行添加 &gt; e 。
我知道这是令人困惑的，坦白说，默认样式没有使用太多的上下文格式和统一格式，让我们看看那些解释更多。让我们来看看这些，并作进一步解释。
我们可以通过添加 -c 选项来使用上下文格式：
diff -c file1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f96df72449ad5a5cf2e699ac72f9456d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/57/">«</a>
	<span class="pagination__item pagination__item--current">58/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/59/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>