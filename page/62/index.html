<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b681b1b236a7e5e9f7f01be4930e142c/" rel="bookmark">
			TreeSizeFree磁盘文件管理工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐一款实用的文件管理工具，使用这款工具，可以一目了然的查看磁盘内文件的大小及占用情况，方便清理磁盘垃圾文件。话不多说，先提供绿色版免安装版本：
百度网盘下载链接：https://pan.baidu.com/s/14jemm47259bfbtoFnVw2Ug
提取码：busa
1.下载完成后直接打开下面目录，找到 TreeSizeFree.exe，最好以管理员身份运行。
2.打开之后的界面如下：
3.选择一个需要打开的路径，例如我想看一下D盘占用情况,点击“选择路径”-&gt;"本地磁盘（D）",然后点击按钮“选择文件夹”。
很方便的就能展示文件夹占用空间大小，以及每个文件的占用大小，方便选择要清理的文件。
4.另外，搜索也很好用，速度挺快的
完。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/289a7abc8432925a1229f2b270db9ac2/" rel="bookmark">
			elasticsearch No alive nodes found in your cluster 解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先检一下host及端口是否正确，网络通不通。
其次想一下你的代码有没有bulk这类批量发送数据的操作，如果发送的数据超过默认的100MB，也会报这个错，我就中招了。解决办法就是把http.max_content_length这个参数调大即可。
我是docker安装的es，因此我们把这个elasticsearch.yaml配置文件映射到宿主机。在挂载之前先在宿主机上创建这个文件！！
touch /es/config/elasticsearch.yaml elasticsearch.yaml增加http.max_content_length配置
cluster.name: "docker-cluster" network.host: 0.0.0.0 http.max_content_length: "500mb" 然后重新开一下容器（特别注意一下，如果要删除原容器，那么在删除容器前确保数据已经挂到了宿主机，不然数据会丢失！！）：
docker run -d -p 9200:9200 -p 9300:9300 --name es-server -v /www/xxxxxx/data:/usr/share/elasticsearch/data -v /www/xxxxx/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -e "discovery.type=single-node" docker.elastic.co/elasticsearch/elasticsearch:7.5.2 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/931b922a9589f8854c346450c011133b/" rel="bookmark">
			一文讲懂SQL聚合函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是宁一。
今天讲解SQL教程第14课：聚合函数。
1、什么是聚合函数
聚合函数，顾名思义，就是会将数据记录聚合到一起的函数。
比如原先数据库中有100条记录，用聚合函数查询这100条记录中的最大值，最后输出的只有最大值的这一条记录。
2、常用的聚合函数有：
MAX( ) 最大值
MIN( ) 最小值
SUM( ) 总值
AVG( ) 平均值
COUNT( ) 记录条数
实例：在Students表中，计算学生编号Sid的最大值、最小值、总值、平均值、记录条数。
SELECT MAX(Sid) AS "最大值", MIN(Sid) AS "最小值", SUM(Sid) AS "总值", AVG(Sid) AS "平均值", COUNT(*) AS "记录条数" FROM Students; COUNT(*)的意思就是结果集中所有记录的数量，COUNT( ) 经常与DISTINCT去重关键字结合使用。
实例：在Students表中，查找一共有多少个班主任。
实例解析：将班主任Tid，进行去重，再用COUNT计算就可以了。
SELECT COUNT(DISTINCT Tid) AS "班主任数量" FROM Students; 聚合函数也是面试中经常会考的题目，通常会与GROUP BY 子句和 HAVING 子句结合使用。我们后面课程会详细讲到~
下节课，我们来讲讲GROUP BY子句。
点击关注，更新课程第一时间通知哦~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b29f217d84d796c3429d6aa0c4822256/" rel="bookmark">
			c&#43;&#43;类和对象(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
面对过程与面向对象的认识 类的引入
类的定义
类的访问限定符及封装
访问限定符：
【访问限定符说明】
封装：
类的实例化
类对象的存储方式
this指针的引出
面对过程与面向对象的认识 c语言是面向过程的，关注的是过程，分析出求解问题的过程，通过函数调用逐步解决问题。
c++是面向对象的，关注的是对象，讲一件事情拆分成不同的对象，靠对象之间的交互完成。
比如要实现一个外卖系统，用c语言写的话，会关注过程上怎样去实现它：上架商品、点外卖、派送、点评……。用c++的话，就关注对象：商家、骑手、用户。然后把有关商家、骑手、用户的信息归纳到各自的类中。
类的引入 在c语言中，结构体中只能定义变量，不能定义函数。在c++中，结构体不仅可以定义变量，而且还可以定义函数。
//c++中struct可以定义变量跟函数 struct student { void Init(const char*name, const char* sex,int age) { strcpy(_name, name); strcpy(_sex, sex); _age = age; } void Print() { cout &lt;&lt; _name &lt;&lt; " " &lt;&lt; _sex &lt;&lt; " " &lt;&lt; _age &lt;&lt; endl; } char _name[20]; char _sex[3]; int _age; }; int main() { student s1; s1.Init("张三", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b29f217d84d796c3429d6aa0c4822256/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c87073371e501b27244548dfa4457e9/" rel="bookmark">
			什么是多态？多态的具体体现是？JAVA的动态绑定机制是？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多态：方法或对象具有多种形态。是面向对象编程(Object Oriented Programming)的第三大特征，建立在封装和继承的基础之上。
OOP三大特征：封装、继承、多态。
多态的具体体现：
1.方法多态
（1）重载体现多态
（2）重写体现多态
重载与重写的区别：
例：
2.对象多态
（1）对象的编译类型和运行类型可以不一致
（2）编译类型在定义时就确定，不能变化
（3）对象的运行类型时可以变化的
（4）编译类型看定义时=号的左边，运行类型看=号的右边
多态的向上转型：
1.本质：父类的引用指向了子类的对象
2.语法：父类类型 引用名 = new 子类类型();
3.特点：
（1）可以调用父类中的所有成员（需遵守访问权限）
（2）不能调用子类的特有成员
（3）最终运行效果看子类的具体实现
例：父类A 子类B
A a = new B();
多态的向下转型：
1.本质：把指向子类对象的父类引用，转成指向子类对象的子类引用
2.语法：子类类型 引用名 = （子类类型）父类引用；
3.特点：
（1）只能强转父类的引用，不能强转父类的对象
（2）可以调用子类的所有成员
（3）父类的引用必须指向当前目标类型的对象
例：B b = (B) a; //父类引用a原来指向的是B类对象，满足(3)
JAVA的动态绑定机制：
1.当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定
2.当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用
注意事项：
属性没有重写！
例：
class A {
int count = 10;
public void display(){
System.out.println(this.count);
}
}
class B extends A {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c87073371e501b27244548dfa4457e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0974259a3d30d42d74b5f6453e0fbee9/" rel="bookmark">
			中央和省级产业政策匹配数据（含完整stata代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、数据来源：国泰安数据库
2、时间跨度：中央产业政策（2001-2020年）和省份产业政策（2006-2020年）
3、区域范围：全国
4、指标说明：
具体匹配代码详见分享文件中的do文件。
匹配流程：
1. 整理证监会2001年分类标准和证监会2012年分类标准
2. 利用国泰安的上市文件里面对应的字段匹配（具体的处理方法在分享的do文件）
3. 设置对应的虚拟变量，在行业代码匹配上之后
是否为重点支持产业
是否为国家重点支持产业
是否有政策鼓励
这些字段在产业政策原始数据里面有对应的字段
相关研究：
[1]江飞涛, 李晓萍. 直接干预市场与限制竞争:中国产业政策的取向与根本缺陷[J]. 中国工业经济, 2010(9):26-36.
[2]黎文靖, 李耀淘. 产业政策激励了公司投资吗[J]. 中国工业经济, 2014(05):122-134.
[3]殷华方, 潘镇, 鲁明泓. 中央——地方政府关系和政策执行力:以外资产业政策为例[J]. 管理世界, 2007(7):22-36.
[4]赵晋平. 我国吸收外资的产业政策研究[J]. 管理世界, 2002, 09:48-53+71.
下载链接：产业数据整理（可以直接使用）2020年+包含Stata整理代码​.zip-数据集文档类资源-CSDN下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/343c074f165689d0804ba582e6549e86/" rel="bookmark">
			mysql链接远程报错10061
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql链接远程报错10061 问题原因解决 问题 安装mysql后本地链接可以，远程无法连接。
原因 1进入mysql
mysql -uroot -p 2切换mysql
use mysql; 3查看root信息
SELECT `Host`,`User` FROM user where user="root"; 最后发现原因是root用户的权限设置是localhost即只允许本地连接。
解决 1更新用户表
UPDATE user SET `Host` = '%' WHERE `User` = 'root' and host='localhost' LIMIT 1; 2刷新权限
flush privileges; 之后再查看发现root用户的权限已经是 % 了，代表所有访问权限。
之后再连接就可以连接了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daead2ceeb01f06f4e8886c6e1fd74c0/" rel="bookmark">
			如何使用IDEA 启动war包maven项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.查看项目pom.xml文件，打包类型是不是war，因为这篇是针对war包的项目启动
2.查看数据库配置是不是正确（根据实际情况是本地还是线上）
一般有一个properties配置文件，避免启动之后发现数据库不对又得重启
3. Ctrl+Shift+Alt+S 打开"项目结构"对话框，或者点击IDEA右上角这个图标
4.在Project栏下设置Project SDK(选自己实际项目的sdk版本)，然后选Project language level对应的级别(一般例如SDK1.8就选8,1,7就选7)
5.在Modules栏下指定src为资源目录
6.在Artifacts栏下设置一个Web Application Exploded
7.点击Apply===OK
8.点击Tomcat配置，点击左上角+，选择Tomcat Server 下面的Local
9.在Server栏下选JRE为对应的SDK版本，要注意下面的HTTP port没被占用，不然需要修改端口（例如我这里改成了80）
10.在Deployment栏下添加Artifacts，修改下面的根路径，然后Apply—Ok即可启动。
启动即可根据http://localhost/访问
我是本篇小编WXM，遇到Bug需要帮助，欢迎加wx：xmzl1988 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8810d5ea7fcf60a8d658e0640c56d770/" rel="bookmark">
			【深度学习】二维CNN卷积手动实现(单/多输入单/多输出通道)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单输入单输出通道 # 手动实现卷积 单输出单输入通道 def my_conv2d(input_feature_map, kernel, stride=1, padding=0, bias=0): if padding &gt; 0: input_feature_map = F.pad(input_feature_map, (padding, padding, padding, padding)) print(input_feature_map) input_h, input_w = input_feature_map.shape kernel_h, kernel_w = kernel.shape output_w = math.floor((input_w - kernel_w + padding + stride) / stride) # 卷积输出的宽度 output_h = math.floor((input_h - kernel_h + padding + stride) / stride) # 卷积输出的高度 # 可见 要想 输出和输入的feature map大小相同则需要 将padding = kernel_w - 1 print(f"output_h:{output_h}, output_w:{output_w}") output = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8810d5ea7fcf60a8d658e0640c56d770/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb13b1b4da6232db23f860ff55efff9d/" rel="bookmark">
			后端接收参数为Date，用postman怎么传？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景 使用SSM框架时，接口的参数为Date类型接收，然后使用Postman测试时，发现总是报错说传进去的参数为String ，在转成Date失败了。
解决 试过网上找的方法：
使用系统变量{{Timestamp}}还是没用
最后解决的方式，写2021/12/16 11:11:00这样的格式就可以，SpringMVC就能转换成日期。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41f2925c5a51a8d4737cdfac27901f89/" rel="bookmark">
			PID算法详解（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据偏差的比例(P)、积分(I)、微分(D)进行控制(简称PID控制)，是
控制系统中应用最为广泛的一种控制规律。
PID调节器之所以经久不衰，主要有以下优点：
(1)技术成熟，通用性强
(2)原理简单，易被人们熟悉和掌握
(3)控制效果较好
（一）、PID的形式：
P：Proportion（比例），就是输入偏差乘以一个常数。
I ：Integral（积分），就是对输入偏差进行积分运算。
D：Derivative（微分），对输入偏差进行微分运算。
注：输入偏差=读出的被控制对象的值-设定值。比如说我要把温度控制在26度，但是现在我从温度传感器上读出温度为28度。则这个26度就是”设定值“，28度就是“读出的被控制对象的值”。
PID控制律的表达式：
对应的模拟PID调节器的传递函数为 其中KP为比例增益；TI为积分时间常数；TD为微分时间常数；u(t)为控制
量(控制器输出)；e(t)为被控量与给定值的偏差。
（二）PID参数对控制性能的影响
1.随着比例系数Kp的增加，超调量增大，系统响应速度加快，
2.积分时间常数Ti对控制性能的影响
积分作用的强弱取决于积分常数Ti。Ti越小，积分作用就越强，反之
Ti大则积分作用弱。积分控制的主要作用是改善系统的稳态性能，消除
系统的稳态误差。当系统存在控制误差时，积分控制就进行，直至无
差，积分调节停止，积分控制输出一常值。
加入积分控制可使得系统的相对稳定性变差。Ti值的减小可能导致
系统的超调量增大，Ti值的增大可能使得系统响应趋于稳态值的速度减
慢。
3.微分时间常数Td对控制性能的影响
随着微分时间常数Td的增加，闭环系统响应的响应速度加快，调节
时间减小。微分环节的主要作用是提高系统的响应速度。由于该环节对
误差的导数(即误差变化率发生作用)，它能在误差较大的变化趋势时施加
合适的控制。
但是过大的Kd值会因为系统造成或者受控对象的大时间延迟而出现
问题。微分环节对于信号无变化或变化缓慢的系统不起作用。 总结：
*比例控制能迅速反映误差，从而减小误差，但比例控制不能消除稳态误
差，KP的加大会引起系统的不稳定；
*积分控制的作用是，只要系统存在误差，积分控制作用就不断地积累，
输出控制量以消除误差。因此只要有足够的时间，积分控制将能完全消
除误差，但是积分作用太强会使系统超调加大，甚至使系统出现振荡；
*微分控制可以减小超调量，克服振荡，使系统的稳定性提高，同时加快
系统的动态响应速度，减小调整时间，从而改善系统的动态性能。
（三）数字PID控制器的基本算法（计算机编程实现，大家最关心的部分）
由于计算机控制是一种采样控制，它只能根据采样时刻的偏差值计
算控制量。
在计算机控制系统中，PID控制规律的实现必须用数值逼近的方法。
当采样周期相当短时，用求和代替积分、用后向差分代替微分，使模拟
PID离散化变为差分方程。
(1) 数字PID位置型控制算法
(2) 数字PID增量型控制算法
1.位置型控制算法
2.增量型控制算法
增量式控制算法的优点
(1) 增量算法不需要做累加，控制量增量的确定仅与最近几次误差采
样值有关，计算误差或计算精度问题，对控制量的计算影响较小。而位
置算法要用到过去的误差的累加值，容易产生大的累加误差。
(2)增量式算法得出的是控制量的增量，例如阀门控制中、只输出阀
门开度的变化部分，误动作影响小，必要时通过逻辑判断限制或禁止本\
次输出，不会严重影响系统的工作。而位置算法的输出是控制量的全量
输出，误动作影响大。
(3) 采用增量算法，易于实现手动到自动的无冲击切换。
(4) 利用增量算法，也很容易得出位置算法u(k)= u(k-1)+△u(k)
数字PID控制算法流程 下文将讲解PID控制算法集中改进。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41f2925c5a51a8d4737cdfac27901f89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47fdb4cb81269a1f44ffd94b44e3d1e7/" rel="bookmark">
			如何调优SQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何调优SQL 如何定位并优化慢查询Sql 具体场景具体分析只提出大致思路，其实这个问题属于开放性的题目，主要考察有没有做过SQL优化，由于该问题属于经验的问题，做过了就是做过了没做过就是没做过，问了你就知道是没有做过的，没办法给出大家准确的答案只能给出大致思路，这里提前公布一下答案。然后我们再依依去讲解
第一步：根据慢日志定位慢查询SQL
第二部：使用explain等工具分析SQL
第三部：修改SQL或者尽量让SQL走索引
根据慢日志定位慢查询SQL 那开始我们的第一步，定位并优化慢SQL。首先我们先要分析慢日志，接下来我们将通过一个简单实用的调优例子，来看看这个问题。我们再次打开MySql客户端，连接上我们的database_demo这个数据库，那MySql呢有很多自带的系统变量，咱们可以通过查看一些系统变量来得知我们的配置信息，那这里呢，我们是要查询跟慢日志有关的配置信息。什么是慢日志呢，慢日志就是用来记录我们查询得比较慢得一些SQL。
那我们来查询一些变量。
show variables like '%quer%'; 我们可以查询出一些相关得变量来。
那这些变量呢，我们只需要关注这3个。
第一个是slow_query_log 顾名思义就是我们得慢日志了，它现在是 OFF 也就是是关闭的，我们需要将它打开。
第二个是slow_query_log_flie 这个文件会记录我们的慢日志。
第三个是long_query_time 现在表示得是每次执行sql花费10秒钟的话。就会被记录 到 slow_query_log_flie 对应的文件中。
了解完这三个变量之后呢我们还需要对它进行设置，slow_query_log 我们是要将它进行打开的，并且呢long_query_time 它现在是10 秒钟对于我们的程序运行来说是非常非常慢的。因此通常情况下它执行超过1秒钟我们就认为这条sql是比较慢的了，要去做优化了，因此这里我们呢把 long_query_time 设置成 1秒。
set global slow_query_log = on; # 打开慢查询 立即设置立即生效 set global long_query_time = 1; # 设置慢查询时间 单位 s (秒) 重新连接MySql客户端才能生效 # 如果想让 配置立即生效linux 可以在 my.cnf,windows是my.ini 配置文件，对这些值进行设置，一旦设置是永久# 保存的。如果我们仅在这里做set global 当我们重启数据库服务的时候，他就会还原成之前的状态，也就是说 # slow_query_log 是 OFF 它就是 OFF 那我们现在重新连接一下数据库。
可以看到之前的 set global 设置已经成功了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47fdb4cb81269a1f44ffd94b44e3d1e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bab9d05b04284108259584da1be7518/" rel="bookmark">
			小米笔记本pro 双硬盘双系统 opencore引导安装黑苹果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人情况说明：
小米笔记本PRO 15.6
项目参数CPUi5 8250UGPUMX150内存8G硬盘1三星pm961 256g硬盘2intel 240g 注意事项：
三星pm981装黑苹果会有问题，嫌麻烦的话建议直接换硬盘。我这边两块都不是pm981，所以两块安装都没什么问题。
一、材料准备 准备TransMac作为u盘烧录工具
说明：balenaEtcher也可以，但是我实际使用中，balenaEtcher写入后验证失败，但TransMac没有问题。Rufus应该也可以，但没有试过，这个随你遍。
准备DiskGenius作为磁盘分区工具
说明：很多高级功能我们也用不到，这个其实可以理解成高级版的windows磁盘工具+windows此电脑。
准备MacOS镜像，来源黑果小兵
说明：我下载的版本合并了OC、CLOUVER、WINPE，还是比较方便的，自己也不用另外准备PE做急救盘了。
版本选择：这个可以自己选择，新旧自己选择，但是过旧的版本对于某些驱动的支持可能有问题，过新的版本对于配置较低的机器又不是很友好，所以全靠自己权衡。我这边选择的是10.15.7。
准备定制化EFI文件，来源daliansky’s github
说明：注意找到自己对应机型/主板的EFI文件，根据不同的引导类型进行下载。我这边选择的是小米pro opencore引导的EFI。这边下载的EFI中可能有一些驱动都打好了，例如网卡驱动，所以可能后期也不用自己打驱动了。
可能会用到OpenCore Auxiliary Tools，详见OC引导选择页面黑屏，但是可以盲操作，这一步非必要，如果出问题了，可以按照链接做一下。
二、硬盘准备 使用disk genius对第二块磁盘进行分区。
删除所有分区，清空数据，记得结束还要点击工具栏的保存更改。
接着点击工具栏的快速分区
我这边忘记截图了，所以用网上别人的图来说明下，注意里面的备注。
三、刻录镜像 准备一个16g+的u盘。
使用TransMac
format成Mac格式
完成之后，会提示需要格式化才能使用该U盘，点击取消
使用MacOS镜像恢复
再次右键点击u盘，然后点击Restore with Disk Image，选择你的mac镜像，进行烧录。
这边时间有点长，耐心等待
完成之后，可能会提示需要格式化才能使用该U盘，点击取消
四、替换EFI文件 打开DiskGenius，选择U盘中的OC盘符，点击EFI文件夹，把我们下载的定制化EFI文件和它替换。
注：五、六可参考视频 小米笔记本pro黑苹果安装
五、重启进入BIOS 开机按f2进入bios
第一次需要设置密码，然后关闭secure boot,在启动项里面，选择U盘OC引导启动。
六、安装MacOS 选择安装macos，然后会读条，结束后正式进入安装。
首先点击磁盘工具，选择刚才分区后的那个NTFS格式的卷标为MAC的磁盘，右键抹掉，卷标保持MAC不变，格式选择APFS。抹掉后叉掉返回，点击开始安装，安装目录选择刚才格式化得到的卷标为MAC的磁盘。 七、EFI移入硬盘 使用Opencore Configurator工具进行操作，选择
挂载EFI，在弹出框中的下半部分，选择需要挂载的EFI，注意卷标。
需要挂载的是：
macos所在硬盘的EFI分区
u盘中的EFI分区
这边说明一下，如果你的u盘中OC引导没有放在EFI分区中，比如我的就放在了OC分区，此时就不用挂载了，因为这个分区不依靠工具也能挂载上。
总之不管你怎么挂载，就是要把OC引导的EFI文件复制到硬盘EFI分区中即可。
八、调整BIOS启动顺序 再次重启进入bios，此时在启动项中，把你的macos所在磁盘的UEFI放到第一位，保存。此时启动的时候就自动进入opencore引导界面了，可以自行选择windows或者macos。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f31c81ab99a7e23330f36c511ea836d/" rel="bookmark">
			黑苹果open core引导 选择系统界面黑屏，但是可以盲操作左右移动和回车，进度条第一阶段没有苹果logo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目场景： 小米pro装黑苹果，opencore引导，OC版本0.8.0
问题 之前装的时候都好好的，今天装的时候，引导选择了OC引导，但是一进去就黑屏，然后过了几秒就去windows了，一度以为是u盘问题，重烧了好几次u盘还是没有解决。
然后想着会不会只是图形界面没输出呢？然后就左右方向键按了几下然后回车，居然就开始读条了？但是读条刚开始还是没有苹果标志的，所以问题就变成了系统选择界面黑屏+读条没有苹果标志。
原因分析： 找了很久也没找到比较类似的问题说法，而且之前装的时候用的同样的配置也是正常的，今天突然就不正常了。
解决方案： 找到一个方案opencore在选择器界面之后黑屏，和我的问题其实也不是完全一样，而且他这边是说要把config.plist中的ProvideConsoleGOP启用，但是我看了我的就是启用的，然后我就按照他的反过来做了，也就是把这个配置取消了，结果就正常了，有点莫名奇妙。
综上所述，如果安装的时候OC进去直接黑屏，过几秒自动进windows，可以考虑是显示没输出。
这个时候两个方法：
进windows，然后使用windows上的OC配置工具，例如 oc auxiliary tools ，加载u盘中OC文件夹中的config.plist，然后把UEFI设置中的ProvideConsoleGOP尝试启用或者尝试取消。直接盲操作，右方向键点一下，应该就能选到install macos，然后回车即可，这个时候还是可以进入到安装界面的。安装结束之后，进入macos使用mac平台的oc配置工具进行配置。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74c84793c10a428ba5f4edbc74122960/" rel="bookmark">
			[C#][原创]webview2简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、本例子需要下载
Microsoft.Web.WebView2 WebView2.Runtime.X64或者​​​​​​WebView2.Runtime.X86
引用库：
webview2运行库这样放置：
代码如下：
using Microsoft.Web.WebView2.Core; using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.IO; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; namespace WindowsFormsApplication1 { public partial class Form1 : Form { public Form1() { InitializeComponent(); } private async void Form1_Load(object sender, EventArgs e) { await webView21.EnsureCoreWebView2Async(await CoreWebView2Environment.CreateAsync(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "WebView2"))); this.webView21.CoreWebView2.Navigate("https://www.baidu.com"); //webView21.Source = new Uri("https://www.baidu.com"); webView21.CoreWebView2.NewWindowRequested += CoreWebView2_NewWindowRequested; } void CoreWebView2_NewWindowRequested(object sender, CoreWebView2NewWindowRequestedEventArgs e) { var deferral = e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74c84793c10a428ba5f4edbc74122960/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d4959f356de0d0ad54a660f8ad52f1b/" rel="bookmark">
			C语言 队列--顺序队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.3 队列--顺序队列 1.main.c``` // // main.c // 9_SqeQueue // // Created by ls on 2022/5/23. // Copyright © 2022 LSC001. All rights reserved. // #include "SqeQueue.h" int main() { SQueue myQueue; InitQueue(&amp;myQueue); int select = 1; ElemType value = 0; while(select) { printf("********************************************\n"); printf("* [1] push_back [2] pop_back *\n"); printf("* [3] show_Stack [4] isEmpty *\n"); printf("* [5] get_top [6] length *\n"); printf("* [7] clear [8] destroy *\n"); printf("********************************************\n"); printf("请选择：&gt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d4959f356de0d0ad54a660f8ad52f1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4649fc960d09deed234649fea713c493/" rel="bookmark">
			【Java面试题】Spring 为何需要三级缓存解决循环依赖，而不是二级缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在使用 Spring 框架的日常开发中，bean 之间的循环依赖太频繁了，Spring 已经帮我们去解决循环依赖问题，对我们开发者来说是无感知的，下面具体分析一下 Spring 是如何解决 bean 之间循环依赖，为什么要使用到三级缓存，而不是二级缓存。
bean生命周期 首先大家需要了解一下bean在spring中的生命周期，bean在spring的加载流程，才能够更加清晰知道spring是如何解决循环依赖的。
我们在spring的BeanFactory工厂列举了很多接口，代表着bean的生命周期，我们主要记住的是我圈红线圈出来的接口, 再结合spring的源码来看这些接口主要是在哪里调用的
AbstractAutowireCapableBeanFactory类的doCreateBean方法是创建bean的开始，我们可以看到首先需要实例化这个bean，也就是在堆中开辟一块内存空间给这个对象，createBeanInstance方法里面逻辑大概就是采用反射生成实例对象，进行到这里表示对象还并未进行属性的填充，也就是@Autowired注解的属性还未得到注入。
我们可以看到第二步就是填充bean的成员属性，populateBean方法里面的逻辑大致就是对使用到了注入属性的注解就会进行注入，如果在注入的过程发现注入的对象还没生成，则会跑去生产要注入的对象，第三步就是调用initializeBean方法初始化bean，也就是调用我们上述所提到的接口
可以看到initializeBean方法中，首先调用的是使用的Aware接口的方法，我们具体看一下invokeAwareMethods方法中会调用Aware接口的那些方法
我们可以知道如果我们实现了BeanNameAware，BeanClassLoaderAware，BeanFactoryAware三个Aware接口的话，会依次调用setBeanName(), setBeanClassLoader(), setBeanFactory()方法，再看applyBeanPostProcessorsBeforeInitialization源码
发现会如果有类实现了BeanPostProcessor接口，就会执行postProcessBeforeInitialization方法，这里需要注意的是：如果多个类实现BeanPostProcessor接口，那么多个实现类都会执行postProcessBeforeInitialization方法，可以看到是for循环依次执行的，还有一个注意的点就是如果加载A类到spring容器中，A类也重写了BeanPostProcessor接口的postProcessBeforeInitialization方法，这时要注意A类的postProcessBeforeInitialization方法并不会得到执行，因为A类还未加载完成，还未完全放到spring的singletonObjects一级缓存中。
再看一个注意的点
可以看到ApplicationContextAwareProcessor也实现了BeanPostProcessor接口，重写了postProcessBeforeInitialization方法，方法里面并调用了invokeAwareInterfaces方法，而invokeAwareInterfaces方法也写着如果实现了众多的Aware接口，则会依次执行相应的方法，值得注意的是ApplicationContextAware接口的setApplicationContext方法，再看一下invokeInitMethods源码
发现如果实现了InitializingBean接口，重写了afterPropertiesSet方法，则会调用afterPropertiesSet方法，最后还会调用是否指定了init-method，可以通过&lt;bean init-method&gt;标签，或者@Bean注解的initMethod指定，最后再看一张applyBeanPostProcessorsAfterInitialization源码图
发现跟之前的postProcessBeforeInitialization方法类似，也是循环遍历实现了BeanPostProcessor的接口实现类，执行postProcessAfterInitialization方法。整个bean的生命执行流程就如上面截图所示，哪个接口的方法在哪里被调用，方法的执行流程
最后，对bean的生命流程进行一个流程图的总结
三级缓存解决循环依赖 上一小节对bean的生命周期做了一个整体的流程分析，对spring如何去解决循环依赖的很有帮助。前面我们分析到填充属性时，如果发现属性还未在spring中生成，则会跑去生成属性对象实例
我们可以看到填充属性的时候，spring会提前将已经实例化的bean通过ObjectFactory半成品暴露出去，为什么称为半成品是因为这时候的bean对象实例化，但是未进行属性填充，是一个不完整的bean实例对象
spring利用singletonObjects, earlySingletonObjects, singletonFactories三级缓存去解决的，所说的缓存其实也就是三个Map
可以看到三级缓存各自保存的对象，这里重点关注二级缓存earlySingletonObjects和三级缓存singletonFactory，一级缓存可以进行忽略。前面我们讲过先实例化的bean会通过ObjectFactory半成品提前暴露在三级缓存中
singletonFactory是传入的一个匿名内部类，调用ObjectFactory.getObject()最终会调用getEarlyBeanReference方法。再来看看循环依赖中是怎么拿其它半成品的实例对象的。
我们假设现在有这样的场景AService依赖BService，BService依赖AService
AService首先实例化，实例化通过ObjectFactory半成品暴露在三级缓存中填充属性BService，发现BService还未进行过加载，就会先去加载BService再加载BService的过程中，实例化，也通过ObjectFactory半成品暴露在三级缓存填充属性AService的时候，这时候能够从三级缓存中拿到半成品的ObjectFactory 拿到ObjectFactory对象后，调用ObjectFactory.getObject()方法最终会调用getEarlyBeanReference()方法，getEarlyBeanReference这个方法主要逻辑大概描述下如果bean被AOP切面代理则返回的是beanProxy对象，如果未被代理则返回的是原bean实例，这时我们会发现能够拿到bean实例(属性未填充)，然后从三级缓存移除，放到二级缓存earlySingletonObjects中，而此时B注入的是一个半成品的实例A对象，不过随着B初始化完成后，A会继续进行后续的初始化操作，最终B会注入的是一个完整的A实例，因为在内存中它们是同一个对象。下面是重点，我们发现这个二级缓存好像显得有点多余，好像可以去掉，只需要一级和三级缓存也可以做到解决循环依赖的问题？？？
只要两个缓存确实可以做到解决循环依赖的问题，但是有一个前提这个bean没被AOP进行切面代理，如果这个bean被AOP进行了切面代理，那么只使用两个缓存是无法解决问题，下面来看一下bean被AOP进行了切面代理的场景
我们发现AService的testAopProxy被AOP代理了，看看传入的匿名内部类的getEarlyBeanReference返回的是什么对象
发现singletonFactory.getObject()返回的是一个AService的代理对象，还是被CGLIB代理的。再看一张再执行一遍singletonFactory.getObject()返回的是否是同一个AService的代理对象
我们会发现再执行一遍singleFactory.getObject()方法又是一个新的代理对象，这就会有问题了，因为AService是单例的，每次执行singleFactory.getObject()方法又会产生新的代理对象，假设这里只有一级和三级缓存的话，我每次从三级缓存中拿到singleFactory对象，执行getObject()方法又会产生新的代理对象，这是不行的，因为AService是单例的，所有这里我们要借助二级缓存来解决这个问题，将执行了singleFactory.getObject()产生的对象放到二级缓存中去，后面去二级缓存中拿，没必要再执行一遍singletonFactory.getObject()方法再产生一个新的代理对象，保证始终只有一个代理对象。还有一个注意的点
总结 前面先讲到bean的加载流程，了解了bean加载流程对spring如何解决循环依赖的问题很有帮助，后面再分析到spring为什么需要利用到三级缓存解决循环依赖问题，而不是二级缓存。网上可以试试AOP的情形，实践一下就能明白二级缓存为什么解决不了AOP代理的场景了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/925792c9eb4e7a8f6f841223f4d4ba60/" rel="bookmark">
			Java回调函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java回调函数 定义（百科）：回调函数就是一个被作为参数传递的函数。
理解回调我们需要明白回调是相对谁而言。通常，我们会调用第三方封装好的库（API），这些库对外提供的API中，有的会需要我们提供一个接口实现类，例如：
public class RedisTemplate&lt;K, V&gt; { public &lt;T&gt; T execute(SessionCallback&lt;T&gt; session) { // ...这里是一些省略掉代码逻辑 return session.execute(this); } } 其中SessionCallback是一个函数式接口：
public interface SessionCallback&lt;T&gt; { &lt;K, V&gt; T execute(RedisOperations&lt;K, V&gt; operations) throws DataAccessException; } 当我们调用RedisTemplate的execute方法时，我们需要提供SessionCallback的实现类，而这个接口实现类就会含有一段逻辑代码（抽象方法），再观察RedisTemplate的execute方法，其调用了我们传入的接口实现类中实现的抽象方法，这就是回调函数（定义）。
总结：1、站在第三方库提供的公开API的角度而言，我们这些使用该API的人必须要提供回调函数，而当前API内部不管你实现的逻辑如何，反正我就是会调用。2、再看流程：程序员（调用时传入回调函数）—&gt;第三方API—&gt;程序员提供的回调函数，此过程中站在程序员角度而言，我传给第三方API的函数就是回调函数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/969b0ef0c8b735cd68f5fd2d364be02f/" rel="bookmark">
			解决vue项目一直报格式错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一直报格式错误是因为我们创项目的时候勾选了ESlint 我们只需要在创建项目的时候不勾选它就不会报空格和换行的错误
首先我们win+r打开命令行窗口
输入 vue ui进入图形化界面
然后在创建项目的时候选择手动配置项目
然后把Linter/Formatter（一般是多人做项目时需要）这一项取消勾选，其他的可以根据自己的需求勾选
然后在选择标准就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6e5e3c72441d77d9bd699614240bf53/" rel="bookmark">
			在VUE组件里面重置数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方法一、重置表单数据from
this.form = this.$options.data().form 方法二、重置所有数据
this.$data = this.$options.data() 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/61/">«</a>
	<span class="pagination__item pagination__item--current">62/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/63/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>