<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8a1f5e3faa2d54a78d6010649099ad3/" rel="bookmark">
			新手学SpringCloud前需知道的5点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第一点： 什么是微服务架构
第二点：为什么需要学习Spring Cloud
第三点： Spring Cloud 是什么
第四点： SpringCloud的优缺点
1、SpringCloud优点
2、SpringCloud缺点
第五点： SpringCloud由什么组成
1）Spring Cloud Eureka
2）Spring Cloud Zuul
3）Spring Cloud Ribbon
4）Spring Cloud Feign
5）Spring Cloud Hystrix
6）Spring Cloud Config
总结
我们知道，Spring Cloud利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。 通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。
那在深入学习SpringCloud前，我们需要对其全貌有一个基础了解，方能知道为什么学习SpringCloud。
第一点： 什么是微服务架构 在知道为什么学SpringCloud之前，我们需要先知道一个概念：微服务。
微服务架构，就是将单体的应用程序分成多个应用程序，这多个应用程序就成为微服务，每个微服务运行在自己的进程中，并使用轻量级的机制通信。这些服务围绕业务能力来划分，并通过自动化部署机制来独立部署。这些服务可以使用不同的编程语言，不同数据库，以保证最低限度的集中式管理。 第二点：为什么需要学习Spring Cloud 首先，SpringCloud是基于SpingBoot的优雅简洁，还记得我们被无数xml支配的恐惧场景吗？还记得SpringMVC，Mybatis错综复杂的配置吗？有了SpingBoot，这些东西就都不需要了，SpingBoot好处就不多说了。
而SpringCloud就是基于SpringBoot把市场上优秀的服务框架组合起来，通过Spring Boot风格进行再封装，并且屏蔽掉了复杂的配置和实现原理，做到了开箱即用，很多都是通过引入JAR包来完成。 另外，SpringCloud大多数子模块都是为了解决现有痛点，像Zuul解决的跨域，Fegin解决的负载均衡，Hystrix的熔断机制等。 第三点： Spring Cloud 是什么 Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。
第四点： SpringCloud的优缺点 1、SpringCloud优点 1) 耦合度比较低。不会影响其他模块的开发。 2) 减轻团队的成本，可以并行开发，不用关注其他人怎么开发，先关注自己的开发。 3) 配置比较简单，基本用注解就能实现，不用使用过多的配置文件。 4) 微服务跨平台的，可以用任何一种语言开发。 5) 每个微服务可以有自己的独立的数据库也有用公共的数据库。 6) 直接写后端的代码，不用关注前端怎么开发，直接写自己的后端代码即可，然后暴露接口，通过组件进行服务通信。 2、SpringCloud缺点 1) 部署比较麻烦，给运维工程师带来一定的麻烦。 2) 针对数据的管理比麻烦，因为微服务可以每个微服务使用一个数据库。 3) 系统集成测试比较麻烦 4) 性能的监控比较麻烦。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8a1f5e3faa2d54a78d6010649099ad3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a9c84c56e8fda700b36abfa458ea005/" rel="bookmark">
			docker部署redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#挂载文件目录 #挂载文件目录 home=/home/docker/config/redis; #mysql密码 password=123456; #创建文件并赋权 mkdir -p ${home}/conf; mkdir -p ${home}/data; chmod 777 ${home}/conf; chmod 777 ${home}/data; cat&gt;${home}/conf/redis.conf&lt;&lt;EOF # Redis配置文件样例 # Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程 # 启用守护进程后，Redis会把pid写到一个pidfile中，在/var/run/redis.pid daemonize no # 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定 pidfile /var/run/redis.pid # 指定Redis监听端口，默认端口为6379 # 如果指定0端口，表示Redis不监听TCP连接 port 6379 # 绑定的主机地址 # 你可以绑定单一接口，如果没有绑定，所有接口都会监听到来的连接 # bind 127.0.0.1 # 当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 timeout 0 # 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose # debug (很多信息, 对开发／测试比较有用) loglevel verbose # 日志记录方式，默认为标准输出，如果配置为redis为守护进程方式运行，而这里又配置为标准输出，则日志将会发送给/dev/null logfile stdout # 设置数据库的数量，默认数据库为0，可以使用select &lt;dbid&gt;命令在连接上指定数据库id # dbid是从0到‘databases’-1的数目 databases 16 ################################ SNAPSHOTTING ################################# # 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 # Save the DB on disk: # # save &lt;seconds&gt; &lt;changes&gt; # # # 满足以下条件将会同步数据: # 900秒（15分钟）内有1个更改 # 300秒（5分钟）内有10个更改 # 60秒内有10000个更改 # Note: 可以把所有“save”行注释掉，这样就取消同步操作了 save 900 1 save 300 10 save 60 10000 # 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大 rdbcompression yes # 指定本地数据库文件名，默认值为dump.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a9c84c56e8fda700b36abfa458ea005/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36b6a63dc1c5fed3319d249a665b625f/" rel="bookmark">
			LeetCode 轮转数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路一： 1. 最笨头插法 递归头插，可以解决，但是不推荐，因为当数据很大时成本很大
2. 三次翻转解决 采用翻转的方式（例子：数组：12345，k: 3）
第一次翻转：54321
第二次翻转：34521（根据分界线翻转前半部分）
第三次翻转：34512（根据分界线翻转前半部分）
此题面试常考，大家可以记一下此方法。
注意点： k值应该对整个数组长度取余，不可以大于数组长度
void reverse(vector&lt;int&gt; &amp;nums, int begin, int end) { while(begin &lt; end) { int temp = nums[begin]; nums[begin] = nums[end]; nums[end] = temp; ++begin; --end; } } void rotate(vector&lt;int&gt;&amp; nums, int k) { if(1 == nums.size()) return; // 此处应注意 k值应该对整个数组长度取余，不可以大于数组长度 k %= nums.size(); reverse(nums, 0, nums.size() - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.size() - 1); } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36b6a63dc1c5fed3319d249a665b625f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb88b1895c58190b14851b92a4ac1821/" rel="bookmark">
			查看进程PID的几种方法记录-20230328
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是进程ID？方法1：使用pidof命令方法 2：使用 pgrep 命令方法 3：使用 pstree 命令方法 4：使用 ps 命令转载来源 什么是进程ID？ PID 代表进程标识号process identification，它在大多数操作系统内核（如 Linux、Unix、macOS 和 Windows）中使用。它是在操作系统中创建时自动分配给每个进程的唯一标识号。一个进程是一个正在运行的程序实例。
除了 init 进程外其他所有的进程 ID 每次都会改变，因为 init 始终是系统上的第一个进程，并且是所有其他进程的父进程。它的 PID 是 1。
PID 默认的最大值是 32768。可以在你的系统上运行 cat /proc/sys/kernel/pid_max 来验证。在 32 位系统上，32768 是最大值，但是我们可以在 64 位系统上将其设置为最大 222（约 4 百万）内的任何值。
你可能会问，为什么我们需要这么多的 PID？因为我们不能立即重用 PID，这就是为什么。另外为了防止可能的错误。
系统正在运行的进程的 PID 可以通过使用 pidof、pgrep、ps 和 pstree 命令找到。
方法1：使用pidof命令 pidof 用于查找正在运行的程序的进程 ID。它在标准输出上打印这些 id。为了演示，我们将在 Debian 9（stretch）系统中找出 Apache2 的进程 ID。
# pidof apache23754 2594 2365 2364 2363 2362 2361 从上面的输出中，你可能会遇到难以识别进程 ID 的问题，因为它通过进程名称显示了所有的 PID（包括父进程和子进程）。因此，我们需要找出父 PID（PPID），这是我们要查找的。它可能是第一个数字。在本例中，它是 3754，并按降序排列。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb88b1895c58190b14851b92a4ac1821/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c36eb085c028ee20fce33568369fd8cf/" rel="bookmark">
			视频MD5值怎么修改？分享几个好用的修改方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		怎么修改视频的MD5值呢？修改视频的MD5值可以使视频的数字指纹发生变化，从而防止视频的盗版和非法传播。这可以保护视频作者的版权和收益。也可以让我们的视频在上传时不容易别和谐掉，可能会使视频产生一些流量，上热门都是可能的，那么有哪些方法可以修改视频MD5值呢？下面把这几个好用的修改方法分享给大家，一起来了解下吧。
方法一：书单视频助手
这是一个在手机上编辑视频的操作软件，里面有很多的视频编辑选项和图片编辑选项。其中修改视频MD5值就是其中的功能之一，操作起来非常简单方便。使用它来修改视频MD5值，我们只需要将软件打开，在视频工具中点击进入“修改MD5”，然后把视频添加进来就可以进行修改了，非常简单方便。
方法二：智能直播助手
这也是一个能够在手机上编辑视频的操作软件。除了能够编辑视频外，也能够编辑图片，还可以搭建虚拟直播间，方便我们在直播的时候能够有不同的直播背景。使用它来修改视频的MD5值，只需要在页面点击进入“修改MD5”，进入后把视频给添加进来，点击一键修改就会修改完成啦。
方法三：HashTools
是一个免费的MD5生成器和校验器，同时也支持修改文件的MD5值。界面简洁，易于使用。使用它来修改视频MD5值可以这样做：
1. 将软件打开，点击 "File"，选择 "Open File"，选择需要修改 MD5 值的视频文件。
2. 在 "Hash" 标签下，选择 "MD5"。
3. 在 "Hash" 栏中编辑想要修改的 MD5 值。
4. 点击 "Recalculate"，HashTools 将会重新计算视频文件的 MD5 值并将其修改为你所输入的值。
5. 点击 "File"，选择 "Save File"，将修改后的视频文件保存下来就可以啦。
以上就是给大家分享的几种能够修改视频MD5值的方法啦，操作起来都非常简单，有需要的小伙伴就去尝试一下吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/393c27129d5e942631c24de93b9ee79d/" rel="bookmark">
			Linux进程编程实例详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们都知道Linux是一个多任务的系统，它可以支持高并发执行任务。可以通过pstree命令查看树状的进程图。
代码1
#include &lt;stdio.h&gt; #include &lt;unistd.h&gt; //这个包里面有getpid和getppid int main() { printf("系统分配的进程号pid：%d\n", getpid()); printf("系统分配的父进程号ppid：%d\n", getppid()); return 0; } 结果表明的执行时系统为程序分配了进程，且有独立唯一的进程号。
代码2
#include &lt;stdio.h&gt; #include &lt;unistd.h&gt; int main() { char *args[] = {"/usr/bin/vim", NULL}; printf("系统分配的进程号pid：%d\n", getpid()); if (execve("/usr/bin/vim", args, NULL)) //execve创建进程，执行/usr/bin/vim perror("用execvve创建进程出错"); return 1; } 结果正确，直接执行vim的可执行程序
代码3
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; int main() { int newret; printf("系统分配的进程号pid：%d\n", getpid()); newret = system("ping www.baodu.com"); //system调用程序 return 0; } 结果直接调用ping
代码4
#include &lt;stdio.h&gt; #include &lt;stdlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/393c27129d5e942631c24de93b9ee79d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/732316599221699f8af53d338f015337/" rel="bookmark">
			GAMES101-现代计算机图形学入门-闫令琪——第一节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记基于P1 GAMES101-现代计算机图形学入门-闫令琪
What is Computer Graphics?计算机图形学的应用领域 电影特效Movies special effects
生成真实感的画面。 动画Animations
首先涉及到几何，如何去表述一些复杂的几何形体，如毛发。以及如何去渲染，把它给真正显示出来。计算光线在这些几何形体之间的传播方式，这个叫做渲染。 设计Computer added design
比如cg生成的车子模型，这个车子允许你做一些交互性的操作，比如你可以移动它，换各种各样不同的环境，就能立刻看到它不同环境下的样子。也可以把车子与墙碰撞的过程通过cg模拟出来。 可视化Visualization
将实际的信息转变为视觉信息的方法就叫做可视化。 虚拟现实Virtual Reality
虚拟现实：纯虚拟增强现实：现实的基础上+虚拟 数字绘画Digital Illustration
一个典型的工业界的例子就是Adobe的Photoshop如何描述曲线，如何做差值，以及如何不同的图层覆盖在一块应该显示成什么样……这一系列的东西在背后存在着很多图形学的技术。 仿真/模拟Simulation
模拟黑洞其实模拟的是光线 图形用户接口 GUI graphics user interface
包括windows磁贴风格和Mac的各种各样的界面设计。 字体Typography
为什么在任意放大某个字母的情况下，我都可以看到一个光滑连续的这种曲线？这里就涉及到点阵和矢量这两个不同的概念。点阵法：用具有颜色信息的像素点阵来表示图形的一种方法。参数法：采用几何方法建立数学模型时，用形状参数和属性参数描述图形的一种方法。图形是使用参数法描述的矢量图，图像是使用点阵法描述的位图。 Why Study Computer Graphics? Fundamental Intellectual Challenges基本智力挑战 Creates and interacts with realistic virtual world创造真实的虚拟世界并与之互动Requires understanding of all aspects of physical world需要了解物理世界的所有方面New computing methods, displays, technologies新的计算方法、显示器、技术 Computer Graphics is awesome!牛就完事了 Course Topics (mainly 4 parts) Rasterization光栅化 如open GL和shader是如何运作的。 Curves and Meshes曲线和曲面 几何：如何表示一条光滑的曲线，如何表示曲面，如何用简单的曲面通过细分的方法得到一些更复杂的曲面，以及在形状发生变化的时候，这些面要如何变化，如何保持住物体的拓扑结构。 Ray Tracing光线追踪 包括路径追踪、复杂的表面建模以及传播方法。生成非常真实的画面。 Animation / Simulation动画/模拟 比如扔一个弹性的球，这个球怎么样都是落在地上，如何被挤压，如何弹上去再下来。 计算机图形学和计算机视觉的区别 计算机图形学：输入数据输出图像。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/732316599221699f8af53d338f015337/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d99ac5f1dedec4b7e3baf3df9bbb9554/" rel="bookmark">
			SpringBoot实现固定、动态定时任务 | 三种实现方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 阅读完本文：🐱‍👓
知晓 SpringBoot 用注解如何实现定时任务明白 SpringBoot 如何实现一个动态定时任务 （与数据库相关联实现）理解 SpringBoot 实现设置时间执行定时任务 （使用 ThreadPoolTaskScheduler 实现） 一、注解实现定时任务 用注解实现是真的简单，只要会 cron 表达式就行。🧙‍♂️
第一步： 主启动类上加上 @EnableScheduling 注解
@EnableScheduling @SpringBootApplication public class SpringBootScheduled { public static void main(String[] args) { SpringApplication.run(SpringBootScheduled.class); } } 复制代码 第二步：写一个类，注入到Spring，关键就是 @Scheduled 注解。 （) 里就是 cron 表达式，用来说明这个方法的执行周期的。 🛌
/** * 定时任务 静态定时任务 * * 第一位，表示秒，取值0-59 * 第二位，表示分，取值0-59 * 第三位，表示小时，取值0-23 * 第四位，日期天/日，取值1-31 * 第五位，日期月份，取值1-12 * 第六位，星期，取值1-7，1表示星期天，2表示星期一 * 第七位，年份，可以留空，取值1970-2099 * @author crush * @since 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d99ac5f1dedec4b7e3baf3df9bbb9554/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b7f76357b5457688005515ed33b9c32/" rel="bookmark">
			pip镜像安装代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接使用pip安装，总是会遇到网络不佳，安装失败的场景
我们可以借助镜像进行安装
1、清华镜像代码
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 2、豆瓣镜像代码
pip install -i http://pypi.douban.com/simple/ 3、阿里云镜像代码
pip install -i http://mirrors.aliyun.com/pypi/simple/ 4、中国科学技术大学镜像代码
pip install -i http://pypi.mirrors.ustc.edu.cn/simple/ 5、华中科技大学镜像代码
pip install -i http://pypi.hustunique.com/ 还有什么镜像，欢迎写在评论区
如有疑问，欢迎大家一起讨论
主要是记录一下自己平时遇到的问题，和大家分享一下
如有侵犯，请联系我
点个赞支持一下吧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f10818725b8b29340a30ce9d1ce154c0/" rel="bookmark">
			计算机组成原理（ 程序员必学简化版 ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、计算机组成概述
1.计算机系统简介
1.1、早期的冯·诺依曼机
1.2、现代计算机组结构
2、计算机的组成
2.1、存储器
2.2运算器
2.3控制器
3、计算机的执行过程
4、计算机的性能指标
二、系统总线
1、总线的结构
2、总线的分类
三、存储器
1、存储器的分类
2、存储器的层次结构
3、主存储器
4、高速缓冲存储器
4.1、缓存的工作原理
4.2、缓存与主存的地址映射
四、CPU的结构和功能
1、CPU的功能
2、CPU的结构图
3、CPU的寄存器
3.1、用户可见寄存器
3.2、用户不可见寄存器
3.3、用户控制和状态寄存器
4、CPU的控单元
五、指令周期
1、指令周期的数据流
一、计算机组成概述 本章节从计算机简介、组成、执行过程、性能指标四个方面进行论述。
1.计算机系统简介 计算机系统软硬件
硬件：计算机的实体，如主机、外设等。
软件：由具有各类特殊功能的信息（程序组成），可分为两类：系统软件、应用软件。
计算机系统层次结构
1.1、早期的冯·诺依曼机 他提出程序存储思想，根据这一原理制造的计算机被称为冯·诺依曼结构计算机
程序存储:指令以代码的形式事先输入到计算机的主存储器中，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。即按地址访问并顺序执行指令
五大特点：
计算机硬件系统由五大部件组成(存储器、运算器、控制器、输出设备、输入设备)指令和数据以同等地位存于存储器，可按地址寻访指令和数据用二进制表示指令由操作码和地址码组成存储程序 以运算器为中心，且是单处理机，基本工作方式是控制流驱动方式！
1.2、现代计算机组结构 2、计算机的组成 计算机有五大部分组成：
&lt;1&gt; 输入设备，是指将外部信息以计算机能读懂的方式输入进来，如键盘，鼠标等
&lt;2&gt; 输出设备，就是将计算机处理的信息以人所能接受的方式输出出来，比如显示屏，打印
机。
&lt;3&gt; 存储器，存储器分为 主存储器(内存储器，CPU能直接访问)和 辅助存储器(外存储器，协助主存储器记忆更多的信息，辅助存储器的信息需要导入到主存储器中，才可以被CPU访问)。
&lt;4&gt; 运算器，是计算机的运算单元，用于算术运算和逻辑运算，运算器的核心单元是算术逻辑单元(ALU)。
&lt;5&gt; 控制器，控制器是计算机的指挥中心，有其指挥各部件自动协调第进行工作，现代计算机将运算器和控制器集成到一个芯片上，合成为中央处理器，简称CPU。有程序计数器(PC)、指令寄存器(IR)和控制单元(CU)。
2.1、存储器 主存储器是由地址寄存器(MAR)，数据寄存器(MDR)，存储体，时序控制逻辑组成。
地址寄存器存放访存地址，经过地址译码后找到所选的存储单元。
数据寄存器，是存储器与其他部件的中介，用于暂存要从存储器读或写的信息。
时序控制逻辑用于产生存储器操作所需的各种时序信号。
主存储器的工作方式是按存储单元的地址进行存取，这种存取方式称为按地址存取方式(相联存储器既可以既可以按照地址寻址，又可以按照内容寻址，为了与传统存储器区别，又称为内容寻址的存储器！)
2.2、运算器 2.3控制器 有程序计数器(PC)、指令寄存器(IR)和控制单元(CU)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f10818725b8b29340a30ce9d1ce154c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ae7a4adcaee9bee933408b308c8bce9/" rel="bookmark">
			Centos7安装、各种环境配置和常见bug解决方案，保姆级教程（更新中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Centos7安装二、各种环境配置与安装2.1 安装net-tools（建议）2.2 配置静态网络（建议）2.1 修改Centos7的时间（建议）2.2 Centos7系统编码问题2.3 vim安装（建议）2.4 解决Centos7命令错误发出蜂鸣警告声2.5 安装wegt命令2.6 Mysql8.0版本安装2.7 Redis6安装2.7.1 Redis安装与启动2.7.2 Redis客户端2.7.3 Redis卸载 前言 一、Centos7安装 因为网上关于Centos7安装教程实在是太多了，我这里就不重复造轮子了，直接上传送门
点击这里安装Centos7
二、各种环境配置与安装 安装好后就是各种要配置的东西了，我这里将各种有用的配置都记录了下来，方便以后重新安装的时候再查看
2.1 安装net-tools（建议） centos7默认没有netstat命令，需要安装 net-tools 工具，
yum install -y net-tools 2.2 配置静态网络（建议） 1、进入虚拟机/设置，查看是否是NAT模式
2、查看虚拟网络编辑器
3、进入etc/sysconfig/network-scripts目录，使用vi打开 ifcfg-ensXXX文件，进行编辑
cd /etc/sysconfig/network-scripts vi ifcfg-ens33 IPADDR中设置的ip地址以后就是这台虚拟机的默认ip地址
设置完后一点要记得重启服务
service network restart 用ifconfig命令查看网络是否已经配置成功（如果命令找不到先安装net-tools）
ping百度
2.1 修改Centos7的时间（建议） 使用命令：
date -s "2022/5/13 23:50:22" 说明：以上为案例，请根据自己情况修改时间
2.2 Centos7系统编码问题 问题：刚刚安装的时候建议检查一下系统编码，因为后期可能会用到Xshell（比如我是用的是Xshell5），如果linux下编码和Xshell中编码不同可能会导致Xshell中出现中文乱码情况。
1、使用loacle命令查看Centos7中的系统编码
centos系统找不到locate命令（locate: command not found）
安装mlocate包，一开始安装了locate,结果发现没有这个包
yum -y install mlocate 更新数据库
updatedb 这里需要注意一点：如果没有updatedb更新后台数据库，直接输入查找命令：locate，还是未能找到命令。原因是Linux不是实时更新它的后台数据库，所以我们并不能马上执行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ae7a4adcaee9bee933408b308c8bce9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe961d98f4ade6cfd4911d15183fcee9/" rel="bookmark">
			51单片机学习笔记-4矩阵键盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4 矩阵键盘 [toc]
注：笔记主要参考B站江科大自化协教学视频“51单片机入门教程-2020版 程序全程纯手打 从零开始入门”。
注：工程及代码文件放在了本人的Github仓库。
4.1 矩阵键盘介绍 在键盘中按键数量较多时，为了减少I/O口的占用，通常将按键排列成矩阵形式。采用逐行或逐列的“扫描”，就可以读出任何位置按键的状态。
数码管扫描（输出扫描）
原理：显示第1位→显示第2位→显示第3位→……，然后快速循环这个过程，最终实现所有数码管同时显示的效果。矩阵键盘扫描（输入扫描）
原理：读取第1行(列)→读取第2行(列) →读取第3行(列) → ……，然后快速循环这个过程，最终实现所有按键同时检测的效果。但同时按下多个按键可能会造成误判。以上两种扫描方式的共性：节省I/O口 图4-1 矩阵键盘实物图及原理图 比如，从上图所示，上四个接口表示行、下四个接口表示列。下面介绍具体的扫描过程：
逐行扫描：
先将某一行置0，此时若该行有按键按下，那该行上对应的列也就为0；以此重复所有的行，即完成一次扫描。逐列扫描：
将“逐行扫描”的行、列互换即可。 注：由于开发板IO资源有限，有一些开发板会把蜂鸣器IO口与矩阵键盘IO口复用，此时看情况更换扫描方式。
单片机的IO口是一种弱上拉（具有较弱的拉高电平或电位的能力）。关于其是如何实现双向口配置的，可以参考STC官方的器件手册“I/O口各种不同的工作模式及其配置介绍”。
4.2 实践：读取矩阵键盘 需求：在LCD1602第一行显示字符串“Matrix key:”，第二行按照按键丝印编号显示按下了哪个键（松开触发）。
为了代码简洁，编写了单独的矩阵按键检测子函数“MatrixKey.h”，并将其单独作为一个文件独立出来。当然，函数声明和定义应该分别放在头文件、源文件中，但由于函数太少，所以为了方便管理我将函数较少的源文件合并在头文件中。下面是工程的组织架构：
图4-2 “读取矩阵键盘”实验代码调用关系 代码展示：
- main.c
#include &lt;REGX52.H&gt; #include "LCD1602.h" #include "Delay.h" #include "MatrixKey.h" void main(){ int key = 0; // 初始化LCD显示 LCD_Init(); LCD_ShowString(1,1,"Matrix key:"); LCD_ShowString(2,1,"S00"); while(1){ key = MatrixKey(); if(key){LCD_ShowNum(2,2,key,2);}; } } - MatrixKey.h
#ifndef __MATRIXKEY_H__ #define __MATRIXKEY_H__ #include &lt;REGX52.H&gt; #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe961d98f4ade6cfd4911d15183fcee9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa0b51f4754ea4f2dbcdd17b0cf698b8/" rel="bookmark">
			【设计模式-工厂方法】想象力和创造力：你考虑过自动化实现工厂吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无限思维-想象力和创造力：自动化实现工厂方法 前言一、《大话设计模式》对应的Java版本工厂方法类图先行：代码实现：思考升华： 二、想象力：创新型思维+解决思路战略上：以无限思维的角度去想问题：部署上：将需求、问题等进行拆分：战术上：每一部分具体怎么实现：升华： 三、创造力：通过创造力加以实现！新手上路——需求1：已有算法类，写一段程序让计算机自动化生成算法工厂类以及对应的客户端类方案：扫描——扫描算法类1、 实现思路：2、类图：3、项目结构图：4、 代码： 小试牛刀——需求2：让计算机帮我们自动生成算法类、算法工厂类以及对应的客户端类，并且进行编译和运算（最终目的是要运算出结果）方案一：注册1、实现思路：2、类图：3、项目结构图：4、代码：5、运行效果： 方案二：扫描——扫描运算类包1、实现思路：2、类图：3、项目结构图：4、代码： 无限思维： 如何在程序运行过程中实时添加运算类且编译运行？目前考虑的方案：写个线程定时的去扫描代码： 继续无限思维的思考：一直扫描则会一直占用资源，那么怎么样可以即实时，又能不一直占用资源呢？方案思路：（先浅浅的透露一下吧~~ ）考虑通过事件与委托，简单的说就是考虑注册和扫描这两个方案相结合，代码还在优化中，敬请期待 ~~ 总结升华小测试：你无限思维的去思考问题了吗？ 前言 设计模式之工厂方法，你能不能通过无限思维去考虑，提出一些想象力创造力的问题：
如果后期要动态的添加无数个运算类怎么办？
我们能不能让计算机帮我们实现自动化的添加运算类？
我们程序员手动添加的类和代码，能不能让计算机帮我们自动生成代码呢？
最重要的是你会提出来这样的问题吗？
…
我们做软件开发的需要有想象力和创造力，这是需要在学习代码过程中不断的去培养和提高的一个过程：
创新型思考+解决思路+实现！！！
一、《大话设计模式》对应的Java版本工厂方法 类图先行： 需要注意类图的规范：类、接口以及六大关系的线:
类图中的接口：
①接口名要加上&lt;&gt;
②接口中的方法必须是斜体的
抽象类：
①抽象类的名称必须是斜体的；
②抽象类中的抽象方法必须是斜体的，非抽象方法是不用斜体的。
对于类图画图规范有需要复习或者了解的，请移步博主的博客：
链接: 类图的作用与画图规范
代码实现： 客户端代码：
/** * @Author: Ariel(huan) * @Description:客户端 * @CreateDate: 2023/3/24 22:37 */ public class Client { public static void main(String[] args) { IOperationFactory operationFactory=new OperationAddFactory(); Operation operation=operationFactory.createOperation(); operation.setNumberOne(1); operation.setNumberTwo(2); double result = operation.getResult(); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa0b51f4754ea4f2dbcdd17b0cf698b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/292e0d836f707bc21d9129b616d6fa01/" rel="bookmark">
			docker 笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更新容器为自启动命令 docker update --restart=always {id} 自动映射端口命令 --net=host 自动映射配置的host命令 --network host 查看容器元素 docker inspect {id} 进入容器内部 docker exec -it {id} /bin/sh/ 退出为 exit docker中 启动所有的容器命令 docker start $(docker ps -a | awk ‘{ print $1}’ | tail -n +2) docker中 关闭所有的容器命令 docker stop $(docker ps -a | awk ‘{ print $1}’ | tail -n +2) 打包镜像 docker -o {id}{路径} 加载打包镜像 docker load XXX.tar 重命名镜像
docker tag {id} REPOSITORY:TAG（仓库：标签）
docker rename {id} NAME
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/292e0d836f707bc21d9129b616d6fa01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9553028c7152d80ffb60591e69825d6f/" rel="bookmark">
			Model.create() no longer accepts a callback
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		白嫖的小伙伴,是否享受到了快乐
之后的所有方法都可以这样使用
let BookModel = mongoose.model('books',BookSchema)
await BookModel.create({
name:'西游记',
author:'吴承恩',
price:100,
is_hot:true,
tags:['妖魔','鬼怪'],
pub_time:new Date(),
text:'abc'
}).then((res)=&gt;{
console.log(res);
})
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b37998a000b5fd99bccc293694f9170c/" rel="bookmark">
			Springboot如何配置过滤器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Spring Boot 中，配置过滤器需要实现 Filter 接口，并重写其中的 doFilter() 方法。下面是一个详细的实例： 首先，我们创建一个过滤器类 MyFilter，实现 Filter 接口，并在其中重写 doFilter() 方法：
public class MyFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println("执行过滤操作"); chain.doFilter(request, response); } } 其中，doFilter() 方法用于执行过滤操作，这里我们简单地输出一句话，并调用 FilterChain 的 doFilter() 方法继续处理请求。 然后，我们需要在配置类中注册过滤器。在 Spring Boot 中，我们可以通过实现 WebMvcConfigurer 或 WebFluxConfigurer 接口，并重写 addFilter() 方法来配置过滤器。下面是一个示例：
@Configuration public class WebFilterConfig { @Bean public FilterRegistrationBean&lt;MyFilter&gt; myFilter() { FilterRegistrationBean&lt;MyFilter&gt; registrationBean = new FilterRegistrationBean&lt;&gt;(); registrationBean.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b37998a000b5fd99bccc293694f9170c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dc01deed0c375bf28417c847662fbac/" rel="bookmark">
			Unity3D-VR《静夜诗》1-项目准备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity3D-VR《静夜诗》1-项目准备 1 要实现的功能分析1.1墙上挂的宝剑1.2桌子上的书1.3开始按钮1.4窗户 2项目准备2.1下载素材包2.2新建一个工程项目2.3导入素材包2.4另存初始场景2.5添加控制相机视角脚本2.6添加灯光 1 要实现的功能分析 这里有一个实现后的运行程序文件，点击下载运行包，在本机解压即可运行
点击 下载运行包
运行程序文件即可体验项目实现的功能，很好地模拟了Android端发布后GearVR头盔上运行效果（没了鼠标键盘手柄，交互确认通过凝视转圈实现），通过操作可以知道，项目要实现如下功能：
程序启动后，可以与4个对象可以进行交互。
1.1墙上挂的宝剑 准星凝视在宝剑上，出现转圈进度条，凝视移出宝剑对象，转圈终止，一直凝视在宝剑对象上到转圈完成后，则显示关于宝剑和李白的文字信息，大约10秒后，文字消失，可以反复凝视转圈显示文字说明。
1.2桌子上的书 凝视、转圈、文字显示与墙上宝剑对象的交互要求一样。
1.3开始按钮 准星凝视在开始按钮上，出现转圈进度条的同时，按钮的背景颜色发生了变化，凝视移出开始按钮区域后，则转圈终止，按钮背景恢复原来颜色。一直凝视在开始按钮上直到转圈完成后，则开始按钮及提示信息消失，触发开始按钮的功能（使得窗户对象可交互）。
1.4窗户 开始按钮通过凝视触发后，场景中的窗户对象变成可交互了（会有一闪一闪的提示，凝视在窗户对象上也会出现转圈进度条的）。此时，桌上的书和墙上的宝剑还是可继续交互的。窗户对象凝视触发后，则窗户被打开，然后李白在室内开始徒步吟颂《静夜诗》。吟诗结束后，李白站立不动，窗户对象也不能再次凝视交互了，桌上的书和墙上的宝剑还是可继续凝视交互的。
要实现的功能大致如上所述。
2项目准备 2.1下载素材包 点击下载素材包到本机
素材包中的模型贴图等素材非本人原创，仅用于学习交流，若侵权敬请告知。
2.2新建一个工程项目 在你的工作目录下，新建一个Unity3D的工程项目Jingyeshi_000。
2.3导入素材包 导入已经下载到本地的素材包NDVRResources_jys.unitypackage（可能需要一段时间，请耐心等待）
提示
导入后如果出现以下错误，则删除Assets/Plugins/System.Drawing.dll文件即可。
文件位置如下：
2.4另存初始场景 导入的素材包后，在NDVRresources\SceneRcs目录下，有一个初始的场景JingYeSi，打开后另存为jys01在你自己新建的工作目录MyWork下，这样我们以后建的场景、脚本、预设、动画、模型、材质、贴图等都可以存在这个目录下了，以便和其他原有的项目文件很好的区分开，当然，如果自己建的文件有很多的话，便于管理，我们也可以再新建目录分类存放的。
2.5添加控制相机视角脚本 我们先实现在PC环境下的开发及调试，然后发布到Android平台上，进行基于GearVR+三星手机设备的移动VR项目发布。
为方便调试，可以通过菜单操作Assets | Import Package | Characters导入角色控制器（如果已经安装Unity基础资源包的话，没有的话请先安装Unity标准资源包）。
然后将脚本 Standard Assets\Characters\FirstPersonCharacter\Scripts\FirstPersonController.cs挂在场景中的相机对象VRCamera上。
试运行一下场景，通过鼠标就可以很方便的转动你的相机视角了，当然如果没有Unity基础资源包的话，调试时只能在相机的属性视图中通过手动改变相机的位置和旋转值来模拟头盔凝视操作了。
2.6添加灯光 初始场景如果感觉比较暗，可以添加一个Directional light光源，Directional light的光照效果只跟其方向有关，调整对象的旋转值到合适的光照效果。
至此，准备工作就完成了。
接下来实现凝视宝剑和书籍时出现提示文本信息
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29560e1912adeccbfbbde23925ccacb2/" rel="bookmark">
			华为云负载均衡配置http强制跳转https
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目部署在华为云上，之前在nginx服务器上配置301跳转，页面访问总是报错重定向次数过多，之后就想是否直接可以在负载均衡上做跳转，于是查官方文档果然有方法，于是乎先记录下来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb6970a074ad7904d366cf25e66953d9/" rel="bookmark">
			放过自己（转）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常听人说，人生有八苦：
生、老、病、死、爱别离、怨长久、求不得、放不下。
生老病死的苦，是人生必经之苦，没有人可以逃脱。
而其余的苦，往往是人心里的苦。
执念太深，不肯放过自己，才会让心负重太多。
亚里士多德说：“没有谁能折磨一个人，除了他自己。”
人若想真正获得快乐，唯有放过自己。
凡事不强求，尽力就好
成长，对于大部分人来说，是认识并接受自己是一个普通人的过程。
小时候，我们总是雄心壮志，坚信自己生而不凡。
可细细想来，这一路奔波，又有多少事遂了心愿。
越长大越明白，很多事情，并不总是朝我们期望的方向发展。
努力可能没有收获，事情也总难做到完美。
倘若强求结果，只会让自己深陷痛苦漩涡，难以自拔。
但是，不强求并非不作为，而是竭尽全力地努力，然后保持一颗平常心。
正如有句话所说的：
生活向来不易，或许我们拼尽全力，才能过上普通的日子。
但那又怎样呢？尽力了，便是生活的强者。
往后，学着放松一点，别对自己那么苛刻。
可以追求伟大，也要坦然接受平凡。
凡事尽力就好，然后顺其自然。
亲疏都随缘，尽心就好 人这一生，会遇见成千上万的人，大部分是过客，知心者寥寥。
你不可能和每一个人成为朋友，也不会被所有人喜欢。
费力迎合别人的期待，会让自己活得很辛苦。
活得清醒的人，早已学会，只关注自己的感受。
三观不同的人，不必费力迎合，聊不到一起，就主动远离；
不喜欢做的事，不必违心去做，该拒绝就拒绝，该翻脸就翻脸；
他人的求助，不想帮的，可以不帮，帮不了的，也不必愧疚。
人生不过几十年，过好自己的生活，远比满足他人的期待重要。
就像房琪说的：
“我们终其一生，不是为了满足每一个人，而是要找到跟自己同频共振的那一部分人。”
按自己喜欢的方式去活，有缘的人自会被你吸引，被筛掉的人，本也不必成为朋友。
往后，缘分不强求，朋友不强留。
做好自己，然后亲疏随缘，爱恨随意。
过往别纠结，当下即好
季羡林先生说：
“人生在世要想得开，如果不能‘忘’，那么痛苦就会时时刻刻都新鲜生动。”
人这一生，总有大大小小的遗憾。
有的人揪着过去不放，任自己在痛苦中沉沦；
有的人则选择放下过去，只抓住当下的时光。
其实很多时候，过不去的不是事，而是自己的心。
生命的车轮向前，再难的事都会结束，只看自己的心如何选择。
倘若放不下内心执念，一味纠结于过去，反而会误了当下的幸福。
打碎的杯子，再难过也无法修复。
与其埋怨悔恨，不如欢欢喜喜去买一只新的。
不为已经发生的事纠结，才是成年人最大的清醒。
毕竟过去的已经过去，懊恼悔恨也好，捶胸顿足也罢，除了徒增悲伤之外，于事无补。
把时间浪费在自怨自艾中，是对生命的无端消耗。
不如把遗憾打包封存，用积极的心态过好当下的生活。
往后，学会和过去告别，不要回头看。
放下过去的痛，才能解脱自己的心。
得失全看淡，知足才好 《菜根谭》里有句话说得好：
“知足者仙境，不知足者凡境。”
人生在世，知足才能常乐，心宽才能从容。
这世间，没有永恒的得到，也没有一味的失去。
在得与失中反复较劲，不过是给自己徒增烦恼。
况且塞翁失马，焉知非福。
眼前的得到，也许埋下了未知的风险。
当下的失去，或许攒下了未来的福气。
一时的得与失，实在不必过于放在心上。
以平常心对待，生活方能豁达坦然。
世间浮华皆如梦，淡看浮云是福人。
人的福气，从不在别处，只在自己的心境。
纠缠于眼前的得失，又怎能拥抱前方的风景？
生活不总是尽如人意，所谓人生，也不过是一半得到，一半失去。
得到的，好好珍惜，不辜负生命的馈赠；
失去的，也别惋惜，它不过是给未来的美好，留出了一席之地。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb6970a074ad7904d366cf25e66953d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d3bfe4456035f8a56643ff66113270c/" rel="bookmark">
			Java switch case语句详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		if…else 语句可以用来描述一个“二岔路口”，我们只能选择其中一条路来继续走，然而生活中经常会碰到“多岔路口”的情况。switch 语句提供了 if 语句的一个变通形式，可以从多个语句块中选择其中的一个执行。
switch 语句格式 switch 语句是 Java 的多路分支语句。它提供了一种基于一个表达式的值来使程序执行不同部分的简单方法。因此，它提供了一个比一系列 if-else-if 语句更好的选择。
switch 语句的基本语法形式如下所示：
switch(表达式){ case 值1: 语句块1; break; case 值2: 语句块2; break; … case 值n: 语句块n; break; default: 语句块n+1; break; } 其中，switch、case、default、break 都是 Java 的关键字。
1）switch 表示“开关”，这个开关就是 switch 关键字后面小括号里的值，小括号里要放一个整型变量或字符型变量。表达式必须为 byte，short，int，char类型。
Java7 增强了 switch 语句的功能，允许 switch 语句的控制表达式是 java.lang.String 类型的变量或表达式。只能是 java.lang.String 类型，不能是 StringBuffer 或 StringBuilder 这两种字符串的类型。
2）case 表示“情况，情形”，case 标签可以是：
类型为 char、byte、 short 或 int 的常量表达式。
枚举常量。
从 Java SE 7 开始， case 标签还可以是字符串字面量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d3bfe4456035f8a56643ff66113270c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/40/">«</a>
	<span class="pagination__item pagination__item--current">41/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/42/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>