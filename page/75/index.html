<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85f58fd9b131e708d5e26a4db9348554/" rel="bookmark">
			Siri语音控制树莓派开关灯 --智能家居
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工具：
ipad或iphone * 1
树莓派 * 1
led灯 * 1
Siri语音控制树莓派开关灯大致的原理就是通过语音指令去执行树莓派中的python脚本。这里首先要注意，树莓派要和ipad或iphone在同一局域网下，然后就是这里我们需要用到gpiozero这个python库，对于这个文件库怎么使用可参考官方文档，这里我就用最简单的方式来编写这个开关灯指令。
首先，我们导入gpiozero这个库文件，然后指定那个引脚作为输出就可以简单的完成开关灯这个指令。完整的python代码如下：
from gpiozero import LED from time import sleep a = LED(21)#这里的编码是BCM编码，声明a这个LED对象 a.on()#打开灯 sleep(5)#延时5秒 a.off()#关灯 将这个python脚本保存到本地(一定要记住这个本地地址)，然后就是在树莓派的首选项中点击Raspberry Pi Configuration，找到Interfaces中的SSH，要保证SSH是开启的。
下面是实物接线图，大家记住LED灯长脚是正极，短脚是负极，然后我用正极接BCM码中的GPIO 21，负极接地。(其实正确操作应该加个电阻，我这为了方便演示就没加😜)
下面我拿ipad演示，打开快捷指令app，可以输入搜索脚本进行搜索，在操作中找到通过SSH运行脚本
点开通过SSH运行脚本，填入下表的相关信息
输入下面的意思就是相当于在树莓派终端输入python led.py这一条指令，不过文件是写绝对地址，然后点击新快捷指令，在快捷指令名称那写上你唤醒脚本的名字。像我写的是开灯，等下我念嗨Siri 开灯，然后连接树莓派的灯就会亮5秒钟。
大家也可以换换其他唤醒词试试😄，这是不是为智能家居提供了一个思路呢，大家可以把一些控制舵机代码或步进电机代码放上来用语音控制，是不是觉得有点高大上，其实实现好像也并不复杂。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d81cf5c6963257a6b7b7010fdf529697/" rel="bookmark">
			用Python实现一个简单的微信聊天机器人
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚学习Python，做点小玩意练练手(￣▽￣)~*
文章目录 目录
一、准备工作
二、环境搭建
1. 安装安卓工具
2. UIAutomator2安装
3. 配置手机环境 4. 安装weditor
三、程序分析
1. 连接手机
2. 启动weditor
3. 整理思路
四、代码实现
五、效果展示
总结
一、准备工作 IDE：pycharm2019
Python：3.7
还有安卓手机一台(＾＿－)
代码git：代码地址
二、环境搭建 1. 安装安卓工具 首先进入谷歌官网，下载对应的SDK工具，这里我使用的是android-sdk_r24.4.1
下载完之后解压，打开SDK Manager，安装对应的工具（PS:这里我就直接无脑下一步）
安装完之后，配置一下环境变量，在cmd界面输入“adb” 来判断安装是否成功
这样，SDK就装好了
2. UIAutomator2安装 直接执行以下命令进行安装
pip3 install --pre -U uiautomator2 3. 配置手机环境 手机用USB连接电脑，手机端开启usb调试。cmd输入adb devices
如果出现 device，则是授权成功。如果出现 unauthorized 则是未授权，需要手机授权 连接成功之后cmd输入命令，安装atx-agent至手机
python -m uiautomator2 init 出现下图则安装成功，手机端会出现一个ATX的app
由于自带的SDK工具无法输入中文，所以还需要一个插件adbkeyboard.apk进行支持
4. 安装weditor 这个插件可以让我们像定位网页元素那样定位手机端元素，执行以下命令进行安装：
pip3 install --pre weditor 安装成功之后，使用以下命令启动：
python -m weditor 启动成功后，效果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d81cf5c6963257a6b7b7010fdf529697/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c69cf4b8297e90ef4d55d80b3263a741/" rel="bookmark">
			2021-09-16 《C#多线程编程实战》第一章线程基础学习记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结：
1.B站视频讲解：https://www.bilibili.com/video/BV1w5411t7Ko
2.《C#多线程编程实战》第一章线程基础
PS：Monitor参考https://blog.51cto.com/13713878410/1530243
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4eee2e34bf84a1bd3a3e9454df61eaf/" rel="bookmark">
			搭建小型网站，服务器需要什么配置的呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求是搭建一个小型网站，国内主流云平台活动机型就是非常理想的选择，原因主要有以下两点：
1.成本低：国内主流云平台遇到大促活动节，活动力度非常大，尤其是针对新用户，入门配置一年才几十块钱。
2.配置合理：个人网站相对来说，访问量不大，不会出现那种量级的高并发，那么低配服务器就完全能满足
3.使用简单：像题主这样的用于搭建网站，其实可以利用一些工具用来快速建站，例如宝塔面板，可通过工具进行一键安装，安装完成后可通过web界面进行操作，屏蔽掉底层shell指令操作，简单易用。
以上说了这么多，其实这些建站工具都集中到轻量应用服务器镜像中，轻量应用服务器特别适用小型应用场景，如个人网站、企业网站，自带多种应用镜像。
程序运行环境由咱们官方配置直接就可以搞定了，只需选定应用镜像，执行简单配置就能使用了，用户无需搭建网站环境。例如我们部署网站需要LAMP环境，则可以选择包含LAMP运行环境的轻量应用服务器，此时无需搭建运行环境，只需要上传程序即可使用。
建站应用镜像
聊完这些，那么该选择哪家的云服务器呢？
主流云平台例如阿里云、腾讯云的活动机在安全性、稳定性、易用性及高性价比等方面都占据绝对的优势，是上云的最佳选择。
国内云服务器性能和配置对比参阅：【云服务器推荐】腾讯云、阿里云、华为云服务器价格和配置评测
总的来说，对于首次搭建的网站来说，官网活动机永远是最佳选择，质优价廉，如果业务周期较长，而且可以一次性购买3年，为你的网站提供足够长的推广时间。
参考来源：知乎
作者：青草云
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e77f2c9e819634b0af50df10252e1e77/" rel="bookmark">
			使用的数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数据集：pubu_db 这个数据集是五一的时候，采集的不同信噪比下的数据集。
有四种信号，每种信号有5个不同的信噪比。
2021.9.14日，使用alexnet跑的结果，准确率为100%，所以没啥太大意义感觉。
2021.9.22，使用吕国裴的论文中的网络(cnn1)运行到底3个epoch就是100%了，没啥比较的意义了。
二、数据集pubu_UAV 这个数据集是五一的时候，采集的10种无人机的数据集。
9月14日10:46 - 11:37 使用resnet50，训练结果为90%. 但是好像是过拟合了，训练集上是100%，验证机只有90%。结果见《09-14_10-46_resnet50_pubu-UAV》
9月14日12:21 - 13:11 使用alexnet，训练结果为90.6%. 但是好像是过拟合了，训练集上是99.62%。结果见《09-14_12-21_alexnet_pubu-UAV》
三、数据集pubu_8 有8种跳频信号。
9月14日14:25，使用resnet50，第2轮的时候，验证集准确率就能达到100%。结果见《09-14_14-25_resnet50_pubu-8》
9月14日14:26到14：53，使用alexnet， 在第50轮的时候，最优，达到99.5%. 结果见《09-14_14-26_alexnet_pubu-8》
四、RML_matlab 这是让静静帮忙用matlab转的数据集。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6099b794f2e64984dae98511063f63f9/" rel="bookmark">
			LSTM模型在测试集上的输出全都是一样的怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 为什么LSTM模型在测试集上的输出全都是一样的？ 答：输入的幅值太大了！！把输入幅度缩放到0到1里去！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d749f151490f107c3fc95f8badde5d01/" rel="bookmark">
			java三种计时器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.
long startTime = System.currentTimeMillis();
System.out.println("开始时间 : " + startTime);
//
long completeTime1 = System.currentTimeMillis();
long tcompleteTime = completeTime1 - startTime;
System.out.println("结束时间 : " + completeTime1);
System.out.println("耗费时间 秒 : 毫秒 " + tcompleteTime / 1000 + " " + tcompleteTime);
2.
long start = System.nanoTime();
//
long duration = (System.nanoTime() - start) / 1_000_000; //毫秒
3.
import java.util.concurrent.TimeUnit;
import org.apache.commons.lang3.time.StopWatch;
StopWatch stopwatch = StopWatch.createStarted();
long sum = 0;
for(long i=0;i&lt;=1000000;i++) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d749f151490f107c3fc95f8badde5d01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/beee1a0bd38b07d7fcc4ec685afb512e/" rel="bookmark">
			C# 超详细的WebService创建、发布与调用（VS2019）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.编写接口 这里我选择的是 “ASP.NET Web应用程序(.NET Framework)”。
填写好项目名称、选择项目位置以及所使用的框架，这里我用的是“.NET Framework 4”框架，然后点击创建。
继续点击创建。
打开解决方案资源管理器-右键创建的Web项目-添加-新建项
添加 web 服务(AMSX)。
在这里除了默认的一个方法，自己又写了两个方法。
[WebMethod] public int GetInt() { int a = 1; int b = 2; return a + b; } [WebMethod] public string GetNameByStr(string name) { return "你好：" + name; } 然后我们启动项目。
在上面我们可以看到我们所写的三个方法，我选择其中一个点进去。
点击调用后我们可以看到输出了“你好：张三”。
其他两个方法也是一样的，点击调用都能看到我们所写的返回结果，至此说明我们所写的没有问题，接下来我们把所写的发布到IIS上面去。
2.发布接口 选择文件夹，点击下一步。
选择发布的文件夹位置，这里可以自己选择，但是一定要记住你选择的位置，这里我就采用默认的发布位置，即在当前项目的 bin\app.publish 文件夹下。点击完成
然后我们点击发布即可。
注：这里有个小细节，当我们更新Web服务里面的内容的时候，再次发布的时候我们需要注意。
打开项目所在的位置，这里面的内容即为我们所发布的内容。
然后我们打开IIS管理器（不会打开IIS的请自行百度，这里就不做教学了）。
右键网站选择添加网站。
对添加的网站进行相关设置后点击确定。
这个时候我们发现打开的网站出现了403.14错误。
我们只需要：
再次浏览即可正常访问。
点击WebService1.asmx
能正常打开，并且能正常调用方法说明发布成功。
至此，我们发布网站的步骤进行完毕，接来了我们将在程序中调用我们说发布的方法并获取到相应的值。
3.调用接口 右键项目-添加-服务引用
打开刚刚启动的网站，复制这个地址粘贴到服务引用中。
接下来点击高级
添加Web 引用(W)-在打开的界面中的URL中输入刚刚复制的网址-点击蓝色箭头-添加引用®
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/beee1a0bd38b07d7fcc4ec685afb512e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/250e7fd8bba5a5b45ea12743d6ae64e0/" rel="bookmark">
			使用过滤器与cookie实现记住用户登录状态，自动登录功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、思路： 用户首次登录并选择了记住登录状态，向服务器发出登录请求，服务器收到请求后验证登录信息，如果用户信息认证成功，服务器将用户的登录信息存入cookie并响应给浏览器，接下来每次浏览器向服务器发出访问资源请求时，都会附带cookie信息，服务器认证cookie中的用户登录信息，如果成功则放行，否则让客户端删除cookie，重新登录认证。
二、流程图 三、代码实现 1、创建LoginServlet，获取用户输入的信息 //处理乱码问题 request.setCharacterEncoding("utf-8"); //获取用户输入的信息 String username = request.getParameter("username"); String password = request.getParameter("password"); //获取用户是否选择记住登录状态，如果auto为null则未选择 String auto = request.getParameter("auto"); 2、用户信息校验，以用户输入的信息作为参数，调用业务逻辑层的用户登录方法获取用户，该部分代码省略，此处代码采用将用户名和密码写死的方式认证 if ("admin".equals(username)&amp;&amp;"888".equals(password)){ //用户登录信息正确，执行后续的代码 //如果是从数据库中获取的用户，则将用户对象放入域中 request.getSession().setAttribute("username", username); } 3、将用户的信息保存到cookie中并重定向到资源页面 if ("admin".equals(username)&amp;&amp;"888".equals(password)){ //用户登录信息正确，执行后续的代码 //如果是从数据库中获取的用户，则将用户对象放入session域中 request.getSession().setAttribute("username", username); //判断用户是否选择记住登录状态 if (auto!=null){ //将用户名与密码进行拼接 String userinfo = username+"#"+password; //通过Base64编码进行信息加密 userinfo = Base64.getEncoder().encodeToString(userinfo.getBytes("utf-8")); //创建名为"userinfo"的cookie Cookie cookie = new Cookie("userinfo",userinfo); //设置回传路径 cookie.setPath(request.getContextPath()); //设置cookie的有效期 cookie.setMaxAge(60*60*24*7); //设置HttpOnly，使js脚本将无法读取到cookie信息，防止跨站脚本攻击 cookie.setHttpOnly(true); //将cookie存入响应中 response.addCookie(cookie); } //重定向到访问资源 response.sendRedirect(request.getContextPath()+"/index.jsp"); } 4、创建过滤器，拦截路径设置为资源路径，过滤资源的访问请求 (1) 从session域获取用户，如果存在，则说明当前会话是登录状态，过滤器放行 //将请求和响应强转成HttpServletRequest类型 HttpServletRequest req = (HttpServletRequest)request; HttpServletResponse resp = (HttpServletResponse)response; //从session域获取用户 String username = (String) req.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/250e7fd8bba5a5b45ea12743d6ae64e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b50a4db0aef7e070fe9e027ea1d29b8f/" rel="bookmark">
			Python实现Excel和TXT文件格式的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：只针对文件中的文字，Excel表格的样式等不随之转换，所以Excel转TXT再转Excel，得到的表格将为默认样式。
【1】Excel转TXT，代码如下：
import pandas # 格式转换 def Excel_to_Txt(input_path, output_path): df = pandas.read_excel(input_path, header=None) print('开始写入txt文件') df.to_csv(output_path, header=None, sep=',', index=False) #sep指定分隔符，分隔单元格 print('写入成功') # 创建同路径同名TXT文件 def creat_txt(input_path): length = len(input_path) output_path = '' for i in range(length-1, -1,-1): if input_path[i] == '.': break for j in range(0, i+1): output_path = output_path + input_path[j] output_path = output_path + 'txt' # file = open(output_path,) return output_path if __name__ == '__main__': input_path = r'C:\1-校级活动列表_1.xlsx' output_path = creat_txt(input_path) Excel_to_Txt(input_path, output_path) 【2】TXT转Excel：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b50a4db0aef7e070fe9e027ea1d29b8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9555b6c4b76fc383a87c9cf525b21e08/" rel="bookmark">
			SpringSecurity 使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网
教程：尚硅谷
简介 概要 Spring 是非常流行和成功的 Java 应用开发框架，Spring Security 正是 Spring 家族中的成员。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。
正如你可能知道的关于安全方面的两个主要区域是“认证”和“授权”（或者访问控制），一般来说，Web 应用的安全性包括用户认证（Authentication）和用户授权（Authorization）两个部分，这两点也是 Spring Security 重要核心功能。
用户认证指的是：验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。通俗点说就是系统认为用户是否能登录用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。通俗点讲就是系统判断用户是否有权限去做某些事情。 同款产品对比 Spring Security 特点：
和 Spring 无缝整合。全面的权限控制。专门为 Web 开发而设计。 旧版本不能脱离 Web 环境使用。新版本对整个框架进行了分层抽取，分成了核心模块和 Web 模块。单独引入核心模块就可以脱离 Web 环境。 重量级。 Shiro
Apache 旗下的轻量级权限控制框架。
特点：
轻量级。Shiro 主张的理念是把复杂的事情变简单。针对对性能有更高要求的互联网应用有更好表现。通用性。 好处：不局限于 Web 环境，可以脱离 Web 环境使用。缺陷：在 Web 环境下一些特定的需求需要手动编写代码定制。 Spring Security 是 Spring 家族中的一个安全管理框架，实际上，在 Spring Boot 出现之前，Spring Security 就已经发展了多年了，但是使用的并不多，安全管理这个领域，一直是 Shiro 的天下。
相对于 Shiro，在 SSM 中整合 Spring Security 都是比较麻烦的操作，所以，Spring Security 虽然功能比 Shiro 强大，但是使用反而没有 Shiro 多（Shiro 虽然功能没有Spring Security 多，但是对于大部分项目而言，Shiro 也够用了）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9555b6c4b76fc383a87c9cf525b21e08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e975c23a92f2cb619a6d4a7299534b62/" rel="bookmark">
			vue组件之间通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue组件之间通信 前言
组件是 vue.js最强大的功能之一，而组件实例的作用域是相互独立的，这就意味着不同组件之间的数据无法相互引用。一般来说，组件可以有以下几种关系：
如上图所示，A 和 B、B 和 C、B 和 D 都是父子关系，C 和 D 是兄弟关系，A 和 C 是隔代关系（可能隔多代）。
针对不同的使用场景，如何选择行之有效的通信方式？这是我们所要探讨的主题。本文总结了vue组件间通信的几种方式，如props、$$emit和$on、vuex、$parent / $children、$attrs/$listeners和provide/inject，以通俗易懂的实例讲述这其中的差别及使用场景，希望对小伙伴有些许帮助。
本文的代码请猛戳github博客，纸上得来终觉浅，大家动手多敲敲代码！
方法一、$props/$emit 父组件A通过props的方式向子组件B传递，B to A 通过在 B 组件中 $emit, A 组件中 v-on 的方式实现。
1.父组件向子组件传值
接下来我们通过一个例子，说明父组件如何向子组件传递值：在子组件Users.vue中如何获取父组件App.vue中的数据 users:[“Henry”,“Bucky”,“Emily”]
//App.vue父组件
//前者自定义名称便于子组件调用，后者要传递数据名 总结：父组件通过props向下传递数据给子组件。注：组件中的数据共有三种形式：data、props、computed 2.子组件向父组件传值（通过事件形式）
接下来我们通过一个例子，说明子组件如何向父组件传递值：当我们点击“Vue.js Demo”后，子组件向父组件传递值，文字由原来的“传递的是一个值”变成“子向父组件传值”，实现子组件向父组件值的传递。
子组件向父组件传值之前
// 子组件 &lt;template&gt; &lt;header&gt; &lt;h1 @click="changeTitle"&gt;{{title}}&lt;/h1&gt;//绑定一个点击事件 &lt;/header&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'app-header', data() { return { title:"Vue.js Demo" } }, methods:{ changeTitle() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e975c23a92f2cb619a6d4a7299534b62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c88298a40b14fa995e5db40d987fca49/" rel="bookmark">
			RNA-seq中的生物学重复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 生物学重复：经过相同方式处理相同样品（不是同一个体）。指样本重复，比如3只小鼠，同时做一种处理，就是三个生物学重复。 消除组内误差：生物学重复可以测量变异程度。增强结果可靠性：测序的样本数越多，越能够降低背景差异。检测离群样本：异常样本的存在，会严重影响测序结果的准确性，通过计算样本间的相关性可以发现异常样本，将其排除。没有生物学重复实验发文章困难，如确实无法设置生物学重复。就得结合强有力的实验数据支撑，如定量实验，FISH荧光原位杂交，或是northern 杂交等，用实验数据说服。考虑到现实条件，重复设置≥3。一般不建议两个重复，如果两者结果不一，无法确定哪个数据为参考。原核生物以及真菌生物学重复的效果&gt;植物&gt;动物植物取样：同一片试验田，同一长势，外部形态特征相同动物取样：同一遗传背景，同一饲养条件，同一年龄，性别相同，外部形态特征相同生物学重复文献研究：在控制相同的假阳性率水平下，差异基因的数目整体与生物重复数量正相关；差异基因数目的稳定性与生物重复数量负相关；生物重复较少时，不同的抽样导致的差异基因数目波动较大；生物重复较多时，差异基因数目更集中。生物重复越多，真阳性率越高，并受筛选阈值影响越少，漏掉的差异基因（假阴性基因）越少。【Paper】RNA-seq differential expression studies:more sequence or more replication：对高、中、低表达的基因的表达量进行了评估，生物学重复提高所有基因表达水平鉴定的准确性，而增加测序深度主要提高了低表达基因表达量鉴定准确性。【paper】The power and promise of RNA-seq in ecology and evolutionEfficient experimental design and analysis strategies for the detection of differential expression using RNA-Sequencing：DESeq的效果优于edgeR或NBPSeq；差异分析对数据量并不敏感，增加生物学重复对提高表达差异分析结果可靠性的效果要优于单样本测序量。 假阳性率（FPR）：真实非差异表达中的基因中，被错误判定为差异表达的比例，FPR越低越好；真阳性率（TPR）：真实差异表达的基因中，能够正确判定为差异表达的比例，TPR越高越好；真阳性率这个概念，如果换用为“差异基因的检出率”更容易理解单样本测序量保持不变，生物学重复数（n）提高，差异分析的假阳性率（FPR）基本稳定，但真阳性率（TPR）在不断提高。提高生物学重复数，实验对差异表达基因的检测更加敏感，那些差异倍数较小或表达量较低的差异表达基因（此类基因的差异检测难度较大）能够更容易检测到。 技术重复：同一样品多次测量。一般是三次实验，比如对一块组织，提了三次RNA，做三次real time。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79bb1b6559ee8a8c989a2bd1b0077ee1/" rel="bookmark">
			如何解决Incorrect username or password (access token)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这是码云的账号密码有问题，这时候我们要去码云重新确认一下密码， 然后找到
把正确密码更新到这里。
这样就ok啦。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c59e83236401d851babff59d573807b/" rel="bookmark">
			Spring Boot搭建一个web工程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Spring Boot 主要特点是： 创建独立的Spring应用，为所有 Spring 的开发者提供一个非常快速的、广泛接受的入门体验
直接嵌入应用服务器，如tomcat、jetty、undertow等；不需要去部署war包
提供固定的启动器依赖去简化组件配置；实现开箱即用（启动器starter-其实就是Spring Boot提供的一个jar
包），通过自己设置参数（.properties或.yml的配置文件），即可快速使用。
自动地配置Spring和其它有需要的第三方依赖
提供了一些大型项目中常见的非功能性特性，如内嵌服务器、安全、指标，健康检测、外部化配置等
绝对没有代码生成，也无需 XML 配置。
二、Spring Boot搭建一个web工程 1、新建一个maven jar工程： 2、添加依赖 现在我们的项目与Spring Boot还没有什么关联。Spring Boot提供了一个名为spring-boot-starter-parent的工程，里面已经对各种常用依赖（并非全部）的版本进行了管理，我们的项目需要以这个项目为父工程，这样我们就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标即可。
2.1、添加依赖 添加父工程坐标
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.5.RELEASE&lt;/version&gt; &lt;/parent&gt; 2.2、添加依赖添加web启动器 为了让Spring Boot帮我们完成各种自动配置，我们必须引入Spring Boot提供的自动配置依赖，我们称为 启动器 。因
为我们是web项目，这里我们引入web启动器，在 pom.xml 文件中加入如下依赖：
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 需要注意的是，我们并没有在这里指定版本信息。因为Spring Boot的父工程已经对版本进行了管理了。
这个时候，我们会发现项目中多出了大量的依赖。
那些依赖都是Spring Boot根据 spring-boot-starter-web 这个依赖自动引入的，而且所有的版本都已经管理好，不
会出现冲突。
2.3、管理jdk版本 如果我们想要修改Spring Boot项目的jdk版本，只需要简单的添加以下属性即可，如果没有需求，则不添加。同样的
在 pom.xml 文件中添加如下：
&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; 2.4、完整pom文件 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c59e83236401d851babff59d573807b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ba74cb07f5a470a42b19ecbef9ba3bf/" rel="bookmark">
			正交试验minitab
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.创建正交试验
2.根据自己的实验选择水平数和因子数，并选定一个正交表
3.得到正交表
4.填写实验结果
5.进行正交分析
点击结果，点击分析
6.得到分析结果
7.方差分析
选择响应变量与因子，点击确定
得到方差分析的结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3ac0d8d7ecf1330fdaf6fb4834642a7/" rel="bookmark">
			Python:ValueError: No tables found matching pattern ‘.&#43;‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 用pandas的readhtml方法读Selenium拿下来的网页元素时发生报错。
之前这个爬虫已经正常运行了几周，感觉是网页源码出了什么问题。
思考 网上关于这个报错的原因解释千奇百怪，所以觉得是个挺宽泛的报错，原因还是得结合实际情况自己分析。
pd.readhtml的作用是自动识别html string中所有的table标签并将其转化为dataframe，所以应该是哪个table的内容识别出了问题。
找原因 有了思路，方法也就有了，既然是数据内容出了问题，那就从数据内容开始排查。
我将原html的整个篇幅形成了table数组，一个一个地排查，发现中间掺进来一个没有tr,th标签的空table.(写网页的人脑子怎么了？)
对应方法 找到了原因，对应的方法也就有了。
获得待分析的content内容后，对内部所有table结构做个过滤，排除掉所有不含&lt;/tr标签的table结构即可。实现方法随便用列表推导还是for循环。建议前者。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a347358ecc47e5e9b40acfa54294d146/" rel="bookmark">
			C#语言入门详解（刘铁锰）---重写与多态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#语言入门详解（刘铁锰）视频教程：https://www.bilibili.com/video/BV1wx411K7rb
IDE：VS2015， .NET Framework4.5.2
IDE：VS2019， .NET Core 3.1
同一代码以上两种环境均可运行。
1. 重写 类定义中，尽量避免对父类成员的隐藏。应使用virtual-override 重写父类成员。
子类可以重写父类中的非privatede 属性和方法。
Note：方法签名由方法的名称、类型形参的个数和它的每一个形参（按从左到右的顺序）的类型和种类（值、引用或输出）组成。
2. 多态（polymorphism） 多态基于重写机制
类可以声明虚的方法、属性和索引器，而派生类可以重写这些函数成员的实现。这使类展示出“多态性行为”特征，也就是说，同一个函数成员调用所执行的操作可能是不同的，这取决于用来调用该函数成员的实例的运行时类型。
实例1：子类中隐藏式定义父类同名方法 隐藏式定义: 子类定义与父类具有相同参数、相同返回值的同名方法。示例如下：
using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace _2021._8._20_重写与多态 { class Program { static void Main(string[] args) { //test1 Console.WriteLine("-----------test1-----------"); //类实例化 Vehicle vehicle1 = new Vehicle(); Car car1 = new Car(); RaceCar raceCar1 = new RaceCar(); vehicle1.Run(); car1.Run(); raceCar1.Run(); Console.WriteLine(); //test2 Console.WriteLine("-----------test2-----------"); //用子类实例化父类 Vehicle vehicle2 = new Car(); Car Car2 = new RaceCar(); vehicle2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a347358ecc47e5e9b40acfa54294d146/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f117d6661928cb25a9c42a6b6facc8fa/" rel="bookmark">
			C#语言入门详解（刘铁锰）---泛型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#语言入门详解（刘铁锰）视频教程：https://www.bilibili.com/video/BV1wx411K7rb
IDE：VS2019
.NET Core 3.1
1.泛型类 实例代码： using System; namespace 泛型 { class Program { static void Main(string[] args) { Console.WriteLine("-------------test-------------"); Apple ap = new Apple("red"); Book bk = new Book("C#入门详解"); Box&lt;Apple&gt; apbox = new Box&lt;Apple&gt;(ap); Console.WriteLine( apbox.Cargo.Color); Box&lt;Book&gt; bkbox = new Box&lt;Book&gt;(bk); Console.WriteLine(bkbox.Cargo.Name); Console.WriteLine("-------------Done-------------"); } } class Apple //被包装的物品类 { private string _color; public string Color { get =&gt; _color; set =&gt; _color = value; } public Apple(string color) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f117d6661928cb25a9c42a6b6facc8fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb973dbd7fb418f4986544e572b61c27/" rel="bookmark">
			C#语言入门详解（刘铁锰）---抽象类与开闭原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#语言入门详解（刘铁锰）视频教程：https://www.bilibili.com/video/BV1wx411K7rb
IDE：VS2019
.NET Core 3.1
1.概念 ///接口和抽象类（abstract）都是软件工程产物；
///具体类-&gt;抽象类-&gt;接口， 原来越抽象，内部实现的东西越来越少；
///抽象类是未完全实现逻辑的类（可以有字段和非public成员，它们代表了具体逻辑）；
///抽象类为复用而生，专门用做基类，也具有解耦作用；
///抽象类中封装确定的。开放不确定的，推迟到合适的子类中去实现；
///接口是完全未实现逻辑的“类”（纯虚类；只有函数成员；成员全部public）；
///接口为解耦而生：高内聚、低耦合，方便测试；
///接口是一个协约；
///接口和抽象类都不能实例化，只能用来声明变量，引用具体类的实例；
2.实例 /// &lt;summary&gt; 为做基类而生的抽象类与开闭原则 &lt;/summary&gt; interface IVehicle { void FillFuel(); void Run(); void Stop(); } abstract class Vehicle:IVehicle //存在抽象方法，所以为抽象类 { public void Stop() { Console.WriteLine("Stopped!"); } public void FillFuel() { Console.WriteLine("pay and fill fuel"); } public abstract void Run(); //抽象方法 } class Car : Vehicle { public override void Run() { Console.WriteLine("car is running.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb973dbd7fb418f4986544e572b61c27/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/74/">«</a>
	<span class="pagination__item pagination__item--current">75/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/76/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>