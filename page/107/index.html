<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e87c409c7bdebbc2084ef9f37e8de9ae/" rel="bookmark">
			NTT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; const int P=998244353,M=510000; int ans=0,g[M],inv[M],n,m,w[2][M],jc[M]; int abs(int x){return x&gt;0?x:-x;} int pow(int a,int k){int ret=1;for(;k;a=1ll*a*a%P,k&gt;&gt;=1) if(k&amp;1)ret=1ll*ret*a%P;return ret;} void pre(){ int g=pow(3,(P-1)/n);w[0][0]=w[1][0]=1; for(int i=1;i&lt;n;i++) w[0][i]=1ll*w[0][i-1]*g%P; for(int i=1;i&lt;n;i++) w[1][i]=w[0][n-i]; } int ntt(int *a,int f){ for(int i=0,j=0;i&lt;n;i++){ if(i&gt;j) swap(a[i],a[j]); for(int l=n&gt;&gt;1;(j^=l)&lt;l;l&gt;&gt;=1); } for(int i=1;i&lt;n;i&lt;&lt;=1)for(int j=0;j&lt;n;j+=(i&lt;&lt;1)) for(int k=0;k&lt;i;k++){ int x=a[k+j],y=1ll*w[f][n/(i&lt;&lt;1)*k]*a[i+k+j]%P; a[k+j]=(x+y)%P;a[i+j+k]=(x-y+P)%P; }	if(!f)for(int i=0,inv1=pow(n,P-2);i&lt;n;i++) a[i]=1ll*a[i]*inv1%P; } int main(){ scanf("%d",&amp;n); inv[n]=1;inv[0]=1;jc[0]=1; for(int i=1;i&lt;=n;i++)inv[n]=1ll*inv[n]*i%P,jc[i]=1ll*jc[i-1]*i%P; inv[n]=pow(inv[n],P-2); for(int i=n-1;i&gt;=1;i--) inv[i]=1ll*inv[i+1]*(i+1)%P; for(int i=1;i&lt;=n;i++) inv[i]=inv[i]*((i&amp;1)?-1:1); g[0]=1;g[1]=n+1; for(int i=2;i&lt;=n;i++){ int t=(pow(i,n+1)-1+P)%P; t=1ll*t*pow(i-1,P-2)%P; g[i]=1ll*t*abs(inv[i])%P; } m=2*n;for(n=1;n&lt;m;n&lt;&lt;=1);pre(); ntt(inv,1);ntt(g,1); for(int i=0;i&lt;n;i++) g[i]=1ll*g[i]*inv[i]%P; ntt(g,0); for(int i=0;i&lt;=m/2;i++) ans=(ans+1ll*pow(2,i)*jc[i]%P*g[i]%P)%P; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e87c409c7bdebbc2084ef9f37e8de9ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86de502ad3fe05ceedaba87164d54d28/" rel="bookmark">
			FFT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; const double PI=acos(-1); const int M=110000; struct complex{//虚数a+bi double a,b;complex(){}complex(double x,double y){a=x;b=y;} complex operator +(complex x)const{return complex (a+x.a,b+x.b);} complex operator -(complex x)const{return complex (a-x.a,b-x.b);} complex operator *(complex x)const{return complex (a*x.a-b*x.b,a*x.b+b*x.a);} }a[M],b[M]; int n; void fft(complex *a,int f){ for(int i=0,j=0;i&lt;n;i++){ if(i&gt;j) swap(a[i],a[j]); for(int l=n&gt;&gt;1;(j^=l)&lt;l;l&gt;&gt;=1); } for(int i=1;i&lt;n;i&lt;&lt;=1){complex w(cos(PI/i),f*sin(PI/i)); for(int j=0;j&lt;n;j+=(i&lt;&lt;1)){complex e(1,0); for(int k=0;k&lt;i;k++,e=e*w){ complex x=a[j+k],y=e*a[j+k+i]; a[j+k]=x+y;a[j+k+i]=x-y; } } } if(f==-1) for(int i=0;i&lt;n;i++) a[i].a/=n; } int main(){ scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86de502ad3fe05ceedaba87164d54d28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3b13412bf244e08fec6302730ce3274/" rel="bookmark">
			10分钟搞懂：亿级用户的分布式数据存储解决方案！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分布式数据库和分布式存储是分布式系统中难度最大、挑战最大，也是最容易出问题的地方。互联网公司只有解决分布式数据存储的问题，才能支撑更多次亿级用户的涌入。
接下来，你将花费十分钟掌握以下三方面内容：
1、MySQL复制：包括主从复制和主主复制；
2、数据分片：数据分片的原理、分片的方案、分片数据库的扩容；
3、数据库分布式部署的几种方案。
一、MySQL复制
1.MySQL的主从复制
MySQL的主从复制，就是将MySQL主数据库中的数据复制到从数据库中去。
主要目的是实现数据库读写分离，写操作访问主数据库，读操作访问从数据库，从而使数据库具有更强大的访问负载能力，支撑更多的用户访问。
它的主要的复制原理是：当应用程序客户端发送一条更新命令到数据库的时候，数据库会把这条更新命令同步记录到Binlog中，然后由另外一个线程从Binlog中读取这条日志，然后通过远程通讯的方式将它复制到从服务器上面去，从服务器获得这条更新日志后，将其加入到自己的Relay log中，然后由另外一个SQL执行线程从Relay log中读取这条新的日志，并把它在本地的数据库中重新执行一遍。
这样当客户端应用程序执行一个update命令的时候，这个命令会在主数据库和从数据库上同步执行，从而实现了主数据库向从数据库的复制，让从数据库和主数据库保持一样的数据。
2.MySQL的一主多从复制
MySQL的主从复制是一种数据同步机制，除了可以将一个主数据库中的数据同步复制到一个从数据库上，还可以将一个主数据库上的数据同步复制到多个从数据库上，也就是所谓的MySQL的一主多从复制。
多个从数据库关联到主数据库后，将主数据库上的Binlog日志同步地复制到了多个从数据库上。通过执行日志，让每个从数据库的数据都和主数据库上的数据保持了一致。这里面的数据更新操作表示的是所有数据库的更新操作，除了不包括SELECT之类的查询读操作，其他的INSERT、DELETE、UPDATE这样的DML写操作，以及CREATE TABLE、DROPT ABLE、ALTER TABLE等DDL操作也都可以同步复制到从数据库上去。
3.一主多从复制的优点
一主多从复制有四大优点，分别是分摊负载、专机专用、便于冷备和高可用。
a.分摊负载
将只读操作分布在多个从数据库上，从而将负载分摊到多台服务器上。
b.专机专用
可以针对不同类型的查询，使用不同的从服务器。
c.便于进行冷备
即使数据库进行了一主多从的复制，在一些极端的情况下。也可能会导致整个数据中心的数据服务器都丢失。所以通常说来很多公司会对数据做冷备，但是进行冷备的时候有一个困难点在于，数据库如果正在进行写操作，冷备的数据就可能不完整，数据文件可能处于损坏状态。使用一主多从的复制就就可以实现零停机时间的备份。只需要关闭数据的数据复制进程，文件就处于关闭状态了，然后进行数据文件拷贝，拷贝完成后再重新打开数据复制就可以了。
d.高可用
如果一台服务器宕机了，只要不发请求给这台服务器就不会出问题。当这台服务器恢复的时候，重新发请求到这台服务器。所以，在一主多从的情况下，某一台从服务器宕机不可用，对整个系统的影响是非常小的。
4.MySQL的主主复制
但是一主多从只能够实现从服务器上的这些优点，当主数据库宕机不可用的时候，数据依然是不能够写入的，因为数据不能够写入到从服务器上面去，从服务器是只读的。
为了解决主服务器的可用性问题，我们可以使用MySQL的主主复制方案。所谓的主主复制方案是指两台服务器都当作主服务器，任何一台服务器上收到的写操作都会复制到另一台服务器上。
如上主主复制原理图，当客户端程序对主服务器A进行数据更新操作的时候，主服务器A会把更新操作写入到Binlog日志中。然后Binlog会将数据日志同步到主服务器B，写入到主服务器的Relay log中，然后执Relay log，获得Relay log中的更新日志，执行SQL操作写入到数据库服务器B的本地数据库中。B服务器上的更新也同样通过Binlog复制到了服务器A的Relay log中，然后通过Relay log将数据更新到服务器A中。
通过这种方式，服务器A或者B任何一台服务器收到了数据的写的操作都会同步更新到另一台服务器，实现了数据库主主复制。主主复制可以提高系统的写可用，实现写操作的高可用。
5.MySQL的主主失效恢复
使用MySQL服务器实现主主复制时，数据库服务器失效该如何应对？
正常情况下用户会写入到主服务器A中，然后数据从A复制到主服务器B上。当主服务器A失效的时候，写操作会被发送到主服务器B中去，数据从B服务器复制到A服务器。
主主失效的维护过程如下：
最开始的时候，所有的主服务器都可以正常使用，当主服务器A失效的时候，进入故障状态，应用程序检测到主服务器A失效，检测到这个失效可能需要几秒钟或者几分钟的时间，然后应用程序需要进行失效转移，将写操作发送到备份主服务器B上面去，将读操作发送到B服务器对应的从服务器上面去。
一段时间后故障结束，A服务器需要重建失效期间丢失的数据，也就是把自己当作从服务器从B服务器上面去同步数据。同步完成后系统才能恢复正常。这个时候B服务器是用户的主要访问服务器，A服务器当作备份服务器。
5.MySQL复制注意事项
使用MySQL进行主主复制的时候需要注意的事项如下：
a.不要对两个数据库同时进行数据写操作，因为这种情况会导致数据冲突。
b.复制只是增加了数据的读并发处理能力，并没有增加写并发的能力和系统存储能力。
c.更新数据表的结构会导致巨大的同步延迟。
需要更新表结构的操作，不要写入到到Binlog中，要关闭更新表结构的Binlog。如果要对表结构进行更新，应该由运维工程师DBA对所有主从数据库分别手工进行数据表结构的更新操作。
二、数据分片
数据复制只能提高数据读并发操作能力，并不能提高数据写操作并发的能力以及数据整个的存储容量，也就是并不能提高数据库总存储记录数。如果我们数据库的写操作也有大量的并发请求需要满足，或者是我们的数据表特别大，单一的服务器甚至连一张表都无法存储。解决方案就是数据分片。
1.数据分片介绍
a.主要目标：将一张数据表切分成较小的片，不同的片存储到不同的服务器上面去，通过分片的方式使用多台服务器存储一张数据表，避免一台服务器记录存储处理整张数据表带来的存储及访问压力。
b.主要特点：数据库服务器之间互相独立，不共享任何信息，即使有部分服务器故障，也不影响整个系统的可用性。第二个特点是通过分片键定位分片，也就是说一个分片存储到哪个服务器上面去，到哪个服服务器上面去查找，是通过分片键进行路由分区算法计算出来的。在SQL语句里面，只要包含分片键，就可以访问特定的服务器，而不需要连接所有的服务器，跟其他的服务器进行通信。
c.主要原理：将数据以某种方式进行切分，通常就是用刚才提到的分片键的路由算法。通过分片键，根据某种路由算法进行计算，使每台服务器都只存储一部分数据。
2.硬编码实现数据分片
如图例子，通过应用程序硬编码的方式实现数据分片。假设我们的数据库将数据表根据用户ID进行分片，分片的逻辑是用户ID为奇数的数据存储在服务器2中，用户ID为偶数的数据存储在服务器1中。那么，应用程序在编码的时候，就可以直接通过用户ID进行哈希计算，通常是余数计算。如果余数为奇数就连接到服务器2上，如果余数为偶数，就连接到服务器1上，这样就实现了一张用户表分片在两个服务器上。
这种硬编码主要的缺点在于，数据库的分片逻辑是应用程序自身实现的，应用程序需要耦合数据库分片逻辑，不利于应用程序的维护和扩展。一个简单的解决办法就是将映射关系存储在外面。
3.映射表外部存储
应用程序在连接数据库进行SQL操作的时候，通过查找外部的数据存储查询自己应该连接到哪台服务器上面去，然后根据返回的服务器的编号，连接对应的服务器执行相应的操作。在这个例子中，用户ID=33查找服务器是2，用户ID=94查找服务器也是2，它们根据查找到的用户服务器的编号，连接对应的服务器，将数据写入到对应的服务器分片中。
4.数据分片的挑战及解决方案
数据库分片面临如图的挑战：
现在有一些专门的分布式数据库中间件来解决上述这些问题，比较知名的有Mycat。Mycat是一个专门的分布式数据库中间件，应用程序像连接数据库一样的连接Mycat，而数据分片的操作完全交给了Mycat去完成。
如下这个例子中，有3个分片数据库服务器，数据库服务器dn1、dn2和dn3，它们的分片规则是根据prov字段进行分片。那么，当我们执行一个查询操作”select * from orders where prov=‘wuhan’“的时候，Mycat会根据分片规则将这条SQL操作路由到dn1这个服务器节点上。dn1执行数据查询操作返回结果后，Mycat再返回给应用程序。通过使用Mycat这样的分布式数据库中间件，应用程序可以透明的无感知的使用分片数据库。同时，Mycat还一定程度上支持分片数据库的联合join查询以及数据库事务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3b13412bf244e08fec6302730ce3274/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67e7185c718a9f436f023d969bf15cb6/" rel="bookmark">
			Linux-shell脚本字符串截取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自https://baijiahao.baidu.com/s?id=1606425493933114713&amp;wfr=spider&amp;for=pc
Linux-shell脚本字符串截取 前言
在Linux shell编程中，我们经常需要截取某个字符串来，继续操作，比如：截取日期来创建整分钟的目录之类的。
字符截取
测试字符串
var=1234567890abcedef1203
1、使用#截取0以后的内容
echo ${var#*0}
结果：abcedef1203
#表示操作符，*0表示从左往右找到第一个0，截取0之后的所有字符
echo ${var##*0}
结果：3
#表示操作符，*0表示从右往左找到第一个0，截取0之后的所有字符
2、使用%截取
echo ${var%0*}
结果：1234567890abcedef12
%表示操作符，0*表示从右往左找到第一个0，截取0之前的所有字符
echo ${var%%0*}
结果：123456789
%表示操作符，0*表示从左往右找到第一个0，截取0之前的所有字符
3、根据索引来截取
echo ${var:0:7}
结果：1234567
其中的 0 表示左边第一个字符开始，7 表示字符的总个数。
echo ${var:7:5}
结果：890ab
其中的 7 表示左往右第七个字符开始，5 表示字符的个数。
echo ${var:0-7:5}
结果：def12
其中的 0-7 表示右往左第七个字符开始，5 表示字符的个数。
echo ${var:0-7}.
结果：def1203
如果不加字符个数就截取剩下的所有字符
总结
shell用来处理字符串还是不习惯，但是不难！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7147f5d57471028288b15d4fc4cbe514/" rel="bookmark">
			拟合（Curve fitting）与回归（Regression analysis）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.Curve Fitting 给定下面一组数据：
时间10:0011:0012:0013:0014:0015：00温度12℃15℃17℃20℃25℃18℃ 如果要预测某个时间的温度值，首先需要利用已知数据对时间-温度进行建模或者说建立温度与时间的关系函数。为建立这样一个模型，通常有两种方法：
差值方法：用一个函数（一般为多项式函数）来近似代替数据列表，并要求多项式经过列表中给定的数据点，插值曲线要经过数据点。
拟合方法： 仅要求在用函数表示列表中数据关系时，其误差在某种度量意义下最小，不要求完全经过数据点。
从几何意义上将，拟合是给定了空间中的一些点，找到一个已知形式未知参数的连续曲面来最大限度地逼近这些点；而插值是找到一个(或几个分片光滑的)连续曲面来穿过这些点。因此拟合可以用于外推预测（可以预测17:00的温度值），而差值一般用于求解差值空间里面的未知函数值（10：00 到15：00 之间任意时刻的值）
（此处还有一个概念函数逼近，其含义指用一个简单的函数近似表示一个复杂的函数，其前提是已知了复杂函数的表达式，而不是函数上面的离散的点）
从上面的介绍可知：拟合是一种数据建模的方法。
以下是维基百科中的曲线拟合的定义。
Curve fitting is the process of constructing a curve, or mathematical function, that has the best fit to a series of data points,possibly subject to constraints.Curve fitting can involve either interpolation, where an exact fit to the data is required, or smoothing, in which a “smooth” function is constructed that approximately fits the data.
曲线拟合是一个求解曲线模型或数学函数的过程，该曲线或数学函数在某种约束下最优表征该组数据点。曲线拟合可能要求拟合结果精确穿过数据（插值）或拟合的结果足够“平滑”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7147f5d57471028288b15d4fc4cbe514/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae203b6c8ff2ba4fb66cdd152f8abd46/" rel="bookmark">
			SQL Server：偏移量为 0x0000000009c000 的位置执行 读取 期间，操作系统已经向 SQL Server 返回了错误 21的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL Server：偏移量为 0x0000000009c000 的位置执行 读取 期间，操作系统已经向 SQL Server 返回了错误 21的解决方法 问题描述： 严重: Servlet.service() for servlet [dispatcher] in context with path [/obd2] threw exception [Request processing failed; nested exception is org.springframework.jdbc.UncategorizedSQLException: CallableStatementCallback; uncategorized SQLException for SQL [{call
web_user_login(?,?)}]; SQL state [null]; error code [0]; com.microsoft.sqlserver.jdbc.SQLServerException: 在文件 ‘F:\DataBase\BIDemo_AccumulateCoin.mdf’ 中、偏移量为 0x0000000009c000 的位置执行 读取 期间，操作系统已经向 SQL Server 返回了错误 21(设备未就绪。)。SQL Server 错误日志和系统事件日志中的其他消息可能提供了更详细信息。这是一个威胁数据库完整性的严重系统级错误条件，必须立即纠正。请执行完整的数据库一致性检查(DBCC
CHECKDB)。此错误可以由许多因素导致；有关详细信息，请参阅 SQL Server 联机丛书。; nested exception is com.microsoft.sqlserver.jdbc.SQLServerException: com.microsoft.sqlserver.jdbc.SQLServerException: 在文件 ‘F:\DataBase\BIDemo_AccumulateCoin.mdf’ 中、偏移量为 0x0000000009c000 的位置执行 读取 期间，操作系统已经向 SQL Server 返回了错误
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae203b6c8ff2ba4fb66cdd152f8abd46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff3a0462518a8343114981230c305b61/" rel="bookmark">
			java反编译工具Java Decompiler
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我想看一下jsp编译后生成的java文件，用记事本这些看的话要不就乱码，要不就看起来很乱，可读性很低
百度了一下java反编译工具Java Decompiler：
这个工具不仅能反编译.class文件，将.class文件转换为可读的.java文件，而且还可以对整个jar包进行反编译。
该工具不仅有自己的图形化界面工具JD-GUI，而且还有eclipse和IntelliJ IDEA的插件，可以将Java Decompiler集成到这些开发工具上
百度搜索Java Decompiler，找到并打开Java Decompiler的官网首页，如下图所示
在首页下方拖动鼠标，来到下载处，选择JD-GUI下面的Download选择相应的Releases版本下载即可
我只是单纯想看一下，下了这个
解压后双击jd-gui.exe就可以打开，或者可以把它发送到桌面快捷方式
我是直接把class文件拉进去就可以看了，我们还可以将该文件保存为.java的格式，这样就实现了反编译
另外在Java Decompiler的官网上还提供了Eclipse和IntelliJ IDEA相应插件的下载
插件的安装方法见博客：
Eclipse离线安装Java Decompiler插件 Intellij Idea离线安装Java Decompiler插件 注意：安装不成功可以去换个低版本的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81f51b6c9e7f474e2df206863c87c835/" rel="bookmark">
			Java 正则表达式的使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文属于技术文章，国外网站Copy过来参考使用，不再具体翻译了，相信程序都能有这些英语阅读能力。 1. 概述 In this article, we will discuss the Java Regex API and how regular expressions can be used in Java programming language.
In the world of regular expressions, there are many different flavors to choose from, such as grep, Perl, Python, PHP, awk and much more.
This means that a regular expression that works in one programming language may not work in another. The regular expression syntax in the Java is most similar to that found in Perl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81f51b6c9e7f474e2df206863c87c835/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb7e5f1e09816a8cca11b8089d675fde/" rel="bookmark">
			luogu 黑题 P3724大佬
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define RG register #define MAX 111 #define ft(i) (zt[i].first) #define sd(i) (zt[i].second) inline int read() { RG int x=0,t=1;RG char ch=getchar(); while((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-')ch=getchar(); if(ch=='-')t=-1,ch=getchar(); while(ch&lt;='9'&amp;&amp;ch&gt;='0')x=x*10+ch-48,ch=getchar(); return x*t; } int f[MAX][MAX]; int n,m,MC,Day,a[MAX],w[MAX],C[MAX]; struct Node{int i,F,L;}; pair&lt;int,int&gt; zt[1111111]; int tot,mx; int MOD=1000007; struct Hash { struct Line{int x,y,next;}e[1111111]; int h[1000007+1],cnt; void Add(int x,int y) { int pos=(1ll*x*101+y)%MOD; e[++cnt]=(Line){x,y,h[pos]};h[pos]=cnt; } bool Query(int x,int y) { int pos=(1ll*x*101+y)%MOD; for(int i=h[pos];i;i=e[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb7e5f1e09816a8cca11b8089d675fde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d8e1c822749f0038d95786443cfe122/" rel="bookmark">
			转发  linux yum 下载至本地及使用本地缓存安装包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux yum 下载至本地及使用本地缓存安装包 由于网络安全的原因，服务器不允许上公网，有2种方案，解决这个问题
1.搭建yum服务器
2.使用yum下载缓存进行封装,然后使用缓存安装
这里讲讲使用yum缓存封装
一、下载指定包及相关依赖
1
yum install --downloadonly packetName
二、查看下载的缓存文件,默认存/var/cache/yum
1
ll /var/cache/yum
三、yum使用缓存安装指定包
1
yum -C install packetName
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50a1b3014722663351d38123f85ecf27/" rel="bookmark">
			CNN的输入图像尺寸问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入图片的大小需要固定 我们知道CNN输入图片的大小需要固定，但是这是为什么呢？
其实在网络结构中卷积层是不需要固定图像的大小（它的输出大小是跟输入图像的大小相关的），一般情况下输入尺寸都会大于常用的卷积核大小。有固定输入图像大小需求的是全连接部分，全连接部分的参数的个数是需要固定的。
解决方案 当然可能我们的数据集的大小并不统一，这时候就需要进行处理了
1.可以在输入网络之前进行resize，将图像全部resize成统一大小。
2.可以在网络的数据层设置crop_size参数，该部分是的意思是对原图进行裁剪。
crop_size crop_size的意思是裁剪，在训练和测试两种情况时的裁剪方案是不一样的。代码请看src/caffe/data_transformer.cpp
意思是如果设置了crop_size参数则有两种裁剪方案。
1.训练：随机裁剪
2.测试：裁剪中间部分
参考：https://blog.csdn.net/u011762313/article/details/48343799
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ece6993fdc24a161aeb5c307cf3df40/" rel="bookmark">
			测试用例设计——场景分析法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试用例设计————场景分析法 定义 分析软件应用的场景，从用户的角度出发，从场景的角度来设计测试用例，是一种面向用户的测试用例设计方法。
优点：实用性强，有效，设计出来的用例有价值
缺点：可能使用的场景不一定能对时间系列进行全面的分析，设计出来的用例不完整。
场景分析是通过描述经用例路径来确定的过程，这个流程经过要从用例开始到结束遍历其中所有基本流：直黑线表示基本流，是最基本、最简单的路径；(软件功能按照正确的事件流实现的一条正确流程无任何错误，程序从开始直到结束)。
遵循上图中每个经过用例的可能路径，可以确定不同的用例场景。从基本流开始，再将基本流和备选流结合起来，可以确定以下用例场景：
场景1基本流场景2基本流备选流1场景3基本流备选流1备选流2场景4基本流备选流3场景5基本流备选流3备选流1场景6基本流备选流3备选流1备选流2场景7基本流备选流4场景8基本流备选流3备选流4 注：为方便起见，场景 5、6 和 8 只描述了备选流 3 指示的循环执行一次的情况。
用场景分析法设计测试用例的步骤： 1.根据说明，画出流程图，确定基本流和备选流；
2.根据基本流和各项备选流确定场景；
3.对每一个场景生成测试用例；
4.对生成的所有测试用例重新复审，去掉多余的测试用例，测试用例确定后，对每一个测试用例确定测试数据值。
用例场景示例 用户登录到网站后，进行书籍的选择，当选好自己心仪的书籍后进行订购，这时把所需图书放进购物车，等进行结帐的时候，用户需要登录自己注册的帐号，登录成功后，进行付款交易，交易成功后，生成订购单，整个购物过程结束。
第一步：画出流程图，确定基本流和备选流；
基本流：登录在线网站→选择课程/方案，放入购物车→登录账号→付款→生成订单
备选流１：用户不存在→注册用户
备选流２：密码不正确
备选流３：账户余额不足→充值
备选流 4 ：账户无金额→充值
第二步：根据基本流和各项备选流确定场景；
场景１（成功购物）：基本流；
场景２（账户不存在）：基本流 备选流１
场景３（账户密码错误）：基本流 备选流２
场景４（账户余额不足）：基本流 备选流3
场景 5（账户无金额）：基本流 备选流4
第三步：对每一个场景生成测试用例；
用例编号场景描述步骤描述输入预期结果1场景1：成功购物登录HB2选择方案/视频，放入购物车3登录账号4付款5生成订单成功购物场景2：账户不存在登录HB选择方案/视频，放入购物车登录账号账号不存在，注册用户提示账号不存在，返回基本流程步骤4登录账号付款生成订单场景3：账户密码错误登录HB选择方案/视频，放入购物车登录账号密码错误，重新输入登录提示账号密码错误，返回基本流步骤4付款生成订单场景4：账户余额不足登录HB选择方案/视频，放入购物车登录账号付款余额不足，充值提示账号余额不足，请充值；返回基本流步骤5付款生成订单场景5：账户无金额登录HB选择方案/视频，放入购物车登录账号付款账号无金额，充值提示账号无余额，请充值；返回基本流步骤5付款生成订单 第四步：对生成的所有测试用例重新复审，补充测试数据值
用例编号场景描述步骤描述输入预期结果1场景1：成功购物登录HB2选择方案/视频，放入购物车总价：80元人民币3登录账号账号：张三，密码：1234564付款账号余额：200元5生成订单成功购物场景2：账户不存在登录HB选择方案/视频，放入购物车总价：80元人民币登录账号账号：李四1，密码：123456账号不存在，注册用户提示账号不存在，返回基本流程步骤4登录账号付款账号余额：200元生成订单场景3：账户密码错误登录HB选择方案/视频，放入购物车总价：80元人民币登录账号账号：张三，密码：12345密码错误，重新输入登录提示账号密码错误，返回基本流步骤4付款账号余额：200元生成订单场景4：账户余额不足登录HB选择方案/视频，放入购物车总价：80元人民币登录账号账号：王五，密码：123456付款余额不足，充值账号余额：30元提示账号余额不足，请充值；返回基本流步骤5付款生成订单场景5：账户无金额登录HB选择方案/视频，放入购物车总价：80元人民币登录账号账号：张华，密码：123456付款账号无金额，充值账号余额：无余额提示账号无余额，请充值；返回基本流步骤5付款生成订单 提款测试用例 基本流/备用流流程描述基本流本用例的开端是 ATM 处于准备就绪状态。 准备提款 - 客户将银行卡插入 ATM 机的读卡机。 验证银行卡 - ATM 机从银行卡的磁条中读取帐户代码，并检查它是否属于可以接收的银行卡。 输入 PIN - ATM 要求客户输入 PIN 码（4 位） 验证帐户代码和 PIN - 验证帐户代码和 PIN 以确定该帐户是否有效以及所输入的 PIN 对该帐户来说是否正确。对于此事件流，帐户是有效的而且 PIN 对此帐户来说正确无误。 ATM 选项 - ATM 显示在本机上可用的各种选项。在此事件流中，银行客户通常选择“提款”。 输入金额 - 要从 ATM 中提取的金额。对于此事件流，客户需选择预设的金额（10 美元、20 美元、50 美元或 100 美元） 。 授权-ATM 通过将卡 ID、PIN、金额以及帐户信息作为一笔交易发送给银行系统来启动验证过程。对于此事件流，银行系统处于联机状态，而且对授权请求给予答复，批准完成提款过程，并且据此更新帐户余额。 出钞 - 提供现金。 返回银行卡 - 银行卡被返还。 收据 - 打印收据并提供给客户。ATM 还相应地更新内部记录。 用例结束时 ATM 又回到准备就绪状态。备选流 1 - 银行卡无效在基本流步骤 2 中 - 验证银行卡，如果卡是无效的，则卡被退回，同时会通知相关消息。备选流 2 - ATM 内没有现金在基本流步骤 5 中 - ATM 选项，如果 ATM 内没有现金，则“提款”选项将无法使用。备选流 3 - ATM 内现金不足在基本流步骤 6 中- 输入金额，如果 ATM 机内金额少于请求提取的金额，则将显示一则适当的消息，并且在步骤 6 - 输入金额处重新加入基本流。备选流 4 - PIN 有误在基本流步骤 4 中- 验证帐户和 PIN，客户有三次机会输入 PIN。 如果 PIN 输入有误，ATM 将显示适当的消息；如果还存在输入机会，则此事件流在步骤 3 - 输入 PIN 处重新加入基本流。 如果最后一次尝试输入的 PIN 码仍然错误，则该卡将被 ATM 机保留， 同时 ATM 返回到准备就绪状态，本用例终止。备选流 5 - 帐户不存在在基本流步骤 4 中 - 验证帐户和 PIN，如果银行系统返回的代码表明找不到该帐户或禁止从该帐户中提款，则 ATM 显示适当的消息并且在步骤 9 - 返回银行卡处重新加入基本流。备选流 6 - 帐面金额不足在基本流步骤 7 - 授权中，银行系统返回代码表明帐户余额少于在基本流步骤 6 - 输入金额内输入的金额，则 ATM 显示适当的消息并且在步骤 6 - 输入金额处重新加入基本流。备选流 7 - 达到每日最大的提款 金额在基本流步骤7- 授权中， 银行系统返回的代码表明包括本提款请求在内，客户已经或将超过在 24 小时内允许提取的最多金额，则 ATM 显示适当的消息并在步骤 6 - 输入金额上重新加入基本流。备选流 x - 记录错误如果在基本流步骤 10 - 收据中，记录无法更新，则 ATM 进入“安全模式”，在此模式下所有功能都将暂停使用。同时向银行系统发送一条适当的警报信息表明 ATM 已经暂停工作。备选流 y - 退出客户可随时决定终止交易（退出） 。交易终止，银行卡随之退出。备选流 z - “翘起”ATM 包含大量的传感器，用以监控各种功能，如电源检测器、不同的门和出入口处的测压器以及动作检测器等。在任一时刻，如果某个传感器被激活，则警报信号将发送 给警方而且 ATM 进入“安全模式”，在此模式下所有功能都暂停使用，直到采取适当的重启/重新初始化的措施。 第一次迭代中，根据迭代计划，我们需要核实提款用例已经正确地实施。此时尚未实施整个用例，只实 施了下面的事件流： 基本流 - 提取预设金额（10 美元、20 美元、50 美元、100 美元） 备选流 2 - ATM 内没有现金 备选流 3 - ATM 内现金不足 备选流 4 - PIN 有误 备选流 5 - 帐户不存在/帐户类型有误 备选流 6 - 帐面金额不足 以从这个用例生成下列场景
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ece6993fdc24a161aeb5c307cf3df40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db7418f93c57cb664eba1eb6bda263b3/" rel="bookmark">
			C&#43;&#43;数组、vector求最大值最小值及其下标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++数组、vector求最大值最小值和下标 可以用max_element（）及min_element（）函数，二者返回的都是迭代器或指针。 头文件：
#include&lt;algorithm&gt; 一.求数组的最大值或最小值 1、vector容器
例 vector&lt;int&gt; vec
最大值：
int maxValue = *max_element(v.begin(),v.end()); 最小值：
int minValue = *min_element(v.begin(),v.end()); 2、普通数组
例 a[]={1,2,3,4,5,6};
最大值：
int maxValue = *max_element(a,a+6); 最小值：
int minValue = *min_element(a,a+6); 2.求数组最大值最小值对应的下标
1、vector容器
例 vector&lt;int&gt; vec
最大值下标：
int maxPosition = max_element(v.begin(),v.end()) - v.begin(); 最小值下标：
int minPosition = min_element(v.begin(),v.end()) - v.begin(); 2、普通数组
例 a[]={1,2,3,4,5,6};
最大值下标：
int maxPosition = max_element(a,a+6) - a; 最小值下标：
int minPosition = min_element(a,a+6) - a; 注意：返回的是第一个最大（小）元素的位置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1a77e822a60253b1cb03820bb441a33/" rel="bookmark">
			理解bottleneck architecture
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇博文主要是讨论为什么叫 bottleneck architecture
bottleneck architecture翻译过来叫做瓶颈结构，瓶颈结构的特点是一头大一头小。
这个是针对于网络结构中输入/输出的维度(dimensions)来讲的。
来看一下Deep Residual Learning for Image Recognition(ResNet)论文当中的一部分。对应结构为下图。
原文：
The three layers are 1X1, 3X3, and 1X1 convolutions, where the 1X1 layers are responsible for reducing and then increasing(restoring) dimensions, leaving the 3X3 layer a bottleneck with smaller input/output dimensions.
翻译过来为：
这三层结构是1X1,3X3和1X1卷积，其中1X1层负责减小然后增加（恢复）尺寸，使3X3层成为具有较小输入/输出尺寸的瓶颈。
理解一 根据结构图解释一下。
“bottleneck” building block中
输入：256d(dimensions、维度)
第一层1*1卷积：64d，即进行了降维（瓶子上边大下边小）
第二层3*3卷积：64d
第三层1*1卷积：256d，即进行了升维（瓶子上边小下边大）
输出：256d
这就可以理解成两个瓶颈。
理解二 整个结构还可以理解成一个瓶颈，它类似于一个沙漏。（个人更偏向于这种理解方式）
作者：GL3_24
来源：CSDN
著作权归作者所有。转载请联系作者获得授权。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe1538d2061a7a2a027f831d5d53f355/" rel="bookmark">
			关于虚拟机使用无线网卡出现的延迟过高，丢包严重问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前一阵，为了方便，使用vmworkstation外接无线网卡做一些Linux上的程序测试，发现视频解码错误，查了几遍代码没有发现任何问题，偶然间ping了下包，发现最大有上千ms的延迟，移植了其余无线网卡发现还是一样效果，后来在我的电脑上装了个双系统，发现并不存在延迟问题，那就是虚拟机的问题了，装了个oracle的开源虚拟机，测试了一下，平均十几ms延迟，比vmworkstation强了太多，垃圾vm，我要是有正版的肯定投诉他了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d12c26272127e02e837e7f1c2028a12/" rel="bookmark">
			科大讯飞副总裁刘鹏：人机交互的未来是人人交互？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嘉宾介绍
刘鹏（微博&amp;知乎：北冥乘海生/公众号：计算广告），现任科大讯飞副总裁，大数据研究院院长。刘鹏在清华大学获得博士学位后，加入微软亚洲研究院，从事人工智能研究。后参与创建雅虎北京研究院，出任高级科学家。刘鹏还曾担任MediaV首席科学家、360商业化首席架构师等职。在多年从业经历中，刘鹏一直致力于将人工智能方法与海量数据相结合的工业界问题，负责过多个大型互联网商业产品体系。
Q1. 怎样才能在大公司里得到晋升？
大公司里，项目成果被截和的概率，正比于项目的成功程度。
如果你不明不白地撸起袖子就干，就算是项目大火，最多也就落得庆功宴上领导致词里轻描淡写的点赞：在CEO的英明领导下，COO的大力支持下，CAO的全力配合下，我带领团队，与某某和某某的兄弟部门密切配合，取得了阶段性的成果。在此，我们要对某某、...、某某(你)等骨干员工提出表彰，并给他们每人加发半个月的奖金！ 因此，要想获得credit，做事前起范儿至关重要。在事情八字还没一撇的时候，没几个人会跟你来抢功，趁着这个机会，一定要充分请示、频繁汇报，planning、brain storming、kick off搞个不停，一直到码皇们耳朵都磨出茧子，册封你为这个项目的负责人，全公司上下也都知道你有御赐的尚方宝剑。事情传开了，别人再来抢功，就师出无名了。
在大公司里，当一个干部管理的团队充分大时，他只有升职和离开两种可能的后续状态。
项目成败在天，干部晋升在人。把仕途寄托在虚无飘渺的项目成败上，是对自己不负责任的表现。趁着项目开工，迅速扩大团队的话，则可以立于不败之地——老板绝不可能承认一个高调成立的队伍啥也没干出来，因为那也是他的失职，最后只好找个机会给你升职加薪，这样的事情，在大公司呆过的应该都见过不少。
所以，这一步是干部往上升最核心的步骤：巧立一个名目，招到十来个人，经理的职位就算是稳了；如法炮制搞个大事情，招到大几十个人，再抓住各种机会多要点headcount，基本上就可以进入中层了。
我还听说某公司一位真正的高手，连名目也跳过了：在移动应用大火的那两年，这位经理主动跳出来说，我要为公司招100名iOS和安卓工程师！干什么先别管，这是公司的战略储备！老板激动得涕泗横流，当即批复：马上干！后来，这位就成了移动开发事业部的总经理。
怎么把小公司20人搞定的事儿编制出200个headcount，还显得倍儿有道理呢？这方面需要专门的技巧和经验了，回头有机会我们专门撰文说明。
Q2. 从事互联网行业的人员如何避免出现中年危机这种状况？
PPT路线：这条路线，是从写代码的岗位转入写PPT的岗位，比如产品、运营、领导秘书，或者仍在技术团队中的项目管理、架构等角色。
分析此路线的好处，首先在于PPT技能随变化很慢。我翻了翻十几年前看过的一些讲稿，放到今天也基本能糊弄过去。因此，PPT岗位不太容易因为技术的骤然升级而被淘汰。另外，虽然PPT能力非常容易习得，可是相配合的演讲能力却需要一番磨炼，总体来说比码农的上手速度也要慢。
Politics路线：这条路线，是从生产力岗位转入生产关系岗位，一般来说就是各种管理岗。这条路性价比高，竞争也激烈，要有意识地构建好自己的能力，才有机会进入。
这条路线的两个速度都很慢：搞生产关系这事儿，需要长时间与人斗的历练，核心能力的习得过程相当漫长，除了天赋异禀的白头山天降伟人，一般都是老而弥坚。另一方面，与人斗的技能树，中国在奴隶社会以降，就没有太大变化，以至有“半部论语治天下”的说法。所以，向这个方向努力，对码农来说，是逃离职场中年危机的通途。
Paper路线：这条路线适应者相对较少，不过却非常有效。简单来说，能够跟学术界搭上点儿关系，在此序列里标名挂号，比只会coding，长期职业生涯会顺利得多。
Q3. 目前人机交互有哪些难点？
今天所有实用的人工智能产品，都是用的“弱智”方法。简单来说，就是凑答案：准备一大坨标注好的数据，然后用大量机器堆上去狂撩，直到把答案凑个八九不离十。至于问题的内在逻辑和简约规律，今天的AI既无心顾及，也无力解读。
“弱智”方法在数据充沛的领域，可谓所向披靡：无论是语音识别、人脸识别，还是机器翻译、各种棋类，机器都已经接近乃至碾压真人了。且慢！机器翻译都快解决了么？翻译可比聊天要难吧？不然，机器翻译这个问题，答案是比较好凑的：找到足够多的语言对数据，把词译过去跟麻将牌一样码好了，再调整一下顺序即可。人机对话则不然，我们要找到对方语言里的关键信息，把它转化为动作，再把动作的结果反馈回去。这些关键信息处理的过程，是要经过统计意义上的推理过程的。
说到推理，当然离不开句子表达内容以外的背景知识。比如你问机器：“直径为10的球体积是多少？”机器就得会球的体积公式才算得出来。当然，微积分、背古诗、查法典这样的知识，对机器来说总是可以解决，因为有大量书本上的语料可供学习，按照弱智大法凑答案即可。难就难在，这世界上还有大量的知识，根本没地方学去。
Q4. 人机交互的未来是要做到人人交互吗？
从开始探索人机交互，我们就想当然地认为，把人人交互的那一端由人变成机器，就是人机交互的理想模式了。于是，我们设计出来的机器人，也都是俩肩膀扛个脑袋，四肢五官齐备，用语言的方式跟对面的人类交流，再加上对常识一窍不通，怎么看怎么像个二傻子。
问题出在哪儿了呢？人类的信息交互，最高效的输出方式是“说”，也就是音频通道；最高效的输入方式是“看”，也就是视频通道。如果你对面是个真人，那没办法，双方都只能靠说输出信息，这就形成了语音为主的交互方式。而靠语音的人机对话，是这样的画风：
我想订一张明天去上海的机票
为您查到：6:35海南航空HU7611，票价480元；6:50吉祥航空HO252，438元；6:50厦门航空MF8178，票价...
我去你大爷的吧！
别乐，就算对面不是机器是个真人客服，这种交互也同样令人抓狂，有过电话订票经历的朋友都有体会，只不过对着活人您不好意思骂街罢了。
既然对面是个机器人，就没必要如此拘泥了。实际上，机器的交互方式，应该跟我们“相反"而不是“相同”：你输出信息靠说，机器人接受信息就得靠听，这没错；你输入信息靠看，那机器人输出就别靠说了，何不在一块屏上展示出来呢？这样，不但信息输出效率提高了很多，而且用户只要在展示的信息底板上做选择题，就算用语音输入也大为便捷。
所以，真正适合人机交互的机器人，最好有个视频输出的设备，近了靠手机就可以，远了怎么办还值得探讨。这个概念，就是讯飞的胡郁老师讲的“强视觉呈现的语音交互”吧。这种模式下的交互方式，已经跟人人交互有了质的区别，未知之处很多，需要我们深入探索。当然，可以确定的是，机器人绝对应该抛弃人形，以避免用户用人的眼光和标准来评价它。
人机交互这件事，看起来简单，却是人工智能王冠上最耀眼的一颗明珠。目前看来，严格意义上的图灵测试离我们还相当遥远，不过通过交互方式和产品上的创新，一个在特定领域内可用的合格助手，或许已经在向我们招手了。
另外，由于计算机对海量信息的检索和处理能力远胜人类，或许可以让机器助手辅助人人交互，这样既能大大提高内容沟通效率，又能发挥人的情感沟通优势，这没准是目前更加可行的产品路线。
Q5. 人工智能的发展前景如何？
我进入这个行业已经有十多年了：博士期间，我做的是语音是别的研究，毕业开始又到MSRA接着干这个。虽然我们的两任院长——李开复老师和洪小文老师都是语音研究出身，却丝毫不能改变当年这一项目在全院最鸡肋的地位。因为在当年，各种各样的人工智能应用能真刀真枪上阵的并不多。更别提要是向互联网界提起自己是做“人工智能”的，那简直就像在两会会场上上偷看了毛片那样无地自容。实际上，那个时期，正是人工智能发展的第二落。
以史为鉴，可以知兴衰。为了探讨人工智能的发展前景，我们简单回顾一下人工智能前面发展的三起两落。
一、六十多年前的达特茅斯会议，提出了“Artifitial Intelligence”的课题，目的是让逐渐成熟的计算机能够代替人类解决一些感知、认知乃至决策的问题。这样一个课题是如此令人神往，也迅速吸引了大量学者的眼球，相关的研究也如火如荼地开展了起来。是为第一起。
二、初，学者们解决人工智能问题的思路，是以人为师，通过专家编制规则的方法，教机器下棋、认字乃至语音识别。在今天看来，这样的方法是完全南辕北辙的——人类的视听器官虽然很发达，却并没有能力总结提炼其中的规律。于是，人工智能的美好憧憬中迎来了残酷的现实，学者们发现解决问题是如此遥远，围观群众也一度认为人工智能的学者都是骗子。是为第一落。
三、既然靠人指导不行，那就要祭出“实事求是”的法宝，从数据里统计规律。在这样数据+统计的方法论下，诸如人脸识别、手写识别等一些较为简单的问题取得了重大进展，而在当时最困难的问题——大词表连续语音识别上，统计方法也是史无前例地造就了实验室中“基本可用”的系统。到此时，我们感觉找到了解决人工智能问题的基本思路。是为第二起。
四、数据+统计模型的方法盛行以后，也很快遇到了瓶颈：数据量的提升并不总能带来识别率的提高。当然，我们很早就知道“深度模型”比“浅层模型”学习数据的能力强，无奈这种模型的计算代价极高，只能望洋兴叹。拿语音识别为例，在“基本可用”到“实用”之间的鸿沟，十几年都没有跨过去，于是大家又转向悲观，觉得人工智能还只是个梦。是为第二落。
五、第二落以来，继续坚持在“深度神经网络”这条战线上的学者很少，因为做这个是拿不到funding的。其中有一位老前辈Jeffrey Hinton，和他的学生Alex一起，发现用GPU算神经网络，能大幅提高速度，于是这种模型居然可能实用了。一旦实用，深度模型可以疯狂吸收数据的优势就发挥出来了，于是在语音识别、图像识别等领域带来了飞跃式的进展。是为第三起。
当然，工业界的看到的这第三起，比我们上面轻描淡写提到的内容要波澜壮阔得多。不过，不要太在意，因为各路大佬不论过去是做黑产、卖假货还搞劫持的，都摇身一变成了人工智能的忠实拥趸和业界先驱——虽然他们的数学也就是初中肄业水平。去年，当我听到某此类上市公司老板歇斯底里地在财报中喊出要投入数千万美元搞人工智能时，不由心生感慨：修脚的可以挂妙手回春的锦旗，但千万别说自己是做精准医疗的！
虽然人工智能的第三起确实有了质的发展，但考虑到这些沉渣泛起的为人工智能从业者，我觉得第三落还是会来到，只不过并非对行业本身的怀疑，而是自我净化罢了。
而人工智能的行业发展趋势，由于大规模数据+大规模算力的基本方法论已经成熟，今后的发展路径是十分清楚的：在那些数据储备充分、商业价值清晰的场景，人工智能会迅猛发展，投身于这样的行业中期发展会非常好；而医疗、教育这类领域，由于电子化数据的整理与积累尚需时日，可以需要一个较为漫长的发展过程。
PMCAFF问答专场是一场与PMCAFF用户互动的问答活动，我们每期都会邀请知名互联网公司的一线产品从业者和咖友们共同交流，目前已成功举办过60+期，先后有来自腾讯、百度、阿里、360、小米、京东、去哪儿等大厂嘉宾入驻。
这个世界问题太多，我们需要一个能够解决问题的人。
如果你有足够的能力解决来自PMCAFF用户在你的专业领域中，以不同的角度提出各类刁钻问题，那么欢迎你参加PMCAFF问答专场。
活动申请可以添加工作人员微信沟通咨询，加好友请备注：问答专场。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd634e3c91fc4d1e0f31a0c2869daf4d/" rel="bookmark">
			caffe测试集分类类别完全一样，得分也一样
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天训练了SE-ResNet，任务是二分类。
训练 训练完成后的loss曲线为：
有曲线图可知，train_loss整体都在0.207左右，test_loss整体都在0.68-0.695之间。这样的loss曲线可以证明没有训好，根本没有学到东西（这是训的什么玩意儿！！！）。
测试 这里重点说一下测试的现象。抱着试一试的心态，我用classification.cpp进行了测试。测试结果也是一种很奇怪的现象。
我的任务是二分类，说一下测试结果：测试集分类类别完全一样（都是1），得分完全一样（都是0.555710）
总结 这样的结果可以明显的说明，网络根本没有学到东西，有可能是超参（网络大小，层数，学习率等）设置的不合理，试试其他网络或者修改参数试试。
作者：GL3_24
来源：CSDN
著作权归作者所有。转载请联系作者获得授权。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/619b51509ee3d7d8f262341765943f53/" rel="bookmark">
			c#之 三种注释方法以及快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#的三种注释方法
第一种：
常规的双斜杠： //
例如 ：
//这是一个注释 第二种：
/* 注释内容， 可以随意换行 */ 第三种：代码块上面的三斜杠注释，用来解释代码块的具体含义，便于后来者理解，例如：
/// &lt;summary&gt; ///管理层的工资 /// &lt;/summary&gt; /// &lt;param name="money"&gt;工资&lt;/param&gt; /// &lt;param name="fh"&gt;分红&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public double Calculation(double money) { int fh = 10000; return money + fh; } 当然，如果想要选中的行快速注释，除了第一第二中方法外，我们可以使用快捷键注释，这样就能在需要注释大量代码行的时候节省时间。
选中需要注释的代码，按ctrl+k+c当然也可以快速取消注释，快捷键为：ctrl+k+u
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/868c512acb788ea8c88c3ef57e78ed27/" rel="bookmark">
			caffe测试时报错 [....syncedmem.cpp:56] Check failed: error == cudaSuccess (2 vs. 0)  out of memory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象： 在caffe复现DenseNet的过程中，训练完成了，就到了测试阶段。当开始运行之后，过了一段时间发现报了一个错误。
F0523 12:55:04.591845 17608 syncedmem.cpp:56] Check failed: error == cudaSuccess (2 vs. 0) out of memory。爆内存了。如图所示。
分析一：batch_size 一般这个问题都是由于batch_size大小设置太大（训练时train_val中的TRAIN和TEST），导致内存不够用，但是由于DenseNet网络很深，需要的内存也很大。作者的显卡配置是1080Ti的，内存为11G。只有在train的batch_size和test的batch_size都设置为1的时候才能跑通。因此在测试的时候跟这部分已经没又关系了。只能和deploy文件有关系。
分析二：deploy文件 下图是输入层的设置，问题就出现在这儿。
首先分析每个参数的意义：
dim:10 #表示对待识别样本进行数据增广的数量，该值的大小可自行定义。但一般会进行5次crop，将整幅图像分为多个flip。该值为10则表示会将待识别的样本分为10部分输入到网络进行识别。如果相对整幅图像进行识别而不进行图像数据增广，则可将该值设置为1.
dim:3 #该值表示处理的图像的通道数，图像为RGB图像则通道数为3，设置该值为3
dim:224 #图像的长度
dim:224 #图像的宽度
问题就出现在第一个dim：10 网络并不需要进行数据增广，因此不需要设置，只需要设置为1。
当改完之后，再次进行测试，完全可以跑通，完美！
作者：GL3_24
来源：CSDN
著作权归作者所有。转载请联系作者获得授权。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cca0ae9fbfd2f152560ae6edebfa0f77/" rel="bookmark">
			训练时的Iteration、batchsize、epoch和loss的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		batchsize：批处理大小。一次训练所选取的样本数。 它的大小影响模型的优化程度和速度。
Iteration：迭代次数。一次Iteration就是batchsize个训练数据前向传播和反向传播后更新参数的过程。
epoch：所有训练数据前向传播和反向传播后更新参数的过程。也就是我们认为的所有数据集跑了一遍。
如果训练集大小是100000。batchsize为100，那么一个epoch需要1000次Iteration。
即：1 epoch = 训练集大小(100000) / batchsize(100) = 1000次Iteration loss：在训练过程中，训练日志中会输出loss值。这个loss值是每一个Iteration得到的loss值，也就是一个batchsize个训练数据前向传播和反向传播后更新参数的过程之后得到的loss值。
其实每次迭代都会得到一个loss值，只是我们在solver.prototxt中设置了display超参数，隔多少次显示一次。
更简单直接的理解就是， Iteration 0, loss = 0.693502，代表的是没有迭代时的loss， Iteration 1, loss =~~代表的是第一次迭代时的loss，也就是第一个batchsize个训练数据的loss，同理，第50次代表50个batchsize个训练数据的loss。
作者：GL3_24
来源：CSDN
著作权归作者所有。转载请联系作者获得授权。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/106/">«</a>
	<span class="pagination__item pagination__item--current">107/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/108/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>