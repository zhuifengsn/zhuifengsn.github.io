<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/695c24e828e1b193d231f39a1c0b2e54/" rel="bookmark">
			如何给基于对话框的应用加启动画面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多基于对话框的程序都有一个启动画面，那么如何为自己的对话框程序也加一个这样的画面呢？本文将一步一步教你实现每一个细节。其实VC++开发环境中有 一个现成的 Splash Screen 组件，用这个组件很容易实现基于框架类（也就是CMainFrame）的程序的启动画面，那么如果是对话框程序，没有框架类怎么办呢？所以这个组件功能不 是想象的那么强。要实现基于对话框应用程序的启动画面必须另辟蹊径。本文将定制一个C++类：CSplashWnd，用这个类可以增强原来的 Splash Screen 组件功能。它不但可以在用于具有CMainFrame的程序，同时也可以用于基于对话框应用的程序。 CSplashWnd的使用方法如下：
思路 需要改写三个函数：
CDialog::OnInitDialog() CWinApp::InitInstance() CWinApp::PreTranslateMessage(MSG* pMsg) 如果你用应用程序向导（AppWizard）创建工程，那么它会自动在CWinApp.h和CWinApp.cpp文件中产生 OnInitDialog 和 InitInstance 的声明和实现的默认代码，但是与CWinApp::PreTranslateMessage(MSG* pMsg)有关的处理必须自己添加到CWinApp派生类中。
具体步骤 第一步 在CDialog::OnInitDialog()方法末尾添加下列代码：
// 创建并显示启动画面 CSplashWnd::ShowSplashScreen(3000, IDB_SPLASH24, this); ShowSplashScreen函数的第一个参数是超时时间，以毫秒计算，表示启动画面持续显示的时间；第二个参数是位图图像的资源标示符，表示启动画面显示的图像。最后一个参数是父窗口，此参数可以为NULL。
第二步 在CWinApp::InitInstance()方法的开始处添加如下代码：
// Enable the splash screen component based on the command line info. CCommandLineInfo cmdInfo; ParseCommandLine(cmdInfo); CSplashWnd::EnableSplashScreen(cmdInfo.m_bShowSplash); 这几行代码的作用是让程序能解析和处理命令行信息。
第三步 用类向导（ClassWizard）改写 CWinApp::PreTranslateMessage(MSG* pMsg)方法，并添加如下代码：
BOOL CDialogsplApp::PreTranslateMessage(MSG* pMsg) { // Route messages to the splash screen while it is visible if (CSplashWnd::PreTranslateAppMessage(pMsg)) { return TRUE; } return CWinApp::PreTranslateMessage(pMsg); } 编译运行程序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/695c24e828e1b193d231f39a1c0b2e54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7710f8658583230c7aad744ec55bc08/" rel="bookmark">
			简历应答准备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首行占位
自我介绍 专业技能 1.常用模块 1.sys：与python解释器交互的一个接口 ，例：sys.path
2.os：与操作系统交互的一个接口 ，例：os.getcwd()
3.time：time.time()时间戳
4.hashlib：加密
5.random：随机
6.json：json.dumps(dict)、json.loads(str)
7.logging：日志
2.Django介绍、Flask概况与web开发流程 Django介绍：
使用Python编写的开源的Web应用框架，采用MTV的模式（增加一个URL分发器），特点是大而全
优点：功能齐全，提高开发效率；社区活跃文档健全，帮助开发者快速解决问题
缺点：高耦合，扩展性不强；笨重，过多不必要的功能
MTV：
M：模型（Model），负责业务对象和数据库的关系映射（ORM）
T：模板（Template），负责把页面展示给用户（html）
V：视图（View）：负责业务逻辑，在适当时候调用Model和Template
除了以上三层之外，还需要一个URL分发器，将一个个URL的页面请求分发给不同的View处理，View再调用相应的Model和Templat
转载于:https://www.cnblogs.com/yijue-lu/p/11135205.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5183cb021ddcc39cfb33d7f15b8f064/" rel="bookmark">
			Bugly Tinker热修复 后台显示补丁下发成功 并且已激活，但是没有生效的问题解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景：
对于加固包通过tinker进行热更新，补丁显示下发生成，并且已经激活，但是补丁实际上没有生效。
问题：
是什么原因导致的补丁不能生效？
解决方案：
分三种情况：
1.显示补丁下发成功，并且显示已经激活，但是实际上没有生效。
通过各种原因的排查，最终锁定在混淆问题上。因为混淆规则不正确。
我的混淆规则中，排除的是系统的activity和fragment
-keep public class * extends android.app.Fragment -keep public class * extends android.app.Activity 但我实际应用的是v7包的AppCompatActivity和v4包的Fragment
-keep public class * extends android.support.v7.app.AppCompatActivity -keep public class * extends android.support.v4.app.Fragment 修改之后，下发补丁，修复成功。
如果还无法解决，就把所有引用的base类要排除混淆。
2.显示下发成功，但是一直没有激活。
如果是补丁下发成功，但是一直显示没有激活，那就是签名有问题，要确保基准包和补丁包签名一致。在buildTypes里面配置签名，可以确保签名的一致性。
buildTypes { debug { buildConfigField "boolean", "IS_DEBUG", "true" minifyEnabled false signingConfig signingConfigs.debug } release { buildConfigField "boolean", "IS_DEBUG", "false" minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' signingConfig signingConfigs.release } } 3.一直没有下发成功。
可能是因为混淆规则中没有添加tinker的混淆规则，导致tinker异常。添加tinker混淆规则配置如下规则。
-dontwarn com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5183cb021ddcc39cfb33d7f15b8f064/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94168bd828e1c8d2b14e9216146e5f30/" rel="bookmark">
			【转】本人常用资源整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人常用资源整理(ing...) Deep Learning（深度学习）：
ufldl的2个教程(这个没得说，入门绝对的好教程，Ng的，逻辑清晰有练习)：一
ufldl的2个教程(这个没得说，入门绝对的好教程，Ng的，逻辑清晰有练习)：二
Bengio团队的deep learning教程，用的theano库，主要是rbm系列，搞python的可以参考，很不错。
deeplearning.net主页，里面包含的信息量非常多，有software, reading list, research lab, dataset, demo等，强烈推荐，自己去发现好资料。
Deep learning的toolbox，matlab实现的，对应源码来学习一些常见的DL模型很有帮助，这个库我主要是用来学习算法实现过程的。
2013年龙星计划深度学习教程，邓力大牛主讲，虽然老师准备得不充分，不过还是很有收获的。
Hinton大牛在coursera上开的神经网络课程，DL部分有不少，非常赞，没有废话，课件每句话都包含了很多信息，有一定DL基础后去听收获更大。
Larochelle关于DL的课件，逻辑清晰，覆盖面广,包含了rbm系列，autoencoder系列，sparse coding系列，还有crf，cnn，rnn等。虽然网页是法文，但是课件是英文。
CMU大学2013年的deep learning课程，有不少reading paper可以参考。
达慕思大学Lorenzo Torresani的2013Deep learning课程reading list.
Deep Learning Methods for Vision(余凯等在cvpr2012上组织一个workshop，关于DL在视觉上的应用)。
斯坦福Ng团队成员链接主页，可以进入团队成员的主页，比较熟悉的有Richard Socher, Honglak Lee, Quoc Le等。
多伦多ML团队成员链接主页，可以进入团队成员主页，包括DL鼻祖hinton，还有Ruslan Salakhutdinov , Alex Krizhevsky等。
蒙特利尔大学机器学习团队成员链接主页，包括大牛Bengio，还有Ian Goodfellow 等。
纽约大学的机器学习团队成员链接主页，包括大牛Lecun，还有Rob Fergus等。
Charlie Tang个人主页，结合DL+SVM.
豆瓣上的脑与deep learning读书会，有讲义和部分视频，主要介绍了一些于deep learning相关的生物神经网络。
Large Scale ML的课程，由Lecun和Langford讲的，能不推荐么。
Yann Lecun的2014年Deep Learning课程主页。 视频链接。 吴立德老师《深度学习课程》
一些常见的DL code列表，csdn博主zouxy09的博文，Deep Learning源代码收集-持续更新…
Deep Learning for NLP (without Magic)，由DL界5大高手之一的Richard Socher小组搞的，他主要是NLP的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94168bd828e1c8d2b14e9216146e5f30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31c8ba7614e537d3340cd86d50fd2361/" rel="bookmark">
			向后兼容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		检查浏览器是否兼容这个方法，加一句：
window.onload = function(){
if(!document.getElementsByTagName) return false；
var links = document.getElementsByTagName("a");
for ( var i = 0 ; i&lt;links.length ; i ++){
if ( links[i].className == "popup"){
links[i].onclick = function(){
popUp(this.getAttribute("href"));
return false;
}
}
}
}
虽然只是一条简单的if语句，但它可以确保那些‘古老的’浏览器不会因为我的脚本代码而出问题。这么做是为了让我的脚本有良好的向后兼容性。因为在给网页添加各有关行为时始终遵循了‘循序渐进’的原则，所以确实地知道我添加的那些功能有预留退路，我的网页在那些‘古老的’浏览器里也能正常浏览。那些只支持一部分javascript功能、但不支持DOM的浏览器任可以访问我的网页内容。 浏览器嗅探（browser sniffung）技术
转载于:https://www.cnblogs.com/Eleanore/archive/2012/05/25/2518168.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18c0dd2f99bc2acb4de75f6fcf61f50c/" rel="bookmark">
			我是如何自学python到找到工作经过
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先做个自我介绍，我13年考上一所很烂专科民办的学校，学的是生物专业，具体的学校名称我就不说出来献丑了。13年我就辍学了，我在那样的学校，一年学费要1万多，但是根本没有人学习，我实在看不到希望，我就退学了。
退学后我也迷茫，大专都没有毕业，我真的不知道我能干什么，我在纠结着我能做什么。所以辍学后我一段时间，我想去找工作，因为我比较沉默寡言，不是很会说话，我不适合去应聘做业务。我想应聘做技术的，可是处处碰壁。
一次偶然的机会，我才听到python这个行业。那天我去新华书店，在计算机分类那边想找本书学习。后来有个女孩子走过来，问我是不是读计算机的，有没有兴趣学习python，然后给我介绍了一下python现在的火热情况，告诉我学python多么的有前景，给我了一份传单，python培训的广告。听了她的介绍，我心里痒痒的，确实我很想去学会一门自己的技术，靠自己的双手吃饭。
回家后，我就上网查了下python，确实是当今比较热门的行业，也是比较好找工作的，工资也是相对比较高。我就下决心想学python了。于是我去找python培训的相关信息，说真的，我也很迷茫，我不知道培训是否真的能像他们宣传的那样好，所以我就想了解一段时间再做打算。
后来，我在百度知道看到一篇让我很鼓舞的文章是一个python高手介绍没有基础的朋友怎么自学入门学python，文章写的很好，包含了如何学习，该怎么学习。他提到一个方法就是看视频，因为看书实在太枯燥和费解的，很多我们也看不懂。这点我真的很认同，我自己看书往往看不了几页。
我在想，为什么别人都能自学成才，我也可以的！我要相信自己，所以我就想自学，如果实在学不会我再去培训。
主意一定，我就去搜索python的视频，虽然零星找到一些python的视频，但是都不系统，我是想找一个能够告诉我该怎么学的视频，一套从入门到精通的视频，一个比较完整的资料，最好能有老师教，不懂可以请教的。
后来我又找到一份很好的视频，是在求知讲堂推出的一份视频《零基础人工智能+python就业班》，网址：http://www.qiuzhijiangtang.com/python.html。里面的教程还不错，很完整。
下面介绍下我的学习流程，希望对和我一样完全没有基础的朋友有所帮助。
下载他们课程，我就开始学习了，由于我没有什么基础，我就从最简单的python基础编程和linux视频教程学起，话说简单，其实我还是很多不懂的，只要重复多看几遍，就能看懂。我差不多学了一个月才学完，接下来我就学了前端开发和web开发，差不多一个多月。我每天都在不停的写一些简单的代码，这样二个月后我基本掌握了python的全部基础。
接下来开始学习python高级课程爬虫开发和人工智能，老师幽默风趣而又轻松的课堂教课，使我发现原来学习python并不是一件很难的事情。之前我把python基础学得还不错，到了到了python高级部分，我觉不又不是很难，可能老师太牛了，他能把复杂的问题讲的比较通俗易懂，有些难点的地方我还是连续看了五六次，把他弄懂。每天下午6点下班后，吃了饭，马上跑回家。看视频，买了几本笔记本。当时，为了编程还花几百元了台二手的台式电脑，配置一般，但编程是足够的。一边看视频，一边记笔记，把重点都记下来，还一边跟着老师敲代码，为了能尽早学会python。每天都坚持学5-6个小时。经常学到晚上一点多才睡觉。星期六，日不用上班，每天7点多起床，学到晚上11,12点。那段时间特别辛苦，特别累。在学习python的三个多月里，除了吃饭睡觉工作，剩余的时间都在学习，因为我知道自己的计算机基础不是很好，也没有学过什么计算机，相对于那些科班的人来说我要比他们付出更多的努力。我只能咬紧牙关，坚持下去，我不能放弃，我要完成我的梦想，我要让我的家人过上好日子。终于三个多月后我把python教程里的内容和项目都学完了，在学项目的过程中我发现项目特别重要，他能把你学过的知识全部联系起来，能更好的理解你所学的知识。还有学习过程中，动手很重要，要经常跟着老师动手敲，动手吧，跟着做，一行一行的跟着敲，再试着加一些自己的功能，按照自己的思路敲一些代码，收获远比干听大的多。 如果遇到暂时对于一些思路不能理解的，动手写，先写代码，慢慢你就会懂了。
于是我就到51job疯狂的投简历，因为我学历的问题，专科没有毕业，说真的，大公司没有人会要我，所以我投的都是民营的小公司，我希望自己的努力有所回报。没有想过几天过后，就有面试了，但是第一次面试我失败了，虽然我自认为笔试很好，因为我之前做了准备，但是他们的要求比较严格，需要有一年的项目经验，所以我没有被选中。
后来陆续面试了几家公司，终于功夫不负有心人。我终于面试上的，是在闵行的一家民营的企业，公司规模比较小，我的职务是python开发程序员，但我也比较满足，开的工资是5500一个月，虽然我知道在上海5500只能过温饱的生活，但是我想我足够了。我至少不用每天都要靠父母养，我自己也能养活自己的。我想只要我继续努力，我工资一定会翻倍的。
把本文写出来，希望能让和我一样的没有基础的朋友有信心，其实我们没有必要自卑，我们不比别人笨，只要我们肯努力，我们一样会成功。
转载于:https://www.cnblogs.com/tanglaoya3/p/11131257.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2da412756460d93a705d304a09a198e1/" rel="bookmark">
			数据结构—队列的顺序表示和实现--循环队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		和顺序栈相类似，在队列的顺序存储结构中，除了用一组地址连续的存储单元依次存放从队列头到队列尾的元素之外，尚需附设两个整型变量 front和rear分别指示队列头元素及队列尾元素
1.队列的顺序表示
typedef struct { int *base; // 分配存储空间 int front; // 队头指针 int rear; // 队尾指针 }SqQueue; 为了在C语言中描述方便起见,在此约定：初始化创建空队列时，令font=rear=0，每当插入新的队列尾元索时，尾指针rear增1;每当删除队列头元素时，头指针 front增1。因此，在非空队列头指针始终指向队列头元素，而尾指针始终指向队列尾元素的下一个位置，如图： 假设当前队列分配的最大空间为6，则当队列处于图(d)所示的状态时不可再继续入新的队尾元素，否则会出现溢出现象，即因数组越界而导致程序的非法操作错误。事实上，此时队列的实际可用空间并未占满，所以这种现象称为“假溢出”。这是由“队尾入队，队头出队”这种受限制的操作造成的。怎样解决这种“假溢出”问题呢?一个较巧妙的办法是将顺序队列变为一个环状的空间，如图所示，称之为循环队列。 头、尾指针以及队列元素之间的关系不变，只是在循环队列中，头、尾指针“依环状增1”的操作可用“模”运算来实现。通过取模，头指针和尾指针就可以在顺序表空间内以头尾衔接的方式循环移动。 在图(a)中，队头元素是J5，在元素J6人队之前，在 Q.rear的值为5，当元素J6人队之，通过“模”运算，Q.rear=(Q.rear+1)%6，得到 Q.rear的值为0，而不会出现图上图(d)的“假溢出”状态在图(b)中，J7、J8、J9、J10相继入队，则队列空间均被占满，此时头、尾指针相同。在图(c)中，若J5和J6相继从图(a)所示的队列中出队，使队列此时呈“空”的状态，头、尾指针的值也是相同的。由此可见,对于循环队列不能以头、尾指针的值是否相同来判别队列空间是“满”还是“空”。在这种情况下,如何区别队满还是队空呢?通常有以下2种处理方法。(1)少用一个元素空间，即队列空间大小为m时，有m-1个元素就认为是队满。这样判断队空的条件不变，即当头、尾指针的值相同时，则认为队空；而当尾指针在循环意义上加1后是等于头指针。则认为队满。因此，在循环队列中队空和队满的条件是: 队空的条件: Q.front = Q.rear队满的条件:(Q.rear+1)% MAXQSIZE = Q.front如图(d)所示，当J7、J8、J9进入图(a)所示的队列后，(Q.rear+1)% MAXQSIZE的值等于Q.front，此时认为队满。(2)另设一个标志位以区别队列是“空”还是“满”。 2.循环队列初始化
算法步骤 ①为队列分配一个最大容量为 MAXQSIZE的数组空间，base指向数组空间的首地址②头指针和尾指针置为零,表示队列为空。算法描述 int InitQueue(SqQueue &amp;Q) { Q.base = new int[MAXQSIZE]; //分配存储空间 if (!Q.base) return 0; // 存储空间分配失败 Q.front = Q.rear = 0; return 1; } 2.求队列长度
对于非循环队列，尾指针和头指针的差值便是队列长度，而对于循环队列，差值可能为负数所以需要将差值加上MAXQSIZE，然后与 MAXQSIZE求余。算法描述 int QueueLength(SqQueue Q) { return ((Q.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2da412756460d93a705d304a09a198e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e236326d2895e48dffb424fbd06e7310/" rel="bookmark">
			学习Oracle Concepts-第6章 数据字典与动态性能视图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容主要来源于Oracle官方文档(官网英文版和网络中文版)
Oracle Database Concepts
1.数据字典概述 数据字典是一组提供有关数据库管理元数据的只读表，包含如下信息：
1.数据库中模式对象的定义，包括列的默认值和完整性约束信息；
2.分配给模式对象和模式对象已经使用的空间量；
3.数据库用户的名称，授予用户的权限和角色、与用户相关的审计信息；
数据字典是数据库管理的核心部分，比如数据库会执行如下操作：
访问数据字典查找相关用户、模式对象很存储结构的信息；
每次发出DDL语言，修改数据字典；
1.1 数据字典的内容 数据字典由下列对象组成：
1、基表：这些基础表存储关于数据库的信息。只有数据库能够写和读这些表。用户很少直接访问基础表，因为它们已经被规范化，并且大部分数据被存储为隐藏格式；
2、视图：这些视图通过联接和过滤语句，简化基础表的数据称为有用的信息，例如用户或者表名。这些视图包含数据字典中所有对象的名称和描述。一些视图能够被所有数据用户访问，其他的职位管理员设计。
数据字典视图集 前缀用户访问内容注意DBA_数据库管理员所有对象一些DBA_视图包含对管理员有用的额外列ALL_所有用户用户有权限的对象包括用户拥有的对象。这些视图服从已启用的角色集合USER_所有用户用户拥有的对象这些视图通常不包含OWNER列，被隐含为查询该视图的用户 不是所有视图都有这三个成员。例如有DBA_LOCK，没有ALL_LOCK。
系统提供了一个名为DICTIONARY的视图，包含所有数据字典视图的名称和简短的描述。
以DBA_开头的视图 显示全库的相关信息，DBA_开头的视图只是为数据库管理员设计的。
例如：查询数据库的所有对象
SELECT OWNER, OBJECT_NAME, OBJECT_TYPE FROM DBA_OBJECTS ORDER BY OWNER, OBJECT_NAME; 以ALL_开头的视图 以ALL_开头的视图从该用户的视角透视数据库。这些视图返回关于用户能访问的模式对象的信息，包括公共或显示时授予的权限和角色；以及用户拥有的模式对象。
例子：你能访问的所有对象
SELECT OWNER, OBJECT_NAME, OBJECT_TYPE FROM ALL_OBJECTS ORDER BY OWNER, OBJECT_NAME; 由于该视图遵从当前已启用的角色集，所以查询结果取决于启用了那些角色,默认情况下，角色是未启用的
SQL&gt; SET ROLE ALL; Role set. SQL&gt; SELECT COUNT(*) FROM ALL_OBJECTS; COUNT(*) ---------- 68295 SQL&gt; SET ROLE NONE; Role set. SQL&gt; SELECT COUNT(*) FROM ALL_OBJECTS; COUNT(*) ---------- 53771 以USER_开头的视图 最能引起普通用户兴趣的是以USER_开头的视图，这些视图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e236326d2895e48dffb424fbd06e7310/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc5a6a2aaa9b3a73810c88125e0979f7/" rel="bookmark">
			The first Tcl script
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 在NS2中跑了一个最简单的The first Tcl script。
2. 大概了解构件：节点，链路，Agent等。
3. 下面学习计划：
理清Otcl和C++类的对应关系学习案例Mflood学习AODV协议 P.S. 论文的背景部分，可以开始着手整理。
转载于:https://www.cnblogs.com/zhangrui/archive/2012/02/10/2345892.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c389ac133d1d5b2ddec1a9c8ed4059c/" rel="bookmark">
			Eclipse3.4汉化包安装步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天才发现自己又落后了，估计很多人已经把eclipse3.4用过一阵子了，自己竟然还不知道，还在用eclipse3.3写代码呢。 下载了Java EE版的eclipse后，解压缩进行安装（绿色阿） 打开当然毫无疑问是英文版了，那么我的下一步目标当然是进行汉化了（英文太滥阿） 和3.3差不多直接从Eclipse3.4的菜单"Help --&gt; Software Updates，这里和3.3稍微有些不同，就是把两个选项集成到一个窗口中了而已，废话不多说，看图： 看到窗口中的上方一些了吗，有两个标签可以切换子窗口，点选Available Software，然后点选Add Site...按钮，输入URL： http://download.eclipse.org/technology/babel/update-site/ 然后他就会加入到窗口中，这时也许点该网址对应的列表刷不出来，没关系，Refresh一下，然后看图： 当然选中文了，你觉得选其他语言有用吗？是穷显摆你的学识吗？有种下个希伯来文玩（不太确定现在还存在这种古圣经的语种）。 然后接受许可协议，下面就不废话了，只要上过小学的懂几个单词的都可以操作下来，然后重起eclipse然后就中文啦，看图吧： 最后，希望大家参与到eclipse的汉化工作中，中国人这么多人，我就不信连日本人的进度都追不过，不太明白为什么中国人为什么都在索取而不去贡献。 eclipse 中文化babel项目需要你一起参与！ 今天早晨我已经注册了账号并开始参与汉化了，其实一般的英文谁都可以去翻译的，难一些的句子可以跳过让高手翻译，翻译工作是采用的Wiki式的协同工作式，你的翻译也可能被翻译更好的人覆盖，里面也有详细的翻译日志，有些像SVN的版本管理。这里注册：https://babel.eclipse.org/babel/login.php 注册完后估计要等半个小时才能进去翻译，因为估计bugzilla和babel不同步。 当然必然的3.4的插件注册形式和已往的有些不同，而且也存在兼容性，过一段时间磨合磨合估计能好一些，3.3刚出来的时候还不是bug一堆吗？ 7/19/2008 re-edit:http://download.eclipse.org/technology/babel/update-site/ganymede 是专门针对3.4的汉化，汉化效果非常棒！
3.4能用的SVN插件：http://subclipse.tigris.org/update_1.4.x
转载于:https://www.cnblogs.com/xtsong/archive/2008/07/23/1249238.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad213743437318716441363d30959481/" rel="bookmark">
			Java 中File类的createNewFile()与createTempFile(), delete和deleteOnExit区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Java 中File类的createNewFile()与createTempFile()的区别
最近，在看代码时看到了一个方法， File.createTempFile() ，由此联想到File.createNewFile() 方法，一时间不知道两者到底有什么区别，感觉都是创建新文件嘛，后来查看api文档介绍，并经过自己动手试验，终于有了一个较为清楚地认识。 1. File 的 createNewFile() 方法： createNewFile()；返回值为 boolean； 方法介 绍：当且仅当不存在具有此抽象路径名指定名称的文件时，不可分地创建一个新的空文件。 使用： File file = new File("D:\\test\\1.txt"); boolean res = file.createNewFile(); if(!res)System.out.println("创建失败！");
如果D:/test 目录下没有 1.txt文件，则创建该文件；如果没有test目录，直接抛出异常，如果1.txt已经存在，那么文件创建失败。 可以得知，createNewFile() 方法，根据抽象路径创建一个新的空文件，当抽象路径制定的文件存在时，创建失败。
2. File 的 createTempFile() 方法
该方法有两种调用方式： createTempFile(String prefix, String suffix)； 在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称。 createTempFile(String prefix, String suffix, File directory)； 在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。
File file2 = new File("D:\\temp");// D;/temp 为一个目录 File tempFile1= file2.createTempFile("msg", ".tmp",file2); File tempFile2 = file2.createTempFile("msg", ".tmp"); System.out.println(tempFile2.getAbsolutePath());
可以这么认为，createTempFile() 方法，在指定的目录下创建一个temp文件，directory 类型为File ，如果路径不存在，则创建失败。createTempFile(String prefix, String suffix)；方法默认的保存路径为：C:\Documents and Settings\Administrator\Local Settings\Temp 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad213743437318716441363d30959481/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/260355c54d5778a16c9e3653e86f1047/" rel="bookmark">
			java编译和运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java应用程序的基本结构编写源文件保存源文件额外附加编译器（javac.exe）解释器（java.exe） 总结：
假如我的B.java源文件在C:\Users\AUSU\Desktop\ts里面
一般都是进入到这个目录里面编译解释
编译：javac B.java
解释：java B
注意：
解释不可能以带目录的方式去运行程序，编译可以
零：java应用程序的基本结构
一个java应用程序由若干个类组成，这些类可以在一个源文件，也可以分布在若干个源文件
java应用程序总是从主类的main方法开始执行
编译器忽略注释内容
一：编写源文件
一个源文件可以有多个类（class）,但只能有一个类是public类
如果有一个类是public类，那么源文件的名字必须与这个类的名字完全相同，扩展名是 .java(注意这个有个点)
如果源文件没有public类，那么只要名字和某个类相同，且扩展名是.java也可以
二：保存源文件
保存类型选择为所以类型，编码选择为ANSI
三：额外附加：
（1）C盘转到D盘
（2）进入某个子目录（文件夹），比如下面的进入E盘的java文件夹
（3）退出某个子目录，比如退出java文件夹
四：编译器（javac.exe）
javac B.java
在上面可以看到编译成功后出现了B.class文件（字节码文件）
如果源文件有多个类，编译源文件会生成多个扩展名为.class的文件，在每个扩展名为.class的文件中只存放一个类的字节码，其文件名与该类的名字相同。
如果文件是这个
public class B { int a=1; int f(int b){ a=b; return a; } } 编译后得到的class文件，我使用反编译器（网上下载的）可以得到这样
public class B { int a = 1; int f(int paramInt) { this.a = paramInt; return this.a; } } 注意：在编译时候可能会出现的问题
（1）如果回车后出现javac不是内部或外部命令，也不是可运行的程序或批处理文件
解决方法：
方法一：重新设置环境变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/260355c54d5778a16c9e3653e86f1047/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffe7892e3523049105dd733279255b12/" rel="bookmark">
			健康小常识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		健康小常识 正确饮食习惯: 早上吃的像皇帝,中午吃的像平民,晚上吃的像乞丐 苹果是机车族、瘾君子、家庭主妇的常备良药， 一天一颗，才能让自己有个干干净净的肺 10种吃了会快乐的食物: 深海鱼,香蕉,葡萄柚,全麦面包,菠菜,大蒜,南瓜,低脂牛奶,鸡肉,樱桃 posted on 2009-08-20 13:09 ／ 囧丶 阅读( ...) 评论( ...) 编辑 收藏 转载于:https://www.cnblogs.com/bengkuiing/archive/2009/08/20/1550546.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/613bc4dbb85a77d50315a67dbe12d859/" rel="bookmark">
			VS2017 WPF程序打包部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装Installer
1、工具-扩展和更新-联机
(1) 下载安装installer
(2)下载完成之后，关闭VS2017,重新启动之后，单击修改，安装插件
(3)关闭后重新打开要打包的工程
二、打包可执行程序
1、现有项目中选择解决方案资源管理器 -选择解决方案-右键-新建项目
三个文件夹分别指向要发送到[文件安装目录下/桌面/开始菜单]中的文件。
Application Folder：用来存放程序项目的可执行文件、资源（图片、音频、视频等）、各种依赖dll文件。 User's Desktop：用来生成桌面快捷方式User's Programs Menu：用来生成开始菜单快捷方式 2、Application Folder
（1）Application Folder右键选择Add&gt;项目输出，接着在弹出窗口中选择主输出，点击确定。
这一步生成如下：
（2）我的bin-Release文件下还有两个用于保存图片的文件夹
Add-Folder 并将文件夹重命名为bin-release文件下同样的名字
接着Add-文件 将Release文件的文件下的内容都添加进来
（3）接着通过add&gt;文件（或Folder）选项将程序运行所需要的其他资源文件、dll文件等全部添加到目录中，创建桌面快捷方式和菜单快捷方式时使用。
3、User's Desktop
选择主输出文件-右击生成快捷方式
对快捷方式重命名
给新建的快捷方式添加图标，图标路径从上面Images文件中添加
拖动到User's Desktop下
4、User's Programs Menu
（1）快捷方式创建
桌面快捷方式和菜单快捷方式创建的方法是相同的，按照User's Desktop下同样方式创建快捷方式，并拖到User's Programs Menu下
（2）安装包提供卸载功能
注意：32位和64位电脑的msiexec.exe相同
1）32位系统
注意：目标系统为32系统 属性中TargetPlatform设置为X86,目标系统为64系统 属性中TargetPlatform设置为X64
Application Folder右键添加文件"C:\Windows\System32\msiexec.exe"。
选中msiexec.exe文件右键创建快捷方式，命名为uninstall
选中uninstall快捷方式，Arguments属性设置为"/x ProductCode"，其中ProductCode的值取自setup project属性中的ProductCode的值。
卸载快捷方式拖动到User's Programs Menu下
注意为了菜单栏中生成快捷方式后，快捷方式和卸载快捷方式都在一个文件下，可以User's Programs Menu创建一个文件夹，将两个快捷方式放到该文件夹下
5、设置完毕，执行build生成解决方案
三、其他注意事项
1、图标转换网址
https://www.easyicon.net/covert/
参考：https://blog.csdn.net/smallbabylong/article/details/78756530
https://blog.csdn.net/Shenpibaipao/article/details/83152955
https://www.jianshu.com/p/0073859e9b0b
https://blog.csdn.net/weixin_42974146/article/details/93649433
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06eea5517305974904f438fdbf26f41a/" rel="bookmark">
			转义字符\r、\n、以及\r\n的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、转义字符 转义字符用来表示常见的那些不能显示的ASCII字符。
常见的转义字符有\t、\n、\r、\\等等，详见常见的转义字符及其意义(C语言)
二、\r、\n、以及\r\n的区别 \r ：将当前位置移到本行开头。又叫回车，对应键盘上的return键
\n：将当前位置移到下一行开头。又叫换行，newline。
这时候可能就有人陷入了思考中，在文本中回车不就相当于换行了吗？换行不就相当于到了下一行了吗？其实按道理说这样理解是没有问题的，但是在不同的操作系统中，换行是由不同的方式来表示的。
Linux中\n表示回车并换行；
Windows中\r\n表示回车并换行。
Mac中\r表示回车并换行。
以上这种表示方式的理解可以通过打开一个文本文件来进行理解，但是需要引入三个概念。CR、LF、CRLF。
三、CR、LF、CRLF CR：Carriage Return，对应ASCII中转义字符**\r**，表示回车
LF：Linefeed，对应ASCII中转义字符**\n**，表示换行
CRLF：Carriage Return &amp; Linefeed，\r\n，表示回车并换行
四、举例理解 随便编辑打开一个txt文件，然后选择菜单栏中的编辑-----&gt;档案格式转换----&gt;转换为Windows格式
然后选择菜单栏中的视图----&gt;显示符号----&gt;显示行尾符
这样就可以看到行尾符了，可以看到每一行的末尾都有CRLF这就代表回车并换行
作者：GL3_24
来源：CSDN
著作权归作者所有。转载请注明来源。
https://blog.csdn.net/GL3_24/article/details/93774122
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b906f8452eccc092ff5bf0402d677ee/" rel="bookmark">
			python多线程的锁用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		锁机制
在了解锁机制前，我们先来看一下下面这个例子：
## 使用多线程进行加法运算 import threading # 定义全局变量VALUE VALUE = 0 # 定义加法线程函数 def add_value(): global VALUE for x in range(1000000): VALUE += 1 print('value = ', VALUE) # 定义两个线程并发执行加法操作 def add_thread_main(): for x in range(2): t = threading.Thread(target=add_value) t.start() if __name__ == '__main__': add_thread_main() """ Output: value = 1147074 value = 1211397 """ 上面的示例按照我们的逻辑看来应该是依次输出1000000和2000000，但结果并不是这样的，这就是常说的多线程共享全局变量问题。其实在我们执行线程时，执行的顺序是不一定的，也就是说有时候可能重合在一起执行，因而导致有时虽二者都对共享变量进行了一次加法(即本应加两次)而实际上只真正加了一次。
而为了解决这样的问题，threading模块提供了一个Lock类，这个类可以在某个线程访问某个变量的时候加锁，其他线程此时不能访问该变量，直到加锁线程处理完控制变量并把锁释放了，其他线程才能进行访问处理。锁机制使用起来也很简单，由于是多个线程访问共享变量，因而需设置一个全局的Lock类对象，然后在访问前后分别使用Lock类的acquire()方法加锁和release()方法释放锁。
上述例子使用锁机制仅需做以下几处的修改：
## 使用多线程进行加法运算 import threading # 定义全局变量VALUE VALUE = 0 gLock = threading.Lock() # 定义加法线程函数 def add_value(): global VALUE gLock.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b906f8452eccc092ff5bf0402d677ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66417c3c3d5008e31b6c25047ea9c310/" rel="bookmark">
			计算机网络运输层习题5-38
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5-38　设TCP的ssthresh（慢开始门限ssthresh）的初始值为8（单位为报文段）。当拥塞窗口上升到12时网络发生了超时，TCP使用慢开始和拥塞避免。试分别求出第1轮次到第15轮次传输的各拥塞窗口大小。你能说明拥塞窗口每一次变化的原因吗？
解答：拥塞窗口大小及变化原因见表T-5-38
表T-5-38 15个轮次拥塞窗口大小及变化原因
轮次拥塞窗口拥塞窗口变化的原因11网络发生了超时，TCP使用慢开始算法22拥塞窗口值加倍34拥塞窗口值加倍48拥塞窗口值加倍59TCP使用拥塞避免算法，拥塞窗口值加1610TCP使用拥塞避免算法，拥塞窗口值加1711TCP使用拥塞避免算法，拥塞窗口值加1812TCP使用拥塞避免算法，拥塞窗口值加191网络发生了超时，TCP使用慢开始算法102拥塞窗口值加倍114拥塞窗口值加倍126拥塞窗口值加倍，但到达12的一半时，改为拥塞避免算法137TCP使用拥塞避免算法，拥塞窗口值加1148TCP使用拥塞避免算法，拥塞窗口值加1159TCP使用拥塞避免算法，拥塞窗口值加1 欢迎评论，共同进步！！
转载于:https://www.cnblogs.com/hengzhezou/p/11071384.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9c8aafb3e44ceb4b0b6a1b43cc04f55/" rel="bookmark">
			shell脚本基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		shell脚本基础 1.变量 1.1什么是变量 变量即可以变化的量
[root@lwq ~]# a=1 [root@lwq ~]# a=2 [root@lwq ~]# echo $a 2 1.2变量名称注意事项 只能包含字母，数字，下划线，并且不能以数字开头不应该跟系统中已有的环境变量重名，尽量不要全部使用大写，尽量不要用“-”下划线开头 [rot@lwq ~]# ppp=1 [root@lwq ~]# echo $ppp 1 最好做到见名知义不能使用程序中的保留字，例如if,for等变量名区分大小写变量名中有多个单词时有两种方法表示 单词间使用下划线分隔 首单词小写，后面单词的首字母大写 teacherName=tom studentName=jerry teacher_name=tom student_name=jerry 变量作用：
保存表达式运算的结果至内存，方便复用或更改
若无变量而需复用表达式运算的结果只能重新运算，耗时较长
可以把变量理解为一个存储信息的容器
[root@lwq ~]# mkdir test;cd test;echo 'hello world' &gt; abc [root@lwq test]# ls abc [root@lwq test]# cat abc hello world [root@lwq ~]# a=$(pwd;ls) [root@lwq ~]# echo $a /root 2019.sh anaconda-ks.cfg 1.3变量类型 字符型数值型 整型 浮点型布尔型 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9c8aafb3e44ceb4b0b6a1b43cc04f55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17d59c2ee5779f5ff8690edfd467ccbb/" rel="bookmark">
			vector或数组求最大值、最小值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以用max_element（）及min_element（）函数，二者返回的都是迭代器或指针。
头文件：#include
1.求数组的最大值或最小值
1）vector容器
例 vector vec
最大值：int maxValue = *max_element(v.begin(),v.end());
最小值：int minValue = *min_element(v.begin(),v.end());
2）普通数组
例 a[]={1,2,3,4,5,6};
最大值：int maxValue = *max_element(a,a+6);
最小值：int minValue = *min_element(a,a+6);
2.求数组最大值最小值对应的下标
1）vector容器
例 vector vec
最大值下标：int maxPosition = max_element(v.begin(),v.end()) - v.begin();
最小值下标：int minPosition = min_element(v.begin(),v.end()) - v.begin();
2）普通数组
例 a[]={1,2,3,4,5,6};
最大值下标：int maxPosition = max_element(a,a+6) - a;
最小值下标：int minPosition = min_element(a,a+6) - a;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e73226e35ee74a893ab2e56124f318a5/" rel="bookmark">
			vim使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://www.xuebuyuan.com/1116162.html
https://blog.csdn.net/luojj26/article/details/50935921
https://blog.csdn.net/lhy2932226314/article/details/69668891#
set nu
"nu=number
set cul
"行亮 cuc 列
set tabstop=4 "tab
set shiftwidth=4 "换行宽度
set softtabstop=4 "删除
set mouse=a "鼠标
set smartindent "自动缩进
set expandtab "转变为空格
set autoindent "和上一行相同缩进
"im=inoremap
im ( ()i
im { {}iV&lt;O
"im { {}O
im [ []i
"括号
set whichwrap+=&lt;,&gt;,[,]
"跳转到上一行
map :call Bian()
map :call Yun()
map :call Tiao()
func! Bian()
exec “w”
exec “!g++ % -o %&lt;”
endfunc
func! Yun()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e73226e35ee74a893ab2e56124f318a5/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/105/">«</a>
	<span class="pagination__item pagination__item--current">106/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/107/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>