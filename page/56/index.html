<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6b8e767f788e940b12ad5992bf18d7e/" rel="bookmark">
			一张图带你了解Docker命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf1523d47283911ce3f5a0e4e9986d02/" rel="bookmark">
			基于活动轮廓算法的图像分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		活动轮廓算法 活动轮廓模型（也称为蛇模型）是一个框架，用于拟合开或闭合样条曲线与图像中的线或边缘。这里的“蛇”是一种受约束、图像和内力影响的能量最小、可变形的样条曲线。因此，它通过部分由图像定义，以及部分由样条的形状、长度和平滑度定义的最小化能量来工作。约束和图像外力将“蛇”拉向目标轮廓，内力则抵抗变形。该算法围绕感兴趣的目标初始化蛇，并让它收缩或膨胀，以便于使封闭的轮廓与感兴趣的目标相拟合。在图像能量和形状能量中显式地实现了最小值。由于点的数量是恒定的，因此需
要确保初始的“蛇”有足够的点来捕捉最终轮廓的细节。
源自 scikit-image 文档的如下例子中的活动轮廓模型将被用来通过在人脸边缘拟合样条曲线，将宇航员的脸与图像的其余部分分割开来。在预处理步骤对图像进行了一些平滑处理。在宇航员的面部周围初始化一个圆圈，并使用默认边界条件bc='periodic’来拟合闭合曲线。欲使曲线搜索到边缘（例如脸部的边界），需使用默认参数值 w_line=0, w_edge=1。如下代码演示了如何使用 active_contour()函数进行分割（函数运行一个迭代算法，其中迭代算法的最大迭代次数可以由函数的参数指定），并显示在不同的迭代次数（max_iteration）下，在内部运行算法得到的闭合轮廓线。
#活动轮廓算法、形态学蛇算法和基于 OpenCV 的GrabCut 图像分割算法 # step1 活动轮廓算法 from skimage import data from skimage.filters import gaussian from skimage.segmentation import active_contour img = data.astronaut() img_gray = rgb2gray(img) s = np.linspace(0, 2*np.pi, 400) x = 220 + 100*np.cos(s) y = 100 + 100*np.sin(s) init = np.array([x, y]).T i = 1 pylab.figure(figsize=(20,20)) for max_it in [20, 30, 50, 100]: snake = active_contour(gaussian(img_gray, 3), init, alpha=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf1523d47283911ce3f5a0e4e9986d02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a1cf68b47f8eadebbc17979583fb02f/" rel="bookmark">
			MYSQL--未提交(read uncommitted)、读已提交(read committed)和repeatable read(可重复读)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、read uncommitted(读未提交)--脏读(Dirty Read) 读未提交的概念：允许一个事务可以看到其他事务未提交的修改。 第一步，建account(账户)表，属性有id(编号)和balance(金额) 。
第二步：
（1）在原窗口调整隔离级别为read uncommitted。
（2）打开新窗口，调整隔离级别为read uncommitted（未提交读）。
第三步：
（1）原窗口开启事务。
（2）新窗口开启事务。
第四步：
（1）原窗口事务1查询account表。
（2）新窗口事务2更新1号账户的钱，将钱加200，更新到1200。
（3）在原窗口事务1验证，理论上read uncommitted(未提交读)模式下，虽然事务2未提交，但事务1可以读到事务1的更新值。结果验证如下，符合理论预期：
第五步：
（1）在窗口2中回滚：事务2的更新操作。
（2）在窗口1中重新查询account表，理论上在事务2回滚后，事务1中查询会得到事务2回滚后的表。
结果验证如下，符合结果预期：
二、read committed(读已提交) 读已提交的概念：允许一个事务只能看到其他事务已经提交的修改，未提交的修改是不可见的。 第一步：
在之前的基础上，将事务2改为read committed(读已提交)模式。
第二步：
（1）在事务1中，更新账户1，将钱减两百，得800。
理论上事务2此时，已经只能看到其他事务已经提交的修改，所有事务1的减操作，事务2看不到，所以在事务2中查询，账户1的钱仍然是1000。
（2）在事务2中验证如下，符合结果预期：事务2只能看到其他事务已提交的内容，事务1尚未提交，因此在事务2中的账户1的钱仍然是1000。
第三步：
（1）在事务1中提交之前的账户1更新操作。
理论上事务1提交操作后，事务2能看的到。所有再在事务2中查询，预期账户1的钱已变为800。
（2）在事务2中重新查询account表。
得到账户1的钱已经变为800，符合预期。
三、repeatable read(可重复读) 可重复读概念：确保如果在一个事务中执行两次相同的select语句，都能得到相同的结果，不管其他事务是否提交这些修改。 第一步：
（1）在之前的基础上，将事务2改为repeatable(可重复读)模式。
（2）在事务2中开启事务。
（3）在事务2中查询一次account表。
使用select * from account;
理论上事务2目前处于可重复读模式，无论其他事务怎么修改account表，后面再次执行该查询语句，结果应该和这次的一样。
（2）第二步：
（1）在事务1中插入账户3，初始的钱为1000。
（2）在事务1使用select * from account;
查询结果中出现了新增的账户记录。
第三步：
（1）返回事务2验证：
在事务2中使用select * from account;
事务2中的查询结果，没有事务1中新增的记录，成功验证：
在同一事务和可重复读模式下，无论其他事务怎么修改，原事务中执行相同的查询语句，前后结果相同。
第四步：
二道验证，看事务1是否将之前新的记录插成功：
在事务2中尝试插入账户3，钱为1000。
运行结果表示：id为3的插入冲突，说明id为3的账户记录已经存在，也就是事务1的插入成功。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a1cf68b47f8eadebbc17979583fb02f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3329ba80d5b6718dc4a07f865b0143aa/" rel="bookmark">
			c语言 指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 读我c语言 指针概念c语言 指针大小c语言 指针类型的意义c语言 int型指针c语言 char型指针c语言 void型指针c语言 数组指针c语言 指针数组c语言 数组传参（结合指针）实参（一维数组）---&gt; 形参（指针）实参（二维数组）---&gt; 形参（指针）实参（一级指针）---&gt; 形参（指针）实参（二级指针）---&gt; 形参（指针）实参（指针数组）---&gt; 形参（指针） c语言 函数指针c语言 函数指针 简介 简单运用c语言 用函数指针实现类似库函数qsort()的功能 c语言 函数指针数组c语言 指向函数指针数组的指针c语言 回调函数c语言 野指针c语言 指针的初始化c语言 面试题小练习：1c语言 面试题小练习：2c语言 面试题小练习：3c语言 面试题小练习：4c语言 面试题小练习：5c语言 指针精髓小题1c语言 指针精髓小题2c语言 指针精髓小题3c语言 指针精髓小题4c语言 指针精髓小题5 读我 这篇文章我很少修改，但是指针却又很牛逼，如文章中有哪些理解的不到位的地方，请留下宝贵的意见
c语言 面试前必备基础知识
c语言 指针概念 指针是个变量，存放的是地址
#include &lt;stdio.h&gt; int main() { int a = 10; // 在内存中开辟一块空间，存储10 int* p = &amp;a; // 取变量a的地址，可以使用&amp;操作符。 //将a的地址存放在p变量中，故p就是一个存放地址的变量。 return 0; } 解引用
#include &lt;stdio.h&gt; int main() { int a = 10; // 在内存中开辟一块空间，存储10 int* p = &amp;a; // 取变量a的地址，可以使用&amp;操作符。 // 因为p里面存储的是a的地址，要输出a的值，故要解引用，即加* printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3329ba80d5b6718dc4a07f865b0143aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3acf1ecb4f5ea1681d3a749ab61d3e63/" rel="bookmark">
			基于图像分割与颜色量化的 k 均值聚类算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于图像分割与颜色量化的 k 均值聚类算法 将演示如何对 Astronaut图像执行像素矢量量化（Vector Quantization，VQ），将显示图像所需的颜色数量从 250 种减少到 4 种，同时保持整体外观质量。在本例中，像素在三维空间中表示，使用 k 均值查找 4 个颜色簇。在图像处理文献中，码本是从 k 均值（簇群中心）获得的，称为调色板。在调色板中，使用 1 个字节最多可寻址 256 种颜色，而 RGB 编码要求每个像素 3 个字节。GIF 文件格式使用的就是这样的调色板。为了进行比较，我们还将使用随机码本（随机选取颜色）的量化图像。在使用 k 均值聚类算法对图像进行分割前，加载所需的库和输入图像，如下面的代码所示：
#Kmens 图像分割颜色聚类 import numpy as np import matplotlib.pyplot as plt from sklearn.cluster import KMeans from sklearn.metrics import pairwise_distances_argmin from skimage.io import imread from sklearn.utils import shuffle from skimage import img_as_float from time import time pepper = data.astronaut() # Display the original image plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3acf1ecb4f5ea1681d3a749ab61d3e63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ff1014ae860950fffa250141c8cf1cb/" rel="bookmark">
			监督机器学习——基于手写数字数据集的图像分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		监督机器学习——基于手写数字数据集的图像分类 MNIST手写数据集介绍 输入数据集是 MNIST，这是机器学习中的一个经典数据集，由大小为 28×28 的手写数字的灰度图像组成。原始训练数据集包含 60000 个样本（手写数字图像和标签，用于训练机器学习模型），测试数据集包含 10000 个样本（手写数字图像和标签作为基本真值，用于测试所学习模型的准确性）。给定一组手写数字和图像及其标签（0～9），目标是学习一种机器学习模型，该模型可以自动识别不可见图像中的数字，并为图像分配一个标签0～9）。具体步骤如下。
（1）使用训练数据集训练一些监督机器学习（多类分类）模型（分类器）。
（2）它们将用于预测来自测试数据集的图像的标签。
（3）将预测的标签与基本真值标签进行比较，以评估分类器的性能。
训练、预测和评估基本分类模型的步骤如下图所示。当在训练数据集上训练更多不同的模型（可能是使用不同的算法，或者使用相同的算法但算法具有不同的超参数值）时，为了选择最好的模型，需要第三个数据集，也就是验证数据集（训练数据集分为两部分，一部分用于训练，另一部分用于验证），用于模型选择和超参调优。
同样，先导入所需的库，如下面的代码所示：
import matplotlib from sklearn.naive_bayes import MultinomialNB import pandas as pd import seaborn as sn from sklearn import metrics from sklearn.ensemble import RandomForestClassifier from sklearn.svm import SVC import time from sklearn.neighbors import BallTree import gzip, os, sys import numpy as np import urllib.request as ureq from scipy.stats import multivariate_normal from keras.datasets import mnist from keras.utils import to_categorical from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ff1014ae860950fffa250141c8cf1cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b3cb4e37149a8b8fc1a0a9b301ca631/" rel="bookmark">
			Ajax异步、同步问题——Ajax和JavaScript执行顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第零章 准备工作 Ajax根据async进行区分同步和异步过程，当async=true异步，async=false为同步，ajax默认async为异步。
异步：Ajax不会影响整个页面的加载，相当于和浏览器加载或者用户操作分开走，互不相干，体现在用户角度就是不会有什么卡顿的感觉仿佛无事发生。
同步：那就与异步相反，Ajax和js加载处于同一条线上，就是在加载Ajax的时候，全部的过程都等停下来，也就是假死状态。
测试代码
index.jsp
&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;index&lt;/title&gt; &lt;script src="js/jquery-3.6.1.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; function f() { let inputData = $("#inputData").val(); let v; $.ajax({ url: "/TestServlet", data: {"inputData": inputData}, success: function (data) { v = data; alert("Ajax:" + v); } }); alert("f():" + v); } &lt;/script&gt; &lt;label for="inputData"&gt;&lt;/label&gt;&lt;input type="text" id="inputData" οnblur="f()"&gt; &lt;/body&gt; &lt;/html&gt; TestServlet.java
import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b3cb4e37149a8b8fc1a0a9b301ca631/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c23884d827b473ac59e5241e5925a9e4/" rel="bookmark">
			python 使用接缝雕刻移除目标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以使用接缝雕刻从图像中去除目标或人工痕迹。这就需要用较低的值
对目标区域进行加权，因为在接缝雕刻中较低的权重被优先删除。如下代码使用了与原始输入照片形状相同的掩模图像，掩盖了包含低权重的狗图像的区域，这表明应该将其移除.
import pylab from skimage.io import imread from skimage.color import rgb2gray from skimage import transform, util, filters, color import cv2 from PIL import Image image = cv2.imread('./9781789343731_Code/images/man2.png')[:,:,::-1] mask_image = rgb2gray(imread('./9781789343731_Code/images/man_mask.png')) print(image.shape) print(mask_image.shape) pylab.figure(figsize=(15, 10)) pylab.subplot(121), pylab.imshow(image), pylab.title('Original image'),pylab.axis('off') # pylab.subplot(122), pylab.imshow(mask_image), pylab.title('Mask image') # pylab.axis('off') # pylab.show() # pylab.figure(figsize=(15, 12)) pylab.subplot(122) pylab.title('Object remove(dog)') out = transform.seam_carve(image, mask_image, 'vertical', 90) # resized = transform.resize(out, image.shape, mode='reflect') # out = transform.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c23884d827b473ac59e5241e5925a9e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bac35cc26576e15e726863a5143db386/" rel="bookmark">
			简述http和https区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http协议和https协议的区别主要是：传输信息安全性不同、连接方式不同、端口不同、证书申请方式不同
一、传输信息安全性不同 http协议：是超文本传输协议，信息是明文传输。如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息。https协议：是具有安全性的ssl加密传输协议，为浏览器和服务器之间的通信加密，确保数据传输的安全。 二、连接方式不同 http协议：http的连接很简单，是无状态的。https协议：是由SSL＋HTTP协议构建的可进行加密传输、身份认证的网络协议。 三、端口不同 http协议：使用的端口是80。https协议：使用的端口是443． 四、证书申请方式不同 http协议：免费申请。https协议：需要到ca申请证书，一般免费证书很少，需要交费。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fbe70b4311f7ab8d64e7a18923fc734/" rel="bookmark">
			Java中 实体类（Entity，VO，DTO）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Entity Entity（PO）　每个属性基本上都对应数据库表里面的某个字段。完全是一个符合Java Bean规范的纯Java对象，没有增加别的属性和方法。持久对象是由insert数据库创建，由数据库delete删除的。基本上持久对象生命周期和数据库密切相关。
二、VO 这个有两种理解，在我接触的项目中更加偏向 第二种 表现层对象(View Object)
VO：值对象(Value Object)，通常用于业务层之间的数据传递，和Entity一样也是仅仅包含数据而已。但应是抽象出的业务对象，可以和表对应，也可以不，这根据业务的需要。
VO：表现层对象(View Object)，主要对应展示界面显示的数据对象，用一个VO对象来封装整个界面展示所需要的对象数据。
三、DTO DTO：数据传输对象(Data Transfer Object)，是一种设计模式之间传输数据的软件应用系统。数据传输目标往往是数据访问对象从数据库中检索数据。数据传输对象与数据交互对象或数据访问对象之间的差异是一个以不具有任何行为除了存储和检索的数据（访问和存取器）。简单来说，当我们需要一个对象10个字段的内容，但这个对象总共有20个字段，我们不需要把整个PO对象全部字段传输到客户端，而是可以用DTO重新封装，传递到客户端。此时，如果这个对象用来对应界面的展现，就叫VO。
说白了，就是对Entity 的一个映射，减少数据的请求之类的数据字段的个数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37b6d6348bc6298073d33a60126df616/" rel="bookmark">
			redis五种数据类型对应的底层数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis五种数据类型对应的底层数据结构 redis的五种数据类型redis核心对象redisObjecttype数据类型encoding编码类型ptr指针 redis五种数据类型对应的底层数据结构String字符串类型SDS hash哈希类型ziplist压缩列表hashtable哈希表 list列表类型ziplist压缩列表linkedlist、quicklist set集合类型intset整数集合hashtable哈希表 zset有序集合类型ziplist压缩列表skiplist跳跃表 redis是一种非关系型key-value内存数据库。 redis的五种数据类型 字符串：string；
哈希（也叫哈希表、字典，下文中统一称为哈希。）：hash；
列表：list；
集合：set；
有序集合：sorted set。
这里的数据类型是针对于value来说的，key全是字符串类型。
redis的这些数据类型在底层都是使用核心对象redisObject表示的。
redis核心对象redisObject redisObject对象有以下属性：
type、encoding、ptr、其它信息。
type数据类型 对应的是value五种数据类型。
字符串：REDIS_STRING；
哈希：REDIS_HASH；
列表：REDIS_LIST；
集合：REDIS_SET；
有序集合：REDIS_ZSET。
encoding编码类型 表示的value保存的编码。
要注意type和encoding不是一一对应的，是组合！
ptr指针 指向了实际保存value的数据结构。
redis五种数据类型对应的底层数据结构 String字符串类型 String类型的编码方式，即encoding有三种：int、embstr、raw。
value的值是整数，encoding为int，没有对应底层数据结构；
value长度小于32，encoding为embstr，长度大于，32编码为raw，embstr和raw都使用SDS数据结构存储。
SDS SDS是简单动态字符串simple dynamic string的缩写。
SDS有三个属性：
struct sdshdr{ int len; // 字符串长度 int free; // 未使用的字节长度 char buf[]; // 保存字符串的字节数组 } c语言中的结构体struct，类似Java中的类class。
redis是c语言实现的，
c语言中的字符串类型不会记录自身长度，获取长度要通过遍历得到，时间复杂度是O(n)，需要n次，（最多）
SDS只需读取len属性，时间复杂度是O(1)，也就是最多1次；
SDS在修改前会根据free属性判断空间是否满足，不满足就会扩容，避免内存溢出；
SDS提供’空间预分配’和’惰性空间释放’两种策略，在分配空间时，分配的空间比实际需要的多，
避免频繁增加字符串长度导致多次扩容带来的成本升高，
当字符串收缩的时候，不会立即回收不使用的空间，等以后使用时释放。
hash哈希类型 哈希类型的编码方式有ziplist、ht两种，分别对应ziplist和hashtable两种底层数据结构，
当哈希对象的键值对数量小于512，并且所有键值对的长度都小于64字节时，使用压缩列表ziplist，否则使用hashtable。
ziplist压缩列表 压缩列表并不是说以某种算法压缩存储数据，它是一组连续的内存块，能够节省空间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37b6d6348bc6298073d33a60126df616/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21aafab5a9944279dea0c624b38ff6b1/" rel="bookmark">
			SLAM十四讲中Sophus库的make报错 lvalue required as left operand of assignment unit_complex_.real()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近开始学习高翔博士的《视觉SLAM十四讲》，第四章要求安装一个非模板类的Sophus库。在安装书中提供的第三方库时出现错误。在安装过程中，使用Cmake ..的时候能够顺利通过，接着执行make命令的时候就会出现错误如下：
***1. Sophus/sophus/so2.cpp:33:26:error: lvalue required as left operand of assignment
unit_complex_.real() = 1.;
2. Sophus/sophus/so2.cpp:33:26:error: lvalue required as left operand of assignment
unit_complex_.imag() = 1.;*
我以为是书中提供的第三方库存在问题，于是按照书中的方法在网上重新下载Sophus库，编译之后仍旧出现这种错误。
自己在网上查找了好久很少有人提出解决这个问题的方法。最终幸运的在一篇博客中找到了解决的方法。鉴于网上的解决方法少，故分享如下。
解决方法如下：
1 SO2::SO2()
2 {
3 //unit_complex_.real() = 1.;
4 //unit_complex_.imag() = 0.;
5 unit_complex_.real(1.);
6 unit_complex_.imag(0.);
7 }
我的小程序： 待办计划：给自己立个小目标吧！ ---------------------
作者：江上雨
来源：CSDN
原文：https://blog.csdn.net/qq_40641575/article/details/81006349
版权声明：本文为博主原创文章，转载请附上博文链接！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e529514ca6743ad1004b0f18b957cec/" rel="bookmark">
			数据结构 有理数实现加减乘除运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当然，下面的代码包括了加减乘除以及分数的化简的函数，但是无法输入0，还请各位大神多多斧正
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
//有理数数据类型定义 typedef struct {
int fenzi;
int fenmu; } *ration,ration1;
//函数声明 void mul(ration num1,ration num2);//执行乘法函数并输出结果
void div(ration num1,ration num2);//执行除法函数并输出结果
void add(ration num1,ration num2);//执行加法函数并输出结果
void sep(ration num1,ration num2);//执行减法函数并输出结果 void clean(int num1,int num2);//化简分数的函数
void clean(int num1,int num2)
{
int flag = 0;
//判断两数是否发生交换
int temp;
if(num1 &lt; num2) {
temp = num1;
num1 = num2;
num2 = temp;
flag = 1;
}
int i = num2;//寻找最大公因数 while(i &gt;= 1)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e529514ca6743ad1004b0f18b957cec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67c35e10cd9487a56f68938ddf82763a/" rel="bookmark">
			测试平台(四) 数据库的连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.修改django 配置文件 1）修改settings文件 将 DATABASES 改成自己的mysql连接
2） 在myapp下的__init__.py文件中增加如下代码，来改变django操作数据库
import pymysql pymysql.install_as_MySQLdb() 3) 在myapp/models.py 文件中增加数据库模型文件
from django.db import models # Create your models here. #创建一个用户表 class user(models.Model): id = models.AutoField('编号',primary_key=True) user_account = models.CharField('用户名',max_length=32,null=False) user_password = models.CharField('用户密码', max_length=32, null=False) createTime = models.CharField('创建时间',db_column='create_time',max_length=19) class Meta: db_table = 'user' 然后使用终端执行： python3 manage.py makemigrations 将会在myapp/migrations目录下生成0001_initial.py文件，并提示 Create model user . 紧接着 我们执行 python3 manage.py migrate
此时就会将模型的数据表迁移到数据库服务器上。
4.增加或者删除字段， 直接在models文件中 增加或者修改字段。然后重复执行python3 manage.py makemigrations和 python3 manage.py migrate 即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38ea027530ccefcf495296e09dec420a/" rel="bookmark">
			精确率/召回率/准确率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TP: Ture Positive 把正的判断为正的数目 True Positive,判断正确，且判为了正，即正的预测为正的。
FN: False Negative 把正的错判为负的数目 False Negative,判断错误，且判为了负，即把正的判为了负的
FP: False Positive 把负的错判为正的数目 False Positive, 判断错误，且判为了正，即把负的判为了正的
TN: True Negative 把负的判为负的数目 True Negative,判断正确，且判为了负，即把负的判为了负的
1. 精确率(Precision)
精确率是相对于预测结果而言的，它表示的是预测为正的样本中有多少是对的；那么预测为正的样本就有两种可能来源，一种是把正的预测为正的，这类有TruePositive个, 另外一种是把负的错判为正的，这类有FalsePositive个，因此精确率即：P=TP/(TP+FP)
2. 准确率 (Accuracy)
准确率是指有在所有的判断中有多少判断正确的，即把正的判断为正的，还有把负的判断为负的；总共有 TP + FN + FP + TN 个，所以准确率：(TP+TN) / (TP+TN+FN+FP)
3. 召回率 (Recall)
召回率是相对于样本而言的，即样本中有多少正样本被预测正确了，这样的有TP个，所有的正样本有两个去向，一个是被判为正的，另一个是错判为负的，因此总共有TP+FN个，所以，召回率 R= TP / (TP+FN)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b426e90ce7e556ccb51140267b2d3704/" rel="bookmark">
			计算机视觉之PCA和特征脸
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机视觉之PCA和特征脸 主成分分析(PCA）是一种统计/非监督机器学习方法，它使用一个正交变换将一组可能相关的变量的观测值转化为一组线性不相关的变量的值（称为主成分），从而在数据集中发现最大方向的方差（沿着主成分）。这可以用于（线性）降维（只有几个突出的主成分在大多数情况下捕获数据集中的几乎所有方差）和具有多个维度的数据集的可视化（在二维空间中）。PCA 的一个应用是特征脸，找到一组可以（从理论上）表示任意脸（作为这些特征脸的线性组合）的特征脸。
1.用 PCA 降维及可视化 我们将使用 scikit-learn 的数字数据集，其中包含 1797 张手写数字图像（每张图像大小为 8×8）。每一行表示数据矩阵中的一幅图像。用下面的代码加载并显示数据集中的前 25 位数字：
import numpy as np import matplotlib.pylab as plt from matplotlib import pylab from sklearn.datasets import load_digits from sklearn.preprocessing import StandardScaler from sklearn.decomposition import PCA from sklearn.pipeline import Pipeline digits = load_digits() #print(digits.keys()) print(digits.data.shape) j = 1 np.random.seed(2) fig = plt.figure(figsize=(3,3)) fig.subplots_adjust(left=0, right=1, bottom=0, top=1, hspace=0.05,wspace=0.05) #从数组中随机抽取元素 for i in np.random.choice(digits.data.shape[0], 25): plt.subplot(5,5,j), plt.imshow(np.reshape(digits.data[i,:], (8,8)),cmap='binary'), plt.axis('off') j += 1 plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b426e90ce7e556ccb51140267b2d3704/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d106de81aec0a1dbf0b0ca82c4feab3/" rel="bookmark">
			如何解决批量上传太多文件导致浏览器挂掉的问题(已解决)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、bug场景描述 今天分到一个bug，场景是这样的，项目中有一个上传文件夹的功能，使用了foreach循环请求接口上传文件，但是如果选择文件夹中图片太多，相当于浏览器在超短时间内发送极多的网络请求（循环速度很快），导致浏览器卡死。
// 上传文件夹 handleUploadFiles() { // 循环上传文件列表 this.fileList.forEach((item,index) =&gt; { // 发送网络请求 this.axios.post(this.api.uploadBatch, formData).then(res =&gt; { if(res.data.code == 2000){ console.log("上传成功"); // 业务逻辑代码...... } }) }) } 2、解决思路 我决定让请求同步发送，也就是第一条发送完成之后在发送第二条，话不多说直接上代码。
// 上传文件夹 handleUploadFiles() { // 下标归0 this.num = 0 let that = this // 上传文件总数 this.uploadFilesLength = this.fileList.length // 上传函数 num变量充当下标，初始值为0 function uploadFun() { // 转换formdata格式 let formData = new FormData() formData.append("file", that.fileList[that.num]); // 根据num上传 // 发送网络请求 that.axios.post(that.api.uploadBatch, formData).then(res =&gt; { if(res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d106de81aec0a1dbf0b0ca82c4feab3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5ffc79f7bec3f936e300a34aa08b0fb/" rel="bookmark">
			算法 - 归并排序（Merge_sort）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是归并排序(Merging_sort)？
归并排序的适用场景：
演示归并排序的过程(默认arr和brr两个数组都是有序的)：
代码实现：
如果我们事先并没有分配好两个已经排序好的数组，而是直接的一个无序序列呢？
代码实现：
什么是归并排序(Merging_sort)？ 在写归并排序的代码之前，我们先对归并排序的定义和排序原理进行梳理。
在严蔚敏的《数据结构（C语言版）》一书中对归并排序是这样定义的：
归并排序（Merging_Sort）是一类不同的排序方法。“归并”的含义是将两个或者两个以上的有序表组合成一个新的有序表。利用归并的思想容易实现排序，且这种实现方法已为读者熟悉，无论是顺序存储结构还是链表存储结构，都可以在O（m+n）的时间量级上实现。归并排序也是一个与插入排序、交换排序、选择排序不同的一类排序方法。
归并排序是一个基于分治法思想的算法，拿两个已经有序的序列重新组合成一个有序的序列。
归并排序的适用场景： 归并排序适合链表排序但不适合数组排序，归并在外部排序，比如磁盘文件的情况下比快速排序好，因为快排比较依赖数据的随机存取，而归并是顺序存取，对磁盘这种外村比较友好，还有很重要的一点就是快速排序和对排序都是不稳定排序，归并排序是稳定排序。
演示归并排序的过程(默认arr和brr两个数组都是有序的)： 例如我在这里给出两个数组：
int arr[] = {1,3,5,7}; int brr[] = {2,4,6,8}; 我们定义两个指针i和j分别指向arr数组和brr数组，在定义一个临时值temp，通过遍历这两个数组，每一次的遍历我们都对i和j所指向的值进行比较，找到两个数中较小的值放入临时值temp中，并拷贝一份放入到新的数组中，直到排序完成：
当我们的i遍历至元素1，j遍历至元素2时，i是小于j的，于是我们将i所指向的元素赋值给temp并放入到新的数组中，令i指针向前迁移一位进行下一次i和j的比较：
此时继续i和j指向元素的比较，我们发现，元素2小于3，这时我们将元素2赋值给temp并放入新数组中，并令j指针的位置加1:
此时继续进行比较，我们发现3 &lt; 4，现在将元素3赋值给temp，放入至新数组中，所对应i指针的位置向后迁移一位：
过程以此类推：
比较4和5:
比较5和6:
比较6和7:
比较7和8:
最后我们直接将元素8放至新数组的末尾：
同样的，如果我们的第二个数组的后面又加上9和10，我们在第一个数组已经遍历完了的情况下，直接将9和10安插在新数组的后面。
代码实现： #include&lt;stdio.h&gt; #include&lt;assert.h&gt; #include&lt;iostream&gt; void showar(int *ar,int len) { assert(ar != nullptr); for(int i = 0;i &lt; len;i++){ printf("%d ",ar[i]); } printf("\n--------------------------\n"); } void Merging_sort1(int *ar,int len1,int *br,int len2,int *temp) { assert(ar !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5ffc79f7bec3f936e300a34aa08b0fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db14bd8b3076b8d60803be7cea2a8e3b/" rel="bookmark">
			python split 函数方法，字符串分割，分割中间，分割左右，分割次数。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		split() 方法格式如下： str = 'www.baidu.com' list = str.split(sep='.',maxsplit=-1) print(list) 参数说明： str：表示为要分割的字符串。
sep：用于指定的分割符，可以包含多个字符，默认为None，即包含所有的空字符（即空格符，换行符 \n，制表符 \t 等）
maxsplit：可选参数，用于指定分割次数，如果不指定，默认为 -1，则分割次数没有限制。
list：为返回值，返回一个 列表。
返回内容： ['www', 'baidu', 'com'] 简写： str = 'www.baidu.com' list = str.split('.',1) print(list) 分割中间： str = 'www.baidu.com' list = str.split('.')[1].split('.')[0] print(list) # 输出 baidu 分割左边： str = 'www.baidu.com' list = str.split('baidu')[0] print(list) # 输出 www. 分割右边： str = 'www.baidu.com' list = str.split('baidu')[1] print(list) # 输出 .com 注 ： 这里分割中间，左边，右边，用到了列表分割形式，所以返回的内容，是字符串，而不在是列表。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c7a942c0e4b7e2ad5e74a16f57b1864/" rel="bookmark">
			scikit-learn机器学习终结，拿走不谢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#导入需要的库
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction import DictVectorizer
from sklearn.preprocessing import MinMaxScaler,StandardScaler
from sklearn.feature_selection import VarianceThreshold
from sklearn.model_selection import GridSearchCV
from sklearn.neighbors import KNeighborsClassifier
from sklearn.naive_bayes import MultinomialNB
from sklearn.tree import DecisionTreeClassifier,export_graphviz
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC, NuSVC, LinearSVC
from sklearn.datasets import fetch_20newsgroups,load_boston
from sklearn.metrics import ConfusionMatrixDisplay,accuracy_score,roc_curve, auc,mean_squared_error,silhouette_score
from sklearn.multiclass import OneVsRestClassifier
from sklearn.linear_model import LinearRegression,SGDRegressor,Ridge,RidgeCV,LogisticRegression
from sklearn.neural_network import MLPRegressor,MLPClassifier
from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c7a942c0e4b7e2ad5e74a16f57b1864/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/55/">«</a>
	<span class="pagination__item pagination__item--current">56/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/57/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>