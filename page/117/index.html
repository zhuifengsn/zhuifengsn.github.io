<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa20fb75acc5940a1bd7afa8909e556b/" rel="bookmark">
			c语言数据结构之顺序线性表的合并、并集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//#include "list_test.c" //#include "link_list_test.c" #include "List.h" #include "LinkList.h" #include "utils.c" void MergeList(const List * l1,const List * l2,List * l3); void list_union(List * l1,List * l2,List * l3); void print(int data); int main() { // list_test(); // link_list_test(); List l1,l2,l3; InitList(&amp;l1); InitList(&amp;l2); InitList(&amp;l3); insert(&amp;l1,3); insert(&amp;l1,5); insert(&amp;l1,8); insert(&amp;l1,11); ListTraverse(&amp;l1,print); printf("\n"); insert(&amp;l2,2); insert(&amp;l2,6); insert(&amp;l2,8); insert(&amp;l2,9); insert(&amp;l2,11); insert(&amp;l2,15); insert(&amp;l2,20); ListTraverse(&amp;l2,print); printf("\n"); MergeList(&amp;l1,&amp;l2,&amp;l3); ListTraverse(&amp;l3,print); printf("\n"); DestroyList(&amp;l3); InitList(&amp;l3); list_union(&amp;l1,&amp;l2,&amp;l3); ListTraverse(&amp;l3,print); printf("\n"); return 0; } void print(int data) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa20fb75acc5940a1bd7afa8909e556b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58d460ace5b4f8ed8382af5a557b8ccf/" rel="bookmark">
			c语言数据结构之实现一元多项式的加减运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现结构：单项链表
思路：对于两个一元多项式中所有指数相同的项，对应系数相加，若其和不为零，则构成“和多项式”中的一项；对于两个一元多项式中所有指数不相同的项，则分别复抄到“和多项式”中去，减法亦然。
main.c
#include &lt;stdio.h&gt; #include &lt;malloc.h&gt; #include "poly.h" #include "lArray.h" void printInfo(); void eatline(); void choose_option(); void poly_exp_add(polyLinkList *ptr); void poly_exp_view(polyLinkList *ptr); void poly_exp_del(polyLinkList *ptr); void poly_addition(polyLinkList *ptr); void poly_sub(polyLinkList *ptr); int main() { printInfo(); choose_option(); return 0; } void printInfo() { printf("一元多项式的运算-----------------------\n"); printf("0.添加一元表达式.\n"); printf("1.查看表达式列表.\n"); printf("2.删除一个表达式.\n"); printf("3.一元多项式的加法.\n"); printf("4.一元多项式的减法.\n"); printf("6.退出.\n"); printf("-------------------------------------\n"); } void choose_option() { polyLinkList Poly_Link_List; initPolyLinkList(&amp;Poly_Link_List); int d; do{ scanf("%d",&amp;d); eatline(); switch(d) { case 0://添加一元表达式 poly_exp_add(&amp;Poly_Link_List); break; case 1://查看表达式列表 poly_exp_view(&amp;Poly_Link_List); break; case 2://删除一个表达式 poly_exp_del(&amp;Poly_Link_List); break; case 3://一元多项式的加法 poly_addition(&amp;Poly_Link_List); break; case 4://一元多项式的减法 poly_sub(&amp;Poly_Link_List); break; case 6://退出 break; default: break; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58d460ace5b4f8ed8382af5a557b8ccf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c16f08a21dcb142e6bbf6e458d6b0ed0/" rel="bookmark">
			Python中escape和unescape
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Python中escape和unescape Python处理HTML转义字符
在抓网页数据经常遇到例如&amp;gt;或者&amp;nbsp;这种HTML转义符，抓到字符串里很是烦人。
比方说一个从网页中抓到的字符串
p ='&amp;lt;abc&amp;gt;'
用Python可以这样处理：
import html p = '&amp;lt;abc&amp;gt;' txt= html.unescape(p) print (txt) #这样就得到了txt= '&lt;abc&gt;'
如果还想转回去，可以这样：
import cgi q = cgi.escape(html) print(q) #这样又回到了 html = '&amp;lt;abc&amp;gt'
posted on 2018-01-28 16:42 Magic_chao 阅读(...) 评论(...) 编辑 收藏 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a9e1c744c978efee5b3f36d2e795a05/" rel="bookmark">
			R语言学习笔记：参数点估计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.点估计
点估计主要有两种方法，分别是矩估计和极大似然估计，具体原理可参考统计学教材。
矩估计需要解n元方程，在R语言中有：
解一次方程：uniroot(),调用格式为;
uniroot(f,interval,...,lower = min(interval), upper = max(interval), f.lower = f(lower,...),f.upper = f(upper,...), tol = .Machine$double.eps^0.25, maxiter = 1000) f指定求解方程的函数；interval为数值向量，指定求解的根的区间，可以用lower,upper分别指定端点；tol表示精度（tolerance），收敛容忍度；maxiter为最大迭代数
解多元方程：multiroot(),调用格式
multiroot(f,start,maxiter=100,rtol=1e-6,atol=1e-8,ctol=1e-8,useFortran = TRUE,...) f指定求解的函数；start给定根的初始值；maxiter指定最大迭代数；rtol和atol为相对误差和绝对误差；ctol用于控制迭代停止，如果两次迭代的最大变化值小于ctol，则停止迭代
最大似然估计：maxLik（）：maxLik包，调用格式：
maxLik(logLik,grad=NULL,hess=NULL,start,method,contraints=NULL,...) logLik是对数似然函数；grad和hess设置对数似然函数的梯度；start是数值向量，设置参数的初始值；method选择求解最大化的方法；constraints指定对数似然估计的约束。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b40b151cde05fbdb2f6b2ff2dfcacfe/" rel="bookmark">
			iOS模拟低速网络工具Network Link Conditioner的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发IOS应用的时候，经常会出现低速网络状况下会出现很多莫名其妙的bug，比如登录不成功，游戏经常丢包，无反应之类。如果只是Http请求，可以使用Fiddler或者Charles等工具模拟，但是如何除了http请求，还有socket长连接，这些工具就帮不上忙了。我们可以使用使用Network Link Conditioner工具可以帮助我们模拟各种速度的网络，进行低速网络测试。
1.首先打开iOS开发者选项
可以参考iOS开发者选项
打开后可以在设置中找到iOS开发者选项
2.进入开发者选项，选择Network Link Conditioner
3.打开Enable，选择对应的手机速率。
3G：3G网络
DSL：ADSL
Edge:2G
LTE:4G
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc07dc38bd925a9134ef0df3fe2ad59b/" rel="bookmark">
			服务器常用端口及应用程序端口作用介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代理服务器常用以下端口：
（1）HTTP协议代理服务器常用端口号：80/8080/3128/8081/9080
（2）SOCKS代理协议服务器常用端口号：1080
（3）FTP（文件传输）协议代理服务器常用端口号：21
（4）Telnet（远程登录）协议代理服务器常用端口：23
HTTP服务器，默认的端口号为80/tcp（木马Executor开放此端口）；
HTTPS（securely transferring web pages）服务器，默认的端口号为443/tcp 443/udp；
Telnet（不安全的文本传送），默认端口号为23/tcp（木马Tiny Telnet Server所开放的端口）；
FTP，默认的端口号为21/tcp（木马Doly Trojan、Fore、Invisible FTP、WebEx、WinCrash和Blade Runner所开放的端口）；
TFTP（Trivial File Transfer Protocol ），默认的端口号为69/udp；
SSH（安全登录）、SCP（文件传输）、端口重定向，默认的端口号为22/tcp；
SMTP Simple Mail Transfer Protocol (E-mail)，默认的端口号为25/tcp（木马Antigen、Email Password Sender、Haebu Coceda、Shtrilitz Stealth、WinPC、WinSpy都开放这个端口）；
POP3 Post Office Protocol (E-mail) ，默认的端口号为110/tcp；
WebLogic，默认的端口号为7001；
WebSphere应用程序，默认的端口号为9080；
WebSphere管理工具，默认的端口号为9090；
JBOSS，默认的端口号为8080；
TOMCAT，默认的端口号为8080；
WIN2003远程登陆，默认的端口号为3389；
Symantec AV/Filter for MSE ,默认端口号为 8081；
Oracle 数据库，默认的端口号为1521；
ORACLE EMCTL，默认的端口号为1158；
Oracle XDB（ XML 数据库），默认的端口号为8080；
Oracle XDB FTP服务，默认的端口号为2100；
MS SQL*SERVER数据库server，默认的端口号为1433/tcp 1433/udp；
MS SQL*SERVER数据库monitor，默认的端口号为1434/tcp 1434/udp；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc07dc38bd925a9134ef0df3fe2ad59b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/776385cf2bfbe9b5d9b02caad908516c/" rel="bookmark">
			Android自定义半圆进度条  半圆渐变色进度条带指示  半圆开口大小可自由修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android自定义半圆进度条 半圆渐变色进度条带指示 半圆开口大小可自由修改
首先我们来看下效果图
不同的开口大小只需要修改一个参数即可
半圆1：
半圆2：
半圆3：
如果是你想要的效果，就直接滑动到文章底部，下载源码，然后结合本文章操作说明集成到自己的项目中吧
如果集成
第一步：
下载项目解压，然后用as打开。
第二步：
复制SemicircleProgressBar这个类到自己的项目中
第三步：
在需要显示的布局中，直接使用自定义控件，如下：
&lt;com.ecaray.semicircleprogressbar.SemicircleProgressBar android:id="@+id/progressbar" android:layout_width="match_parent" android:layout_height="200dp" android:layout_centerInParent="true" android:background="@color/white" /&gt; 具体操作见下图，复制自定义控件的完整路径，然后在xml布局文件中直接引用
第四步：在对应布局的类里面，声明控件，然后给控件通过setProgress方法，设置进度即可
package com.ecaray.semicircleprogressbar; import android.os.Bundle; import android.support.v7.app.AppCompatActivity; import android.view.View; import android.widget.Button; import android.widget.TextView; /** * 类描述: 自定义半圆进度条 * 创建人: 简雨山舍 * 创建时间: 2018/1/8 11:58 * 修改人: 简雨山舍 * 修改时间: 2018/1/8 11:58 */ public class MainActivity extends AppCompatActivity { SemicircleProgressBar percentView;//自定义控件声明 TextView tvProgress;//显示进度的文本 Button btAdd;//加按钮 Button btSubstract;//减按钮 private int progress = 80;//初始进度 @Override protected void onCreate(Bundle savedInstanceState) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/776385cf2bfbe9b5d9b02caad908516c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ee0930a94f88fcfdd8d89ae44d8f1cd/" rel="bookmark">
			1.2MySQL-InnoDB-READ COMMITTED（读已提交）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.设置为读已提交
SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;
2.此时TA执行插入，并查询，可以查询到结果
3.TB不能查到结果
证明已经不能读到未提交的数据
但是仍然存在不可重复读问题 （同一事务内两次读的数据不一致）
4.为了演示效果，把用户数据插入数据库并提交，此时表中有一条id为1的 name为aaa的记录
TB开启一个事务 并进行查询
5.此时TA进行数据修改，并提交
6.B再次查询可以看到A事务已经提交的结果
根据测试可以发现，先开启的事务TA在事务TB提交之前进行的查询和TB提交之后进行的第二次查询，两次查询结果不一致，出现不可重复读情况。
如果要避免不可重复读，至少要把事务隔离级别设为：1.3 MySQL-InnoDB-REPEATABLE READ（可重复读）
InnoDB采用了MVCC(Multiversion Concurrency Control)多版本并发控制，避免不可重复读。MVCC只在 READ COMMITTED 和 REPEATABLE READ 2个隔离级别下工作。MVCC会建立多个ReadView，RC是语句级多版本(事务的多条只读语句，创建不同的ReadView，代价更高)，RR是事务级多版本(一个事务有一个ReadView)。由于RC中未提交的事务，不允许其他事务看到，但是本身事务需要看到，所以执行多条语句时，都需要建立新的ReadView，以支持本事务后面的查询。
注：
MVCC本意应该是下面的样子：
每行数据都存在一个版本，每次数据更新时都更新该版本
修改时Copy出当前版本随意修改（类似于Java并发包中的CopyOnWrie操作），各个事务之间无干扰
保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）
但是InnoDB的实现有一些差别：
事务以排他锁的形式修改原始数据
把修改前的数据存放于Undo log，通过回滚指针与主数据关联
修改成功（commit）啥都不做，失败则恢复Undo log中的数据（rollback）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c70abefd7266c4dd677e88f618b919ba/" rel="bookmark">
			基于状态机的按键检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于状态机的按键检测 一般在学单片机的时候，最基础的一个内容就是学习按键的输入扫描，最简单的方式当然是读IO电平然后再加上一段延时做消抖。今天要分享的是我自己写的一个基于状态机检测的按键扫描程序，使用状态机可以根据按键按下时长的不同状态实现短按单击、长按连击、长时间长按高速连击（我叫超级连击）的区分。
今天我所说的按键扫描程序全部是基于这种5向开关来做的，如果是矩阵按键扫描的话得做一些相应的修改 原理图如下，一共6个引脚。一个公共端上拉，其他5个引脚接单片机IO口就可以了。 首先是最简单的按键输入方式，哪个按键按下就返回哪个按键的值，没有按下的时候就返回空格键，这里是纯粹的按键扫描，一般还要加入一个20ms到150ms之间的延迟函数来做按键消抖：
uint8_t GetKeyInpt(){ uint8_t Key_x; if(Key_Up) Key_x = 'U'; else if(Key_Down) Key_x = 'D'; else if(Key_Left) Key_x = 'L'; else if(Key_Rignt) Key_x = 'R'; else if(Key_Center) Key_x = 'C'; else Key_x = ' '; return Key_x; } 因为一个比较大延迟的加入，这样的按键检测也是缺点非常明显的，无论你有没有按下按键都会有一个固定的100ms左右的延迟，它大大的降低了整个程序的执行的速度。之前做智能车的时候有一次学弟跟我说他的舵机感觉不管怎么调总是反应特别慢，最后检测才发现他的按键检测和舵机控制是放在main函数里的，而罪魁祸首就是按键检测里的Delay();
而基于状态机做的按键检测在没有按键按下的时候完全不需要做延迟，几乎不花时间，实测我的按键检测程序在48M主频的KEAZ128上之花了13us。
在说程序之前先说说什么是状态机，这是百度百科上的说法： 简单的理解就是通过不停的检测系统输入的状态，然后根据不同的条件让系统处于不同的状态，然后得到不同的输出。 对于按键的输入，我的按键扫描状态转移图可以由下表示： 这只是一个按键的输入扫描，如果多个按键怎么办？其实也很简单弄一个数组然后用循环不就可以啦！
具体实现的代码如下：
///////////////////////////////////////////// 按键输入检测 //////////////////////////////////////////////////////////////// //功能：5向开关检测按键 //返回值 ： 'U' 'D' 'L' 'R' 'C' 分别代表5向按键的 上、下、左、右、中 5个方向上的某个被按下了 ，没有任何按键按下返回 ' ' // // 注意： // 1、需要在头文件中配置按键的引脚，以及按下/松开按键时的电平状态 // 2、按键输入分为不按，短按单击，长按连击,超级连击四种模式。可以在头文件中把短按配置成按下时返回按键值或松开的时候返回按键值 // 短按的时候在 按下/松开 的时候返回一次按键值（需要头文件配置），短按超过一段时间之后，自动进入连击和超级连击模式（进入的时间 // 以及连击的速度可以在头文件中配置），连击模式下持续返回按键值 // 3、5个按键是有优先级的，分别为 ： 上 &gt; 下 &gt; 左 &gt; 右 &gt; 中 //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// uint8_t GetKeyInpt(){ //这个数组表示按键的状态，0表示已经松开，1表示短按，2表示长按进入连击模式，3表示超级连击（连击速度超快） static uint8_t key_state[] = {0 , 0 , 0 , 0 , 0 }; // 对应的按键 'U' 'D' 'L' 'R' 'C' uint8_t key_input[5] = {0}; //按键当前的输入状态 #if Key_Trigger_Rising_Edge == 1 static uint8_t key_input_1[5] = {0}; //上一次按键的输入 #endif static uint8_t key_con[5] = {0}; //按键计数，控制按下的持续时间 static uint16_t key_con_s[5] = {0}; //进入超级连击的计数 static uint8_t Key_x[] = {'U','D','L','R','C'}; //返回值 uint8_t i = 0; //获取当前键盘状态 key_input[0] = Key_Up; key_input[1] = Key_Down; key_input[2] = Key_Left; key_input[3] = Key_Right; key_input[4] = Key_Center; for(i = 0;i&lt;5;i++){ if(key_state[i]==0 &amp;&amp; key_input[i] == Key_Press){//某个按键的之前状态是松开的，然后又被按下了,这是短按模式 KEY_Delay(50); //消抖 key_state[i] = 1; //按键状态改为按下 #if Key_Trigger_falling_Edge == 1 KEY_Delay(50); return Key_x[i]; //返回按键值，在这返回相当于是下降沿触发（短按按下的时候返回值） #elif Key_Trigger_Rising_Edge == 1 return ' '; //上升沿在这不返回按键值 #endif } else if(key_state[i] == 1 &amp;&amp; key_input[i] == Key_Press){ //上次某个按键被按下了，这次还是按下的，检测长按模式 key_con[i]++; KEY_Delay(Delay_Tim); if(key_con[i]&gt;=Time_Multiple_Hit){ //设置计数时间 key_state[i] = 2; //该按键状态改为长按连击模式 key_con[i] = 0; //清空计数值 #if Key_Trigger_Rising_Edge == 1 return Key_x[i]; //上升沿模式下，在进入连击模式之前先返回一次单击的按键值 #endif } } else if(key_state[i] == 2 &amp;&amp; key_input[i] == Key_Press){ //如果还一直按着这个按键，进入长按模式 key_con[i]++; key_con_s[i]++; //超级连击计数 KEY_Delay(Delay_Tim); if(key_con[i]&gt;=Speed_Multiple_Hit){ //设置计数时间 key_con[i] = 0; //清空计数值 return Key_x[i]; //返回按键值 } if(key_con_s[i] &gt;= Time_Super_Multiple_Hit){ key_con[i] = 0; //清空计数值 key_con_s[i] = 0; //清空计数值 key_state[i] = 3; //进入超级连击模式 return Key_x[i]; //返回按键值 } } else if(key_state[i] == 3 &amp;&amp; key_input[i] == Key_Press){ //处于超级连击状态还按着按键 key_con_s[i]++; KEY_Delay(Delay_Tim); if(key_con_s[i] &gt;= Super_Speed_Multiple_Hit){ key_con_s[i] = 0; //清计数值 return Key_x[i]; //返回按键值 } } else if(key_state[i] == 2 &amp;&amp; key_input[i] == Key_Release){ //某按键上次状态是长按，但是这次没有按键按下 key_state[i] = 0; //状态改为没按下 key_con[i] = 0; //检测长按计数清0 } #if Key_Trigger_Rising_Edge == 1 //这一次检测某按键是松开的，但是上一次是按下的，而且按键的状态是短按的时候，返回按键值（这个if相当于上升沿，短按松开的时候返回按键值） else if((key_input[i] == Key_Release &amp;&amp; key_input_1[i] == Key_Press) &amp;&amp; (key_state[i] == 1)){ key_state[i] = 0; KEY_Delay(20); //消抖 return Key_x[i]; //返回按键值 } #endif else if(key_input[i] == Key_Release){ //某按键没有按下 key_state[i] = 0; //状态改为没按下 key_con[i] = 0; //检测长按连击计数清0 key_con_s[i] = 0; //检测超级连击计数清0 } #if Key_Trigger_Rising_Edge == 1 key_input_1[i] = key_input[i]; //记录按键 #endif } return ' '; //没有任何按键按下时返回空格' ' } 这里面用了一些条件编译，实现了按键单击是下降沿触发（按键按下的时间就返回按键值）还是上升沿触发（按键松开的时候才返回按键值），还有按键从单击转换到连击所需的时间、连击的速度、进入高速连击的时间、进入高速连击的速度都是用宏在头文件中定义的，方便做相应的修改。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c70abefd7266c4dd677e88f618b919ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/546b287ee9803dd76fa6e92debc1364f/" rel="bookmark">
			MySQL基础教程22-Mysql列属性-唯一键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一张表往往有很多字段需要具有唯一性，数据不能重复，但是一张表中只能有一个主键。唯一键（unique key）就可以解决表中有多个字段需要唯一性约束的问题。唯一键的本质与主键差不多，唯一键默认的允许自动为空，而且可以多个为空（因为字段为空不参与唯一性比较）。
增加唯一键
基本与主键差不多，也有三种方法。
方案1：在创建表的时候，字段之后直接跟unique关键字
看到Key列下显示UNI就表示unique，代表唯一性生效了。
方案2：在所有的字段之后增加unique key(字段列表); -- 支持复合唯一键
上面显示PRI，其实不是主键，原因是：这里number刚好是一个不为空的唯一键（主键性质一样），真实原因是该表没有主键，系统自动给添加上去的。具体你可以使用下面show create table命令查看。
方案3：在创建表之后增加唯一键
上面先是创建一个没有唯一键的表，然后通过追加的方式给number添加唯一键属性。
唯一键约束
唯一键和主键本质相同，唯一区别是唯一键允许为空，而且多个字段允许为空。
举例，插入数据。
查看表数据
上面表示如果列属性有unique修饰，那么是允许为空，但是不能重复，下面来验证唯一性冲突检查。
删除唯一键
举例删除唯一键
语法格式：alter table 表名drop index 索引名称；
上面语法提到index，这个索引指的是什么呢，请看下图。
执行删除唯一键操作
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1236b0898c1e2f737535b4ec42c6a5f5/" rel="bookmark">
			a/b &#43; c/d
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Problem Description 给你2个分数，求他们的和，并要求和为最简形式。 Input 输入首先包含一个正整数T（T&lt;=1000），表示有T组测试数据，然后是T行数据，每行包含四个正整数a,b,c,d（0&lt;a,b,c,d&lt;1000），表示两个分数a/b 和 c/d。 Output 对于每组测试数据，输出两个整数e和f，表示a/b + c/d的最简化结果是e/f，每组输出占一行。 Sample Input 2 1 2 1 3 4 3 2 3 Sample Output 5 6 2 1 代码： #include&lt;stdio.h&gt; #include&lt;string.h&gt; using namespace std; int Gcd(int a,int b){ int c; while(b){ c=a%b; a=b; b=c; } return a; } int main(){ int T; scanf("%d",&amp;T); while(T--){ int a,b,c,d; scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d); int n=a*d+c*b; int m=b*d; int k=Gcd(n,m); printf("%d %d\n",n/k,m/k); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01041972276a9a9017462775a4c40ad4/" rel="bookmark">
			计算机组成原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1章：计算机系统概论 1、计算机系统由哪两部分组成？计算机系统性能取决于什么？
计算机系统是由“硬件”和“软件”组成。衡量一台计算机性能的优劣是根据多项技术指标综合确定的，既包括硬件的各种性能指标，又包括软件的各种功能。
1）计算机系统由硬件和软件两部分组成。
2）计算机系统性能由硬件和软件共同决定。 2、计算机系统5层层次结构从下到上由哪五层组成？哪些是物理机，哪些是虚拟机？ 1）微程序机器、传统机器、操作系统机器、汇编语言机器、高级语言机器 2）微程序机器和传统机器是物理机，其他是虚拟机。 3、在计算机系统结构中，什么是翻译？什么是解释？ 1）翻译：将一种语言编写的程序全部翻译成另一种语言，然后再执行； 2）解释：将一种语言编写的程序的一条语句翻译成另一种语言的一条或多条语句，然后执行，执行完这条语言后，再解释下一条。 4、什么是计算机体系结构？什么是计算机组成？以乘法指令为例说明二者区别。 1）计算机体系结构是指那些能够被程序员看到的计算机的属性。如指令集、数据类型等； 2）计算机组成是指如何实现计算机体系结构所体现出来的属性； 3）以乘法指令为例，计算机是否有乘法指令，属于体系结构的问题。乘法指令是采用专用的乘法器，还是使用加法器和移位器构成，属于计算机组成的问题。 5、冯诺依曼机器的主要特点？ 1）计算机由运算器、存储器、控制器、输入设备和输出设备五大部分组成； 2）指令和数据存储在存储器中，并可以按地址访问； 3）指令和数据均以二进制表示； 4）指令由操作码和地址码构成，操作码指明操作的性质，地址码表示操作数在存储器中的位置； 5）指令在存储器内按顺序存放，通常按自动的顺序取出执行； 6）机器以运算器为中心，I/O设备与存储器交换数据也要通过运算器。（因此，后来有了以存储器为中心的计算机结构） 6、画出现代计算机的组成框图。 P10,图1.9 7、什么是存储单元、存储字、存储字长、存储体？ 存储单元：存储一个存储字并具有特定存储地址的存储单位； 存储字：一个存储单元中存放的所有的二进制数据，按照某个地址访问某个存储单元获取的二进制数据。 存储字长：存储字中二进制数据的位数，即按照某个地址访问某个存储单元获取的二进制数据的位数； 存储体：由多个存储单元构成的存储器件。 8、主存储器中，什么是MAR，什么是MDR，存储器的最大容量由什么决定？ 1）MAR：存储地址寄存器，保存需要访问的存储单元地址。反映存储单元的个数。 2）MDR：存储数据寄存器，缓存读出/写入存储单元的数据。反映存储字长。 3）存储器的最大容量由MAR寄存器的位数和MDR寄存器的位数决定。 9、什么是机器字长，什么是存储字长长？ 机器字长：CPU一次能够处理的二进制数据的位数。 存储字长：按照某个地址访问某个存储单元获取的二进制数据的位数。 10、假设MAR寄存器的位数为16位，MDR寄存器的位数为16位，存储器的最大容量是多少？ 1）MAR寄存器的位数为16位，能表示的地址个数为2的16次方，为64K； 2）MDR寄存器的位数为16位，说明存储字长为16位，也即2个字节； 3）存储器的最大容量为64K * 2B = 128K Byte ------------------------------------------------------------------------------------------------------ 第三章 系统总线 1、为什么要使用总线？ 在冯诺依曼结构中，各个部件之间均有单独连线，不仅线多，而且导致扩展I/O设备很不容易。即扩展一个I/O设备，需要连接很多线。 因此，引入了总线连接方式，将多个设备连接在同一组总线上，构成设备之间的公共传输通道。 2、总线的两大基本特征是什么？ 1）共享：多个部件连接在同一组总线上，各个部件之间都通过该总线进行数据交换。 2）分时：同一时刻，总线上只能传输一个部件发送的信息； 3、系统总线按照传输信息的不同，分成哪几类？是单向的，还是双向的？ 1）分成数据总线、地址总线以及控制总线。 2）数据总线：各个功能部件之间传送数据信息，双向传输； 3）地址总线：用来指明数据总线上，源数据或目的数据所在的主存单元的地址。单向：由CPU发出 4）控制总线：用来发送各种控制信号。对于控制总线中的单根线，是单向的，即只能由一个部件发向另一个部件。而一组控制总线中，有输入也有输出，因此，控制总线也可以看成是双向的。 3、什么是总线宽度、总线带宽、总线复用、信号线数？ 1）总线宽度：数据总线的根数，一般是8的倍数。是衡量计算机系统性能的重要指标； 2）总线带宽：即总线数据传输速率，总线上每秒能够传输的最大字节量。 3）总线复用：一条信号线上分时传送两种信号。例如数据总线和地址总线的分时复用； 4）信号线数：地址总线、数据总线和控制总线三种总线的线数之和。 4、假设总线的工作频率为33MHz，总线宽度为32位，则它最大的传输速率是多少？ 33 * （32/8） = 132 MB/s 5、简要说明单总线结构的概念及缺点？（现代计算机为什么要采用多总线结构？） 在单总线结构中，所有的部件（CPU、主存、I/O设备）都连接在一组总线上。 但所有的信息传送都要通过这组总线，同时只能有一个部件向总线上发送信息，导致总线成为系统的瓶颈。 因此，发展出来了多总线结构，其基本思想均是将速度相近的设备挂接在同一组总线上，总线之间通过总线控制器相连。 例如CPU和Cache之间、I/O设备之间等。 6、集中式总线判优控制有哪三种方式，哪种方式的优先级不能改变？ 1）链式查询、计数器定时查询、以及独立请求。 2）链式查询的优先级不能改变，离控制器最近的优先级最高。 7、简述链式查询、计数器定时查询以及独立请求三种方式的工作原理。 （略） 8、什么是总线周期，分为哪几个阶段？ 1）总线周期：总线上两个部件完成一次完整且可靠的数据传输时间； 2）分为四个阶段： 申请分配阶段：申请总线 寻址阶段：发出地址及有关命令 传数阶段：进行数据交换 结束：从总线上撤除信号，让出总线 9、什么是总线通信控制，总线通信控制有哪几种？ 1）总线通信控制：解决通信双方如何获知传输开始和传输结束，以及如何协调配合； 2）同步通信、异步通信、半同步通信、分离式通信 10、什么是同步通信？其优点和缺点？ １）同步通信：总线上各个部件由统一的时钟信号控制；在总线周期中，每个时钟周期各个部件如何动作都有明确的规定。 ２）优点：速度快，各个模块间配合简单 ３）缺点：以总线上最慢的部件来设计公共时钟，影响总线效率。 11、什么是异步通信？异步通信分为哪几种类型？ 1）异步通信：总线上各部件没有统一的时钟标准，采用应答式通信；（主模块发出请求后，一直等到从模块反馈回来应答信号之后才开始通信） 2）不互锁、半互锁、全互锁。（需要了解各种方式的含义） 12、什么是波特率？什么是比特率？（需要掌握如何计算波特率、比特率） 波特率：单位时间内传送的二进制数据数据的位数，单位bps 比特率：单位时间内传送的有效的二进制位数。 13、异步通信时，常规需要设置的参数有哪些？ 波特率、停止位（1/2/1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01041972276a9a9017462775a4c40ad4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a266da2f72b2cb4cf1bc5a3979d1bae3/" rel="bookmark">
			CentOS 6.x 最小化安装推荐安装的依赖包和修改内核参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS 6.x 最小化安装推荐安装的依赖包 我在日常工作中，新建的xenserver的虚拟机，CentOS release 6.9 (Final)操作系统，采用最小化安装，后续很多操作需要各种依赖包，经过一些时间的积累，推荐安装如下依赖包。前提是需要yum源先配置好，最好能联网，采用网络yum源。
yum clean all yum -y update yum -y install gd libxml2-devel libjpeg-devel libpng-devel net-snmp-devel wget telnet vim zip unzip yum -y install curl-devel libxslt-devel pcre-devel libjpeg libpng libcurl4-openssl-dev yum -y install libcurl-devel libcurl freetype-config freetype freetype-devel unixODBC libxslt yum -y install libtool openssl-devel readline-devel readline yum -y install perl-devel perl-ExtUtils-Embed yum -y install ncurses-devel.x86_64 openldap-devel.x86_64 lrzsz openssh-clients gcc-g77 bison yum -y install libmcrypt libmcrypt-devel mhash mhash-devel bzip2 bzip2-devel yum -y install ntpdate rsync svn patch iptables iptables-services yum -y install libevent libevent-devel cyrus-sasl cyrus-sasl-devel yum -y install gd-devel libmemcached-devel memcached git libssl-devel libyaml-devel auto yum -y install gcc gcc-c++ make autoconf automake ncurses-devel ncurses cmake libaio libaio-devel boost yum -y install perl-DBI perl-DBD-MySQL perl-Time-HiRes perl-IO-Socket-SSL perl perl-devel yum -y groupinstall "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a266da2f72b2cb4cf1bc5a3979d1bae3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d611c4edba2113c14f5fa915ebee5a26/" rel="bookmark">
			因子分析（factor analysis）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因子分析
基本思想公式推导基于R的实验结论 基本思想 在这一讲当中呢，我们谈一谈，因子分析（factor analysis），在上一节当中，我们说了主成分分析，我们说这两种方法有点相似，初学者往往有些搞不清楚。首先从原理上说，主成分分析是试图寻找原有自变量的一个线性组合。这个组合方差要大，那么携带的信息也就多，也就是相当于把原始数据的主要成分给拿了出来。而因子分析呢，是从假设出发，它是假设所有的自变量 x 出现的原因是因为背后存在一个潜变量f,也就是我们所说的因子，在这个因子的作用下， x 可以被观察到。什么意思呢，举个例子，比如一个学生考试，数学，化学 ，物理都考了满分，那么我们认为这个学生理性思维较强，理性思维就是一个因子。在这个因子的作用下，偏理科的成绩才会那么高。这就是因子分析，通过这点，大家就可以感受到，因子分析和主成分分析是明显不一样的。并且因子分析最早就由心理学家提出的。那么因子分析呢，又存在两个方向，一个是探索性因子分析（exploratory factor analysis）。另一个是验证性因子分析（confirmatory factor analysis）。探索性因子分析是不确定一堆自变量背后有几个因子，我们通过这种方法试图寻找到这几个因子。而验证性因子分析是已经假设自变量背后有几个因子，试图通过这种方法去验证一下这种假设是否正确。验证性因子分析又和结构方程模型有很大关系。后面我们会专门的介绍，今天先介绍探索性因子分析。
数学推导 因子分析假设自变量x背后存在影响它的因子 z ,既然是z影响 x ，那么x就可以写成 z 的函数了。当然，直接写不行，它有个假设，假设这个x是已经中心化的。那么就可以写出下式： xi−μ=∑j=1maijzj+ϵi i=1,2,...l, 如果为了方便呢，我们可以把它写成矩阵代数的形式如下： x−μ=Az+ϵ 这里呢，需要加一些假设，否则没法求解。首先是无关于误差项 ϵ 的，均值为 0 ，协方差矩阵∑ϵ=E(ϵϵT)=diag(σ21,σ22,...,σ2l).还需要假设因子和误差是独立的。在这种情况下，当我们的数据已经中心化之后，上面的因子分析式子就可以写成下式： x=Az+ϵ 进一步有 xT=(Az+ϵ)T 所以 xxT=(Az+ϵ)(Az+ϵ)T=AzzTA+ϵzTAT+AzϵT+ϵϵT 这样的话，对上式两边取数学期望。利用误差项均值为 0 ,我们得到下式： E[xxT]=AE[zzT]AT+E[ϵϵT] 这里还需要一个假设，那就是因子的协方差矩阵为单位矩阵。也就可以得到下式 ∑x=AAT+∑ϵ 这样的话，就简明了一些，我们主要是为了求载荷矩阵 A 和因子z。但是我们在推导过程中先巧妙地把 z 给去掉了。这样就可以先计算出A,再计算 z 。那么A其实就是矩阵 (∑x−∑ϵ) 的一种分解。当然这种分解不是唯一的，因为如果一个矩阵 C 可以写成AAT，那么 C=AU(AU)T 也是成立的。其中 U 为正交变换。所以才有了因子变换这个东西，经过因子变换，矩阵A中一部分数被变的很小，这样就可以看出哪个自变量属于哪个因子了。如果矩阵 A 计算出来了。那么z就好说了. z=AT∑−1xx 。这样就全部计算出来了。 下面给出一个基于R的因子分析 基于R的因子分析 数据介绍：数据是来自上市公司的财务指标，因此想通过因子分析将财务指标进降维，希望提取出一些反应不同特征的因子出来。最后根据因子对上市公司进行排名。
#设置路径 setwd('D:/Rdata') #清除空间变量 rm(list = ls()) #载入读取excel的包 library(readxl) library(psy) #读取数据 dat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d611c4edba2113c14f5fa915ebee5a26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/866f3461509c0b866f002d4093033643/" rel="bookmark">
			android通过webView加载第三方h5应用，无法加载图片和播放视频的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只需给webview的配置中加上下面这段代码即可解决
这是Android5.0 WebView中Http和Https混合问题，在Android5.0 以及以上的系统，当WebView加载的链接为Https开头，但是链接里面的内容，比如图片为Http链接，这时候，图片就会加载不出来。
if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT){ getSettings.setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW); } 问题相关知识分析： 从Android5.0以后，当一个安全的站点（https）去加载一个非安全的站点（http）时，需要配置Webview加载内容的混合模式，一共有如下三种模式： MIXED_CONTENT_NEVER_ALLOW：Webview不允许一个安全的站点（https）去加载非安全的站点内容（http）,比如，https网页内容的图片是http链接。强烈建议App使用这种模式，因为这样更安全。 MIXED_CONTENT_ALWAYS_ALLOW：在这种模式下，WebView是可以在一个安全的站点（Https）里加载非安全的站点内容（Http）,这是WebView最不安全的操作模式，尽可能地不要使用这种模式。 MIXED_CONTENT_COMPATIBILITY_MODE：在这种模式下，当涉及到混合式内容时，WebView会尝试去兼容最新Web浏览器的风格。一些不安全的内容（Http）能被加载到一个安全的站点上（Https），而其他类型的内容将会被阻塞。这些内容的类型是被允许加载还是被阻塞可能会随着版本的不同而改变，并没有明确的定义。这种模式主要用于在App里面不能控制内容的渲染，但是又希望在一个安全的环境下运行。 分析：
在Android5.0以下，默认是采用的MIXED_CONTENT_ALWAYS_ALLOW模式，即总是允许WebView同时加载Https和Http；而从Android5.0开始，默认用MIXED_CONTENT_NEVER_ALLOW模式，即总是不允许WebView同时加载Https和Http。
虽然官网给出的建议是，为了安全考虑，使用MIXED_CONTENT_NEVER_ALLOW模式，但是在实际引用中，当我们的服务器已经升级到Https，但是一些页面的资源是第三方的，我们不能要求第三方也都升级到Https，所以我们只能根据系统版本，用代码去设置加载模式为MIXED_CONTENT_ALWAYS_ALLOW。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e57bdae8f47090c19406df21883442b5/" rel="bookmark">
			client-go的使用及源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文个人博客地址：http://www.huweihuang.com/article/source-analysis/client-go-source-analysis/
1. client-go简介 1.1 client-go说明 ​ client-go是一个调用kubernetes集群资源对象API的客户端，即通过client-go实现对kubernetes集群中资源对象（包括deployment、service、ingress、replicaSet、pod、namespace、node等）的增删改查等操作。大部分对kubernetes进行前置API封装的二次开发都通过client-go这个第三方包来实现。
​ client-go官方文档：https://github.com/kubernetes/client-go
1.2 示例代码 git clone https://github.com/huweihuang/client-go.git cd client-go #保证本地HOME目录有配置kubernetes集群的配置文件 go run client-go.go client-go.go
package main import ( "flag" "fmt" "os" "path/filepath" "time" metav1 "k8s.io/apimachinery/pkg/apis/meta/v1" "k8s.io/client-go/kubernetes" "k8s.io/client-go/tools/clientcmd" ) func main() { var kubeconfig *string if home := homeDir(); home != "" { kubeconfig = flag.String("kubeconfig", filepath.Join(home, ".kube", "config"), "(optional) absolute path to the kubeconfig file") } else { kubeconfig = flag.String("kubeconfig", "", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e57bdae8f47090c19406df21883442b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5b7e7882a462fed354f5a692b4a7d84/" rel="bookmark">
			python中ones的含义和用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ones是numpy的一个内置函数，作用是生成参数为一的数组。英文解释：
Return a new array of given shape and type, filled with ones.
例子：
&gt;&gt;&gt; np.ones(5) array([ 1., 1., 1., 1., 1.]) &gt;&gt;&gt; np.ones((5,), dtype=np.int) array([1, 1, 1, 1, 1]) &gt;&gt;&gt; np.ones((2, 1)) array([[ 1.], [ 1.]]) &gt;&gt;&gt; s = (2,2) &gt;&gt;&gt; np.ones(s) array([[ 1., 1.], [ 1., 1.]]) 转载于:https://www.cnblogs.com/dylancao/p/8037350.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/179f06d415a21a56e9ff173284834951/" rel="bookmark">
			H3C交换机密码修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改交换机密码
1. 首先telnet他登陆需要修改的交换机
2. system-view
3. local-user admin
4. undo password
5. password cipher XXXXXXXXXXXXX
6. authorization-attribute level 3
7. service-type telnet
8. service-type ssh
9. 退出登陆，然后用新密码试试能不能登陆成功，登陆成功就save保存
转载于:https://www.cnblogs.com/lordhaart/p/8026457.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b474a29fd5388febcc96edc48e69b3b8/" rel="bookmark">
			PICT使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PICT使用教程
1. 简单使用 使用PICT生成正交测试用例，首先需要准备一个模型文件，例如，如果您希望为分区和卷创建创建一组测试用例，则可以使用以下参数来描述该域：类型，大小，文件系统，格式化方法，群集大小和压缩
模型文件myfolder.txt内容如下（标点符号均为英文）：
类型：主要，逻辑，单个，跨度，条纹，镜像，RAID-5
尺寸：10,100,500,1000,5000,10000,40000
格式化方法：快，慢
文件系统：FAT，FAT32，NTFS
簇大小：512,1024,2048,4096,8192,16384,32768，65536
压缩：打开，关闭
将该文件放到PICT目录下，在cmd命令行下即可生成相关测试用例：
C：\ YourFolder&gt; pict ModelFile.txt
输出重定向：
C：\ YourFolder&gt; pict ModelFile.txt&gt; OutputFile.txt
也可以将输出文件导入Excel，在Excel中打开它：
C：\ YourFolder&gt; pict ModelFile.txt&gt; OutputFile.xls
C：\ YourFolder&gt; OutputFile.xls
2. 高级特性 2.1 PICT命令选项和参数 【用法】pict 模式文件[选项]
【选项】
/o:N 组合数，默认值为2
默认生成二元组的测试用例，即pict生成的测试用例集中最多有两个值与其他测试集是相同的；改为3，则覆盖率会增大，但同时也会生成更多的测试用例；但缺陷大部分发生在参数两两组合的情况下，三个参数组合导致的缺陷并不多见。
/d:C 值与值之间的分隔符，默认为逗号（,）
例如一个参数操作系统 winxp,win7,win8 之间会用逗号隔开；
/a:C 别名间的分隔符，默认是管道符（|）
例如一个参数（用户名不区分大小写，但为了保证测试的可信度，可以用大小写轮换的方式进行测试）用户名 admin|ADMIN；
/n:C 无效数值或者是非法数值的前缀，默认值为（~）
例如一个参数（只能取1、2，为了测试非法值的输入，取0，但又不希望0和其他参数的每隔值都配一次对，为了减少测试集的数量，在0前面加一个~）即参数 ~0,1,2；
/e:file 定义种子文件，作用是可以指定组合方式
例如在种子文件seed.txt中指定一个组合方式，在执行1.txt时，命令：pict 1.txt /e:seed.txt 生成的测试集中会包含seed中指定的组合集（当然指定的组合集有一定条件）。（此参数目前的理解可能会有误区）；
/r[:N] 随机生成，N -种子
通过/r参数，可以使每次生成的测试集不同；
/c 参数的值完全区分大小写
/s 显示模型统计数据 2.2 模型文件 模型由三个部分组成
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b474a29fd5388febcc96edc48e69b3b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63764ab5edac8703f76461758983c493/" rel="bookmark">
			H5交互中，调用相册闪退到主界面_篱下悠然_新浪博客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导致问题的html代码是这一句：input type = "file" name = "file" 调用app的UIDocumentMenuViewController控制
问题发生场景：VC presentViewController 显示 webVC；
或者VC presentViewController 显示NVC，webVC在NVC上
这时候在H5上的 input type = "file" 触发后会导致UIDocumentMenuViewController 和 pre出来的VC（显示webVC的界面）两个直接dismis掉，
控制台会打印这么句警告： Warning: Attempt to present on whose view is not in the window hierarchy! 个人觉得这是apple的一个bug，应该有开发者反馈了才对，但是到目前WKWebView, UIWebView还存在这个问题，具体原因不晓得，坐等apple修复，在这之前可以参考我的处理方式，把那demo里的UIViewController+Dismis_FileUploadPanel .h和.m文件拖到项目里就ok了，不需要额外代码。修复处理逻辑看下文：
经过分析，发现是WKFileUploadPanel（或 UIWebFileUploadPanel）这么个东西的 _dismisDisplayAnimated: 方法执行的，直接代码是在UIDocumentMenuViewController控制器关闭后的completion内触发。 调试堆栈WKWebView 分析后发现 UIDocumentMenuViewController 和 webVC 之间并没有什么关系(pre关系)，只是和WKFileUploadPanel（或 UIWebFileUploadPanel） 这货有关系（delegate关系），基于这一点结合runtime切入，在presentViewController:animated: 时候对特殊UIDocumentMenuViewController进行标记
由于cancel是由UIDocumentMenuViewController发起的，所以也对其进行标记。
对然后dismissViewControllerAnimated:animated:时候的completion对标记对象进行区分处理，由于两次dismis是两个无关的vc顺序执行，所以用一个静态变量dismisFromFileUploadPanel 来标记是否是UIDocumentMenuViewController之后的dismis。
标记的目的是其它正常的dismis可以正确执行，避免其它bug出现。
于web内相册访问需要更多可控操作或获取更多信息，建议采用js交互实现。 然后dismissViewControllerAnimated:animated:时候的completion对标记对象进行区分处理，由于两次dismis是两个无关的vc顺序执行，所以用一个静态变量dismisFromFileUploadPanel 来标记是否是UIDocumentMenuViewController之后的dismis。
标记的目的是其它正常的dismis可以正确执行，避免其它bug出现。
更新：新增选择图片拦截，可知道选择的图片信息，修复选择图片拦截bug
分析发现图片文件选择走的是UIImagePickerController，而UIImagePickerController是通过代理返回结果集，那么在FileUploadPanel内部就必然有回调方法，否则无法完成图片获取操作
之前尝试runtime对WKFileUploadPanel 或 UIWebFileUploadPanel 采用方法替换拦截测试不可行，
新的拦截思路采用代理拦截器实现，在UIImagePickerController setDelegate:时候增加_UIImagePickerController_IFUP 拦截[imagePickerController: didFinishPickingMediaWithInfo:]代理事件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63764ab5edac8703f76461758983c493/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/116/">«</a>
	<span class="pagination__item pagination__item--current">117/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/118/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>