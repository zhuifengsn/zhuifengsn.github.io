<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a464fb03158f35167081b43971176234/" rel="bookmark">
			opencv学习-Mat详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.Mat简介1.1 Mat基本结构 2.Mat类的构造与赋值2.1 Mat类的构造2.1.1 默认构造函数2.1.2 根据输入矩阵尺寸和类型构造2.1.3 用Size（）结构构造Mat类。2.1.4 利用已有矩阵构造Mat类2.1.5 构造已有Mat的子类 2.2 Mat类的赋值2.2.1 在构造时赋值2.2.2 枚举法赋值：2.2.3 循环法赋值：2.2.4 利用类方法赋值示例：2.2.5 利用数组进行赋值 3.2 两个Mat类矩阵的乘法运算 4. Mat类元素的读取4.1 多通道数据的存储4.2 Mat类常用属性和成员方法4.3 通过at读取Mat类单通道矩阵的元素4.4 通过at读取Mat类多通道矩阵的元素4.5 通过指针ptr读取Mat矩阵中的元素4.6 通过迭代器访问Mat类矩阵中的元素 1.Mat简介 OpenCv提供了Mat类用来存储矩阵类型数据，包括向量、矩阵、图像等数据。Mat类分为分为矩阵头和指向存储数据的矩阵指针两部分。矩阵头包含矩阵的尺寸、存储方法、地址和引用次数。矩阵头是一个常数，绝大数情况下，矩阵头的大小远小于矩阵数据量的大小。
Mat { public: --- int dims; //维数 int rows,cols; //行列数 uchar *data; //存储数据的指针 int *refcount; //引用计数 } 1.1 Mat基本结构 2.Mat类的构造与赋值 2.1 Mat类的构造 2.1.1 默认构造函数 cv::Mat::Mat(); 这种构造方式，不需要传递任何参数，在后续给变量赋值的时候会自动判断矩阵的类型与大小，实现灵活的存储，常用于存储读取的图像数据和某个函数运算的输出结果。
2.1.2 根据输入矩阵尺寸和类型构造 cv::Mat::Mat(int rows,int cols,int type) 其中rows:构造矩阵的行数；cols：矩阵的列数；type：矩阵存储的数据类型，例如CV_8UC1之类。
2.1.3 用Size（）结构构造Mat类。 cv::Mat::Mat(Size size(), int type); 其中size：为二位数组变量尺寸，通过Size（cols，rows）进行赋值（列在前，行在后）；type：矩阵存储的数据类型，例如CV_8UC1之类。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a464fb03158f35167081b43971176234/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44a27f810d33bad6b3798b9dba9b6891/" rel="bookmark">
			单片机——LCD1602
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.基础知识介绍
1.1、为什么叫1602
因为可以显示两行，一行16个
1.2、LCD1602管脚认识
编号符号引脚说明1VSS电源地2VDD电源正极3VEE液晶显示偏压信号4RS数据/命令选择（H/L）5R/W读/写选择（H/L）6E使能端7D0数据8D1数据9D2数据10D3数据11D4数据12D5数据13D6数据14D7数据 1.3、LCD1602关键性指令设置
1.3.1、清屏指令
管脚对应二进制RS0R/W0DB70DB60DB50DB40DB30DB20DB10DB01 功能：
&lt;1&gt; 清除液晶显示器，即将 DDRAM 的内容全部填入"空白"的 ASCII
码 20H;
&lt;2&gt; 光标归位，即将光标撤回液晶显示屏的左上方;
&lt;3&gt; 将地址计数器(AC)的值设为 0。
1.3.2、模式选择指令
管脚对应二进制RS0R/W0DB70DB60DB50DB40DB30DB21DB1I/DDB0S 功能：
设定每次定入 1 位数据后光标的移位方向 ， 并且设定每次写入的一个字符是否移动。参数设定的情况如下所示：
位名设置I/D0=写入新数据后光标左移I/D1=写入新数据后光标右移S0=写入新数据后显示屏不移动S1=写入新数据后显示屏整体右移 1 个字符 1.3.3、显示开关控制指令
管脚对应二进制RS0R/W0DB70DB60DB50DB40DB31DB2DDB1CDB0B 功能：
功能：控制显示器开/关、光标显示/关闭以及光标是否闪烁。参数设定的情况如下：
位名设置D0=显示功能关D1=显示功能开C0=无光标C1=有光标B0=光标闪烁B1=光标不闪烁 设置完成之后，要判断液晶模块是否处于忙状态。
1.3.4功能设置指令
管脚对应二进制RS0R/W0DB70DB60DB51DB4DLDB3NDB2FDB1XDB0X 功能：设定数据总线位数、显示的行数及字型。参数设定的情况如下：
位名设置DL0=数据总线为 4 位DL1=数据总线为 8 位N0=显示 1 行N1=显示 2 行F0=5×7 点阵/每字符F1=5×10 点阵/每字符 0x38:00111000，就是数据总线8位，显示两行，以5×7 点阵/每字符 进行显示。
2、程序解释
2.1、宏定义
头文件，宏定义，根据连接定义端口
#include &lt;reg52.h&gt; #include &lt;intrins.h&gt; //定义端口 sbit duan=P2^6; sbit wei=P2^7; sbit RS=P1^0; sbit RW=P1^1; sbit E=P2^5; #define uchar unsigned char #define uint unsigned int #define Data P0 //	数据接在P0 #define	RS_commad	RS=0 //命令 #define	RS_data	RS=1 //数据 #define	RS_write	RW=0	//写 #define	RS_read	RW=1	//读 #define	E_close	E=0	//使能关 #define	E_open	E=1	//使能开	2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44a27f810d33bad6b3798b9dba9b6891/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b70b3468a27591bdce7a36b2f4038e59/" rel="bookmark">
			计算机考研机试指南第二版（王道）——第三章 排序和查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排序和查找： 3.1排序例题3.1 排序sort函数中自定义排序规则。 例题3.2 成绩排序1例题3.3 成绩排序2 3.2 查找例题3.4 找x例题 3.5 查找 3.1排序 例题3.1 排序 sort函数初使用。
题目描述：
#include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; using namespace std; int main() { int arr[101]; int n; scanf("%d",&amp;n); for (int i = 0; i &lt; n; ++ i) { scanf("%d", &amp;arr[i]); } sort(arr, arr+n);//排序 sort方法中传入数组首个元素的地址以及尾后地址，即左闭右开。 for (int i = 0; i &lt; n; ++ i) { printf("%d ", arr[i]); } printf("\n"); return 0; } sort函数中自定义排序规则。 //sort函数中自定义排序规则 //即修改比较和交换规则， //改为逆序 bool comp(int lhs, int rhs) { //不发生交换的条件下返回真-&gt;因此在对sort函数进行改造的时候，要明确什么情况下不发生交换！ if (lhs &gt;rhs) {//左边比右边大不发生交换-&gt;逆序 return true; }else { return false; } } int main() { int arr[8]; for (int i = 0; i &lt; 8; ++i) { scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b70b3468a27591bdce7a36b2f4038e59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81c05a20d0cff7f758e9da92f154d521/" rel="bookmark">
			Linux驱动开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、驱动分类 Linux中包含三大类驱动：字符设备驱动、块设备驱动和网络设备驱动。其中字符设备驱动是最大的一类驱动，因为字符设备最多，从led到I2C、SPI、音频等都属于字符设备驱动。块设备驱动和网络设备驱动都要比字符设备驱动复杂。因为其比较复杂，所以半导体厂商都已经帮我们写好了，大部分情况下都是可以直接使用的。所谓的块设备驱动就是存储器设备的驱动，比如EMMC、NAND、SD卡和U盘等存储设备
二、字符设备驱动开发 字符设备驱动是Linux驱动中最基本的一类设备驱动，字符设备就是一个一个字节，按照字节流进行读写操作的设备，读写数据是分先后顺序的。我们先来了解Linux下的应用程序是如何调用驱动程序的，如下图：
应用程序运行在用户空间，而Linux驱动属于内核的一部分，因此驱动运行于内核空间。open、close、write和read等这些函数是由C库提供的，在LInux系统中，系统调用作为C库的一部分。
三、Linux设备号 1、设备好的组成 为了方便管理，Linux中每个设备都有一个设备号，设备号由主设备号和次设备号两部分组成，主设备号表示某一个具体的驱动，次设备号表示使用这个驱动的各个设备。Linux提供了一个名为dev_t的数据类型表示设备号，dev_t定义在include/linux/types.h里面。dev_t其实是unsigned int类型，是一个32位的数据类型。其中高12位是主设备号，低20位是次设备号，因此Linux系统中主设备号范围是0~4095
设备号的操作函数
MAJOR用于从dev_t中获取主设备号，将dev_t右移20位即可 MINOR用于从dev_t中获取次设备号，取dev_t的低20位即可 MKDEV用于将给定的主设备号和次设备号的值组合成dev_t类型的设备号 2、设备号的分配 静态设备号：注册字符设备需要给设备指定一个设备号，这个设备号可以是驱动开发者静态指定的设备号，但是要注意该设备号没有被内核开发者分配掉。使用cat/proc/devices命令即可查看当前系统中已经使用的设备号
使用register_chrdev函数注册字符设备的时候只需要给定一个主设备号即可
/* 注册字符设备驱动 */ retvalue = register_chrdev(CHRDEVBASE_MAJOR, CHRDEVBASE_NAME, &amp;chrdevbase_fops); 这是老版本字符设备注册函数，其0~1048575（2^20-1）这个区间的次设备号全部设置为0
动态分配设备号：使用设备号的时候向linux内核申请，需要几个就申请几个，由linux内核分配设备可以使用的设备号。在注册字符设备之前先申请一个设备号，系统会自动给你一个没有被使用的设备号，这样就避免了冲突，卸载驱动的时候释放掉这个设备号即可
int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name) dev：保存申请到的设备号
baseminor：次设备号起始地址，alloc_chrdev_region可以申请一段连续的多个设备号，这些设备好的主设备号一样，但是次设备号不同，次设备号以baseminor为起始地址开始递增。一般baseminor为0，也就是次设备号从0开始
count：要申请的设备号数量
name：设别名字
如果给定了设备的主设备号和次设备号就使用如下所示函数来注册设备号
int register_chrdev_region(dev_t from, unsigned count, const char *name) 参数 from 是要申请的起始设备号，也就是给定的设备号 参数 count 是要申请的数量，一般都是一个 参数 name 是设备名字 一般采用动态分配设备号，模板如下
/* 注册字符设备驱动 */ /* 1、创建设备号 */ if (newchrled.major) { /* 定义了设备号 */ newchrled.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81c05a20d0cff7f758e9da92f154d521/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb7b643fc0fd9067294ad338ac86baaa/" rel="bookmark">
			Docker环境离线安装教程，附docker容器镜像打包，导出，导入加载镜像等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker离线安装方式1 （此方式在某些环境下可能不支持，如果不支持 请参考方式2）
下载文件：https://dn-dao-get.daocloud.io/docker/docker-1.13.0-centos-7.2.1511.tar.gz
上传，解压文件， 进入目录 执行 ：bash install.sh
启动docker服务：service docker restart
docker离线安装方式2 下载地址：https://download.docker.com/linux/static/stable/x86_64/
tar zxf docker-20.10.9.tgz sudo cp docker/* /usr/bin/ sudo dockerd &amp; 验证：docker ps
注意：如果切换用户无法使用docker命令时，需要分配用户组权限，然后重启docker服务
DOCKER 离线部署打包 docker save 和 docker export 区别 ：
1：docker save保存的镜像必须用docker load来导出 docker export 保存的容器 必须用 docker import导出 两者不能混用，否则容器无法正常启动
2：docker save保存的是镜像（image），docker export保存的是容器（container）
3：docker load --input 用来载入镜像包，docker import用来载入容器包，但两者都会恢复为镜像；
运行命令：
docker save -o xxx_save.tar 镜像ID -&gt; docker load --input xxx_save.tar
docker export -o xxx_export.tar 容器ID-&gt; docker import xxx_export.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb7b643fc0fd9067294ad338ac86baaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3de0d1b37d5a1fe2458bfee2e8159951/" rel="bookmark">
			Java 递归求树工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求描述 有时候，我们的数据是带有层级的，比如常见的省市区三级联动，就是一层套着一层，如下图：
而我们在数据库存放数据的时候，往往是列表形式的，如下图：
那么当我们从数据库查询出来，返回给前端的时候，前端又需要给出树形层级的时候，这个时候可能就需要递归处理为树形结构了，因此下面这个工具或许就可以用得上了。
使用示例 我们按照上面定义一个Place对象，打上工具注解：
@TreeKey 标识唯一
@TreeParentKey 标识父节点标识
@TreeChildren 标识子孙节点集合
@Data public class Place { @TreeKey private String id; @TreeParentKey private String parentId; private String name; @TreeChildren private List&lt;Place&gt; children; public Place(String id, String name, String parentId) { this.id = id; this.name = name; this.parentId = parentId; } } 测试：
public class Test { public static void main(String[] args) { List&lt;Place&gt; places = new ArrayList&lt;&gt;(); places.add(new Place("510000", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3de0d1b37d5a1fe2458bfee2e8159951/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94f88b34d3b5ded148c2087b7145f4b5/" rel="bookmark">
			王道机试指南（第二版）——题目OJ链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第2章 暴力求解2.1 枚举2.2 模拟1. 图形排版2. 日期问题3. 其他模拟 第3章 排序与查找3.1 排序3.2 查找 第4章 字符串4.1 字符串4.2 字符串处理4.3 字符串匹配 第5章 数据结构一5.1 向量5.2 队列5.3 栈 第6章 数学问题6.1 进制转换6.2 最大公约数与最小公倍数6.3 质数6.4 分解质因数6.5 快速幂6.6 矩阵与矩阵快速幂6.7 高精度整数 第7章 贪心策略7.1 简单贪心7.2 区间贪心 第8章 递归与分治8.1 递归策略8.2 分治法 第9章 搜索9.1 广度优先搜索9.2 深度优先搜索 第10章 数据结构二10.1 二叉树10.2 二叉排序树10.3 优先队列10.4 散列表 第11章 图论11.1 概述11.2 并查集11.3 最小生成树11.4 最短路径11.5 拓扑排序11.6 关键路径 第12章 动态规划12.1 递归求解12.2 最大连续子序列和12.3 最长递增子序列12.4 最长公共子序列12.5 背包问题1. 0-1背包2. 完全背包3. 多重背包 12.6 其他问题 王道机试指南（第二版）——题目OJ链接 方便大家跳转检验，侵删。 第2章 暴力求解 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94f88b34d3b5ded148c2087b7145f4b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79fcbc1cdf60d243b30985a30d9c9625/" rel="bookmark">
			Unocss(原子化css) 使用(vue3 &#43; vite &#43; ts)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unocss 简单使用 首先初始化一个vite项目
使用pnpm安装
pnpm create vite unocss-demo -- --template vue-ts 使用npm 安装
npm init vite@latest my-vue-app -- --template vue 使用yarn
yarn create vite my-vue-app --template vue 下载Unocss依赖 安装unocss和三个预设，第一个是工具类预设，第二个是属性化模式支持，第三个是icon支持
pnpm i -D unocss @unocss/preset-uno @unocss/preset-attributify @unocss/preset-icons 在vite.config.ts中引入 import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' // 引入Unocss import Unocss from 'unocss/vite'; import { presetUno, presetAttributify, presetIcons } from 'unocss' // https://vitejs.dev/config/ export default defineConfig({ plugins: [ vue(), Unocss({ // 使用Unocss presets: [ presetUno(), presetAttributify(), presetIcons()], }) ] }) 最后在main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79fcbc1cdf60d243b30985a30d9c9625/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f0bf4636867b406136ce7cf45b5b938/" rel="bookmark">
			SpringBoot 过滤器 filter 3种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、3种配置Spring Boot过滤器的方法二、web.xml的配置三、Spring Boot过滤器方式1，使用@WebFilter注解1.WebFilter的常用属性2.使用方法3.代码演示 四、Spring Boot过滤器方式2，使用FilterRegistrationBean1.自定义类演示2.第三方jar演示 五、Spring Boot过滤器方式3，实现ServletContextInitializer接口1.代码演示 总结 前言 最近Spring Boot项目做单点登录对接的时候，在配置过滤器的时候，找了几种方法，记录一下。欢迎评论补充沟通~
由于之前JAVA Web项目最开始都有web.xml配置，随着框架慢慢的进化，从Spring Boot开始，已经没有了web.xml配置文件。
那原来在web.xml里，配置的filter过滤器，在Spring Boot中怎么配置呢？
一、3种配置Spring Boot过滤器的方法 实现Filter接口，使用@WebFilter注解
过滤和实现都有，但是@order排序只能根据过滤器的类名排序
使用FilterRegistrationBean
主要是过滤，实现类要单独写，可以自定义排序
实现ServletContextInitializer接口
主要是过滤，实现类要单独写，目前没试能不能排序
二、web.xml的配置 &lt;!-- 应用集成 开始 --&gt; &lt;!-- 单点登录过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;SPDispacher&lt;/filter-name&gt; &lt;filter-class&gt;org.xxx.SpFilterWrapper&lt;/filter-class&gt; &lt;/filter&gt; &lt;!-- 客户端会话集成 --&gt; &lt;filter&gt; &lt;filter-name&gt;SessionIntegrationFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.xxx.AgentSessionIntegrationFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;!-- 访问控制器 --&gt; &lt;filter&gt; &lt;filter-name&gt;AuthorizationFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.xxx.AgentAuthzBaseRoleFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;!-- 应用集成 结束 --&gt; &lt;!-- 应用集成 开始 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;SPDispacher&lt;/filter-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;SPDispacher&lt;/filter-name&gt; &lt;url-pattern&gt;/service/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;SPDispacher&lt;/filter-name&gt; &lt;url-pattern&gt;/SAML2/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;SessionIntegrationFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;AuthorizationFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/service/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f0bf4636867b406136ce7cf45b5b938/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79c2750abaa82c7dd9ea305373cc98b2/" rel="bookmark">
			从键盘输入的年份，判断该年是否是闰年
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 从键盘输入的年份，判断该年是否是闰年 #include&lt;stdio.h&gt;
int main()
{
int y,l;
printf(“年份:”);
scanf(“%d”,&amp;y);
if(y%4== 0)
{
if(y%100== 0)
{
if(y%400==0)
l=1;
else
l=0;
}
else
l=1;
}
else
l=0 ;
if(l)
printf(“%d年是闰年”,y);
else
printf(“%d年不是闰年”,y);
}
在这里插入代码片 ```#include&lt;stdio.h&gt; int main() { int y,l; printf("年份:"); scanf("%d",&amp;y); if(y%4==0) { if(y%100==0) { if(y%400==0) l=1; else l=0; } else l=1; } else l=0 ; if(l) printf("%d年是闰年",y); else printf("%d年不是闰年",y); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0337e12a55a6db034976b7a19e816dee/" rel="bookmark">
			假如某月的1日是星期三，那么输入该月中的日期，要求输出对应的星期数。如输入3，则输出Friday。（用if…else…与switch语句两种方法实现）。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 假如某月的1日是星期三，那么输入该月中的日期，要求输出对应的星期数。如输入3，则输出Friday。（用if…else…与switch语句两种方法实现）。 #include&lt;stdio.h&gt;
int main()
{
int day = 0;
scanf (“%d”, &amp;day);
int week = (day + 2) % 7;
switch (week)
{
case 0:
printf(“Sunday\n”);
break;
case 1:
printf(“Monday\n”);
break;
case 2:
printf(“Tuesday\n”);
break;
case 3:
printf(“Wednesday\n”);
break;
case 4:
printf(“Thursday\n”);
break;
case 5:
printf(“Friday\n”);
break;
case 6:
printf(“Saturday\n”);
break;
}
return 0;
}
在这里插入代码片 ```#include&lt;stdio.h&gt; int main() { int day = 0; scanf (“%d”, &amp;day); int week = (day + 2) % 7; switch (week) { case 0: printf(“Sunday\n”); break; case 1: printf(“Monday\n”); break; case 2: printf(“Tuesday\n”); break; case 3: printf(“Wednesday\n”); break; case 4: printf(“Thursday\n”); break; case 5: printf(“Friday\n”); break; case 6: printf(“Saturday\n”); break; } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b02fda937f4c495193f00ac3a11b82f2/" rel="bookmark">
			算法与数据结构——一元多项式的表示和相加
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一元多项式的表示和相加 1，实验目的 用户可以通过键盘输入两个多项式，并非能够实现输入的一元多项式的显示，能够完成各项的排序，以及两个一元多项式的相加。
掌握链表的表示方法及存储。
掌握链表的操作。
2，实验内容 一个一元多项式的每一个子项都由“系数-指数”两部分组成，因此课抽象为包含系数coef,指数exp,指针域next构成的链式线性表。将两个多项式分别存放在两个线性表中，然后经过相加后将所得的多项式放入一个新的线性表里，然后进行打印。
利用链表实现一元多项式的表示和相加。通过main()函数调用实现。包括建立链表函数，输出链表函数，链表排序函数，链表相加函数。采用链式存储结构，将两个线性链表表示的一元多项式相加，并输出。此一元多项式遵循多项式相加运算规则：对于两个一元多项式中存在指数相同的项时，其对应系数相加：合并时系数和为零时，删除“和多项式”中此项；合并时系数和不为零时，则构成“和多项式”中的一项。对于两个一元多项式中存在的指数不相同的项，则分别复抄到“和多项式”中去，原多项式保持不变。
3，代码展示 //一元多项式的表示及相加
//打开相应库文件
//定义多项式最大项数
#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;
#define MAX 20
//定义单链表结点类型
typedef struct pnode
{
float coef;
int exp;
struct pnode* next;
}PolyNode;
//定义存放多项式的数组类型
typedef struct
{float coef;
int exp;
}PolyArray[MAX]; ;
//一元多项式的表示（建立多项式链表）
void CreateListR(PolyNode*&amp; L, PolyArray a, int n)
{
PolyNode* s, * r; int i;
L = (PolyNode*)malloc(sizeof(PolyNode));
L-&gt;next = NULL;
r = L;
for (i = 0; i &lt; n; i++) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b02fda937f4c495193f00ac3a11b82f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82cab864f544862f83612ed695e43abd/" rel="bookmark">
			计算机三级数据库大题及答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(1) 设在SQL Server 2008某数据库中有商品表和销售表，表的定义如下：
CREATE TABLE 商品表(
商品号 char(10) PRIMARY KEY,
商品名 char(20) NOT NULL,
销售总量 int DEFAULT 0)
CREATE TABLE 销售表(
商品号 char(10),
销售时间 datetime,
销售数量 int NOT NULL,
PRIMARY KEY(商品号,销售时间),
FOREIGN KEY(商品号) REFERENCES 商品表(商品号))
现要创建一个具有如下功能的触发器：每当在销售表中插入一条销售记录时，修改商品表中对应商品的销售总量，假设一次只插入一条销售记录。请补全下列代码。
CREATE TRIGGER tri_insert on [1] FOR [2] AS [3] 商品表 [4] 销售总量= [5] +(SELECT 销售数量 FROM [6]) WHERE 商品号 IN (SELECT 商品号 FROM Inserted) 参考答案： [1]:销售表 [2]:INSERT [3]:UPDATE [4]:SET [5]:销售总量或商品表.销售总量 [6]:Inserted （2）设在SQL Server 2008某数据库中有商品表和销售表，表的定义如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82cab864f544862f83612ed695e43abd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9df5e069bf90274ba83d5297e6a5392b/" rel="bookmark">
			王道复试C语言第一章枚举和模拟问题（上）——代码笔记分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 枚举题：给条件列出所有可能值2.1求所有三位数abc+bcc=5322.2求所有四位数abcd，其九倍与其逆序数相等2.3求所有平方为对称的不大于256的数 图形题：二维数组+数字规律2.4输入一个高度h，输出一个高度为h、上底边长度为h的*梯形2.5叠筐 枚举题：给条件列出所有可能值 2.1求所有三位数abc+bcc=532 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { //枚举：给条件列出所有可能值 //求三位数abc+bcc=532 int a,b,c; for(a=0;a&lt;10;a++){ for(b=0;b&lt;10;b++){ for(c=0;c&lt;10;c++){ if(a*100+b*10+c+b*100+c*10+c==532) printf("%d %d %d\n",a,b,c); } } } return 0; } 2.2求所有四位数abcd，其九倍与其逆序数相等 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { //求四位数abcd，其九倍与其逆序数相等 int a,b,c,d; for(a=0;a&lt;10;a++){ for(b=0;b&lt;10;b++){ for(c=0;c&lt;10;c++){ for(d=0;d&lt;10;d++){ if((a*1000+b*100+c*10+d)*9==d*1000+c*100+b*10+a) printf("%d%d%d%d\n",a,b,c,d); } } } } return 0; } 2.3求所有平方为对称的不大于256的数 如11的平方为121是对称
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //循环：知道次数用for，不知道用while //对称平方数 int reverse(int num) { int temp=0; while(num!=0){ temp=temp*10+num%10; num=num/10; } return temp; } int main() { int i; for(i=0;i&lt;257;i++){ if(i*i==reverse(i*i)) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9df5e069bf90274ba83d5297e6a5392b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c75e95d4973bf991db0181720b9f0c38/" rel="bookmark">
			【C语言督学训练营 第二天】C语言中的数据类型及标准输入输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、数据类型1.基本数据类型①.整形②.浮点型③.字符型 2.高级数据类型3.数据分类①.常量②.变量 三、标准输入输出1.scanf2.printf 四、进制转换1.进制转换简介2.十进制转其他进制3.其他进制转换 五、OJ网站的使用 一、前言 王道2024考研408C语言督学营第二天，今天介绍的是C语言的基础语法，虽然是基础语法但还是值得我们的注意的，有些细节像我这种练习两年半的ikun都不知道，当然了基础知识也并不需要全部掌握，讲课的老师都给出了考与不考的提示。
二、数据类型 什么是数据类型呢？举个栗子裁缝做衣服时需要用到化纤、纯棉、丝绸等不同类型的布料，经过裁缝的巧织最终做出了一件非常完美的衣服，那么程序员在编写程序时也一样，数据类型就相当于做衣服用到的化纤、纯棉、丝绸等不同类型的布料，那么C语言中需要用到哪些数据类型呢?数据类型的分类如下图所示。
1.基本数据类型 ①.整形 整形可以分为短整型、整形、长整形三类，定义时的关键字分别是 short、int、long、long long 几种类型的区分最明显的特征就是占用的字节数不同。那么说到这里什么是关键字呢？关键字就是C语言编译器已经占用了的英文单词，可以使用这些英文单词告诉编译器我们需要让他做什么。讲课的讲师也给出了详细的解释，C语言中的关键字有以下几种，考试不会考、写代码时集成开发环境会有提示(也就是不用记)，大家只需了解即可。
说完关键字就要开始说整形的概念了：整形可以通俗的理解为整数，可以分为整形符号常量、整形变量。可以使用以下代码体会一下整形。
整形符号常量，仅仅做位置的替换，并不会直接参与运算，可以从以下一个例子体会到
#include &lt;stdio.h&gt; #define PI 3+2 int main(){ printf("Hello!PI*2=%d,2*PI=%d",PI*2,2*PI); return 0; } 体会一下整形变量的使用：这里捎带介绍一下整除，两个整形相除会向下取整。体现在了下面例子
// // Created by Zhu Shichong on 2023/1/9. // #include "stdio.h" int main(){ int i=4; int j=3; printf("this num is %d，this 4/3=%d",i,i/j); } 要想得出正确的结果需要进行强制类型转换：
// // Created by Zhu Shichong on 2023/1/9. // #include "stdio.h" int main(){ int i=4; int j=3; float ans=(float)i/j; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c75e95d4973bf991db0181720b9f0c38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7628cc2f43a16789ed9a7dcfb010812/" rel="bookmark">
			洛谷 P1443 马的遍历 BFS解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目链接：https://www.luogu.com.cn/problem/P1443
题目描述：
解题思路： 利用BFS求最短的思想，第一次到达的一定是最短的。首先将马的起点坐标入队列，然后定义一个数组记录到达这个位置的步数。 AC代码 #include &lt;bits/stdc++.h&gt; using namespace std; struct node{ int x,y; }; int vis[405][405]={0}; int cnt[405][405]={0}; int fx[8][2]={{2,1},{-2,1},{2,-1},{-2,-1},{-1,2},{1,2},{-1,-2},{1,-2}}; queue&lt;node&gt;q; int main() { int n,m,ex,ey; cin&gt;&gt;n&gt;&gt;m&gt;&gt;ex&gt;&gt;ey; vis[ex][ey]=1; q.push({ex,ey}); while(q.size()){ node p; p=q.front(); q.pop(); int x1=0,y1=0; for(int i=0;i&lt;8;i++){ x1=p.x+fx[i][0]; y1=p.y+fx[i][1]; //cout&lt;&lt;x1&lt;&lt;" "&lt;&lt;y1&lt;&lt;endl; if(x1&lt;=n&amp;&amp;x1&gt;0&amp;&amp;y1&gt;0&amp;&amp;y1&lt;=m&amp;&amp;vis[x1][y1]==0){ q.push({x1,y1}); cnt[x1][y1]=cnt[p.x][p.y]+1; vis[x1][y1]=1; } } } for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ if(cnt[i][j]) cout&lt;&lt;cnt[i][j]&lt;&lt;" "; else if(i==ex&amp;&amp;j==ey){ cout&lt;&lt;cnt[i][j]&lt;&lt;" "; } else{ cout&lt;&lt;-1&lt;&lt;" "; } } cout&lt;&lt;endl; } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a63f25b1296a60e64d5038c15c9433e7/" rel="bookmark">
			虚拟试穿代码理解Down to the Last Detail: Virtual Try-on with Fine-grained Details（demo.py下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 demo.pyfoward函数（下）main函数 Down to the Last Detail: Virtual Try-on with Fine-grained Details, ACM MM 2020 Paper, Code/Model, ArXiv 深入到最后一个细节：能雕刻细节的虚拟试穿 理解得不对的地方欢迎评论区指正~ demo.py foward函数（下） #使用了torch.no_grad()上下文管理器，它会在其范围内禁用梯度计算，以减少内存占用并提高代码执行速度。 with torch.no_grad(): for i, result in enumerate(val_dataloader):#循环遍历val_dataloader中的数据。enumerate()函数可以同时返回数据的下标i和数据内容result #服装空间对齐模块（Clothing Spatial Alignment Module）：用于得到目标姿态下的变形后的服装图像。 'warped cloth' warped_cloth = warped_image(gmm, result)#执行warped_image函数，将数据传入gmm生成器模型中，并输出warped_cloth，表示变形后的衣服图像。 if opt.warp_cloth:#如果指定了opt.warp_cloth参数为True，则将warped_cloth保存到文件中 warped_cloth_name = result['warped_cloth_name'] warped_cloth_path = os.path.join('dataset', 'warped_cloth', warped_cloth_name[0]) if not os.path.exists(os.path.split(warped_cloth_path)[0]):#判断 warped_cloth_path 路径所在的目录是否存在 os.makedirs(os.path.split(warped_cloth_path)[0])#不存在则使用 os.makedirs() 创建该目录 utils.save_image(warped_cloth * 0.5 + 0.5, warped_cloth_path) print('processing_%d'%i) continue #从result中提取出了多个tensor数据，将其赋值给对应的变量名。 source_parse = result['source_parse'].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a63f25b1296a60e64d5038c15c9433e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d86b25ab6faa40cb882b356c587e4c6/" rel="bookmark">
			王道C语言督学营OJ练习全解【24考研最新版】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
本篇博客是在博主参加王道408专业课前置课程-----C语言督学营的学习笔记，包含了从第一节课到最后一节课的所有OJ习题题解，文章中每一题都给出了详尽的代码，并在每一题的关键部位加上了注释，记录下来的目的是方便自己以后进行复习，也希望能够帮助到大家，经过测试所有代码都可以通过王道OJ网站给出的样例，如果还有什么疑问的话评论区留言吧！（tips:网站上的样例比较简单，可能刷刷小聪明也可以通过，但是我建议大家还是按照要求来最好，毕竟是要锻炼自己的能力，投机取巧也不好！如果是感觉非常没有必要的能省则省。）
总体来说C语言督学营不算难，讲的知识很贴切考研考的知识点，前期主要对C语言语法进行了讲解，中后期补充了一些有关408的专业课知识点：
初级阶段 C语言基础语法数据类型&amp;数据的输入输出运算符与表达式选择循环一维数组与字符串指针函数结构体与C++引用 中级阶段 简要介绍了C语言数据结构顺序表基础操作单链表基础操作栈与队列基础操作二叉树层次建树&amp;层序遍历前中后序遍历&amp;求WPL顺序&amp;二分&amp;二叉排序树（查找算法）冒泡&amp;选择&amp;插入&amp;归并&amp;快速&amp;堆(排序算法)另加一些数据结构相关的考研大题 高级阶段 C语言语法补充（大多是考研不考的语法，或者有更好的替代）数据的机器级表示（计组里面的一些基本概念&amp;IEEE754浮点数表示法）汇编语言入门C语言文件另加一些计算机组成原理相关的大题 文章目录 初级阶段课时二作业1作业2作业3 课时三作业1作业2 课时四作业1作业2作业3 课时五作业1作业2 课时六作业1作业2 课时七课时八作业1作业2 中级阶段课时十课时十一课时十二课时十三课时十四作业1作业2 课时十五课时十六课时十七作业1作业2 高级阶段课时十九作业1作业2 课时二十课时二十一 初级阶段 课时二 作业1 题目描述
AC代码
// // Created by Zhu Shichong on 2023/1/9. // #include &lt;stdio.h&gt; int main() { printf("hello wangdao"); return 0; } 注意点
注意输入输出格式即可！HelloWord!
作业2 题目描述
AC代码
// // Created by Zhu Shichong on 2023/1/9. // #include &lt;stdio.h&gt; int main() { int a,b; scanf("%d %d",&amp;a,&amp;b); printf("%d",a+b); return 0; } 注意点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d86b25ab6faa40cb882b356c587e4c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa62a6d5a80b85c2f72d779788a3136d/" rel="bookmark">
			虚拟试穿代码理解Down to the Last Detail: Virtual Try-on with Fine-grained Details（demo.py上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 demo.py引用库：load\_model函数：forward函数（上）：模型初始化模块：数据增强模块：数据初始化模块： Down to the Last Detail: Virtual Try-on with Fine-grained Details, ACM MM 2020 Paper, Code/Model, ArXiv 深入到最后一个细节：能雕刻细节的虚拟试穿 理解得不对的地方欢迎评论区指正~ demo.py 引用库： torch：PyTorch的核心库，提供张量数据结构和数值计算操作等基本功能。torch.nn：PyTorch中神经网络模块的库，提供各种层和模型的定义和实现。models.networks：该脚本定义了自己的网络模型，其中包括Define_G和Define_D模型。torch.optim：PyTorch中优化算法的库，包括SGD、Adam、Adagrad、AdamW等优化器。config：一个Python脚本，定义了训练和测试的各种参数。os：提供了与操作系统交互的函数，用于访问文件系统等操作。os.path：提供了与路径相关的函数，用于处理文件和目录路径。torch.utils.data：PyTorch中数据加载和预处理的库，包括DataLoader等数据加载器。transforms：用于对图像进行变换的库，可以进行裁剪、缩放、旋转等操作。data.regular_dataset：一个Python脚本，定义了数据集类，用于读取和处理训练和测试数据。data.demo_dataset：一个Python脚本，定义了演示数据集类。utils.transforms：自定义的图像变换函数。time：Python的时间库，用于时间相关操作。datetime：Python的日期和时间库，用于日期和时间相关操作。torch.backends.cudnn：PyTorch针对GPU优化的库，用于提升训练速度。numpy：Python的数值计算库，提供了大量数学函数和矩阵操作。torchvision.utils：PyTorch中关于图像处理的工具函数。PIL.Image：Python的图像处理库，提供了图像读取、保存、缩放、旋转等操作。utils.pose_utils：自定义的人体姿态估计工具函数。torch.nn.functional：PyTorch中一些常用的函数库。lib.geometric_matching_multi_gpu：自定义的几何变换库，用于图像变形操作。cv2：Python中OpenCV库的接口，用于图像和视频处理 load_model函数： #load_model功能是加载预训练模型并返回预训练好的模型 def load_model(model, path): checkpoint = torch.load(path)#从指定路径（path）加载预训练模型（checkpoint） try: model.load_state_dict(checkpoint)#加载预训练模型的状态字典，以便将预训练模型的参数应用于该模型。 except: model.load_state_dict(checkpoint.state_dict())#如果出现加载不成功的情况，使用 checkpoint.state_dict() 来加载 model = model.cuda()#将模型加载到 GPU 中，以便后续在 GPU 上进行计算 model.eval()#将模型设置为测试模式，即关闭 dropout 和 batch normalization 等对模型参数的影响。 print(20*'=') for param in model.parameters():#冻结模型参数，避免在预测时更新模型参数，节省计算资源。 param.requires_grad = False #状态字典（state dictionary）是指在深度学习模型中保存了模型所有可学习参数的字典，每个参数都对应一个键值对。 # 在 PyTorch 中，状态字典通常是由模型的 state_dict() 方法返回的，它包含了所有的权重、偏差等参数信息。 # 状态字典可以通过调用 load_state_dict() 方法加载到模型中，使得模型的权重与状态字典中保存的权重保持一致。 # 通常在保存和加载模型时会用到状态字典，以便能够准确地保存和加载模型的权重，方便进行模型的训练和推理。 #Dropout是一种在深度神经网络中使用的正则化技术，可以在训练过程中减少过拟合现象。 #Dropout在每个训练批次中随机地使一些神经元失活，即将它们的输出设置为0，从而使得每个神经元都有一定的概率被临时忽略。 # 通过这种方式，dropout可以迫使神经元们相互独立地学习，而不是互相依赖，从而防止模型对训练集的过拟合。 #Batch normalization (批量归一化)是一种常用的神经网络正则化技术，旨在减轻训练深度神经网络时的内部协变量偏移 (internal covariate shift) 问题。 #内部协变量偏移是指在训练过程中，网络内部每一层的输入分布会随着网络的参数不断变化而发生变化，导致训练过程变得困难。 #Batch normalization 将每个 batch 的输入进行标准化处理，使其均值为0，方差为1，从而减少输入分布的变化，缓解了内部协变量偏移问题。 #同时，Batch normalization 也可以使得网络更加稳定，提高模型的收敛速度和准确性。Batch normalization 通常在网络的激活函数之前应用。 forward函数（上）： 模型初始化模块： def forward(opt, paths, gpu_ids, refine_path):#opt包含了试穿的相关参数，paths包含了用于加载模型的路径，gpu_ids指定了使用的GPU ID，refine_path指定了渲染的参考图片的路径。 cudnn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa62a6d5a80b85c2f72d779788a3136d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e53640f7671bf984c2bb6320c717c041/" rel="bookmark">
			LCD1602原理驱动代码及例程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LCD1602概述 LCD1602是一种工业字符型液晶，能够显示16x02即32字符的内容，是一种广泛使用的字符显示模块。它是由字符型液晶显示屏（LCD）、控制驱动主电路HD44780及其扩展驱动电路HD44100，以及少量电阻、电容元件和结构件等装配在PCB板上而组成。该显示屏的优点是耗电量低、体积小、辐射低。
LCD1602引脚接口说明 第四脚：RS为寄存器选择，高电平时选择数据寄存器、低电平时选择指令寄存器。
第五脚：R/W 为读写信号线，高电平时进行读操作，低电平时进行写操作。当 RS 和 R/W 共
同为低电平时可以写入指令或者显示地址，当 RS 为低电平 R/W 为高电平时可以读忙信号，
当 RS 为高电平 R/W 为低电平时可以写入数据。
LCD1602模块控制指令 在哪显示，如何显示 显示在那 我们可以在LCD中看到的只有32的位置，在开发中我们是不是可以用2的5次方来进行定义，但实际上LCD1602会有我们看不见的部分，所以我们用D0到D7八根导线来实现对于显示位置的确定，例如第二行第一个字符的地址是 40H，那么是否直接写入 40H 就可以将光标定位在第二行第
一个字符的位置呢？这样不行，因为写入显示地址时要求最高位 D7 恒定为高电平 1 所以实
际写入的数据应该是 01000000B(40H) +10000000B(80H)=11000000B(C0H)
显示什么 例如显示一个字母a，根据上图我们可以知道它应该为0110 0001换算成16进制为0x61，ASII值为97对应他的ASII值。
时序图 读操作时序
写操作
数序参数
由于时序时间间隔太小，我们同意用空函数nop（）代替间隔
显示一个字符 #include &lt;REGX51.H&gt; #include"intrins.h" #define databuffer P0 //定义8位数据线，P0端口组 sbit RS=P1^0; //读写寄存器选择位 sbit RW=P1^1; //读写信号线 sbit EN=P1^4; //使能端 void chek_busy() { char tmp; while(tmp &amp; 0x80){ RS=0; RW=1; EN=0; _nop_(); tmp=databuffer; //使用databuffer进行对于数据的缓存 EN=1; _nop_(); _nop_(); EN=0; _nop_(); } } void Write_Cmd_Func(char cmd) { chek_busy(); RS=0; RW=0; EN=0; _nop_(); databuffer=cmd; _nop_(); EN=1; _nop_(); _nop_(); EN=0; _nop_();	} void Write_Data_Func(char cmd) { chek_busy(); RS=1; RW=0; EN=0; _nop_(); databuffer=cmd; _nop_(); EN=1; _nop_(); _nop_(); EN=0; _nop_();	} void Delay15ms()	//@11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e53640f7671bf984c2bb6320c717c041/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/42/">«</a>
	<span class="pagination__item pagination__item--current">43/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/44/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>