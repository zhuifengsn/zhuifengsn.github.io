<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1003189d9b29fb283d53420c7791e7a0/" rel="bookmark">
			C：数组的部分初始化与过分初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; #define SIZE 8 int main(void) { int nums[SIZE]; for(int i = 0; i &lt; SIZE; i++) { printf("第%d个元素值为%d\n", i+1, nums[i]); } return 0; } 运行结果： 第1个元素值为16 第2个元素值为0 第3个元素值为1223955705 第4个元素值为32758 第5个元素值为0 第6个元素值为0 第7个元素值为34 第8个元素值为0 不对数组做任何初始化动作时，数组中的元素值就是为数组分配内存之前存储的值。因此毫无规律乱七八糟。
#include &lt;stdio.h&gt; #define SIZE 8 int main(void) { int nums[SIZE] = { 10 }; for(int i = 0; i &lt; SIZE; i++) { printf("第%d个元素值为%d\n", i+1, nums[i]); } return 0; } 运行结果如下： 第1个元素值为10 第2个元素值为0 第3个元素值为0 第4个元素值为0 第5个元素值为0 第6个元素值为0 第7个元素值为0 第8个元素值为0 如果对数组进行部分初始化，则其余元素值也会被初始化，如上int数组其余元素全部被初始化为0。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1003189d9b29fb283d53420c7791e7a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dcb7a1957949405ea8dcc563264b6b2/" rel="bookmark">
			刷穿力扣 ｜ 最大正方形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 原题链接点这里
解题思路 这道题，首先可以考虑的到暴力解法，但是肯定不是最优解。我们要使用动态规划来完成。
我们可以记录下来每个元素当正方形的右下角元素的时候的边长，那么，当前元素作为正方形右下角元素的最大变长就和它上面、左面、左上方记录的正方形最大边长有关，如果当前元素的值为1，那么它记录的最大边长就等于它上面、左面、左上方记录的正方形最大边长 + 1。
我们只需要遍历一遍矩阵，拿到最终的最大边长，最后返回平方就可以了。
代码 class Solution { public int maximalSquare(char[][] matrix) { // 养成良好的编码习惯，异常情况一定要考虑好 if (Objects.isNull(matrix) || matrix.length == 0 || matrix[0].length == 0) { return 0; } int maxSide = 0; int[][] dp = new int[matrix.length][matrix[0].length]; for (int i = 0; i &lt; matrix.length; i++) { for (int j = 0; j &lt; matrix[0].length; j++) { // 第一行或者第一列，以当前元素为正方形右下角的话，最大面积就是1 if (i == 0 || j == 0) { if (matrix[i][j] == '1') { dp[i][j] = 1; } } else if (matrix[i][j] == '1') { dp[i][j] = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dcb7a1957949405ea8dcc563264b6b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06d971814651a712b383b3287cc354ef/" rel="bookmark">
			代码如人生——修窗户的思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 代码如人生，如果生活中的事情都处理不好，那怎么写好代码呢？如果生活中事情的逻辑都搞不清楚，怎么能保证写的代码是逻辑清晰的，符合开闭的呢？ 1、问题背景： 窗户的把手由于用力不当或长期使用，导致把手的螺丝处松动，把手损坏。
2、引发哪些思考？ ①把手的螺丝处松动，把手损坏的原因是什么？
②怎样开窗关窗才能避免导致把手损坏？
③开窗关窗的正确姿势以及其逻辑和原理？
④把手处的螺丝松动导致把手损坏，可以怎么修呢？
3、自己是怎么思考这些问题的？自己的解决方案 ①把手的螺丝处松动，把手损坏的原因是什么？
窗户的设计：短螺丝钉，螺丝钉孔未穿透窗户而是嵌在窗户的中间层，这样把手的受力只能集中再窗户的这一面；且依靠的是螺丝钉与打的孔之间的摩擦力来固定把手，这样会导致孔逐渐变大摩擦力变小，而导致固定不住把手开窗关窗的姿势不正确导致用力不当、用力过猛，从而导致把手处螺丝松动把手损坏 ②怎样开窗关窗才能避免导致把手损坏？
观看开窗关窗的视频，正确的开窗关窗户。要了解开窗关窗的逻辑和原理 ③开窗关窗的正确姿势以及其逻辑和原理？
开窗：把手垂直90度，然后向外推开，再向后拉回来一点固定住——支撑结构的“锁住”关窗：先向外推一点解开支撑结构的“锁住”，然后再往回拉，拉回来之后把手横向右方90度逻辑和原理：开窗关窗都是有“锁扣”的，要先解开锁扣再进行开窗/关窗。 ④把手处的螺丝松动导致把手损坏，可以怎么修呢？
由于原来打的孔变大变松动，我们可以在这个孔外边加一个铁皮做螺丝和孔的隔离，使得铁片分担部分摩擦力原来的孔变大了，我们可以尝试用一个大的螺丝拧上 4、采用什么方案解决的？有什么好处？ 螺丝钉孔穿透窗户，使用长螺丝钉，可以在窗户的另一面增加螺母固定，这样把手的受力是整个窗户，受力点大了，不易损坏，而且即使把手坏了也不需要换孔，只需要重新安装一个把手的壳子即可。 5、结合生活中的这个例子，可以和哪些知识结构化 面向对象——解耦合，复用，可维护如何学习？——无限思维，不将就 6、有哪些收获？ ①不将就是发现的源动力：
可以是这样，还可以是怎样…； ②无限思维：
运动的、连续的、相对的、无限的去思考问题，不能静止的只看眼前的这个问题。可以是这样，还可以是怎样…； ③复用——可维护，符合开闭原则
原来修窗户的方式是孔坏了再打新的孔，导致窗户上很多坏的孔，孔都不能复用，长远来看，之后的窗户上全是不能用的孔导致没有位置再打孔的时候，就需要换窗户。现在的维修方案：螺丝钉孔穿透窗户，使用长螺丝钉，可以在窗户的另一面增加螺母固定，这样把手的受力是整个窗户，受力点大了，不易损坏，而且即使把手坏了也不需要换孔，只需要重新安装一个把手的壳子即可。 ④组合——改为聚合
解耦合，更灵活 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ae563127d97b83ed55d32d6aaa59309/" rel="bookmark">
			MAUI开发大杂烩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDE：Visual Studio 2022 Enterprise 17.3.4
.Net版本：.Net 6
1.首次使用MAUI创建的项目，在启动的时候可能会报错：
DEP0100: 请确保目标设备已启用了开发人员模式。由于错误 00000490，无法检查本地计算机上是否已启用开发人员模式。要详细了解开发人员模式，请访问 https://go.microsoft.com/fwlink/?linkid=2128411 在开始菜单搜索“开发者设置”，打开开发者选项界面，将下图红框选项勾选：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/299714a49301d92951fb97533280dec2/" rel="bookmark">
			APP弱网测试【快速上手】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.弱网测试概念 简单说就是在不同网络环境下，像在公车上、在地铁、地下车库等。在这种情况下，手机常常会出现网络抖动、上行或下行超时，导致 APP 应用中出现丢包延迟，从而影响用户体验。
1.1 弱网测试的思路 弱网功能测试：2G/3G/4G、高延时、高丢包
无网状态测试：断网功能测试、本地数据存储
用户体验关注：响应时间、页面呈现、超时文案、超时重连、安全及大流量风险
网络切换测试：WIFI → 4G/3G/2G → 网多状态切换
1.2 2G/3G 网络范围 tips：需要自定义可以根据下方两张图的范围去输入
2G网络
3G网络
目前3G运营及制式：
中国电信 CDMA2000
中国移动 TD-SCDMA
中国联通 WCDMA
其他概念自己搜别人的看，我们直接上手
二、Android弱网测试 2.1 QNET 2.1.1 简介 ①腾讯的一款不借助 PC 或者服务器，只需在任一智能手机上安装 QNET App，即可搭建一套完善的弱网环境，覆盖国内所有省份、海外 47 个主流的国家地区的运营商实时网络数据；
②提供真实的地铁、电梯等 20+ 弱网络场景；
③提供了网络数据包抓包功能，便于进行网络数据问题的分析；
④支持 adb 命令驱动，实现自动化弱网络测试，降低成本、提高效率
2.1.2 第一步下载、登录 浏览器搜索 QNET下载，目前官网下载需要申请
下载安装完后
【登录页面】
2.1.3 第二步创建场景 打开网络环境 向下找到 WIFI-4G网络切换 点击 添加
这些配置可以根据需要改，这里先整一个 2G正常 网络出来
1.打开网络类型选择2G
2. 打开弱网场景选择正常网络
3. 然后改个模板名字 点击保存
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/299714a49301d92951fb97533280dec2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f4be46289dc99dd3ada7e733b776204/" rel="bookmark">
			Netty客户端断线重连实现及问题思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在实现TCP长连接功能中，客户端断线重连是一个很常见的问题，当我们使用netty实现断线重连时，是否考虑过如下几个问题：
如何监听到客户端和服务端连接断开 ?如何实现断线后重新连接 ?netty客户端线程给多大比较合理 ? 其实上面都是笔者在做断线重连时所遇到的问题，而 “netty客户端线程给多大比较合理?” 这个问题更是笔者在做断线重连时因一个异常引发的思考。下面讲讲整个过程：
因为本节讲解内容主要涉及在客户端，但是为了读者能够运行整个程序，所以这里先给出服务端及公共的依赖和实体类。
服务端及common代码 maven依赖：
&lt;dependencies&gt; &lt;!--只是用到了spring-boot的日志框架--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.1.56.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jboss.marshalling&lt;/groupId&gt; &lt;artifactId&gt;jboss-marshalling-serial&lt;/artifactId&gt; &lt;version&gt;2.0.10.Final&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 服务端业务处理代码 主要用于记录打印当前客户端连接数，当接收到客户端信息后返回“hello netty”字符串
@ChannelHandler.Sharable public class SimpleServerHandler extends ChannelInboundHandlerAdapter { private static final InternalLogger log = InternalLoggerFactory.getInstance(SimpleServerHandler.class); public static final ChannelGroup channels = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE); @Override public void channelActive(ChannelHandlerContext ctx) throws Exception { channels.add(ctx.channel()); log.info("客户端连接成功: client address :{}", ctx.channel().remoteAddress()); log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f4be46289dc99dd3ada7e733b776204/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b5d0a100ce4cda2f45d12876a13ded7/" rel="bookmark">
			【完结版】jmeter&#43;ant&#43;python自动化框架，且支持jenkins持续集成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：本文是实现jmeter+ant+python脚本的自动化测试框架，并且把整套部署在jenkins，通过jenkins的构建来出发脚本的运行，而且还会在jenkins上展示html报告。本文记录搭建框架的整个步骤，以及遇到的问题和记录解决办法。
一、整体框架的介绍。 项目名：jmeter_autotest
项目需要的工具：apache-jmeter-5.4.3 apache-ant-1.10.5 编辑器：pycharm （只是为了比较好修改文件）
项目目录
--project. 用来存放项目文件 jmx和build
--report 用来存放测试报告
--testing 用来存放python脚本
--tools 用来存放apache-jmeter-5.4.3 apache-ant-1.10.5 包
给大家展示下我本地的目录结构：
二、部署到jenkins，并且通过参数构建给jmeter传参数，以至于来给jmeter的用户变量传递不同的参数，达到参数构建的效果 1）jenkins的部署，这个部署步骤就百度吧或者看我之前的文章。资料很多，这里不再废话。
2）将上面的框架代码，包含jmeter和ant全部上传到gitee。我这里已上传，有需要的自取，自取的同学不要忘了给作者文章点个小赞👍哦。
3）在jenkins上创建自由风格的项目。取名jmeter_autotest
4) 选择参数化构建-选项参数，然后在名称处填上 env 在选项处填上 uat 和prod（需要换行填写） 描述可以填入 “请选择执行环境 ”的提示语
5）选择git 拉取上传到git上的代码。
6）添加构建步骤，这里一定要跟我添加的步骤一样，不然会出现各种各样的额问题
执行shell脚本删除掉历史报告 echo "删除历史报告" rm -rf ${WORKSPACE}/report/html/* rm -rf ${WORKSPACE}/report/jtl/* 选择Execute system Groovy script （一定是这个哈，需要先在jenkins插件管理安装Groovy插件）然后在Groovy Script处填入以下代码。这里主要是解决我们后面显示html报告时，没有出来css样式的问题。 System.setProperty("hudson.model.DirectoryBrowserSupport.CSP", "") 选择 Invoke Ant， 选择版本，同样是需要先在jenkins管理中心先配置ant Target填写run Build File填写build.xml文件的路径 7）修改build.xml文件 源文件因为涉及到太多公司项目路径，这里不方便截图，需要请私聊
注意一个点：这个点我研究了很久
接收上面jenkins传过来的env，如何把值传给jmeter呢？ 答案是这样的。jenkins传给ant的build.xml文件，然后在传给需要执行jmeter的jmx文件。build.xml文件中需要增加 &lt;property name="env" value="${env}"/&gt; 如下图： &lt;jmeter jmeterhome="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b5d0a100ce4cda2f45d12876a13ded7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b3f9478a9ec7571937ad72380a88af9/" rel="bookmark">
			Ubuntu下OpenCV3.4.16的安装及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、安装OpenCV1、下载OpenCV3.4.16数据包2、解压缩包3、适用cmake安装opencv4、使用make创建编译5、安装 二、配置环境三、图片示例1、创建代码2、执行3、输出结果 四、视频示例1、获取摄像头权限2、播放视频3、录制视频五、总结六、参考资料 前言 OpenCV是一个基于BSD许可（开源）发行的跨平台计算机视觉库，可以运行在Linux、Windows和Mac OS操作系统上。它轻量级而且高效——由一系列 C 函数和少量 C++ 类构成，同时提供了Python、Ruby、MATLAB等语言的接口，实现了图像处理和计算机视觉方面的很多通用算法。
一、安装OpenCV 1、下载OpenCV3.4.16数据包 在Ubuntu上打开浏览器，进入如下网址，选择要下载的数据包（此处选择的是OpenCV-3.4.16）
https://opencv.org/releases/
2、解压缩包 将OpenCV-3.4.16.zip复制到主目录文件夹下
在终端中解压命令unzip opencv-3.4.16.zip
3、适用cmake安装opencv 先进入解压后的文件夹cd opencv-3.4.16
进入root用户，并更新
sudo su sudo apt-get update 然后执行如下命令安装cmake
sudo apt-get install cmake 出现是否执行，确定执行输入y
复制如下命令，安装依赖库
sudo apt-get install build-essential libgtk2.0-dev libavcodec-dev libavformat-dev libjpeg.dev libtiff5.dev libswscale-dev libjasper-dev 再创建build文件夹
mkdir build 使用cmake编译参数
cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local .. 4、使用make创建编译 仍是在build文件夹下进行
sudo make 编译完成
5、安装 sudo make install 安装中没有报错即可完成安装。
二、配置环境 修改opencv.conf文件，添加opencv库的安装路径：/usr/local/lib
sudo gedit /etc/ld.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b3f9478a9ec7571937ad72380a88af9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/056a591616528c85a82554652e2115aa/" rel="bookmark">
			linux 删除目录下所有纯数字文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		删除目录下所有数字文件夹
ls -a|grep -E "^\d$" | xargs -n 90 rm -rf 删除需谨慎！无法恢复
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e3aa9c1bcf32b882361760ddfa4bea9/" rel="bookmark">
			win7安装.net framework4.7.2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win7安装.net framework4.7.2 1.win7需要有sp1，可以用一下链接推荐方式安装
https://www.catalog.update.microsoft.com/Search.aspx?q=KB976932
https://support.microsoft.com/zh-cn/windows/%E5%AE%89%E8%A3%85-windows-7-service-pack-1-sp1-b3da2c0f-cdb6-0572-8596-bab972897f61
2.下载.net framework离线安装包
https://soft.3dmgame.com/down/214789.html
3.开始安装，如果提示已处理证书链,但是在不受信任提供程序信任的根证书中终止，去下面地址下载一个证书：http://download.microsoft.com/download/2/4/8/248D8A62-FCCD-475C-85E7-6ED59520FC0F/MicrosoftRootCertificateAuthority2011.cer，下载完了之后右击安装证书，下一步，选择讲述由证书放入以下存储，点击浏览，选择受信任的根证书颁发机构，完成。
4.重新安装.net framework4.7.2，成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33832af5a6398fe7718cf4b733d4ea4c/" rel="bookmark">
			HL7入门收集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、HL7 卫生信息交换标准（Health Level 7） 标准化的卫生信息传输协议，是医疗领域不同应用之间电子传输的协议。HL7汇集了不同厂商用来设计应用软件之间接口的标准格式，它将允许各个医疗机构在异构系统之间，进行数据交互。
作为信息交换标准，HL7 自1987年发布V1.0版后相继发布了v2.0 v2.1 v2.2 v2.3 v2.3.1 ，
2000年发布了v2.4版，现已用 XML 开发了v3.0版，
但 HL7 v2.4 版本仍是 ANSI 正式发布的版本。所以我们学习 HL7 2.4 版本即可
HL7_百度百科
二、HL7协议解析 消息结构 HL7标准包含256个事件、116个消息类型、139个段、55种数据类型、408个数据字典，涉及79种编码系统。
MSH|^~\&amp;|Mindray|Gateway|||||ORU^R01|2|P|2.3.1| &lt;CR&gt; PID|||M1015_00010||John^||20091112|M|||^^^^||| &lt;CR&gt;
PV1||I|^^ICU&amp;Bed5&amp;3232241659&amp;0&amp;0|||||||||||||||A||||||||||||||||||||||||||20091201111211 &lt;CR&gt; OBR||||Mindray Monitor|||20091203121631| &lt;CR&gt; OBX||NM|52^Height||169.0||||||F &lt;CR&gt; OBX||NM|51^Weight||59.0||||||F &lt;CR&gt; OBX||CE|2302^BloodType||1^A||||||F &lt;CR&gt; OBX||CE|2303^PACE_Switch||0^Off||||||F &lt;CR&gt; OBX||NM|101^HR|2101|60||||||F &lt;CR&gt; OBX||NM|151^RR|2102|20||||||F &lt;CR&gt; OBX||NM|200^T1|2104|37.00||||||F &lt;CR&gt;
每个HL7消息Message都有多个段Segment组成，每个段都以回车（&lt;CR&gt;）结尾
每个段最开始的3个大写字母表示段的唯一标识，如MSH（message header）表示消息头，PID（patient identity）标识病人唯一标识，PVI（patient visit）标识病人的一些基本信息如床号等。这些段的含义都是HL7标准里定义的。
每个段有包含多个域（Fileld），field之间用 | 分割。如果一个field没有被使用就什么都不用写，者就是很多两个域分隔符之间什么都没有的原因。每个field在段中都有一个序号（SEQ），各个field的序号和含义都是HL7标准中定义的，我们可以只使用其中一部分field。（有些field是必须出现的，不能省略，必须传值）
每个field又可以包含多个Component（组件），component之间用 ^ 分割
如 52^Height
一个component又可以包含多个Sub component（子组件），子组件之间用 &amp;分割
如ICU&amp;Bed5&amp;3232241659&amp;O&amp;O
HL7自定义段 Z-段 https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33832af5a6398fe7718cf4b733d4ea4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8befd521aa78b1b421dac75d104d3e56/" rel="bookmark">
			spring为什么使用三级缓存而不是两级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先先回答几个疑问：
1.实际上代理类是相当于持有一个原对象（spring用的两种代理，Proxy和cglib都是一样）：先创建对象，再创建代理类，再初始化原对象，和初始化之后再创建代理类，是一样的。
基于上述类写个main方法测试：
先根据空对象创建代理类，再初始化空对象，执行代理类方法，没问题！（忽略get/set方法）
2.尾部对象依赖前面对象，所以在尾部对象初始化时，就调用三级缓存中对象工厂的接口方法，即AbstractAutowireCapableBeanFactory#getEarlyBeanReference方法根据前面的空对象创建代理类，并设值给尾部对象。
前面的对象在装配和初始化完成之后，spring通过这段代码，将二级缓存中的代理类取出返回，最后会设置到一级缓存中，从而保证尾部对象依赖的，和容器中的前面对象，是一个对象。
下面说下我的结论：只用两级缓存可以解决循环依赖，甚至一级缓存就行（AOP也同样适用）。
要理解下面的内容需要阅读过一定的spring源码，基础较弱的读者建议去看本回答的出处： 【超级干货】为什么spring一定要弄个三级缓存？。以免错过此次刷新你认知的机会（不是吹牛）。 不信你可以改下添加三级缓存的源码，直接加入第二层缓存或者第一层缓存里。
启动正常，所以验证了上述结论 为什么呢？很简单，解决循环依赖只需要保证创建完成的bean和创建中与设置到其他相互引用的bean里的bean是同一个就行。
没有代理的情况下（getEarlyBeanReference返回原对象）去创建AServiceImpl（简称AS）：
反射创建AS的实例，并放入第一层缓存初始化AS实例时发现需要依赖注入BS，则获取BS的实例反射创建BS的实例，并放入第一层缓存初始化BS实例时发现需要依赖注入AS，则获取AS的实例，直接从第一层里获取BS实例初始化完成，放入第一层缓存（此时BS里的AS只是刚创建完，未初始化）回到第2步，AS实例初始化完成，放入第一层缓存（由于是同一个对象引用，所以BS里的AS也初始化完成） 有代理的情况下（getEarlyBeanReference返回代理对象）去创建AServiceImpl（给AServiceImpl和BServiceImpl都加上事务注解）：
前面5步都没啥问题，只是第一层缓存里的是AS代理类（BS里的也是），第6步中，原AS对象初始化完成，则AS代理类其实也初始化完成，所以进行引用覆盖，返回缓存中的代理类即可。
从技术的角度看一层缓存就能解决循环依赖，为什么spring要整的这么复杂呢？
请大家换个角度，不要再站在spring使用者的角度去思考了，现在要假设自己是spring的开发者！
不要在别人已经既定设计好的方案里去猜人家当时为什么这么设计，这就是从结果反推过程，说实话很容易潜意识认为就应该这样设计，从而变成想方设法圆他人所说。 先抛却掉这几级缓存，重新审视下创建和初始化bean实例的代码。
一个bean在创建过程中可能会产生两个对象：
一个是循环依赖时需要设值给与此bean相互引用的其他bean的对象（getEarlyBeanReference）一个是初始化后的对象（initializeBean） 如果现在要对bean做增强，比如实现切面，则需要生成代理类，所以spring在上述两个方法中通过BeanPostProcessor类提供了拓展点。
假如我是spring这块代码的开发者，如果我这么设计（只用一层缓存）：
假设spring没有提供AOP，需要使用spring的人自己去实现，那我就需要写个说明文档告诉他们：
请实现BeanPostProcessor接口的两个方法：getEarlyBeanReference和postProcessAfterInitialization（假如我是设计者，按我的设计那我肯定都整合在一个接口里了，不会再整个SmartInstantiationAwareBeanPostProcessor）这两个方法在bean刚创建完成但还未初始化时，和已装配并执行初始化方法之后会被调用，方法的入参bean分别是空对象和已初始化后的对象这两个方法的返回最好是同一个对象，如果不一样，由于最后引用会重新赋值，以getEarlyBeanReference方法返回为最终值 相信这样的文档会很让使用者很困惑：
这两个方法都会执行，而且第一个方法的返回值为优先，所以我实现第二个方法干嘛呢？第一个方法的入参还是个空对象，没有什么有用的信息啊？第二个方法的入参里有有用的信息，但是返回的对象还是会被第一个方法的覆盖啊？ 而且还暴露了很多内部设计细节，一个优秀的框架就是要让使用者对内部细节知道的越少越好，这样才便于迭代升级。 所以大家有没有发现，这种设计，让getEarlyBeanReference成为了创建bean时必会被调用的核心方法，而原本此处只是为了循环依赖时先给其他bean赋值！
倘若我们压根都没有循环依赖，bean本身的创建流程就应该是先new（一般是通过反射创建）一个，再装配初始化，最后放入实例缓存，此种设计就成了本末倒置！
那怎么调整呢？让getEarlyBeanReference延迟触发，只在有循环依赖时被引用的bean需要赋值当前bean时才触发！
所以就有了对象工厂ObjectFactory，也就有了第三级缓存。
而最理想的情况下，可以不用第二级缓存。
举个例子，A依赖B，B依赖A和C和D，C和D又依赖A，创建A的时候初始化需要B，创建B的时候初始化需要A，拿到A的ObjectFactory后调用接口方法获取对象，B还需要C和D，它们又需要去调用A的ObjectFactory，所以就重复调用了getObject方法，其实只要getEarlyBeanReference方法实现保证同一个beanName返回同一个对象，就不需要第二级缓存。
但是，这又暴露了内部实现细节，假如我弄个BeanPostProcessor实现类，spring也没有提示我要遵守上述约定，而我在getEarlyBeanReference方法里只是创建新对象返回，这就会导致B里面的是A1，C里面是A2，D里面是A3，那完了，芭比Q了！
所以让实现者去做重复性判断是不可控的，很容易出现问题，于是乎引入了第二级缓存，当调用三级缓存里的对象工厂的getObject方法之后，spring就会把返回值放入二级缓存，删除三级缓存，这样C和D取的就是二级缓存里的A对象，和B里的是同一个。
所以二级缓存和三级缓存其实是一套组合拳，不要拆成两个独立的东西去理解，出发点就不对。
基于这种设计，没有发生循环依赖的bean就是正常的创建流程，有相互引用的bean（除链尾的那个，比如之前的BS）会触发getEarlyBeanReference。
spring其实也不想你用框架前还要先了解循环引用，所以把getEarlyBeanReference方法设计在了SmartInstantiationAwareBeanPostProcessor接口中。从设计者这里的注释也能看出：此接口是一个专用接口，主要用于框架内的内部使用！
AOP是spring内部集成的，它的开发者知道这些逻辑，所以AbstractAutoProxyCreator实现了SmartInstantiationAwareBeanPostProcessor接口，可以看看其对这两个方法的实现。
循环引用的bean的创建过程会触发这两个方法，所以在getEarlyBeanReference方法中会打标记再去判断是否需要创建代理类（wrapIfNecessary），而postProcessAfterInitialization方法则需要先判断标记，以免重复执行wrapIfNecessary。
也得亏根据空对象去创建代理类后再去初始化原对象，和根据已初始化后的对象创建代理类效果一样。 否则这里 getEarlyBeanReference方法就没啥用了，只能返回原对象，在postProcessAfterInitialization方法返回前加上把相互引用的其他bean的引用指向方法返回值的操作了，那就没现在这么简单了。 最后再对这三级缓存做个简单的总结：
第一层缓存：最基础的缓存，创建完并初始化（createBean）后的bean实例会放入，项目启动完成后获取bean实例时从此获取第三层缓存：创建bean过程中用于处理循环依赖的临时缓存，由于只有在初始化时才知道有没有循环依赖，所以通过ObjectFactory临时“存储”刚创建完的bean，并延迟触发循环依赖时被引用的bean需要赋值当前bean时去获取当前bean的逻辑，且获取对象会作为当前bean的最终对象第二级缓存：创建bean过程中用于处理循环依赖的临时缓存，搭配第三层缓存，用于其ObjectFactory返回对象的缓存，保证多个关联对象对当前bean的引用为同一个 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a85302a9bca5ab2256dd53f45808dee/" rel="bookmark">
			一个UWP 框架开发的哔哩哔哩非官方应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大家推荐一个基于UWP框架开发的、原生的Windows应用。
项目简介 这是基于UMP框架开发的，UWP 应用是Universal Windows Platform的简介，即「Windows通用应用平台」，是微软公司建立并在Windows 10中首次引入的一个同性质应用程式架构平台。可以在拥有Win 10系统的手机、个人电脑、Xbox以及HoloLens等平台上运行。
这个是第三方应用，已经上架到Microsoft Store，想要体验的也可以到上面下载，此项目在UI设计、功能易用性都评价都很好，深受大家的喜欢，也是一个用来学习、参考的好项目。
技术架构 1、平台：UMP框架开发，支持Win 10/11，以及版本号在 22000 以上的 XBOX。
2、开发环境需安装：通用Windows 平台开发组件。
项目结构
系统架构
系统主要采用两种设计思路：依赖注入与响应式编程。依赖注入让系统层与层之间耦合度尽量降低，方便做单元测试；响应式编程大大的减少开发工作量，提升开发效率，UI采用ReactiveUI ，这是MVVM设计模式。
系统分成如下：
1、Model：数据层
定义实体
2、Provider：服务层
主要针对API的封装。
3、ViewModel：视图模型层
主要是对数据进行集中处理，提供给UI层显示。
4、View：用户界面层
交互体验、界面展示。
5、工具：Toolkit
公共层，主要是数据处理，提供给各个层使用。
界面截图
windows
XBOX
项目地址：https://github.com/Richasy/Bili.Uwp
- End -
专注分享编程知识、热门有用有趣的开源项目
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d73450074a6a2a8dcbfe997e2695d8a6/" rel="bookmark">
			rabbitmq 消息存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rabbitmq 消息存储分为两部分内容：
消息本身和其索引
而队列由两部分组成：
rabbit_amqqueue_process 接收并处理消息
backing_queue 则负责消息存储，默认实现为rabbit_variable_queue.erl，内含q1、q2、delta、q3、q4几个子队列
按照消息的存储位置，消息在backing_queue中可区分为以下几种状态：
alpha：消息本身和其索引都在内存中
beta：消息在磁盘，索引在内存
gamma：消息在磁盘，索引同时存在内存和磁盘
delta：消息和索引都只存在磁盘
一般而言消息在队列中的转化流程是：
q1-&gt;q2-&gt;delta-&gt;q3-&gt;q4
即内存存储到磁盘，再从磁盘取出到内存中这样的存储思路
其中q1和q4只存储alpha类型，q2和q3只存储beta、gamma类型
不过上述转移步骤经常被部分跳过，消息的状态受到系统负载的影响，会不断变动。
另外消费者消费时从q4反向获取消息，也触发消息的状态转移，当q4、q3、delta、q2都为空时，会将消息从q1直接转移到q4，下次直接读取q4。因此负载较轻，消费速率超过生成速率时，非持久化的消息基本处于alpha状态，从q1转移到q4被消费或者始终在q4（q3为空时消息会直接投到q4），消息始终处于内存中；而负载较高无法及时消费时，消息则可能存储到磁盘，增加开销并降低系统性能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45baa891c1f7612f06470b15514c18d4/" rel="bookmark">
			51单片机-6-矩阵键盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、矩阵键盘的介绍 在键盘中按键数量较多时，为了减少I/O口的占用，通常将按键排列成矩阵形式 采用逐行或逐列的“扫描”，就可以读出任何位置按键的状态。
扫描的概念：
数码管扫描（输出扫描）原理：显示第1位→显示第2位→显示第3位→……，然后快速循环这个过程，最终实现所有数码管同时显示的效果矩阵键盘扫描（输入扫描） 原理：读取第1行(列)→读取第2行(列) →读取第3行(列) → ……，然后快速循环这个过程，最终实现所有按键同时检测的效果以上两种扫描方式的共性：节省I/O口 比如这里的矩阵键盘：
若采用逐行扫描模式，先令P17、P16、P15、P14分别为0111，代表扫描第一行（即按键S1、S2、S3、S4），若能检测到P13、P12、P11、P10有0或低电平，则表示某按键被按下；检测完第一行后，令P17、P16、P15、P14分别为1011，即检测第二行，再检测P13、P12、P11、P10；令P17、P16、P15、P14分别为1101，即检测第三行，再检测P13、P12、P11、P10；令P17、P16、P15、P14分别为1110，即检测第四行，再检测P13、P12、P11、P10。
若采用逐列扫描模式，令P13、P12、P11、P10分别为0111，即检测第一列，再检测P17、P16、P15、P14；以此类推。
2、弱上拉概念理解 如下如所示：单片机内部某个引脚结构简图，若外部也是接入的高电平，则单片机读入高电平；若外部读入的是低电平，则强低电平把内部电源Vcc拉成低电平，单片机读入低电平。
P1、P2、P3都是弱上拉，P0是开漏输出，但外接上拉电阻，因此和其他几个端口都是同样的模式。
3、Debug本节汇总： 若添加了LCD1602.c函数后，转到相关子函数报错，可以保存程序退出，重新打开工程文件。写法问题：在main函数里面定义变量要放在开头，放在中间系统会报错，变量没有定义。 4、代码：按下按键，松开后在第二行显示按下按键的键号 （1）主函数 #include &lt;REGX52.H&gt; #include "LCD1602.h" #include "Delay.h" #include "Matrixkey.h" void main() { unsigned char Keynum=0; LCD_Init(); LCD_ShowString(1,1,"HelloWorld"); while(1) { Keynum=MatrixKey(); if(Keynum) { LCD_ShowNum(2,1,Keynum,2); }	} } （2）矩阵键盘函数（Matrixkey.c）:按行检索。 #include &lt;REGX52.H&gt; #include "Delay.h" unsigned char MatrixKey() { unsigned char keynumber=0; P1=0xFF; P1_7=0; if(P1_3==0){Delay(20);while(P1_3==0);Delay(20);keynumber=1;} if(P1_2==0){Delay(20);while(P1_2==0);Delay(20);keynumber=2;} if(P1_1==0){Delay(20);while(P1_1==0);Delay(20);keynumber=3;} if(P1_0==0){Delay(20);while(P1_0==0);Delay(20);keynumber=4;} P1=0xFF; P1_6=0; if(P1_3==0){Delay(20);while(P1_3==0);Delay(20);keynumber=5;} if(P1_2==0){Delay(20);while(P1_2==0);Delay(20);keynumber=6;} if(P1_1==0){Delay(20);while(P1_1==0);Delay(20);keynumber=7;} if(P1_0==0){Delay(20);while(P1_0==0);Delay(20);keynumber=8;} P1=0xFF; P1_5=0; if(P1_3==0){Delay(20);while(P1_3==0);Delay(20);keynumber=9;} if(P1_2==0){Delay(20);while(P1_2==0);Delay(20);keynumber=10;} if(P1_1==0){Delay(20);while(P1_1==0);Delay(20);keynumber=11;} if(P1_0==0){Delay(20);while(P1_0==0);Delay(20);keynumber=12;} P1=0xFF; P1_4=0; if(P1_3==0){Delay(20);while(P1_3==0);Delay(20);keynumber=13;} if(P1_2==0){Delay(20);while(P1_2==0);Delay(20);keynumber=14;} if(P1_1==0){Delay(20);while(P1_1==0);Delay(20);keynumber=15;} if(P1_0==0){Delay(20);while(P1_0==0);Delay(20);keynumber=16;} return keynumber; } 5、本节补充 （1）函数注释说明 /** * @brief : * @param : * @retval: */ 例如对矩阵键盘函数进行说明，如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45baa891c1f7612f06470b15514c18d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/849940f5c97d23b951de4e02b99fdf63/" rel="bookmark">
			md5修改器v1.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 自己用python写的一个小程序，用来修改文件夹内所有视频的md5值的，速度快，自动搜索视频文件，其他文件不做修改。
有需要的朋友可以自取，作用就是修改了md5的视频文件上传到网盘不能秒传，但是也不会因为别人的文件失效而失效，懂得自然懂。个人测试在阿里云盘完美使用。
使用说明 打开exe，根据提示，输入文件夹路径即可，软件会自动搜索文件夹内，包括子文件夹内的视频文件修改其md5值。
软件开源，有Python环境的可以直接使用压缩包内的源码。
软件链接1.0：（bug修复版）
md5_changer1.0bug修复版.7z - 蓝奏云
解压密码：52pojie
后记 其实百度也可以找到一些md5修改器，但是他们很多都没有搜索子文件夹的功能，后期如果大家需要，我可以更新单文件修改，回退修改，其他文件类型修改，GUI界面等功能。
希望朋友们用的开心。
有任何问题随时与我联系。
MD5修改器2.0更新说明 bug修复 修复了不能识别wmv格式视频（代码敲错了。。）
功能增加 支持不同种类文件修改，包括视频，音频，图片，也可以一次修改文件夹内所有文件的md5。
功能优化 采用随机的方式修改文件，这样即使是同样的文件经过我的程序一次处理也不会相同。这个功能保证了你每次修改过得文件一定是独一无二的。
软件链接2.0 md5_changer2.0.7z - 蓝奏云
解压密码：52pojie
小结 今天一个网盘wmv格式视频失效了，我很诧异，然后再次测试了一次软件，发现无法检测wmv格式视频，代码修正后，重新修改md5后上传，视频成功存活。修了bug，顺便也加了一个根据文件类型修改md5的功能，之后为了双重保险，最终又加了一个随机修改，保证一个文件，这样不同的人用相同的软件跑一次得到的md5也不相同。1.0版本新链接是bug修复版，有需要的朋友们可以重新下载下。
另外，软件是开源的，有python环境的也可以直接跑源代码。
下次更新可能会晚一点，因为最近比较忙，下次更新内容如下：
添加GUI界面，方便大家操作，也更加美观。添加md5计算，方便你们看到效果。支持文件还原单独文件修改
如果大家还想要其他的功能请在帖子下面留言吧，每一条我都会看的，最后祝大家软件用的开心。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c82092c8cb0199a7f0f5d69c6230e024/" rel="bookmark">
			C#调用python脚本的方法步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方式一：适用于python脚本中不包含第三方模块的情况
C#代码
using IronPython.Hosting; using Microsoft.Scripting.Hosting; using System; namespace CSharpCallPython { class Program { static void Main(string[] args) { ScriptEngine pyEngine = Python.CreateEngine();//创建Python解释器对象 dynamic py = pyEngine.ExecuteFile(@"test.py");//读取脚本文件 int[] array = new int[9] { 9, 3, 5, 7, 2, 1, 3, 6, 8 }; string reStr = py.main(array);//调用脚本文件中对应的函数 Console.WriteLine(reStr); Console.ReadKey(); } } } Python代码
def main(arr): try: arr = set(arr) arr = sorted(arr) arr = arr[0:] return str(arr) except Exception as err: return str(err) 方式二：适用于python脚本中包含第三方模块的情况
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c82092c8cb0199a7f0f5d69c6230e024/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0ae35f2ba52c29e5936a0b035ca905f/" rel="bookmark">
			数据结构-顺序表详解（含完整代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.线性表的顺序存储结构1.1定义1.2 数据长度和线性表长度的区别1.3顺序存储的结构代码1.4顺序表中基本操作的实现1.4.1自定义变量1.4.2 初始化1.4.3 查找1.4.4 插入1.4.5 删除1.4.6 打印 1.5完整代码实现（*==结合完整代码再看模块理解更快==*）1.6顺序表的优缺点1.6.1 优点1.6.2 缺点 1.线性表的顺序存储结构 1.1定义 指用一段地址连续的存储单元依次存储线性表的数据元素。
该图片来源于《大话数据结构》—作者程杰
1.2 数据长度和线性表长度的区别 数据长度： 是存放线性表的存储空间的长度，存储分配后这个量一般是不变的。
线性表长度： 线性表长度是线性表数据元素的个数，会随着插入和删除操作的进行，这个量也会发生改变。
1.3顺序存储的结构代码 #define MAXSIZE 20 /*存储空间初始分配量*/ typedef int ElemType; /*ElemType的类型根据实际情况而定*/ //存储 typedef struct { ElemType data[MAXSIZE]; /*数组存储数据元素，最大值为MAXSIZE*/ int length; /*线性表当前长度*/ }SqList; 1.4顺序表中基本操作的实现 1.4.1自定义变量 为了方便读者对后续代码的理解，我将我自定义的一些变量放在该部分的开头
#define OK 1 #define ERROR 0 #define MAXSIZE 20 /*存储空间初始分配量*/ typedef int ElemType; /*ElemType的类型根据实际情况而定*/ typedef int Status; 1.4.2 初始化 顺序表初始化操作就是构造一个空的顺序表。
代码如下：
//初始化操作 void InitList(SqList* L) { int i = 0; for (i = 0;i &lt; MAXSIZE;i++) { L-&gt;data[i] = 0; } L-&gt;length = 0; } 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0ae35f2ba52c29e5936a0b035ca905f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/070cb17ec4af44f68e209392275c7b44/" rel="bookmark">
			R语言安装DESeq2包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ｒ语言DESeq2包
R语言DESeq2包介绍
DESeq2包是为高维计数教据的归一化，可视化和差分分析而设计的。它利用经验贝叶斯技术对数折矗变化和离散的先验，并计算这些量的冠验估计。分析ＲＮＡ序列数据的主要任务是探测基因差异，而应用EDSeq中可以利用二项分布和收缩的分布方程估计.
DESeq2的差异表达分析涉及多个步骤:
简单的说——DESeq2将对原始reads进行建模，使用标准化因子(scale factor)来解释库深度的差异。然后，DESeq2估计基因的离散度，并缩小这些估计值以生成更准确的离散度估计，从而对reads count进行建模。最后，DESeq2拟合负二项分布的模型，并使用Wald检验或似然比检验进行假设检验。
包的安装
首先在库中查询，确定包不是自带的也没有安装
第一种安装方法失败
第二种安装方法:网上查阅资料找到扩展包的网站
访问此网站得到
输入以上代码重新开始安装DESeq包
安装中出现小故障输入n快速解决
成功安装DESeq
CollapseReplicates函数及应用
函数功能
折叠复制：折叠范围汇总实验或 DESeq 数据集中的技术复制
描述
通过在分组因子分组的级别内求和来折叠对象中的列。此函数的目的是汇总来自技术重复的读取计数，以创建一个对象，其中包含每个样本的单个读取计数列。（可选）使用分组因子的水平重命名返回对象的列。注意：这个函数写得非常简单，可以通过检查源代码来轻松更改以产生其他行为。
用法
应用例子
源代码：
dds &lt;- makeExampleDESeqDataSet(m=12)
# make data with two technical replicates for three samples
dds$sample &lt;- factor(sample(paste0("sample",rep(1:9,c(2,1,1,2,1,1,2,1,1)))))
dds$run &lt;- paste0("run",1:12)
ddsColl &lt;-collapseReplicates(dds,dds$sample, dds$run)
# examine the colData and column names of the collapseddata
colData(ddsColl)
colnames(ddsColl)
# check that the sum of the counts for "sample1" is the same
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/070cb17ec4af44f68e209392275c7b44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c75eea766532b831c4bd9e5c111a224/" rel="bookmark">
			springboot文件上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MultipartFile接口 springboot使用文件上传可以使用springmvc的MultipartFile这个接口，在参数方法中定义这个类的对象，然后使用这个对象完成文件的传送
MultipartFile是SpringMVC提供简化上传操作的工具类。
在不使用框架之前，都是使用原生的HttpServletRequest来接收上传的数据，文件是以二进制流传递到后端的，然后需要我们自己转换为File类。使用了MultipartFile工具类之后，我们对文件上传的操作就简便许多了。
来学习一下MultipartFile工具类全部的接口方法（我已经备注好了哈哈）
import java.io.File; import java.io.IOException; import java.io.InputStream; import java.nio.file.Files; import java.nio.file.Path; import org.springframework.core.io.InputStreamSource; import org.springframework.core.io.Resource; import org.springframework.lang.Nullable; import org.springframework.util.FileCopyUtils; public interface MultipartFile extends InputStreamSource { //getName() 返回参数的名称 String getName(); //获取源文件的昵称 @Nullable String getOriginalFilename(); //getContentType() 返回文件的内容类型 @Nullable String getContentType(); //isEmpty() 判断是否为空，或者上传的文件是否有内容 boolean isEmpty(); //getSize() 返回文件大小 以字节为单位 long getSize(); //getBytes() 将文件内容转化成一个byte[] 返回 byte[] getBytes() throws IOException; //getInputStream() 返回InputStream读取文件的内容 InputStream getInputStream() throws IOException; default Resource getResource() { return new MultipartFileResource(this); } //transferTo(File dest) 用来把 MultipartFile 转换换成 File void transferTo(File var1) throws IOException, IllegalStateException; default void transferTo(Path dest) throws IOException, IllegalStateException { FileCopyUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c75eea766532b831c4bd9e5c111a224/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/54/">«</a>
	<span class="pagination__item pagination__item--current">55/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/56/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>