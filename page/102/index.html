<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62ecca80d6f60f0211c44f1c9b7e2630/" rel="bookmark">
			android sharePreferences学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人学习笔记，代码大部分摘自《Android应用开发从入门到精通 卢东海著》
一、简介 众所周知，sharePrefences是android四种基本的储存数据的方式。另外三种分别是sqlite、contentProvider、文件储存。而它的主要适用范围在应用程序保存一些配置信息，如保存账号密码、保留上次的设置配置等，可以说是一个十分轻巧而常用的设置。当然作为明码保存的方式，在实际运用过程中对一些重要信息还要进行加密处理。
二、使用 1、存储信息 使用步骤（1）获取shareprefences对象（2）调用edit接口的putxxx（）方法（3）最后再提交
SharedPreferences sharedPreferences=getSharedPreferences("setting",0); sharedPreferences.edit().putString("name",nametext.getText().toString()).apply(); sharedPreferences.edit().putString("pwd",pwdtext.getText().toString()).apply(); getSharePreferences（，）; //获得对象，第一个参数是文件名，第二个参数是打开方式。有0或者MODE_PRIVATE
注：apply（）和commit可行。区别在于是否关注返回值。如果不在意结果，则使用apply
2、读取信息 SharedPreferences useinfo=getSharedPreferences("setting",0); String name=useinfo.getString("name",""); String pwd=useinfo.getString("pwd",""); shareprefences.getXXX（“”，）//XXX代表获取数据的类型，比如string或者int。第一个参数是key值，第二个参数代表无此值的默认数值。
3、PreferenceActivity（3.0前使用，3.0后推荐使用PreferenceFragment） （1）先创建xml的布局文件。如例
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;PreferenceCategory android:title="网络权限"&gt; &lt;CheckBoxPreference android:key="gps_setting" android:title="启动gps卫星设置" android:summary="该程序有使用GPS的权限" /&gt; &lt;CheckBoxPreference android:key="wire_setting&gt;" android:title="使用无线网络" android:summary="该程序有使用无线网络的权限"/&gt; &lt;/PreferenceCategory&gt; &lt;PreferenceCategory android:title="个人信息"&gt; &lt;CheckBoxPreference android:key="save_info" android:title="是否保存个人信息"/&gt; &lt;EditTextPreference android:key="name" android:title="姓名" android:summary="请输入姓名"/&gt; &lt;PreferenceScreen android:key="other_msg" android:title="其他个人信息" android:summary="是否工作"&gt; &lt;CheckBoxPreference android:key="work" android:title="工作"/&gt; &lt;EditTextPreference android:key="phone" android:title="手机" android:summary="请输入手机号"/&gt; &lt;/PreferenceScreen&gt; &lt;/PreferenceCategory&gt; &lt;/PreferenceScreen&gt; 其中几个注意点
preferenceSceen 是界面，是最大的分类preferenceCategory 代表一个设置分类checkBoxPreferences 勾选框edittextPrefences 输入框 （2）继承PrefernceActivity类 ，加载页面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62ecca80d6f60f0211c44f1c9b7e2630/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c083ba40c271271cb3f2665168e3a748/" rel="bookmark">
			C&#43;&#43; 空指针与野指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		空指针 空指针：指针变量指向内存中编号为0的空间，0-255之间的内存是系统使用的，nullptr默认是0
用途：初始化指针变量
注意：空指针指向的内存是不允许访问的。
实例：空指针
野指针
野指针：指针变量指向的是一块非法的内存空间
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d43cc8887fc7a7f07b9ab3601e89bf3/" rel="bookmark">
			C&#43;&#43; #include &lt;algorithm&gt;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标准模板库：算法
头文件&lt;algorithm&gt;定义了一组专门设计用于元素范围的函数集合。
范围是可以通过迭代器或指针访问的任何对象序列，例如数组或某些STL容器的实例。 但是请注意，算法通过迭代器直接对值进行操作，而不以任何方式影响任何可能容器的结构（它从不影响容器的大小或存储分配）。
参考手册：cplusplus.com
具体包括 1、非修改序列操作 2、修改序列的操作 3、分区操作 4、排序操作 5、二分查找操作 6、合并操作
7、堆操作 8、最大最小值操作 9、其它操作
这里列举几个常见操作：
1、reverse()
// reverse algorithm example #include &lt;iostream&gt; // std::cout #include &lt;algorithm&gt; // std::reverse #include &lt;vector&gt; // std::vector int main () { std::vector&lt;int&gt; myvector; // set some values: for (int i=1; i&lt;10; ++i) myvector.push_back(i); // 1 2 3 4 5 6 7 8 9 std::reverse(myvector.begin(),myvector.end()); // 9 8 7 6 5 4 3 2 1 // print out content: std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d43cc8887fc7a7f07b9ab3601e89bf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea386d2ce0c6f5250dd73d647a2c5a0a/" rel="bookmark">
			Caffe测试集分类结果相同，全部为最后一类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象说明 目标：二分类，训练过程中验证集准确率比较高。训练完成之后对测试集进行测试，测试结果中的类别全部为1(最后一类)。
Caffe测试集分类结果相同，全部为最后一类
原因及解决方案 原因：没有对网络的第一个卷积层进行初始化。下图是原来网络第一个卷积层的参数。
解决方案：将第一个卷积层权重初始化为“xavier”，偏置初始化为常量0。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/421c18247d13cd954d1d23770bba05f6/" rel="bookmark">
			Spring MVC 入门总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring MVC 入门总结 文章目录 1.MVC 设计模式1.1模式一（Mode I）1.1模式2（Mode Il） Spring MVC 在校大学生第一次写博客，借鉴了一些文章（侵删） 1.MVC 设计模式 DAO(Data Access Object)：主要对数据的操作，增加、修改、删除等原子性操作。
View层：主要是界面 如 jsp html 等
Service业务层：将多个原子性的DAO操作进行组合，组合成一个完整的业务逻辑
控制层：主要使用Servlet进行控制
数据访问层：JDBC技术、持久化框架实现对数据的增删改查
JavaBean：用于封装数据。
1.1模式一（Mode I） 本来大学用这个模式做了多次开发，需求更改的时候维护难度深有体会！
模式一指的就是在开发中将显示层、控制层、数据层的操作统一交给JSP或者JavaBean来进行处理
使用JSP+JavaBean做开发
优点：
程序的可读性较高，业务代码都写在JavaBean上，jsp页面上方直接是当前页面的数据处理。可重复利用高，核心的代码都由JavaBean开发了，可以直接写代码生成器生成代码，复用度很高 缺点：
没有流程控制，程序中的JSP页面都需要检查请求的参数是否正确，异常发生时的处理。显示操作和业务逻辑代码工作会紧密耦合在一起的！日后维护会困难 1.1模式2（Mode Il） Mode II 中所有的开发都是以Servlet为主体展开的，由Servlet接收所有的客户端请求，然后根据请求调用相对应的Service业务层,在由业务层调用DAO层，在由DAO层去与数据库进行交互，最后吧所有的显示结果交给JSP完成！，也就是俗称的MVC设计模式！
优点：
MVC模式开发使用Servlet来做处理请求，代码量略大，但层次清晰分工明确，代码维护难度降低。 缺点：
对于萌新，代码可阅读性差了一些，代码量多一些 参考于
https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247483775&amp;idx=1&amp;sn=c9d7ead744c6e0c3ab2fe55c09bbe61f&amp;chksm=ebd7407edca0c9688f3870d895b760836101271b912899821fb35c5704fe215da2fc5daff2f9#rd
Spring MVC 官方文档介绍：
1.Spring MVC 简介 :Spring Web model-view-controller(MVC)framework 是围绕DispatcherServlet设计的，它通过可配置的处理程序映射，视图解析，locale，time zone 和主题解析以及对上传 files 的支持来向处理程序发送请求。默认处理程序基于@Controller和@RequestMapping 注释，提供各种灵活的处理方法。随着 Spring 3.0 的引入，@Controller机制还允许您通过@PathVariable annotation 和其他 features 创建 RESTful Web 站点和 applications。仅如此。它与 Spring IoC 容器完全集成，因此允许您使用 Spring 所具有的所有其他 feature。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/421c18247d13cd954d1d23770bba05f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b625be6e8f3fc4a63b9b1aa5dafdc895/" rel="bookmark">
			利用pandas实现SQL操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在SQL中常见的操作主要是增、删、改、查几个动作，那么pandas能否实现对数据的这几项操作呢？答案是Of Course!
增：添加新行或增加新列
dic = {'Name':['LiuShunxiang','Zhangshan'],'Sex':['M','F'],'Age':[27,23],'Height':[165.7,167.2],'Weight':[61,63]} student2 = pd.DataFrame(dic) print(student2) Age Height Name Sex Weight 0 27 165.7 LiuShunxiang M 61 1 23 167.2 Zhangshan F 63 现在将student2中的数据新增到student中，可以通过concat函数实现：
student3 = pd.concat([student,student2]) print(student3) Age Height Name Sex Weight 0 14 69.0 Alfred M 112.5 1 13 56.5 Alice F 84.0 2 13 65.3 Barbara F 98.0 3 14 62.8 Carol F 102.5 4 14 63.5 Henry M 102.5 5 12 57.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b625be6e8f3fc4a63b9b1aa5dafdc895/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41c61dc873ce33a603dcb7cdcfeb16cf/" rel="bookmark">
			python爬虫入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import re import requests def fun(first): #http://www.mmonly.cc/gqbz/list_41_345.html url = "http://www.mmonly.cc/gqbz/list_41_"+first+".html"#10-70 1-7 res = requests.get(url=url) html=res.text with open("zhenze.txt", "rt", encoding="utf-8") as in_file: zhenze = in_file.read() pic_url = re.findall(zhenze,html,re.S) print(pic_url) for i in range (1,len(pic_url)-1): picture=requests.get(pic_url[i]) with open(first+"_"+str(i) +".jpg", "wb")as f: f.write(picture.content) def getfun(): for i in range(10,300): fun(str(i)) if __name__ == "__main__": getfun() 下面是zhenze.txt的内容 &lt;img.*?src="(.*?\.jpg)" 运行，爬虫完毕，继续学习~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc7557f07db8264b184e1f98e4020ebc/" rel="bookmark">
			Hbuilder红色版下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网：https://www.dcloud.io/
解压后就可以使用了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63a3342230dd06e0ab8fae9e1fe598aa/" rel="bookmark">
			压缩感知图像重建质量与JPEG2000(kakadu)的批量比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本脚本适合于压缩感知的研究者，将自己的算法与JPEG2000进行比较，批量得出结果。
具体见我的github:compressed_sensing-batch-JPEG2000-kakadu-PSNR-SSIM
压缩感知 压缩感知（CS）是一类图像压缩重建的算法，其流程为:
编码后保存的数据为经过熵编码的测量值y。
总压缩倍数R为：
R = c r ∗ 8 b ∗ S R=cr*\frac{8}{b}*S R=cr∗b8​∗S
其中cr为测量率（原图与测量值的数据数量比例，比如压缩20倍则cr为20），b为量化比特，S为测量值y的熵编码倍数。
熵编码算法主要为算术编码和霍夫曼编码，但不同的实现方式效率有所区别，他们的最终目标都是达到香农极限，在这种情况下，压缩倍数R为：
R ′ = c r ∗ 8 e n t r o p y o f y ′ {R}'=cr*\frac{8}{entropy\;of\;{y}'} R′=cr∗entropyofy′8​
其中 y ′ {y}' y′为量化后的测量值。
这是理想的情况，实际达不到这么高的压缩倍数。本脚本采用了这种方式，避免了复杂的熵编码的实现，但是使得效果偏高，需要注意。
JPEG2000 常用的JPEG2000软件是kakadu，其使用方式见我的另一篇博文：kakadu——JPEG2000图像压缩软件的安装和使用
而kakadu只能一张一张得进行压缩和解压，如果需要统计一批图像的数据，就会很麻烦，本脚本解决这个问题。
处理脚本 文件目录：
orig:原图文件夹，以orig_%d.bmp命名。
represent:kakadu得到的压缩文件夹。
recon:kakadu得到的重建图文件夹，以recon_%d.bmp命名。
注：图像格式支持:bmp,jpg,tif,png等常见格式，但orig和recon文件夹内的图像格式必须是同一种。
measurement:自己的算法得出的图像的测量值文件夹，以y_%d.txt命名。
import argparse import numpy as np import os import pandas as pd import cv2 from skimage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63a3342230dd06e0ab8fae9e1fe598aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92bf7c5cef73f988b9db1025a20965f0/" rel="bookmark">
			JDK8中JPA使用LocalDate, LocalTime 和 LocalDateTime会报反序列错误解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring-boot在使用spring-data-jpa时，如果需要对LocalDate、LocalDateTime等在jsr310中定义的新日期类进行支持，需要在启动类或带有@Configuration的类上加入以下注解： import org.springframework.boot.autoconfigure.domain.EntityScan; import org.springframework.cloud.stream.annotation.StreamListener; import org.springframework.data.jpa.convert.threeten.Jsr310JpaConverters; @EntityScan( basePackageClasses = {ServicePromotionApplication.class, Jsr310JpaConverters.class} ) public class ServicePromotionApplication { public static void main(String[] args) { SpringApplication.run(ServicePromotionApplication.class, args); } @StreamListener(PromotionCacheProcessor.SYNC_CACHE) public void syncPromotionCache(Message&lt;PromotionNoticeVo&gt; message) { log.info("接收到Spring Cloud Stream消息: {}", message); long t1 = System.currentTimeMillis(); promotionCacheService.loadCache(message.getPayload().getPromotionType()); long t2 = System.currentTimeMillis(); log.info("处理消息结束, 耗时: {}ms", t2 - t1); } @StreamListener(PromotionCacheProcessor.SYNC_RECEIVED) public void syncPromotionReceived(Message&lt;PromotionNoticeVo&gt; message) { log.info("接收到Spring Cloud Stream消息: {}", message); long t1 = System.currentTimeMillis(); promotionCacheService.loadCache(message.getPayload().getPromotionType()); long t2 = System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92bf7c5cef73f988b9db1025a20965f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f279d013ceee016bfd80d8396422ec0/" rel="bookmark">
			C#方法的重载 重写 覆盖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.方法的重载一般发生在类内部,同样的方法名,有不同的参数与返回类型, 2.方法的重写发生在子类对于父类抽象方法/虚方法的重写,重写的方法都有前缀override,父类一旦包含抽象方法,必然为抽象类,包含虚方法可以为普通类,当然静态类中也可以有有普通的方法.方法的重写一般会碰到实例化调用方法的问题. 例如:当子类Son重写(override)了父类的hit()方法时
(1)
Parent p=new Parent();
p.hit(); 执行父类方法
(2)
Parent p=new Son();
p.hit(); 执行子类方法
(3)
Son s=new Son();
s.hit(); 执行子类方法
(4)
Son s=new Parent(); 注意此种情况是不存在的 不可能通过new父类返回一个子类
s.hit();无效
对比 (2)(4)两种情况我们分析下 new son()可以被降级为Parent的实例这个很好理解 因为Son基于继承关系中肯定有所有Parent中的方法,这也很好的解释(4)为何不存在,因为new Parent()产生的实例未必会包含子类自己扩展出的方法,所以写法违法. 3.对于(2)中执行子类的方法 则可以对比重写与覆盖的区别 子类对父类方法的重写(override)当Parent的实例是通过new Son()产生时,会第一时间去子类中找对应的方法,如果此方法在父类中是个虚方法,则子类可能没有重写,在子类中找不到时才会去父类中寻找. 例如:当子类Son覆盖(new)了父类的hit()方法时
(1)
Parent p=new Parent();
p.hit(); 执行父类方法
(2)
Parent p=new Son();
p.hit(); 执行父类方法
(3)
Son s=new Son();
s.hit(); 执行子类方法
(4)
Son s=new Parent(); 注意此种情况是不存在的 不可能通过new父类返回一个子类
s.hit();无效
回顾下构造函数的子父类的执行关系: public class Parent { private void Start() { } private void Update() { } public Parent() { Test(); } protected virtual void Test() { Debug.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f279d013ceee016bfd80d8396422ec0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0032e199080d8c21a76ea48d7dafa004/" rel="bookmark">
			Android Sdk安装和环境变量配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Sdk安装Android Sdk环境变量配置参考：https://blog.csdn.net/qq_21454973/article/details/80429545 一：Android Sdk安装
下载Android SDK（Software Development Kit）
Google Android的官网上下载（http://developer.android.com/sdk/index.html），好像要翻墙，为了节省时间，我就选择了这个网址
https://www.androiddevtools.cn/
选择一个最新的版本就行了。注意，这里有exe和zip两种文件可供下载，exe的就是个安装程序，下载下来需要自己双击安装。这里建议下载zip压缩包，下载后，直接解压缩到你想要安装Android的路径就行了。解压后的文件目录如下：
解压后的样子
双击“SDK Manager.exe”，弹出这个
有几个必须要安装的，如上图所示的，Tools文件夹里面的Android SDK Tools（这个我们在之前的一步已经下载好了的，一般不会让你再安装了，不过有可能会让你更新），然后就是Android SDK Platform-tools和Android SDKBuild-tools，注意只需要下载最新的版本就行了
然后就是API的选择了。这里提供了Android 2.2到Android 5.x的很多版本的API，新手直接选一个最新的就算了，因为Android是向下兼容的。其他的以后你要用到了在下载就行了（因为下载安装的速度实在太慢）
如果你选择其他，比如我选择的是8.0，那你要把默认选择的那个最新的勾掉
这里需要说明的是，如果你以后不打算用模拟器调试，而是一直用真机来调试的话，那么就可以不用装“system images“了。不过新手的话，不知道怎么选择，还是建议直接全部勾上吧
最后就是extras文件夹中的东西了
理论上来说，extras中的东西如果网速允许，时间充沛的话，就都下载了吧，应为都是好东西。不过一开始安装的话，可以只用安装上图中的三个，即Android Support Repository、Android SupportLibrary和Google USB Driver
点了ok后，发现有没安装成功的，虽然这次只是图片，但是如果下次是其他的怎么办？
这种时候，我们可以通过有Android SDK的国内镜像服务器来下载安装，这里推荐几个：
1、中科院开源协会镜像站地址: IPV4/IPV6 : http://mirrors.opencas.ac.cn 端口：80 2、北京化工大学镜像服务器地址： IPv4: http://ubuntu.buct.edu.cn/ 端口：80 IPv4: http://ubuntu.buct.cn/ 端口：80 IPv6: http://ubuntu.buct6.edu.cn/ 端口：80 3、大连东软信息学院镜像服务器地址: http://mirrors.neusoft.edu.cn 端口：80 注：镜像粘贴的时候不要带http://
我选择的是第三个站点，即大连东软的镜像，使用方法如下：
再次点击安装，发现这两个图片还是没安装上，这样的话那就算了吧
二：Android Sdk环境变量配置
新建一个系统环境变量，变量名为ANDROID_SDK_HOME，变量值为你的SDK安装路径
我把它放在了用户变量里面了
然后就是在系统的Path变量后，追加
;%ANDROID_SDK_HOME%\platform-tools;%ANDROID_SDK_HOME%\tools 注意，如果你原来变量最后面有；了，那就不用再加；了 追加完后查看一下：
检验一下Android SDK是否安装成功（管理员身份）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0032e199080d8c21a76ea48d7dafa004/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3834b815c56d2b4abca724db1aa1b866/" rel="bookmark">
			MNIST是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初始的迷茫 我想很多菜鸟和我一样，开始零基础学习机器学习，没办法火啊，为了钱大家都是冲呀。估计很多人开始学习ML，就一头雾水，完全不知道在说什么。因为学习模式和学习其他语言完全不同，我们知道学习其他语言的时候，第一个程序就是打印“Hello World”。
其实机器学习是在某个框架下，使用某种语言，来解决问题。因此对于零基础的菜鸟而言，我们需要先学习好某种语言，可以推荐Python，因为功能强大，而且语法相对简单，也可以使用C++。框架呢，个人推荐是TensorFlow2，因为google的大腿粗啊。
什么是MNIST 建议在了解Python后，开始在TF2的框架下进行。
机器学习的入门就是MNIST。MNIST 数据集来自美国国家标准与技术研究所，是NIST（National Institute of Standards and Technology）的缩小版，训练集（training set）由来自 250 个不同人手写的数字构成，其中 50% 是高中学生，50% 来自人口普查局（the Census Bureau）的工作人员，测试集（test set）也是同样比例的手写数字数据。
获取MNIST MNIST 数据集可在http://yann.lecun.com/exdb/mnist/获取，图片是以字节的形式进行存储，它包含了四个部分：
Training set images: train-images-idx3-ubyte.gz (9.9 MB, 解压后 47 MB, 包含 60,000 个样本) Training set labels: train-labels-idx1-ubyte.gz (29 KB, 解压后 60 KB, 包含 60,000 个标签) Test set images: t10k-images-idx3-ubyte.gz (1.6 MB, 解压后 7.8 MB, 包含 10,000 个样本) Test set labels: t10k-labels-idx1-ubyte.gz (5KB, 解压后 10 KB, 包含 10,000 个标签) 此数据集中，训练样本：共60000个，其中55000个用于训练，另外5000个用于验证。测试样本：共10000个，验证数据比例相同。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3834b815c56d2b4abca724db1aa1b866/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0a31e1da4c6b7129e31c6158cf6b46b/" rel="bookmark">
			java记录方法计时工具类StopWatch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import org.springframework.util.StopWatch; public static void main(String[] args) throws InterruptedException { StopWatch sw = new StopWatch("测试计时工具类StopWatch"); sw.start("第一次计时"); Thread.sleep(100); sw.stop(); sw.start("第二次计时"); Thread.sleep(200); sw.stop(); System.out.println(sw.prettyPrint()); } 输出结果如下:
StopWatch ‘测试计时工具类StopWatch’: running time (millis) = 302
ms%Task name00101033%第一次计时00201067%第二次计时 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0d5f4b5dd5f60c47409b52a0895d045/" rel="bookmark">
			window caffe训练卡在Loading mean file from: ming_mean.binaryproto不动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 现象如图所示： 原因：自己疏忽在train和test阶段的source全部设置成了mtrainldb(如下图所示)，造成数据锁死情况。修改test的source为即可。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c250efee321b79b2876f12f32084683/" rel="bookmark">
			namespace什么意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		namespace其实就是一个名称空间，相当于一个类，里面含有很多已经定义过的函数，如果要用到一个在名称空间里面的函数，就需要通过函数所在名称空间的名字（如std）+“：：”+函数名的方式访问，如：
int c=std::min(a,b);//求解a与b的最小值 std::cout&lt;&lt;c; 也可以在代码开始时加上下面这一句话这样的话之后就不需要再添加std::了
using namespace std; 接下来教大家写一个自己的namespace
我在下面写了一个名叫myfunction的名称空间，里面写了一个min函数，还写了using std::，min函数大家都能理解，这个的std::的意思就是在之后在用到cin等函数时不需要加std::.名称空间写完后，就可以像下面一样调用了。
namespace myfunction{ int min(int a,int b){ return a&lt;b?a:b; } using std::cin; using std::cout; using std::endl; using std::string; using std::map; } #include&lt;iostream&gt; #include&lt;map&gt; #include&lt;iomanip&gt; namespace myfunction{ int min(int a,int b){ return a&lt;b?a:b; } using std::cin; using std::cout; using std::endl; using std::string; using std::map; } using namespace myfunction; int main(){ int c=min(1,2); cout&lt;&lt;c; } 上述程序便可以正常的输出结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/334515adc062dacff21aec1379b31cbf/" rel="bookmark">
			Windows下配置NoVNC过程（支持一拖多）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows下配置NoVNC过程（支持一拖多） 实现目标工具具体过程 实现目标 在windows下使用vnc协议可以通过浏览器访问服务端桌面，并且使用token可以一拖多。
工具 windows server2008中转服务器一台TightVNC服务端Node.js(https://nodejs.org/en/download)noVNC(https://github.com/novnc/noVNC)Websockify(https://github.com/novnc/websockify/wiki)Python3.7(https://www.python.org/downloads/release/python-370/) 具体过程 安装TightVNC Server并开启服务安装Node.js安装Python3.7在C:\Users\think\node_modules\noVNC下创建vnc_tokens文件 target1: 192.168.0.151:5900
target2: 192.168.0.152:5900
启动vnc cd C:\Users\think\node_modules\noVNC\websockify-master
py websockify.py --web ./ --target-config=./vnc_tokens 6080
下面大家可以试试用vnc客户端或浏览器直接访问服务！
访问地址：
http://服务器ip:服务器端口/novnc/vnc_lite.html?path=websockify/?token=target序号&amp;password=密码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8aeecd4552c7aaa4241111d603965f7a/" rel="bookmark">
			第八课（JDBC）-- 创建一个用户类（Tuser）以及创建一个向数据库中插入新用户数据的类（TuserDAO）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用主线在于做出一个用户的注册和登陆界面，当然是要和后端的数据库连接的，注册时往数据库中写入用户数据，登陆时通过读出数据库中用户信息进行对比，判断该用户是否为合法用户
首先通过在数据库中已经建立的表的结构，将用户数据抽象为一个类，命名为Tuser
package tools; public class Tuser { int userid; String username; String password; public int getUserid() { return userid; } public void setUserid(int userid) { this.userid = userid; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } 在其他的类中通过该类的相关属性的get/set方法来设置该用户类实例化之后的属性值
以下为通过创建以上定义的用户类向数据库中插入新用户数据的类TuserDAO，该类通过调用上一课中创建的连接数据库的工具类DBconn以及实例化上述用户类Tuser，来实现先连接数据库，再向其中插入实例化Tuser类之后的用户数据
package tools; //DAO为database access object的缩写 import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8aeecd4552c7aaa4241111d603965f7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3cc376b771c0685e026cee5de248069/" rel="bookmark">
			python-问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		can't multiply sequence by non-int of type 'str'invalid decimal literalValueError: math domain errormissing whitespace after ‘,’missing whitespace around operatorno newline at end of filePEP 8: expected 2 blank lines after class or function definition, found 1This dictionary creation could be rewritten as a dictionary literal （标题）can't multiply sequence by non-int of type 'str'
通过键盘输入返回值的类型是字符串，要进行数学运算要强制转换
//像java这样：int a在这里是无效语法 //可以这样（两种方式都可以） 1：a = int(input('请输入乘数:')) 2：int(a)*int(b) （标题）invalid decimal literal
翻译了一下：十进制文本无效
这里犯了个打错，变量的命名规则呀，不能数字开头
（标题）ValueError: math domain error
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3cc376b771c0685e026cee5de248069/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a66dedd525cdd5bfe0869af35f3c7ebb/" rel="bookmark">
			【转载】奇异值分解(SVD)计算过程示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原文链接：https://byjiang.com/2017/11/18/SVD/ 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/101/">«</a>
	<span class="pagination__item pagination__item--current">102/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/103/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>