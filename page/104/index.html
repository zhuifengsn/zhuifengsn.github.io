<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e285f82410dbdf4b11d97fd15ca21d51/" rel="bookmark">
			java.lang.UnsatisfiedLinkError: dalvik.system.PathClassLoader[DexPathList[[zip file .
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在开发项目出现了.so应用不到的问题，查了一下项目并没有问题，Google 发现是应用了Fresco 引起的，原因是：
Fresce 应用so 库会根据CPU的类型查找.SO库，当使用cpu类型为64位，就不会再往下查找.SO。报以下错误
java.lang.UnsatisfiedLinkError: dalvik.system.PathClassLoader[DexPathList[[zip file "/data/app/xxx-1/base.apk"],nativeLibraryDirectories=[/data/app/xxxx-1/lib/arm64, /vendor/lib64, /system/lib64]]] couldn't find "xxx.so"
解决这个问题：
在build.gradle中加入
android { splits { abi { enable true reset() include 'x86', 'x86_64', 'armeabi-v7a', 'armeabi' universalApk false } } 参考资料：http://frescolib.org/docs/multiple-apks.html#_
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b9c723359f0e67e6ac2e29e43181c3e/" rel="bookmark">
			Mac模拟慢速网络（基于Xcode10） - Network Link Conditioner
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近为了测试app极端网络环境的反馈结果，在网上找了很多资料，发现大多数关于Network Link Conditioner的使用安装比较旧，安装之后无法起到效果，所以重新整理了一份，建议Network Link Conditioner工具版本号与Xcode版本号保持一致
在Xcode4.1中有一个工具叫Network Link Conditioner，可以让用户模拟不同的网络连接和带宽，可供Mac和iOS开发者测试自己的程序在不同网络环境下的表现。
在Xcode4.3之后，此工具不再随Xcode工具提供，需要单独下载。在Xcode10中通过Xcode-&gt;Open Developer Tool-&gt;More Developer Tools…菜单
image.png
可进入Apple开发者下载中心，Network Link Conditioner包含在Hardware IO Tools中，但在Xcode7.3之后版本Hardware IO 包含在工具Additional Tools包中，点击下载。
image.png
下载安装后，可看到其中有一个Hardware,进入后就能见到Network Link Conditioner.prefPane文件。
image.png
image.png
点击运行Network Link Conditioner.prefPane后，Network Link Conditioner就会被添加到系统偏好设置的其他分类中。
image.png
image.png
点击打开，Network Link Conditioner界面为
image.png
在Profile中包含预置的几种网络环境，包含3G,DSL,Edge,Wifi，每种网络环境对应不同的上下行带宽，丢包率和网络延迟,DNS延迟。
image.png
还可以根据需要自定义不同的网络环境，点击左下角锁按钮输入系统密码解锁后，右侧Manage Profiles…就变为可用，点击后可进入管理Profiles窗口,在其中可定义自己需要的Profile.
image.png
把ON/OFF按钮滑动到ON,即启动了网络模拟器。
image.png
启动Network Link Conditioner就可以使用iOS模拟器测试APP在此种环境下的运行情况了。
在测试完毕时，记得停止Network Link Conditioner，Network Link Conditioners是对整个系统有效的，普通上网的速度也会被限制。
真机调试时模拟网速 真机调试时模拟网速更加方便，在iPhone设置里，选择开发者-&gt;Status 这个就是网速模拟，选择好模式记得选择Enable打开。
IMG_1673.jpg
IM
iOS系统有个模拟慢速网络测试的好帮手 刚进公司的时候，被分配在一个物流项目组负责iOS系统下App的测试。该App中有一个主要功能是车辆到达目的地的时候，需要在App里显示一个对应的状态并开始计时。测试过程中，总会碰到几次后台服务里单子的状态变了，但App里的单子依然停留在前一个状态，并且计时还不准确！在这个Bug被重复开关N次后，开发确定地说是网络问题，那么测试人员要怎么办，,怎样才能更加准确的了解在不同网络状况下用户使用App时的表现呢？这时候就需要来一次模拟不同网络环境下的App测试了。
常用的模拟弱网的第三方软件比如：Charles，Fiddler，NetworkEmulator Toolkit等。如果设备没有安装这些软件，那么对于iOS系统的设备来说还有一种方法，就是利用自带的“开发者”来模拟不同网络的测试。
这里简单介绍一下使用步骤：
打开iOS系统设备，进入 设置➔ 开发者➔ Network Link Conditioner(on)➔ Enable(on)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b9c723359f0e67e6ac2e29e43181c3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2072390c28071420d99bcfe38ba10ac4/" rel="bookmark">
			01背包和完全背包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01背包
int main() { //01背包，time==》V 分数等于价值，时间等于体积 int size; cin &gt;&gt; size; vector&lt;int&gt; w; w.resize(size + 1, 0); vector&lt;int&gt; v; v.resize(size + 1, 0); vector&lt;int&gt; dp; for (int i = 1; i &lt;= size; i++) { int temp; cin &gt;&gt; temp; v[i] = temp; } for (int i = 1; i &lt;= size; i++) { int temp; cin &gt;&gt; temp; w[i] = temp; } int weight = 10; //cin &gt;&gt; weight; dp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2072390c28071420d99bcfe38ba10ac4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45ab57e53c06f253c19e3f0dbe52bbc0/" rel="bookmark">
			第一课--jsp文件创建与运行--hello world
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这学期开始学习JSP&amp;Servlet，昨天上了第一节课，教我们在myeclipse中创建jsp文件以及运行第一个jsp文件--helloworld.jsp，以下为学习总结，经供参考：
首先打开MyEclipse 2019
首先new一个web project，创建好名字，例如：helloworld 在设置好工程名字后记得点击next，到以下界面: 如果想在创建好的工程中找到web.xml的话就勾选第二个复选框
单击finish完成工程创建： 展开工程可以看到可以在工程下找到web.xml以及index.xml
创建第一个jsp文件—helloworld。一般将jsp文件创建在src-&gt;main-&gt;webapp下面，可以直接在该目录下创建，也可以在该目录下创建一个文件夹用来集中管理你创建的jsp文件 如图new了一个新文件夹：helloworld
再在该文件夹下new一个新的jsp文件：
单击finish完成创建
创建好之后会自带如下图的内容：
在该图中自需要我们将 This is my JSP page.改写为 Hello World！即可：
保存文件
将写好的项目加载到tomcat9.0上： 单击控制台中的servers：
右键tomcat 9.0
单击add/remove Deployments..
左边是在myeclipse中检测到还未添加到tomcat服务器上的工程，右边是已经加入到tomcat服务器上的工程，单击左边你想要加入的工程点击add，若有多个项目想要加入，则直接点击add all即可
单击finish完成添加
将控制台中的tomcat下拉菜单展开，可以看到刚刚的helloworld项目已经部署到tomcat服务器上去了
检验结果： 启动tomcat服务器：右键控制台的tomcat点击start即可
等待服务器启动之后，打开浏览器，在地址栏中输入：localhost:8080，跳转至以下页面说明tomcat服务器启动成功：
之后在地址栏输入：http://localhost:8080/helloworld/helloworld/helloworld.jsp
即可跳转至刚刚写的第一个jsp程序—helloworld.jsp啦：
注：若在myeclipse中保存helloworld.jsp时报错：
这是因为文件的编码方式的问题
解决：将文件第一行：&lt;%@ page language="java" import="java.util.*" pageEncoding="ISO-8859-1"%&gt; 中的 "ISO-8859-1 改为 GBK 即可
千万不要点击Save as UTF-8 !!!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a5e837db6bc865c8f989b4e0567012e/" rel="bookmark">
			网络安全传输系统(5)—账号管理子系统设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.登录模块设计
输入用户名和密码根据用户名从数据库提取密码比较用户输入密码和数据库提取密码，以决定是否登录成功 2.编译客户端程序
arm-linux-gcc-L ../../008/openssl-1.0.0s/_install/lib/ -lssl -lcrypto-I ../../008/openssl-1.0.0s/_install/include/-L ../../010/sqlite-autoconf-3070800/_install/lib/ -lsqlite3-I ../../010/sqlite-autoconf-3070800/_install/include/client.c -o client 3.创建数据库
./test_db user.db "create table tb0(name varchar(10),passwd varchar(10));". 4.插入数据
./test_db user.db "insert into tb0 values('xxx','123');"./test_db user.db "insert into tb0 values('xxx','456');"./test_db user.db "insert into tb0 values('xxx','789');" 5.改进的客户端代码
#include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;netinet/in.h&gt; #include &lt;sys/socket.h&gt; #include &lt;sys/stat.h&gt; #include &lt;errno.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;string.h&gt; #include &lt;openssl/ssl.h&gt; #include &lt;openssl/err.h&gt; #include &lt;sqlite3.h&gt; #define port 3333 int sockclient; struct sockaddr_in sockaddr1; char ipaddr[15]; SSL_CTX *ctx; SSL *ssl; int linkS() {	if((sockclient=socket(AF_INET,SOCK_STREAM,0))==-1) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a5e837db6bc865c8f989b4e0567012e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ee8f7d4cdfb49d93a7105c27d6c6222/" rel="bookmark">
			网络安全传输系统(4)—线程池优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器单发模式 初始化-&gt;等待连接-&gt;处理请求-&gt;关闭连接-&gt;再次等待连接服务器并发模式 初始化-&gt;等待连接-&gt;交给子进程处理请求-&gt;再次等待连接单发服务器不能同时处理多个客户端请求，并发服务器则可以同时处理多个客户端请求。并发服务器一般通过创建线程来处理多个客户端请求。当处理的客户端到达上万个时，不断的创建和销毁线程对服务器是一笔很大的开销。通过线程池技术，预先创建大量线程。在使用时直接从线程池中取出，用完后放回线程池。这样就可以大大减少对线程的创建和销毁开销。 1.线程池工作原理
线程池就是有一堆已经创建好了的线程，当有新的任务需要处理的时候，就从这个池子里面取出一个空闲等待的线程来处理该任务，当处理完成了就再次把该线程放回池中，以供后面的任务再次使用，当池子里面的线程全都处理忙碌状态时，这时新到来的任务需要稍作等待。线程的创建和销毁比之进程的创建和销毁是轻量级的，但是当我们的任务需要大量进行大量线程的创建和销毁操作时，这个消耗就会变的相当大。线程池的好处就在于线程复用，当一个任务处理完成后，当前线程可以继续处理下一个任务，而不是销毁后再创建，非常适用于连续产生大量并发任务的场合。 2.线程池的实现
先采用一个结构体来描述线程池 /*线程池结构*/ typedef struct { pthread_mutex_t queue_lock; pthread_cond_t queue_ready; /*链表结构，线程池中所有等待任务*/ Cthread_task *queue_head; /*是否销毁线程池*/ int shutdown; /*存放线程id的指针*/ pthread_t *threadid; /*线程池中线程数目*/ int max_thread_num; /*当前等待的任务数*/ int cur_task_size; } Cthread_pool; 这里采用一个链表来保存线程池中等待的任务，当有新任务加入则唤醒一个线程，取下头结点的任务，然后开始工作。如果当前没有任务，则所有的线程都在睡觉，等待新任务加入然后被唤醒。每个任务也采用一个结构体来保存 typedef struct task { //任务需要执行的函数 void *(*process) (void *arg); //执行函数的参数 void *arg; //下一个任务的地址 struct task *next; } Cthread_task; 对线程池进行初始化，主要完成对参数的初始化和创建线程，在线程创建时需要调用下面的线程运行函数： static Cthread_pool *pool = NULL; void pool_init (int max_thread_num) { int i = 0; pool = (Cthread_pool *) malloc (sizeof (Cthread_pool)); pthread_mutex_init (&amp;(pool-&gt;queue_lock), NULL); /*初始化条件变量*/ pthread_cond_init (&amp;(pool-&gt;queue_ready), NULL); //没有任务，头结点为空 pool-&gt;queue_head = NULL; //最大线程个数 pool-&gt;max_thread_num = max_thread_num; //现在任务为0 pool-&gt;cur_task_size = 0; //线程池开始工作 pool-&gt;shutdown = 0; //申请存放线程池id的数组 pool-&gt;threadid = (pthread_t *) malloc (max_thread_num * sizeof (pthread_t)); for (i = 0; i &lt; max_thread_num; i++) { //创建线程，线程属性为空，参数也设置为空 pthread_create (&amp;(pool-&gt;threadid[i]), NULL, thread_routine, NULL); } } 线程运行函数，线程运行函数编程遵循如下步骤： 如果当前没有任务，线程被阻塞，等待任务加入唤醒线程如果有任务加入，线程会被唤醒，需要取下链表的头任务并对相应的参数做修改，注意这里需要加上互斥锁，最后运行任务函数。如果线程池要销毁了，需要做相应的操作。 void * thread_routine (void *arg) { printf ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ee8f7d4cdfb49d93a7105c27d6c6222/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47f597723bad394f249ec1a5604e0ffa/" rel="bookmark">
			(九) SQL CREATE 语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL CREATE DATABASE 语句 CREATE DATABASE 语句用于创建数据库。
SQL CREATE DATABASE 语法 CREATE DATABASE dbname; //dbname 是新的数据库名字 SQL CREATE TABLE 语句 CREATE TABLE 语句用于创建数据库中的表。
表由行和列组成，每个表都必须有个表名。
CREATE TABLE table_name ( column_name1 data_type(size), column_name2 data_type(size), column_name3 data_type(size), .... ); column_name 参数规定表中列的名称。
data_type 参数规定列的数据类型（例如 varchar、integer、decimal、date 等等）。
size 参数规定表中列的最大长度。
SQL CREATE INDEX 语句 CREATE INDEX 语句用于在表中创建索引。
在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。
您可以在表中创建索引，以便更加快速高效地查询数据。
用户无法看到索引，它们只能被用来加速搜索/查询。
注意：更新一个包含索引的表需要比更新一个没有索引的表花费更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。
SQL CREATE INDEX 语法 在表上创建一个简单的索引。允许使用重复的值：
CREATE INDEX index_name ON table_name (column_name) SQL CREATE UNIQUE INDEX 语法 在表上创建一个唯一的索引。不允许使用重复的值：唯一的索引意味着两个行不能拥有相同的索引值。Creates a unique index on a table.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47f597723bad394f249ec1a5604e0ffa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d93784bfc372942312b764e784866f3/" rel="bookmark">
			动态规划（最长公共序列，最长上升序列）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在牛客网上刷面经的过程中，发现面试常问的两道题，这里记录下来，方便以后复习查看。
并分别在 poj 1458 2533 AC!
#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #define N 1005 using namespace std; int dp[N][N]; /* dp[i][j]表示 P1[1...i]与 P2[1...j]的最长公共子序列LCS 初始状态：某一个排列为空，那么LCS肯定为0，故很容易推断出 dp[0][1..n]=0, dp[1..n][0] 1、if P1[n]==P2[n]，则 dp[n][n]=dp[n-1][n-1] + 1 2、if P1[n]!=P2[n], 则 dp[n][n] = max(dp[n][n-1], dp[n-1][n]) Tips: 为了提高效率，采用自底向上计算的方法。 也即先计算dp[1][1]... 最后计算dp[n][n]，因为dp[n][n]肯定要用到之前的状态嘛 */ int solve(string p1, string p2, int p1_len, int p2_len){ for(int i=1;i&lt;=p1_len;i++){ for(int j=1;j&lt;=p2_len;j++){ if(p1[i-1]==p2[j-1]){ dp[i][j] = dp[i-1][j-1] + 1; }else{ dp[i][j] = max(dp[i-1][j], dp[i][j-1]); } } } return dp[p1_len][p2_len]; } int main(){ string p1, p2; while(cin&gt;&gt;p1&gt;&gt;p2){ memset(dp, 0, sizeof(dp)); int p1_len = p1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d93784bfc372942312b764e784866f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7c3529016d3b23dcfcaf3847a9046fd/" rel="bookmark">
			网络安全传输系统(3)—OpenSSL加密传输
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.基本介绍
1.1 未加密传输的安全弊端
如果在网络传输中没有加密，就是以明文传输。传输的数据可以被抓包软件直接截获，并能读取里面的数据。 1.2 加密基本原理
对称加密：对称加密指的就是加密和解密使用同一个秘钥，所以叫做对称加密。对称加密只有一个秘钥，作为私钥。常见的对称加密算法：DES，AES，3DES等等。非对称加密：加密和解密使用不同的秘钥，一把作为公开的公钥，另一把作为私钥。公钥加密的信息，只有私钥才能解密。私钥加密的信息，只有公钥才能解密。 常见的非对称加密算法：RSA，ECC公钥私钥：公钥和私密要配对。公钥加密的数据用私钥来解密，私钥加密的数据用公钥来解密。 1.3 数字证书
当公钥被替换成别的公钥之后，替换前对应的私钥就不能解密了，只能用替换后对应的私钥解密，但是并不能判断公钥是否被替换，所以引入数据证书的概念。数字证书由权威机构发布，所以无法伪造。并且数字证书里面包含公钥和对应所有者信息，所以就可以判断公钥是否属于自己。 1.4 SSL协议
网络传输中有很多加密技术，有DES、AES、RSA、SSL等，我们这里采用OpenSSL的开源加密算法。 SSL协议位于TCP/IP协议与各种应用层协议之间，利用数据加密技术，可以确保数据在网络上传输过程中不会被截取及窃听。SSL协议可分为两层： SSL记录协议(SSL Record Protocol)：它建立在可靠的传输协议(TCP)之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL握手协议(SSL Handshake Protocol)：它建立在SSL记录协议之上，用于实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。OpenSSL：OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。 2.OpenSSL移植
移植OpenSSL库到开发板 2.1 解压
tar zxvf openssl-1.0.0s.tar.gz 2.2 配置
mkdir _install./config no-asm shared –prefix=${PWD}/_install （no-asm表示在编译过程中不要使用汇编代码加快编译过程） 2.3 修改Makefile
CC = arm-linux-gccAR = arm-linux-arRANLIB = arm-linux-ranlib 2.4 编译
make 2.5 安装
make install 生成的库文件在_install/lib中，拷贝到开发根目录/lib中。
3.OpenSSL编程
在TCP传输文件框架上，增加OpenSSL加密系统，需要遵循如下的编程步骤客户端模型：1.初始化；2.创建SSL；3.数据收发；4.关闭 服务器模型：1.初始化；2.载入数字证书和私钥；3.创建SSL；4.数据收发；5.关闭 创建私钥：# openssl genrsa -out privkey.pem 2048，genrsa表示创建私钥，privkey.pem输出私钥文件名，2048表示位数创建公钥：# openssl req -new -x509 -key privkey.pem -out cacert.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7c3529016d3b23dcfcaf3847a9046fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d266d752cb0bb36c32577b44852185c/" rel="bookmark">
			C&#43;&#43; sizeof(struct)计算结构体大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、sizeof() 在学习C++的时候会学到一个sizeof操作符，在 C 语言中，sizeof() 是一个判断数据类型或者表达式长度的运算符。单位是位（byte）。
我们都知道char、short、int、long、float、double的大小；
二、结构体的大小 定义一个结构体：
struct stru{ char a; int b; float c; double d; }; cout &lt;&lt; "struct: " &lt;&lt; sizeof(stru) &lt;&lt; " 字节" &lt;&lt; endl; 请问输出是什么？
可能你是这么想的： sizeof(stru) = sizeof(a) + sizeof(b) + sizeof(c) + sizeof(d) = 1 + 4 + 4 + 8 = 17;
实际上并不是这样的。
在计算结构体大小的时候存在对齐的问题
类型 对齐方式（变量存放的起始地址相对于结构的起始地址的偏移量） Char 偏移量必须为sizeof(char)即1的倍数 Short 偏移量必须为sizeof(short)即2的倍数 int 偏移量必须为sizeof(int)即4的倍数 float 偏移量必须为sizeof(float)即4的倍数 double 偏移量必须为sizeof(double)即8的倍数 偏移量指的是结构体变量中成员的地址和结构体变量地址的差。结构体大小等于最后一个成员的偏移量加上最后一个成员的大小。
然而，在实际中，存储变量时地址要求对齐，编译器在编译程序时会遵循两条原则： （1）结构体变量中成员的偏移量必须是成员大小的整数倍（0被认为是任何数的整数倍） （2）结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数。 下面详细讲解：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d266d752cb0bb36c32577b44852185c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbf82057c1190c57e98fb8d85073f407/" rel="bookmark">
			滴滴笔试--算术转移（20190827）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述： 给出一个仅包含加减乘除四种运算符的算式(不含括号)，如1+2*3/4，在保持运算符顺序不变的情况下，现在你可以进行若干次如下操作：如果交换相邻的两个数，表达式值不变，那么你就可以交换这两个数。 现在你可以进行任意次操作，使得算式的数字序列字典序最小，然后输出结果，数字之间的字典序定义为若a&lt;b则a的字典序小于b。 输入 第一行包含一个整数n，表示算式的长度，即包含n个数字和n-1个运算符。(1≤n≤100000)。 第二行包含一个含有n个非0整数和n-1个运算符的算式，整数与运算符用空格隔开，运算符包括“+，-，*，/”，整数的绝对值不超过1000。 输出 按要求输出字典序最小的表达式，数字与符号之间用空格隔开。 样例输入 6 3 + 2 + 1 + -4 * -5 + 1 样例输出 1 + 2 + 3 + -5 * -4 + 1 思路：参考自
先用两个数组来存储数字（opNum）和这个数字之前的操作符（opChar）。其中ops第一个元素固定是'+'，因为第一个数没有符号。例如样例就会得到如下的两个数组： 索引 0 1 2 3 4 5 nums 3 2 1 -4 -5 1 ops + + + + * + 接着用两个指针 l 和 r，一段一段地找ops中连续的操作符，例如样例中就会得出“l=0,r=3; l=4,r=4; l=5,r=5”三段。 接着根据一套规则来确定 l 和 r 区间内哪些元素是需要进行排序，以实现字典序最小： 如果ops[l]是加号或减号 这段区间下一个操作符是'*'或者‘/’，那么要排序的区间是[l, r-1]； 想想类似5+4+3+2+1*5的情况 这段区间下一个操作符是'-'，那么要排序的区间是[l, r]；想想类似5+4+3+2+1-5的情况这里不需要考虑区间前一个操作符是*、/，-，要排序的区间肯定是[l, r]，可参考5*4+1+2+3的情况 (故2,3归为else语句即可） ops[l]是乘号 区间前一个操作符是'+'或者‘-’，那么要排序的区间是[l-1, r]；想想类似1+5*4*3*2*1的情况 区间前一个操作符是‘/’，那么要排序的区间是[l, r]；想想类似1/5*4*3*2*1的情况
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbf82057c1190c57e98fb8d85073f407/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2217abf5ab1bbf8201a91eaa534028e5/" rel="bookmark">
			监控日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.创建脚本存放目录，写脚本，给执行权限，改脚本存放目录的属主属组为zabbix 在客户端上进入根目录
[root@lwq-client ~]# cd /scripts/ //传入脚本log.py [root@lwq-client scripts]# ls check_swap.sh log.py zabbix.sh [root@lwq-client scripts]# chmod a+x log.py [root@lwq-client scripts]# chown -R zabbix.zabbix log.py [root@lwq-client scripts]# ll 总用量 12 -rwxr-xr-x. 1 zabbix zabbix 187 8月 25 09:50 check_swap.sh -rwxr-xr-x. 1 zabbix zabbix 1854 8月 25 10:27 log.py -rwxr-xr-x. 1 zabbix zabbix 126 8月 24 16:45 zabbix.sh //log.py脚本内容如下 #!/usr/bin/env python3 import sys import re def prePos(seekfile): global curpos try: cf = open(seekfile) except IOError: curpos = 0 return curpos except FileNotFoundError: curpos = 0 return curpos else: try: curpos = int(cf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2217abf5ab1bbf8201a91eaa534028e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dddb2e3ba5b23e74cf0ed840e6197e8/" rel="bookmark">
			架构整理-CentOS 7中KVM的安装与使用-CentOS 7中noVNC的安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、noVNC简介 noVNC 是一个 HTML5 VNC 客户端，采用 HTML 5 WebSockets, Canvas 和 JavaScript 实现，noVNC 被普遍用在各大云计算、虚拟机控制面板中，比如 OpenStack Dashboard 和 OpenNebula Sunstone 都用的是 noVNC。noVNC 采用 WebSockets 实现，但是目前大多数 VNC 服务器都不支持 WebSockets，所以 noVNC 是不能直接连接 VNC 服务器的，需要一个代理来做 WebSockets 和 TCP sockets 之间的转换。这个代理在 noVNC 的目录里，叫做 websockify。
二、noVNC的用途 noVNC用来实现在Linux和macOS的客户端系统中，对KVM虚拟机的远程界面访问。
三、需要注意的前提条件 1、确保关闭CentOS所有的防火墙
命令：
setenforce 0 或者执行：
vim /etc/sysconfig/selinux 将SELINUX=disabled，SELINUXTYPE=targeted，并重启操作系统
2、确保vncserver服务已开启，并能正常访问
四、解决方案 1、安装依赖软件包
命令：
yum install -y epel* git tigervnc-server 2、从github上克隆noVNC项目
命令：
git clone git://github.com/kanaka/noVNC 3、切换当前工作目录到noVNC/utils
命令：
cd ./noVNC/utils 4、创建一个安全的VNC连接的证书，并根据提示完成证书的创建
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dddb2e3ba5b23e74cf0ed840e6197e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b99246de4331629b0140e4c60e90811/" rel="bookmark">
			ZSH隐藏命令行前面的用户名和主机名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改vim ~/.zshrc文件,在文件底部增加
隐藏用户名和主机名 prompt_context() {} 只保留用户名，隐藏主机名 prompt_context() { if [[ "$USER" != "$DEFAULT_USER" || -n "$SSH_CLIENT" ]]; then prompt_segment black default "%(!.%{%F{yellow}%}.)$USER" fi } 只保留主机名，隐藏用户名 prompt_context() { if [[ "$USER" != "$DEFAULT_USER" || -n "$SSH_CLIENT" ]]; then prompt_segment black default "%(!.%{%F{yellow}%}.)$HOST" fi } 修改后记得执行 source ~/.zshrc
转载于:https://www.cnblogs.com/ilizhu/p/11390400.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c726731b17309649c7cec14638ee91e3/" rel="bookmark">
			Win10激活virtualenv问题及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Win10 上面激活virtualenv的时候
执行venv\scripts\activate 会报错
错误信息：
无法加载文件 D:...\venv\scripts\activate.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参
阅 http://go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。
所在位置 行:1 字符: 1
+ c:\Users\coloz\Desktop\servertest\iot\Scripts\activate.ps1
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ CategoryInfo : SecurityError: (:) []，PSSecurityException
+ FullyQualifiedErrorId : UnauthorizedAccess
原因：
为了安全起见，power shell不能运行脚本
解决办法：
使用管理员身份打开PowerShell，执行 Set-ExecutionPolicy -ExecutionPolicy UNRESTRICTED 开启脚本运行权限。
系统会询问你是否更改，选全是。
修改后，我们再重新打开Power Shell尝试激活虚拟环境，可以看到虚拟环境已经激活成功：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adc8184c8df7821456d7dea29e142153/" rel="bookmark">
			线段树和树状数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线段树、树状数组常用来解决区间上的更新以及求和问题。
梳理如下：
/***********线段树***********/ /* 1、build_tree() 2、update(int idx, int val) 3、query(int L, int R) */ #include&lt;iostream&gt; #include&lt;cstdio&gt; #define MAX_SIZE 1000 using namespace std; void build_tree(int arr[], int tree[], int node, int left, int right){ if(left == right){ tree[node] = arr[left]; }else{ int mid = (left + right) / 2; int left_node = 2 * node + 1; int right_node = 2 * node + 2; build_tree(arr, tree, left_node, left, mid); build_tree(arr, tree, right_node, mid+1, right); tree[node] = tree[left_node] + tree[right_node]; } } void update(int arr[], int tree[], int node, int left, int right, int idx, int val){ if(left == right){ tree[node] = val; arr[idx] = val; }else{ int mid = (left + right) / 2; int left_node = 2 * node + 1; int right_node = 2 * node + 2; if(idx&lt;=mid){ update(arr, tree, left_node, left, mid, idx, val); }else{ update(arr, tree, right_node, mid+1, right, idx, val); } tree[node] = tree[left_node] + tree[right_node]; } } int query(int arr[], int tree[], int node, int left, int right, int L, int R){ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adc8184c8df7821456d7dea29e142153/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eb140228fc91b4914b6fde2b3b9b92b/" rel="bookmark">
			iOS淘宝授权登录及跳转淘宝页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者公司是做淘客的，本文会介绍淘宝授权登录的介入流程，淘客返现等逻辑想要了解的可以看作者的其他文章，或者是私聊作者，qq号见个人资料。
1.注册APP 淘宝授权登录的SDK是阿里百川的不是淘宝的，有些开发者初次了解的时候可能有误解。阿里百川开放平台需要一个淘宝账号去登录，地址：https://baichuan.taobao.com。
淘宝授权登录及淘宝其他相关电商功能（领券、返现）都在电商服务里面，去电商服务里面注册APP信息。
2.集成SDK 用cocoapods集成SDK
#source ‘http://repo.baichuan-ios.taobao.com/baichuanSDK/AliBCSpecs.git’
pod ‘AlibcTradeSDK’
导入这个SDK的时候先切换一下源，不然会出现找不到SDK的情况。
3.初始化SDK 导入头文件
#import &lt;AlibabaAuthSDK/albbsdk.h&gt;
#import &lt;ShareSDK/ShareSDK.h&gt;
// 百川平台基础SDK初始化，加载并初始化各个业务能力插件 [[AlibcTradeSDK sharedInstance] asyncInitWithSuccess:^{ } failure:^(NSError *error) { //NSLog(@"Init failed: %@", error.description); }]; // 开发阶段打开日志开关，方便排查错误信息 //默认调试模式打开日志,release关闭,可以不调用下面的函数 [[AlibcTradeSDK sharedInstance] setDebugLogOpen:NO]; // 配置全局的淘客参数 //如果没有阿里妈妈的淘客账号,setTaokeParams函数需要调用 AlibcTradeTaokeParams *taokeParams = [[AlibcTradeTaokeParams alloc] init]; taokeParams.pid = kBaiChuanPID; //mm_XXXXX为你自己申请的阿里妈妈淘客pid [[AlibcTradeSDK sharedInstance] setTaokeParams:taokeParams]; //设置全局的app标识，在电商模块里等同于isv_code //没有申请过isv_code的接入方,默认不需要调用该函数 //[[AlibcTradeSDK sharedInstance] setISVCode:@"your_isv_code"]; // 设置全局配置，是否强制使用h5，若设置成yes，则跳转淘宝页面会用h5打开。 [[AlibcTradeSDK sharedInstance] setIsForceH5:NO]; 4.设置 URL Schemes URL Scheme为tbopen{AppKey},如tbopen123456
5.添加安全图片 注意文件名不能修改，不然会导致找不到文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2eb140228fc91b4914b6fde2b3b9b92b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fa762d3ba369ac7b7a96fa5f898eb55/" rel="bookmark">
			链表头结点存在的意义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、防止单链表是空的而设的.当链表为空的时候,带头结点的头指针就指向头结点.
2、是为了方便单链表的特殊操作,插入在表头或者删除第一个结点.这样就保持了单链表操作的统一性
/链表的 头点 插入法，即从第一个节点的位置 插入链表 func (l *List) Prepend(value interface{}) { node := NewNode(value) if l.Len() == 0 { //当链表为空的时候,初始化head， 然后收尾相连 l.Head = node l.Tail = l.Head } else { formerHead := l.Head formerHead.Prev = node node.Next = formerHead l.Head = node } l.Length++ } 3、单链表加上头结点之后，无论单链表是否为空，头指针始终指向头结点，因此空表和非空表的处理也统一了，不用每次都进行判空处理，提升了节点插入的性能。
4、对单链表的多数操作应明确对哪个结点以及该结点的前驱。不带头结点的链表对首元结点、中间结点分别处理等；而带头结点的链表因为有头结点，首元结点、中间结点的操作相同 ,从而减少分支，使算法变得简单 ,流程清晰。对单链表进行插入、删除操作时，如果在首元结点之前插入或删除的是首元结点，不带头结点的单链表需改变头指针的值，在C 算法的函数形参表中头指针一般使用指针的指针(在C+ +中使用引用 &amp;)；而带头结点的单链表不需改变头指针的值，函数参数表中头结点使用指针变量即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7e703f3ce0755ec409d36adebe73db1/" rel="bookmark">
			AndroidStudio项目一片报红，但是可以正常编译，运行没有错误的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 场景：
打开AndroidStudio后发现项目一片红，资源文件都点击不进去，很是可怕。试着运行了一下，结果成功编译通过，没有任何错误。但是代码还是一片红。
问题：
怎样解决AndroidStudio项目一片飘红，但是又没有错误的问题？
解决方案：
清理缓存即可！依次操作
File-&gt; Invalidate Caches/Restart -&gt; Invalidate and Restart 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c9835555ef4325b917cc45f4412b068/" rel="bookmark">
			SQL Server查询所有用户表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		select name from sysobjects where xtype='u' order by name
转载于:https://www.cnblogs.com/welcomer/p/5068323.html
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/103/">«</a>
	<span class="pagination__item pagination__item--current">104/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/105/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>