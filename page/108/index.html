<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a15c31b30bb4c9a0a7c0fea04baae904/" rel="bookmark">
			如何判断欠拟合、适度拟合、过拟合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以通过查看训练集误差和验证集误差，从而判断算法达到什么效果。通过衡量训练集和验证集的误差就可以得出不同结论。
1.欠拟合：
假定训练集误差是 15%，验证集误差是 16%。这样则说明算法并没有在训练集中得到很好的训练，如果训练集数据的拟合度不高，就是数据欠拟合，就可以说这种算法偏差比较高。也就是我们说的没有训练好。
相反，它对于验证集产生的结果是合理的，验证集中的错误率只比训练集的多了 1%，所以这种算法偏差高，因为它甚至不能拟合训练集。就更别提验证集了。
训练集和验证集的误差都较高，但相差很少——&gt;欠拟合
2.适度拟合
训练集误差是 0.5%，验证集误差是 1%，这样的结果偏差和方差都很低，说明训练效果很好，这是我们想要的结果。
训练集和验证集的误差都很低——&gt;适度拟合
3.过拟合
假定训练集的误差是 1%，验证集误差是 11%，可以看出训练集训练的非常好，而验证集很差，从而可以判断可能过度拟合了训练集，在某种程度上，验证集并没有充分利用交叉验证集的作用，这就是过拟合现象，也称为“高方差”。
训练集误差较低，验证集误差比训练集大较多——&gt;过拟合
4.最差的情况
训练集误差是 15%，偏差相当高，但是，验证集的评估结果更糟糕，错误率达到 30%，这样说明算法偏差高，因为它在训练集上结果不理想，而且方差也很高，这是方差偏差都很糟糕的情况。这是我们最不想看到的情况。
参考：吴恩达的深度学习视频
作者：GL3_24
来源：CSDN
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a2b77ea5641ce2810376d043c168e7f/" rel="bookmark">
			MySQL日期函数总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
参考链接
当前日期
当前日期时间
日期操作函数
参考链接 http://wiki.jikexueyuan.com/project/mysql/useful-functions/time-functions.html 当前日期 函数名称：curdate查询命令： select curdate(); 命令解释： help curdate; 当前日期时间 函数名称：now查询命令： select now() now; 命令解释： help now; 日期操作函数 函数名称：adddate查询命令： select curdate() curdate, subdate(curdate(), 1) yesterday, adddate(curdate(), 1) tomorrow, subdate(curdate(), weekday(curdate())) firstDayOfWeek, adddate(curdate(), 6 - weekday(curdate())) lastDayOfWeek, subdate(curdate(), dayofmonth(curdate()) - 1) firstDayOfMonth, last_day(curdate()) lastDayOfMonth, subdate(curdate(), dayofyear(curdate()) - 1) firstDayOfYear, last_day(adddate(now(), interval 12 - month (now()) month)) AS lastDayOfYear; 命令解释： help adddate; note subdate()函数和adddate()函数功能等价可通过以上函数求昨天、明天、月初、月末、年初、年末等特殊日期 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d57bb97e0eab3a75b5eed198468c731/" rel="bookmark">
			【网站模板】37套大气的企业网站模板，不管是练习还是商用，都值得你收藏学习...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 | web小二
如果你不是计算机专业毕业，但你又很想得到一份前端开发的工作，有什么办法可以快速达到这个目的？
我想，最直观的办法就是写一个属于自己的小站点作为作品展示给你的面试官看。
但是，在这个作品出来之前，你需要学习很多知识，需要写大量的练习，很多时候，写着写着就没有了灵感，也不知道从哪里下手，也经常看到很多培训机构，总是把京东淘宝作为学员的练习作业，但是写完了，还是不知道怎么去开始一个属于自己的小作品。
而今天我跟大家分享的这些企业网站的网站模板，里面有很多的效果与思路，希望可以给正在做练习的你，一些启发，这些网站模板，均收集整理来源于网络，主要是用于大家学习使用，有些是比较完整的静态模板，这37套模板，个人觉得非常大气，有很多值得学习的地方，非常具有学习价值。
这37套网站模板，是我从100多套模板里精选出来的，希望你能喜欢，也希望能帮助到你提升前端开发技能，并给你一些开发学习的思路。
下面是一些网站模板的截图，我随便选取了其中几套模板，你可以感受一下，看看小二眼观怎么样？哈哈~
01、这是一套幼儿教育的网站模板，是基于Bootstrap构建的。
02，这一个旅行网站。
03、这个是一个偏平化的网站。
里面还有很多这样大气好看，响应式的网站模板。但因为时间与篇幅关系，我就不依次截图展示。
总之，我个人认为这是非常不错的一期学习资源，我个人比较喜欢。不管你是设计师，还是程序员，这个都可以作为你学习的参考资料，需要的话，可以自行通过关键字网站模板下载获取。
以下是37套模板的文件截图：
通过关键字，在公号的留言窗口一次获取这37套网站模板，进行学习。
本文完~
推荐阅读
【源码下载】50套高大上的后台管理系统模板，总有一套适合你
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62b556777e6e47f7348b2fb14536ce8d/" rel="bookmark">
			sql unique约束详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sql unique约束详解 UNIQUE 约束唯一标识数据库表中的每条记录。
UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。
PRIMARY KEY 拥有自动定义的 UNIQUE 约束。
请注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。
SQL UNIQUE Constraint on CREATE TABLE 下面的 SQL 在 "Persons" 表创建时在 "Id_P" 列创建 UNIQUE 约束：
MySQL: CREATE TABLE Persons ( Id_P int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255), UNIQUE (Id_P) ) SQL Server / Oracle / MS Access: CREATE TABLE Persons ( Id_P int NOT NULL UNIQUE, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255) ) 如果需要命名 UNIQUE 约束，以及为多个列定义 UNIQUE 约束，请使用下面的 SQL 语法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62b556777e6e47f7348b2fb14536ce8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d229a41e38469674bcc6f53139fa4864/" rel="bookmark">
			Spring的下载与安装（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring是一个独立的框架，它不需要依赖于任何Web服务器或容器。
它既可在独立的Java SE项目中使用，也可以在Java Web项目中使用。
下载Spring地址：https://repo.spring.io/libs-release-local/
沿着org-springframework-spring，可以看到各版本的压缩包下载链接。
我看书学习的时候下载的是5.0.1版本，建议下个高点的。
下载后会有这样一个压缩包
解压后有如下几个子文件
docs：Spring相关文档，包括开发指南，API参考文档。
libs：该文件夹下的jar分为三类：Spring框架class文件的jar包；Spring框架源文件的压缩包，文件名以-source结尾；Spring框架API文档的压缩包，文件名以-javadoc结尾。
schemas：该文件下包含了Spring各种配置文件的XML Schema文档。
readme.txt,notice.txt,license.txt：说明性文档
另外：
spring的核心容器必须依赖于common-logging的jar包
http://commons.apache.org/
Releases-Logging
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46c143836ee9b56909c8e4b0295f2ef7/" rel="bookmark">
			CentOS 6.0 下 VNC 配置方法（带防火墙配置）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS 6.0 下 VNC 配置方法（带防火墙配置） (2012-12-03 16:30:53)[编辑][删除]
转载▼
标签： linux tigervnc配置 it 分类： linux 一、安装 VNC 首先检查一下本机是否安装了 VNC，默认情况下，CentOS 6.0 是没有安装的。
检查是否安装，输入：
[root@localhost ~]# rpm -q vnc vnc-server 得到：
package vnc is not installed package vnc-server is not installed 提示没有安装，那么就开始安装，输入：
[root@localhost ~]# yum install vnc vnc-server 注：如果是 Ubuntu 则输入：
[root@localhost ~]# apt-get install vnc vnc-server 在一串指令提示后，会让你确认一些选项，输入两次 "Y" 并确认，稍作等待，提示 "Complete!" 即完成安装。
二、设置 VNC 密码 启动 VNC，输入：
[root@localhost ~]# vncserver 此时会提示你输入密码，因为是第一次配置。重复输入两次即可。
三、配置桌面类型 设置一下远程桌面使用那个类型的桌面，分辨率多少等等。输入：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46c143836ee9b56909c8e4b0295f2ef7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f63074c3279db6c6977a9fe0cc73d60/" rel="bookmark">
			WPF 中DataGrid控件显示和设置数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基础知识
1、DataGrid控件：用来显示数据的控件，从对象集合中获取信息并在具有行和单元格的网格中显示信息。每行和单独的对象相对应，并且每列和对象的某个属性相对应。
2、在DataGrid 中同时包含“自动生成列”与“用户自定义列” 由属性AutoGenerateColumns控制。
&lt;DataGrid Name="dataGrid1" AutoGenerateColumns="True" /&gt;//自动生成列（默认）
&lt;DataGrid Name="dataGrid1" AutoGenerateColumns="False" /&gt;//用户自定义列
3、DataGrid常用属性
组件常用方法：
BeginEdit：使DataGrid进入编辑状态。
CancelEdit：取消DataGrid的编辑状态。
CollapseRowGroup：闭合DataGrid的行分组。
CommitEdit：确认DataGrid的编辑完成。
ExpandRowGroup：展开DataGrid的行分组。
GetGroupFromItem：从具体Item中得到分组。
ScrollIntoView：滚动DataGrid视图。
组件常用属性：
AlternatingRowBackground：获取或设置一个笔刷用来描绘DataGrid奇数行的背景。
AreRowDetailsFrozen：获取或设置一个值用来判断是否冻结每行内容的详细信息。
AreRowGroupHeadersFrozen：获取或设置一个值用来判断是否冻结分组行的头部。
AutoGenerateColumns：获取或设置一个值用来判断是否允许自动生成表列。
CanUserReorderColumns：获取或设置一个值用来判断是否允许用户重新排列表列的位置。
CanUserSortColumns：获取或设置一个值用来判断是否允许用户按列对表中内容进行排序。
CellStyle：获取或设置单元格的样式。
ColumnHeaderHeight：获取或设置列头的高度。
ColumnHeaderStyle：获取或设置列头的样式。
Columns：获取组件中包含所有列的集合。
ColumnWidth：获取或设置列宽。
CurrentColumn：获取或设置包含当前单元格的列。
CurrentItem：获取包含当前单元格且与行绑定的数据项。
DragIndicatorStyle：获取或设置当拖曳列头时的样式。
DropLocationIndicatorStyle：获取或设置呈现列头时的样式。
FrozenColumnCount：获取或设置冻结列的个数。
GridLinesVisibility：获取或设置网格线的显示形式。
HeadersVisibility：获取或设置行头及列头的显示形式。
HorizontalGridLinesBrush：获取或设置水平网格线的笔刷。
HorizontalScrollBarVisibility：获取或设置水平滚动条的显示样式。
IsReadOnly：获取或设置DataGrid是否为只读。
MaxColumnWidth：获取或设置DataGrid的最大列宽。
MinColumnWidth：获取或设置DataGrid的最小列宽。
RowBackground：获取或设置用于填充行背景的笔刷。
RowDetailsTemplate：获取或设置被用于显示行详细部分的内容的模板。
RowDetailsVisibilityMode：获取或设置一个值用以判定行详细部分是否显示。
RowGroupHeaderStyles：获取呈现行分组头部的样式。
RowHeaderStyle：获取或设置呈现行头的样式。
RowHeaderWidth：获取或设置行头的宽度。
RowHeight：获取或设置每行的高度。
RowStyle：获取或设置呈现行时的样式。
SelectedIndex：获取或设置当前选中部分的索引值。
SelectedItem：获取或设置与当前被选中行绑定的数据项。
SelectedItems：获取与当前被选中的各行绑定的数据项们的列表（List）。
SelectionMode：获取或设置DataGrid的选取模式。
VerticalGridLinesBrush：获取或设置垂直网格线的笔刷。
VerticalScrollBarVisibility：获取或设置垂直滚动条的显示样式。
组件常用事件：
BeginningEdit：发生于一个单元格或行进入编辑模式之前。
CellEditEnded：发生于一个单元格编辑已被确认或取消。
CellEditEnding：发生于一个单元格正在结束编辑时。
CurrentCellChanged：发生于一个单元格成为当前单元格时。
PreparingCellForEdit：发生于在DataGridTemplateColumn下的单元格进入编辑模式时。
SelectionChanged：发生于当SelectedItem或SelectedItems属性值改变时。
4、DataGrid控件的列类型
DataGridTextColumn:标准数据DataGridCheckBoxColumn:显示复选框DataGridHperlinkColumn:显示可单击的连接。DataGridTemplateColumn:显示列值定义数据模板。 二、简单数据显示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f63074c3279db6c6977a9fe0cc73d60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bdabab0e35b94e8d96c9a1a4be10e3f/" rel="bookmark">
			Android中OpenGl ES兼容性问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 在前面使用OpenGLEs的过程中由于使用的是OpenGlEs3.0的版本所以会带来不少因为版本兼容问题的坑（开始的时候没有发现，因为一直使用的是Android8.1.0的系统的手机。后来测试兼容性的时候发现了坑，我这里最低版本的手机是装有4.4.2系统的）。
问题产生的原因是因为Android系统随着版本的不同里面自带的OpenGL ES版本也会随之不同，而在我们编写GLSL文件的时候如果没有考虑到兼容性的问题的时候就会带来相应的问题。
下面总结一些OpenGLES从2.0到3.0的变化：
一 问题 先将顶点着色器和片段着色器文件贴出来（这是用来渲染普通视频用的），这是使用的OpenGLES3.0版本。（存在兼容性问题），下面只是一部分问题，且这里就不将bug的log写出来了，这是提示大家正确的写法。
顶点着色器 #version 300 es in vec4 aPosition;//顶点位置 in vec2 aTexCoord;//S T 纹理坐标 out vec2 vTexCoord; void main() { vTexCoord = aTexCoord; gl_Position = aPosition; } 片段着色器 #version 300 es #extension GL_OES_EGL_image_external_essl3 : require precision mediump float; in vec2 vTexCoord; uniform samplerExternalOES sTexture; out vec4 vFragColor; void main() { vFragColor=texture(sTexture, vTexCoord); } 1 没有在着色器文件中标明使用版本的时候默认使用2.0版本。 在上面的着色器文件中添加#version 300 es即表明使用3.0版本，如果不添加则使用默认2.0版本（注意此行必须放在第一行）。同时注意使用3.0的api的时候必须添加此行。
2 3.0中attribute变成了in和out OpenGL ES 3.0中将2.0的attribute改成了in，顶点着色器的varying改成out，片段着色器的varying改成了in，也就是说顶点着色器的输出就是片段着色器的输入，另外uniform跟2.0用法一样。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bdabab0e35b94e8d96c9a1a4be10e3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fbb87dfec230f2ab7372e40df14a257/" rel="bookmark">
			高级Bash脚本编程指南(2)：Shell特殊字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高级Bash脚本编程指南(2)：Shell特殊字符
成于坚持，败于止步
注释 表示注释
在引号中间和#等表示#本身
3.echo ${PATH#*:} # 参数替换,不是一个注释
4.echo $(( 2#101011 )) # 数制转换,不是一个注释
; 分隔
1.命令分隔，在一行中写多个命令 echo “aa” ; echo “bb”
2.在条件中的if和then如果放在同一行，也用;分隔
;; case条件的结束
1.命令分隔，在一行中写多个命令 echo “aa” ; echo “bb”
2.在条件中的if和then如果放在同一行，也用;分隔
echo hello; echo there
if [ -x “$filename” ]; then # 注意: "if"和"then"需要分隔.
echo “File $filename exists.”; cp $filename $filename.bak
else
echo “File $filename not found.”; touch $filename
fi; echo “File test complete.”
. 命令相当于
1.命令：source
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fbb87dfec230f2ab7372e40df14a257/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecb7f1f2376f0e4ccab9051bb74c140d/" rel="bookmark">
			Patient Orientation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tag(0020,0020)TypeConditionally Required, Empty if Unknown (2C)KeywordPatientOrientationValue Multiplicity2Value RepresentationCode String (CS) Patient direction of the rows and columns of the image. Required if image does not require Image Orientation (Patient) (0020,0037) and Image Position (Patient) (0020,0032) or if image does not require Image Orientation (Slide) (0048,0102). May be present otherwise. See Section C.7.6.1.1.1 for further explanation.
Note IODs may have Attributes other than Patient Orientation, Image Orientation, or Image Position (Patient) to describe orientation in which case this Attribute will be zero length.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecb7f1f2376f0e4ccab9051bb74c140d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/494d74cc9d05e966bba7d1ae6e1edbc7/" rel="bookmark">
			train loss和test loss的变化趋势分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		变化趋势分析
1.train loss 不断下降，test loss不断下降，说明网络仍在学习;（最好的）
2.train loss 不断下降，test loss趋于不变，说明网络过拟合;（max pool或者正则化）
3.train loss 趋于不变，test loss不断下降，说明数据集100%有问题;（检查dataset）
4.train loss 趋于不变，test loss趋于不变，说明学习遇到瓶颈，需要减小学习率或批量数目;（减少学习率）
5.train loss 不断上升，test loss不断上升，说明网络结构设计不当，训练超参数设置不当，数据集经过清洗等问题。（最不好的情况）
转载自：https://blog.csdn.net/u012986684/article/details/79179640
自己遇到的情况
训练GoogLeNet时遇到过第二种情况：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b474e83360d1a522000b8719fd83e4e6/" rel="bookmark">
			图像的频域理解以及频域处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般我们见到的简单的图像处理都是空间域的处理。即图像是一个二维图像，每个点都有对应的坐标。
图像的频域理解起来并不是那么简单，因此我在这里说一下个人理解，希望帮助到需要帮助的人。本篇博文使用Halcon软件的示例以及图像进行展示。
首先需要说明的几点知识：
1.如果需要看频谱图是要进行傅里叶变换的，图像的傅里叶变换其实是将图像的灰度分布函数变换为图像的频率分布函数。
2.图像的频域中的高频分量对应图像的细节信息，图像低频分量对应图像的轮廓信息。高频分量代表的是信号的突变部分（即灰度值梯度大），而低频分量决定信号的整体形象（即梯度小）。
3.在频谱图中，可以看到亮度不同的点，这些点中亮度大就证明该点的梯度大（即高频分量），亮度小证明该点的梯度小（即低频分量）。
4.频谱图中中心部分代表高频分量，四周代表低频分量，尤其是四个顶点。
然后根据图像进行简单解释。
原图
然后进行傅里叶变换
rft_generic (Image, ImageFFT, 'to_freq', 'none', 'complex', Width) 傅里叶变换之后的频谱图
原图特征一致，图像梯度很小，则低频分量较多，高频分量较少。体现在频谱图中就是顶点部分更亮。而肉眼可以明显的看到图像中有一部分凸起，这部分的梯度就变大了，在频谱图中该部分就偏亮些。
然后可以对图像进行滤波
convol_fft (ImageFFT, Filter, ImageConvol) rft_generic (ImageConvol, ImageFiltered, 'from_freq', 'n', 'real', Width) 滤波之后的图像
这样就可以将中间部分的凸起检测出来了。
有的图像在空间域中进行处理会很困难，例如该例中的检测缺陷。但是放到频域中就可以很简单的进行检测，比如我们看到的经过滤波之后的图像，待检测点部分的特征明显去其他地方不同。
作者：GL3_24
来源：CSDN
著作权归作者所有。转载请联系作者获得授权并注明出处。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8204a98bc65ea7b7c168b05c99b1a9c/" rel="bookmark">
			OpenGL ES之十一——绘制3D图形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 这是一个系列的Android平台下OpenGl ES介绍，从最基本的使用最终到VR图的展示的实现，属于基础篇。（后面针对VR视频会再有几篇文章，属于进阶篇） OpenGL ES之一——概念扫盲
OpenGL ES之二——Android中的OpenGL ES概述
OpenGL ES之三——绘制纯色背景
OpenGL ES之四——绘制点，线，三角形
OpenGL ES之五——相机和投影，绘制等腰三角形
OpenGL ES之六——绘制矩形和圆形
OpenGL ES之七——着色器语言GLSL
OpenGL ES之八——GLES20类和Matrix类
OpenGL ES之九——相机和投影
OpenGL ES之十——纹理贴图（展示一张图片）
OpenGL ES之十一——绘制3D图形
OpenGL ES之十二——地球仪和VR图
本篇概述 经过前面的铺垫，我们对OpenGLES了解了不少了，是时候绘制立体图像了。
一 圆锥 拆分原理： 在之前的文章中我们绘制过圆形，圆锥可以看成是圆心顶点坐标z不为0的圆形，绘制的方法和绘制一个圆是一样的，将圆锥的侧面切分为一个个三角形。如下：
着色器文件 顶点着色器
#version 300 es layout (location = 0) in vec4 vPosition; layout (location = 1) in vec4 aColor; uniform mat4 u_Matrix; out vec4 vColor; void main() { gl_Position = u_Matrix*vPosition; gl_PointSize = 10.0; vColor = aColor; } 片段着色器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8204a98bc65ea7b7c168b05c99b1a9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aa8584610b74d9a688745c7ad8c9cff/" rel="bookmark">
			【科技金融】互金产品设计流程和运营策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转：https://mp.weixin.qq.com/s/Ucd_j3ALG0CcoZ5CzhsudQ
合规的网络信贷最基本要求放款方是金融机构，综合贷款利率不超过36%，没有砍头息、暴力催收等现象。本文就跟大家谈谈合规的网络信贷用户画像、产品设计、获客逻辑和用户增长体系。
今天我们来谈谈网络信贷用户画像、产品设计、获客逻辑和用户增长体系。
合规的现金贷平台最基本要求放款方是金融机构，综合贷款利率不超过36%，没有砍头息、暴力催收等现象。
用户画像 临时借款 年轻白领或者有稳定工作的人群，平时不缺钱，偶尔遇到人情来往或者其它意外情况，缺1-2万块钱，懒得找亲戚或朋友借，找借贷平台临时周转几天，很快会把借款还清。
平台选择：对额度和借款利率比较敏感，首选金融机构的平台贷款。借款频率：频率不高，周期也不太长，但对于平台的忠诚度较高。
月光一族 主要是90后年轻人群，工资低而且永远不够花，发工资后会把马上还清贷款，或者选择等额本息每月还款。这批用户对利率不敏感，只算自己的工资抛去开支是否够下月的还款。
平台选择：这批用户很大部分是白户或者征信数据不全，所以金融机构给不了授信，信用卡额度也比较低，是互联网现金贷平台首选用户。借款频率：缺钱的日子总是很多，关键是培养用户的金融习惯，提高用户的复借率。
养卡一族 信用卡和网络借贷火爆后这批人永远有数十万或者更多的借款，需要记住每一个信用卡的还款日去网络借贷平台续借，每个月东拆西补，工资很大比例用来还利息但用户浑然不知，控制不住自己的财务状况，债务雪球则越滚越大。
平台选择：会仔细选择额度大和利率低的平台，当然很多用户算不清楚什么叫年化利率，申请的平台会很多。借款频率：每月都有很多次，一量出现信用卡或平台降额、清出，还款能力就可能出现问题。
老赖客群 行业里养活几百万老赖用户，这些人天天建群沟通心得、撸新口子、开班授课，某个平台出现漏洞后这批用户就像恶狼会迅速传播撸爆。
养卡、手机号、收入流水，某些时候会在一些网络借贷平台正常还款，然后同时在多家现金贷平台撸笔大额度的借款丢掉手机卡后消失。
业务流程 360借条是360旗下借款平台，这几年发展速度和规模在同业算是在第一阵营了，2018年成功上市后发展势头更猛，360初期的流量主要是360旗下平台的导流，还有在各大平台比如头条购买流量，自己不要的流量导往第三方贷款平台，平台整体流量运营效果比较好，今天我们以360借条的产品来介绍业务流程。
下载APP和注册 下载和注册比较简单，也比较人性化，不需要设置登陆密码，每次输入短信验证码就可以，不需要用户再记登陆密码。
2. 申请流程
（1）第一步是设置交易密码，6位数字密码同银行卡密码策略一致
（2）人面识别
活体校验，采用第三方SDK，目前包括腾讯、阿里都在发展的技术，技术比较成熟了。
（3）身份证认证
身份证正反面拍照和识别，此环节作3件事，第一与公安网认证申请人身份真伪，第二留存你的身份证照片资料，第三证明身份证原件在你手上。
（4）绑卡
绑卡是用户申请环节最核心的步骤，用户需要输入银行卡预留的手机验证码，进行4要素认证。
（5）运营商认证
此环节需要输入你的手机号码、运营商服务密码，360后台的爬虫去运营商网站爬取你的手机通话记录，爬虫登陆网站时需要输入短信验证码。
360平台会获取你的数据：
手机通讯录（APP会询问你是否授权）。运营商网站里你的所有通话记录。 （6）激活授信
完成所有申请步骤，一共6步比较简单，易用性好。
完成后系统自动发个红包，可以把红包分享给好友，与饿了么之类的APP玩的同一个裂变套路。
额度计算过程中，可以分享礼包给好友，还可以请好友助力提高额度。
裂变套路：
红包分享；好友助力提升额度；邀请有礼。
3. 授信审批
审批过程会走自动风控流程，可能会查人行征信、第三方征信、名单，然后基于这些数据加工成风控变量，不同的环节走决策流程，每个决策流程都可以会被拒绝。
小部分用户会走人工审批，所有风控流程走完会审批出用户的风险等级和额度。
360的审批时间太长，一般成熟的风险决策流程1分钟左右，比较优秀的像万卡、读秒之在的产品审批3-5秒就出决策结果。
4. 申请借款
批额度不知道为什么这么慢，第二天才出来。
计息方式：等本等息。
折算后年化：20%左右，与其它现金贷比不算特别高。
5. 借款审批
用户申请提现风险需要过一下名单，如果授信的时间和提现的时间间隔超过1-3个月，用户的资质可能已经发生比较大的变化，部分数据还需要重新获取和决策。
用户获得授信的1周内提现通过率一般情况下都会很高。
6. 打款
打款到用户绑卡的银行卡中，不同的银行卡经过资金路由走不同的支付通道，需要降低支付手续费和提高支付成功率。
用户增长模型 现金贷运营的时间比较短，与其它互联网行业如电商相比，运营的套路和方式都要LOW很多，目前用户运营主要着重在获客、促活、转化和裂变方面。
现金贷的用户与电商相比目的性要强很多，活跃和转化率也是比较高。
平台存在的主要问题和困难是拉新，获客成本在2018年从年初持续攀升，用户质量也是不停的下降。所以裂变分享是现金贷平台比较重视的拉新方法。
1. 自然流量
自然流量过来的大概率是两类人，一类是到处撸口子的老赖客群，新上线的平台在群里很快会传播出来，大家会研究平台需要什么资质和资料，什么样的客户在平台容易通过。
另一类特别需要用钱的用户，在搜索引擎之类的地方到处找现金贷平台。
现金贷用户有一个明显的特点，主动找上来的用户质量都偏差，特别是平台上线后第一波用户，我们的经验初期全拒，积累名单数据。
如果是持牌金融机构、上市公司或者有一定品牌知名度的平台自然流量会好很多，平台稳定运营后靠产品、口碑和品牌会有不错的自然流量。
2. 自媒体运营
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3aa8584610b74d9a688745c7ad8c9cff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c39b4e70df5faf98a37678ef29a1462/" rel="bookmark">
			C# 使用Math.NET读取mat格式文件内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、前序知识
1、mat格式
Mat文件格式，实际上使用的是一种通用的数值数据存储格式Hierarchical Data Format(HDF)，该格式最先是由美国国家超级计算应用中心开发的，后来由HDF非盈利组织资助。LabVIEW,MATLAB,Scilab,Octave,Mathematica等都支持该格式，该格式目前主要有HDF4和HDF5。
2、Mat数据格式读写的组件是MathNet.Numerics.Data.Matlab,Mat数据格式的读取主要用MatlabReader类
二、正确引用
MathNet.Numerics.Data.Matlab
安照之前从网上直接找MathNet.Numerics.dll文件，然后再引用
using MathNet.Numerics.LinearAlgebra; using MathNet.Numerics.Data.Matlab; 会出现 缺少MathNet.Numerics.Data.Matlab错误
正确方法：通过安装.nupkg文件来正确引用
注意要使用VS较高版本的，本人使用VS2017
1、准备两个库文件
下载地址
下载地址下载地址
注意：MathNet.Numerics.Data.Matlab的版本不要太高，笔者使用4.0的版本 ，出现在vs2017下无法安装的情况。
2、VS里面安装NuGet管理器
即要安装工具箱里的如下应用，如果已经安装过，则跳过这一步
（1）点击工具-扩展和更新
（2）搜索并安装NuGet Package Project 3、打开一个工程
需要先添加一个程序包源，即添加自己下载的.nupkg文件存放的路径
工具-选项
4、回到NuGet解决方案，安装.nupkg
此时会在自己设置的路径下生成两个dll文件
之后可以正常引用了。
三、读取mat格式文件内容
//从collection.mat文件中，读取第一个double矩阵 Matrix&lt;double&gt; m = MatlabReader.Read&lt;double&gt;("collection.mat"); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a60633c585bca7bd77ccb66929ba1b28/" rel="bookmark">
			【工作计划】4.22-4.27
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【工作计划】4.22-4.27
1. 翻译小论文初稿 （5天）
2. 了解英文文章中各部分的写法，学习它。
------------------------------------- 认识有多深，呈现才有多深 ------------------------------------------------------------------ 凡事预则立，不预则废。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/840498c3dacbda076aba715192b7d47d/" rel="bookmark">
			xpath 特殊用法 starts-with(),string(.),字符串的startswith,endswith函数的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#-*-coding:utf8-*- from lxml import etree html1 = ''' &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="test-1"&gt;需要的内容1&lt;/div&gt; &lt;div id="test-2"&gt;需要的内容2&lt;/div&gt; &lt;div id="testfault"&gt;需要的内容3&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; ''' html2 = ''' &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="test3"&gt; 我左青龙， &lt;span id="tiger"&gt; 右白虎， &lt;ul&gt;上朱雀， &lt;li&gt;下玄武。&lt;/li&gt; &lt;/ul&gt; 老牛在当中， &lt;/span&gt; 龙头在胸口。 &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; ''' # selector = etree.HTML(html1) # #content = selector.xpath('//div[starts-with(@id,"test")]/text()') # content = selector.xpath('//div[contains(@id,"test-1")]/text()') # for each in content: # print (each) # selector = etree.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/840498c3dacbda076aba715192b7d47d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ec9bfffb77f6590999b07e10e8463e2/" rel="bookmark">
			hive批量导出表结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hive按user导出全部库的表结果信息，并可以作为表信息迁移使用 #!/bin/bash # 读取表create table # $1 = dim_sycm_offical # $2 = $eachline # $3 = sql file name funCreateTable(){ echo "-- --------------$2" &gt;&gt; create_table_first.txt echo "use $1;" &gt;&gt; create_table_first.txt echo "drop table if exists $2;" &gt;&gt; create_table_first.txt hive -e "use $1; show create table $2;" &gt;&gt; create_table_first.txt sed -e '/WARN/d' create_table_first.txt &gt; create_table.txt echo ";" &gt;&gt; create_table.txt echo "msck repair table $2;" &gt;&gt; create_table.txt cat create_table.txt &gt;&gt; $3 rm create_table.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ec9bfffb77f6590999b07e10e8463e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6660853c4d4d8d53788883eef4e07edb/" rel="bookmark">
			RTTI：运行时类型识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RTTI：运行时类型识别 参考链接：https://www.cnblogs.com/JohnTsai/p/4821287.html1、什么是RTTI应用场景 2、获取Class对象的三种方法 参考链接：https://www.cnblogs.com/JohnTsai/p/4821287.html 在《Java编程思想》一书中，学习泛型的时候提到了一个很重要的点，称之为RTTI，即运行时类型识别
经过自己的查阅，稍微有一点理解，整理备忘。
1、什么是RTTI Java在运行时识别对象和类的信息的方式： (1)一种是RTTI，它假定我们在编译时已经知道了所有的类型。 (2)另一种是反射机制，它允许我们在运行时发现和使用类的信息。 运行时类型识别(RTTI, Run-Time Type Identification) 是Java中非常有用的机制，在Java运行时，RTTI维护类的相关信息。 多态(polymorphism)是基于RTTI实现的。 RTTI的功能主要是由Class类实现的。 应用场景 /** * Java中每个对象都有相应的Class类对象 * 因此，我们随时能通过Class对象知道某个对象“真正”所属的类。 * 无论我们对引用进行怎样的类型转换，对象本身所对应的Class对象都是同一个。 * 当我们通过某个引用调用方法时，Java总能找到正确的Class类中所定义的方法，并执行该Class类中的代码。 * 由于Class对象的存在，Java不会因为类型的向上转换而迷失。这就是多态的原理。 * * @version 1.0 created by Justmemoryl on 2018/11/14 9:37 */ public class RTTIDemo { public static void main(String[] args) { Human aPerson = new Human(); Class c1 = aPerson.getClass(); System.out.println(c1.getName()); // 向上转型，由父类接收子类对象 Human anotherPerson = new Woman(); Class c2 = anotherPerson.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6660853c4d4d8d53788883eef4e07edb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddcbb6790c7b292c12aad504881705e4/" rel="bookmark">
			RGB三通道图像和灰度值简单理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		24bit RGB图像也叫全彩图。其有三个通道，分别为：R(red),G(green),B(blue)。
用halcon程序以及halcon自带图像进行理解RGB图像和灰度值。
1.读一张图像（橘子在蓝色背景下）并画一个点（图中红×）
get_grayval (Image, Row, Column, RGBGrayval) 获得所画点的灰度值，结果为
2.三通道分离，并获取灰度值
decompose实现三通道分离，并分别获得三个通道的灰度值。
get_grayval (R, Row, Column, RGrayval)
get_grayval (G, Row, Column, GGrayval)
get_grayval (B, Row, Column, BGrayval)
由此可以得出三通道图像的灰度值是三个单通道的灰度值的组合。灰度值为0-255，每个通道都是0-255，值越大图像看起来越亮，值越小图像越暗。在三通道图像上看到哪部分的哪种颜色越深，证明在该部分的哪种颜色分量越大，反应到该单通道上越亮。例如，由原图可以看到背景大部分是蓝色的，则在蓝色通道上看到的背景部分越亮，橘子部分很暗。
注：另外，灰度图是由R G B三个分量按照一定比例进行计算得到的单通道图像，计算方法不单一。
作者：GL3_24
来源：CSDN
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/107/">«</a>
	<span class="pagination__item pagination__item--current">108/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/109/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>