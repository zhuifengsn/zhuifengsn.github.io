<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87309249fadce5c001ce6261a96be3e2/" rel="bookmark">
			过采样：SMOTE算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：在比赛中遇到关于样本不均衡问题，特地过来补补知识点！
1、smote原理 过采样的技术有非常多,最常见的就是随机过采样和SMOTE过采样。
随机过采样就是从少的类中进行随机进行采样然后拼接上去,这种效果很多时候和加权差不大。还有一种较常见的也是现在比赛中出现最多的采样方法,SMOTE采样。
SMOTE的示意图如下,
SMOTE算法的生成过程为:
对于少数类中每一个样本x，以欧氏距离为标准计算它到少数类样本集中所有样本的距离，得到其k近邻。根据样本不平衡比例设置一个采样比例以确定采样倍率N，对于每一个少数类样本x，从其k近邻中随机选择若干个样本，假设选择的近邻为xn。对于每一个随机选出的近邻xn，分别与原样本按照如下的公式构建新的样本
2、smote缺点 从算法中,我们可以发现,SMOTE采样其实就是生成样本之间的一些样本。
但是因为思路简单,我们也很容易就可以发现SMOTE算法的一些缺点。
在近邻选择时,K值的决定一般较难,可以枚举然后根据实验效果来定;算法无法克服非平衡数据集的数据分布问题,容易产生分布边缘化问题。如果正样本都分布在边缘,我们通过采样正样本来生成样本,那么这样新生成的样本将也会全部在边缘，且会越来越边缘化,从而模糊了正类样本和负类样本的边界,而且使边界变得越来越模糊。这种边界模糊性,虽然使数据集的平衡性得到了改善,但有时也会加大了分类算法进行分类的难度． 3、Python实现smote import random from sklearn.neighbors import NearestNeighbors import numpy as np class Smote: """ SMOTE过采样算法. Parameters: ----------- k: int 选取的近邻数目. sampling_rate: int 采样倍数, attention sampling_rate &lt; k. newindex: int 生成的新样本(合成样本)的索引号. """ def __init__(self, sampling_rate=5, k=5): self.sampling_rate = sampling_rate self.k = k self.newindex = 0 def fit(self, X, y=None): if y is not None: negative_X = X[y==0] X = X[y==1] n_samples, n_features = X.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87309249fadce5c001ce6261a96be3e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2ebae741523e931d6614c07bf324268/" rel="bookmark">
			oracle 数据库怎么启动,Oracle数据库：启动操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		联系邮箱：cloud_data@163.com
1、切换到oracle用户，登陆到数据库
[root@localhost Desktop]# su - oracle # 切换到oracle用户
[oracle@localhost ~]$ sqlplus / as sysdba # 以dba身份登录到数据库
SQL*Plus: Release 11.2.0.1.0 Production on Sat Jun 22 19:51:58 2013
Copyright (c) 1982, 2009, Oracle. All rights reserved.
Connected to an idle instance. # 这里表明，数据库还未启动，需要启动数据库
2、启动数据库
SYS&gt; startup # 启动数据库
ORACLE instance started. # 实例启动
Total System Global Area 795127808 bytes # 分配内存等操作
Fixed Size 1339456 bytes
Variable Size 503320512 bytes
Database Buffers 285212672 bytes
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2ebae741523e931d6614c07bf324268/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95d0217c96cf5cda94fd99a372d656ec/" rel="bookmark">
			磁盘阵列 php,raid10和raid5性能区别是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		raid10和raid5性能的区别：1、RAID10的利用率是【50%】，而RAID5的利用率是【75%】；2、RAID10的安全性高于RAID5；3、在连续写方面的性能，RAID5比RAID10会更好一些。
raid10和raid5性能的区别：
RAID10的安全性高于RAID5，RAID5的空间利用率越高。
二者具体区别：
1、安全性方面的比较：RAID10的安全性高于RAID5。通过简单的分析：当盘1损坏时，对于RAID10，只有当盘1对应的镜像盘也损坏，才会导致RAID失效。但是对于RAID5，剩下的3块盘中，任何一块盘出现故障，都将导致RAID失效。
2、空间利用率的比较：RAID10的利用率是50%，RAID5的利用率是75%。硬盘数量越多，RAID5的空间利用率越高。
3、读写性能方面的比较：读操作方面的性能差异：RAID10可供读取有效数据的磁盘个数为4，RAID5可供读取有效数据的磁盘个数也为4个(校验信息分布在所有的盘上)，所以两者在读方面的性能应该是基本一致的。
4、连续写方面的性能差异：在连续写操作过程中，如果有写Cache存在，并且算法没有问题的话，RAID5比RAID10会更好一些，虽然也许并没有太大的差别。(这里要假定存储有一定大小，足够的写Cache，而且计算校验的CPU不会出现瓶颈)。
扩展资料：
RAID5把数据和相对应的奇偶校验信息存储到组成RAID5的各个磁盘上，并且奇偶校验信息和相对应的数据分别存储于不同的磁盘上，其中任意N-1块磁盘上都存储完整的数据，也就是说有相当于一块磁盘容量的空间用于存储奇偶校验信息。
因此当RAID5的一个磁盘发生损坏后，不会影响数据的完整性，从而保证了数据安全。当损坏的磁盘被替换后，RAID还会自动利用剩下奇偶校验信息去重建此磁盘上的数据，来保持RAID5的高可靠性。
做raid 5阵列所有磁盘容量必须一样大，当容量不同时，会以最小的容量为准。 最好硬盘转速一样，否则会影响性能，而且可用空间=磁盘数n-1，Raid 5 没有独立的奇偶校验盘，所有校验信息分散放在所有磁盘上， 只占用一个磁盘的容量。
用简单的语言来表示，至少使用3块硬盘(也可以更多)组建RAID5磁盘阵列，当有数据写入硬盘的时候，按照1块硬盘的方式就是直接写入这块硬盘的磁道，如果是RAID5的话这次数据写入会根据算法分成3部分，然后写入这3块硬盘，写入的同时还会在这3块硬盘上写入校验信息。
当读取写入的数据的时候会分别从3块硬盘上读取数据内容，再通过检验信息进行校验。当其中有1块硬盘出现损坏的时候,就从另外2块硬盘上存储的数据可以计算出第3块硬盘的数据内容。
也就是说raid5这种存储方式只允许有一块硬盘出现故障，出现故障时需要尽快更换。当更换故障硬盘后，在故障期间写入的数据会进行重新校验。 如果在未解决故障又坏1块，那就是灾难性的了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9666dcff9a17775e504a7917a7fbd5f0/" rel="bookmark">
			关于pict工具进行测试用例的自动生成过程中：使用 pict.exe test.txt ＞test.xsl 导出为xls格式的表格文件时，出现拒绝访问的提示解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验题目：（4）下面是测试磁盘分区创建功能的实例。输入条件有分区类型、大小、格式化方式、文件系统类型、簇大小、是否压缩。各项输入条件分别有不同的参数选择。（pair-wise）法进行测试
Type: Primary, Logical, Single, Span, Stripe, Mirror, RAID-5
Size: 10, 100, 500, 1000, 5000, 10000, 40000
Format method: quick, slow
File system: FAT, FAT32, NTFS
Cluster size: 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536
Compression: on, off
***对于该实验的要求：***c)针对第（4）题，请根据pair-wise法设计测试用例对磁盘创建功能进行检测。
同时，利用PICT或其他自动基于pair-wise的工具完成此测试用例的自动生成，将生成的测试用例结果保存到Excel文档中。
使用其工具使用过程如下：
1、安装pict应用（没什么难度，不过安装的过程中，我是默认安装在C盘的ProgramFiles(x86)这儿需要注意下可能安装在其他你自己指定的目录下会出现问题，若是出现问题可以重装将其安装在默认的安装路径
安装完成后在其目录下，建立一个xx.txt文件将上面的输入条件复制进去保存
2、cd 进入安装pict的目录
3、执行pict.exe test.txt,查看返回结果：
4、通过 pict.exe test.txt &gt;test.xsl 导出为xsl格式的表格文件
这里之所以出现错误是因为，打开命令提示符不是以管理员身份打开的原因导致在这一步当中出现：拒绝访问的提示；
如下图
解决问题请大佬点个赞，学习日常分享。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75c33b28e266c82655c0695edd2a7f6c/" rel="bookmark">
			WPF基础系列六：MVVM框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MVVM框架 文章目录 MVVM框架前言一、MVVM框架简介1. 什么是MVVM？2. MVVM的优势3.MVVM的应用场景 二、MVVM使用及示例 前言 在WPF开发中，经典的编程模式是MVVM，是为WPF量身定做的模式，该模式充分利用了WPF的数据绑定机制，最大限度地降低了Xmal文件和CS文件的耦合度，也就是UI显示和逻辑代码的耦合度，如需要更换界面时，逻辑代码修改很少，甚至不用修改。与WinForm开发相比，我们一般在后置代码中会使用控件的名字来操作控件的属性来更新UI，而在WPF中通常是通过数据绑定来更新UI；在响应用户操作上，WinForm是通过控件的事件来处理，而WPF可以使用命令绑定的方式来处理，耦合度将降低。 一、MVVM框架简介 1. 什么是MVVM？ MVVM是Model-View-ViewModel的简写。微软的WPF(Windows Presentation Foundation–微软推出的基于Windows 的用户界面框架)带来了新的技术体验, 使得软件UI层更加细节化、可定制化。与此同时，在技术层面，WPF也带来了 诸如Binding（绑定）、Dependency Property（依赖属性）、Routed Events（路由事件）、Command（命令）、DataTemplate（数据模板）、ControlTemplate（控制模板）等新特性。MVVM模式其实是MVP模式与WPF结合的应用方式时发展演变过来的一种新型架构模式。它立足于原有MVP框架并且把WPF的新特性糅合进去，以应对客户日益复杂的需求变化。 结构模型如下：
Model： 就是系统中的对象，可包含属性和行为（就是一个class，是对现实中事物的抽象，开发过程中涉及到的事物都可以抽象为Model，例如客户，客户的姓名、编号、电话、住址等）；View： 就是用xaml实现的界面，负责与用户交互，接收用户输入，把数据展现给用户；ViewModel： 是一个C#类，负责收集需要绑定的数据和命令，聚合Model对象，通过View类的DataContext属性绑定到View，同时也可以处理一些UI逻辑。显示的数据对应着ViewMode中的Property，执行的命令对应着ViewModel中的Command。 三者之间的关系： View对应一个ViewModel，ViewModel可以聚合N个Model，ViewModel可以对应多个View
2. MVVM的优势 MVVM的根本思想就是界面和业务功能进行分离，View的职责就是负责如何显示数据及发送命令，ViewModel的功能就是如何提供数据和执行命令。各司其职，互不影响。
在实际的业务场景中我们经常会遇到客户对界面提出建议要求修改，使用MVVM模式开发，当设计的界面不满足客户时，我们仅仅只需要对View作修改，不会影响到ViewModel中的功能代码，减少了犯错的机会。随着功能地增加，系统越来越复杂，相应地程序中会增加View和ViewModel文件，将复杂的界面分离成局部的View，局部的View对应局部的ViewModel，功能点散落在各个ViewModel中，每个ViewModel只专注自己职能之内的事情。ViewModel包含了View要显示的数据，并且知道View的交互代码，所以ViewModel就像一个无形的View。使用MVVM架构具有以下优势： 易维护（低耦合），视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。灵活扩展(可重用性)，可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑；易测试，界面向来是比较难于测试的，而现在测试可以针对ViewModel来写独立开发，开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xml代码。 3.MVVM的应用场景 使用MVVM框架的好处就是当前后端进行一些数据交互的时候，前端可以通过Ajax请求对后端做数据持久化，不需要刷新整个页面，只需要改动DOM里需要改动的那部分数据和内容，特别是对于移动端应用场景，刷新页面的代价太昂贵，会重新加载很多资源，虽然有些资源会被缓存，但是页面的DOM、JS、CSS都会被浏览器重新解析一遍，因此，移动端页面经常会做成SPA单页应用，在这个基础上就诞生了很多MVVM框架，如Angular、React、Vue。
针对具有复杂交互逻辑的前端应用提供基础的架构抽象通过Ajax数据持久化，保证前端用户体验 二、MVVM使用及示例 NuGet引用MVVM框架包
引入该框架包之后, 默认会在目录下创建ViewModel层的示例代码
通过在MainViewModel中创建一些业务代码, 将其与MainWindow.xaml 通过上下文的方式关联起来, 而MainWindow则是通过Binding的写法 引用业务逻辑的部分。 2.1. 在MainViewModel中, 添加同一个班级名称, 与学生列表, 分别用于显示在文本 和列表上展示, Command则用于绑定DataGrid的双击命令上, 通过双击, 展示点击行的学生信息：
2.2. 设计UI层，在XMAL文件中 添加一个文本用于显示班级名称, 添加一个DataGrid 用于展示学生列表, 同时DataGrid中添加一个绑定的命令(红色区域)
关于上面红色圈的代码, 为一种绑定语法, 主要在MouseBinding中, MouseAction 以为触发的事件类型, CommandParameter 则是命令传递的参数, 也就是DataGrid选中的一行的类型 Student。Command 则是MainViewModel中定义的Command。RelativeSource FindAncestor，主要用于控件模板或可预测的自包含 UI 组合。2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75c33b28e266c82655c0695edd2a7f6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/939160a79d7a21767a098ecdb295d69b/" rel="bookmark">
			铸就项目经理的必备技能——ISO/IEC9126软件质量模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ISO/IEC 9126(1991)：软件产品评估—质量特性及其使用指南纲要，就是为支援软件产品的每个相关质量特性而发展出来的。在此标准中，定义了六种质量特性，并且描述了软件产品评估过程的模型。
目录
(1)功能性
(2)可靠性
(3)可用性
(4)效率
(5)可维护性
(6)可移植性
你好呀，我是灰小猿，一个超会写bug的程序猿！
今天来和大家聊一下在软件产品开发中用到的ISO/IEC9126的软件质量模型。其中包括6个质量特性和21个质量子特性是在进行软件产品开发过程中要理解的内容。
具体如下表所示：
接下来和大家具体分析一下这6个质量特性和21个质量子特性的具体内容：
(1)功能性 功能性是指与软件所具有的各项功能及其规定性质有关的一组属性，包括：
适合性:与规定任务能否提供一组功能以及这组功能的适合程度有关的软件属性。适合程度的例子是面向任务系统中由子功能构成的功能是否合适、表容量是否合适等。准确性:与能否得到正确或相符的结果或效果有关的软件属性。此属性包括计算值所需的准确程度。互操作性(互用性):与同其他指定系统进行交互的能力有关的软件属性。为避免可能与易替换性的含义相混淆，此处用互操作性(互用性)而不用兼容性。依从性:使软件遵循有关的标准、约定、法规及类似规定的软件属性。安全性:与防止对程序及数据的非授权的故意或意外访问的能力有关的软件属性。 (2)可靠性 可靠性是指在规定运行条件下和规定时间周期内，与软件维护其性能级别的能力有关的一组属性。可靠性反映的是软件中存在的需求错误、设计错误和实现错误而造成的失效情况，包括:
成熟性:与由软件故障引起失效的频度有关的软件属性。容错性:与在软件故障或违反指定接口的情况下，维持规定的性能水平的能力有关的软件属性。指定的性能水平包括失效防护能力。可恢复性:与在失效发生后，重建其性能水平并恢复直接受影响数据的能力以及为达此目的所需的时间和努力有关的软件属性。 (3)可用性 可用性是指根据规定用户或隐含用户的评估所作出的与使用软件所需要的努力程度有关的一组属性，包括:
可理解性:与用户为认识逻辑概念及其应用范围所花的努力有关的软件属性。易学性:与用户为学习软件应用(如运行控制、输入、输出)的努力有关的软件属性。可操作性:与用户为操作和运行控制的努力有关的软件属性。 (4)效率 效率是指在规定条件下，与软件性能级别和所用资源总量之间的关系有关的组属性。包括:
时间特性:与软件执行其功能时响应和处理时间以及吞吐量有关的软件属性。资源特性:与在软件执行其功能时所使用的资源数量及其使用时间有关的软件属性。 (5)可维护性 可维护性是指与对软件进行修改的难易程度有关的一组属性，包括:
可分析性:与为诊断缺陷或失效原因及为判定待修改的部分所需努力有关的软件属性。可改变性:与进行修改、排除错误或适应环境变化所需努力有关的软件属性。稳定性:与修改所造成的未预料结果的风险有关的软件属性。可测试性:与确认已修改软件所需的努力有关的软件属性。此子特性的含义可能会被研究中的修改加以改变。 (6)可移植性 可移植性是指与一个软件从一个环境转移到另一个环境运行的能力有关的一-组属性。包括:
适应性:与软件无须采用为该软件准备的活动或手段就可能适应不同的规定环境有关的软件属性。可安装性:与在指定环境下安装软件所需努力有关的软件属性。遵循性(-致性):使软件遵循与可移植性有关的标准或约定的软件属性。可替换性:与软件在该软件环境中用来替代指定的其他软件的机会和努力有关的软件属性。为避免可能与互操作性(互用性)的含义相混淆，此处用可替换性而不可兼容性，特定软件的可替换性并不隐含此软件可由所考虑的软件代替，可替换性可能包含可安装性和适应性两个属性，由于此概念的重要性，它已经被采用作为一个独立的子特性。 觉得有用记得点赞关注哟！ 灰小猿陪你一起进步！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/800e90c0dc2183ff8d8c8e979f9a2643/" rel="bookmark">
			Leetcode链表5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ int kthToLast(struct ListNode* head, int k){ struct ListNode* slow_p=head,*p=head; while(k--){ p=p-&gt;next; } while(p!=NULL){ slow_p=slow_p-&gt;next; p=p-&gt;next; } return slow_p-&gt;val; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed9f4b8f879ddbb59fda1057ea3a2810/" rel="bookmark">
			import os
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、为什么要执行import os？
在python下写程序，需要对文件以及文件夹或者其他的进行一系列的操作。
os便是对文件或文件夹操作的一个工具。
os.name返回当前系统
os.getcwd()返回当前的路径
os.remove(路径）删除路径下的文件
2、 import os的作用
其实该语句就是在python环境下对文件，文件夹执行操作的一个模块。
相关详细讲解链接：学习链接1
https://blog.csdn.net/Li_haiyu/article/details/80448028
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6471d7411a7510d1807c65ff13765f77/" rel="bookmark">
			深度学习——早停法（Early Stopping）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习链接：https://www.jianshu.com/p/9ab695d91459
https://www.datalearner.com/blog/1051537860479157
目的： 为了获得性能良好的神经网络，网络定型过程中需要进行许多关于所用设置（超参数）的决策。
超参数之一是定型周期（epoch）的数量：亦即应当完整遍历数据集多少次（一次为一个epoch）？如果epoch数量太少，网络有可能发生欠拟合（即对于定型数据的学习不够充分）；如果epoch数量太多，则有可能发生过拟合（即网络对定型数据中的“噪声”而非信号拟合）。
早停法旨在解决epoch数量需要手动设置的问题。它也可以被视为一种能够避免网络发生过拟合的正则化方法（与L1/L2权重衰减和丢弃法类似）。
根本原因就是因为继续训练会导致测试集上的准确率下降。
那继续训练导致测试准确率下降的原因猜测可能是1. 过拟合 2. 学习率过大导致不收敛
原理 1.将数据分为训练集和验证集
2.每个epoch结束后（或每N个epoch后）： 在验证集上获取测试结果，随着epoch的增加，如果在验证集上发现测试误差上升，则停止训练；
3.将停止之后的权重作为网络的最终参数。
这种做法很符合直观感受，因为精度都不再提高了，在继续训练也是无益的，只会提高训练的时间。
那么该做法的一个重点便是怎样才认为验证集精度不再提高了呢？并不是说验证集精度一降下来便认为不再提高了，因为可能经过这个Epoch后，精度降低了，但是随后的Epoch又让精度又上去了，所以不能根据一两次的连续降低就判断不再提高。
一般的做法是，在训练的过程中，记录到目前为止最好的验证集精度，当连续10次Epoch（或者更多次）没达到最佳精度时，则可以认为精度不再提高了。
直观感受：
最优模型是在垂直虚线的时间点保存下来的模型，即处理测试集时准确率最高的模型。
为什么能够减小拟合：
当还未在神经网络运行太多迭代过程的时候，w参数接近于0，因为随机初始化w值的时候，它的值是较小的随机值。当你开始迭代过程，w的值会变得越来越大。到后面时，w的值已经变得十分大了。所以early stopping要做的就是在中间点停止迭代过程。我们将会得到一个中等大小的w参数，会得到与L2正则化相似的结果，选择了w参数较小的神经网络。
Early Stopping的缺点：
没有采取不同的方式来解决优化损失函数和降低方差这两个问题，而是用一种方法同时解决两个问题 ，结果就是要考虑的东西变得更复杂。之所以不能独立地处理，因为如果你停止了优化代价函数，你可能会发现代价函数的值不够小，同时你又不希望过拟合
作者：zzkdev
链接：https://www.jianshu.com/p/9ab695d91459
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
作者：zzkdev
链接：https://www.jianshu.com/p/9ab695d91459
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d034d4e0382ce00eb8902960b1457d35/" rel="bookmark">
			用户的埋点和用户行为分析实战（埋点数据分析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hello，大家好，很久没有发帖了，最近脑补最近的心得。
首先介绍一下，什么是埋点？ 我的个人见解，埋点是数据化的体现，数据化的定义回到最初，都是对时间，空间的定义，最简单的的埋点描述，就是基于时空论法则的什么人在什么空间什么时间段做了什么事。
既然如此，数据表的定义就可以给出，比如什么人对应一个用户的ID,什么空间假如场景在C端，那很多都是1级页面，2级页面之类的点击，什么时间段，那么可以定义为简单的时间类型字段，做了什么事，比如点击了分享，优惠券，加入购物车，这些运营动作，又或者是，观察了什么商品，商品的名称所传达的点击动作，都可以定义为一个行为。
用户的埋点解释已经给出，我们需要更快的切入到实战战场，就开始切人正题，从简单到复杂，我们假设有小明，小天这两个人，用户ID是分别是1，2，观测他们在早上做了什么电商的动作，然后我们根据他动作的次数去分析这两个人的重度行为是什么，进而在电商平台上给他们推送类似的产品，以提高我们电商产品的转化率，提高转化率的方法很多种，听自媒体说当年马化腾也男扮女在QQ聊天提高转化率（哈哈），这种是相对较有效率而直接。
重度行为的分析一般也是可以从时空论入手，比如时间（点击什么花费的时间最多），空间（点击的次数最多，发送的请求量最多），耗费时间方面还需要考虑数据库字段的设计，这里就不再多述，空间方面我们可以简单从点击次数入手，也是最为简单的手段，下面我们来看一下小明和小天做了什么？下面这个是csv文件，可以保存成csv格式就能导入。
id,username,time,behavior 1,小明,2019/1/1 12:00,球鞋 1,小明,2019/1/1 12:13,键盘 1,小明,2019/1/3 12:20,鼠标 1,小明,2019/1/1 12:40,鼠标 1,小明,2019/1/1 12:50,鼠标 1,小明,2019/1/3 14:20,键盘 2,小天,2019/1/1 12:00,可乐 2,小天,2019/1/1 12:13,王老吉 2,小天,2019/1/3 12:20,炸鸡 2,小天,2019/1/1 12:40,王老吉 2,小天,2019/1/1 12:50,炸鸡 2,小天,2019/1/3 14:20,全家桶 我这里就直接把小明和小天的数据库表csv格式给展现出来了，直观来看，小明应该是一个喜欢电脑方面，玩游戏的童鞋，小天一眼看去就是吃货，这个表结构很直观的体现出时空论的三要素，什么人，什么时间，什么行为，这里是一个APP或者小程序产品的埋点，我们其实还需要增加页面的定义的埋点（空间场景埋点），但这里没有具体可阐述的电商产品，我们就以最简单的形式来吧。
接下来我会使用python的一个库：pandas进行分析这些行为特征，找出他们的重度行为，当然简单来说，普通的数据库语言都能操作这些行为，但以后遇到更复杂的场景，pandas会更为好用。
这里先将脉络用导图方式画出来，这样好理解。
接下来，二话不多说，开始分析了，这里用到jupyter的形式去分析。
#%% #一，导入处理数据包 pandas,numpy import pandas as pd import numpy as np import os #设置分析文件的路径 os.chdir(r'C:\Users\foxirenseng\Desktop') #%% # 二，读取数据 df = pd.read_csv('behavior_analysis.csv',encoding='utf-8',dtype= {'id':str}) #%% #计算df的行列数 df.shape #(12, 4) #%% #观察df的每列的数据结构 df.info() #&lt;class 'pandas.core.frame.DataFrame'&gt; # RangeIndex: 12 entries, 0 to 11 # Data columns (total 4 columns): # # Column Non-Null Count Dtype # --- ------ -------------- ----- # 0 id 12 non-null object # 1 username 12 non-null object # 2 time 12 non-null object # 3 behavior 12 non-null object # dtypes: object(4) # memory usage: 512.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d034d4e0382ce00eb8902960b1457d35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7ef864faa8b070448388632112bfd11/" rel="bookmark">
			oracle database concepts,深入学习Oracle Database Concepts
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入学习Oracle Database Concepts
免费
专栏简介
分享Oracle Database Concepts(11g Release 2)相关知识，按照官方文档的先后顺序，通过理论知识与实践案例相结合的模式，对数据库知识进行分享。如果您希望深入学习关系型数据库概念和Oracle数据库基础知识，可以跟着作者的思路，一起深入学习Oracle Database Concepts。
专栏大纲
前言(Preface)
第1章 Oracle数据库简介(1 Introduction to Oracle Database)
第一部分 Oracle关系数据结构(Part I Oracle Relational Data Structures)
第2章 表和表簇(2 Tables and Table Clusters)
第3章 索引和索引组织表(3 Indexes and Index-Organized Tables)
第4章 分区、视图和其他模式对象(4 Partitions, Views, and Other Schema Objects)
第5章 数据完整性(5 Data Integrity)
第6章 数据字典和动态性能视图(6 Data Dictionary and Dynamic Performance Views)
第二部分 Oracle数据库访问(Part II Oracle Data Access)
第7章 SQL(7 SQL)
第8章 服务器端编程：PL/SQL和Java(8 Server-Side Programming: PL/SQL and Java)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7ef864faa8b070448388632112bfd11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e58ef9df6fb0f9003eae75cc4e77a98e/" rel="bookmark">
			MySQL基础查询与排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SELECT语句
SELECT &lt;列名&gt;, FROM &lt;表名&gt;;
WHERE语句 ： 从表中选取符合条件的数据
SELECT &lt;列名&gt;, …FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;;
相关法则
星号（）代表全部列的意思。 SQL中可以随意使用换行符，不影响语句执行（但不可插入空行）。 设定汉语别名时需要使用双引号（"）括起来。
在SELECT语句中使用DISTINCT可以删除重复行。 注释是SQL语句中用来标识说明或者注意事项的部分。分为1行注释"–“和多行注释两种”/ */"。
算术运算符
+，-，*，/
比较运算符
=， &lt;&gt;, &lt;=, &gt;, &lt;=, &lt;
逻辑运算符
NOT， AND, OR,
括号内的优先运行
聚合查询
COUNT, SUM, AVG, MAX, MIN
删除重复值 DISTINCT
COUNT函数的结果根据参数的不同而不同。COUNT()会得到包含NULL的数据行数，而COUNT(&lt;列名&gt;)会得到NULL之外的数据行数。
聚合函数会将NULL排除在外。但COUNT()例外，并不会排除NULL。
MAX/MIN函数几乎适用于所有数据类型的列。SUM/AVG函数只适用于数值类型的列。
想要计算值的种类时，可以在COUNT函数的参数中使用DISTINCT。
在聚合函数的参数中使用DISTINCT，可以删除重复数据。
分组
GROUP BY : 聚合键中包含NULL时,会将NULL作为一组特殊数据进行处理
GROUP BY的子句书写顺序有严格要求，不按要求会导致SQL无法正常执行，目前出现过的子句书写****顺序为：
1**.**SELECT → 2. FROM → 3. WHERE → 4. GROUP BY
常见错误:在使用聚合函数及GROUP BY子句时，经常出现的错误有：
①在聚合函数的SELECT子句中写了聚合健以外的列 使用COUNT等聚合函数时，SELECT子句中如果出现列名，只能是GROUP BY子句中指定的列名（也就是聚合键）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e58ef9df6fb0f9003eae75cc4e77a98e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ba5581dbebb8119d9445dc6ae8469b3/" rel="bookmark">
			JAVA 毕业设计 论文题目参考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机专业课设题目参考
1 基于JSP的“吃货SHOW”食品销售系统的设计与实现 2 基于JSP驾校管理系统的设计与实现
3 基于jsp的在线智能家居购物网站的设计与实现
4 基于微信小程序的教室选座系统
5 基于JSP的物资捐助系统
6 基于VUE+SpringBoot商业保险选购系统的设计与实现
7 基于jsp医院预约挂号平台系统
8 基于java web的空闲教室管理系统的设计与实现
10 基于JSP的自驾旅游网站设计与实现
11 基于SSM框架的机房管理系统的设计与实现
12 基于Java Web的走失人口档案系统的设计与实现
13 基于javaweb的餐厅点餐系统的设计与实现
14 基于javaweb的历史答疑系统
15 基于java的枣庄学院校内学习论坛的设计与实现
16 基于javaweb企业物流管理
17 基于JavaWeb的汽车销售网站的设计与实现
18 基于JavaWeb 的病床管理系统设计与实现
19 基于Javaweb的小区物业管理系统
20 基于JSP的当当网图书商城网站
21 基于微信小程序的校园二手商品交易
22 手机销售网站的设计与实现
23 电子图书商城的设计与实现
24 珠宝网上商城的设计与实现
25 食品购物网站
26 旅游管理系统的设计与开发
27 水果农贸商城网站的设计与实现
28 基于php的票务购买系统的设计与实现
31 基于vue的历史答疑系统
33 基于uni-app的在线学习交流平台的设计与实现
34 基于SSM教育云学习考试系统设计与实现
35 基于Springboot的梦想游旅游导航系统设计与实现
36 基于SSM票务影城联盟系统设计与实现
37 基于SSM框架的农村社会养老保险管理信息系统的设计与实现
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ba5581dbebb8119d9445dc6ae8469b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f20504d463cac6e71d468d2a08781cf/" rel="bookmark">
			airtest web 自动化实操
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境搭建 airtest内置python 和selenium库，并且进行封装，所以用来做web 自动化也是非常方便的
操作原理：
airtest web 自动化测试是基于python 语言和selenium 库，通过调用chrome浏览器Devtools Protoco协议，将用户
操作解析成python 脚本
1、准备安装chrome浏览器最(新版本为89版本)
特别注意：airtest 自带chromedriver 是不支持最新的版本chrome 浏览器，需要重新下载chrome 浏览器对应chromedriver 去覆盖airtest里面的版本，否则chrome
会启动不起来
下载地址：http://chromedriver.storage.googleapis.com/index.html
2、启动airtest设置chrome 浏览器的启动文件路径
选项-&gt;设置-&gt;selenium-&gt;chromepath 设置chrome 启动路径-&gt;ok
3、在airtest 的窗口中勾选上selenium window
4、新建.air Airtest项目
1） 新建.air 项目
2）点击启动浏览器，导入相应的包和初始化代码
包的导入和初始化代码
5、windows 窗口操作
1）windows窗口连接
1、选择游戏窗口
打开正在运行chrome的窗口，然后对需要的进行框选，则该窗口会展示在窗口界面
框选浏览器
选中后，该chrome 会在设备窗口展示
2、搜索窗口
搜索选择对应的窗口和选择游戏窗口差不多
3、其他
由于Windows应用的底层实现各不相同，有些应用窗口如果使用默认的一键嵌入方法，在嵌入到AirtestIDE里之后会遇到一些问题（例如嵌入后无法用鼠标操作、无法正常嵌入、 嵌入后无法显示图像等）。
针对这些问题，我们提供了一种无嵌入连接的方案，请在AirtestIDE的设置面板中，找到Device-Windows Embed Backup Method，勾选后即可使用备用方案来连接窗口。
接下来的连接方式和常规方法一样，点击选定窗口，然后选择待测窗口程序：
二、selenium 常用的操作 1、窗口操作
Web 录制无法模拟的按键操作，可以手动通过代码来完成，比如send keys， keys.ENTER 等等。
2、元素操作
· clear（） 清楚元素输入的内容
·send_keys() 模拟键盘按键输入内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f20504d463cac6e71d468d2a08781cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cd5ddc35a7c70badf6e4c8137a3ae39/" rel="bookmark">
			《长安十二时辰》之学习PMP项目管理、 NPDP产品经理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《长安十二时辰》之组建项目团队
PMP云课堂
PMP云课堂
项目经理
《长安十二时辰》之组建项目团队
《长安十二时辰》是网上口碑颇佳的一部电视剧，目前还在热播。通过已知的故事脉络，电视剧中的某些场景是可以作为项目管理的案例进行解读的。为了节约篇幅，我不对电视剧中人物进行详细介绍，有兴趣的可以先去看电视剧，再来看文章。
本文利用第一集中的部分场景，来看看项目团队是如何组建的？
原本的项目目标很简单，利用崔六郎引狼卫（可理解成恐怖分子）进长安城，然后利用军队捉获他们，通过审问获得狼卫获得的目的，从而保障长安城的安全。结果，十六位狼卫虽然有十五位被歼灭，结果首领曹破延逃跑。同时，崔六郎被杀，一位副队长殉职。面对这样的结局，身为项目经理的李必并没有责备下属，而是想办法如何补救失败的项目。
李必的措施是重新选择一个人来替代死去崔六郎的角色，他找到了张小敬。由于张小敬是死囚犯，所以李必借免除死罪的理由让其参与这个工作。他让张小敬一个人去追查曹破延的下落，并将其捉拿归案。整个过程要保密，不能干扰长安百姓，怕在上元节（正月十五）造成更大的恐慌和动乱。
李必向张小敬简要回顾了项目的过程，两人在交流的过程中，也找到了崔六郎失败原因：在抓捕狼卫的过程中，李必过于聪明地将驼铃声调成了“静音”，导致狼卫敏锐地发现了危险，杀死了崔六郎，并在拘捕过程中杀死了一位副队长黄山。
张小敬很快进入项目角色，通过解剖崔六郎的尸体，他发现了其留下的信息，从而推断长安城里不止有一个狼卫，应该还有很多人。
截至到此，由于崔六郎参与项目的失败，导致张小敬参与项目时，项目成员发生了变化，项目的主要目标虽然还是捉拿曹破延，但是通过分析发现，长安城里还有更多的狼卫，这些狼卫可能与曹破延有关联，有可能会制造危害长安的大事件。因此，这个项目的范围比之前变大了。为了更快地完成目标，整个项目被限定在12时辰（24小时）之内。
李必的项目成员，除了张小敬，还包括以下成员：
靖安司人员：以徐宾为主的办公人员，这些人员从各部门抽调过来，参与临时性项目，他们可以查看大唐所有的档案，通过大案牍术来分析数据，来为项目提供参考。这些数据可以理解成组织过程资产，也可理解成专家判断。总之，是一种相对客观的数据文档。 2.望楼人员：望楼是用来传递信息的，这些信息是加密的。另外，望楼上的武侯除了传递信息，也可以通过射箭来击毙可疑人员。总之，望楼主要以项目沟通为主，用于快速传递信息。
3.辅助人员：包括崔器、姚汝能、檀棋等。其中，崔器带领士兵主要以辅助抓捕为主；姚汝能和檀棋则属于机动人员，根据项目需要随时补位。
在项目经理李必的推动下，项目团队再次搭建完成。这个换了核心成员的项目团队，在接下来的12时辰内如何克服困难，如何相互协作，如何相互沟通，从而完成项目目标，也很值得玩味。
《长安十二时辰》之风险应对
PMP云课堂
PMP云课堂
项目经理
《长安十二时辰》之风险应对
项目执行过程中，项目经理最重要的一项技能是识别风险。当识别完风险后，还必须有应对措施。
在《长安十二时辰》第35集中，龙波为了利用太上玄元大仙灯杀死圣上，共制订了3个风险应对方案。
正常方案：由毛顺控制按钮，推出麒麟臂，杀死圣人。
第一个风险应对方案：如果第一套方案失败，还有一个备用装置，一样可以推出麒麟臂，杀死圣人。
第二个风险应对方案：如果前两套方案都不行，等燃灯的时候，圣人会射出一支金箭，一样可以推出麒麟臂。
第三个风险应对方案：如果前面的方案都不行。龙波会亲自去动手，确保麒麟臂能够推出，进而完成目标。
如果把龙波看作一位项目经理，把杀死圣人作为项目目标。那么，利用太上玄元大仙灯的麒麟臂则是这个项目成功的关键。
项目经理龙波为了项目能够正常执行，针对麒麟臂失效的风险，提出了3个应对举措。另外，他还对阻碍整体项目执行的关键人进行了梳理，比如张小敬等。以上这些事情，他做的都很到位。但是上面这些风险，大都是可识别的风险。真正考验项目经理的往往是不确定风险的识别及应对。
由于剧中角色所设定，项目经理龙波的失败就是在于没有识别出不确定风险。比如，他没有预料到闻染的死。最终，他不得不中止这个项目，并把项目目标变为与圣人交谈。
至此，项目经理龙波虽然识别了风险并做好了应对措施，看似完美。但是，他没有识别出不确定的风险，最终也因此失败了。所以，项目经理想要完成一项目标，必须集合所有的资源来分析风险，只有如此，才能最大程度上保证项目可控。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/110950ba1d36e500503073aa44b2aec0/" rel="bookmark">
			python中escape,一日一技：在 Python 正则表达式模块中逃跑（escape）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一日一技：在 Python 正则表达式模块中逃跑(escape)
摄影：产品经理
时间：从九溪十八涧出来后的小雨天
在编程语言中，有常见的符号被赋予了特殊的意义，例如小数点.，在正则表达式里面表示任意一个非换行符的字符；小于号
但有时候，我们只想让这些符号表示它本来的意思，不想让它的特殊意义表露出来，应该怎么办？
我们知道，在正则表达式中可以使用反斜杠来让一个特殊符号变成普通符号，例如.表示普通的小数点，\$表示普通的美元符号。
现在我有一个列表keywords_list，里面是100个字符串，我想判断是否有任意一个字符串在某个给定的句子中。如果用 for 循环一个一个去检查，效率非常低。于是可以考虑使用正则表达式：
import re
pattern = re.compile('|'.join(keywords_list))
if pattern.search('目标句子'):
print('目标句子中包含某个关键词')
但假设 keywords_list列表中有如下的字符串：
keywords_list = ['4.5', '+{d', '***']
那么我们使用正则表达式就会导致报错，如下图所示。
这是因为这些字符串里面存在特殊的符号，这些符号在正则表达式里面有特殊的意义，有使用的规范，不能随意使用。
但是，keywords_list里面有各种各样的特殊符号，难道要一个一个取出来，逐一x.replace('+', '+').replace('.', '.').replace('', '\')...?
当然不用，Python 的正则表达式模块已经帮你想好了解决办法，使用re.escape就能自动处理所有的特殊符号了！
它的用法如下：
&gt;&gt;&gt; import re
&gt;&gt;&gt; keywords_list = ['4.5', '+{d', '***']
&gt;&gt;&gt; pattern_str = '|'.join(keywords_list)
&gt;&gt;&gt; safe_pattern_str = re.escape(pattern_str)
&gt;&gt;&gt; print(safe_pattern_str)
4\.5\|\+\{d\|\*\*\*
&gt;&gt;&gt; re.compile(safe_pattern_str)
re.compile('4\\.5\\|\\+\\{d\\|\\*\\*\\*')
&gt;&gt;&gt;
运行效果如下图所示：
解决问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/183d673319cfc7ee3b2f4827d4ca99a4/" rel="bookmark">
			下拉框(select)，可以多选，带有分组搜索功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FSelect使用 实际效果使用教程 实际效果 使用教程 FSelect文件
下载 FSelect 将 fSelect.css 与 fSelect.js 拖入项目 需要引入 fSelect.css 与 fSelect.js 文件 &lt;link href="fSelect.css" rel="stylesheet" type="text/css"&gt; &lt;script src="fSelect.js"&gt;&lt;/script&gt; &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;jQuery fSelect Plugin Demo&lt;/title&gt; &lt;link href="fSelect.css" rel="stylesheet" type="text/css"&gt; &lt;/head&gt; &lt;body&gt; &lt;select class="sel" multiple="multiple" style="width: 500px;"&gt; &lt;optgroup label="Languages"&gt; &lt;option value="cp"&gt;C++&lt;/option&gt; &lt;option value="cs"&gt;C#&lt;/option&gt; &lt;option value="oc"&gt;Object C&lt;/option&gt; &lt;option value="c"&gt;C&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label="Scripts"&gt; &lt;option value="js"&gt;JavaScript&lt;/option&gt; &lt;option value="php"&gt;PHP&lt;/option&gt; &lt;option value="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/183d673319cfc7ee3b2f4827d4ca99a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c01d42918ce3bbc18eeec380a80064c/" rel="bookmark">
			树莓派3b&#43;串口/TTL采集噪声传感器PG-760/ZY-C python程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要准备的东西
1.树莓派3b+；
2.噪声传感器，我用的是串口/TTL款的，5V供电；
硬件接线 ## 实物接线图
树莓派串口配置 此节参考添加链接描述
（1）修改cmdline.txt文件 编辑cmdline.txt文件 $ sudo nano /boot/cmdline.txt 原来cmdline.txt文件的内容如下： console=serial0,115200 console=tty1 root=PARTUUID=a05c3c8f-02 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait quiet splash plymouth.ignore-serial-consoles 将有关console的内容全部删掉，修改后的cmdline.txt文件内容如下： root=PARTUUID=a05c3c8f-02 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait quiet splash plymouth.ignore-serial-consoles （2）关闭板载蓝牙 禁用蓝牙功能 $ sudo systemctl disable hciuart 编辑config.txt文件 $ sudo nano /boot/config.txt 增加如下一行： dtoverlay=pi3-disable-bt 重启树莓派！！！ （先重启再进行下一步） （3）禁用串口的控制台功能 编辑config.txt文件，增加如下一行： enable_uart=1 python代码 import time import serial import sys import RPi.GPIO as GPIO port="/dev/ttyAMA0" usart=serial.Serial(port,9600,timeout=None) usart.flushInput() sendbuf = bytearray.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c01d42918ce3bbc18eeec380a80064c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90636c1a4daa233ce316ee3a0ebc1fc4/" rel="bookmark">
			matlab 如何得到矩阵的 角向和 径向分布,波函数的角度分布图和概率径向分布图.ppt...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		波函数的角度分布图和概率径向分布图
比较电子云的角度分布图与波函数的角度分布图: 相似之处：二者形状相似; 区别：(1)电子云的角度分布图更要瘦些; 这是因为Y值小于1 ，平方后Y2值更小. (2)电子云的角度分布图均为正值; 因为Y 值平方后无正负的区别。 结论： (1)1s轨道的径向分布图在r＝53pm时一个峰值， 说明电子在半径53pm处出现的概率最大。 ②外层电子对选定电子的屏蔽常数σ为零。 ③同组电子间的屏蔽常数σ=0.35； 但1s内σ=0.30。 ④若选定的是ns,np态的电子，则(n-1)层电子对该电子的 σ=0.85。 更内层电子对该电子的σ=1.00。 ⑤若选定的是nd和nf态的电子，除了同组电子间的σ=0.35； 其余内组电子的对该电子的σ=1.00 2. 钻穿效应 6-4-2. 多电子原子的能级图 美国著名化学家鲍林(L.Pauling) 根据光谱实验数据和某些近似的理论计算， 提出了多电子原子的原子轨道的近似能级图。 核外电子的排布应遵循三原则: 即能量最低原理、鲍利不相容原理、洪特规则。 例： 26Fe: 1s2 2s2 2p6 3s2 3p6 3d6 4s2 6-6-1、有效核电荷数(补充) 6-6-2、原子半径 6-6-3、电离能 6-6-4、电子亲和能 6-6-5 电负性 镧系收缩的特殊性： 镧系元素的原子半径缩小的幅度很小， 导致La到Lu共15种元素，它们的原子半径很相近; 从0.183nm降至0.174nm，仅减少0.009nm， 从而造成了镧系元素及镧系后面元素的某些性质的特殊。 ①ⅠB和ⅡB族：价电子构型为 (n-1)d10 ns1-2 族数 = ns 电子数 ②ⅢB ~ ⅦB 族：价电子构型为(n-1)d1-5 ns1-2 族数 = 价电子总数 ③Ⅷ 族：包括了三个纵列共9种元素，它们性质相似， 故合并Ⅷ 族。价电子总数为8-10个。 价电子构型为(n－1)d 6~8ns 2 需说明：镧系和锕系元素理论上属于IIIB, 但它们性质特殊，单独列在周期表下边。 副族元素的族数与价层电子数的关系可分三种情况： 6-5 元素周期表 1、元素周期表中的周期 2、元素周期表中的族 3、元素周期表中的分区 三、元素在周期表中的分区 周期表划分为五区：s区， p区，d区，ds区 和f 区 f 第6章 原子结构和元素周期律 本章内容： 6-1 近代原子结构理论的确立(不讲) 6-2 微观粒子运动的特殊性(不讲) 6-3 核外电子运动状态的描述(重点) 6-4 核外电子的排布(重点) 6-5 元素周期表 6-6 元素性质的周期性变化规律 6-6 元素性质的周期性变化规律 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90636c1a4daa233ce316ee3a0ebc1fc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36d73d130c346ca368b1021f132eb404/" rel="bookmark">
			【操作系统】互斥：软件解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		互斥：软件解决方法 算法一 算法思路 预留一个全局内存区域，并标记为turn。进程（P0或P1）想进入它的临界区执行时，要先检查turn的内容。若turn的值等于进程号，则该进程可以进入它的临界区；否则该进程被强制等待。等待进程重复地读取turn的值。直到被允许进入临界区。这一过程称为忙等待（busy waiting） 或 自旋等待（spin waiting），进程在获得临界区的访问权并完成访问后，必须为另一个进程更新turn的值。
P0 :
while(turn != 0) {/* busy waiting */} /* critical section */ turn = 1; P1 :
while(turn != 1) {/* busy waiting */} /* critical section */ turn = 0; 缺陷 进程必须严格交替（P0临界区执行完后才会更新turn值，使得P1跳出忙等待状态，同理P0也需等待P1临界区执行完）使用它们的临界区，因此执行的步调由两个进程较慢的进程决定。
例如：若P0在1小时内仅使用临界区1次，而P1要以1000次/小时的速率使用临界区，则P1就必须适应P0的节奏。 BUG 若一个进程终止，则另一个进程就会被永久阻塞。无论进程是在临界区内终止还是在临界区之外终止，都会发生这种情况。
例如：P0在执行到第二行代码（临界区内）时终止，此时turn值为0且此后不会被更新，因此P1将永久处于忙等待状态；P0在执行到第三行代码（临界区外）时终止，此时turn值为1，于是P1进入临界区，执行完后便将turn值置为0，而P0进程因为终止便不会再更新turn值，因此P1将永久处于忙等待状态。 算法二 算法一仅由一个共享的仲裁变量去实现进程间的互斥，因此进程之间必须严格交替执行，进程之间的依赖关系过强
算法二为每一个进程都配备了专门的”钥匙“，这里定义一个bool数组flag，flag[0]与P0关联，flag[1]与P1关联，每个进程可检查但不能改变另一个进程的flag值
算法思路 一个进程要进入临界区时，它会周期性地检查另一个进程的flag，直到其值为false，这表明另一个进程不在临界区内。检查进程立即设置自己的flag为true，进入自己的临界区。离开临界区时，将自己的flag设置为false。
P0 :
while(flag[1]) {/* busy waiting */} flag[0] = true; /* critical section */ flag[0] = false; P1 :
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36d73d130c346ca368b1021f132eb404/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/83/">«</a>
	<span class="pagination__item pagination__item--current">84/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/85/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>