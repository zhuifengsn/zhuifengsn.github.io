<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0608743f98f409d35a97807a9d878847/" rel="bookmark">
			晨跑的好处
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		宜轻适当的晨练是“活力之源”，是一天活动的首次启动，具有“开关效应”。轻度晨练可使人全天充满活力、生机勃勃，并能增强幽默风趣感及艺术感染力，不易出现内分泌紊乱，并有减少焦虑，改善睡眠质量的作用。这一切都是在轻度晨练可增强人体生物钟有序性的基础上实现的。晨练有度，微汗即止，才可见效。
早晨空气清新，跑一会儿步，会使人情绪饱满；晨跑会使全身各器官功能提高到较高水平，并能提高一天的新陈代谢率。
跑步结束后休息一会儿，用早餐、上班，不仅能增强体力，还能使身体灵活、思路敏捷，有助于提高工作效率。有些研究发现，在早晨锻炼的人比那些在其他时间锻炼的人更可能会坚持一个计划，晨跑有利于良好生活习惯的养成，很多朋友都把晨跑作为养成早睡早起习惯的手段。
人们常说生命在于运动，科学的运动可以增加人体免疫力，多年来许多人都是坚持晨练，但由于冬季的早晨空气上下流通不畅，烧煤和汽车尾气排放等产生的氮氧化物、碳氢化物等各种有害物质不容易扩散，人体吸入后容易产生呼吸道疾病，因此专家建议在空气不好或雾大天气最好不要进行晨炼，而且还要尽量减少在户外活动时间。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ee720fcd88ac6c3b5f327bce8b79fd1/" rel="bookmark">
			mongoose中的文档中的插入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文档新增 文档新增有三种方法，一种是使用上面介绍过的文档的save()方法，另一种是使用模型model的create()方法，最后一种是模型model的insertMany()方法
1.save() [注意]回调函数可以省略
save([options], [options.safe], [options.validateBeforeSave], [fn]) 新建{age:10,name:'save'}文档，并保存
var mongoose = require('mongoose'); mongoose.connect("mongodb://u1:123456@localhost/db1", function(err) { if(!err){ var schema = new mongoose.Schema({ age:Number, name: String}); var temp = mongoose.model('temp', schema); //使用链式写法 new temp({age:10,name:'save'}).save(function(err,doc){ //[ { _id: 59720bc0d2b1125cbcd60b3f, age: 10, name: 'save', __v: 0 } ] console.log(doc); }); } }); 2.create() 使用save()方法，需要先实例化为文档，再使用save()方法保存文档。而create()方法，则直接在模型Model上操作，并且可以同时新增多个文档
Model.create(doc(s), [callback]) 新增{name:"xiaowang"}，{name:"xiaoli"}这两个文档
var mongoose = require('mongoose'); mongoose.connect("mongodb://u1:123456@localhost/db1", function(err) { if(!err){ var schema = new mongoose.Schema({ age:Number, name: String}); var temp = mongoose.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ee720fcd88ac6c3b5f327bce8b79fd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad2f649cee2d321f8687a2b248616155/" rel="bookmark">
			对图像高频信号和低频信号的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对图像高频信号和低频信号的理解 https://blog.csdn.net/jialeheyeshu/article/details/51097860
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b702762e11f889371f65925e42df869/" rel="bookmark">
			group  by详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 概述 group_by的意思是根据by对数据按照哪个字段进行分组，或者是哪几个字段进行分组。
二. 语法 select 字段 from 表名 where 条件 group by 字段
或者
select 字段 from 表名 group by 字段 having 过滤条件
注意：对于过滤条件，可以先用where，再用group by或者是先用group by，再用having
三. 案例 1 创建表格并插入数据
说明：在plsql developer上创建表格并插入数据，以便下面进行简单字段分组以及多个字段分组，同时还结合聚合函数进行运算。
创建student表
create table student
(id int not null ,
name varchar2(30),
grade varchar2(30),
salary varchar2(30)
)
在student表中插入数据
insert into student values(1,'zhangsan','A',1500);
insert into student values(2,'lisi','B',3000);
insert into student values(1,'zhangsan','A',1500);
insert into student values(4,'qianwu','A',3500);
insert into student values(3,'zhaoliu','C',2000);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b702762e11f889371f65925e42df869/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ea05142672a6c2a5ad4552e1e27f527/" rel="bookmark">
			give gandies(数学题)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		传送门：https://nanti.jisuanke.com/t/31716
题意：求2的n次方（10^1000000）mod 1e9+7
思路：利用费马小定理，a^(p-1)=1（mod p），然后求出次方模1e9+6的结果。求次方模1e9+6的方法是还原过程中每次mod 1e9+6
#include &lt;bits/stdc++.h&gt; using namespace std; long long pow(long long a,long long b,long long mod) { long long ans=1; while(b&gt;0) { if(b&amp;1)	ans=ans*a%mod; a=a*a%mod; b/=2; } return ans; } inline char inputchar() { return getchar(); } int p[10000000]; int main() { int num; scanf("%d",&amp;num); while(num--) { char ch = inputchar(); int cnt=0; memset(p,0,sizeof(p)); while(ch &lt; '0' || ch &gt; '9') ch = inputchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') { p[++cnt]=ch-'0'; ch=inputchar(); } long long now=0; for(int i=1;i&lt;=cnt;i++) { now*=10; now+=p[i]; now%=1000000006; } int ans=pow(2,--now,1000000007); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ea05142672a6c2a5ad4552e1e27f527/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00d7b918df6450ab6132490a7cf1e50b/" rel="bookmark">
			小型web服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小型web服务器 一、项目平台： centos 6.5
二、实现功能 ：网站的后台程序
三、基本要求：
1.基于HTTP/1.0版本的web服务器，客户端可以通过GET、POST方法进行资源请求
2.服务器将客户请求的资源以html页面的形式呈现，并且能够进行差错处理。
3.服务器能运行简单的cgi
四、项目的背景知识
1.了解HTTP协议
是超文本传输，是应用层的协议，他是基于TCP协议的。他的工作过程：客户端通过浏览器向服务器发送请求，浏览器将请求的资源在传给浏览器，在关闭连接。
2.了解url
是统一资源定位符，也是我们俗称的网址。
http://www.example.jp:80/dir/index.html？uid=1
如上一个url包括协议方案名，服务器的地址和端口号，请求资源的路径,查询字符串。
在这里的查询字符串是根据请求的方法来确定有还是没有。若为GET方法就会有查询字符串。若为POST方法就没有，他是通过http请求报文中的body发送的。
3.http请求及响应的格式
五、项目的基本思路
1.通过socket来建立通信
a) 创建socket
b) 绑定地址端口
c) 监听
d) 进入事件循环
2.服务器接收浏览器的请求并且进行解析
a)解析请求的首行，获取方法和url（在这里只考虑GET、POST的请求方法）
b)再去解析出url获取path和query_string
c) 读取并解析header（这里只获取到content-length）其余信息丢弃
d)body暂时不进行解析，根据后面的情况再去判断是否需要解析
3.根据解析好的HTTP请求来进行计算
a ) 静态页面：服务器上的某个固定位置的html文件，文件内容若没有人去修改，就会一直不变，浏览器的页面就一样。
也就是进入到一个非cgi模式
（1）拼接目录
/index.html----&gt;不是一个绝对路径，只是和服务器上某个路径匹配的
是一个相对于HTTP的根目录---&gt;允许对外访问的文件集中到某个目录下面就是HTTP的根目录
若url_path是一个文件，直接进行拼接
若url_path是一个目录，就会默认构造一个文件路径，尝试取目录下的index.html文件
（2）打开文件
读取文件中的内容，根据内容构造http响应，文件中的内容就是响应中body的部分
b）动态页面：服务器会根据用户输入参数来决定生成什么样的页面。
进入到一个cgi模式
（1）HTTP服务器需要创建子进程
（2）子进程进行程序替换，替换成磁盘上某个可执行程序
父进程执行父进程的相关逻辑：
1.将body写入管道
2.父进程尝试读取子进程构造的结果
3.父进程构造HTTP响应，写回客户端
子进程传递给父进程的信息
1.设置环境变量（方法、query_string、content_length）
2.重定向
3.根据url_path构造路径
4.进行替换
六、测试
用一个简单版的计算器来测试CGI
1.基于CGI协议获取到需要的参数
2.根据业务逻辑（计算器相关的逻辑），进行计算
3.把结果构造成HTML写回到标准输出中
代码实现：
1.创建socket连接，采用多线程来进行处理清楚
#define SIZE (1024*10) 17 typedef struct HttpRequest 18 { 19 char first_line[SIZE]; 20 char *method; 21 char *url; 22 char *url_path; 23 char *query_string; 24 int content_length; 25 }HttpRequest; //线程的入口函数 void* ThreadEntry(void* arg) { int32_t new_sock=(int32_t)arg; HandlerRequest(new_sock); return NULL; } typedef struct sockaddr_in sockaddr_in; typedef struct sockaddr sockaddr; //服务器的入口函数 void HttpServerStart(const char* ip,short port) { //0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00d7b918df6450ab6132490a7cf1e50b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d18d19244d9103a14aa491d2ce3b28b9/" rel="bookmark">
			关于virtualenv虚拟环境中python版本的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过virtualenv创建了基于python3的虚拟环境，激活虚拟环境后发现执行程序时依然在用python2在解析，后折腾一番后发现原因是，虚拟环境中未pip install flask，导致执行程序时系统自动去加载系统默认的python2。折腾的经过如下： 通过如下两行命令分别创建基于python2和python3版本的两个虚拟环境：
virtualenv -p /usr/bin/python ~/virtualenv/one #python2 virtualenv -p /usr/local/python3/bin/python3 ~/virtualenv/two #python3 分别激活两个虚拟环境，查看python版本对应没问题：
[root@localhost one]# source bin/activate (one) [root@localhost one]# python -V Python 2.7.5 (one) [root@localhost one]# [root@localhost two]# source bin/activate (two) [root@localhost two]# python -V Python 3.6.4 (two) [root@localhost two]# 用flask框架的入门程序测试：
1 2 from flask import Flask 3 4 app = Flask(__name__) 5 6 7 @app.route('/') 8 def hello_world(): 9 return '这是首页' 10 在基于python3的虚拟环境two中启动程序，然后浏览器端访问后报错如下（编码有误，不支持中文）：
百度，python2的确默认不支持中文，若要支持中文，需要在代码前加上#coding=utf-8；但python3默认是“utf-8”编码，应该是支持中文的啊。难道解析程序的是python2？？？，另外网页端报错信息里有python2.7的字样，我更怀疑这是python2。为了证明这是python2而不是python3，通过两个版本对print打印语句的区别：
python2下执行print ('hhh','ggg')结果应该为：('hhh','ggg')
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d18d19244d9103a14aa491d2ce3b28b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0eef7722bc4ab9104fa2d2f9e74e545f/" rel="bookmark">
			关于transform函数实现string大小写转化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于transform函数
1.头文件algorithm
2.transform(处理对象容器起始地址，处理对象容器结束地址，存放结果的容器地址，处理操作（可自定义））
注意：前后两个容器的大小一致
3.transform( str.begin() , str.end() , str.begin() , ::toupper );//化为大写
transform( str.begin() , str.end() , str.begin() , ::tolower );//化为小写
4.char op(char ch)
{if (ch&gt;=‘A’&amp;&amp;ch&lt;=‘Z’)
return ch+32;
else return ch;}
transform( str.begin(), str.end() , second.begin() , op);
待拓展：将op换为其他功能函数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2fbaec0f0e86006504cd979c4c1d5b9/" rel="bookmark">
			L1-025 正整数A&#43;B（15 分）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题的目标很简单，就是求两个正整数A和B的和，其中A和B都在区间[1,1000]。稍微有点麻烦的是，输入并不保证是两个正整数。
输入格式： 输入在一行给出A和B，其间以空格分开。问题是A和B不一定是满足要求的正整数，有时候可能是超出范围的数字、负数、带小数点的实数、甚至是一堆乱码。
注意：我们把输入中出现的第1个空格认为是A和B的分隔。题目保证至少存在一个空格，并且B不是一个空字符串。
输出格式： 如果输入的确是两个正整数，则按格式A + B = 和输出。如果某个输入不合要求，则在相应位置输出?，显然此时和也是?。
输入样例1： 123 456 输出样例1： 123 + 456 = 579 输入样例2： 22. 18 输出样例2： ? + 18 = ? 输入样例3： -100 blabla bla...33 输出样例3： ? + ? = ? #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;string.h&gt; #include&lt;cstdio&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; int main(){ char s1[50]; char s2[50]; cin&gt;&gt;s1&gt;&gt;s2; int flag1=1,flag2=1; for(int i=0;i&lt;strlen(s1);i++) { if(s1[i]&lt;'0'||s1[i]&gt;'9')flag1=0; } for(int i=0;i&lt;strlen(s2);i++) { if(s2[i]&lt;'0'||s2[i]&gt;'9')flag2=0; } double a = atof(s1); if(a&gt;1000||a&lt;1)flag1=0; double b = atof(s2); if(b&gt;1000||b&lt;1)flag2=0; if(flag1){ cout&lt;&lt;s1; } else{ cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2fbaec0f0e86006504cd979c4c1d5b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03a5f268addd68febaa93884ef831481/" rel="bookmark">
			math.h库函数中atan与atan2的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		详情：https://blog.csdn.net/tuyang120428941/article/details/5822041
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dd7cb9b528c3d9681c22ef38b923353/" rel="bookmark">
			c#调用python的四种方法（尝试了四种，只详细讲解本人成功的后两种，其余方法只列出，详细用法请自行谷歌百度）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用c#，nuget管理包上下载的ironPython安装包
尝试后发现，对引用了numpy等第三方库的python代码，会报找不到模块xxx的错误，上网查证后发现此问题基本难以解决
二、使用c++程序调用python文件，然后将其做成动态链接库（dll），在c#中调用此dll文件
限制：实现方式很复杂，并且受python版本、(python/vs)32/64位影响，而且要求用户必须安装python运行环境
三、使用安装好的python环境，利用c#命令行，调用.py文件执行
优点：执行速度只比在python本身环境中慢一点，步骤也相对简单
缺点：需要用户安装配置python环境
实用步骤：
1、下载安装python，并配置好环境变量等（本人用的Anaconda，链接此处不再提供）
2、编写python文件（这里为了便于理解，只传比较简单的两个参数） 注：这两个python文件，我引用了numpy第三方库，也要安装后才能在python中使用
#multi.py def multiplication(a,b): return a*b #main.py import numpy as np import multi import sys def func(a,b): result=np.sqrt(multi.multiplication(int(a),int(b))) return result if __name__ == '__main__': print(func(sys.argv[1],sys.argv[2])) ps:为了import不报错，尽量把multi.py文件放main.py同一文件夹下。因为打包exe文件执行后，可能会报找不到Multi模块的错误 3、在c#中调用上述主python文件：main.py
(我直接建了一个wpf文件，放在一个按钮的点击事件中执行了，你们随意)
private void Button_Click(object sender, RoutedEventArgs e) { string[] strArr=new string[2];//参数列表 string sArguments = @"main.py";//这里是python的文件名字 strArr[0] = "2"; strArr[1] = "3"; RunPythonScript(sArguments, "-u", strArr); } //调用python核心代码 public static void RunPythonScript(string sArgName, string args = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dd7cb9b528c3d9681c22ef38b923353/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27253a4fff27a38cea52d8ac6becf0ae/" rel="bookmark">
			java编程题50道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JAVA基础编程练习50题
本文对50道经典的java程序题进行详细解说，对于初学者可以跳过一些逻辑性太强的题目，比如第一题用到了方法的递归，初学者可能不理解，最好先看那些有if、for、while可以简单解决的程序题！但是，对于比较深入学习过的同学，还是希望可以一口气就看完，这是比较全面思维锻炼！
【程序1】
题目：古典问题：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子对数为多少？
程序分析：兔子的规律为数列1,1,2,3,5,8,13,21….
做这种题目，最好的做法就是找出规律，跟高中的数列一样 本题有：a[n]=a[n-1]+a[n-1],而第一第二项都知道了，后面的值也可以求得 public class Programme1 {
public static void main(String[] args) { System.out.print("请输入你想知道的兔子数量的月份："); Scanner scanner=new Scanner(System.in); int n=scanner.nextInt();//获取输入的整数 System.out.println("第"+n+"个月兔子总数为"+fun(n)); scanner.close(); } //求得所需月份的兔子的数量，返回值为兔子的数量 private static int fun(intn){ if(n==1 ||n==2) return 1; else returnfun(n-1)+fun(n-2); } }
【程序2】
题目：判断101-200之间有多少个素数，并输出所有素数。
程序分析：
* 素数是：只能被1或本身整除的数，如：3,5,7,11,131... *判断素数的方法：用一个数分别去除2到sqrt(这个数)， *其实用这个数分别去除2到他本身少1的数也可以，但是运算时间增加了 *如果能被整除，则表明此数不是素数，反之是素数。 public class Programme2 {
public static void main(String[] args) { int sum=0; for (inti = 100; i &lt; 200;i++) { if (IsRightNum(i)) { //判断这个数是不是素数 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27253a4fff27a38cea52d8ac6becf0ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/180353fbdb512e45c2d38fe5e62fc636/" rel="bookmark">
			js的基本特点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 JavaScript是一种属于网络的脚本语言,已经被广泛用于Web应用开发,常用来为网页添加各式各样的动态功能,为用户提供更流畅美观的浏览效果。通常JavaScript脚本是通过嵌入在HTML中来实现自身的功能的。 [3] 是一种解释性脚本语言（代码不进行预编译）。 [4] 主要用来向HTML（标准通用标记语言下的一个应用）页面添加交互行为。 [4] 可以直接嵌入HTML页面，但写成单独的js文件有利于结构和行为的分离。 [4] 跨平台特性，在绝大多数浏览器的支持下，可以在多种平台下运行（如Windows、Linux、Mac、Android、iOS等）。 Javascript脚本语言同其他语言一样，有它自身的基本数据类型，表达式和算术运算符及程序的基本程序框架。Javascript提供了四种基本的数据类型和两种特殊数据类型用来处理数据和文字。而变量提供存放信息的地方，表达式则可以完成较复杂的信息处理。 [5] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ddee5eb6caa8f9a19655ba1a2d915a9/" rel="bookmark">
			atan(y/x)与atan2(y,x)的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C/C++标准库中计算正切的函数有两个，一个是atan(y/x)，一个是atan2(y, x)。
atan2(y, x)是4象限反正切，它的取值不仅取决于正切值y/x，还取决于点 (x, y) 落入哪个象限：
当点(x, y) 落入第一象限时，atan2(y, x)的范围是 0 ~ pi/2;当点(x, y) 落入第二象限时，atan2(y, x)的范围是 pi/2 ~ pi;当点(x, y) 落入第三象限时，atan2(y, x)的范围是 －pi～－pi/2;当点(x, y) 落入第四象限时，atan2(y, x)的范围是 -pi/2～0. 而 atan(y/x) 仅仅根据正切值为y/x求出对应的角度 （可以看作仅仅是2象限反正切）：
当 y/x &gt; 0 时，atan(y/x)取值范围是 0 ~ pi/2；当 y/x &lt; 0 时，atan(y/x)取值范围是 -pi/2～0. 故 atan2(y, x) = atan(y/x) 仅仅发生在 点 (x, y) 落入第一象限 （x&gt;0, y&gt;0）或 第四象限（x&gt;0, y&lt;0）。
例如，假设y =1.0, x = -1.0，则 atan(y/x) = atan(-1.0) = -pi/4, 而 atan2(y, x) = 3*pi/4。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ddee5eb6caa8f9a19655ba1a2d915a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41446aaa5fd6ec8cb508ca4e85a4f76c/" rel="bookmark">
			WM_MOUSEWHEEL与WM_MOUSEHWHEEL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转动滚轮会导致Windows在有输入焦点的窗口（不是鼠标光标下面的窗口）产生WM_MOUSEWHEEL消息。所以当子窗口没有焦点的时候将收不到消息WM_MOUSEWHEEL。但是，当我们把鼠标移到某个子窗口的时候，并转动滚轮，应该是希望这个子窗口响应滚轮，而不管它是否有焦点。最直接的解决方法是调用SetFoucs函数把这个子窗口设为有焦点。
常规来说，滚轮是改变滚动条位置的，而单击鼠标左键才是用来改变焦点的。滚动滚轮的时候焦点改变并不是我们所希望的。
那我们要怎么又使鼠标下面的窗口响应滚轮， 而又不改变焦点呢？ 这就需要重载 PreTranslateMessage 来改变响应WM_MOUSEWHEEL消息的窗口。
例子： BOOL CXXXApp::PreTranslateMessage(MSG* pMsg)
{
if (pMsg-&gt;message == WM_MOUSEHWHEEL || pMsg-&gt;message == WM_MOUSEWHEEL)
{
POINT pos; GetCursorPos (&amp;pos); pMsg-&gt;hwnd = WindowFromPoint (pos); }
return CWinAppEx::PreTranslateMessage(pMsg);
}
对于没用MFC的程序来说，可以参考下面的代码
int WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) { MSG msg; while (GetMessage (&amp;msg, NULL, 0, 0)) { if (msg.message == WM_MOUSEWHEEL) { POINT pos; GetCursorPos (&amp;pos); msg.hwnd = WindowFromPoint (pos); //要在TranslateMessage 函数前面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41446aaa5fd6ec8cb508ca4e85a4f76c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3997275ca31ca6b83a60af9cd873d5e/" rel="bookmark">
			界面数据量大，导致界面卡死的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Application.DoEvents();
支持在快速刷新界面的同时，允许响应消息的机制（刷新界面过程中的按钮点击也属于消息一种）
切记：不要再程序中频繁使用该语句，使用弊端是由于需要不断的轮询各个消息，会影响程序的性能。
转载于:https://www.cnblogs.com/zst-blogs/p/9533331.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3de3790d9af1ba3364ae6f6214829799/" rel="bookmark">
			建模方法（四）-因子分析定义和应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因子分析(factor analysis)也是一种降维、简化数据的技术。 它通过研究众多变量之间的内部依赖关系，使用少数几个“抽象”的变量来表示其基本的 数据结构。这几个抽象的变量被称作“因子”，能反映原来 众多变量的主要信息。原始的变量是可观测的显在变量，而 因子一般是不可观测的潜在变量。 例如：商店的环境、商店 的服务和商品的价格作为因子，这三个方面除了价格外，商店的环境 和服务质量，都是客观存在的、抽象的影响因素，都不便于 直接测量，只能通过其它具体指标进行间接反映。因子分析 就是一种通过显在变量测评潜在变量，通过具体指标测评抽 象因子的统计分析方法。
因子分析类型分为R型因子分析和Q型因子分析。就像聚类分析分为R型和Q型一样，R型的因子分析是对变量作因子分析， Q型因子分析是对样品作因子分析。
下面我们以R型为例，介绍因子分析。
R型因子分析的模型如下所示：
R因子分析中的公共因子是不可直接观测但又客观存在的共 同影响因素，每一个变量都可以表示成公共因子的线性函数 与特殊因子之和，即 式中的F1 ,F2，...Fm称为公共因子，εi称为 Xi的特殊因子，Xi为可测变量。
模型的矩阵形式如下：
（7.2）
以上式子满足：
（1）式很好理解，因为我们目的是降维所以因子的数量一般都小于变量数量，不然没有任何意义。
（2）式需要概率论基础，Cov表示协方差，相关系数的分子为协方差，而相关系数描述变量间的线性相关性，如果相关系数为0，表示变量线性无关，因为特殊因子如果与公共因子有线性关系，则特殊因子可以合并到公共因子里面。
（3）与（2）类似，从这里可以看出为什么要用因子分析，各个变量相互相关，因子分析就是找出互不相关因子，揭示这些变量数据背后的结构，找出各个变量表达的主要信息。
（4）可以这样理解因为ε是变量的特殊因子，所以只与变量有关。
如果想要理解上诉的公式，可以参考概率论相关章节，如果只想知道如何应用因子分析，不知道概率论公式不影响。
模型中的aij称为因子“载荷”，是第i个变量在第j个因子上 的负荷，因此矩阵 A 称为因子载荷矩阵。注意因子载荷矩阵A不是唯一的，在实际的应用中常常利 用这一点，通过因子的变换，使得新的因子有更好的实际意 义。 实 际上因子载荷矩阵存在明显的统计意义。
aij是 变量Xi和因子Fj的相关系数（需要标准化Xi和Fj得出），它一方面表示Xi对Fj的依赖程度，绝对值 越大，密切程度越高；另一方面也反映了变量Xi对公共因子Fj 的相对重要性。
下面介绍变量的共同度。
设因子载荷矩阵为A，称第i行元素的平方和，即 为变量Xi的共同度。 由因子模型，知 对Xi做标准化处理后，得：
（7.8）式说明变量Xi的方差由两部分组成： 第一部分为变量Xi的共同度，它描述了全部公共因子对变量Xi 的总方差所作的贡献，反映了公共因子对变量Xi的影响 程度。第二部分为特殊因子εi 对变量Xi的方差的贡献， 通常称为个性方差。
上面是对载荷矩阵A的一行的计算，下面对列计算，即公因子Fj对全部变量的贡献。
设因子载荷矩阵为A，称第j列元素的平方和，即 为公共因子Fj对所有变量的贡献，即上述结果表示同一公共因子Fj对 各变量所提供的方差贡献之总和，它是衡量每一个公共因子 相对重要性的一个尺度。他对于选择公因子的数量有很大的作用。
求解因子载荷矩阵方法有主成分分析法、主因子法、大似然估计法，下面介绍主成分分析法：
因为因子数&lt;变量数，所以m+1~p是没有任何意义的，即图中红色标记，分解中将红色部分作为特殊因子的方差忽略。在式（7.5）中因随机向量X的协方差矩阵在X标准化以后就是相关矩阵，有如下式子
上述绿色部分的p*m矩阵就是因子载荷矩阵A。
因子旋转用于给各个公因子取一个描述性名字，像之前提到的使用商店的环境、商店 的服务和商品的价格作为描述商品的因子。因为我们得到的载荷矩阵中的因子的系数载荷在各个变量上的值很难看出差异，也就很难看出因子对于哪些变量很重要，也就难以得出因子的含义。而因子旋转使同一列上的载荷尽可能地向靠近 1和靠近0两极分离。这时就突出了每个公共因子和其载荷较 大的那些变量的联系，矛盾的主要方面显现出来了，该公共 因子的含义也就能通过这些载荷较大变量做出合理的说明， 这样也显示了该公共因子的主要性质。 它的原理这里就不给出了，matlab中仅需一行代码就可以得到因子旋转的结果。
matlab命令：rotatefactors(A, 'method', 'varimax')
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3de3790d9af1ba3364ae6f6214829799/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d57b1c8f5cdb325790d326a1b95fc1d2/" rel="bookmark">
			char和uchar区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 char和uchar区别 char 是有符号的， uchar(unsigned char)是无符号的！
1、作为字符来表示的话，两者没有什么区别！
2、作为整数来表示的话，由于char是有符号的，于是数值范围为-128～127
而uchar是无符号的，于是数值范围为0～255,在图像处理中表示像素值范围时用的多！
posted on 2018-08-17 11:19 Magic_chao 阅读(...) 评论(...) 编辑 收藏 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/265ad2731efe26a9283b54698e3c631a/" rel="bookmark">
			学习ADO.NET技术（七） Command对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面几节主要学习了ADO.NET与外部数据源建立连接以及运用连接池提高连接性能的知识。连接对象（Connection）是ADO.NET的主力先锋，为用户与数据库交互搭建了扎实的桥梁。Connection对象为用户与数据库搭建好桥梁之后，它的任务就完成了。此时，Command对象就闪亮登场。Command对象在ADO.NET的世界里总是忙忙碌碌，像是一个外交官，为用户传达了所有操作数据库的信息。
目录 目录1、准备工作2、什么是Command对象？3、Command对象的几个属性4、Command对象的几个方法5、如何创建Command对象？6、选择合适的执行命令7、总结说明 1、准备工作 创建一个数据库，名为db_MyDemo.创建一个数据表，名为tb_SelCustomer。 2、什么是Command对象？ ADO.NET最主要的目的是对外部数据源提供一致的访问。而访问数据源，就少不了增删查改等操作。Connection对象连接好数据源之后，不会再对数据源进行任何操作。Command对象封装了所有对外部数据源的操作（包括增删查改等SQL语句与存储过程），并在执行完成后返回合适的结果。与Connection对象一样，对于不同数据源，ADO.NET提供了不同的Command对象。具体可见以下表格：
.Net数据提供程序对应Commad对象用于OLE DB的.Net Framework数据提供程序OleDbCommand对象用于SQL Server的.Net Framework数据提供程序SqlCommand对象用于ODBC的.Net Framework数据提供程序OdbcCommand对象用于Oracle的.Net Framework数据提供程序OracleCommand对象 不管是哪种Command对象，它都继承于DBCommand类。它同样是抽象基类，不能实例化。DBCommand类定义了完善的健全的数据库操作的基本方法和属性。它的结构如下：
public abstract class DbCommand:Component,IdbCommand,IDisposable 3、Command对象的几个属性 CommandText：获取或设置对数据源执行操作的文本命令CommandType：命令类型，指定如何解释CommandText属性。CommandType属性的值是一个枚举类型，定义结构如下： public enum CommandType { Text = 1;//SQL文本命令 StoredProcedure = 4;//存储过程的名称 TableDirect = 512;//表的名称 } 将CommandType设置为StoredProsedure时，应将CommandText属性设置为存储过程的名称。调用Execute方法之一时，该命令将执行此存储过程。Connection：设置或获取与数据源的连接。Parameters：绑定SQL语句或存储过程的参数。参数化查询中不可或缺的对象，非常重要。Tranction：获取或设置在其中执行.NetFramework数据提供程序的Command对象的事务。 4、Command对象的几个方法 ExecuteNonQuery:执行不返回数据行的操作，并返回一个Int类型的数据。 注意：对于 UPDATE、INSERT 和 DELETE 语句，返回值为该命令所影响的行数。 对于其他所有类型的语句，返回值 为 -1。
ExecuteReader：执行查询，并返回一个DataReader对象。ExecuteScalar：执行查询，并返回查询结果集中第一行的第一列。如果找不到第一行第一列，则返回null的引用。 5、如何创建Command对象？ 在创建Command对象之前，需要明确两件事情：（1）需要对哪个数据源执行操作（2）执行什么样的操作。 对哪个数据源执行操作：由连接对象来确定。执行什么样的操作，由SQL语句来决定。那么如何通过这两个信息来构造Command对象呢？一般来说，有两种方法： （1）通过构造函数。
string strSQL = "select * from tb_SelCustomer"; string conn = "Data Source = LENOVO - PC\\MR2014; " + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/265ad2731efe26a9283b54698e3c631a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94f8057104087469bd936ca833e0678b/" rel="bookmark">
			安装OSX和Windows双系统以后系统时间不同步的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因分析 可能你们都遇到过这样的问题，就是安装完OSX系统以后，发现系统时间和Windows的系统时间就不对了，总是相差了几个小时（刚好8个小时），这个问题的原因呢其实是因为他们看待系统硬件时间的方式不一样引起的，Windows把系统硬件时间当做本地时间，也就是操作系统显示的时间是跟Bios或者Efi中显示的时间是一样的，而MAC则是把硬件时间当做UTC，操作系统中现实的时间是硬件时间经过换算得到的时间，假如说北京时间是GMT+8小时刚好是硬件时间+8小时。
那么这里的UTC其实就是协调世界时（Universal Time Coordinated）GMT就是我们经常说的格林尼治时间
说了那么多究竟是什么意思呢？举个例子：
如果说你的MAC和WIN中的时间都是北京时间，而你把MAC中的时间改为10：00AM，也就是上午十点，那么其实硬件中真正存储的时间是2：00AM，这是你的电脑中的时间也就是BIOS的时间就是2：00AM，所以你的WIN启动的时候显示的时间就是BIOS的时间，也就是2：00AM，这也就是为什么每次重启以后两个系统的时间都是错8小时的原因。
那么我们知道原因了，怎么解决呢？
我们把Windows硬件时间当做UTC理论上就解决了！
问题解决 怎么操作呢？
win7：桌面右键新建一个快捷方式，输入cmd，回车，然后管理员身份运行
win8/win10：win+X，找到shell的管理员运行
在打开的DOS窗口中输入：
Reg add HKLM/SYSTEM/CurrentControlSet/Control/TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1 然后确定就可以了。
当然这里如果您的MAC时区设置的不对的话也是不行的，也就是说只有当两边都是同一时区的时候才是可以的，怎么看自己的时区呢？很简单：
确定是同一时区以后就可以了！
喜欢的可以关注我，谢谢阅读！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/112/">«</a>
	<span class="pagination__item pagination__item--current">113/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/114/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>