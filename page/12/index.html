<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0804ce01605dc1bc2ae30a26e8881ca8/" rel="bookmark">
			使用WxPython处理弹出菜单和绑定回调
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前段时间大厂找我做软件开发，那时候我们在做开发得过程中，尤其在创建用户界面时，使用 WxPython 处理弹出菜单并绑定回调函数有很多好处，不仅可以增强用户交互性、提高用户体验、简化界面设计等等，看看下面得问题。
1、问题背景
使用WxPython创建用户界面时，我们可能需要在应用程序中使用弹出菜单。在弹出菜单中，用户可以通过点击选项来触发相应的回调函数，执行特定的操作。然而，在使用WxPython处理弹出菜单时，可能会遇到这样的问题：用户点击弹出菜单选项后，回调函数没有被触发，或者没有正确执行操作。
为了解决这个问题，我们可以采用以下解决方案：
2、解决方案
在WxPython中，可以使用 Bind() 方法来绑定回调函数到弹出菜单选项。当用户点击弹出菜单选项时，绑定的回调函数就会被触发。在使用 Bind() 方法时，我们需要指定以下几个参数：
event: 要绑定的事件类型，例如 wx.EVT_MENU。handler: 要绑定的回调函数。source: 要绑定回调函数的控件，例如弹出菜单选项。 此外，还需要注意以下几点：
在使用 Bind() 方法时，需要确保回调函数的签名与事件类型一致。例如，如果要绑定一个 wx.EVT_MENU 事件，那么回调函数必须接受一个 wx.MenuEvent 参数。在使用 Bind() 方法时，可以使用 wx.NewId() 方法来生成一个唯一的 ID。ID 用于标识控件，并且在绑定事件时需要使用。 下面是一个使用WxPython处理弹出菜单并绑定回调函数的代码示例：
import wx class MyApp(wx.App): def OnInit(self): frame = TestFrame(None, -1, "Hello from wxPython") frame.Show(True) self.SetTopWindow(frame) return True class TestFrame(wx.Frame): def __init__(self, *args, **kw): wx.Frame.__init__(self, *args, **kw) sizer = wx.BoxSizer() button = wx.Button(self, label='Click me') sizer.Add(button) self.SetSizerAndFit(sizer) mainmenu = wx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0804ce01605dc1bc2ae30a26e8881ca8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3869018d9dab4d75e79634210130db27/" rel="bookmark">
			tomcat通过JAVA_OPTS注入自定义变量 —— 筑梦之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景说明
tomcat部署的java应用在k8s集群或容器中，想要给tomcat传自定义变量，应该如何实现？
解决方法
1. 在k8s集群或容器环境中通过env或者configmap方式添加自定义的环境变量
比如：
my_key: aaaa
2. tomcat下新增脚本：setenv.sh，示例如下：
JAVA_OPTS="$JAVA_OPTS -Dkey=value" key ： 自定义key value ：自定义value 多个环境变量使用多个-D参数进行添加 eg： JAVA_OPTS="$JAVA_OPTS -Done-key=${my_key}" 3. tomcat配置引用变量
在配置文件server.conf context.xml等文件中引用自定义环境变量one-key，比如
key="${one-key}"
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01ed431afb851b170f90bab4e0816136/" rel="bookmark">
			开源软件的影响力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着信息技术的快速发展，开源软件已成为软件开发的趋势，并产生了深远的影响。其低成本、可协作性和透明度等特点促进了软件行业的繁荣。然而，在使用开源软件时，需关注可能带来的问题，如安全风险和维护困难。如何更好地利用开源软件优势，推动技术创新和应用，成为当前热门话题。
方向一：开源软件如何推动技术创新
通过开放源代码，开源软件促进全球开发者协作与交流，推动软件技术创新和发展。共享代码库提供了学习资源和灵感源泉，激发了创新思维，加速了技术演进的步伐。
方向二：开源软件的商业模式
探讨开源软件的商业模式，以及如何结合商业软件，实现商业价值。开源软件通常采用服务、支持和定制化等方式获取收入，同时提供免费核心产品，从中获益。
方向三：开源软件的安全风险
分析开源软件的安全风险，强调加强安全措施保障系统安全性的重要性。开源软件的开放性也带来潜在的漏洞，需要定期更新和监测，确保系统不易受到攻击。
方向四：开源软件的未来发展趋势
预测开源软件未来发展趋势，探讨如何因应新挑战和机遇。趋势包括更多行业的采用、自动化集成和增强安全性，以满足日益复杂的需求。
方向五：开源软件在各行业的应用案例
分享开源软件在各行业的应用案例，展示其优势和价值。案例涵盖人工智能、医疗保健、金融服务等领域，突出开源软件在不同行业中的创新应用与效果。
以上方向可作为深入探讨开源软件影响力的起点，有助于更全面理解开源软件对技术和商业的影响。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f258a630ff29f8eb2d663767b233021c/" rel="bookmark">
			PyQt应用程序中的多线程：使用Qt还是Python线程?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多线程模块能够更加高效得完成任务，但是在PyQt 应用程序中实现多线程可以使用 Qt 的线程模块（QThread）或者 Python 的 threading 模块。两者各有优劣，具体选择取决于项目需求和个人偏好。下面我们将以案例来说明两种模块具体得优缺点。
1、问题背景
在 PyQt 应用程序中，编写了一个定期通过 web 连接检索数据的 GUI 应用程序。由于检索过程需要一段时间，因此导致在检索过程中 UI 无响应（无法将其拆分为更小的部分）。因此，需要将 web 连接外包给单独的工作线程。
2、解决方案
Qt 线程： 优势： 与 Qt 库的其余部分更好地集成。例如，Qt 中具有线程感知的方法需要知道它们在哪个线程中运行，并且要在线程之间移动对象，则需要使用 QThread。另一个有用的功能是在线程中运行自己的事件循环。 劣势： 可能无法从 Python 线程访问 Qt。例如，无法通过 QApplication.postEvent 将事件发布到主线程。 Python 线程： 优势： 更简单、更安全。由于这是一个基于 I/O 的应用程序，因此它们能够绕过 GIL。Python 线程是系统线程。但是，Python 使用全局解释器锁 (GIL) 来确保一次只执行一定大小的字节码指令块。幸运的是，Python 在输入/输出操作期间会释放 GIL，从而使线程对于模拟非阻塞 I/O 很有用。 劣势： 由于 Python 的内置锁 GIL（全局解释器锁），Python 线程不能真正并发执行 Python 代码，包括了调用 Python API 和解释 Python 字节码。多线程编程使应用程序复杂度大增，尤其是在处理 Python 解释器和编译模块代码之间的本来就复杂的交互时。 非阻塞 I/O： 通过异步 I/O，可以始终确保每个打开的文件描述符的执行路径一致且有序。例如： QNetworkAccessManager：如果应用程序正在访问 HTTP 服务器，则应该考虑 QNetworkAccessManager。Twisted 或非阻塞套接字/select：可以考虑使用 Twisted 或非阻塞套接字/select 实现非阻塞 I/O。Diesel 库：它目前仅限于 Linux，但它的速度非常快且非常优雅。pyevent：它是 libevent 库的包装器，它提供了一个基本框架，用于使用系统最快的可用方法（在编译时确定）进行基于事件的编程。 在 PyQt 应用程序中使用线程时，需要考虑以下几点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f258a630ff29f8eb2d663767b233021c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/375c68d87819b2551efb5304782145c1/" rel="bookmark">
			常用开发命令汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1、基本概念1.1.给自己remote/origin提交PR1.2.给upstream提交PR 2、Vim常用命令3、linux命令 前言 记录平时常用的一些开发命令。
1、基本概念 在提交PR过程中，上游仓库叫upstream; fork到自己github叫origin；自己在本地克隆叫local。
1.1.给自己remote/origin提交PR # 首先pull git pull origin master # 若pull过程发生冲突，会发生merging 错误 git reset --hard head # 可清空暂存区 git rm --cached Look_Hear.md # clone git branch # 查看最新的分支 git pull origin main # 拉取origin仓库main分支为最新 # ------ # git checkout -b dev vim xxx.py git add . git commit -m 'xxx' git push origin dev # 将Dev分支推送至origin，会多一个分支 # -----在github界面点击PR下的squash进行分支合并 # # --- 删除dev分支 --- git checkout main # 切换回main分支 git branch -d dev # 删除local的分支 git push origin --delete dev # 删除远程仓库的分支 # 查看分支: git branch -a # 将本地项目提交给上游仓库新的分支 step1: 配置ssh-key: https://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/375c68d87819b2551efb5304782145c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8f904bb7c57bee4365d0c5cf3bce7dd/" rel="bookmark">
			用html编写的招聘简历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用html编写的招聘简历 相关代码 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table&gt; &lt;thead&gt;&lt;h3&gt;请填写简历信息&lt;/h3&gt;&lt;/thead&gt; &lt;tr&gt; &lt;td&gt; &lt;label for="name"&gt;姓名&lt;/label&gt; &lt;/td&gt; &lt;td&gt;&lt;input type="text" name="" id="name"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 性别 &lt;/td&gt; &lt;td&gt; &lt;input type="radio" name="sex" id="male" checked="checked"&gt; &lt;label for="male"&gt; &lt;img src="https://gitee.com/fly0213/drawing-bed/raw/master/nan.png" alt="" width="20" height="20"&gt;男 &lt;/label&gt; &lt;input type="radio" name="sex" id="female"&gt; &lt;label for="female"&gt; &lt;img src="https://gitee.com/fly0213/drawing-bed/raw/master/nv.png" alt="" width="20" height="20"&gt;女 &lt;/label&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;出生日期&lt;/td&gt; &lt;td&gt; &lt;select name="" id=""&gt; &lt;option value=""&gt;--请选择年份--&lt;/option&gt; &lt;option value="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8f904bb7c57bee4365d0c5cf3bce7dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29e10739af6b5295f06d31189d7f3c44/" rel="bookmark">
			【C语言必刷题】4. 打印100~200之间的素数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📚博客主页：爱敲代码的小杨.
✨专栏：《Java SE语法》 | 《数据结构与算法》 | 《C生万物》
❤️感谢大家点赞👍🏻收藏⭐评论✍🏻，您的三连就是我持续更新的动力❤️
🙏小杨水平有限，欢迎各位大佬指点，相互学习进步！
文章目录 🔥 题目描述🔥 解题思路🔥代码 🔥 题目描述 使用C语言写一个程序打印100~200之间的的素数，数字中间使用空格分割。
🔥 解题思路 素数是指只能被1和它本身整除的正整数。我们可以遍历100~200，并找出那些数字是素数。
试除法：从 2 到 x-1 ，逐个尝试是否能整除 x，如果能，x就不是素数，否则 x 是素数
优化代码：当 x 为偶数时，x 一定不是素数，因此在遍历时我们可以跳过每个偶数
试除法时间优化：
当 2 到 x-1 中存在某个数 t 可以整除 x 时，令 d = x/t，则 d 也可以整除 x，并且结果为 t。因
此，当 2~ x \sqrt[]x x ​中不存在可以整除x的数时， x + 1 \sqrt[]x+1 x ​+1​~ x 也不存在可以整除 x 的数。
利用反证法证明：
假设 2 到 x-1 中不存在可以整除 x 的数， x + 1 \sqrt[]x+1 x ​+1~x 中存在⼀个数 d 可以整除 x；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29e10739af6b5295f06d31189d7f3c44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1e05a00f2afa17a059f1dcd3a864bee/" rel="bookmark">
			c语言笔记typedef与输出输入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一typedef 1.1概述 ：C 语言提供了 typedef 关键字，可以使用它来为类型取一个新的名字
示例：我们可以看到这里 我们将unsigned char 新起一个名字为 BYTE 后面我们定义此类型的变量的时候就可以使用BYTE
typedef unsigned char BYTE; BYTE b1, b2; 那在起了新名字之后 unsigned char 是否可以使用呢？
#include &lt;stdio.h&gt; int main() { typedef unsigned char BYTE; unsigned char a='a'; BYTE b='b'; printf("%c\n",a); printf("%c\n",b); } 我们可以看到是可以使用的 我们在使用typedef的时候并不会影响到原来的类型使用 只是起了新名方便我们使用。
当然也可以使用 typedef 来为用户自定义的数据类型取一个新的名字。例如，您可以对结构体使用 typedef 来定义一个新的数据类型名字，然后使用这个新的数据类型来直接定义结构变量 示例：这里提醒大家一下 strcpy的函数头文件在string.h
#include &lt;stdio.h&gt; #include &lt;string.h&gt; typedef struct BOOK { char name[50]; }Book; int main() { Book book; strcpy(book.name,"pxd"); printf("name:%s\n",book.name); return 0; } 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1e05a00f2afa17a059f1dcd3a864bee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef0c4fcd824eb679b760d8ea32d5f124/" rel="bookmark">
			Scrum管理工具-敏捷研发端到端管理流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Leangoo领歌是款永久免费的专业的敏捷开发管理工具，提供端到端敏捷研发管理解决方案，涵盖敏捷需求管理、任务协同、进展跟踪、统计度量等。
Leangoo领歌上手快、实施成本低，可帮助企业快速落地敏捷，提质增效、缩短周期、加速创新。
Leangoo领歌区别于传统项目管理软件，项目的需求、任务、问题、缺陷都作为卡片放在看板上，通过看板实现可视化和透明化的管理，通过看板上卡片的实时同步实现实时协作。
项目进展、状态多视角实时更新，可视化展示。
Leangoo可以支持敏捷研发管理全流程，包括小型团队敏捷开发，规模化敏捷SAFe，Scrum of Scrums大规模敏捷等敏捷开发方法，具有产品管理和项目管理的功能。可以私有部署，私有部署收费。在线版本全部免费，没有任何限制。
这是一个Scrum敏捷单团队敏捷开发示例：
1、建立产品路线图 首先我们需要为这个项目创建一个产品路线图，产品路线图是一个高层次的战略计划，它描述了产品在未来一段时间可能会如何发展和壮大，产品路线图确保整个产品团队持续关注产品的目标，帮助产品负责人把握产品的战略方向，调整产品的优先级和产品规划。
在产品路线图里有多个里程碑，里程碑是产品路线图上达成产品愿景的一个个阶段性目标。敏捷的里程碑通常是按照节奏进行规划的，比如每两个月一个里程碑，或者每个季度一个里程碑。
「我们利用Leangoo领歌敏捷开发工具进行管理敏捷项目，如果要做敏捷，完全可以利用Leangoo领歌。」
下图是产品路线图敏捷看板示例：
​
创建好产品路线图之后，产品路线图上的史诗故事通常都是比较大的故事，所以我们需要将史诗故事规划到产品Backlog中，以便让团队在产品Backlog中对史诗故事进行拆分，将其拆解为更小的用户故事，从而让团队在后续的Sprint迭代中去逐步完成。
2、产品路线图规划 在Leangoo领歌中，直接可以使用“里程碑规划”按钮，打开里程碑规划弹框，将“里程碑”列表内的史诗故事拖拽至对应的“里程碑-产品Backlog”内，这样这些史诗故事便会被引用到产品Backlog看板内，即完成里程碑规划。 ​
3、在产品Backlog中进行用户故事拆分 团队在产品Backlog看板中，将规划过来的这些史诗故事进行拆分，拆解成更小的用户故事，然后准备进行后续Sprint规划。
一个史诗故事一个泳道，用泳道横向对应用户故事拆分的任务。
​
4、用户故事梳理 用户故事拆解完成后，团队可以对优先级较高的用户故事进行梳理。可以将完成用户故事需要的任务项添加到卡片内的检查项中，以便后续用户故事规划到Sprint中后，方便拆解成更小的任务卡片。
通过列表流转，让团队直观的了解需求的优先级和规划安排
​ 5、迭代规划 用户故事梳理完成后，迭代开始前，我们需要将已经梳理完成且优先级高的用户故事规划到迭代看板中，迭代开始前，团队需要对要做的用户故事进行估算和添加工作量等。。
在看板中点击“Sprint规划”按钮，将梳理好的用户故事拖拽到迭代看板中。
​
6、缺陷管理 当前迭代的缺陷，建议放到当前迭代的迭代看板上，在迭代结束前修复完成。
“缺陷看板”通常放发布后遗留的缺陷、客户反馈的缺陷等。
在迭代过程中，不仅需要做相关的用户故事，也要解决出现的缺陷问题，所以在迭代规划时，我们也需要将缺陷规划到Sprint中。
​ 7、迭代执行 在迭代规划完成后，进入迭代看板，可以看到已规划的用户故事分别放置在独立泳道中，泳道可横向对应用户故事和拆分的任务。
Sprint开始后，团队根据这些用户故事相关信息（比如检查项、描述内的信息），将其拆解为更小的任务，然后大家各自领取开发。
通过列表流转，体现任务的进展及完成情况。
​
8、Sprint回顾 在敏捷开发中，我们每个迭代团队都会开回顾会议，这时团队可以将回顾的事项放到 Sprint回顾 看板内，然后在后续的Sprint迭代中保持高效协作的同时、逐步解决需要改进的问题。 ​
查看迭代进度 每个迭代类型看板中都有一个重要的Sprint进度统计 – 燃尽图。
燃尽图是Scrum中的一个简单实用的团队进展跟踪的工具，能形象地展示当前迭代中的剩余工作量和剩余工作时间的变化趋势，一般在每日站会时团队会通过燃尽图来了解当前Sprint冲刺速度情况。
​
迭代完成率 迭代完成率是统计项目内每个迭代看板的完成情况。
配置好看板周期和燃尽图，Leangoo会自动统计每个迭代看板的完成情况，并且自动生成可视化统计图表，以便管理层可以一目了然的看到每个迭代完成进度。
​
迭代缺陷统计 迭代缺陷是统计项目内每个迭代看板的缺陷分布以及完成情况。
配置好看板周期和燃尽图以及卡片类型，Leangoo会自动统计每个迭代看板的缺陷完成情况，并且自动生成可视化统计图表，以便管理层可以一目了然的看到每个迭代中缺陷的分布及完成进度。
查看团队速率 团队速率是Scrum团队在一个Sprint中实际完成的工作量（通常使用故事点作为团队速度的单位）。
每个Sprint结束后，Leangoo会自动记录当前Sprint完成的工作量，并且自动生成团队速率的可视化统计图表，以便团队可以了解团队效率变化的趋势并进行分析。 ​
查看任务分布 Scrum 团队是一个自组织的团队，团队每天的目标和工作安排由团队讨论决定。
通过任务分布统计帮助团队快速直观的了解团队成员每个人负责的工作负荷及工作进展状态，帮助团队进行更高效的协作。
​
查看缺陷分布 缺陷分布统计可以通过不同维度(工作量、卡片数)展现项目中缺陷看板内每个列表下的任务分布情况 ​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef0c4fcd824eb679b760d8ea32d5f124/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d898bb9cd6b7b9be5099d46611e2c8ba/" rel="bookmark">
			.net 微服务 服务保护 自动重试 Polly
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 概要 实验服务保护，自动重新连接功能。
2.代码 2.1 重复工具 using Polly; using Polly.Retry; using System; using System.Collections.Generic; using System.Linq; using System.Net.Http; using System.Threading.Tasks; namespace WebApplication2 { public class ClientPolicy { public AsyncRetryPolicy&lt;HttpResponseMessage&gt; asyncRetryPolicy { get; set; } public ClientPolicy() { asyncRetryPolicy = Policy.HandleResult&lt;HttpResponseMessage&gt;(p=&gt;!p.IsSuccessStatusCode).WaitAndRetryAsync(5,retryAttemp=&gt;TimeSpan.FromSeconds(Math.Pow(2,retryAttemp))); } } } 2.2 调用位置
using Microsoft.AspNetCore.Mvc; using Microsoft.Extensions.Logging; using System; using System.Collections.Generic; using System.Linq; using System.Net.Http; using System.Threading.Tasks; namespace WebApplication2.Controllers { [ApiController] [Route("[controller]")] public class WeatherForecastController : ControllerBase { private static readonly string[] Summaries = new[] { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d898bb9cd6b7b9be5099d46611e2c8ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdc391c8ed1681109eac03b7b57e7f4f/" rel="bookmark">
			ADO世界之THIRD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、ADO 删除记录
二、ADO 加速脚本
1.多行 Response.Write
2.GetString() 方法
一、ADO 删除记录 使用 SQL 的 DELETE 命令来删除数据库表中的某条记录。
删除 Northwind 数据库的 Customers 表中的一条记录。
创建一个表格，来列出 Customers 中的所有记录。
&lt;html&gt;
&lt;body&gt;
&lt;%
set conn=Server.CreateObject("ADODB.Connection")
conn.Provider="Microsoft.Jet.OLEDB.4.0"
conn.Open "c:/webdata/northwind.mdb"
set rs=Server.CreateObject("ADODB.Recordset")
rs.open "SELECT * FROM customers",conn
%&gt;
&lt;h2&gt;List Database&lt;/h2&gt;
&lt;table border="1" width="100%"&gt;
&lt;tr&gt;
&lt;%
for each x in rs.Fields
response.write("&lt;th&gt;" &amp; ucase(x.name) &amp; "&lt;/th&gt;")
next
%&gt;
&lt;/tr&gt;
&lt;% do until rs.EOF %&gt;
&lt;tr&gt;
&lt;form method="post" action="demo_delete.asp"&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdc391c8ed1681109eac03b7b57e7f4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/871f01b320582b70b19983a98194d9a7/" rel="bookmark">
			基于java的眼镜店仓库管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码获取，加V：qq2056908377
摘要：
随着电子商务的兴起，越来越多的商家选择在线销售他们的产品。眼镜店作为零售业的一种，也不例外。随着市场需求的不断增加，眼镜店需要更加高效的管理他们的仓库和库存，以满足客户的需求。为了解决这个问题，本论文旨在设计和实现一个基于Java语言的眼镜店仓库管理系统，帮助眼镜店更加高效地管理他们的仓库和库存。本系统实现一系列功能，包括眼镜入库、出库、退货、盘点、订单管理、库存查询等。
本系统将采用Java语言作为主要的开发语言，结合MySQL数据库，实现数据的持久化。系统将采用MVC设计模式，具有良好的可扩展性和可维护性。我们将采用软件开发过程中常用的迭代式开发模型，从需求分析、概要设计、详细设计、编码实现等方面，不断优化和改进系统。通过本论文的研究，我们相信能够设计出一个实用性强、性能稳定、易于维护的眼镜店仓库管理系统。
系统经过功能测试和性能评估，确认其具有一定实用性和功能健壮性。通过本论文的研究，我们期望为眼镜店仓库管理系统的设计和实现提供参考和帮助，为企业提高管理效率和经济效益做出贡献。
关键词：仓库管理,眼镜店,SpringBoot；
目录
摘要 Abstract: 1、绪论 1.1、背景分析 1.2、设计的目的与意义 1.3、设计的主要内容 1.4、总体结构 2、系统分析 2.1、需求分析 2.2、系统用例分析 2.2.1、店员用例分析 2.2.2、店长用例分析 2.3、可行性分析 3、系统设计 3.1、系统架构设计 3.2、系统功能设计 3.2.1、总体功能设计 3.2.2、客户管理与供应商管理 3.2.3、度数分类管理 3.2.3、眼镜管理模块 3.2.5、仓库管理模块 3.2.6、出库管理模块 3.2.7、入库管理模块 3.2.8、用户管理模块 3.2.9、管理端日志管理模块 3.3、数据库设计 3.3.1数据库概念设计 3.3.2数据库表设计 3.4、本章小节 4、系统实现 4.1、开发技术选型 4.9、密码管理实现 4.2、度数分类管理实现 4.3、眼镜管理实现 4.4、仓库管理实现 4.5、入库管理实现 4.6、入库退货实现 4.7、出库管理实现 4.8、出库退货实现 4.10、本章小节 5、 系统测试 5.1、测试方法 5.2、测试范围 5.3、功能流程测试 5.4本章小节 参考文献 致 谢 1、绪论 1.1、背景分析 眼镜行业是近年来发展非常迅速的一个领域，而随着市场需求的增加和业务规模的扩大，眼镜店的仓库管理也变得愈加重要。眼镜店是一种以售卖眼镜为主要业务的零售店，与其他行业相比，其商品种类较少，但颜色、型号、规格等方面的变化较多。此外，眼镜店的客户群体多为老年人和中年人，具有较高的客户忠诚度和反复购买率。因此，眼镜店仓库管理需要保证货品的稳定性和准确性，同时也需要注重客户服务和售后支持。
市场上已经有许多仓库管理系统可供选择，但它们的功能和适用性并不完全符合眼镜店的特殊需求。眼镜店仓库管理需要针对性地设计和开发，满足眼镜店特有的业务需求和管理模式。本论文旨在探究一种基于Java的眼镜店仓库管理系统的设计与实现方案，以提高眼镜店的运营效率和管理水平。
1.2、设计的目的与意义 目的在于通过基于Java技术的仓库管理系统，为眼镜店提供一个科学、规范、高效的仓库管理方案，实现对仓库管理流程的规范化和自动化，提高运营效率和服务质量，减少管理成本和人力投入，提高眼镜店的核心竞争力。
意义在于通过本研究的设计和实现，可以提高眼镜店的运营效率和客户服务水平。通过实现仓库管理系统的自动化和智能化，可以大大减少人工操作，提高工作效率，降低成本开支。此外，系统中的客户管理和供应商管理功能，可以提高客户服务质量和供应商合作效率，为眼镜店带来更多的商业价值
综上所述，本研究的设计和实现可以为眼镜店的管理和运营带来实质性的改善和提升，同时也对相关领域的研究和应用具有积极的推动作用。
1.3、设计的主要内容 本论文的主要内容是基于Java技术，设计并实现一套适用于眼镜店的仓库管理系统，包括客户管理、供应商管理、库位管理、库存管理、出库管理、入库管理、出库退货管理、入库退货管理等功能。
通过该系统，用户可以轻松地完成对供应商、客户和眼镜的管理和维护，根据实际情况对库存进行合理分类和管理，并实时掌握库存的情况。同时，用户还可以方便地进行出入库操作和退单处理，有效地解决了库存管理中的各种问题和难题。
该系统还具备完善的用户权限和角色管理功能，可以实现对不同用户的访问和操作权限进行控制和管理，确保系统的安全性和稳定性。
1.4、总体结构 本论文的总体结构是严格按照开发和设计规范来排版的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/871f01b320582b70b19983a98194d9a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/089d6b105575ddb9f70a51ae22f4101d/" rel="bookmark">
			redis相关面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Redis？它的特点是什么？
基于内存的非关系型数据库；
它具有以下特点：
高性能：Redis是基于内存的数据库，读写速度非常快，适合处理高并发的应用场景。
支持持久化：Redis支持两种持久化方式，分别是RDB和AOF，可以保证数据不丢失。
多种数据结构：Redis支持多种数据结构，可以满足不同的业务需求。
支持事务：Redis支持事务操作，可以保证一组命令的原子性。
支持主从复制：Redis支持主从复制，可以实现数据的备份和读写分离。
支持集群模式：Redis可以通过集群模式实现数据的分片和负载均衡。
支持发布订阅：Redis支持发布订阅功能，可以实现消息的广播和订阅。
总的来说，Redis具有高性能、灵活的数据结构、持久化、事务处理、主从复制、集群模式等特点，适用于各种场景下的数据存储和处理需求。
Redis支持哪些数据结构？
字符串（String）： 存储一个字符串值。
哈希表（Hash）： 存储字段和字段值的映射。
列表（List）： 存储有序的字符串列表。
集合（Set）： 存储唯一的字符串集合。
有序集合（Sorted Set）： 与集合类似，但每个元素都关联一个分数，可以按分数排序。
位图（Bitmap）： 存储位操作相关的数据。
HyperLogLog： 用于估计一个集合中的不重复元素的数量。
地理空间索引（Geospatial Index）： 用于存储地理位置信息和计算位置之间的距离。
Redis的持久化机制有哪些？它们有什么区别？
RDB持久化机制： RDB持久化机制是通过定期将内存中的数据快照保存到磁盘上的文件中来实现的。在指定的时间间隔内，Redis会将数据快照写入到一个临时文件中，然后再将这个临时文件替换原来的RDB文件。RDB持久化机制适合用于备份数据和实现快速恢复。
优点：
RDB文件较小，适合用于备份和恢复。
在恢复大数据集时比AOF快。
缺点：
如果Redis意外宕机，可能会丢失最后一次快照之后的数据。
数据在磁盘上的保存频率较低，可能会导致数据丢失。
AOF持久化机制： AOF持久化机制是通过将每个写操作追加到文件末尾来实现的。在AOF文件中记录了每个写操作的命令，当Redis重启时，可以通过重新执行AOF文件中的命令来恢复数据。
优点：
可以保证数据不丢失，因为每个写操作都会被记录到AOF文件中。
AOF文件是一个追加写入的文件，可以避免文件损坏的问题。
缺点：
AOF文件通常比RDB文件大，恢复数据速度可能会比较慢。
AOF文件可能会因为频繁写入而导致性能下降。
区别：
RDB持久化机制是定期将内存中的数据快照保存到磁盘，而AOF持久化机制是将每个写操作追加到文件末尾。
RDB适合用于备份和快速恢复数据，AOF适合用于保证数据不丢失。
AOF文件通常比RDB文件大，但可以保证数据的完整性。
Redis的主从复制是如何实现的？
Slave连接到Master： Slave服务器向Master服务器发送SYNC命令请求复制数据。Master接受请求后开始将自己的数据发送给Slave。
快照同步：Master会在内存中创建一个快照，并将快照发送给Slave。Slave接收到快照后会将其加载到自己的内存中。
增量复制：Master会将接收到的写命令发送给Slave，Slave会按照相同的顺序执行这些写命令，从而保持数据的一致性。
断线重连：如果Slave与Master之间的连接断开，Slave会尝试重新连接Master，并请求增量复制数据，以保持数据的同步。
通过主从复制，可以实现数据的备份、读写分离和负载均衡。在主从复制中，Master负责处理写请求和同步数据，而Slave负责处理读请求，提高了系统的性能和可用性。
Redis的集群模式是怎样工作的？
Redis集群模式是用于在多个Redis节点之间分片和复制数据，以实现高可用性和横向扩展。Redis集群模式采用了分布式哈希槽（hash slot）的方式来将数据分散存储在多个节点上，同时通过复制和故障转移来保证数据的可靠性和可用性。
以下是Redis集群模式的主要工作原理：
哈希槽分片：Redis集群将整个数据集分成16384个哈希槽（0-16383），每个槽对应一个数据片段。当一个键被存储时，Redis会根据键的哈希值将其映射到一个具体的哈希槽中。
节点分布：集群中的每个Redis节点负责一部分哈希槽的数据。当一个节点加入或离开集群时，集群会自动进行数据的重新分配，确保每个节点负责的哈希槽数量尽量均衡。
节点间通信：集群中的节点通过互相通信来协调数据的分片和复制。节点之间会维护一个集群状态，用于记录每个哈希槽的分配情况和节点的状态。
数据复制：每个哈希槽在集群中会有一个主节点负责处理读写请求，同时还会有若干个从节点负责数据的复制。当主节点发生故障时，集群会从从节点中选举一个新的主节点来接管故障节点的哈希槽。
客户端路由：客户端在向集群发送读写请求时，会根据键的哈希值计算出对应的哈希槽，并通过集群状态信息找到负责该槽的节点。如果请求的键所在的槽在客户端连接的节点上，则直接处理请求；否则，客户端会被重定向到正确的节点。
故障转移：当一个节点发生故障或不可用时，集群会自动进行故障转移，从该节点的从节点中选举一个新的主节点来接管数据。这种自动化的故障转移机制确保了集群的高可用性。
Redis的数据淘汰策略有哪些？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/089d6b105575ddb9f70a51ae22f4101d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ab3dc0bd913a9e895b77b5b8353d16d/" rel="bookmark">
			RabbitMq相关面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Rabbitmq：
1.什么是RabbitMQ？它的作用是什么？
消息中间件实现各个应用程序之间的异步通信和解耦
作用：异步通信和解耦、缓冲和削峰填谷、可靠性（RabbitMQ支持消息持久化、消息确认机制)
2.RabbitMQ的基本架构是怎样的？
生产者将消息发送到Exchange(Direct Exchange、Fanout Exchange、Topic Exchange、Headers Exchange)，Exchange根据路由规则将消息发送到队列(队列可以持久化，确保消息在RabbitMQ重启后不会丢失。)中，消费者从队列中获取消息进行消费。
3.RabbitMQ中的重要概念有哪些？比如Exchange、Queue、Routing Key等。
Exchange（交换机）：Exchange是消息的路由中心，负责接收生产者发送的消息，并根据路由规则将消息路由到一个或多个队列中。Exchange有几种类型，包括Direct Exchange、Fanout Exchange、Topic Exchange、Headers Exchange等。
Queue（队列）：队列是消息的存储区，消息最终存储在队列中等待消费者消费。消费者从队列中获取消息并处理。队列可以持久化，确保消息在RabbitMQ重启后不会丢失。
Binding（绑定）：绑定是Exchange和Queue之间的关联关系，指定了消息从Exchange到达Queue的路由规则。Exchange通过Binding将消息路由到相应的Queue中。
Routing Key（路由键）：Routing Key是生产者在发送消息时附加的关键字，Exchange根据Routing Key将消息路由到相应的Queue中。
Producer（生产者）：生产者负责向RabbitMQ发送消息，将消息发送到Exchange中。
Consumer（消费者）：消费者从队列中获取消息，并进行相应的处理。消费者可以订阅一个或多个队列，从中获取消息并进行消费。
Connection（连接）：连接是生产者或消费者与RabbitMQ Broker之间的连接，通过连接可以进行消息的发送和接收。
Channel（通道）：通道是在连接上创建的虚拟连接，通过通道可以进行消息的发送、接收和确认，一个连接可以创建多个通道。
Message（消息）：消息是生产者发送的数据单元，包含消息体和一些元数据，如Routing Key、Exchange等。
4.RabbitMQ中的消息确认机制是什么？有哪几种确认模式？
生产者确认模式（Publisher Confirms）：在生产者发送消息到RabbitMQ后，可以通过确认机制来确保消息已经被正确地发送到Broker。生产者可以选择同步方式或异步方式来进行确认。同步方式是在发送消息后等待Broker的确认，异步方式是通过回调函数来处理确认结果。生产者确认模式可以保证消息的可靠发送。
消费者确认模式（Consumer Acknowledgements）：在消费者从队列中获取消息并处理后，可以通过确认机制来告知Broker消息已经被正确地处理。消费者可以选择手动确认模式或自动确认模式。手动确认模式需要消费者显式地发送确认消息给Broker，告知消息已经被处理；自动确认模式则由RabbitMQ自动确认消息。消费者确认模式可以保证消息的可靠消费。
5.RabbitMQ如何处理消息的持久化？
队列持久化：在声明队列时，可以设置队列的持久化属性，使得队列在RabbitMQ服务器重启后不会丢失。当队列被声明为持久化时，RabbitMQ会将队列的元数据（如队列的名称、绑定、属性等）保存到磁盘上，确保队列的持久性。
消息持久化：在生产者发送消息时，可以设置消息的持久化属性，使得消息在被发送到队列后不会丢失。当消息被声明为持久化时，RabbitMQ会将消息保存到磁盘上，以确保消息在RabbitMQ服务器重启后不会丢失。
消息确认机制：通过消息确认机制，可以确保消息在发送和消费过程中的可靠传递。生产者可以通过生产者确认模式来确认消息是否已经成功发送到Broker，消费者可以通过消费者确认模式来确认消息是否已经成功消费。这可以确保消息的可靠性。
6.RabbitMQ中的消息传递模式有哪些？分别是什么？
点对点模式（Point-to-Point）：在点对点模式下，消息发送者（生产者）将消息发送到一个特定的队列，只有一个消费者可以从该队列中接收并处理消息。这种模式适用于一对一的消息传递场景，确保消息被唯一的消费者接收。
发布/订阅模式（Publish/Subscribe）：在发布/订阅模式下，消息发送者（生产者）将消息发送到一个交换机（Exchange），交换机将消息路由到多个队列，每个队列对应一个消费者。消费者可以订阅一个或多个队列，从而接收并处理相应的消息。这种模式适用于一对多的消息传递场景，支持消息广播。
主题模式（Topic）：主题模式是发布/订阅模式的一种变体，消息发送者（生产者）将消息发送到一个主题交换机（Topic Exchange），交换机根据消息的Routing Key将消息路由到一个或多个队列，消费者可以根据通配符的Routing Key来订阅感兴趣的消息。主题模式支持更灵活的消息路由规则，可以根据消息的特定属性来进行消息路由。
工作队列模式（Work Queues）：工作队列模式也称为任务队列模式，多个消费者共享同一个队列，消费者从队列中获取消息并处理。这种模式适用于任务分发和负载均衡的场景，多个消费者可以并行处理消息，提高系统的吞吐量和处理能力。
7.RabbitMQ如何处理消息的路由？
Direct Exchange：直接交换机根据消息的Routing Key将消息直接路由到与之匹配的队列。生产者发送消息时需要指定一个Routing Key，Exchange会根据消息的Routing Key将消息路由到与之匹配的队列中。
Fanout Exchange：扇出交换机会将消息路由到所有与之绑定的队列中，无论消息的Routing Key是什么。Fanout Exchange适用于消息广播的场景，消息会被所有订阅了该Exchange的队列接收。
Topic Exchange：主题交换机根据消息的Routing Key和Exchange与队列的绑定规则将消息路由到一个或多个队列中。主题交换机支持通配符的Routing Key匹配，可以根据消息的特定属性来进行消息路由。
Headers Exchange：头交换机根据消息的Header属性来进行路由，而不是根据Routing Key。通过匹配消息的Header属性，头交换机可以将消息路由到与之匹配的队列中。
8.RabbitMQ如何处理消息的消费者负载均衡？
工作队列模式（Work Queues）：在工作队列模式中，多个消费者共享同一个队列，消费者可以并行地从队列中获取消息并处理。RabbitMQ会将消息均匀地分发给多个消费者，以实现消费者之间的负载均衡。消费者可以通过设置预取值（prefetch count）来控制每次从队列中获取的消息数量，以避免某个消费者处理过多的消息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ab3dc0bd913a9e895b77b5b8353d16d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/363e99ec0c2bc6d565bfb8d789c1dfd9/" rel="bookmark">
			主流开发语言和开发环境?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主流开发语言 Java
简介：Java 是一种广泛使用的面向对象的编程语言，由Sun Microsystems公司于1995年发布，后由Oracle公司接手。Java具有“一次编写，到处运行”的特性，它的跨平台能力得益于Java虚拟机（JVM）。Java被广泛应用于企业级应用开发、移动应用（特别是Android应用）、游戏开发、大数据处理（如Hadoop生态系统）、云计算服务端开发等场景。 C++
简介：C++ 是对C语言的扩展，增加了面向对象编程特性以及其他现代编程特性，如模板、异常处理、命名空间等。C++ 在系统软件、嵌入式开发、实时交易系统、游戏引擎、桌面应用程序等方面拥有强大的性能表现。 C#
简介：C#（发音为"C sharp"）是由Microsoft开发的一种面向对象的编程语言，主要用于.NET框架下的应用程序开发，兼容Windows、Linux和macOS等多个平台。C#语法简洁、类型安全且支持现代编程范式，常用于Windows桌面应用、游戏开发（Unity引擎）、服务器端开发（ASP.NET Core）、移动应用（Xamarin）等。 Python
简介：Python 是一种解释型、面向对象、动态数据类型的高级程序设计语言，以其简洁明了的语法、丰富的第三方库和活跃的社区著称。Python被广泛应用于数据分析、科学计算（SciPy、NumPy）、机器学习（TensorFlow、Scikit-Learn）、Web开发（Django、Flask）、自动化脚本编写等多个领域。 JavaScript
简介：JavaScript 是一门轻量级的解释型编程语言，主要应用于网页和网络应用客户端开发，也是唯一能在所有主流浏览器上运行的脚本语言。随着Node.js的出现，JavaScript也能用于服务器端编程。此外，JavaScript还有众多前端框架，如React、Vue.js、Angular等，用于构建复杂的Web应用程序。 开发环境 针对以上主流开发语言，以下是一些对应的开发环境：
Java 开发环境：IntelliJ IDEA、Eclipse、NetBeans等，均提供强大的Java开发支持，包括代码补全、调试、构建工具（Maven/Gradle）集成等。 C++ 开发环境：Visual Studio (VS)、Eclipse CDT、Clion、Code::Blocks、Qt Creator等，这些IDE不仅提供代码编辑和编译功能，还支持项目管理和调试。 C# 开发环境：Visual Studio（包括Visual Studio Community、Professional和Enterprise版本），集成了C#编译器、.NET Framework/.NET Core SDK，以及各种设计器和调试工具。 Python 开发环境：PyCharm、VS Code（配合Python插件）、Jupyter Notebook、Anaconda等，这些环境提供了交互式编程、调试、包管理（pip）、虚拟环境（venv）等全方位支持。 JavaScript 开发环境： 前端开发：VS Code（配合Live Server等插件）、Sublime Text、Atom等文本编辑器；Webpack、Parcel等打包工具；Vue DevTools、React Developer Tools等浏览器开发者工具。Node.js后端开发：Visual Studio Code（支持Node.js插件）、WebStorm等，同样提供完善的代码编辑、调试和npm包管理功能。 除了上述特定语言的IDE，还有一些跨平台、多语言支持的开发环境，如VS Code、Sublime Text等，它们可以通过安装相应的插件支持多种编程语言的开发。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b32a3044c5e1991648e508f47e86bce2/" rel="bookmark">
			概率基础——泊松分布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概率基础——泊松分布 介绍 在统计学中，泊松分布是一种用来描述单位时间（或空间）内事件发生次数的概率分布。它常被用来模拟稀有事件在固定时间或空间内的发生情况。泊松分布有着许多实际应用，尤其是在描述随机事件的计数过程中。
理论及公式 泊松分布的概率质量函数（PMF）为：
P ( X = k ) = e − λ λ k k ! P(X = k) = \frac{e^{-\lambda} \lambda^k}{k!} P(X=k)=k!e−λλk​
其中， k k k 表示事件发生的次数， λ \lambda λ 是单位时间（或空间）内事件发生的平均次数。
理论背景 泊松分布的出现是基于二项分布的一种极限情况。具体来说，当二项分布的试验次数 ( n ) 很大，每次试验成功的概率 p p p 很小，但是试验次数 n n n 乘以成功概率 p p p的期望值 n p np np保持适中时，二项分布可以近似为泊松分布。这种情况下，泊松分布的参数 λ \lambda λ 即为 n p np np。
示例与应用 一个典型的例子是飞机事故的发生情况。假设我们将一天内所有飞机起飞和降落的次数视为一系列独立同分布的伯努利试验，每次试验成功的概率 p p p即是一架飞机出现事故的概率，而试验次数 n n n 则是一天内飞机起飞和降落的总次数。在这种情况下，如果 n n n很大而 p p p很小，使得 n p np np保持适中，那么飞机事故的总数就可以用泊松分布来近似描述。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b32a3044c5e1991648e508f47e86bce2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5a5cb4bfcb653dbd297eb433b1f57d3/" rel="bookmark">
			Rabbitmq入门与应用(四)-RabbitMQ常见模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RabbitMQ常见Queue模式 简单模式 点对点模式，一个生产者一个消费者
生产者将消息发送到队列，消费者从队列中获取消息，队列是存储消息的缓冲区。
查看管理端效果 序列化解决方案 基于java序列化基于Json @Bean public MessageConverter messageConverter() { return new Jackson2JsonMessageConverter(); } @Bean public RabbitTemplate rabbitTemplate() { RabbitTemplate rabbitTemplate = new RabbitTemplate(factory); rabbitTemplate.setMessageConverter(messageConverter()); : : } 基于json
Work queues 工作队列模式：
一个生产者，多个消费者
C1，C2 是否都收到假设只有一个收到，谁收到（先） 结果： 只有一个消费者消费，轮训(负载均衡)的方式进行消费
@Bean public Queue workQueue() { return new Queue(RabbitMQConstants.WORK_QUEUE, DURABLE); } 发布订阅/fanout模式 生产者通过fanout扇出交换机群发消息给消费者，同一条消息每一个消费者都可以收到。
@Bean public Binding bindingFanoutA(){ return BindingBuilder .bind(fanoutQueueA()) .to(fanoutExchange()); } /** * Fanout交换机和队列B绑定 * @return */ @Bean public Binding bindingFanoutB(){ return BindingBuilder .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5a5cb4bfcb653dbd297eb433b1f57d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed6e253007af1817b9f880e0577d52b3/" rel="bookmark">
			http 和 https 的区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.http 和 https 的基本概念
2.http 和 https 的区别
3.https 协议的工作原理
4.https 协议的优点
5.https 协议的缺点
1.http 和 https 的基本概念 http: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。
https: 是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL 层， HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。https 协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。
2.http 和 https 的区别 http 传输的数据都是未加密的，也就是明文的，网景公司设置了 SSL 协议来对 http 协议传输的数据进行加密处理，简单来说 https 协议是由 http 和 ssl 协议构建的可进行加密传输和身份认证的网络协议，比 http 协议的安全性更高。 主要的区别如下：https协议需要 ca 证书，费用较高。http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。 使用不同的链接方式，端口也不同，一般而言，http协议的端口为80，https的端口为443，http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
3.https 协议的工作原理 客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：客户使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。 web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。 客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。 客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加 密会话密钥，并传送给网站。 web 服务器通过自己的私钥解密出会话密钥。 web 服务器通过会话密钥加密与客户端之间的通信。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed6e253007af1817b9f880e0577d52b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/803184b5299fa21a7ad279f0ddb57dcd/" rel="bookmark">
			初始化Superset数据库时提示：Refusing to start due to insecure SECRET_KEY（由于不安全SECRET_KEY而拒绝启动）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		水善利万物而不争，处众人之所恶，故几于道💦
文章目录 安装完Superset3.0.0后，初始化数据库的时候报错：设置一下这个变量的值：export SUPERSET_SECRET_KEY="oh-so-secret"，然后重新初始化就好了 pip install apache-superset==3.0.0 -i https://pypi.douban.com/simple/
安装完Superset3.0.0后，初始化数据库的时候报错： Refusing to start due to insecure SECRET_KEY
设置一下这个变量的值：export SUPERSET_SECRET_KEY=“oh-so-secret”，然后重新初始化就好了 参考地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0b7b736bf323d80d0ad3eff44f8ee3e/" rel="bookmark">
			kali live持久化的最新方法(以联想小新潮为例)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		categories: [VM]
tags: Linux VM Kali 写在前面 最近找到一块闲置的 u 盘, 想着重新折腾一下 Kali Linux 的 USB 持久化, 其实步骤不复杂, 但是 Windows 和联想小新潮 7000 的 bios 设置比较迷(可能是因为我之前装过双系统, 很多设置都要变)
Windows10 22H2 Intel i5
kali Linux2023.4 amd64
aigo u330 64GB
镜像下载 这里一定要下载 live 镜像, 用 ndm 开多线程十几分钟就下载好了. 下面附最新的链接
https://cdimage.kali.org/kali-2023.4/kali-linux-2023.4-live-amd64.iso 烧录 这里推荐用 Rufus 工具, 开源而且能够一步到位.
踩坑记录:
还试过官网推荐的其他方法, 例如用 etcher 或者 minitool, 前者显示失败了, 后者要花钱, 还用过 ventoy, 后来发现这个工具没啥实际用途, 主要是为了多系统共同存在于一个系统安装 U盘的工具, 而非把系统安装在 U 盘里面, 最后还是用 Rufus 了
选择镜像
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0b7b736bf323d80d0ad3eff44f8ee3e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/11/">«</a>
	<span class="pagination__item pagination__item--current">12/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/13/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>