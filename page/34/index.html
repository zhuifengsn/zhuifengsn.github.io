<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66fc9138dd8569082371da4e518713df/" rel="bookmark">
			相机雷达联合标定cam_lidar_calibration
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 运行环境：1.1 ROS环境配置1）工作空间创建和编译2）官方数据集测试环境 2.1 在线标定1）数据类型2）标定板制作3）配置文件4）开始标定5）完整实现步骤 3.1 python版本选择3.2 rviz参数修改 运行环境： ubuntu18.04.6 melodic
opencv 3.4.16
python 2.7.17 (ros自带)
usb-cam
速腾robosense 16
1.1 ROS环境配置 官方Github: https://github.com/acfr/cam_lidar_calibration
rs_to_velodyne :https://github.com/HViktorTsoi/rs_to_velodyne
1）工作空间创建和编译 # 创建工作空间 mkdir -p calib_new_ws/src cd calib_new_ws/src # 克隆仓库 git clone -c http.sslverify=false https://gitlab.acfr.usyd.edu.au/its/cam_lidar_calibration.git # 下载ros和python依赖 sudo apt update &amp;&amp; sudo apt-get install -y ros-noetic-pcl-conversions ros-noetic-pcl-ros ros-noetic-tf2-sensor-msgs pip install pandas scipy # 编译 cd calib_new_ws catkin_make 2）官方数据集测试环境 ①开始标定
source ./devel/setup.bash roslaunch cam_lidar_calibration run_optimiser.launch import_samples:=true 标定好的文件保存在 cam_lidar_calibration/data/vlp/路径下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66fc9138dd8569082371da4e518713df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fab4864e965486f610b1eab5991d7191/" rel="bookmark">
			抽奖！抽奖！抽奖！大转盘、九宫格、老虎机开放抽奖组件！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个基于JS+Canvas实现大转盘&amp;九宫格&amp;老虎机的抽奖免费组件！只需要简单的配置需要的属性就可以制定自己需要的功能效果。
地址如下：https://100px.net/
使用范围：JS/TS、VUE、Reacct、微信小程序、UniApp、Taro中使用。
第一步先安装插件：
# npm 安装： npm install @lucky-canvas/react@latest # yarn 安装： yarn add @lucky-canvas/react@latest
第二步超简单的引入方式
在示例中的基本示例选择你需要的的抽奖模式→大转盘、九宫格、老虎机。
引入你的页面或者单独将抽奖封装成一个组件即可使用。
第三步根据提供的文档中的属性，修改成你单独的抽奖组件。
使用示例，React 中单独封装的抽奖组件
//简单封装 export interface RouletteConfiguration { width?: string height?: string Blocks?: any Prizes?: any RouletteImage?: any } const BigWheel = (props: RouletteConfiguration) =&gt; { //获取初始化数据 useEffect(() =&gt; { setblocks([ { padding: '12px', imgs: [ { src: props?.RouletteImage, width: '100%', height: '100%', rotate: true } ] } ]) }, [props?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fab4864e965486f610b1eab5991d7191/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40cc49256f28c1462bf02ead0dd250af/" rel="bookmark">
			java8 list to tree 工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ListToTreeUtil import lombok.Data; import java.util.*; import java.util.function.BiConsumer; import java.util.function.Consumer; import java.util.function.Function; import java.util.function.Supplier; public class ListToTreeUtil { public static &lt;T&gt; List&lt;Tree&lt;T&gt;&gt; convertListToTree(List&lt;T&gt; nodeList, TreeConverter&lt;T&gt; converter) { if (nodeList == null || nodeList.isEmpty()) { return new ArrayList&lt;&gt;(); } Map&lt;Object, Tree&lt;T&gt;&gt; nodeMap = new HashMap&lt;&gt;(); List&lt;Tree&lt;T&gt;&gt; rootNodes = new ArrayList&lt;&gt;(); // 将节点放入Map中，方便后续查找和创建树 for (T item : nodeList) { Object itemId = converter.getItemId(item); Tree&lt;T&gt; treeNode = new Tree&lt;&gt;(itemId, item); nodeMap.put(itemId, treeNode); } // 遍历节点列表，将每个节点添加到其父节点的子节点列表中，或者作为根节点 for (T item : nodeList) { Object parentId = converter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40cc49256f28c1462bf02ead0dd250af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eee2a7c16a1557be834f2bda32fcc83b/" rel="bookmark">
			51单片机——LCD1602模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.LCD1602介绍
1.LCD1602 (Liquid Crystal Display
)液晶显示屏是一种字符型液晶显示模块，可以显示ASCII码的标准字符和其它的一些内置特殊字符，还可以有8个自定义字符。
2.显示容量:16x2个字符，每个字符为5*7点阵。
二.LCD1602接口介绍
引脚功能VSS接地VDD电源正极（4.5v-5.5v）VO对比调节电压RS数据/指令选择，1为数据，0为指令RW读/写选择，1为读，0为写E使能，1为数据有效，下降沿执行命令（使能：相当于遥控器的电源键）D0-D7数据输入/输出A背灯电源正极K背灯电源负极 注：当RS=1时，D0-D7为数据，当RS=0时，D0-D7为指令。
三.LCD1602原理图
四.LCD1602内部结构图 DDRAM：在哪个方格子显示数据（RS=0——指令）。
CGRAM（可写）+CGROM（不可写）：在方格子显示什么数据（RS=1——数据）。
AC（光标位置）：控制当前要写在屏幕对应的那个格子。
DDRAM确定显示位置然后字模库显示想要数据，最后输出在屏幕上。
五.时序结构
RS，RW和D7-D0上面介绍过了，这里介绍E，E下面有一行字母valid Data（有效数据），则E为高电平的时候数据有效，之后在设置为低电平，以便下一次数据设置，因此代码为：
E=1;
Delay1ms();
E=0;
Delay1ms();
所以想写数据跟指令的代码为：
#include &lt;REGX52.H&gt; #include &lt;INTRINS.H&gt; sbit LCD_RS=P2^6; sbit LCD_RW=P2^5; sbit LCD_EN=P2^7; #define LCE_Dataport P0 void Delay1ms()	//@11.0592MHz { unsigned char i, j; _nop_(); _nop_(); _nop_(); i = 11; j = 190; do { while (--j); } while (--i); } void LCD_WriteCommand(unsigned char Command)//写指令 { LCD_RS=0; LCD_RW=0; LCE_Dataport=Command; LCD_EN=1; Delay1ms(); LCD_EN=0; Delay1ms(); } void LCD_WriteData(unsigned char Data)//写数据 { LCD_RS=1; LCD_RW=0; LCE_Dataport=Data; LCD_EN=1; Delay1ms(); LCD_EN=0; Delay1ms(); } 六.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eee2a7c16a1557be834f2bda32fcc83b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d880d999056d666132d8f0adb9e5221/" rel="bookmark">
			SQL如何确保数据唯一性？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL中的UNIQUE约束：确保数据唯一性的强大工具 简介 在SQL数据库中，UNIQUE约束是一种用于确保数据唯一性的重要工具。本文将深入探讨UNIQUE约束的概念、应用场景以及使用方法，以帮助读者更好地理解和利用UNIQUE约束来保证数据的一致性和准确性。
获取更多技术资料，请点击！
UNIQUE约束 在SQL数据库中，UNIQUE约束是一种用于确保数据唯一性的关键工具。它允许我们在表的一列或多列上定义唯一性限制，防止重复数据的插入或更新。下面我们将深入探讨UNIQUE约束的重要性、应用场景以及使用方法。
UNIQUE 和 PRIMARY KEY 的区别
UNIQUE（唯一约束）和 PRIMARY KEY（主键）非常相似，但是 UNIQUE 允许字段中出现一次 NULL 值，而 PRIMARY KEY 不允许出现 NULL 值一张表可以包含多个 UNIQUE 字段，但是只能有一个主键 UNIQUE约束的重要性 UNIQUE约束在数据库中具有重要的作用。它用于确保特定列或列组合中的值是唯一的，防止重复数据的出现。通过使用UNIQUE约束，我们可以保证数据的一致性、准确性和完整性，提高数据质量和查询效率。
UNIQUE约束的应用场景 主键约束：在SQL中，主键是一种特殊的UNIQUE约束。它可以将一个或多个列定义为表的主键，确保主键值的唯一性。主键约束常用于标识表中的唯一记录，作为数据的主要标识符。唯一索引：除了主键约束外，我们还可以在表的列上创建独立的唯一索引。唯一索引使用UNIQUE约束，可以加速数据查询，并确保特定列的唯一性。复合UNIQUE约束：有时，我们需要在多个列的组合上定义唯一性限制。通过创建复合UNIQUE约束，可以确保多个列的组合值是唯一的。这在多列组合具有唯一性要求的情况下非常有用。 注意事项
空值和UNIQUE约束：UNIQUE约束通常将空值视为唯一值。因此，在定义UNIQUE约束时，需要特别注意对允许空值的列进行处理，以确保数据的一致性。外键约束和UNIQUE约束：当在表之间定义外键关系时，需要注意与UNIQUE约束之间的关系。外键引用的列通常需要与UNIQUE约束的列保持一致，以确保数据的引用完整性。 使用示例 下面的 SQL 语句将创建一个名为 Customers 的新表，该表包含八个字段，其中 email 和phone被设置为 UNIQUE，因此任何顾客的email地址和电话号码都必须不同。如下：
CREATE TABLE Customers ( id INT NOT NULL AUTO_INCREMENT, name VARCHAR(20) NOT NULL, age TINYINT UNSIGNED NOT NULL, city INT UNSIGNED NOT NULL, Consumption amount FLOAT DEFAULT '0.0', country CHAR(3) NOT NULL DEFAULT '', email VARCHAR(30) UNIQUE, phone VARCHAR(30) UNIQUE, PRIMARY KEY (`id`) ); 如果已经创建了 Customers 表，则可以通过 ALTER TABLE 语句将 UNIQUE 约束添加到 email 字段，代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d880d999056d666132d8f0adb9e5221/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02df4d42c95f9a565c363c40836dd6d9/" rel="bookmark">
			【C语言督学训练营 第十四天】二叉树真题实战 ----- 层序建树、前中后序遍历、求树的WPL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言树概念二叉树层序建树四种遍历二叉树的方式层次遍历前序遍历中序遍历后续遍历 真题实战！ 前言 今天进行总结的是考研408有关二叉树的基础知识，是王道C语言督学营的第十四天，随着课程的深入，代码实战的难度慢慢的上来了，如果觉着代码实战有困难，那么我推荐先在纸上画一画，然后再上代码，今天这节课主要进行了二叉树的层序建树，二叉树的前中后序遍历，以及层序遍历，最后针对一道2014年的考研真题进行了解析！
先预热一下：
树概念 树是n (n≥0）个节点的有限集。当n = O时，称为空树。
在任意一棵非空树中应满足:
1)有且仅有一个特定的称为根的结点。2)当n &gt;1时，其余节点可分为m (m &gt; 0）个互不相交的有限集T1，T2,…", Tm，其中每个集合本身又是一棵树，并且称为根的子树。 树作为一种逻辑结构，同时也是一种分层结构，具有以下两个特点:
1）树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。2）树中所有结点可以有零个或多个后继。
二叉树 二叉树是一种特殊的树形结构，其特点是每个结点至多只有两棵子树(即二叉树中不存在度大于2的结点)，并且二叉树的子树有左右之分,其次序不能任意颠倒。
与树相似，二叉树也以递归的形式定义。二叉树是n (n≥O)个结点的有限集合:
①或者为空二叉树，即n= 0.②或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。 二叉树又可分为满二叉树与完全二叉树，两者形如下图：
满二叉树与完全二叉树，因为其独有的特性，采用顺序存储结构存储极为方便。后面排序时会进行实战！
链式二叉树节点结构定义如下：
这里仅仅是对二叉树进行了简要的介绍，真正的知识要比这个多得多，后面在介绍数据结构的时候会详细介绍！记住下面图片的内容，然后开启我们今天的实战！
层序建树 层析建树我们需要借助一个辅助队列进行实现，我的思路是，使用队列记录数节点的输入顺序，然后根据节点的左子树右子树指针是否为空向其子树填值，当左子树右子树均有值的时候就向下一个节点填充，每次填充的内容是新入队的节点！直到将辅助队列遍历一遍，二叉树也就层序建树成功！
建树代码如下：
节点的定义：
// // Created by 123 on 2023/2/20. // #ifndef MYTEST_BITSTRUCT_H #define MYTEST_BITSTRUCT_H //基础元素类型 #define ElementData int #define ElementDataEnd -1 //二叉树的节点 struct BiTNode{ ElementData data; struct BiTNode *leftNode; struct BiTNode *rightNode; }; typedef struct BiTNode BiTNode; //辅助队列（通过这个队列层次建树） struct auxiliary{ // 指向二叉树中的节点 struct BiTNode* p; struct auxiliary *next; }; typedef struct auxiliary tagQueue; #endif //MYTEST_BITSTRUCT_H 代码中的前两个函数是为了初始化节点方便设计的；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02df4d42c95f9a565c363c40836dd6d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0702c182864aef25321493dd7c4204e8/" rel="bookmark">
			VS Code基于服务器中的docker的开发环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VS Code基于服务器中的docker的开发环境配置 基于Dev Containers插件基于Jump Machine（跳板机）服务器通过ssh连接docker容器VS Code配置ssh config文件连接docker容器 基于Dev Containers插件 当然可以在vscode中直接下载Dev Containers插件，在连接到服务器之后，在Dev Containers中找到相应的docker连接后直接进行开发。
此时你就会看到你服务器上所有正在运行的docker容器（必须要保证你想要开发的docker容器此时的状态是正在运行），然后点击对应的docker容器连接即可，之后的操作就和remote-ssh连接服务器操作一致了。
基于Jump Machine（跳板机） 跳板机可以理解为将服务器作为一个跳板，然后通过这个跳板连接到服务器中的docker容器。
服务器通过ssh连接docker容器 注意服务器连接docker容器可以直接通过docker exec -it &lt;docker_container&gt; /bin/bash，此处演示用ssh连接docker容器
ssh -p &lt;port&gt; root@127.0.0.1 # 注意此处的&lt;port&gt;是指docker容器22端口映射到本地的端口 # 即在创建docker容器的时候 docker run -it -p &lt;host_port&gt;:22 ...... # 此处的&lt;host_port&gt;就是指上述命令中的&lt;port&gt; 通过上述命令就能连接到docker容器，但是此处需要注意，在连接前docker容器中需要修改一些参数，
vim /etc/ssh/sshd_config PubkeyAuthentication yes # 启用公钥私钥配对认证方式 PermitRootLogin yes # root能使用ssh登录 port=22 # 开启22端口 然后将服务器的~/.ssh/id_rsa.pub中的公钥添加到docker容器的~/.ssh/authorized_keys文件中，实现免密登录。
VS Code配置ssh config文件连接docker容器 此处以macOS为例，先找到家目录下的~/.ssh/config文件
# 配置服务器作为跳板机 Host server # 自定义即可 User &lt;username&gt; HostName &lt;server_ip&gt; Port &lt;port&gt; # 此处&lt;port&gt;是指服务器的ssh端口(默认是22) IdentityFile ~/ssh/id_rsa # 如果是私钥连接服务器，则需要本地私钥文件 # 利用跳板机连接docker容器 Host server_docker # 自定义即可 User root HostName 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0702c182864aef25321493dd7c4204e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdfecb94904a1e4c46fc184371cf10e7/" rel="bookmark">
			Java泛型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。
泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。
泛型标记符 E - Element (在集合中使用，因为集合中存放的是元素)T - Type（Java 类）K - Key（键）V - Value（值）N - Number（数值类型）？ - 表示不确定的 java 类型 优点 避免了类型强转的麻烦。它提供了编译期的类型安全，确保在泛型类型（通常为泛型集合）上只能使用正确类型的对象，避免了在运行时出现ClassCastException。 泛型类 泛型类的定义语法 class 类名称 &lt;泛型标识，泛型标识，…&gt; { private 泛型标识 变量名; ..... } 定义语法 // Java1.7以后，后面的&lt;&gt;中的具体的数据类型可以省略不写,如：类名&lt;具体的数据类型&gt; 对象名 = new 类名&lt;&gt;(); 类名&lt;具体的数据类型&gt; 对象名 = new 类名&lt;具体的数据类型&gt;(); 泛型类注意事项 泛型类，如果没有指定具体的数据类型，此时，操作类型是Object
泛型的类型参数只能是类类型，不能是基本数据类型
泛型类型在逻辑上可以看成是多个不同的类型，但实际上都是相同类型
泛型类派生子类（泛型继承） 子类是泛型类，子类和父类的泛型类型要一致
class ChildGeneric&lt;T&gt; extends Generic&lt;T&gt; 子类不是泛型类，父类要明确泛型的数据类型
class ChildGeneric extends Generic&lt;String&gt; 使用示例 /** * 此处的T可以随便写为任意标识，常见的有T、E等形式的参数表示泛型,泛型在定义的时候不具体，使用的时候才变得具体。在使用的时候确定泛型的具体数据类型。即在创建对象的时候确定泛型。 */ public class GenericsClassDemo&lt;T&gt; { //t这个成员变量的类型为T,T的类型由外部指定 private T t; //泛型构造方法形参t的类型也为T，T的类型由外部指定 public GenericsClassDemo(T t) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdfecb94904a1e4c46fc184371cf10e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/968c8425a037ca20cce6e2742429a01c/" rel="bookmark">
			settings.xml 阿里云源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/968c8425a037ca20cce6e2742429a01c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3b10ccbe41cc838a84a556d465db745/" rel="bookmark">
			【数据结构】链表带头结点与不带头结点区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链表带头节点和不带头节点的区别在于： 是否在链表头部添加一个额外的节点作为哨兵节点。
链表不带头节点的实现中，第一个节点即为链表的头节点，因此在插入和删除节点时需要特别处理。如果链表为空，需要特别处理头指针；如果删除的是头节点，需要特别处理头指针。这些特殊情况会增加代码的复杂度和出错的可能性。
链表带头节点的实现中，在链表头部添加一个额外的节点作为哨兵节点，该节点不存储数据，只用于简化链表的操作。头指针指向哨兵节点，因此链表中的第一个节点为哨兵节点的下一个节点，这样在插入和删除节点时就不需要特别处理头指针，所有节点的操作都可以统一处理。
因此，链表带头节点的实现更加简单、清晰，容易理解和维护，也更加健壮。但是，带头节点的实现会增加一个额外的节点，占用一定的内存空间。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/505c89e7eb7b9097c80ae4fd275d6735/" rel="bookmark">
			Windows10下安装Oracle19c提示“无法将 **\** 安装用户添加到 ** 组“解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 操作系统：window10
数据库版本：Oracle19c
本机在安装Oracle19c提示无法将 ZHOUQUAN\zhouquan 安装用户添加到 %2% 组。
问题原因 根据安装的对话框中的日志，找到并打开
日志报错信息：
信息: WindowsSecurityException has occurred
严重: PRCZ-1082 : 无法将 Windows 用户或 Windows 组 “zhouquan” 添加到 Windows 组 “USERS” 中
WSE-000031: 无法将用户添加到操作系统组。
O/S-Error: (OS 1387) 该成员不存在，因此不能将其添加到本地组中或从本地组删除。
Caused by: oracle.ops.mgmt.nativesystem.NativeException: WSE-000031: 无法将用户添加到操作系统组。
O/S-Error: (OS 1387) 该成员不存在，因此不能将其添加到本地组中或从本地组删除。
信息: 操作中引发异常错误: AddInstallUserToGroup
异常错误名: WindowsSecurityException has occurred
异常错误字符串: 无法将 ZHOUQUAN\zhouquan 安装用户添加到 %2% 组。
异常错误严重性: 0
信息: WindowsSecurityException has occurred
严重: PRCZ-1082 : 无法将 Windows 用户或 Windows 组 “zhouquan” 添加到 Windows 组 “USERS” 中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/505c89e7eb7b9097c80ae4fd275d6735/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c472d69c5720bd6e75b92c91f57a06f4/" rel="bookmark">
			计算机网络层——习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 某单位的一台主机的IP地址为218.23.49.55，其子网掩码为255.255.255.224，请写出该IP地址所在的网络号，该子网内可分配的主机IP地址范围。 正确答案： P地址218.23.49.55与子网掩码255.255.255.224相与得218.23.49.32，即该IP地址所在的网络号为218.23.49.32。可分配的IP地址范围为218.23.49.33~218.23.49.62。
2. 某C类网络号为198.168.3.0，若需要将该网络划分成6个子网，请给出你的划分方案。 （1）给出选用的子网掩码；
（2）给出各子网的网络号；
（3）给出各子网内的广播地址；
（4）给出各子网内可分配的主机IP地址范围。
正确答案： 划分为6个子网，选用的子网位为3位，即掩码为255.255.255.224。
网络号
广播地址
IP地址范围
第1个子网
198.168.3.32
98.168.3.63
198.168.3.33~198.168.3.62
第2个子网
198.168.3.64
198.168.3.95
198.168.3.65~198.168.3.94
第3个子网
198.168.3.96
198.168.3.127
198.168.3.97~198.168.3.126
第4个子网
198.168.3.128
198.168.3.159
198.168.3.129~198.168.3.158
第5个子网
198.168.3.160
198.168.3.191
198.168.3.161~198.168.3.190
第6个子网
198.168.3.192
198.168.3.223
198.168.3.193~198.168.3.222
3.简述路由器转发IP数据报的基本过程。 正确答案： （1）解封数据链路层协议，去掉L2的数据，得到IP数据报。
（2）从数据报的头部提取目的主机的IP地址D，和对应的子网掩码做与运算，得出目的网络地址为N。
（3）若网络N与此路由器直接相连，则已经到达目的网络，则把数据报直接交付目的主机D；否则是间接交付，执行（4）。
（4）若路由表中有目的地址为D的特定主机路由，则表示可以直接到达目的端，把数据报传送给路由表中所指明的转发接口；否则执行（5）。
（5）若路由表中有到达远程网络N的路由，则把数据报传送给路由表指明的下一跳路由器；否则执行（6）。（6）在当前路由器中查询不到远程网络N的下一跳地址，若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则执行（7）。
（7）报告转发分组出错，丢弃该分组。
4. (简答题) 设某路由器R建立了路由表如表1，此路由器可以直接从接口0和接口1转发分组，也可以通过相邻的路由器R2，R3和R4进行转发。
表1 路由器R的路由表
目的网络 子网掩码 下一站
202.118.0.0 255.255.255.224 接口0
202.118.10.0 255.255.255.0 接口1
202.118.0.240 255.255.255.240 R2
190.168.19.0 255.255.255.192 R3
*（默认） 0.0.0.0 R4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c472d69c5720bd6e75b92c91f57a06f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b29f0af7d7b63e116cef7c594779e92f/" rel="bookmark">
			vuex页面刷新数据丢失问题的四种解决方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vuex是大家使用vue时大多数都会选择的,但是当页面刷新之后vuex数据会丢失,下面这篇文章主要给大家介绍了关于vuex页面刷新数据丢失问题的四种解决方式,需要的朋友可以参考下
为什么说刷新页面vuex的数据会丢失 刷新页面vuex的数据会丢失属于正常现象，因为JS的数据都是保存在浏览器的堆栈内存里面的，刷新浏览器页面，以前堆栈申请的内存被释放，这就是浏览器的运行机制，那么堆栈里的数据自然就清空了。
第一种方法用sessionStorage 将接口返回的数据保存在vuex的store里，也将这些信息也保存在sessionStorage里。注意的是vuex中的变量是响应式的，而sessionStorage不是，当你改变vuex中的状态，组件会检测到改变，而sessionStorage就不会了，页面要重新刷新才可以看到改变，所以应让vuex中的状态从sessionStorage中得到，这样组件就可以响应式的变化。
在store文件夹里面的js文件 示例如下
const state = { authInfo: JSON.parse(sessionStorage.getItem("COMPANY_AUTH_INFO")) || {} } const getters = { authInfo: state =&gt; state.authInfo, } const mutations = { SET_COMPANY_AUTH_INFO(state, data) { state.authInfo = data sessionStorage.setItem("COMPANY_AUTH_INFO", JSON.stringify(data)) } } //actions 模块里无需使用 sessionStorage export default { namespaced: true, state, getters, mutations, //actions, } 其实这里还可以用 localStorage，但是它没有期限；所以常用的还是sessionStorage，当浏览器关闭时会话结束。
第二种方法是 vuex-along 示例如下 （1）安装 vuex-along
npm install vuex-along --save （2）在store文件夹里的index.js中引入vuex-along并配置相关代码
import Vue from 'vue' import Vuex from 'vuex' import indexOne from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b29f0af7d7b63e116cef7c594779e92f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e04c71e9d9f3fc91f6aee89fa4f5a3a/" rel="bookmark">
			linux机器配置互信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 两台机器A和B,现要通过A ssh无密码访问B
1、登录A，执行命令
ssh-keygen -t rsa 之后一路回车，在/root/.ssh 目录下生成id_rsa和id_rs.pub两个文件,id_rsa为私钥,id_rs.pub为公钥
2、公钥拷贝到B机器上：
scp /root/.ssh/id_rsa.pub root@B:/root/ 3、登录B，并将该文件追加到/root/.ssh/authorized_keys文件中
cat /root/id_rsa.pub &gt;&gt;/root/.ssh/authorized_keys 4、修改authorized_keys权限
chmod 600 /root/.ssh/authorized_keys 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffaee42b647d52eb1611e120160300e3/" rel="bookmark">
			利用JWT、注解拦截请求并验证token
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Web应用程序中，注解是一种方便的方式来拦截和处理请求。可以通过在代码中添加注解来定义一些特殊的行为，比如拦截器（Interceptor）等。
拦截器是一种处理请求的技术，它可以在请求被处理之前或之后对请求进行处理。通过使用拦截器，可以在处理请求之前或之后添加额外的逻辑，例如身份验证、权限检查等。
所需JWT依赖： &lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;4.2.1&lt;/version&gt; &lt;/dependency&gt; 定义一个登录用户类： /** * @Author RainCity * @Date 2021-05-24 10:49:59 * @Desc 登录用户 */ public class LoginUser implements Serializable { private static final long serialVersionUID = 768788313972112861L; /**登录名*/ private String loginName; /**登录密码*/ private String password; public String getLoginName() { return loginName; } public void setLoginName(String loginName) { this.loginName = loginName; } public String getPassword() { return password; } public void setPassword(String password) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffaee42b647d52eb1611e120160300e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ba745c15ca50ae9e1f2990f1bdb39f6/" rel="bookmark">
			对象池 GenericObjectPool 配置参数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对象池 GenericObjectPool 配置参数详解 1. 依赖2. 父类BaseObjectPoolConfig配置参数2.1 lifo2.2 fairness2.3 maxWaitMillis2.4 minEvictableIdleTimeMillis2.5 evictorShutdownTimeoutMillis2.6 softMinEvictableIdleTimeMillis2.7 numTestsPerEvictionRun2.8 evictionPolicyClassName2.9 testOnCreate2.10 testOnBorrow2.11 testOnReturn2.12 testWhileIdle2.13 timeBetweenEvictionRunsMillis2.14 blockWhenExhausted2.15 jmxEnabled2.16 jmxNamePrefix2.17 jmxNameBase 3. 子类GenericObjectPoolConfig配置参数3.1 maxTotal3.2 maxIdle3.3 minIdle 1. 依赖 &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.4.3&lt;/version&gt; &lt;/dependency&gt; 使用 GenericObjectPool，有必要了解一下 GenericObjectPoolConfig，下面将说明一下其配置参数。
2. 父类BaseObjectPoolConfig配置参数 /** * Provides the implementation for the common attributes shared by the * sub-classes. New instances of this class will be created using the defaults * defined by the public constants.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ba745c15ca50ae9e1f2990f1bdb39f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a84c94d4ca3b2919e3340acae39bd98/" rel="bookmark">
			利用注解及ResponseBodyAdvice对返回参进行加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对返回参数进行加密可以增强数据传输的安全性，以防止敏感数据被截获或篡改。
枚举类 用于区分数据的加密方式
/** * 加密方式 * @Author RainCity * @Date 2023-04-12 17:00:53 */ public enum EncryptMode { /** * BASE64 */ BASE64, /** * AES */ AES, /** * RSA */ RSA, } 注解 用于方法上，标识此方法的返回参数需要加密后返回，默认BASE64加密
/** * @Author RainCity * @Date 2022-08-29 08:49:23 * @Desc 用于方法，参数加密注解 */ @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface EncryptResponse { EncryptMode encryptMode() default EncryptMode.BASE64; } ResponseBodyAdvice 处理参数的加密
/** * @Author RainCity * @Date 2023-04-12 13:44:18 * @Desc 返回参数加密 */ @ControllerAdvice public class EncryptResponseAdvice implements ResponseBodyAdvice&lt;Object&gt; { private static final Logger log = LoggerFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a84c94d4ca3b2919e3340acae39bd98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dbed163733ee2111e80730513c46ea6/" rel="bookmark">
			使用logback配置日志打印策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
logback-spring.xml配置详解
1、父标签configuration
2、两种属性标签
3、三个节点标签
3.1、append节点标签
3.2、root节点标签
3.3、logger节点标签
3.4、logger和root的关系
4、完整日志配置
logback在springboot中有内置的存在，当然也可以再重新引用依赖，但是没必要。logback框架可以控制日志日志的打印级别、打印内容、还可以实现error级别日志报警，将其发送到指定邮箱或者钉钉。
logback-spring.xml配置详解 在logback-spring.xml配置文件中，按标签的级别来分，有一个父标签，两种属性标签和和三种节点标签。分别是
一个父标签：configuration 两种属性：contextName和property 三个节点：appender、root、logger springboot配置文件的加载顺序logback.xml-&gt;application.yml-&gt;logback-spring.xml
1、父标签configuration configuration最外层标签，该标签有三个属性：
scan
当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为truescanPeriod
设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。debug
当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 &lt;configuration scan="true" scanPeriod="10 seconds" debug="true"&gt; &lt;/configuration&gt; 2、两种属性标签 contextName和property是处于第二层的标签。
contextName
&lt;contextName&gt;标签用于指定日志上下文的名称。日志上下文是Logback框架中的一个重要概念，它表示一个独立的日志实例或日志环境。通过设置不同的上下文名称，您可以创建并配置多个独立的日志记录器，每个日志记录器可以有自己的日志级别、输出目标等配置。
&lt;configuration scan="false" scanPeriod="60 seconds" debug="false"&gt; &lt;contextName&gt;logback_demo&lt;/contextName&gt; &lt;/configuration&gt; property
用来定义变量值的标签， 有两个属性，name和value；其中name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义变量后，可以使“${}”来使用变量。
&lt;property name="log-path" value="log.path" /&gt; 3、三个节点标签 三个节点标签分别是append、logger、root
3.1、append节点标签 这个标签属于核心标签，用于定义日志的输出目标。它指定了日志消息将发送到哪里，例如控制台、文件、数据库等。
标签属性：
name：指定appender的名称，应该是唯一的。class：指定appender的实现类。例如，ch.qos.logback.core.ConsoleAppender表示控制台输出，ch.qos.logback.core.FileAppender表示文件输出。其他属性：具体取决于所选的appender类，例如文件路径、文件滚动策略等。 控制台输出时子标签：
&lt;filter&gt;：标签用于配置日志事件过滤器，可以根据特定的条件过滤和控制日志输出。&lt;encoder&gt;：ancoder的意思是追加器，在这里可以理解为渲染器，用来指定日志输出的格式。&lt;rollingPolicy&gt; ：日志记录器的滚动策略，按日期，按大小记录，只有在输出到文本中时才需要配置这个。 控制台打印示例：
&lt;!--0. 日志格式和颜色渲染 --&gt; &lt;!-- 彩色日志依赖的渲染类 --&gt; &lt;conversionRule conversionWord="clr" converterClass="org.springframework.boot.logging.logback.ColorConverter" /&gt; &lt;conversionRule conversionWord="wex" converterClass="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dbed163733ee2111e80730513c46ea6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57dad5daeab807db55f92764f697756a/" rel="bookmark">
			Java通过注解构建树结构工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java通过注解构建树结构工具类 前言枚举类注解获取注解标识的字段值构建树结构工具类 前言 在Java中，注解是一种元数据，可以提供有关代码的附加信息。通过使用注解，可以在代码中添加配置信息、验证条件、文档和其他信息，这使得代码更易于理解和维护。在本文中，我将介绍如何使用Java注解构建树结构工具类。
话不多说，现在开搞======================&gt;
枚举类 标识字段的数据类型
public enum DataType { /** long */ LONG, /** string */ STRING, /** LIST */ LIST, } 注解 标识字段为主键
@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) public @interface PrimaryKey { /** 字段数据类型默认为 long */ DataType dataType() default DataType.LONG; } 标识字段为父id
@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) public @interface ParentKey { /** 字段数据类型默认为 long */ DataType dataType() default DataType.LONG; } 标识字段为子集
@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) public @interface ChildrenKey { /** 字段数据类型默认为 List */ DataType dataType() default DataType.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57dad5daeab807db55f92764f697756a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aef09ff5ba2eb06b62e49595c1c992e9/" rel="bookmark">
			AES加密解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Java中的AES加密和解密需要使用javax.crypto包中的Cipher类。
AES数据填充模式有以下几种：
NoPadding
不进行任何填充，要求明文数据长度必须为加密算法块大小的整数倍。如果明文数据长度不足，则需要进行补位操作。PKCS5Padding
适用于块长度为8个字节的加密算法（如DES），每个填充字节的值都为填充字节数量。PKCS7Padding
适用于块长度为1到255个字节的加密算法，填充字节的值都为填充字节的数量。ISO10126Padding
在PKCS7Padding的基础上，填充字节中随机填入一部分字符。TBCPadding
适用于块长度为8个字节的加密算法，每个填充字节的值都为0x00。 在实际使用中，常用的填充模式是PKCS7Padding。如果要求数据长度必须为加密算法块大小的整数倍，可以选择使用NoPadding，并在加密前手动对数据进行补位。
下面利用PKCS7Padding填充模式实现Java的AES加密和解密。
需要的依赖： &lt;!--让java支持PKCS7Padding--&gt; &lt;dependency&gt; &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt; &lt;artifactId&gt;bcprov-jdk18on&lt;/artifactId&gt; &lt;version&gt;1.72&lt;/version&gt; &lt;/dependency&gt; 常量： /** 加密算法 */ private static final String ALGORITHM = "AES"; /** 数据填充模式 */ private static final String AES_CBC_PKCS_7_PADDING = "AES/CBC/PKCS7Padding"; /** 密钥 key 16位 */ private static final String SECRET_KEY = ""; /** 偏移向量 iv */ private static final String IV_SPEC = ""; static { //让java支持PKCS7Padding Security.addProvider(new BouncyCastleProvider()); } 加密： /** * 加密 * @param plaintext 需要加密的明文 * @return java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aef09ff5ba2eb06b62e49595c1c992e9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/33/">«</a>
	<span class="pagination__item pagination__item--current">34/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/35/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>