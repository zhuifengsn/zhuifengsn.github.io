<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d67142b0d576f637748607006ccf5ac/" rel="bookmark">
			《深度学习进阶 自然语言处理》第五章：RNN通俗介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 5.1 概率和语言模型5.1.1 概率视角下的word2vec5.1.2 语言模型5.1.3 将CBOW模型用作语言模型的效果怎么样？ 5.2 RNN5.2.1 循环神经网络5.2.2 展开循环5.2.3 Backpropagation Through Time5.2.4 Truncated BPTT5.2.5 Truncated BPTT的mini-batch学习 5.3 RNN的实现5.4 RNNLM的学习与评价5.4.1 RNNLM的实现5.4.2 语言模型的评价 5.5 小结 之前文章链接：
开篇介绍：《深度学习进阶 自然语言处理》书籍介绍
第一章：《深度学习进阶 自然语言处理》第一章：神经网络的复习
第二章：《深度学习进阶 自然语言处理》第二章：自然语言和单词的分布式表示
第三章：《深度学习进阶 自然语言处理》第三章：word2vec
第四章：《深度学习进阶 自然语言处理》第四章：Embedding层和负采样介绍
我们之前在介绍神经网络的时候，一般以CNN举例。那么CNN和接下来要介绍的RNN(Recurrent Neural Network)有什么区别呢？
其实CNN是一种典型的前馈型神经网络。前馈 (feedforward）是指网络的传播方向是单向的。具体地说，先将输入信号传给下一层（隐藏层)，接收到信号的层也同样传给下一层，然后再传给下一层⋯⋯像这样，信号仅在一个方向上传播。
这类型前馈神经网络在处理时间序列数据的时候，效果并不好，其无法充分学习时序数据的性质，但是该问题恰好RNN可以解决。那么，接下来我们一起看一下RNN的结构。
5.1 概率和语言模型 5.1.1 概率视角下的word2vec 在介绍RNN之前，我们先复习一下上一章的word2vec, 以CBOW为例，该模型所做的事情就是从上下文（wt-1和 wt+1） 预测目标词（wt)。整体结构如下图：
用数学式来表示“当给定wt-1，和wt+1时目标词是wt的概率”：
如果把CBOW中的上下文限定为左侧窗口，则如下图：
在仅将左侧2 个单词作为上下文的情况下，CBOW 模型输出的概率如下：
现在我们已经通过概率表示了CBOW模型，那么其是否可以在语言模型中发挥作用呢？在讨论这个问题前，我们先一起看一下什么是语言模型。
5.1.2 语言模型 语言模型 （languege model）给出了单词序列发生的概率。具体来说， 就是使用概率来评估一个单词序列发生的可能性，即在多大程度上是自然的单词序列。比如，对于“you say goodbye”这一单词序列，语言模型给出高概率（比如0.092)；对于 “you say good die“这一单词序列，模型则给出低概率（比如0.000 000 000 003 2)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d67142b0d576f637748607006ccf5ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f6ab9b687f67890c10b848059619339/" rel="bookmark">
			VIAVI唯亚威FI-10/-11 光纤识别仪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FI-10 和 FI-11 手持式光纤识别仪稳固可靠，易于安装和维护，能够检测通过单模光纤传输的光信号，从而识别出光纤。它们采用局部检测技术（非破坏性宏弯检测），从而不再需要在接合点处打开光纤进行识别，而这又消除了中断服务的可能性。
特点
工作范围为 850-1700 纳米。
与大多数 AT&amp;T 和 Corning 光纤兼容。
使用非破坏性宏弯技术。
检测灵敏度为 -40 dBm。
双向流量标示。
应用
实时光纤识别。
测量核心功率并在 2 位 LED 显示屏上显示 (FI-11)。
270 Hz、1000 Hz 和 2000 Hz 调制音调检测。
相对零功率读数 (FI-11)。
接头或连接器功率损耗测量 (FI-11)。
主要特性
高强度 LED 指示活动信号传输。
套层光纤、涂层光纤或带状光纤的可互换适配头。
低电量指示。
可单手操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71c0b6d3ba613d1df20cee0401dfa645/" rel="bookmark">
			Redis的底层数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Redis的五种数据类型及七种底层结构 键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合
对于Redis来讲，对于键值对来说，键总是字符串，值就是五个中的一个，所以我们只用关心值的类型。**值有五种数据类型**
String Hash List Set ZSet
​​​​​​​
​​​​​​​
1、Redis的底层数据结构 Redis底层数据结构有⑦种：
1、简单动态字符串
2、链表
3、字典
4、跳跃表
5、整数集合
6、压缩列表
7、快速列表
2、Redis的底层数据结构 Redis底层数据结构之hash - 凡尘多遗梦 - 博客园讲的挺详细的
1、简单动态字符串（SDS） （1）Redis默认字符串底层存储结构，比如set k1 v1，键k1是一个字符串，底层实现是保存着字符串k1的SDS，值v1也是一个字符串，底层实现是保存着字符串v1的SDS
（2）每个sds.h/sdshdr表示一个SDS，结构如下
struct sdshdr { //记录buf数组中已使用字节的数量，相当于保存的字符串的长度 int len; //记录buf数组中未使用的字节数量 int free; //字节数组，用于保存字符串 char buf[]; } 底层是一个SDS，核心是字节数组 char buf[];注意是字节数组，因为Redis会使用SDS API以处理二进制的方式来处理SDS存在buf数组里的数据。
（3）优点：
1&gt;获取字符串长度的复杂度为O(1)。
C字符串不记录自身长度，获取C字符串长度时必须遍历整个字符串计数得到，复杂度是O(N)；
SDS字符串自身记录维护len长度属性，获得SDS字符串长度的复杂度是O(1)；
2&gt;杜绝缓存区溢出。因为其API会进行空间扩展，扩展之后未使用字节数量free和已使用字节数量len一样
和重分配的区别是：这是在修改之前，预先判断内存空间是否够用，不够用则进行拓展
C字符串不记录长度，由于两个C字符串在内存存储上紧邻，在执行字符串拼接strcat时，如果不提前分配足够空间，很可能发生修改s1的数据溢出到s2所在的空间中；（缓冲区溢出） SDS完全杜绝了缓冲区溢出问题，它记录了长度，当修改SDS字符串之前，API都会检查SDS的空间是否满足修改的要求，不满足API会自动进行空间扩展。
3&gt;减少字符串修改时的内存重分配次数，因为有free（预分配），所有在最坏的情况下就是修改n次，重分配n次。
在修改之后，进行预分配（len&lt;1mB,free=len,大于1MB，free=1MB）
C字符串每次修改增加或减少时，都会对保存这个C字符串的数组进行一次内存重分配； 拼接操作，在执行之前，程序需要先通过内存重分配来扩展底层数组的空间大小——如果忘了这一步就会产生缓冲区溢出。 截断操作，在执行之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间——如果忘了这一步就会产生内存泄漏。 内存重分配算法复杂还需要执行系统调用，如果发生频繁修改可能对性能造成影响。
SDS通过free未使用空间，实现了空间预分配和惰性空间释放两种优化策略。 空间预分配 空间预分配：增长操作时，Redis可以减少连续执行字符串增长操作所需的内存重分配次数； 当SDS做增长操作，不仅会分配修改所必须要的空间，还会额外分配未使用空间，具体分配未使用空间如下2种方式： 一：如修改后长度len小于1MB，就分配和len属性相同大小的未使用空间；free=len; 二：如修改后长度len大于等于1MB，就分配1MD的未使用空间；free=1MB;
4、二进制安全。
C字符串的字符必须符合某种编码，除结尾空字符以外，字符串内部不允许有空字符串。存储有局限性； SDS存储的都是二进制安全的字符串，SDS API都会以处理二进制的方式来处理SDS存在buf数组里的数据。（这也是SDS的buf称之为字节数组的原因因——Redis不是用这个数组来保存字符，而是用它来保存一系列二进制数据）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71c0b6d3ba613d1df20cee0401dfa645/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/545d6f500a831b2369b74fa2e8d5c373/" rel="bookmark">
			Matplotlib 基础入门知识点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、绘图的一些基本命令展示
2、Matplotlib 绘制网格
3、plt.gca() 对坐标轴的操作
4、 图表的样式参数设计
5、创建图形对象
6、绘制多子图
1.add_axes()：添加区域
2. subplot()函数，可以均等的划分画布
3.subplots()函数详解
7、柱形图的绘制
1. 基本柱状图
2.同位置多柱状图
3.堆叠柱状图绘制
4.水平柱状图
5.水平堆叠柱状图
6.水平同位置柱状图
8、直方图 plt.hist()
9、饼状图
10、散点图
1、绘图的一些基本命令展示 # 导入 Pyplot 模块 from matplotlib import pyplot as plt # 导入 numpy 包 import numpy as np # 获得 -5 到 5 之间的 ndarray 对象 x = np.arange(-5, 5) x1 = ['2010年','2011年','2012年','2013年','2014年','2015年','2016年','2017年','2018年','2019年'] # print(x) y = x**2 y1 = 3*x # 使用 plot() 绘制线性图标 plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/545d6f500a831b2369b74fa2e8d5c373/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baca204ee9231a870abbe6628798ed9b/" rel="bookmark">
			[转][001] [STM32] 如何下载STM32原厂资料
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32
官网下载
通过STM32CubeMX下载
总结
本文为百问网&amp;韦东山【物联网智能家居实战训练营】课程笔记
1 官网下载 ST官网： https://www.st.com/
直接在搜索框输入使用的芯片型号，如stm32f103c8t6：
然后点击该芯片，进入详情页：
在详情页中有如下主题：
Overview：芯片总体描述，包括电气属性、芯片外设资源等信息
Sample &amp; Buy：ST官方样板购买
Documentation：该产品的所有文档手册，下面对相对比较重要部分进行说明：
Product Specifications(产品规格)：即数据手册，包含该系列MCU的整体描述、引脚描述、内存映射、电气特性、封装信息、订购信息等。在芯片选型、原理图设计、PCB设计、代码编程等开发环节，都会需要该文档；Reference Manuals(参考手册)：包含该系列MCU各外设寄存器的详细描述，在代码编程时，需要找到对应外设章节，仔细阅读；Programming Manuals(编程手册)：包含闪存编程手册和Cortex-M3内核编程手册，一些资源是在内核里的，比如NVIC和SysTick，此时在参考手册里找不到相关寄存器信息，就需要在Cortex-M3内核编程手册里查找；Errata Sheets（勘误手册）：包含该MCU内核、外设资源的限制，解决方案等，在调试中出现了bug，可以看看该手册是否有类似记录。 CAD Resources：EDA 符号、封装和 3D 模型，一般设计PCB的时候需要用到。
Tools &amp; Software：可以看到该产品的所有工具软件，比如各种硬件开发工具、软件开发工具、元件模块、评估工具软件、MCU/MPU嵌入式软件、产品评估工具、解决方案评估工具、工程服务、培训课程等。
Hardware Development Tools：ST-LINK仿真下文件等Software Development Tools：可以下载Keil MDK 与 STM32Cube开发工具。MCU &amp; MPU Embedded Software：可以下载的STM32Cube工具的固件包。
如示例芯片固件包目录如下：
Documentation：里面是本固件包的详细说明文档；Drivers： BSP：板级支持包（Board Support Package），适配ST原厂的几个公板；CMSIS: Cortex微控制器软件接口标准（Cortex Microcontroller Software Interface Standard），包含STM32F1符合CMSIS标准的软件抽象层相关文件（内核寄存器定义、启动文件等）；STM32F1xx_HAL_Driver：ST提供的HAL库驱动，方便快速编写程序； Middlewares： ST：ST提供的图形GUI库“STemWin”、USB从设备库“STM32_USB_Device_Library”、USB主设备库“STM32_USB_Host_Library”；Third_Party：第三方提供的文件系统库“FatFs”、实时性操作系统“FreeRTOS”、网络协议栈“LwIP”; Projects：以ST原厂公板为载体，提供的外设应用示例，比如GPIO、UART、ADC、RTC等；Utilities：一些字体、日志、多媒体等杂项示例。 此外，如果想直接搜索手册，可以选择Resources，输入手册名字，如STM32F10xx Cortex-M3编程手册：
F1系列HAL库开发手册：
其中PM0056和UM1850为手册编号索引，也可以通过它来搜索。
2 通过STM32CubeMX下载 打开软件，点击help：
选择Docs &amp; Resources：
3 总结 MCU开发资料可以直接在芯片厂商官网下载，如数据手册、参考手册、芯片封装等资料；原厂提供的资料比较多，按需求阅读学习即可，搜索关键词定位到相应章节。 END
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/baca204ee9231a870abbe6628798ed9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9008745754b4d85d41edb58536c55009/" rel="bookmark">
			【测试用例设计】黑盒测试方法论-场景法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景法 模拟用户操作软件时的场景，主要用于测试系统的业务流程。
用例场景定义 基本流：按照正确的业务流程来实现的一条操作路径
备选流：导致程序出现错误的操作流程
场景法用例设计步骤 根据需求规格说明，画出功能模块流程图
根据流程图，描述程序的基本流和备选流
根据基本流备选流，生成不同场景，构造场景列表
每个场景生成相应的测试用例
对生成的测试用例重新复审，去掉多余用例
为每个测试用例确定测试数值
场景法优缺点 优点：适合业务流程的分析与测试，对整体的业务场景有较好的测试效果。
缺点 ：缺少对单个功能项的验证。需要与等价类、判定表等方法结合使用。
案例 淘宝网购物流程
1.根据需求规格说明，画出功能模块流程图 2.根据流程图，确定基本流和备选流 基本流
进入淘宝网→不需要注册→浏览物品→选择物品购买→直接购买→是会员→填写验证码→付款到支付宝→等待收货→确认收货
备选流
备选流1：需要注册→填写注册信息→验证通过，返回基本流浏览物品步骤。
备选流2：需要注册→填写注册信息→验证未通过→重新填写注册信息→验证通过，最终返回基本流浏览物品步骤。
备选流3：加入购物车→不再选购，返回基本流购买商品步骤。
备选流4：加入购物车→继续选购→加入购物车→继续选购→加入购物车→不再选购，最终返回基本流购买商品步骤。
备选流5：不是会员→填写注册信息→验证通过，返回基本流付款验证步骤。
备选流6：不是会员→填写注册信息→未通过验证→填写注册信息→验证通过，最终返回基本流付款验证步骤。
3.根据基本流备选流，构造场景 场景1：进入淘宝后已经是会员，直接选购商品进行付款，成功购物。（基本流）
场景2：进入淘宝后没有进行注册，先注册账号，之后再选购商品。（基本流+备选流1）
场景3：进入淘宝后没有进行注册，先注册账号，注册中出现验证错误，重新注册完成后，再选购商品。（基本流+备选流2）
场景4：选购商品后，没有直接购买，而是添加购物车，通过购物车付款。（基本流+备选流3）
场景5：选购商品后，添加购物车，继续选购，添加购物车，继续选购，之后通过购物车付款。（基本流+备选流4）
场景6：准备购买商品时，发现不是会员，需要进行注册，之后再进行付款验证。（基本流+备选流5）
场景6：准备购买商品时，发现不是会员，需要进行注册，注册中出现验证错误，重新注册完成后，再进行付款验证。（基本流+备选流6）
4.每个场景生成相应的测试用例 用例编号
测试点
测试步骤
预期结果
1
淘宝网站成功购物
前提：已登陆
1.进入淘宝网
2.浏览物品
3.选择物品购买
4.直接购买
5.付款验证
6.付款到支付宝
7.等待收货
8.确认收货
确认收货成功，订单完成
2
未注册淘宝账号，进入网页后先注册账号
前提：未注册
1.进入淘宝网
2.选择注册
3.填写注册信息
显示注册完成，账号为已登录状态。
3
未注册淘宝账号，进入网页后先注册账号，注册中发现错误
前提：未注册
1.进入淘宝网
2.选择注册
3.填写注册信息
显示注册错误信息，注册未完成，返回注册页面，重新注册。
4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9008745754b4d85d41edb58536c55009/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11a5c98c2c2624fd6aff3e4c6edec109/" rel="bookmark">
			【C语言】操作符大全万字详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天已成为历史，明天是未知的，而今天是上天赐予我们的礼物，这就是为什么我们把它叫做现在！——《功夫熊猫》
目录
1、操作符的分类
2、算术操作符
2.1+、-、*（加减除）
2.2 /、%（除取余）
3、移位操作符
3.1原码反码补码
3.2&lt;&lt;（左移操作符）
3.3&gt;&gt;（右移操作符）
4、位操作符
4.1&amp; （按位与）
4.2 |（按位或）
4.3 ^ （按位异或）
5、赋值操作符
6、单目操作符
6.1！（逻辑反操作）
6.2-（负值）、+（正值）
6.3&amp;（取地址）
6.4sizeof（取字节操作符）
6.5~（二进制位取反）
6.6--、++（前后置--、++）
6.7*（间接访问操作符、解引用操作符）
6.8sizeof和数组
7、关系操作符
8、逻辑操作符
8.1&amp;&amp;、||（逻辑与逻辑或）
9、条件操作符
9.1？：三目操作符
10、逗号表达式
11、下标引用、函数调用和结构成员
11.1[]下标引用操作符
11.2()函数调用操作符
11.3.、-&gt;结构体访问操作符
12、表达式求值
12.1一些有问题的表达式
12.2操作符优先级表格
前言： 大家好我是拳击哥，今天我给大家展现是C语言中各种各样的操作符。操作符是说明特定操作的符号，它是构造C语言表达式的工具，下面我就来介绍它们的详细用法，并且目录12.2中有从高到低的操作符优先级表格供大家参考。
1、操作符的分类 操作符分为：
算术操作符移位操作符位操作符赋值操作符单目操作符关系操作符逻辑操作符条件操作符逗号表达式下标引用、函数调用和结构成员 2、算术操作符 算术操作符有：+（加）、-（减）、*（乘）、/（除）、%（取余、取模）
2.1+、-、*（加减除） +、-、*（加减除）跟我们数学中的意思是一致的，我们来看一组代码:
#include&lt;stdio.h&gt; int main() { int a = 5; int b = 5; int c = 0; c = a + b; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11a5c98c2c2624fd6aff3e4c6edec109/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/850f1fa31e7ec52c3b0cdeeae012249d/" rel="bookmark">
			如何使用Python读取超大文本文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python是一种开放源代码的动态类型化和解释型编程语言。读取和写入文件是编程的组成部分。在Python中, 使用readlines()方法。 readlines()方法返回一个列表, 其中列表的每个项目都是文件中的完整句子。当文件较小时, 此方法很有用。由于readlines()方法将每行追加到列表中, 然后返回整个列表, 因此如果文件的大小非常大(以GB为单位), 则将非常耗时。同样, 该列表将占用大量内存, 如果没有足够的内存, 则可能导致内存泄漏。为避免此问题, 我们可以使用文件对象作为迭代器来迭代文件并执行所需的任务。由于迭代器仅迭代整个文件, 并且不需要任何其他数据结构来存储数据, 因此消耗的内存相对较少。而且, 迭代器不会执行像追加这样的昂贵操作, 因此它也是省时的。文件在Python中是可迭代的, 因此建议使用迭代器。
以下两个程序演示了如何使用Python读取大型文本文件。
方法1：
第一种方法利用迭代器遍历文件。在这项技术中, 我们使用文件输入Python中的模块。 fileinput模块的input()方法可用于读取文件。与readlines()相比, 使用此方法的优点是fileinput.input()不会将整个文件加载到内存中。因此, 不存在内存泄漏的机会。 fileinput.input()方法采用文件名列表, 如果未传递任何参数, 它将接受来自stdin的输入。该方法返回一个迭代器, 该迭代器从要扫描的文本文件返回单独的行。
代码实现：
# import module import fileinput import time #time at the start of program is noted start = time.time() #keeps a track of number of lines in the file count = 0 for lines in fileinput. input ([ 'sample.txt' ]): print (lines) count = count + 1 #time at the end of program execution is noted end = time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/850f1fa31e7ec52c3b0cdeeae012249d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e00ba8a618b505b6b175834911e5284/" rel="bookmark">
			ULN2003步进电机驱动电路详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一.ULN2003芯片介绍 ULN2003 是高耐压、大电流达林顿陈列，由七个硅 NPN 达林顿管组成。该电路的特点如下：
ULN2003 的每一对达林顿都串联一个 2.7K 的基极电阻,在 5V 的工作电压下它能与 TTL 和 CMOS 电路直接相连，可以直接处理原先需要标准逻辑缓冲器来处理的数据。
ULN2003 工作电压高，工作电流大，灌电流可达 500mA，并且能够在关态时承受 50V 的电压，输出还可以在高负载电流并行运行。
ULN2003 采用 DIP-16 或 SOP-16 塑料封装。
ULN2003内部电路框图及封装图
主要作用：ULN2003的主要作用就是为单片机提供大电流的驱动能力，以此达到驱动步进电机所需的电流。
二.28BYJ-48五线四相电机介绍 28BYJ-48步进电机为五线四相永磁式步进电机，其名称含义为：“28”为电机直径28mm，B为步进电机，Y表示电机为永磁式，J表示内部自带减速箱，48表示驱动方式为四相八拍；
（1）28BYJ-48步进电机参数
对于初学者，对于以上参数，可以先注意以上几个主要参数：工作电压为DC5-12V；步距角为5.625°，即电机转一圈需要的步数=360/5.625*64=4096步，驱动方式为四相四拍或四相八拍。
（2）28BYJ-48步进电机电路图
从电路图可以看出，五线四相表示电机有4个线圈，5根接线端子，其中引脚5为公共端。
三.ULN2003步进电机驱动模块
（1）驱动模块电路图如下：
其中IN1-4引脚为ULN2003的控制端，主要连接单片机引脚，高电平导通，低电平截止；OUT1-4为ULN2003的驱动端，主要连接步进电机4个相线。LED1-4为指示作用，ULN2003通道导通时亮，截止时灭。
VCC主要为ULN2003内部续流二极管的公共端，VM为步进电机的驱动电压；VCC与VM的工作电压需保持一直。
ULN2003模块与电机实物图
（2）单片机与驱动模块连接图
ULN2003与单片机、步进电机电路连接图，步进电机以5V为工作电压。
四.驱动程序 步进电机的驱动方式主要为四相四拍或四相八拍；
四相四拍为步进电机的导通顺序为：
（1）正转：A-B-C-D；
（2）反转：D-C-B-A；
四相八拍为步进电机的导通顺序为：
（3）正转：AD-A-AB-B-CB-C-DC-D；
（4）反转：D-DC-C-CB-B-BA-A-AD；
程序以四相四拍为例：
******************************************************* 接线方式: IN1 ---- P00 IN2 ---- P01 IN3 ---- P02 IN4 ---- P03 *********************/ #include&lt;reg52.h&gt; #define uchar unsigned char #define uint unsigned int #define MotorData P0 //步进电机控制接口定义 uchar phasecw[4] ={0x08,0x04,0x02,0x01};//正转 电机导通相序 D-C-B-A uchar phaseccw[4]={0x01,0x02,0x04,0x08};//反转 电机导通相序 A-B-C-D //ms延时函数 void Delay_xms(uint x) { uint i,j; for(i=0;i&lt;x;i++) for(j=0;j&lt;112;j++); } //顺时针转动 void MotorCW(void) { uchar i; for(i=0;i&lt;4;i++) { MotorData=phasecw[i]; Delay_xms(4);//转速调节 } } //逆时针转动 void MotorCCW(void) { uchar i; for(i=0;i&lt;4;i++) { MotorData=phaseccw[i]; Delay_xms(4);//转速调节 } } //停止转动 void MotorStop(void) { MotorData=0x00; } //主函数 void main(void) { uint i; Delay_xms(50);//等待系统稳定 while(1) { for(i=0;i&lt;500;i++) { MotorCW(); //顺时针转动 } MotorStop(); //停止转动 Delay_xms(500); for(i=0;i&lt;500;i++) { MotorCCW(); //逆时针转动 } MotorStop(); //停止转动 Delay_xms(500); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37398417cd157fa94a421e20bdbd04b9/" rel="bookmark">
			【算法刷题】1 Python基础篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1 输入圆的半径r，输出其周长和面积 import math from math import pi class circle(object): def __init__(self, r): self.r = r self.__d = 2 * r # 私有对象，外部无法访问 self.__s = pi * r ** 2 self.__c = 2 * pi * r def get_square(self): # area return self.__s def get_perimeter(self): return self.__c while(1): x = eval(input("请输入圆的半径：")) if not x: break c = circle(x) print(f"圆的面积为：{c.get_square()}") print(f"圆的周长为：{c.get_perimeter()}") 请输入圆的半径：5 圆的面积为：78.53981633974483 圆的周长为：31.41592653589793 请输入圆的半径：5 圆的面积为：78.53981633974483 圆的周长为：31.41592653589793 请输入圆的半径：2 圆的面积为：12.566370614359172 圆的周长为：12.566370614359172 请输入圆的半径：3 圆的面积为：28.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37398417cd157fa94a421e20bdbd04b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b35319a5b657365f7a56f1010dc1b42c/" rel="bookmark">
			jar 包与 war 包区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：
https://www.jianshu.com/p/3b5c45e8e5bdhttps://www.cnblogs.com/banml/p/11767305.htmlhttps://blog.csdn.net/cjw12581/article/details/107463971 文章目录 1. jar 包jar 与 zip 异同jar 包主要用途 2. war 包war 包部署优势开发阶段不适合使用 war 的原因部署 war 包到 tomcat 3. jar 包 vs. war 包SpringBoot 打包方式区别SpringBoot 适宜打成 war 包的场景 1. jar 包 JAR（Java Archive），是与平台无关的文件格式。它允许将多个文件组合成要给压缩文件。
其实可以对比一下：jar 与 rar ，j 可以理解成 java。
jar 包其实就是 java 项目压缩包，是通过 java 程序压缩产生的压缩包。jar 包是通过 JavaSE 程序打成的包。
jar 与 zip 异同 jar 文件格式以流行的 zip 文件格式为基础。
同：jar、zip 用于压缩和发布异：jar 还用于 部署封装库、组件、插件程序可被编译器、jvm 等工具直接使用 另外 jar 包还含有特殊的文件，如 manifest 和部署描述符，用来指示工具如何处理特定的 jar。
jar 包目录结构如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b35319a5b657365f7a56f1010dc1b42c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83899130d6e3532bc900ff22e72da2bd/" rel="bookmark">
			三次握手时，客户端发送的 SYN 报文为什么会被丢弃？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		楔子 我们知道当客户端和服务端建立连接时，会进行三次握手。客户端先向服务端发送 SYN 报文，表示想要建立连接，这是第一次握手；然后服务端收到 SYN 之后会给客户端回复 SYN + ACK，表示同意建立连接，也就是第二次握手。
但如果第二次握手的时候，服务端没有回复，那么说明客户端发送的 SYN 报文被服务端忽略了。
​然后客户端在规定时间内，因收不到服务端的反馈就会触发超时，于是重传 SYN 报文，直到达到最大的重传次数。以上便是 SYN 报文被丢弃的过程，但问题是它为什么会被丢弃呢？主要有以下原因：
开启 tcp_tw_recycle 参数，并且处于 NAT 环境下；Accpet 队列满了；SYN 队列满了； 下面来解释一下。
tcp_tw_recycle 参数 TCP 四次挥手过程中，主动断开连接方会有一个 TIME_WAIT 状态，这个状态会持续 2 MSL 后才转变为 CLOSED 状态。
在 Linux 操作系统下，TIME_WAIT 状态的持续时间是 60 秒，你可以通过修改 Linux 源代码来改变这个值，但不推荐。
因此在 60 秒内，端口会一直被客户端占用。而端口资源是有限的，一般可开启的端口为 32768 ~ 60999。
当然你也可以修改这两个值，但总之如果主动断开连接方的 TIME_WAIT 状态过多，占满了所有端口资源，则会导致无法创建新连接。问题来了，既然 TIME_WAIT 有缺陷，那为什么还要保留这个特性呢？不用想，肯定是有着其它作用，而作用有两个：
防止旧的连接数据包；保证连接正确关闭； 我们分别解释。
原因一：防止旧的连接数据包
假设 TIME-WAIT 没有等待时间或时间过短，被延迟的数据包抵达后会发生什么呢？
如上图黄色框框显示的那样，服务端在关闭连接之前发送的 Seq = 301 报文，被网络延迟了。这时有相同端口的 TCP 连接被复用后，被延迟的 Seq = 301 抵达了客户端，那么客户端有可能正常接收这个过期的报文，这就会产生数据错乱等严重的问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83899130d6e3532bc900ff22e72da2bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5020593dce9ddf0e404964e46128be9c/" rel="bookmark">
			变异检测准确性评估软件hap.py使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		变异检测准确性评估软件hap.py使用 1. hap.py简介 Hap.py 是illumina官方开发的在单倍型水平上比较二倍体基因型的工具。可用于针对金标准变异数据集（例如NA12878样本）对检测的变异结果进行基准测试，以判断检测结果的准确性， 也可以用于比较和评估两个不同变异检测软件检测结果的差异。
2. hap.py 的使用 安装就不多说了，怕麻烦的同学建议直接使用docker镜像，省时省力。docker pull pkrusche/hap.py
下面直接上基本使用命令行吧。
hap.py hap.py/example/happy/PG_NA12878_hg38-chr21.vcf.gz \ hap.py/example/happy/NA12878-GATK3-chr21.vcf.gz \ -f hap.py/example/happy/PG_Conf_hg38-chr21.bed.gz \ -r hap.py/example/happy/hg38.chr21.fa \ --threads 5 \ -o gatk-all 其中，
-r hap.py/example/happy/hg38.chr21.fa 用于指定使用的参考序列。 也可以通过设置环境变量HGREF来指定export HGREF=hap.py/example/happy/hg38.chr21.fa ， 其中hap.py/example/happy/hg38.chr21.fa 需要换成你实际使用的fasta序列hap.py/example/happy/PG_NA12878_hg38-chr21.vcf.gz 和 hap.py/example/happy/NA12878-GATK3-chr21.vcf.gz 为待比较的两个VCF文件，替换为你实际VCF文件即可。 -f hap.py/example/happy/PG_Conf_hg38-chr21.bed.gz 指定需要比较的区间，即只有该bed区间内的位点用于比较。--threads 5 指定线程-o out_prefix 指定输出文件前缀 3. 结果说明 结果包含以下几个文件：
Output FileContentsgatk-all.summary.csvSummary statisticsgatk-all.extended.csvExtended statisticsgatk-all.roc.all.csvAll precision / recall data points that were calculatedgatk-all.vcf.gzAnnotated VCF according to https://github.com/ga4gh/benchmarking-tools/tree/master/doc/ref-implgatk-all.vcf.gz.tbiVCF Tabix Indexgatk-all.metrics.jsonJSON file containing all computed metrics and tables.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5020593dce9ddf0e404964e46128be9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58f8969d8744f8eef36215f082f26756/" rel="bookmark">
			Centos7 安装Redis详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要介绍如果在Centos7下安装Redis。
1、安装依赖环境 redis是由C语言开发，因此安装之前必须要确保服务器已经安装了gcc，可以通过如下命令查看机器是否安装：
gcc -v 如果没有安装则通过以下命令安装：
yum install -y gcc 2、下载redis安装包并解压 官网下载地址：Download | Redis
# 下载redis压缩包，这儿下载的6.2.6版本 wget https://download.redis.io/releases/redis-6.2.6.tar.gz # 解压压缩包 tar -zxvf redis-6.2.6.tar.gz 3、进入解压目录并编译 # 进入解压目录 cd redis-6.2.6 # 编译 make 4、指定安装目录并进行安装 sudo make install PREFIX=/usr/local/redis 5、启动redis服务 5.1 直接启动（不建议启动） # 进入redis安装目录 cd /usr/local/redis/bin/ # 启动服务 ./redis-server 5.2 通过守护进程方式启动 # 第一步：从 redis 的源码目录中复制 redis.conf 到 redis 的安装目录 cp /home/keepmoving/redis-6.2.6/redis.conf /usr/local/redis/bin/ # 第二步：修改redis.conf配置文件 cd /usr/local/redis/bin/ vi redis.conf # 修改内容如下： #daemonize 的值从 no 修改成 yes # 第三步：启动服务 注意：这种启动方式Ctrl+C不会终止程序，后台一直运行 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58f8969d8744f8eef36215f082f26756/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba98ccae53eb6c55728b0b500ba3b77b/" rel="bookmark">
			第六章 聚合函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 聚合函数介绍 什么是聚合函数
聚合函数作用于一组数据，并对一组数据返回一个值。
聚合函数类型
AVG()
SUM()
MAX()
MIN()
COUNT()聚合函数语法
1.1 AVG和SUM函数 可以对数值型数据使用AVG 和 SUM 函数。
SELECT AVG(salary), MAX(salary),MIN(salary), SUM(salary) FROM employees WHERE job_id LIKE '%REP%'; 1.2 MIN和MAX函数 可以对任意数据类型的数据使用 MIN 和 MAX 函数。
SELECT MIN(hire_date), MAX(hire_date) FROM employees; 1.3 COUNT函数 COUNT(*)返回表中记录总数，适用于任意数据类型。 SELECT COUNT(*) FROM employees WHERE department_id = 50; COUNT(expr) 返回expr不为空的记录总数。 SELECT COUNT(commission_pct) FROM employees WHERE department_id = 50; 问题：用count()，count(1)，count(列名)谁好呢?其实，对于MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。Innodb引擎的表用count(),count(1)直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但好于具体的count(列名)。问题：能不能使用count(列名)替换count()?
不要使用 count(列名)来替代 count() ，count() 是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。说明：count()会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba98ccae53eb6c55728b0b500ba3b77b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/935f5fd6d1659f8e0da37a89b04f6285/" rel="bookmark">
			基于Redis的 Jwt Token续期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后端拦截器代码
/** * @author crlion */ @Component public class AuthInterceptor implements HandlerInterceptor { @Resource private RedisOperator redisOperator; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws IOException { //判断请求方式，通过所有OPTION请求 if ("OPTIONS".equals(request.getMethod().toUpperCase())) { return true; } System.err.println("==================进入拦截器了=================="); String url = request.getRequestURL().toString(); String token = request.getHeader("Authorization"); System.err.println("url:" + url + " token:" + token); if (JwtUtils.checkToken(request)) { System.err.println("无效Token!"); response.setContentType("application/json"); response.setCharacterEncoding("UTF-8"); ResultList result = new ResultList(new Meta(Code.Auth_ERR, "无效Token!"), null); response.getWriter().println(JSON.toJSONString(result)); response.getWriter().flush(); return false; } else if (redisOperator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/935f5fd6d1659f8e0da37a89b04f6285/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ff4fb21693e5a3e5192a26e7246383a/" rel="bookmark">
			Pandas基础入门知识点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、pandas 常用类
1.1 Series
1.1.1创建 Series
1.1.2 访问 Series 数据
1.1.3 更新、插入和删除
1.2 DataFrame
1.2.1 创建 DataFrame
1.2.2 访问DataFrame首尾数据
1.2.3 更新、插入和删除（列操作）
1.3 Index
1.3.1 创建 Index
1.3.2 常用方法
2、DataFrame 基础操作
2.1 索引
2.1.1 基础化索引
2.1.2 loc 方法和 iloc方法（行、列操作）
2.1.3 行追加append
2.1.4 删除数据行
2.1.5 MultiIndex
2.2 排序
2.2.1 sort_index 方法
2.2.2 sort_values 方法
2.3 合并
2.3.1 堆叠合并
3、时间数据
3.1 Python 模块time
3.1.1 time模块
3.1.2 datetime 模块
3.1.3 timedelta 类，时间加减
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ff4fb21693e5a3e5192a26e7246383a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aa3666597195b94af7d206a58f34dcd/" rel="bookmark">
			蓝桥杯单片机备战（七）矩阵键盘的扫描原理及其应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.扫描原理 1.首先还是先观察电路图 我们知道要想控制独立按键的话首先要先使J5跳帽连接到1和2,这时P44和第一列键盘也就是S4~S7连上了
2.那要怎么来实现按键状态的读取呢？我们使用扫描的思想，也就是逐行逐列读取 这里我们选择逐行读取，先读取第一行（也就是S7、S11、S15、S19），先将P30口置低，P31P32P33置高，然后将代表四列的P34P35P42P44置高，此时检测P34P35P42P44口，如果P44是低电平，那么证明S7被按下了，如果P42是低电平，证明S11被按下了，以此类推就检测了所有的按键。
2.代码实现 注意事项！！！！
我们导入的头文件“reg52.h”中并没有对于P4口的定义
我们需要自行查找数据手册来得知P4口寄存器的地址
查找手册得知P4口的地址为C0H，我们需要在头文件或者用户编写的文件中添加这个定义：
这里再补充一个点：“sfr”
SFR全称为：special function register（翻译为：特殊功能寄存器）
在单片机的世界里，并不会识别所谓的“P1”，只会识别P1这个IO口的地址0x90，sfr是用来给这个地址赋予一个名字的，sfr P1 = 0x90，代表的意思就是给地址0x90赋予一个名字P1（有点类似与sbit、define这种东西，有机会会再写一篇笔记来充分认识51单片机bit、sbin、sfr、sfr_16的区别。
#include "reg52.h" sbit R1 = P3^0;//第一行的P3^0口为R1,下面以此类推 sbit R2 = P3^1; sbit R3 = P3^2; sbit R4 = P3^3; sbit C1 = P4^4; sbit C2 = P4^2; sbit C3 = P3^5; sbit C4 = P3^4; unsigned char KEY_number = 0;//按键按下标志位 void Delay(unsigned char t)	//延时函数 { while(t--) { unsigned char i, j; i = 15; j = 90; do { while (--j); } while (--i); } } unsigned char code SMG_duanma[18] = {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80, 0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e,0xbf,0x7f}; // 数码管的断码表 void HC138Init(unsigned char n) { switch(n) { case 4: P2 = (P2 &amp; 0x1f) | 0x80;//让Y4输出低电平,此时Y4C为高电平 break; case 5: P2 = (P2 &amp; 0x1f) | 0xa0;//让Y5输出低电平,此时Y5C为高电平 break; case 6: P2 = (P2 &amp; 0x1f) | 0xc0;//让Y6输出低电平,此时Y6C为高电平 break; case 7: P2 = (P2 &amp; 0x1f) | 0xe0;//让Y7输出低电平,此时Y7C为高电平 break; } } void showSMG(unsigned char position,unsigned char number) //字符显示函数 { HC138Init(6); // 选通Y6C switch(position) { case 1://第1个位置 P0 = 0x01; break; case 2://第2个位置 P0 = 0x02; break; case 3://第3个位置 P0 = 0x04; break; case 4://第4个位置 P0 = 0x08; break; case 5://第5个位置 P0 = 0x10; break; case 6://第6个位置 P0 = 0x20; break; case 7://第7个位置 P0 = 0x40; break; case 8://第8个位置 P0 = 0x80; break; } HC138Init(7); // 选通Y7C if(number == '0') //下面是显示各个字符 P0 = SMG_duanma[0]; else if(number == '1') P0 = SMG_duanma[1]; else if(number == '2') P0 = SMG_duanma[2]; else if(number == '3') P0 = SMG_duanma[3]; else if(number == '4') P0 = SMG_duanma[4]; else if(number == '5') P0 = SMG_duanma[5]; else if(number == '6') P0 = SMG_duanma[6]; else if(number == '7') P0 = SMG_duanma[7]; else if(number == '8') P0 = SMG_duanma[8]; else if(number == '9') P0 = SMG_duanma[9]; else if(number == 'a') P0 = SMG_duanma[10]; else if(number == 'b') P0 = SMG_duanma[11]; else if(number == 'c') P0 = SMG_duanma[12]; else if(number == 'd') P0 = SMG_duanma[13]; else if(number == 'e') P0 = SMG_duanma[14]; else if(number == 'f') P0 = SMG_duanma[15]; else if(number == '-') P0 = SMG_duanma[16]; else if(number == '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3aa3666597195b94af7d206a58f34dcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a419f25f1db0b97b4e6104122b3c3f70/" rel="bookmark">
			Linux用户分类和权限详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux用户分类和权限详解 文章目录 ` Linux用户分类和权限详解`一、用户种类linux系统中用户分为三类:UID和GID 1）/etc/passwd 2）/etc/shadow 3）/etc/group 4）/etc/gshadow 二、文件权限 1.文件访问用户分类 2.文件访问权限 3.文件权限修改 chmod命令 chown命令 chgrp命令 umask命令 三、目录的权限总结 一、用户种类 linux系统中用户分为三类: root超级用户：root(超级管理员)，UID为0，这个用户有极大的权限，可以直接无视很多的限制，包括读写执行的权限ftp系统用户：系统用户，UID为1～499。一般是不会被登入的,系统中系统服务由不同用户运行，更加安全，默认被限制登录系统。test普通用户：普通用户，UID范围一般是500～65534。这类用户的权限会受到基本权限的限制，也会受到来自管理员的限制。不过要注意nobody这个特殊的帐号，UID为65534，这个用户的权限会进一步的受到限制，一般用于实现来宾帐号。 UID和GID UID，也就是用户 ID。每个用户都有唯一的一个 UID，Linux 系统通过 UID 来识别不同的用户。一般默认root用户UID是0。实际上，UID 就是一个 0~65535 之间的数，不同范围的数字表示不同的用户身份，具体如表所示： 且需要注意：
GID，全称“Group ID”，简称“组ID”，表示用户初始组的组 ID 号。GID 是用户组的编号，可以将多个用户加入到某个组中，方便指派任务或工作。每个用户在被创建时均会创建一个默认组（其GID与UID相同，叫作基本组或初始组），而后加入的组叫作扩展组或附加组。用户组名和GID则保存在 /etc/group 文件中。并且在 /etc/passwd 文件的第四个字段中看到的 ID 是这个用户的初始组。 初始组，指用户登陆时就拥有这个用户组的相关权限。每个用户的初始组只能有一个，通常就是将和此用户的用户名相同的组名作为该用户的初始组。
附加组，指用户可以加入多个其他的用户组，并拥有这些组的权限。每个用户只能有一个初始组，除初始组外，用户再加入其他的用户组，这些用户组就是这个用户的附加组。附加组可以有多个，而且用户可以有这些附加组的权限。
小结：linux下用户的ID分为两类：UID和GID。每个文件都有自己的拥有者 ID 和群组 ID，当显示文件属性时，系统会根据 /etc/passwd 和 /etc/group 文件中的内容，分别找到 UID 和 GID 对应的用户名和群组名，然后显示出来。
1）/etc/passwd 首先我们来看一下这个文件目录下保存了什么东西，效果如图：
当然这里只是截图了一部分。那么看到这里你可能会蒙蔽，这么多用户哪来的。那么这里可以告诉你这些用户中的绝大多数是系统或服务正常运行所必需的用户，这种用户通常称为 系统用户或伪用户系统用户无法用来登录系统，但也不能删除，因为一旦删除，依赖这些用户运行的服务或程序就不能正常执行，会导致系统问题。
且每行用户信息都以 “：” 作为分隔符，划分为 7 个字段，每个字段所表示的含义如下： 用户名：密码：UID（用户ID）：GID（组ID）：描述性信息：主目录：默认Shell
首先用户名，没啥好说的，就是代表用户的一段字符串，但是系统识别用户是用过UID来识别并且去分配权限，而/etc/passwd文件中就说明了用户名和UID的关系密码的话，“x” 表示此用户设有密码，但不是真正的密码，真正的密码保存在 /etc/shadow 文件中。其次就是该文件是系统用户配置文件，所有的用户都具有可读权限 2）/etc/shadow 用于存储 Linux 系统中用户的密码信息，又称为“影子文件”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a419f25f1db0b97b4e6104122b3c3f70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7d255cf8e57ac476e908fc7c8f2a76f/" rel="bookmark">
			WPF中， DataGrid表格设置标题Header文字大小和行高
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用的VS2013。
解决方法： 1. 在&lt;DataGrid&gt;内部添加&lt;DataGrid.ColumnHeaderStyle&gt;
2. 先设置好该样式对应的类型&lt;Style TargetType="DataGridColumnHeader"&gt;
3. 设置文字大小"FontSize"，行高"Height"等属性即可
4.示例
&lt;DataGrid x:Name="size" AutoGenerateColumns="False" CanUserSortColumns="False" CanUserAddRows="True"&gt;
&lt;DataGrid.Columns&gt;
&lt;DataGridTextColumn Width="80" Binding="{Binding}" Header="宽"/&gt;
&lt;DataGridTextColumn Width="80" Binding="{Binding}" Header="高"/&gt;
&lt;DataGridTextColumn Width="80" Binding="{Binding}" Header="数量"/&gt;
&lt;/DataGrid.Columns&gt;
&lt;DataGrid.ColumnHeaderStyle&gt;
&lt;Style TargetType="DataGridColumnHeader"&gt;
&lt;Setter Property="FontSize" Value="30"/&gt;
&lt;Setter Property="Height" Value="80"/&gt;
&lt;Setter Property="HorizontalContentAlignment" Value="Center"/&gt;
&lt;/Style&gt;
&lt;/DataGrid.ColumnHeaderStyle&gt;
&lt;/DataGrid&gt;
（如下图）
走过的弯路： 1. 在&lt;DataGridTextColumn/&gt;语句中直接设置，“Height”属性不存在，“FontSize”属性是无效的
2. 文本大纲里编辑“HeaderStyle”模板副本，添加“FontSize”属性，编辑界面的预览是有效的，显示正常，但是运行起来后就又失效了，原因不知
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/50/">«</a>
	<span class="pagination__item pagination__item--current">51/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/52/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>