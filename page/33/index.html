<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/643a6bfaac476abe007491c301cff5c2/" rel="bookmark">
			刘铁猛C#教程学习笔记--初识C#程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 构成C#程序的基本元素 关键字：C#保留的用作特殊用途的标识符标识符：名字，如变量名字，类名字，命名空间名字等等； 标识符命名规则：只能以数字字母或者下划线开头，不能用关键字作为标识符，除非在关键字前面加上符号‘@’，比如if是一个非法的标识符，但是@if是一个合法的C#标识符，可以用中文作为变量名或者其它国家的语言作为变量名，但是为了不同国家程序员之间的交流合作，最好不要用自己国家的语言为变量命名，统一使用通用语言英语命名；
标识符命名规范：对于方法名，采用驼峰法命名，所谓驼峰法就是当标识符中出现多个单词时，第一个单词首字母小写，后序单词的首字母全部大写；除方法名之外如类名，变量名，命名空间的名字都采用pascal命名法，所谓pascal命名法是指，若标识符中出现多个单词，那么每一个单词的首字母都应该大写；
标点符号：如用于划分程序块的{}，以及用于表示一条语句结束的“;“等；
文本：简单理解可以理解为常量，如整型常量，字符串常量，布尔值等等，比如1就是文本，"abbc"也是一个文本；
操作符：用于进行运算的符号，如加减乘除符号，sizeof()运算符等等
空白与注释：在C#看来注释和空白是一样的，对于C#编译器来说在编译的时候都会忽略它们；C#注释规则和C语言一样；
初步学习阅读C#文档 1.打开vs2022，点击帮助-&gt;查看帮助
2.进入如下界面：点击语言-&gt;选择C#语言
这样就可以查看C#文档了，里面的内容非常丰富
这是中文版的，我找了英文版的关于标识符的C#文档，练习读英文文档的能力，英语不好的人真的看的很头痛 以下是我对该文档的翻译，虽然有些翻译出来了，但是不太理解其意思，但是对于初学者来说，这些细节不用太在意，应该先熟悉C#常见的语法规则，然后深入学习时再慢慢探究吧
初识C#程序，简单算法练习 分别用循环和递归实现求1到x的累加和，用函数来组织算法 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace Homework { class P5_test1 { static void Main(string[] args) //static关键字用于修饰类的静态成员，所谓静态成员就是属于类的成员而不是属于某一个具体的类实例的成员 { Calculate c = new Calculate(); int result1 = c.Sum1ToX1(10); int result2 = c.Sum1ToX2(10); Console.WriteLine(result1); Console.WriteLine(result2); } } //以下类用于实现计算1到x的累加和 class Calculate { //用循环实现该算法 public int Sum1ToX1(int x) { int sum = 0; for(int i=0;i&lt;x+1;i++) { sum += i; } return sum; } //用递归实现该算法 public int Sum1ToX2(int x) { if (x == 1) return 1; else { return x + Sum1ToX2(x - 1); } } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/101b8b9c482506b18bdde3f0390d45fe/" rel="bookmark">
			树莓派VNC server设置开机自启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前已测试OK的几个方法：
方法1（作为服务自启动）：
在/etc/init.d/中创建一个文件。例如tightvncserver：
sudo nano /etc/init.d/tightvncserver 在该文件中写入以下内容：
#!/bin/sh ### BEGIN INIT INFO # Provides: tightvncserver # Required-Start: $local_fs # Required-Stop: $local_fs # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 # Short-Description: Start/stop tightvncserver ### END INIT INFO # More details see: # http://www.penguintutor.com/linux/tightvnc ### Customize this entry # Set the USER variable to the name of the user to start tightvncserver under export USER='pi' ### End customization required eval cd ~$USER case "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/101b8b9c482506b18bdde3f0390d45fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59450b3ae6893b4e99de5d3b16beba63/" rel="bookmark">
			RoboScript #4 - RS3 Patterns to the Rescue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RoboScript #4 - RS3 Patterns to the Rescue | Codewarshttps://www.codewars.com/kata/594b898169c1d644f900002e/java
题目概括： 背景是开发一个操纵机器人行动的脚本语言RoboScript， 实现以下语言标准
F - Move forward by 1 step in the direction that it is currently pointing. Initially, the robot faces to the right.L - Turn "left" (i.e. rotate 90 degrees anticlockwise)R - Turn "right" (i.e. rotate 90 degrees clockwise)Fn - Execute the F command n times (NOTE: n may be more than 1 digit long!)Ln - Execute L n timesRn - Execute R n times (SEQUENCE_OF_COMMANDS)n .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59450b3ae6893b4e99de5d3b16beba63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5d17b6366822d325440579b7b935546/" rel="bookmark">
			Latex-Texlive和Texstudio的安装和初步使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Latex- Texlive+Texstudio 安装和使用 文章目录 文章目录 Latex- Texlive+Texstudio 安装和使用文章目录1.LaTex介绍2.Texlive下载和安装(1) 下载(2) 安装(3) 配置环境变量 3.TeXstudio的安装以及初步使用(1) 下载安装包(2) 初步配置(3) 初次运行 4.参考文献 1.LaTex介绍 LaTeX 基于 TeX，主要目的是为了方便排版。在学术界的论文，尤其是数学、计算机等学科论文都是由 LaTeX 编写, 因为用它写数学公式非常漂亮。
在稍微了解一点 LaTeX 后，你会发现 LaTeX 的工作方式类似 web page，都是由源文件（.tex or .html）经由引擎（TeX or browser）渲染产生最终效果（得到 PDF 文件 或者 生成页面）。两者极其神似，包括语法规则与工作方式。所以呢，与 HTML 一样，入门其实很简单。
一般的规范写法中都是在 HTML 文件中写入 web page 的结构与内容，再由 css 控制页面生成的样式。当然你也可以选择在 HTML 中直接写入样式内容，不过这并不提倡。同样，在 LaTeX 有着同样的情况，你可以在 tex 源文件中同时写入内容和样式，也可以内容与样式分离，以网络上流传广泛的 清华大学 LaTeX 模板为例，以.cls(class)结尾的 thuthesis.cls 便可看作是与 css 起到同样作用的样式文件。
LaTeX 有所谓宏包的概念，\usepackage{foo} 即可使用宏包 foo 中定义的内容。所谓宏包就是一些写好的内容打包出来以便大家使用而已。这跟 C 语言的 include 是一致的，将文件加载进来进行使用。利用宏包，我们可以使用很多现成的好用的样式。当然了，如果要编写一个自己的个性化的宏包也是可以的，不过需要学习成本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5d17b6366822d325440579b7b935546/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdd706d9e0d1a8e6b89f40c913208238/" rel="bookmark">
			LabVIEW开发X射线图像增强
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LabVIEW开发X射线图像增强
X射线图像在临床诊断中起着重要作用。但是，由于各种原因，例如不均匀，低照度条件和一些噪点，图像质量通常不是很好。因此有必要增强这些图像，以方便后续处理或诊断。模糊集论是开发图像处理中新的鲁棒技术的有力工具。当应用于X射线图像时，缺乏兼容性和灵活性。例如，通过直方图均衡化方法增强的图像看起来粗糙且不自然，最大化模糊度参数指数法容易过度增强X射线图像。模糊事件法的最大香农熵原理不会扩大中间的灰度级别，因此增强的图像看起来不明显。由于这些原因，需要寻找一个合适且灵活的函数来修改图像的强度分布。
设计一种基于最大模糊确定熵，利用模糊分区和对合模糊补码的图像增强新方法。首先，利用c-partition将图像划分为暗和亮两部分，然后得到相应的对合模糊补码，计算明暗概率，计算出模糊确定熵。使用穷竭搜索方法来获得最佳对α和λ，通过搜索最大模糊确定熵。同时，选择合适的正阈值来控制增强性能的新方法。
​
LabVIEW是高性能的虚拟仪器图形软件，广泛应用于测试、测量、自动化、科学实验等领域。但它不具备强大的复杂数值分析和复杂数学计算能力。开发了一种LabVIEW平台中的X射线图像增强方法，该方法是LabVIEW和MATLAB脚本的混合程序。混合程序不仅利用了仪器语言的优势，还扩展了算法工具箱，考察了新型智能虚拟仪器的发展路径。
通过采用可视化界面来简化可编程测量系统的设计、实现和使用。类似于真实仪器的图形界面使习惯于使用传统仪器的个人更直接地使用和理解VI。在本文中，使用LabVIEW平台，MATLAB脚本和IMAQ Vision工具箱实现了X射线图像增强系统。
通过基于最大模糊确定熵的图像增强方法。，在低质量图像上应用我们提出的方法时，特别是在低亮度和低对比度图像上，它非常高效和有效。其次，所提出的方法非常稳健，因为可以在相对非常大的范围内选择阈值，直到获得满意的结果。最后，在LabVIEW系统平台中，所提方法对许多X射线图像进行了实验，实验结果的比较表明，所提方案的性能优于传统算法。
这是LabVIEW的一个应用，更多的开发案例，欢迎登录官网，了解更多信息。有需要LabVIEW项目合作开发，请与我们联系。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c63c09575833d2da6b1c85d4fb749fb/" rel="bookmark">
			Linux使用脚本启动jar/war包（springboot&#43;maven工程jar包）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux（CentOS7）使用脚本启动java jar/war包 本文以jar包为例（war包是同样的操作流程）。
开始之前，先准备一个jar包 以springboot工程为例。
我打包用的maven。
在pom文件中可以约束最终的jar包名称：
mvn clear 再然后 mvn install 这些都没什么好说的。
建议以下文件全部放在一个目录下 1、部署jar包 通过xftp或别的方式，将jar包放入服务器某个目录：
2、准备application.yml（springboot工程，如果是别的框架请略过此节） yml文件放入jar包的同一个目录，内容是常规的springboot-yml文件内容，注意yml格式：
一会儿启动的时候会以服务器这个yml文件配置的内容为准👆👆👆
而不是项目中的yml文件👇👇👇
3、准备jvm_opt文件（.file文件） 此文件内容为java虚拟机启动时的参数：
配置jvm内存：一般只改abc这三个地方：
a = b 并且 c = a*(2/3)
单位：g 或者 m
如果你怕这么配置有啥问题，你可以临时恶补一下java虚拟机的知识，反正我这儿好几个工具jar包这么配没啥问题。
VM_OPTIONS="-Xms512m -Xmx512m -Xss256K -Xmn384m -XX:+UseG1GC -XX:G1HeapRegionSize=16m -XX:G1ReservePercent=25 -XX:InitiatingHeapOccupancyPercent=30 -XX:-OmitStackTraceInFastThrow -XX:+AlwaysPreTouch -XX:-UseLargePages -XX:-UseBiasedLocking" -Xss根据你的接口或者定时任务的每次调度的数据大小，可以适当增大一些。
4、准备脚本 我这儿命名为boot.sh
先上脚本，文章后面会介绍：怎么用？脚本内容的含义？
#!/bin/bash APP_NAME=$1 YUM_FILE_PATH=$2 [ -r jvm_opt ] &amp;&amp; source jvm_opt ##检查配置文件存在且可读，则将其souce VM_OPT=${VM_OPTIONS:-Xms1g -Xmx1g -Xss256K -Xmn600m -XX:+UseG1GC -XX:G1HeapRegionSize=16m -XX:G1ReservePercent=25 -XX:InitiatingHeapOccupancyPercent=30 -XX:-OmitStackTraceInFastThrow -XX:+AlwaysPreTouch -XX:-UseLargePages -XX:-UseBiasedLocking} # 提示输入参数 usage() { echo app_name=$APP_NAME vm_opt=$VM_OPT yum=$YUM_FILE_PATH echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c63c09575833d2da6b1c85d4fb749fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eed8e9228ed5de2e12278c47b7c23633/" rel="bookmark">
			Mysql数据库比较工具类(2.0版本)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package sql; import com.alibaba.fastjson.JSONArray; import com.alibaba.fastjson.JSONObject; import lombok.Data; import java.sql.*; import java.util.*; /** * 数据库比较工具类 * 温馨提示： * （1）如果想知道现数据库和原数据库有哪些区别，则原数据库配置 old，现数据库配置 now; * （2）比较结果以现数据库的视角说明，如：提示新增 xxx 表，则表示现数据库有，原数据库没有，反之； * （3）整个比较过程中，并不会对两个数据库造成任何影响，可放心使用； * （4）配置好两个数据库后，直接运行本类中的 main() 方法即可，最终比较结果将以 json 的格式直接输出在控制台。 * * @author Yuanqiang.Zhang * @since 2023/7/3 */ @Data public class CompareDataBaseUtils { public static Map&lt;String, String&gt; old; public static Map&lt;String, String&gt; now; static { // 原数据库 old = new HashMap&lt;&gt;(); old.put(Constant.ip, "127.0.0.1"); old.put(Constant.port, "3306"); old.put(Constant.dataBaseName, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eed8e9228ed5de2e12278c47b7c23633/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3036837eaaa0521a8c31d227135de14b/" rel="bookmark">
			SpringCloud运用与理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 SpringCloud介绍优缺点SpringCloud和SpringBoot关系SpringCloud和Dubbo的区别SpringCloud作用SpringCluod的五大组件引入组件的步骤 SpringCloud核心组件的业务运用EurekaEureka ClientEureka Server客服端与服务端的链接Eureka的自我保护机制EurekaServer集群Eureka与zookeeper比较 RibbonFeignHystrix问题背景解决方案服务熔断概念实现 服务降级概念实现 熔断与服务降级的区别Dashboard监控 Zuul实现 SpringCloud介绍 Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具
SpringCloud官网：http://projects.spring.io/spring-cloud/
相关学习网站：
https://springcloud.cc/spring-cloud-netflix.html
中文API文档： https://springcloud.cc/spring-cloud-dalston.html
SpringCloud中国社区 http://springcloud.cn/
SpringCloud中文网 https://springcloud.cc
优缺点 优点：
1、服务拆分粒度更细，有利于资源重复利用，有利于提高开发效率
2、可以更精准的制定优化服务方案，提高系统的可维护性
3、微服务架构采用去中心化思想，服务之间采用Restful等轻量级通讯，比ESB更轻量
4、适于互联网时代，产品迭代周期更短
5、社区活跃度高
缺点：
1、微服务过多，治理成本高，不利于维护系统
2、分布式系统开发的成本高（容错，分布式事务等）对团队挑战大
总的来说优点大过于缺点，目前看来SpringCloud是一套非常完善的分布式框架，目前很多企业开始用微服务
SpringCloud和SpringBoot关系 SpringBoot专注于快速方便的开发单个个体微服务SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，为各个微服务之间提供：配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务SpringBoot可以离开SpringCloud独立使用，开发项目，但是SpringCloud离不开SpringBoot，属于依赖关系SpringBoot专注于快速，方便的开发单个个体微服务，SpringCloud关注全局的服务治理框架 SpringCloud和Dubbo的区别 SpringCloudDubbo服务注册中心SpringCloud Netfilx EureKaZookeeper服务调用方式REST APIRPC服务监控Spring Boot AdminDubbo-monitor断路器Spring Cloud Netflix Hystrix不完善服务网关Spring Cloud Netfilx Zuul无分布式配置Spring Cloud Config无服务跟踪Spring Cloud Sleuth无消息总线Spring Cloud Bus无数据流Spring Cloud Srream无批量任务Spring Cloud Task无 最大区别：SpringCloud抛弃了Dubbo的RPC通信，采用的是最基本的HTTP的REST方式
严格来说，这两种方式各有优劣，虽然从一定程度上来说，后者牺牲看服务调用的性能，但是也避免的上面提到的原生RPC带来的问题，而且REST相比RPC更灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更加合适
他们解决的问题域不一样：Dubbo的定位是一款RPC框架，Spring Cloud的目标是微服务架构下的一站式解决方案
SpringCloud作用 Distributed/versioned configuration (分布式/ 版本控制配置)Service registration and discovery （服务注册与发现）Routing（路由）Service-to-service calls　（服务到服务的调用）Load balancing （负载均衡配置）Distributed messaging（分布式消息管理）。。。 SpringCluod的五大组件 服务发现 ——Netflix Eurek客户端负载均衡——Netflix Ribbon断路器——Netflix Hystrix服务网关——Netflix Zuul分布式配置——Spring Cloud Config 引入组件的步骤 导入依赖编写配置文件开启这个功能 @EnableXXXXX配置类 SpringCloud核心组件的业务运用 在实际微服务开发中，是将项目拆分为一个一个的子服务，如在常见的电商项目中，存在搜索服务，库存服务，订单服务，评价服务，仓储服务，积分服务等服务，微服务使得开发容易和为维护，因为一个服务只关注一个特定的业务，使得业务清晰，代码量少等优点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3036837eaaa0521a8c31d227135de14b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26cf5ac293464952cb0323d0afb12f4c/" rel="bookmark">
			QT5项目程序打包成可执行exe程序（绿色版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、QT在release模式下编译生成.exe 二、然后新建一个空白文件夹package，再将在release模式下生成的.exe文件复制到新建的文件夹中package。 三、打开QT5的命令行（选择项目所使用的的环境） 查找项目使用环境
打开命令行
四、在命令行输入命令 1、用命令行进入在（二）新建文件夹package； cd /d I:\package ##根据自己新建文件夹的路径来更改 五、使用windeployqt对生成的exe文件进行动态配置库文件 windeployqt humiture.exe 此时在package文件夹中的生成的配置文件，可以直接点击.exe文件运行了 以下为打包绿色版本步骤： 1、安装Enigma virtual box工具 下载Enigma virtual box安装包 2、打开Enigma virtual box工具 在package文件夹中选择exe文件 点击“添加” &gt;&gt; “添加文件夹递归（X）” &gt;&gt; 选择新建生成配置的文件夹 &gt;&gt; "添加文件夹" Enigma virtual box此时就会自动添加配置文件及库 点击“文件选项” &gt;&gt; 选择"压缩文件" 点击“打包” 3、完成打包后，在package文件夹中生成的_boxed.exe文件就是原来exe文件的绿色版本 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b247fd402591ae86235c5de68124d0fc/" rel="bookmark">
			c#之UDP协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UDP协议 Internet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。RFC 768 描述了 UDP。
Internet 的传输层有两个主要协议，互为补充。无连接的是 UDP，它除了给应用程序发送数据包功能并允许它们在所需的层次上架构自己的协议之外，几乎没有做什么特别的事情。面向连接的是 TCP，该协议几乎做了所有的事情。
UDP的优缺点 优点:
1,传输数据之前通信双方不需要建立连接，因此不存在连接建立的时延。在发送端，UDP 传送数据的速度仅仅受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端， UDP 把每个数据报放在队列中，应用程序每次从队列中读一个数据报。
2,传输数据不需要维护连接状态，包括收发状态等，这样一台服务器可同时向多个客户端传输相同的数据，如实现多播。
缺点:
容易丢包
它不能提供可靠性保证，数据可能会丢失或损坏，因此不适合传输重要的数据。另外，UDP也不能提供流量控制，因此可能会导致网络拥塞。
简单逻辑代码:
#region 单播 /// &lt;summary&gt; /// 接收 /// &lt;/summary&gt; static void UdpRevice() { Socket udp = new Socket(AddressFamily.InterNetwork,SocketType.Dgram,ProtocolType.Udp); IPEndPoint ipP = new IPEndPoint(IPAddress.Any,8080); udp.Bind(ipP); Task.Run(() =&gt; { byte[] bytes = new byte[1024]; while (true) { EndPoint endP = new IPEndPoint(0,0); int length = udp.ReceiveFrom(bytes,ref endP); if (length &lt;= 0) { udp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b247fd402591ae86235c5de68124d0fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b25d57a332c0b16b259f7ae42330fb17/" rel="bookmark">
			C# 如何调用python，避免重复造轮子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 原因资源调用python文件需求解决方案1、C#里面运行python引入python文件，再调用其中的方法启动python脚本，监听返回值改造一下，可以入参的python调用查看是否等待python运行完成之后再运行C#如果参数比较复杂 开一个python网络后端 总结 原因 最近有个需求，需要按照填入的参数动态地生成对应word文件。excel文件我还有办法，word文件我是真没办法。我去.NET上面搜了一下C#支持的word编辑库，发现好像就NPOI支持word文件修改。我没办法网上所了好久，终于找到了对应的博客通过反射和泛型去解决模板化的文件填充。然后领导又给了我一个需求。
现在是能够用占位符去替换了，内容是动态的，现在个数也要动态的。比如我一个报表，有A,B,C三项内容，现在能把ABC三项填进去了。现在的需求是有多个ABC，1，5,10,20个。就是只有一个模板但是能自我复制。自己造轮子太麻烦了。
我后来看到python处理这些特别简单，后来我决定，C#去调用python，不重复造轮子。
Tips:我最后在ChatGPT上面找到方法了，国内C#相关的博客也太少了
Tips:我后来发现nuget上面有minWord和minExcel，专门用于模版文件导入导出，我到时候看一下
资源 这个是自己纯手撸了一个代码
C# 生成word文档（NPOI.XWPF）
这个是我网上逛github逛到的
C# MiniWord Gtihub官网
这个是这个作者另一个快速Excel文件，我感觉这个好像很好使
C# MiniExcel Gtihub官网
python的方法
Python docxtpl 操作 Word 模板文档
调用python文件 需求 如果我们要调用python代码或者文件，我们至少要做的一下几步：
主要要求
能执行。至少我能运行python文件有返回。我能知道结果。能入参。我能将参数添加进去能同步。我能等待python运行完了之后再接着运行C#代码。 保证了这个我们就能勉强使用
次要要求
宽松环境。我python版本、C#和.NET 版本都随意。我能随意pip install 任意版本的第三方库好部署：在一个新环境下面好部署。最好文件复制过去就能用。编写简单。我能很快的编写代码高效。保证一定的运行效率稳定。不容易出bug 解决方案 c#调用python的三种方法
1、C#里面运行python 太蠢了，我就直接写了
使用Pythonnet库:
Pythonnet是一个开源项目，可以直接在C#中调用Python。首先，需要在C#项目中安装Pythonnet库。可以使用NuGet包管理器或手动安装。
using System; using Python.Runtime; class Program { static void Main() { using (Py.GIL()) // 获取全局解释器锁 { dynamic py = Py.Import("module_name"); // 导入Python模块 // 调用Python函数或访问Python对象 dynamic result = py.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b25d57a332c0b16b259f7ae42330fb17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05cd92670297edbef47d42fe43f08595/" rel="bookmark">
			MAC OS X 这个“安装 macOS Xxx Xxx”应用程序副本已损坏，不能用来安装 macOS,超级终端修改日期date 已解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因：旧版 macOS 证书已经过期
解决方法：断开互联网，修改系统时间
date 102013142018.20 说明：10是月，20是日，13是时，14是分，2018是年，20是秒
输入上面的代码按回车后返回的是 Sat Oct 20 13:14:20 PST 2018 就是正确的，否则输入有误。
*日期格式解析："091400002022"代表2022年9月14日0点发布，所以需更改成对应版本的发布日期方可安装
date 091400002022.00 (macOS Monterey 12.6)
date 082000002022.00 (macOS Monterey 12.5.1)
date 072100002022.00 (macOS Monterey 12.5)
date 032900002023.00 (macOS Ventura 13.3)
date 030400002021.00（macOS Big Sur）
date 0201010116（OS X El Capitan 10.11.6适用）
date 010514102017.30（macOS Sierra 10.12适用）
date 102013142018.20 (10.14.6)
date 102013142017.20 (10.13.6)
date 062614102014.30 （10.13、10.14适用）(10.9.5可用)
date 121212122019 （10.15）
date 0923222120 （10.15）
date 032208102015.20
date 112202022015
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05cd92670297edbef47d42fe43f08595/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/676c2d3b244565d74c0af8624d5f8c04/" rel="bookmark">
			OpenCV(Mat类)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、什么是Mat类
2、Mat类组成
3、Mat类能存储的数据类型
4.Mat类的创建
4.1 利用矩阵宽、高和类型参数创建
4.2 利用矩阵Size()结构和数据类型参数来创建
4.3 利用已有Mat类来创建
5、Mat类的赋值
5.1 创建时赋值
5.2 类方法赋值
5.3 枚举赋值
6、Mat类数据的读取
6.1 Mat类的常用属性
6.2 at方法读取矩阵元素
6.3 矩阵元素地址定位方式访问元素
7.Mat支持的运算
7.1 符号运算
7.2 两个矩阵相乘
7.3 OpenCV中提供的运算函数
1、什么是Mat类 Mat类是OpenCV中用于存储矩阵数据的类型。
2、Mat类组成 3、Mat类能存储的数据类型 Tp:用户可自定义类型
4.Mat类的创建 4.1 利用矩阵宽、高和类型参数创建 Mat a(3, 3, CV_8S); 4.2 利用矩阵Size()结构和数据类型参数来创建 Mat a(Size(3,3), CV_8SC(2));//C(2)通道数为2 4.3 利用已有Mat类来创建 5、Mat类的赋值 5.1 创建时赋值 Mat f(Size(3,3),CV_8U,Scalar(0,55,255)); 5.2 类方法赋值 a=Mat::eye(3,3,CV_8U); 5.3 枚举赋值 6、Mat类数据的读取 6.1 Mat类的常用属性 6.2 at方法读取矩阵元素 6.3 矩阵元素地址定位方式访问元素 Mat a = (Mat_&lt;int&gt;(3, 3) &lt;&lt; 1, 2, 3, 4, 5, 6, 7, 8, 9); Mat c0(5,5,CV_8UC1,Scalar(4,5,6)); Mat c1(5,5,CV_8UC2,Scalar(4,5,6)); Mat c2(5,5,CV_8UC3,Scalar(4,5,6)); cout &lt;&lt; a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/676c2d3b244565d74c0af8624d5f8c04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd0edbd8afa5c68b6609e81dd3d310d4/" rel="bookmark">
			单片机通识之按键扫描框架(非死等消抖)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按键是用户向单片机输入信息的重要方式之一，最近遇到很多刚大学毕业的学生在写按键消抖时，都是在死等，这种方式并不实用，应该没有产品会采用这种低效的方式。
本文就该问题展开叙述，提供一个可行的思想。在示例代码中，主要实现了: 若按键数目或所用引脚发生变化，仅需改变头文件按键定义即可，代码部分无需改动。
文章目录 开发环境核心思想示例代码头文件源文件 结语 开发环境 STM32F103C8T6: 价格低，用来学习非常合适。
核心思想 在商业用途的项目开发中，一个通用的框架是必须的，写一次框架，可应对多种场合、多次使用，这会很大的提升效率，所以在实现一个模块时，一定要考虑它的复用性。
在示例代码中，实现 仅需改动头文件即可 这一功能的思想就是利用数组、指针数组，遍历的方式去检测每一个数组中的IO口，并且判断按键是否按下，再利用指针数组去调用按键对应的函数。在示例代码中会详细讲解。
数组包括:
用到的GPIO，例如 GPIOA、GPIOB等用到的引脚，例如　GPIOA的　第４个引脚、GPIOB的　第５个引脚等 指针数组:
把每一个按键按下、松开要调用的函数地址放入数组中，这样就可以灵活的根据索引去调用对应的函数 示例代码 头文件 #ifndef __INDEPENDENTKEYH #define __INDEPENDENTKEYH #include "stm32f10x.h" // Device header // Debounce time (INDEPENDENT_KEY_DEBOUNCE_TIME) * 10us // 消抖时间为 320ms，利用 TIM2 计时，中断周期为 10us。 // 这里可以根据自己实际用到的定时器去 计时 #define INDEPENDENT_KEY_DEBOUNCE_TIME 320 // INDEPENDENT_KEY_GPIO_NUMBER 定义用到了几个GPIO // 因为STM32对每一个外设都设计了一个时钟，所以在用到GPIO前，都需要预先开启对应的时钟 // 这里是采用遍历的方式，去开启用到的GPIO，所以会产生以下两个宏定义 #define INDEPENDENT_KEY_GPIO_NUMBER 2 #define INDEPENDENT_KEY_GPIO_ENABLE_TABLE \ /* GPIOA */ RCC_APB2Periph_GPIOA, \ /* GPIOB */ RCC_APB2Periph_GPIOB // INDEPENDENT_KEY_NUMBER 一共用到了多少个 IO 口 // INDEPENDENT_KEY_PORT_TABLE 定义每一个按键对应的 IO 口 // INDEPENDENT_KEY_PIN_TABLE 定义每一个按键对用 IO口 的哪个引脚 // 这两个数组定义均要按照实际顺序，例如Key1 用到 GPIOA 的第4个引脚，KEY3 用到GPIOA的引脚的第6个引角 #define INDEPENDENT_KEY_NUMBER 5 #define INDEPENDENT_KEY_PORT_TABLE \ /* Port of key1 */ GPIOA, \ /* Port of key2 */ GPIOA, \ /* Port of key3 */ GPIOA, \ /* Port of key4 */ GPIOA, \ /* Port of key5 */ GPIOB, #define INDEPENDENT_KEY_PIN_TABLE \ /* Pin of key1 */ GPIO_Pin_4, \ /* Pin of key2 */ GPIO_Pin_5, \ /* Pin of key3 */ GPIO_Pin_6, \ /* Pin of key4 */ GPIO_Pin_7, \ /* Pin of key5 */ GPIO_Pin_11, // 这个数组定义了每个按键的触发电平，以适用不同电平的触发方式 // 这个触发电平要和 STM32 定义的BitAction一致，即 仅允许 低电平 Bit_RESET 和 高电平 Bit_SET #define INDEPENDENT_KEY_TRIGGER_LEVEL_TABLE \ /* Trigger level of key1 */ Bit_SET, \ /* Trigger level of key2 */ Bit_SET, \ /* Trigger level of key3 */ Bit_SET, \ /* Trigger level of key4 */ Bit_SET, \ /* Trigger level of key5 */ Bit_SET /* * @brief: 对按键进行初始化，包括 GPIO 和 用到的变量 * @param void * @retval void */ void Independent_Key_Init(void); /* * @brief: 放在主循环中检测按键状态 * @param void * @retval void */ void Independent_Key_Scan(void); /* * @brief: 按键状态发生变化，消抖时间需要清零，重新开始计时 * @param void * @retval void */ void Key_Changed(uint16_t current_buffer); /* * @brief: 按键状态未发生变化 * @param void * @retval void */ void Key_No_Changed(uint16_t current_buffer); /* * @brief: Key_Press_1 之后的函数为按键按下松开对应的触发函数，根据需要去添加功能 * @param void * @retval void */ void Key_Press_1(void); void Key_Press_2(void); void Key_Press_3(void); void Key_Press_4(void); void Key_Press_5(void); void Key_Release_1(void); void Key_Release_2(void); void Key_Release_3(void); void Key_Release_4(void); void Key_Release_5(void); #endif 源文件 #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd0edbd8afa5c68b6609e81dd3d310d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfb9bddaa33d110725dd28063f4b7f76/" rel="bookmark">
			APP自动化之Poco框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大家介绍一款自动化测试框架Poco，其脚本写法非常简洁、高效，其元素定位器效率更快，其本质基于python的第三方库，调试起来也会非常方便，能够很好的提升自动化测试效率，节省时间。
(一）背景 1. Poco介绍
Poco是一款跨平台的自动化测试框架，基于UI控件识别原理，适用于Android、iOS原生和各种主流的游戏引擎应用，由于Airtest是基于图像识别原理，所以Poco+Airtest结合使用更适合混合应用。尤其是针对flutter app部分元素控件无法识别情况，采用airtest框架，针对元素控件的部分，采用Poco框架进行自动化测试。
2. Poco本质
Poco和Airtest框架一样，Poco实际上也是Python的一个第三方库，如果需要本地编写Poco脚本，需要先安装Pocoui库即可
pip install pocoui 3. 官方文档
https://airtest.doc.io.netease.com/IDEdocs/poco_framework/1_poco_info/
（二）使用Poco框架 1. 查看控件元素
在AirtestIDE连接待测设备后，然后在Poco辅助窗口选择对应的设备进行查看
备注：选择模式时，脚本编辑窗口顶部会让我们选择是否插入对应的初始化代码，我们选择Yes即可
2. 查看控件的方式
第一种：冻结模式
进入模式：点击下图冻结按钮
说明：单击下图箭头区域，则会进入冻结模式查看元素控件，光标移至右侧的元素位置，并点击相应元素控件，则自动会定位到页面层级，log窗口可以查看当前层面的元素属性。即使实际连接的被测设备已经离开当前页面，冻结模式也不会受影响，相当于一直冻结在这个页面，便于查看元素
退出方式：再次点击冻结按钮
第二种：检视模式
进入模式：点击下图检视按钮
说明：单击下图箭头区域，则会进入检视模式查看元素控件，与刚才的冻结模式最大的区别是，此时查看控件，如我们对控件进行操作，设备画面也会跟着变化
退出方式：再次点击检视按钮
3. 定位元素的方式
基本定位器
由于AirtestIDE内置Poco，直接导入即可使用，基本定位器就是poco(节点名或节点属性)
# -*- encoding=utf8 -*- __author__ = "86150" from poco.drivers.android.uiautomation import AndroidUiautomationPoco poco = AndroidUiautomationPoco(use_airtest_input=True, screenshot_each_action=False) # 单个条件 poco(text="中古屋") # 多个条件 poco('com.addcn.android.house591:id/grid_item_text',text="中古屋") 相对选择器
就是通过元素之间的层级关系进行选择，例如父子关系、兄弟关系、祖先后代关系等等，Poco控件给我们提供了利用树的层级关系来定位的各种方法：
子节点：child所有子节点：children子孙节点：offspring父节点：parent兄弟节点：sibling poco("plays").child("playBasic").offspring("star_single") 说明：这种方式较为繁琐，一般是通过属性和节点无法定位的时候，可以选择使用这种方式
正则表达式
正则表达式匹配时一种少见的方式，但也是非常好用的方式，按照下图通过属性定位的方式为：
# 1.text属性方式定位 poco(text="中古屋") # 换成正则表达式定位 poco(textMatches="正则表达式") poco(textMatches=".*中古屋") # 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfb9bddaa33d110725dd28063f4b7f76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa8c35043bd17e2859c3e8fb436f721e/" rel="bookmark">
			linux设备驱动程序：简单字符设备驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、linux系统设备分类 linux系统将设备分为3类：字符设备、块设备、网络设备。使用驱动程序：
1、字符设备：是指只能一个字节一个字节读写的设备，不能随机读取设备内存中的某一数据，读取数据需要按照先后数据。字符设备是面向流的设备，常见的字符设备有鼠标、键盘、串口、控制台和LED设备等。
2、块设备：是指可以从设备的任意位置读取一定长度数据的设备。块设备包括硬盘、磁盘、U盘和SD卡等。
每一个字符设备或块设备都在/dev目录下对应一个设备文件。linux用户程序通过设备文件（或称设备节点）来使用驱动程序操作字符设备和块设备。
二、字符设备驱动程序基础 1、主设备号和次设备号（二者一起为设备号）：
一个字符设备或块设备都有一个主设备号和一个次设备号。主设备号用来标识与设备文件相连的驱动程序，用来反映设备类型。次设备号被驱动程序用来辨别操作的是哪个设备，用来区分同类型的设备。
linux内核中，设备号用dev_t来描述，2.6.28中定义如下：
typedef u_long dev_t;
在32位机中是4个字节，高12位表示主设备号，低12位表示次设备号。
可以使用下列宏从dev_t中获得主次设备号： 也可以使用下列宏通过主次设备号生成dev_t:
MAJOR(dev_t dev);　MKDEV(int major,int minor);
MINOR(dev_t dev);
//宏定义： #define MINORBITS 20 #define MINORMASK ((1U &lt;&lt; MINORBITS) - 1) #define MAJOR(dev) ((unsigned int) ((dev) &gt;&gt; MINORBITS)) #define MINOR(dev) ((unsigned int) ((dev) &amp; MINORMASK)) #define MKDEV(ma,mi) (((ma) &lt;&lt; MINORBITS) | (mi)) 2、分配设备号（两种方法）：
（1）静态申请：
int register_chrdev_region(dev_t from, unsigned count, const char *name)；
/** * register_chrdev_region() - register a range of device numbers * @from: the first in the desired range of device numbers; must include * the major number.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa8c35043bd17e2859c3e8fb436f721e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09c3a7dcdacb2113d077fc7dd403def7/" rel="bookmark">
			华为防火墙SSL VPN隧道连接实验配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		远程拨号用户发起SSL VPN隧道连接实验配置 文章目录 远程拨号用户发起SSL VPN隧道连接实验配置前言一、实验拓扑二、实验步骤：1.AR12.LNS 三、Web登录防火墙配置总结测试 前言 用于远程访问VPN，工作在应用层与传输层之间
SSL VPN是以SSL协议为安全基础的VPN远程接入技术，移动办公人员（在SSL VPN中被称为远程用户）使用SSL VPN可以安全、方便的接入企业内网，访问企业内网资源，提高工作效率。
SSL与IPSec、L2TP的区别：
1.IPSec、L2TP缺点：远程用户终端上需要安装指定的客户端软件，导致网络部署、维护比较麻烦。
2.IPSec、L2TP配置繁琐
3.网络管理人员无法对远程用户访问企业内网资源的权限做精细化控制。
SSL的特点：
1.B/S结构：浏览器/服务器结构，远程用户终端上无需安装额外的客户端软件，直接使用Web浏览器就可以安全、快捷的访问企业内网资源。
2.可以根据远程用户访问内网资源类型的不同，对其访问权限进行高细粒度控制。
3.提供了本地认证、服务器认证、证书匿名和证书挑战多种身份认证方式，提高了身份认证的灵活性。
4.主机检查策略可以检查远程用户终端的操作系统、端口、进程以及杀毒软件等是否符合安全要求，并且还具备防跳转、防截屏的能力，消除了潜藏在远程用户终端上的安全隐患。
5.缓存清理策略用于清理远程用户访问内网过程中在终端上留下的访问痕迹，加固了用户的信息安全。
SSL应用场景：
SSL VPN的主要应用场景是保证远程用户能够在企业外部安全、高效的访问企业内部的网络资源。
1.远程用户的SSL VPN接入网关
FW作为企业出口网关连接至Internet，并向远程用户提供SSL VPN接入服务。远程用户可以使用移动终端（如便携机、PAD或智能手机）随时随地访问FW并接入到企业内网，访问企业内网资源。
实验目的
移动办公用户的便携机上装有VPN Client软件。用户期望使用VPN Client软件与企业出口网关LNS间建立SSL VPN隧道，从而通过VPN隧道访问企业内网！
一、实验拓扑 二、实验步骤： 1.AR1 &gt;clock timezone beijing add 8 sys sysname AR1 user-interface console 0 idle-timeout 0 quit # interface GigabitEthernet0/0/0 ip address 1.1.1.2 255.255.255.0 quit # interface GigabitEthernet0/0/1 ip address 3.3.3.2 255.255.255.0 quit 2.LNS 代码如下（示例）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09c3a7dcdacb2113d077fc7dd403def7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f375ef1e067fce59ccc28d391fa239c0/" rel="bookmark">
			新版docker存储目录迁移教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新版docker存储目录迁移教程 前言查看磁盘大小停止docker服务创建新目录拷贝原数据查找docker.service文件位置修改docker.service文件重启docker确认修改再次确认 前言 docker默认数据存储目录为/var/lib/docker，在docker的使用中随着下载镜像越来越多，构建镜像、运行容器越来越多, 数据目录必然会逐渐增大；当所有docker镜像、容器对磁盘的使用达到上限时，就需要对数据目录进行迁移。
查看磁盘大小 [root@localhost system]# df -h 文件系统 容量 已用 可用 已用% 挂载点 devtmpfs 16G 0 16G 0% /dev tmpfs 16G 0 16G 0% /dev/shm tmpfs 16G 12M 16G 1% /run tmpfs 16G 0 16G 0% /sys/fs/cgroup /dev/mapper/centos-root 50G 40G 11G 80% / /dev/mapper/centos-home 957G 14G 944G 2% /home /dev/vda1 1014M 152M 863M 15% /boot tmpfs 3.2G 0 3.2G 0% /run/user/0 此处，我们可以看到，home的存储空间最大，我们将docker迁移到这个目录下。
停止docker服务 systemctl stop docker 创建新目录 mkdir -p /home/docker/lib 拷贝原数据 cp -r /var/lib/docker/ /home/docker/lib/ 查找docker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f375ef1e067fce59ccc28d391fa239c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d68bc0774b21a03023af1f26a568fa75/" rel="bookmark">
			性能测试 —— 开源负载测试工具Locust详解~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.locaust是什么？ Locust是一款易于使用的分布式负载测试工具，完全基于事件，即一个locust节点也可以在一个进程中支持数千并发用户，不使用回调，通过gevent使用轻量级过程（即在自己的进程内运行）
2.locust安装 命令：pip install locust
3.一个简单的locustfile.py文件 import time import time from locust import HttpUser,task,between class QuickStartUser(HttpUser): host = 'http://192.168.0.102:5000' min_wait = 3000 max_wait = 6000 @task def index(self): r=self.client.get('/login') assert r.status_code==200 @task def login(self): r = self.client.post( url='/login', json={"username": "wuya", "password": "admin", "age": 18, "sex": "男"}) assert r.status_code == 200 4.控制台运行：locust -f locustfile.py 启动locust文件成功后，编译器控制台会显示如下信息：
[2018-10-09 01:01:44,727] IMYalost/INFO/locust.main: Starting web monitor at *:8089
[2018-10-09 01:01:44,729] IMYalost/INFO/locust.main: Starting Locust 0.8 PS：8089是该服务启动的端口号，如果是本地启动，可以直接在浏览器输入http://localhost:8089打开UI界面，如果是其他机器搭建locust服务，则输入该机器的IP+端口即可；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d68bc0774b21a03023af1f26a568fa75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68435c1013793943a0faaae76345cccb/" rel="bookmark">
			安装部署vcenter 6.7（保姆级教学）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于自己在日常工作中经常会使用到CSDN查询疑难杂症，于是就萌生了将他作为自己学习和成长过程中的记录者，其实更多是想方便自己日后的反复阅览，如果能帮助到其他同学的话，那自然是最好的。其实这个安装部署过程网上随便搜索有一大堆，不过自己还是想记录一下。
好了，现在进入正题
一、下载vcenter6.7 1.下载地址，直接复制粘贴到web回车即可，这一步就不截图了。
https://down2.130.cloud/vmware/vcsa6.7/VMware-VCSA-all-6.7.0-19300125.iso
二、安装部署vcenter6.7 将下载好的镜像文件拷贝到一台Windows机器上，双击以后会自动挂载到光驱。（如图）
接下来安装vcenter
双击运行以后，回到设备和驱动器的目录下即可看到新加入的DVD驱动器（如图）
双击DVD驱动器以后，会出现VMware VCSA的目录，进入以后找到如下图的目录，进入此目录
进入上图的目录以后会出现Win32的目录，继续进入目录
找到install.exe，双击运行它
刻会弹出要安装的界面，在右上角选择自己熟悉的语言（日常使用，还是首选母语啦）
选择语言以后，继续选择安装的按钮
下一步
同意许可协议
部署类型（建议嵌入式部署）
部署到ESXi中（输入已存在的ESXi主机IP即可，端口不需要更换。用户名和密码都是你填入IP的主机信息）
上面输入对应的消息以后，点击下一步，选择“是”即可！
设置vcenter信息（最好记录一下！）
选择vcenter服务资源配置（根据自己公司的规模来选择，我这里选择的是默认的微型）
选择vcenter存储到哪块磁盘
设置vcenter的IP地址。
信息确认，开始安装！
这一步需要点时间，不要中断！不要中断！不要中断！重要的事情说三遍！
这个安装的过程其实就跟平时装虚拟机的过程是一样的，你可以登录到上面已经绑定的宿主机上进行查看安装过程和安装进度。
安装完成！点击继续即可！接下来进行第二阶段的配置！
第三步、第二阶段配置vcenter sso 上面点击完继续以后会出现第二阶段安装窗口，咱们按照提示继续操作。
直接下一步！
ntp时间同步，这里我用的是aliyun的。输入ntp1.aliyun.com
创建sso（这一步是自定义，涉及到web登录时候要用的，最好记录一下）
配置完成（核对信息）
等待配置完成
第四步、浏览器登录访问vcenter 通过浏览器访问，H5版本已经具有全部功能，强烈推荐使用（将右下角的证书下载保存，再启动）
输入账号密码
看到如下界面就代表安装完成
配置vcenter许可证
添加vcenter6的许可证（这里是vcenter6许可证01）
点击“资产”后，点击“分配许可证”
选择刚才添加的许可证（vcenter许可01），点击“确定”
分配新许可证后，可以看到vcenter已经没有到期时间
第五步、添加主机 安装完VCSA后在浏览器输入之前规划配置好的VSCA的IP进行访问
新建数据中心
添加主机（这一步是将目前存在的ESXi主机添加到界面进行管理）
输入要添加的宿主机IP和密码
出现证书问题直接点击“是”即可
等待添加即可
成功以后，该ESXi主机摘要显示如下，所有的部署全部结束，后面有空的时候会继续记录一些在vcenter上操作的。希望能帮助你们！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/32/">«</a>
	<span class="pagination__item pagination__item--current">33/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/34/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>