<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/439a106b0358c1c9096f975f73053e88/" rel="bookmark">
			HTTP 和 HTTPS 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简述 1️⃣HTTP (全称 Hyper Text Transfer Protocol)，就是超文本传输协议，用来在 Internet 上传送超文本。是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准(TCP)，用于从 WWW 服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。
2️⃣HTTPS：安全超文本传输协议。简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。
HTTPS 的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。
超文本传输协议 HTTP 被用于 Web 浏览器和网站服务器之间传递信息，HTTP 以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了 Web 浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息。因此，HTTP 不适合传输敏感信息，比如：资金账户、密码等。为了解决 HTTP 的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议 HTTPS，为了数据传输的安全，HTTPS 在 HTTP 的基础上加入了 SSL 协议，SSL 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。
二、HTTP 与 HTTPS 的区别 HTTP 传输的数据都是未加密的，也就是明文的，因此使用 HTTP 传输信息非常不安全。为了保证数据能加密传输，网景公司设计了 SSL(Secure Sockets Layer) 协议用于对 HTTP 传输的数据进行加密，从而就诞生了 HTTPS。二者主要区别如下：
1️⃣HTTPS 需要到 ca 申请证书，一般免费证书较少，因而需要一定费用。
2️⃣HTTP 信息是明文传输，HTTPS 则是具有安全性的 ssl 加密传输协议。
3️⃣HTTP 和 HTTPS 连接方式完全不同，端口也不一样，前者是 80，后者是 443。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/439a106b0358c1c9096f975f73053e88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cf13ab71608db4e2e9b924365d00d5b/" rel="bookmark">
			java数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java数据类型可分为两大类（基本数据类型、引用类型），而基本数据类型可细分为4类8种。每一种数据都定义了明确的数据类型，在内存中分配了不同大小的内存空间（例如byte占1个字节）。
一、基本数据类型4类
1、整数型 byte [1]、short[2] 、int[4] 、long[8]
2、浮点型 float [4]、 double[8]
3、字符型 char[2]，存放单个字符，如’a’、‘男’，单个字母占1个字节，单个汉字占2个字节
4、布尔型 boolean[1]，存放true、false
整数型和浮点型都属于数值型，因此也可以说是3类。
二、基本数据类型8种
三、引用类型
1、类 class
2、接口 interface
3、数组 [ ]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c9c74070deff58ae98d7a33624d99bf/" rel="bookmark">
			系统运维系列 之在Windows下可以查看文件夹大小的工具TreeSize Free
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给大家推荐一个在Windows下可以查看文件夹大小的工具TreeSize Free。
下载链接：
https://customers.jam-software.de/downloadTrial.php?language=EN&amp;article_no=80
参考资料：
https://blog.csdn.net/qq_33204709/article/details/111661871
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4084594d4214c0078ec7c5107b1f344f/" rel="bookmark">
			SHELL脚本类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多终端，分别运行可执行文件 文章目录 多终端，分别运行可执行文件 前言 前言 通过脚本，完成打开多个终端，分别运行可执行文件；
最终实现功能：可以启用多个界面，每个界面运行N个终端，每个终端可以独立命名；
备注：
Ubuntu系统：
gnome-terminal -x bash -c “./test.sh”
银河麒麟系统：
mate-terminal -x bash -c "./test1
#!/bin/bash for((i = 1;i&lt;26;i++)) #for i in 'seq 1 25' //与上面等同 #for ((i = 1;i&lt;26 ; i+=5)) //递增5 do if(($i==1)) then mate-terminal --title="USV$i" -- bash -c "./control_01 $i" elif(($i&lt;7)) then mate-terminal --tab --title="USV$i" -- bash -c "./control_01 $i" elif$i == 7 then mate-terminal --title="USV$i" -- bash -c "./control_01 $i" elif(($i&lt;13)) then mate-terminal --tab --title="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4084594d4214c0078ec7c5107b1f344f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ac743031db50b203aae61975f94fec0/" rel="bookmark">
			SPRINGBOOT视图跳转问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring boot使用 ModelAndView 视图跳转：
①将html文件存储在templates文件夹下，可以直接存储，也可以创建子文件夹存储
②导入thymeleaf依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; ③controller的注解必须是@Controller 而不是@RestController
④视图跳转代码ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName("视图名称"); modelAndView.addObject("param name", param value); return modelAndView; 视图跳转时若出现template无法解析的情况：
①thymeleaf的依赖是否导入
②pom.xml中的静态文件是否放开&lt;resources&gt; &lt;!--解决mapper.xml文件的编译问题，如果不指定，在编译的时候，编译器默认只编译类文件，不编译xml文件--&gt; &lt;resource&gt; &lt;!--指定源文件夹位置--&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;!--指定源文件夹中的哪些资源要进行编译--&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.css&lt;/include&gt; &lt;include&gt;**/*.js&lt;/include&gt; &lt;include&gt;**/*.html&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; ③查看target文件夹，检验打包发布的项目是否包含html文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c2266e60a963ccb2c0727203dc170d7/" rel="bookmark">
			[转]一个严谨的STM32串口DMA发送&amp;接收（1.5Mbps波特率）机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 前言2 串口有必要使用DMA吗3 实现方式4 STM32串口使用DMA5 串口DMA接收 5.1 基本流程5.2 相关配置5.3 接收处理 5.3 .1 接收数据大小5.3.2 接收数据偏移地址 5.4 应用读取串口数据方法 6 串口DMA发送 5.1 基本流程5.2 相关配置5.3 发送处理 6 串口设备 6.1 数据结构6.2 对外接口 7 相关文章8 完整源码 1 前言 直接存储器访问（Direct Memory Access），简称DMA。DMA是CPU一个用于数据从一个地址空间到另一地址空间“搬运”（拷贝）的组件，数据拷贝过程不需CPU干预，数据拷贝结束则通知CPU处理。因此，大量数据拷贝时，使用DMA可以释放CPU资源。DMA数据拷贝过程，典型的有：
内存—&gt;内存，内存间拷贝外设—&gt;内存，如uart、spi、i2c等总线接收数据过程内存—&gt;外设，如uart、spi、i2c等总线发送数据过程 2 串口有必要使用DMA吗 串口(uart)是一种低速的串行异步通信，适用于低速通信场景，通常使用的波特率小于或等于115200bps。对于小于或者等于115200bps波特率的，而且数据量不大的通信场景，一般没必要使用DMA，或者说使用DMA并未能充分发挥出DMA的作用。
对于数量大，或者波特率提高时，必须使用DMA以释放CPU资源，因为高波特率可能带来这样的问题：
对于发送，使用循环发送，可能阻塞线程，需要消耗大量CPU资源“搬运”数据，浪费CPU对于发送，使用中断发送，不会阻塞线程，但需浪费大量中断资源，CPU频繁响应中断；以115200bps波特率，1s传输11520字节，大约69us需响应一次中断，如波特率再提高，将消耗更多CPU资源对于接收，如仍采用传统的中断模式接收，同样会因为频繁中断导致消耗大量CPU资源 因此，高波特率场景下，串口非常有必要使用DMA。
3 实现方式 整体设计图
4 STM32串口使用DMA 关于STM32串口使用DMA，不乏一些开发板例程及网络上一些博主的使用教程。使用步骤、流程、配置基本大同小异，正确性也没什么毛病，但都是一些基本的Demo例子，作为学习过程没问题；实际项目使用缺乏严谨性，数据量大时可能导致数据异常。
测试平台:
STM32F030C8T6UART1/UART2DMA1 Channel2—Channel5ST标准库主频48MHz（外部12MHz晶振） 5 串口DMA接收 5.1 基本流程 串口接收流程图
5.2 相关配置 关键步骤
【1】初始化串口
【2】使能串口DMA接收模式，使能串口空闲中断
【3】配置DMA参数，使能DMA通道buf半满（传输一半数据）中断、buf溢满（传输数据完成）中断
为什么需要使用DMA 通道buf半满中断？
很多串口DMA模式接收的教程、例子，基本是使用了“空间中断”+“DMA传输完成中断”来接收数据。实质上这是存在风险的，当DMA传输数据完成，CPU介入开始拷贝DMA通道buf数据，如果此时串口继续有数据进来，DMA继续搬运数据到buf，就有可能将数据覆盖，因为DMA数据搬运是不受CPU控制的，即使你关闭了CPU中断。
严谨的做法需要做双buf，CPU和DMA各自一块内存交替访问，即是"乒乓缓存” ，处理流程步骤应该是这样：
【1】第一步，DMA先将数据搬运到buf1，搬运完成通知CPU来拷贝buf1数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c2266e60a963ccb2c0727203dc170d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97a35e45af2934ab188f1a90360c8e7f/" rel="bookmark">
			【Spring源码三千问】为什么要用三级缓存来解决循环依赖问题？二级缓存行不行？一级缓存行不行？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要用三级缓存来解决循环依赖问题 前言版本约定正文分析：如果只使用一级缓存疑问：如果在 createBeanInstance 之后就生成代理对象放入一级缓存呢？ 分析：如果只使用二级缓存Spring 为什么不用二级缓存来解决循环依赖问题？ 辟谣：使用二级缓存解决不了 AOP 代理 bean 的循环依赖？ 小结SpringIoC源码视频讲解： 前言 前面的文章 中，我们分析了 Spring 是怎样使用三级缓存来解决循环依赖的。
使用三级缓存的关键问题是为了解决下面的场景:
当 AOP 代理 bean 被循环依赖时，需要通过第三级缓存 singletonFactories 提前获取到原始 bean 对应的 AOP 代理对象，从而将 AOP 代理 bean 的引用作为依赖注入到目标对象中。
那么，Spring 为什么要用三级缓存来解决循环依赖问题呢？如果只用二级缓存行不行？只用一级缓存呢？
凡事多问几个为什么，理解问题会更加透彻
版本约定 Spring 5.3.9 (通过 SpringBoot 2.5.3 间接引入的依赖)
正文 Spring 做为一个优秀的框架，在设计上肯定有很多的思考。所以，我们猜想如果减少缓存应该是不能达到目的的。
想要证明这个结论，我们只需要各举一个反例就行。
分析：如果只使用一级缓存 首先，我们分析一下，如果只用一级缓存行不行？
只使用一级缓存，也就是将所有的 bean 的实例都放在同一个 Map 容器中。其中就包括已经初始化好的 bean 和未初始化好的 bean。
已经初始化好的 bean: 指经过了 bean 创建的三个阶段之后的 bean 对象
未初始化好的 bean : 指经过了 bean 创建的第一个阶段，只将 bean 实例创建出来了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97a35e45af2934ab188f1a90360c8e7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/130f9d0b43a6b3d32924041270602239/" rel="bookmark">
			Java 打 jar 包的几种方式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、制作只含有字节码文件的 jar 包 只含有字节码文件，即只含有class文件的jar包制作，这是最简单的形式
1、最简单的jar包——直接输出hello 最终生成的jar包结构
META-INF
Hello.class
方法步骤：
1️⃣用记事本写一个Hello.java的文件
class Hello{ public static void main(String[] agrs){ System.out.println("hello"); } } 2️⃣用命令行进入到该目录下，编译这个文件
javac Hello.java
3️⃣将编译后的Hello.class文件打成jar包
jar -cvf hello.jar Hello.class
c表示要创建一个新的jar包，v表示创建的过程中在控制台输出创建过程的一些信息，f表示给生成的jar包命名。
4️⃣运行jar包
java -jar hello.jar 这时会报错：hello.jar中没有主清单属性
添加Main-Class属性：
用压缩软件打开hello.jar，会发现里面多了一个META-INF文件夹，里面有一个MENIFEST.MF的文件，用记事本打开
1 Manifest-Version: 1.0 2 Created-By: 1.8.0_121 (Oracle Corporation) 3 在第三行的位置写入 Main-Class: Hello （注意冒号后面有一个空格，整个文件最后有一行空行），保存。再次运行 java -jar hello.jar，此时成功在控制台看到 hello。
2、含有两个类的jar包——通过调用输出hello 最终生成的jar包结构
META-INF
Tom.class
Hello.class
方法步骤：
1️⃣用记事本写一个Hello.java和一个Tom.java的文件，目的是让Hello调用Tom的speak方法。
class Hello{ public static void main(String[] agrs){ Tom.speak(); } } class Tom{ public static void speak(){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/130f9d0b43a6b3d32924041270602239/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8568d62f435b4307dad83143da932e4d/" rel="bookmark">
			C&#43;&#43;中atan()与atan2()的区别和用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		区别 atan(x)函数接收一个参数。参数类型可参考下列函数声明。
double atan (double x); float atan (float x); long double atan (long double x); double atan (T x); // additional overloads for integral types 若有一个坐标A(a,b)，则函数参数x=b/a。
atan(x)函数返回以弧度为单位的角度，范围为[-pi/2,+pi/2]，注意是包含-pi/2和+pi/2的。该角度为A点和原点的连线与X轴正方向之间的夹角。上方夹角为正，下方夹角为负。由此可以看出，atan()函数只能区分一象限和四象限的点。取一象限和三象限任意一点Ai(ai,bi)计算x=bi/ai，x均为正值。对于二象限和四象限则均为负值。
atan参考
atan2(y,x)函数接收两个参数，即一个坐标值。参数类型可参考下列函数声明。
double atan2 (double y , double x); float atan2 (float y , float x); long double atan2 (long double y, long double x); double atan2 (Type1 y , Type2 x); // additional overloads atan2(x)函数返回以弧度为单位的角度，范围为[-pi,+pi]，注意是包含-pi和+pi的。函数内部考虑了参数x,y 的符号。所以可以区分坐标点在哪个象限。
atan2参考
使用示例 static double normalize(double z) { return atan2(sin(z),cos(z)); } 上述代码实现了不管输入多大的角度值（以弧度为单位），输出均落在[-pi,+pi]里。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8568d62f435b4307dad83143da932e4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/015b0c413954dc186a3cae0812a175f2/" rel="bookmark">
			对Rapidly-exploring Random Trees(RRT)路径规划方法的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RRT与PRM一样，也是概率完备且不最优的。概率完备是指只要解存在就一定能在某一时刻找到。但解不一定是最优的。RRT与PRM相比，有一个优势就是，它在构建图的过程中就在寻找路径。
RRT的主要算法流程 这份基于matlab的代码很好的展示了RRT的算法流程
RRT的优劣分析 优势：
相对于PRM更具有目标导向，它在构建图的过程中就在寻找路径。无需对系统进行建模，无需对搜索区域进行几何划分，在搜索空间的覆盖率高，搜索的范围广，可以尽可能的探索未知区域。 劣势：
RRT得到的路径往往不是最优的。有比较大的优化空间。RRT是在整个地图空间中随机采样点，这样全范围的采样往往效率不高。可以考虑启发式的采样，让采样的点更具有目标导向。在狭窄的通道里不易获得采样点。所以有时无法通过狭窄通道。 在RRT上的改进 Bidirectional-RRT/RRT-Connect 算法流程：
关于双向RRT的介绍来源于：https://www.cnblogs.com/21207-iHome/p/7210543.html
RRT* RRT* 完全继承了RRT的特性，并在其基础上扩展了两个新的特性。正是由于新特性的加入，RRT* 可以生成更优的路径。同时由于算法步骤的增加和collision check的增加，计算消耗也增加了。
下面是RRT* 的算法流程：
其实整个RRT* 算法可以分为三个大的部分。第一部分是继承至RRT的。这一部分和RRT是一样的，就是寻找到 z n e w z_{new} znew​和 z n e a r e s t z_{nearest} znearest​。这一过程就是伪代码中的4，5，6步骤。
near neighbor search
在这一步骤中，我们要为新得到的 z n e w z_{new} znew​找一个合适的父节点。思路是，以 z n e w z_{new} znew​为圆心，以固定的半径 r r r画圆。落在该圆范围内的节点就是 z n e w z_{new} znew​潜在的父节点。我们将 z n e w z_{new} znew​与每个邻近的节点相连（如下图节点 a a a、 b b b），计算 z n e w z_{new} znew​通过哪个邻近节点到达 z i n i t z_{init} zinit​的cost最小。注意，这里的cost一般是指路径长度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/015b0c413954dc186a3cae0812a175f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f70d68040fdf901d516bebcf6ddee93f/" rel="bookmark">
			[深度学习][原创]yolo训练时候提示页面文件太小，无法完成操作5种解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		翻看了很多博客，目前提供有5种方法解决，由于方法众多难以验证。看看具体方法
第一种方法：更改虚拟内存
这种方法可以参考文章：但是更改虚拟内存有个问题，究竟是改anaconda3安装磁盘的虚拟内存还是yolov5源码所在磁盘呢，这个网上都没说清楚。但是更改过我有时候可以解决问题，但是YOLO系列——[WinError 1455] 页面文件太小，无法完成操作_Star星屹程序设计的博客-CSDN博客_yolo页面文件太小
有时候就突然不行了，有个博客说法是其实你即使增加虚拟内存实际也是没用的，参考博客已经禁用了虚拟内存，为什么还提示“页面文件太小 无法完成操作 ”_Ideality_hunter的专栏-CSDN博客
不过这种说法暂时无法证明
第二种方法：更改batch size大小
这种方法是通过降低batch size大小，这种效果我使用时候往往效果很好通常设置1或者2可以很好解决，但是这样一来显存占用就小了训练相对慢
第三种方法：更改num_workers为0或者1
这种方法参考博客：OSError: [WinError 1455] 页面文件太小,无法完成操作_每个脚印都值得被记录-CSDN博客_页面文件太小,无法完成操作
这种方法有时候会有作用，有时候却不行
第四种方法：想办法关掉无关程序尽量在cmd操作
这种是降低内存方法，其实说到底这个报错就是内存不足引起，经过测试发现pycharm即使什么也不干也会吃掉你的2GB内存，所有不用pycharm训练有时候是个明智选择
第五种方法：保证磁盘空间充足
参考博客：
pycharm/pytorch 页面文件太小，无法完成操作_幽哈的博客-CSDN博客_页面文件太小,无法完成操作
这种方法暂时无法验证。不过可能性不大，最可能是C盘情况空间不足造成，但是我放D盘充足时候也会报错。
此外经过我在github查找资料发现，很少有这个报错解决方法。暂时只有这几种解决方法。如果你想不想减少batch size太小我建议清理无关内存然后设置虚拟内存试试，此外降低num_worker值，可能会解决您的问题。如果您看到这个文章说明你大概率遇到这个问题，如果您解决了这个问题请在评论留言，让广大网友参考一下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69fe8dd9daee3e4eef9f700022cbeb6b/" rel="bookmark">
			华为防火墙ssl xxx配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ipsec vpn,gre vpn 适合企业间的连接，要求连接的两端设备都可以配置；如果是出差的员工，或员工在家想连接到企业网的内部，这两类vpn就不能满足条件。
可以使用PPTP VPN ,L2TP VPN,SSL VPN,EZVPN(CISOCO 专有)，其中以SSL VPN最为安全，应用最普遍。
SSL VPN(CISCO称为 web vpn),使用SSL(安全套接层)协议，实现隧道加密数据传输，客户端使用浏览器即可（L2TP要手工在系统中建立一个连接）,浏览器使用HTTPS协议加密数据，客户端只要能上网，连接到SSLVPN设备即可。
本实验使用 EVE-NG平台，华为USG6K防火墙和思科的路由交换机实现。
拓扑：
图中，内网使用ospf 协议，防火墙使用默认路由访问外网。内网服务器使用eve-ng中的linux服务器模拟，如EVE中 没有的话也可以使用桥接到Vmware 中的虚拟机，外网用户模拟客户端，使用vmware中的windows。
准备：eve-ng中添加两块网卡，用于桥接到vmware虚拟机
在eve-ng中查看ip
目标：在防火墙上配置SSL VPN,使windows10客户端，可以访问到内网的web服务器、文件共享服务器、可以远程管理内网交换机、可以访问内网的指定网段。
配置步骤：
1、交换机配置
sw ena conf t ip routing int lo 0 ip add 172.16.100.254 255.255.255.255 int g0/0 ip add 192.168.10.2 255.255.255.0 no sh int g0/1 ip add 172.16.10.1 255.255.255.0 no sh int g0/2 ip add 172.16.20.1 255.255.255.0 no sh exit router ospf 1 net 172.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69fe8dd9daee3e4eef9f700022cbeb6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cfa3c957e6b165c9edb188cd06a2958/" rel="bookmark">
			【lzy学习笔记-dive into deep learning】4.6 暂退法Dropout 的原理与代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4.6.1 重新审视过拟合 线性模型 当⾯对更多的特征而样本不⾜时，线性模型往往会过拟合。相反，当给出更多样本而不是特征，通常线性模型不会过拟合。
不幸的是，线性模型泛化的可靠性是有代价的。简单地说，线性模型没有考虑到特征之间的交互作⽤。对于每个特征，线性模型必须指定正的或负的权重，而忽略其他特征。
深度神经网络 2017年，⼀组研究⼈员通过在随机标记的
图像上训练深度⽹络。这展⽰了神经⽹络的极⼤灵活性，因为⼈类很难将输⼊和随机标记的输出联系起来，但通过随机梯度下降优化的神经⽹络可以完美地标记训练集中的每⼀幅图像。想⼀想这意味着什么？假设标签是随机均匀分配的，并且有10个类别，那么分类器在测试数据上很难取得⾼于10%的精度，那么这⾥的泛化差距就⾼达90%，如此严重的过拟合。
深度⽹络的泛化性质令⼈费解，而这种泛化性质的数学基础仍然是悬而未决的研究问题。
vs 泛化性和灵活性之间的这种基本权衡被描述为偏差-方差权衡（bias-variance tradeoff）
线性模型深度神经网络没有考虑到特征之间的交互作⽤。对于每个特征，线性模型必须指定正的或负的权重，而忽略其他特征。学习特征之间的交互。e.g.可能推断“尼⽇利亚”和“西联汇款”⼀起出现在电⼦邮件中表⽰垃圾邮件，但单独出现则不表⽰垃圾邮件。当给出更多样本而不是特征，通常线性模型不会过拟合。即使我们有⽐特征多得多的样本，深度神经⽹络也有可能过拟合。 4.6.2 扰动的稳健性 好的预测模型 期待好的预测模型能在未知的数据上有很好的表现：经典泛化理论认为，为了缩小训练和测试性能之间的差距，应该以简单的模型为目标。
①简单性以较小维度的形式展现。
e.g. 权重衰减（L2正则化）参数的范数代表了⼀种有⽤的简单性度量。
②简单性的另⼀个⻆度是平滑性，即函数不应该对其输⼊的微小变化敏感。
暂退法dropout的出现 原始论文：
在训练过程中，建议在计算后续层之前向⽹络的每⼀层注⼊噪声。因为当训练⼀个有多层的深层⽹络时，注⼊噪声只会在输⼊-输出映射上增强平滑性。
解读：
暂退法在前向传播过程中，计算每⼀内部层的同时注⼊噪声，这已经成为训练神经⽹络的常⽤技术。这种⽅法之所以被称为暂退法，因为从表⾯上看是在训练过程中丢弃（drop out）⼀些神经元。在整个训练过程的每⼀次迭代中，标准暂退法包括在计算下⼀层之前将当前层中的⼀些节点置零。
如何注入噪声 4.6.3 实践中的暂退法 4.6.4 从零开始实现 源代码遇到的问题
Class Net
import torch from torch import nn import commfuncs def dropout_layer(X, dropout): assert 0 &lt;= dropout &lt;= 1 if dropout == 1: return torch.zeros_like(X) if dropout == 0: return X # 从均匀分布U[0, 1]中抽取样本，样本数与这层神经网络的维度⼀致 # 保留那些对应样本大于p的节点，把剩下的丢弃 mask = (torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cfa3c957e6b165c9edb188cd06a2958/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1556366927bc63712d24597eeb5431c1/" rel="bookmark">
			RNA 3. SCI 文章中基于TCGA 差异表达基因之 DESeq2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 上期我们介绍了基于 limma 来做差异表达基因，那么这期来讲一下 DESeq2，那么这两款软件有什么区别吗？区别主要在于一个是计算芯片探针给出来的结果，而 DESeq2 是基于NGS 测序结果中 Read counts 来计算差异表达，根据输入数据的不同，我们对比一下做法。
在比较高通量测序分析中，一项基本任务是分析计数数据，如 RNA-seq 中每个基因的 Read count，以获得跨实验条件的系统性变化的证据。离散性，大动态范围和异常值的存在需要一个合适的统计方法。DESeq2 是一种计数数据的差分分析方法，使用离散度和折叠变化的收缩估计来提高估计的稳定性和可解释性。这使得更多的定量分析集中在强度上，而不仅仅是差异表达的存在。下面我们就根据这篇文章的数据模式进行差异分析。
01. 软件包安装 安装 DESeq2 软件包，这个包需要通过 BiocManager 来安装，所以首先检测是否安装 BiocManager ，我之前安装过 DESeq2 ，所以不需要重复安装，如果使用 RStudio 安装不成功，可以通过 R 软件安装，运行如下：
if (!require("BiocManager", quietly = TRUE)) install.packages("BiocManager") if (!require("DESeq2", quietly = TRUE)) BiocManager::install("DESeq2") if (!requireNamespace("TCGAbiolinks", quietly=TRUE)) BiocManager::install("TCGAbiolinks") if (!requireNamespace("EDASeq", quietly = TRUE)) BiocManager::install("EDASeq") if (!requireNamespace("SummarizedExperiment", quietly = TRUE)) BiocManager::install("SummarizedExperiment") if (!requireNamespace("EnhancedVolcano", quietly = TRUE)) BiocManager::install("EnhancedVolcano") if (!requireNamespace("limma", quietly = TRUE)) BiocManager::install("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1556366927bc63712d24597eeb5431c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d10a9bb7978136c9383e59e812f80daa/" rel="bookmark">
			【lzy学习笔记-dive into deep learning】4.4 模型选择 欠拟合 过拟合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import math import numpy as np import torch from torch import nn import commfuncs # step 1: 生成数据集(x,y) max_degree = 20 # 设置最大阶数 n_train, n_test = 100, 100 true_w = np.zeros(max_degree) true_w[0:4] = np.array([5, 1.2, -3.4, 5.6]) # 示例给定 features = np.random.normal(size=(n_train + n_test, 1)) # 随机生成x # 默认标准正态 def normal(loc=0.0, scale=1.0, size=None) # print(features.shape) # print(features[:5]) np.random.shuffle(features) # 随机打乱数据 # 开始逐步算y poly_features = np.power(features, np.arange(max_degree).reshape(1, -1)) # broadcasting # print(poly_features[:5,:]) # print(poly_features.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d10a9bb7978136c9383e59e812f80daa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bbb80ad47845272f126b7117c548da4/" rel="bookmark">
			[001] [STM32] 如何下载STM32原厂资料
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32 官网下载 通过STM32CubeMX下载 总结 本文为百问网&amp;韦东山【物联网智能家居实战训练营】课程笔记
1 官网下载 ST官网： https://www.st.com/
直接在搜索框输入使用的芯片型号，如stm32f103c8t6：
然后点击该芯片，进入详情页：
在详情页中有如下主题：
Overview：芯片总体描述，包括电气属性、芯片外设资源等信息Sample &amp; Buy：ST官方样板购买Documentation：该产品的所有文档手册，下面对相对比较重要部分进行说明：
Product Specifications(产品规格)：即数据手册，包含该系列MCU的整体描述、引脚描述、内存映射、电气特性、封装信息、订购信息等。在芯片选型、原理图设计、PCB设计、代码编程等开发环节，都会需要该文档；Reference Manuals(参考手册)：包含该系列MCU各外设寄存器的详细描述，在代码编程时，需要找到对应外设章节，仔细阅读；Programming Manuals(编程手册)：包含闪存编程手册和Cortex-M3内核编程手册，一些资源是在内核里的，比如NVIC和SysTick，此时在参考手册里找不到相关寄存器信息，就需要在Cortex-M3内核编程手册里查找；Errata Sheets（勘误手册）：包含该MCU内核、外设资源的限制，解决方案等，在调试中出现了bug，可以看看该手册是否有类似记录。 CAD Resources：EDA 符号、封装和 3D 模型，一般设计PCB的时候需要用到。Tools &amp; Software：可以看到该产品的所有工具软件，比如各种硬件开发工具、软件开发工具、元件模块、评估工具软件、MCU/MPU嵌入式软件、产品评估工具、解决方案评估工具、工程服务、培训课程等。
Hardware Development Tools：ST-LINK仿真下文件等Software Development Tools：可以下载Keil MDK 与 STM32Cube开发工具。MCU &amp; MPU Embedded Software：可以下载的STM32Cube工具的固件包。
如示例芯片固件包目录如下：
Documentation：里面是本固件包的详细说明文档；Drivers： BSP：板级支持包（Board Support Package），适配ST原厂的几个公板；CMSIS: Cortex微控制器软件接口标准（Cortex Microcontroller Software Interface Standard），包含STM32F1符合CMSIS标准的软件抽象层相关文件（内核寄存器定义、启动文件等）；STM32F1xx_HAL_Driver：ST提供的HAL库驱动，方便快速编写程序； Middlewares： ST：ST提供的图形GUI库“STemWin”、USB从设备库“STM32_USB_Device_Library”、USB主设备库“STM32_USB_Host_Library”；Third_Party：第三方提供的文件系统库“FatFs”、实时性操作系统“FreeRTOS”、网络协议栈“LwIP”; Projects：以ST原厂公板为载体，提供的外设应用示例，比如GPIO、UART、ADC、RTC等；Utilities：一些字体、日志、多媒体等杂项示例。 此外，如果想直接搜索手册，可以选择Resources，输入手册名字，如STM32F10xx Cortex-M3编程手册：
F1系列HAL库开发手册：
其中PM0056和UM1850为手册编号索引，也可以通过它来搜索。
2 通过STM32CubeMX下载 打开软件，点击help：
选择Docs &amp; Resources：
3 总结 MCU开发资料可以直接在芯片厂商官网下载，如数据手册、参考手册、芯片封装等资料；原厂提供的资料比较多，按需求阅读学习即可，搜索关键词定位到相应章节。 END
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/068798f7002c1d9547ee779c133324b5/" rel="bookmark">
			vue3兄弟组件传值方式mitt.js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3中兄弟组件传值的方式mitt 下载mitt
yarn add mitt 或者 npm install mitt 方式一: 在main.js中注册挂载到全局
import { createApp } from 'vue' import { createPinia } from 'pinia' import App from './App.vue' // 导入mitt import mitt from 'mitt' const app = createApp(App) // vue3挂载到全局 app.config.globalProperties.$mitt = new mitt(); app.use(createPinia()).mount('#app') 2.在组建中使用
组件1 发送数据
&lt;template&gt; &lt;h2&gt;组件1: {{money}}&lt;/h2&gt; &lt;button @click="sendMitt"&gt;$mitt发送数据&lt;/button&gt; &lt;/template&gt; &lt;script&gt; import { getCurrentInstance, ref } from 'vue' export default { setup() { let { proxy } = getCurrentInstance() let money = ref(100) function sendMitt() { proxy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/068798f7002c1d9547ee779c133324b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/982c5df9ed7d035474274f8efc06abca/" rel="bookmark">
			为什么采用flask-apscheduler设置的定时任务会重复执行两次函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因：在调试模式下（debug），Flask的重新加载器将加载应用程序两次。因此flask总共有两个进程，重新加载器监视文件系统的更改并在不同的进程中启动真实应用程序。
解决办法：
禁用重新加载器。在启动flask程序的run语句中，将添加use_reloader=False参数即可禁用重新加载器关闭调试模式。同样地，在启动flask程序的run语句中，将debug=True改为debug=False即可关闭debug模式，在部署后真实的运行场景中都会关闭调试模式。 if __name__ == "__main__": # 启动flask程序 # 直接启动，use_reloader=False禁用重新加载器 app.run(host="127.0.0.1", port=5000, debug=True, use_reloader=False) # 只能本机访问 # app.run(host="0.0.0.0", port=5000, debug=True, use_reloader=False) # 外网可以访问 # 以命令行方式启动 # manager.run() （注：第31次发文，如有错误和疑问，欢迎在评论区指出!）
——2022.2.13
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c1f9605dc2a9c3b9f8ba14c3f4c4daf/" rel="bookmark">
			python在操作mysql数据库时，sql语句的字符转义问题可采用escape_string字符转义函数来解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到的问题及解决方法：
遇到的问题：在使用python操作mysql数据库插入数据时，由于变量值也采用了多重引号，导致sql出现语法错误，而无法执行的问题
解决方法：mysql数据库在插入数据时，可以使用escape_string()函数进行特殊字符的转义处理，同时也为了防止数据攻击。
要使用escape_string函数只需要加上from pymysql.converters import escape_string导入此函数即可。
（注：第30次发文，如有错误和疑问，欢迎在评论区指出!）
——2022.2.13
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22bc6dc6283235451eda6a540387a71d/" rel="bookmark">
			【牛客算法】KY45 skew数（C语言char型转int型）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt; #include&lt;math.h&gt; #include&lt;string.h&gt; int main(){ int len,sum,i; char n[100]; while(scanf("%s",&amp;n) != EOF){ len = strlen(n); //string.h sum = 0; for(i = 0;i &lt;len;i++){ sum +=(n[i] - '0') * (pow(2,len - i)-1); printf("%d\n",sum); } return 0; } C语言中char型转换成int型方法：
方法1： char-‘0’；（亲测有效）
方法’2：int char= integer.parseInt(String.valueOf(char)); （还未尝试）
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/68/">«</a>
	<span class="pagination__item pagination__item--current">69/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/70/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>