<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/095d30e7c2503875bc676a37dc36e2bc/" rel="bookmark">
			如何将word翻译成中文？跟我学几招让你的文档秒变中文版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这个国际化的时代，人们需要进行跨语言交流的情况越来越多。在处理文档的时候，有时候我们需要将一些以外语编写的word文档翻译成中文。这种需求在各行各业都非常常见，例如企业中的文件翻译、学术领域中的论文翻译、旅游中的指南翻译等等。对于不熟悉外语的人来说，如何快速、准确地将word文档翻译成中文，是一个非常重要的问题。因此，我今天来给小伙伴们分享几个好用的翻译方法，教大家如何将word翻译成中文。
【方法一】借助全能翻译官APP来实现
全能翻译官是一款支持多种语言翻译的软件，能够将文档、文本、图片等内容进行翻译，支持中、日、韩等多种语言互译。该软件使用了AI技术和自然语言处理技术，可以准确识别文本语言，提供实用的翻译服务。此外，它还支持语音翻译和拍照翻译等功能，方便我们在不同场景下的翻译需求。其中这款软件的文档翻译功能可以直接将pdf、word、ppt等格式的文档导入到应用程序中，然后选择需要翻译的语言即可进行翻译。
【操作步骤】
步骤一：打开全能翻译官，在软件的“工具”页面中，找到“文档翻译”功能。接着在操作页面中，选择好需要翻译的语言，然后通过“上传文档”来将需要翻译的文件导入到软件中。
步骤二：点击需要翻译的文件，软件就会自动将其进行翻译操作，在翻译完成后，我们可以通过“查看文档”功能来浏览文件，也可以通过“立即分享”按钮将其发送给好友。
【方法二】借助百度网盘来实现
百度网盘是一款云存储应用程序，支持在线存储、分享和管理文件。该软件的文档翻译功能可以帮助大家将文档翻译成四种语言，包括英语、日语、韩语、中文。我们可以通过将文档上传到百度网盘中，然后选择需要翻译的语言进行翻译。该软件使用了机器翻译技术，能够实现较为准确的翻译效果。大家可以在翻译后对结果进行查看和编辑，以达到更好的翻译质量。
【操作步骤】
步骤一：打开百度网盘，接着在软件“首页”中找到并点击“我的工具”，在进入到“全部工具”页面后，选择“全文翻译”功能。
步骤二：通过“选择网盘中的文件”功能将需要翻译的文档上传到软件中，待文件识别成功后，根据自身需求选择“文档语言”和“译后语言”。在选择完毕后，点击“开始翻译”按钮即可。
【方法三】借助WPS来实现
WPS是一款功能丰富、界面简洁的办公软件。它包括文字处理、表格处理、演示文稿等多个模块，适用于个人和企业用户。其中，该软件的word模块被广泛使用于各种场景中，例如撰写论文、编写合同等。其中它自带翻译功能，可以将word文档翻译成多种语言，包括中文。此外，它的翻译功能还支持文档整体翻译和选中部分翻译这两种翻译方式，非常灵活方便。
【操作步骤】
步骤一：用WPS打开需要翻译的word文档，接着在软件顶部的菜单栏中找到“审阅”工具。
步骤二：我们可以根据自身的需求在“审阅”工具中的“翻译”功能里选择所需要的翻译类型，然后点击即可。
以上就是关于如何将word翻译成中文的全部内容，大家可以根据自身的需求选择其中一种方法去操作看看哦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70325a4237218ec6ec7eec0a041fd1e2/" rel="bookmark">
			神经网络中的epoch、batch、batch_size、iteration的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		神经网络中的epoch、batch、batch_size、iteration的理解
下面说说这三个区别：
（1）batchsize：批大小。在深度学习中，一般采用SGD训练，即每次训练在训练集中取batchsize个样本训练；
（2）iteration：1个iteration等于使用batchsize个样本训练一次；
（3）epoch：1个epoch等于使用训练集中的全部样本训练一次。
举个例子，训练集有1000个样本，batchsize=10，那么：
训练完整个样本集需要：100次iteration，1次epoch。
1、epoch 当一个完整的数据集通过神经网络一次并且返回一次的过程称为一个epoch。
一个epoch=所有训练样本的一个正向传递和一个反向传递。
然而，当一个epoch对于计算机太过庞大时，就需要把它分成多个小块（batch）。
2、iteration：中文翻译为迭代 iteration是重复反馈的动作，神经网络中我们希望通过迭代进行多次的训练以达到所需的目标或结果。iteration=step
每一次迭代得到的结果都会被作为下一次迭代的初始值。
一个迭代=一个正向通过+一个反向通过。
3、batch 在不能将数据一次性通过神经网络的适合，就需要将数据集分成几个batch。
4、batch_size 直观的理解：一个batch中的样本总数（一次训练所选取的样本数）。
batch_size的大小影响模型的优化程度和速度，同时其直接影响到GPU内存的使用情况。
假如GPU显存不大，该数值最好设置小一点。
5、为什么要提出Batch Size？ 在没有使用Batch Size之前，这意味着网络在训练时，是一次把所有的数据（整个数据库）输入网络中，然后计算它们的梯度进行反向传播，由于在计算梯度时使用了整个数据库，所以计算得到的梯度方向更为准确。
但在这情况下，计算得到不同梯度值差别巨大，难以使用一个全局的学习率，所以这时一般使用Rprop这种基于梯度符号的训练算法，单独进行梯度更新。
在小样本数的数据库中，不使用Batch Size是可行的，而且效果也很好。但是一旦是大型的数据库，一次性把所有数据输进网络，肯定会引起内存的爆炸。所以就提出Batch Size的概念。
6、Batch Size设置合适时的优点 1、通过并行化提高内存的利用率。就是尽量让GPU满载运行，提高训练速度。
2、单个epoch的迭代次数减少了，参数的调整也慢了，假如要达到相同的识别精度，需要更多的epoch。
3、适当Batch Size使得梯度下降方向更加准确。
7、Batch Size从小到大的变化对网络影响 1、没有Batch Size，梯度准确，只适用于小样本数据库
2、Batch Size=1，梯度变来变去，非常不准确，网络很难收敛
3、Batch Size增大，梯度变准确
4、Batch Size增大，梯度已经非常准确，再增加Batch Size也没有用
注意：Batch Size增大了，要到达相同的准确度，必须要增大epoch。
GD（Gradient Descent）：就是没有利用Batch Size，用基于整个数据库得到梯度，梯度准确，但数据量大时，计算非常耗时，同时神经网络常是非凸的，网络最终可能收敛到初始点附近的局部最优点。
SGD（Stochastic Gradient Descent）：就是Batch Size=1，每次计算一个样本，梯度不准确，所以学习率要降低。
mini-batch SGD：就是选着合适Batch Size的SGD算法，mini-batch利用噪声梯度，一定程度上缓解了GD算法直接掉进初始点附近的局部最优值。同时梯度准确了，学习率要加大。
对于mini-batch SGD:
为什么需要有Batch_Size： batchsize的正确选择是为了在内存效率和内存容量之间寻找最佳平衡。
Batch_Size的取值：
全批次（蓝色） 如果数据集比较小，我们就采用全数据集。全数据集确定的方向能够更好的代表样本总体，从而更准确的朝向极值所在的方向。
注：对于大的数据集，我们不能使用全批次，因为会得到更差的结果。
迷你批次（绿色） 选择一个适中的Batch_Size值。就是说我们选定一个batch的大小后，将会以batch的大小将数据输入深度学习的网络中，然后计算这个batch的所有样本的平均损失，即代价函数是所有样本的平均。
随机（Batch_Size等于1的情况）（红色） 每次修正方向以各自样本的梯度方向修正，横冲直撞各自为政，难以达到收敛。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70325a4237218ec6ec7eec0a041fd1e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/257f3f74c0de068fff06c9af178e0401/" rel="bookmark">
			RocketMQ Docker部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 镜像制作前准备 1.1 clone rocketmq-docker项目的代码
#官方的docker地址 git clone https://github.com/apache/rocketmq-docker.git 复制代码 执行上面命令克隆下来这项目的代码。
2. 构建镜像 这里需要构建的镜像有两个
rocketmq-dashboard镜像(web控制台)rocketmq镜像(NameSrv和Broker) 2.1 rocketmq镜像构建
cd image-build sh build-image.sh RMQ-VERSION BASE-IMAGE 复制代码 原理：通过版本和BASE-IMAGE(支持centos, alpine)来判断是使用 Dockerfile-centos文件还是Dockerfile-alpine文件来构建镜像。
等待镜像构建完成，然后通过docker命令查看
docker image ls 复制代码 2.2 rocketmq-dashboard镜像构建
和构建rocketmq镜像一样，我们依葫芦画瓢构建rocketmq-dashboard镜像
cd image-build sh build-image-dashboard.sh dashboard-VERSION BASE-IMAGE 复制代码 BASE-IMAGE只支持centos
等待镜像构建完成。
docker image ls 复制代码 3. Docker-compose 安装 这里为什么用Docker-compose 安装呢？因为RocketMQ的安装的东西有三个部分：namesrv、broker、rocketmq-dashboard ，用Docker-compose安装起来比较方便。
3.1 环境准备
本地已经有了rocketmq-dashboard镜像和rocketmq镜像
在构建rocketmq-dashboard的时候可以修改Dockerfile-centos-dashboard文件的最后一条命令如:ENTRYPOINT ["java","${JAVA_OPTS}", "-jar", "bin/rocketmq-dashboard.jar"]; 这样构建的镜像可以调节JVM的内存大小.好处就是如果你机器内存小就可以将这个内存设置的小一点
3.2 RockerMQ 单机部署
3.2.1 NameSrv的Docker宿主机环境
主要配置的是日志路径以及存储路径。(挂载路径)
mkdir -p /root/rocketmq/data/namesrv/logs mkdir -p /root/rocketmq/data/namesrv/store 复制代码 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/257f3f74c0de068fff06c9af178e0401/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73a41219e6994802d46ada44f8837895/" rel="bookmark">
			redis 底层数据结构详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.字符串
1.1 SDS定义
1.2 SDS1好处
2.列表
2.1 void 实现多态
3 字典
3.1 底层实现是hash表
3.2 字典结构
3.3 哈希算法
3.3.1 rehash
3.3.2 rehash的触发时机
3.3.3 渐进式rehash
扩展或收缩哈希表需要将ht[0]里面的所有键值对rehash到ht[1]里面，但是，这个rehash动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。
4.跳跃表
4.1 跳跃表-zskiplistNode 4.2 跳跃表 - zskiplist
5.压缩列表
1.字符串 Redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组，以下简称C字符串），而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型（对象），并将SDS用作Redis的默认字符串表示。在Redis里面，C字符串只会作为字符串字面量（string literal）用在一些无须对字符串值进行修改的地方，比如打印日志，当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，Redis就会使用SDS来表示字符串值。除了用来保存数据库中的字符串值之外，SDS还被用作缓冲区（buffer）：AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区，都是由SDS实现的 1.1 SDS定义 struct sdshdr { //SDS所保存字符串的长度 int len; // 记录buf数组中未使用字节的数量 int free; // 字节数组，用于保存字符串 char buf[]; }; 1.2 SDS1好处 C 语言的字符串如果想要得到他的长度，需要进行遍历，意味着时间复杂度为 o(N)。如果使用sds，我们的长度直接从len属性里获取，o(1). 本质上，其实就是多了一个len属性，保存了我们的字符串的长度；C语言的字符串如果进行我们的 扩展（增加字符串的长度） 或者 缩减（减少字符串的长度）。 进行扩展：我们必须要提前分配内存空间，一旦忘了分配，造成缓冲区溢出；进行缩减：必须要有意识的进行空间的释放，否则造成空间浪费。无论是进行扩展还是缩减，都需要进行内存的重新分配，耗时啊。 SDS 来说，他不会造成缓冲区溢出的问题，是封装好的对象，他已经为我们考虑了这部分内存的扩展及缩减问题。二进制安全问题。C 语言来说，他的字符串是二进制不安全的，因为C语言的 空字符 结尾的设计，如果一个字符串中间有空字符串，那么 c语言的字符串的二进制转化会遗弃第一个空字符出现的后边的所有内容。 举例： m \0 s g \0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73a41219e6994802d46ada44f8837895/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b5055f1bbea2ee67d275224d1bbe557/" rel="bookmark">
			Redis7搭建主从&#43;哨兵通俗易懂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景前提–用到的命令 ps -ef |grep redis redis服务器启动(精确启动配置文件位置) redis-server redis6379.conf redis-server redis6380.conf redis-server redis6381.conf redis客户端登录 redis-cli -a 123456 -p 6379 redis-cli -a 123456 -p 6380 redis-cli -a 123456 -p 6381 redis客户端登录后查看角色 master/slave info replication redis如何关闭服务器 redis登录客户端后 输入 shutdown redis退出客户端但不关闭服务器 quit 哨兵启动 redis-sentinel sentinel26379.conf --sentinel redis-sentinel sentinel26380.conf --sentinel redis-sentinel sentinel26381.conf --sentinel 哨兵关闭 redis-cli -p 26379 shutdown redis-cli -p 26380 shutdown redis-cli -p 26381 shutdown 背景前提1 安装支持 文件导入命令 rz 然后解压 tar -zxvf redis-7.0.10.tar.gz
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b5055f1bbea2ee67d275224d1bbe557/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e5e929949e6c1ce674ae2376cc8c69e/" rel="bookmark">
			Spring boot 启动类实现 CommandLineRunner
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发中有时候需要实现项目启动后执行相关功能，比如特殊数据初始化处理等。Spring boot提供了CommandLineRunner 来帮我们实现启动时执行一段代码, 示例代码如下:
package com.riskeys.tobtoa; import com.github.xiaoymin.swaggerbootstrapui.annotations.EnableSwaggerBootstrapUI; import com.riskeys.common.base.constant.CodeConstant; import com.riskeys.constants.RouteConstants; import lombok.extern.slf4j.Slf4j; import org.mybatis.spring.annotation.MapperScan; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.boot.CommandLineRunner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.autoconfigure.condition.ConditionalOnClass; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; import org.springframework.cloud.openfeign.EnableFeignClients; import org.springframework.context.annotation.ComponentScan; import org.springframework.transaction.annotation.EnableTransactionManagement; import springfox.documentation.spring.web.SpringfoxWebMvcConfiguration; import springfox.documentation.swagger2.annotations.EnableSwagger2; @Slf4j @EnableDiscoveryClient @EnableFeignClients(basePackages = "com.riskeys") @ComponentScan(basePackages = "com.riskeys") @MapperScan(basePackages = "com.riskeys.**.mapper") @EnableTransactionManagement @EnableSwagger2 @EnableSwaggerBootstrapUI @ConditionalOnClass(SpringfoxWebMvcConfiguration.class) @SpringBootApplication public class BizChannel2b2aApplication implements CommandLineRunner{ @Autowired RabbitTemplate rabbitTemplate; // @Autowired // CodeDictService codeDictService; //系统启动路由刷新开关 0-关闭， 1-开启 @Value("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e5e929949e6c1ce674ae2376cc8c69e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/045d6346c06a8b5363eb062403e49c26/" rel="bookmark">
			C语言中的算数操作符------除号操作符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.有哪些算数操作符： + （加号）
- （减号）
* （乘号）
/ （除号）
% （取余，即取模）
2.除号操作符 / / 两边的操作数如果都是整数，则执行整数除法。而只要有浮点数，执行的就是浮点数除法
使用算数操作符 / 的注意点：
如果用 / 想求出带有小数的值
（1）需要满足两个条件：（a）变量的类型 需要为 浮点数字类型
（b）/ 的两边至少有一个数精确到小数点后
如： double a = 9.0 / 2 ； 得到的结果就是 4.500000
（2）若不满足条件（a） 或者 若不满足条件（b）
得到的数可能不精确，无法展现小数点后面的数
如： int a = 9.0 / 2； 得到的结果就是4
3.补充点： 打印float类型， 需要用 %f
打印double类型，需要用 %lf
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b61b7e636fe384f07b5d43bc205767f0/" rel="bookmark">
			算法与数据结构课程设计——最短距离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# # 最短距离 #基本要求： 设计最短路径，包含以下方面： 1、用邻接矩阵存储一张带权有向图。
2、对图进行从某一源点到其他各顶点的最短路径
3、输出最后结果（路径名称、路径长度）。
信息描述 邻接矩阵建立包括：用二维数组存储信息。没有直达路径的为无穷。
用循环来判断最小值。
最终结果用一维数组存储。
D[]存放源点到其他顶点的最短路径的长度，
P[]存放该顶点最短路径的前驱顶点下标，
visit[]为访问标识。
初始全部值设为F，先把源点的标识设为T，后面每找到一个源点到其余顶点的最短路径，就将该顶点下标对应的标识置为T。直到全部顶点执行完毕。
输出一维数组D[]和P[]，显示最终结果。
在这里插入代码片 #include&lt;stdio.h&gt; #include &lt;iostream&gt; #define MAX 1000 //定义数组长度 #define INFINITY 1000 //定义无穷 struct Graph { int VertexNum; //图中顶点个数 char Vertex[MAX]; //将图的顶点字母存入数组 int AdjMatrix[MAX][MAX]; //设置领接矩阵用两个数组 }; Graph MGraph; char P[MAX][MAX]; //设置图的邻接矩阵 int D[MAX]; //全局设置权值 void CreateGraph(Graph* G); //生成图 调用函数 void ShowGraph(Graph* G); //展示图 调用函数 void ShortestP(Graph* G, char StartVexChar); //测试路径 void ShowP(Graph* G); //展示路径 int main() { char StartVex; CreateGraph(&amp;MGraph); ShowGraph(&amp;MGraph); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b61b7e636fe384f07b5d43bc205767f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0495a382f0348a4868feb40a55dab616/" rel="bookmark">
			蓝桥杯-四平方和（python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.题目 2.python实现 import math n=int(input()) xi=int(math.pow(n/4,1/2)) xj=int(math.pow(n/3,1/2)) xk=int(math.pow(n/2,1/2)) def f(n): for i in range(xi): for j in range(xj): for k in range(xk): t=n-i*i-j*j-k*k m=int(t**0.5) if m&gt;=k and i*i+j*j+k*k+m*m==n: print(i,j,k,m,sep=' ') return f(n) 3.代码解释 导入了 math 库，以便使用其中的 pow 和 sqrt 函数。
通过 int(input()) 从控制台读取一个整数，将其赋值给变量 n。
通过 pow 函数和 sqrt 函数计算出 n/4、n/3 和 n/2 的平方根，将其分别赋值给变量 xi、xj 和 xk。这些平方根将用于限制循环中 i、j 和 k 的取值范围，从而加速计算。
定义一个名为 f 的函数，该函数的参数为整数 n。
在函数 f 中使用三重嵌套的 for 循环，分别枚举 i、j 和 k 的取值范围。其中，i、j 和 k 的取值范围分别是 [0, xi)、[0, xj) 和 [0, xk)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0495a382f0348a4868feb40a55dab616/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d2cd8cab4507bce213d91dc6141a957/" rel="bookmark">
			常见算法模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数学 1.1 素数 素数：只有1和本身两个因子。
2、3、5、7、11、13、17...
1) 单个判断 普通判断算法 O ( n ) O(\sqrt{n}) O(n ​)
public boolean isPrime(int n) { if (n &lt;= 1) return false; for (int i = 2; i * i &lt;= n; i++) { if (n % i == 0) return false; } return true; } 稍快速的判断算法 O ( 1 2 n ) O({1\over2}\sqrt{n}) O(21​n ​)
素数中只有一个2是偶数，其余都是奇数，这些奇素数不可能有偶因子
public boolean isPrime2(int n) { if (n &lt;= 1) return false; if (n == 2) return true; for (int i = 3; i * i &lt;= n; i += 2) { if (n % i == 0) return false; } return true; } 2) 区间判断 循环套单个判断 O ( 1 2 n 3 2 ) O({1\over2}n^{3\over2}) O(21​n23​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d2cd8cab4507bce213d91dc6141a957/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed1c68dfc28add696c122c5189599df2/" rel="bookmark">
			Unity Game FrameWork—模块使用—本地化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方说明：提供本地化功能，也就是我们平时所说的多语言。Game Framework 在本地化方面，不但支持文本的本地化，还支持任意资源的本地化，比如游戏中释放烟花特效也可以做出几个多国语言的版本，使得中文版里是“新年好”字样的特效，而英文版里是“Happy New Year”字样的特效。
语言表xml Demo中有四种语言，路径及内容如下。首先需要把对应的语言写为Xml文件，格式按照Demo的提供的格式来，一个key对应一个value。（格式可以改，后续解析语言表时会说到，解析方式需与语言表的格式对应，否则无法解析成功）本专栏后续会写一个扩展组件，将配置语言表的表格拆分转换为多种语言对应的Xml文件。这里先熟悉语言表怎么使用。
语言设置 启动流程ProcedureLaunch的OnEnter方法进行了语言的设置
public override void OnEnter(ProcedureOwner procedureOwner) { base.OnEnter(procedureOwner); // 语言配置：设置当前使用的语言，如果不设置，则默认使用操作系统语言 InitLanguageSettings(); // 变体配置：根据使用的语言，通知底层加载对应的资源变体 InitCurrentVariant(); // 默认字典：加载默认字典文件 Assets/GameMain/Configs/DefaultDictionary.xml // 此字典文件记录了资源更新前使用的各种语言的字符串，会随 App 一起发布，故不可更新 GameEntry.BuiltinData.InitDefaultDictionary(); } 语言的设置是从SettingComponent设置组件获取数据，首次进入游戏，这个值没有设置，会使用系统默认语言。编辑器模式下，直接使用编辑器配置的语言。
游戏内部更改并保存语言调用SettingForm里的OnSubmitButtonClick方法，可以看到在设置组件设置完成后，停止播放音乐，并重启了游戏框架。代码如下
public void OnSubmitButtonClick() { if (m_SelectedLanguage == GameEntry.Localization.Language) { Close(); return; } GameEntry.Setting.SetString(Constant.Setting.Language, m_SelectedLanguage.ToString()); GameEntry.Setting.Save(); GameEntry.Sound.StopMusic(); UnityGameFramework.Runtime.GameEntry.Shutdown(ShutdownType.Restart); } 语言加载 语言表加载在预加载流程ProcedurePreload里完成，通过语言名称获取加载路径，并读取其中的key-value键值对，写入本地化组件。
语言加载完成后，如下图在UI父类UGuiForm里，获取了UI所有的text组件。并将text当前值作为key去获取对应value，并将value写入text。这里有一个不方便的地方，只有游戏运行时，才能够看到页面适配效果，调试也不方便，只能在运行模式下调试效果。后续本地化扩展会改一下这个地方。
文本需要动态赋值也可以使用同样的方式
text.text = GameEntry.Localization.GetString(key);
资源本地化 官方有提到资源的本地化，可以作为实体或UI去调用
先看一下实体，是通过路径获取预制件，并加载预制件，那么只要语言不一样，设置的路径也不一样就可以实现该功能。
可以在AssetUtility里找到预制件获取路径，类似于语言表，每个语言的资源的路径不同，即可实现获取不同的预制件，从而实现不同的新年好高特效。
再看下UI，不用质疑，UI也是通过路径获取的，同样的操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dba8c2bf93fad08e78107d27f7c842d8/" rel="bookmark">
			远程连接——SSH
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 SSH（Secure Shell）是一种安全通道协议，主要用来实现字符界面的远程登录、远程 复制等功能。SSH 协议对通信双方的数据传输进行了加密处理，其中包括用户登录时输入的用户口令，SSH 为建立在应用层和传输层基础上的安全协议。对数据进行压缩，加快传输速度。
优点：
数据传输是加密的，可以防止信息泄漏
数据传输是压缩的，可以提高传输速度
原理 SSH客户端&lt;--------------网络----------------&gt;SSH服务端
SSH客户端：Putty、 Xshell、CRTSSH服务端：OpenSSH ssh免密码登录主要采用算法：
对称加密算法 原理：采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，由于其速度快，对称性加密通常在消息发送方需要加密大量数据时使用。
特点：计算量小、加密解密的速度比较快，适合数据比较长时的使用； 密钥传输的过程不安全，且容易被破解，密钥管理也比较麻烦。
非对称加密算法 原理：非对称加密算法需要两个密钥：公开密钥（publickey:简称公钥）和私有密钥（privatekey:简称私钥）。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。
特点：非对称加密技术安全性更好，但性能更慢。
安装 Centos 7系统默认已安装openssh相关软件包，并将sshd 服务添加为开机自启动。sshd服务默认使用的是TCP的22端口，安全协议版本sshv2，出来2之外还有1(有漏洞)sshd服务的默认配置文件是/etc/ssh/sshd_ config 检查是否安装：
ssh -V 已经安装如下所示：
(base) [root@localhost homes]# ssh -V OpenSSH_7.4p1, OpenSSL 1.0.2k-fips 26 Jan 2017 (base) [root@localhost homes]# 查看一下和ssh相关的安装包：
# centos yum search ssh # ubantu sudo apt-get install ssh 存在ssh的安装包： (base) [root@localhost homes]# yum search ssh 已加载插件：fastestmirror, langpacks Repository libnvidia-container is listed more than once in the configuration Repository libnvidia-container-experimental is listed more than once in the configuration Repository nvidia-container-runtime is listed more than once in the configuration Repository nvidia-container-runtime-experimental is listed more than once in the configuration Loading mirror speeds from cached hostfile .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dba8c2bf93fad08e78107d27f7c842d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a59c15deb49b41b982e2c54ed359ddcc/" rel="bookmark">
			【数据结构】一元多项式的表示及相加
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ⭐️写在前面的话⭐️一元多项式的表示及相加初始化0_1、初始化链表0_2_1、头插法插入多项式的项(没有相同项)0_2_2、将要插入的相同，链表中有相同项，对应系数相加0_3、从链表中查找是否有相同的指数项0_4、对已经创建好的一元多项式按指数大小进行排序进行(采用冒泡排序)0_5、比较指数值的大小1、输入m项的系数和指数，建立表示一元多项式的有序链表P2、销毁一元多项式P3、打印输出一元多项式P4、返回一元多项式P中的项数5、完成多项式相加运算，即：Pa=Pa+Pb,并销毁Pb主函数 程序源码运行效果 ⭐️写在前面的话⭐️ 📒博客主页： 程序员好冰
🎉欢迎 【点赞👍 关注🔎 收藏⭐️ 留言📝】
📌本文由 程序员好冰 原创，CSDN 首发！
📆入站时间： 🌴2022 年 07 月 13 日🌴
✉️ 是非不入松风耳，花落花开只读书。
💭推荐书籍：📚《Java编程思想》，📚《Java 核心技术卷》
💬参考在线编程网站：🌐牛客网🌐力扣
🍭 作者水平很有限，如果发现错误，一定要及时告知作者哦！感谢感谢！🍭
一元多项式的表示及相加 一个一元多项式可以表示按升序写
两个一元多项式相加
因此，一元多项式的表示及相加可以使用线性表的链式存储结构（单链表）来表示
有关两个结点互换位置的操作：
两个多项式相加的过程：
初始化 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define OK 1 #define ERROR 0 typedef int Status; typedef struct { int coef;//系数 int expn;//指数 }term,ElemType; typedef struct Node { ElemType elem; struct Node *next; }Node,*LinkList; typedef LinkList polynomial; Status InitList(polynomial*);//0_1、初始化链表 Status push_node_head(polynomial*,ElemType);//0_2_1、头插法插入多项式的项 Status sameExpn_list_addCoef(polynomial*,ElemType);//0_2_2、将要插入的相同，链表中有相同项 Status find_list_by_expn(polynomial,int);//0_3、从链表中查找是否有相同的指数项 Status sort_by_expn(polynomial*);//0_4、对已经创建好的一元多项式按指数大小进行排序进行 //0_5、比较指数值的大小 /* a &lt; b,返回 -1 a = b,返回 0 a &gt; b,返回 1 */ int cmp(term,term); //声明函数 Status CreatPolyn(polynomial*,int);//1、输入m项的系数和指数，建立表示一元多项式的有序链表P Status DestoryPolyn(polynomial*);//2、销毁一元多项式P Status PrintPolyn(polynomial);//3、打印输出一元多项式P int PolynLength(polynomial);//4、返回一元多项式P中的项数 Status AddPolyn(polynomial*,polynomial*);//5、完成多项式相加运算，即：Pa=Pa+Pb,并销毁Pb 0_1、初始化链表 //0_1、初始化链表 Status InitList(polynomial *P) { *P=(polynomial)malloc(sizeof(Node)); if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a59c15deb49b41b982e2c54ed359ddcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edc4e6fa5493f7b288684083fdefc15e/" rel="bookmark">
			计算机视觉入门 - MacOS搭建Python的OpenCV环境并在VScode上使用的详细步骤（完整版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
过程：
下载VScode编辑器：
在VScode中安装Python插件： 安装Python解释器：
测试Python程序： 安装wget插件：
安装cmake插件： 安装opencv：
通过程序来测试opencv：
运行成功： 过程： 下载VScode编辑器： 要使用的东西：VScode编辑器、Terminal终端、Homebrew软件包管理工具、Python、OpenCV
首先在Mac上下载VScode编辑器，VScode官网地址：
Visual Studio Code - Code Editing. Redefined
打开官网后，点击Download按钮：
在VScode中安装Python插件： 下载完成之后直接安装，打开VScode，在扩展页面输入Python，如图：
因为我已经安装过了，这里显示的是禁用，在这里之间点击安装即可，安装完了最好把编辑器重新启动一下。 安装Python解释器： 接下来就是Python解释器的安装了，在我之前这篇文章中：
MacOS配置Python开发环境和Pycharm的详细步骤（完整版）https://blog.csdn.net/weixin_45571585/article/details/128606516?spm=1001.2014.3001.5502讲过关于Pycharm和Python的安装步骤，可以进行参考，安装完解释器之后，停留在VScode界面按F1，然后输入：
Python:Select Interpreter 如图：
然后会让你选择，这是我刚才下的解释器，选择就行了，如图：
测试Python程序： 弄完了之后我们来试一下，在桌面上创建一个HelloWorld.py的文件输入以下代码；
msg = "Hello World" print(msg) 然后点击左上角的运行按钮：
如图：成功将Hello World输出，这意味着VScode编辑器中已经可以成功地运行Python程序了。下来我们进入正题，进行OpenCV第三方库的安装。
安装wget插件： 我们打开终端，首先我们要安装wget插件，在终端中输入命令：
brew install wget 如图：
安装cmake插件： 然后进行第二个插件cmake的安装，在终端中输入命令：
brew install cmake 如图：
因为我这里已经安装过了，且Cmake的版本为3.24.2，输入命令即可。
安装opencv： 然后进行第三个插件，也就是我们这篇文章的主旨，opencv第三方库的安装，在终端中输入命令：
brew install opencv 等待完成之后我们来查看安装的opencv信息，输入命令：
brew info opencv 使用brew info opencv命令查看关于opencv的信息：
如图检测到我的opencv版本为4.6.0，且下面的glog等依赖包均已安装完成，如果你输入完命令之后下面的这些插件有一些叉号，你可以使用这条命令对依赖包进行独立的安装；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edc4e6fa5493f7b288684083fdefc15e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27ffa5b502be0c6f29d99124c8b2542d/" rel="bookmark">
			@ComponentScan 注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本使用 @ComponentScan 注解的作用就是根据指定的扫描路径，把路径中符合扫描规则的类装配到 Spring 容器中。
加入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; 复制代码 配置启动类，使用ComponentScan扫描指定包路径 @ComponentScan(basePackages = "com.cxyxj.componentscan.app") public class AppMain { public static void main(String[] args) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppMain.class); // 打印 bean 名称 String[] beanDefinitionNames = context.getBeanDefinitionNames(); for (String name : beanDefinitionNames){ System.out.println(name); } } } 复制代码 运行结果：
org.springframework.context.annotation.internalConfigurationAnnotationProcessor org.springframework.context.annotation.internalAutowiredAnnotationProcessor org.springframework.context.annotation.internalCommonAnnotationProcessor org.springframework.context.event.internalEventListenerProcessor org.springframework.context.event.internalEventListenerFactory appMain 复制代码 除了 Spring 本身注册的一些 bean 之外， AppMain这个类也注册进了容器中。
上述的使用方式，在没什么特殊的要求下，在实际工作当中完全满足项目的开发。@ComponentScan注解还有其他好用的功能，我们有必要了解并会使用。
@ComponentScan注解与XML文件中的context:component-scan标签等效。
&lt;beans&gt; &lt;context:component-scan base-package="com.cxyxj"/&gt; &lt;/beans&gt; 复制代码 注解定义 @Retention(RetentionPolicy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27ffa5b502be0c6f29d99124c8b2542d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c09986d6f85c67510370790dfaabb11/" rel="bookmark">
			springcloud理解及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 SpringCloud总架构图 一、简介 负载均衡的概念 Feign概念 二、入门案例 导入依赖Feign的客户端调用Feign开启Feign功能启动测试Feign实现原理简单分析 三、负载均衡（Ribbon） 四、熔断器支持 五、请求压缩和响应压缩 六、配置日志级别 SpringCloud 架构图 Springcloud 常见的集成方式是使用Feign + Ribbon 来完成服务间远程调用及负载均衡：
1.微服务启动时，会向服务注册中心商报四针实例信息，这里ServiceB包含多个实例。每个实例包括：IP地址、端口信息等配置信息
2.微服务会定期从Nacos获取服务实例列表
3.当ServiceA调用ServiceB时，Ribbon组件从本地服务实例列表中查找ServiceB的实例，如获取了多个实例如：Instance1、Instance2.这时Ribbon会通过用户所配置的负载均衡政策从中选择一个实例
4.最终，Feign组件会通过Ribbon选取的实例发送http请求
采用 Feign + Ribbon 的整合方式，是由Feign完成远程调用的整个流程、而Feign集成了Ribbon,Feign使用Ribbon,来完成调用实例的负载均衡
一、简介 1.负载均衡的概念
在SpringCloud服务协议流程中，ServiceA通过负载均衡调用ServiceB,接下来了解下负载均衡：
负载均衡就是将用户请求通过一定的策略，分摊在多个服务实例执行，它是系统处理高并发、缓解网络压力和进行服务端扩容的重要手段之一，它分为
服务端负载均衡和客户端负载均衡
服务端负载均衡：
客户端负载均衡： 2.Feign概念
Feign英文为"伪装、假装"意思，是一个http请求调用的轻量级框架，是以java接口注解的方式调用Http请求，而不用像Java中通过封装Http请求报文的方式直接调用。
Feign通过处理注解，将请求模板化，当实际调用的时候，传入参数，根据参数再应用到请求上，进行转化成真正的请求，这种请求相对而言比较直观。
Feign被广泛应用在Spring cloud的解决方案中，是学习基于SpringCloud微服务架构不可或缺的重要组件。
封装了Http调用流程，更符合面向接口化的编程习惯
二、入门案例 使用Feign替代RestTemplate发送Rest请求，使之更符合面向接口化的编程习惯。
实现步骤：
1.导入feign依赖步骤
2.编写Feign客户端接口
3.消费者启动引导类开启Feign功能注解
4.访问接口测试
实现过程：
1.导入依赖
2.Figen的客户端
在项目启动类添加注解@EnableFeignClients，启用feign客户端
在SomsFeign中编写客户端接口端 SomsFeign,即接口将是被调用
esc-finder为其他模块服务名称，contract为其他模块控制层父路径，getServiceProduct为具体接口信息、参数等等
Feign会通过动态代理，帮我们生成实现类。
注解@FeignClient声明Feign的客户端，指明服务名称
接口定义的方法，采用SpringMVC的注解。Feign会根据注解帮我们生成URL地址
3.调用Feign
4.Feign实现原理简单分析
Feign帮我们做了哪些事儿：
在 声明Feign客户端 之后，Feign会根据@FeignClient注解使用java的动态代理技术生成代理类，在这里我们指定@FeignClient value为serviceB，则说明这个类的远程目标为spring cloud的服务名称为serviceB的微服务。
serviceB的具体访问地址，Feign会交由ribbon获取，若该服务有多个实例地址，ribbon会采用指定的负载均衡策略选取实例。
Feign兼容spring的web注解（如：@GetMapping），它会分析声明Feign客户端方法中的Spring注解，得出Http请求method、参数信息以及返回信息结构。
当业务调用Feign客户端方法时，会调用代理类，根据以上分析结果，由代理类完成实际的参数封装、远程http请求，返回结果封装等操作。
三、负载均衡 Ribbon核心组件IRule是负载均衡策略接口，它有如下实现，大家仅做了解：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c09986d6f85c67510370790dfaabb11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73aefd662af22984783b760aa79e9de2/" rel="bookmark">
			SpringBoot&#43;Shiro框架整合实现前后端分离的权限管理基础Demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下使用SpringBoot集成Shiro框架实现前后端分离Web项目的过程，后端使用SpringBoot整合Shiro，前端使用vue+elementUI，达到前后端使用token来进行交互的应用，这种方式通常叫做无状态，后端只需要使用Shiro框架根据前端传来的token信息授权访问相应资源。
案例源码：SpringBoot+Shiro框架整合实现前后端分离的权限管理基础Demo
首先新建SpringBoot项目，导入Springboot整合shiro所需要的依赖包
&lt;!-- SpringBoot整合shiro所需相关依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.10.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.10.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--web模块的启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; 使用的SpringBoot版本
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; 使用SpringBoot集合Shiro之前，需要建立相应的类和从数据库获取的用户数据(这里新建一个java静态类来模拟解决)
用户登录的类UserValidate.java
package boot.example.shiro.domain; /** * 蚂蚁舞 */ public class UserValidate { String username; String password; // get set } 用户类SysUsers.java
package boot.example.shiro.domain; /** * 蚂蚁舞 */ public class SysUsers { private Integer user_id; private String username; private String password; private int user_type; // 用户类型 -1表示超级账号 1表示普通账号 private Integer role_id; // 用户角色 拿权限需要的 private Integer locked; // 用户状态 1-正常 2=锁定 public SysUsers() { } public SysUsers(Integer user_id, String username, String password, int user_type, Integer role_id, Integer locked) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73aefd662af22984783b760aa79e9de2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80cdd22d2541a7582c1e5cf4a72d74d1/" rel="bookmark">
			批量查找并替换 txt 记事本文件中的一些关键字内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要：我们平常在处理很多个txt记事本文件的时候，都需要用到查找并替换的功能，然后我们经常使用的是内置的功能，但是这个功能是非常难用的。如果只需要查找并替换一两个关键字的话还可以接受，但是如果我们需要一次性查到并替换多个记事本文件的时候，这个时候该怎么办呢？
当我们需要一次性的查找多个记事本文件中的关键字的时候，这个时候我们头就大了，因为我们平常接触到的批量的搜索记事本文本文件中的文件内容都是一个一个的去搜索的，但是没有软件去批量的去搜索txt格式的记事本文件中的所有的关键字。今天我就遇到了这样一个问题，我需要在我磁盘中的一个文件夹中的所有的记事本文件中的内容都要检查一遍，然后发现有特定的关键字的话，就需要将他们统一的替换为我想要的关键字。
比如说有一些记事本文件中有一些敏感词，然后我需要统一的搜索这些敏感词，让他们统一的替换成星号或者替换成一些特殊符号。那么遇到这个问题该怎么办呢？再没有找到今天这个方法之前呢，我都是手工的去处理的，我也之前也试用过很多软件，但是他们都效果不是很理想，有些会导致我的txt记事本文件在处理后会变成乱码。今天呢就给大家分享一下我现在发现的一个新的方法。
这个方法呢比较简单，它只需要单击几步就可以批量的查找并替换多个txt记事本文件中的一些关键字，注意这里的特点是能够查找并替换多个关键词和多个记事本文件。也就是说它不仅可以一次性查找多个关键字，还可以一次性的将这些关键字的检查机制应用到很多个记事本文件中。
打开「我的ABC软件工具箱」，然后单击批量修改文件内容的功能中。这个功能的主要目的就是先查找记事本文件中的关键字，然后批量的将这些关键字替换成为我们想要的内容。
当我们进入到按规则查找并替换记事本文件内容的功能中之后呢，我们直接单击右上角的添加文件，这个时候我们把我们磁盘中的记事本文件都批量的一次性的添加到软件的列表中就可以了。这里的意思就是让软件知道我们需要处理txt记事本文件，并且这些文件有很多个。
当我们选择完需要处理的txt记事本文件中之后了，我们直接单击下一步，然后这个时候软件就提示我们设置批量查找的规则，这个时候我们一定要选择精确文本。精确文本的意思就是说我们告诉软件需要精确查找这些关键词，然后我们填写一下旧内容，填写旧内容的意思就是告诉软件在现有的记事本文件中查找这些关键词。填写新内容的意思就是说告诉软件，将我们前面查到的关键字统一的替换成我们想要的关键字。
当我们填写完批量查找并替换的规则之后，让我们直接单击下一步，然后这个时候软件就会自动扫描我们所添加的所有的txt记事本文件中的文本内容，并且呢批量地将它们替换成我们想要的文字。如果这个记事本文件中的文本内容不包含我们需要查找的内容，那么它是不会替换的，这里只会替换我们已经查找到的关键字。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03842860cacfdce8dd67825bb00af75e/" rel="bookmark">
			批量删除多个 Word 文件中的多个关键字文字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要：Word文件应该是我们用的最多的文件了，我们平常在整理word的时候避免不了去修改这些word文件，但是呢，大家有没有遇到过批量处理word文件的场景呢。这里就给大家演示一下如何批量删除多个word关键字，也就是说一次性的将所有的word文件中的某一些关键字全部删除掉。
Word文件是我们用的最多的文档格式，有时候在需要对word文件进行统一的文件整理的时候，一定需要用到批量的查找word文件中的关键字。今天呢，我们遇到了一个问题，就是如何批量的删除Word文件中的多个关键字，我们以往在一个word中查找的时候，我们直接使用word的内置的功能查找并替换。一个文件一个文件地搜索我们需要查找的多个关键字，并且把这些word中的关键字都一次性的删除掉，这里的限制就是我们有多个关键字，并且有多个Word文件，我们都希望在一次完整的操作中，能够将它们统一的进行处理掉。
今天就给大家讲解一下，如何批量的删除多个word文件中的多个关键字。大家如果有遇到需要批量处理word文件的时候，一定要看一下这里的介绍，当我们掌握到了这个批量删除多个关键字的方法之后呢，我们的办公技能又多了一个知识点，并且呢，这个技能很少有人会使用。当我们掌握了这个批量删除多个word文件中的关键字的方法，那么我们以后再遇到需要删除word关键字的问题的时候就可以迎刃而解，就可以提高办公效率。
打开「我的ABC软件工具箱」进入到批量查找替换文件内容的功能中，这个功能可以支持对word文件进行批量的搜索关键字，如果搜索到这些关键字的话，我们可以将这些关键字替换为新的内容，也可以批量的将这些关键字删除掉。
当我们进入到批量查找跟替换文件内容的功能中之后呢，我们直接单击右上方的添加文件，这个时候我们将需要查到并替换关键字的word内容的word文件全部一次性的添加到下面的待处理列表中，添加到这里的意思就是告诉软件我们需要让软件自动搜索这些word文件中的关键字。
当我们添加完word文件之后，我们直接单击下一步，这个时候软件会提示我们设置查找的规则，我们这里选择批量查找精确文本，然后输入多个关键字，大家一定要仔细的看一下下面截图的内容，每一行代表一个独立的关键字，由于我们是一次性的查找多个关键字，因此我们需要添加多行。
当我们填写完需要在word中搜索的关键字之后呢，我们就会发现在替换为的内容中不用填写，因为如果我们填写的话，这里就变成了查找并替换，这里给大家演示的是删除这些关键字，因此我们可以使用这样的空白操作来代表的删除。然后呢，我们直接单击下一步，如果这些Word文件包含某个关键字的话，软件会一次性的将这些关键字都给批量的删除掉。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba5a418d2f21e0a062bd7d6f5f19d863/" rel="bookmark">
			【wpf】DataGrid的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DataGrid动态生成 简单方式 动态生成实现需要设置AutoGenerateColumns="True"，
&lt;DataGrid Name="dataGrid" AutoGenerateColumns="True" /&gt;
后台dataGrid.ItemsSource = infoList;
infoList，就是一个类似Json的数组结构数据：
[ { "columnChName": "孔宽1", "nominalDim": 17.28, "tolMax": 0.02, "tolMin": 0.02, "usl": 17.3, "lsl": 17.26 }, { "columnChName": "孔从中心偏移3", "nominalDim": 17.28, "tolMax": 0.02, "tolMin": 0.02, "usl": 17.3, "lsl": 17.26 }, { "columnChName": "孔从中心偏移6", "nominalDim": 17.28, "tolMax": 0.02, "tolMin": 0.02, "usl": 17.3, "lsl": 17.26 }, { "columnChName": "孔从中心偏移5", "nominalDim": 13.84, "tolMax": 0.05, "tolMin": 0.05, "usl": 13.89, "lsl": 13.79 }, { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba5a418d2f21e0a062bd7d6f5f19d863/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/39/">«</a>
	<span class="pagination__item pagination__item--current">40/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/41/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>