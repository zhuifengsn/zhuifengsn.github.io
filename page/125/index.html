<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3573a43b7783c61ebeea5b96284f574c/" rel="bookmark">
			Linux设备驱动开发详解-Note(1)---设备驱动概述(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设备驱动概述(1) 成于坚持，败于止步
设备驱动的作用 任何一个计算机系统的运行都是系统中软硬件协作的结果，没有硬件的软件是空中楼阁，而没有软件的硬件则只是一堆废铁。硬件是底层基础，是所有软件得以运行的平台，代码最终会落实为硬件上的组合逻辑与时序逻辑；软件则实现了具体应用，它按照各种不同的业务需求而设计，满足了用户的需求。硬件较固定，软件则很灵活，可以适应各种复杂多变的应用。可以说，计算机系统的软硬件互相成就了对方。 但是，软硬件之间同样存在着悖论，那就是软件和硬件不应该互相渗透到对方的领地。为了尽可能快速地完成设计，应用软件工程师不想也不必关心硬件，而硬件工程师也难有足够的闲暇和能力来顾及软件。例如，应用软件工程师在调用套接字发送和接收数据包的时候，不必关心网卡上的中断、寄存器、存储空间、I/O 端口、片选以及其他任何硬件词汇；在使用 printf()函数输出信息的时候，他不用知道底层究竟是怎样把相应的信息输出到屏幕或串口。 也就是说，应用软件工程师需要看到一个没有硬件的纯粹的软件世界，硬件必须被透明地呈现给他们。谁来实现硬件对应用软件工程师的隐形？这个艰巨的任务就落在了驱动工程师的头上。 对设备驱动最通俗的解释就是“驱使硬件设备行动”。设备驱动与底层硬件直接打交道，按照硬件设备的具体工作方式读写设备寄存器，完成设备的轮询、中断处理、DMA 通信，进行物理内存向虚拟内存的映射，最终使通信设备能够收发数据，使显示设备能够显示文字和画面，使存储设备能够记录文件和数据。 由此可见，设备驱动充当了硬件和应用软件之间的纽带，它使得应用软件只需要调用系统软件的应用编程接口（API）就可让硬件去完成要求的工作。在系统中没有操作系统的情况下，工程师可以根据硬件设备的特点自行定义接口，如对串口定义SerialSend()、SerialRecv()；对 LED 定义 LightOn()、LightOff()；以及对 Flash 定义FlashWrite()、FlashRead()等。而在有操作系统的情况下，设备驱动的架构则由相应的操作系统定义，驱动工程师必须按照相应的架构设计设备驱动，这样，设备驱动才能良好地整合到操作系统的内核中。 驱动程序沟通着硬件和应用软件，而驱动工程师则沟通着硬件工程师和应用软件工程师。随着通信、电子行业的迅速发展，全世界每天都会有大量的新芯片被生产，大量的新电路板被设计，因此，也会有大量设备驱动需要开发。这些设备驱动，或运行在简单的单任务环境中，或运行在 VxWorks、Linux、Windows等多任务操作系统环境中，发挥着不可替代的作用。 无操作系统时的设备驱动
并不是任何一个计算机系统都一定要运行操作系统，在许多情况下操作系统是不必要的。对于功能比较单一、控制并不复杂的系统，如公交车刷卡机、电冰箱、微波炉、简单的手机和小灵通等，并不需要多任务调度、文件系统、内存管理等复杂功能，
用单任务架构完全可以很好地支持它们的工作。一个无限循环中夹杂对设备中断的检测或者对设备的轮询是这种系统中软件的典型架构:
1 int main(int argc, char* argv[]) 2 { 3 while (1) 4 { 5 if (serialInt == 1) 6 /*有串口中断*/ 7 { 8 ProcessSerialInt(); /*处理串口中断*/ 9 serialInt = 0; /*中断标志变量清零*/ 10 } 11 if (keyInt == 1) 12 /*有按键中断*/ 13 { 14 ProcessKeyInt(); /*处理按键中断*/ 15 keyInt = 0; /*中断标志变量清零*/ 16 } 17 status = CheckXXX(); 18 switch (status) 19 { 20 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3573a43b7783c61ebeea5b96284f574c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00cb18b86744be3d644676332f3971b0/" rel="bookmark">
			内核参数module_param的有关操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内核参数module_param的有关操作 定义一个内核参数比较简单
module_param（参数变量名字，类型，访问权限）
MODULE_PARM_DESC（参数变量名字，“参数说明描述”）
如果需要限制或者检查用户输入的参数的值，比如说限制输入的整型数是 256～512的某个范围等等，输入的一定是某个特定字符串等。那么可以用这个宏。这个支持你传进去一个参数处理的回调函数。
module_param_call 2.6.35 以下
module_param_cb 2.6.38 这里我只针对module_param_cb 做一下说明，module_param_call 用法类似，看内核中的定义：
/** * module_param_cb - general callback for a module/cmdline parameter * @name: a valid C identifier which is the parameter name. * @ops: the set &amp; get operations for this parameter. * @perm: visibility in sysfs. * * The ops can have NULL set or get functions. */ #define module_param_cb(name, ops, arg, perm)	\ __module_param_call(MODULE_PARAM_PREFIX,	\ name, ops, arg, __same_type((arg), bool *), perm) 1、name是你要定义的变量的名字
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00cb18b86744be3d644676332f3971b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3a1bc354c5fdccff02a85e72147045b/" rel="bookmark">
			mini2440 uboot使用nfs方式引导内核，文件系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mini2440 uboot使用nfs方式引导内核，文件系统 成于坚持，败于止步
看了一段时间的u-boot了，到今天才真正完全实现u-boot引导内核和文件系统，顺利开机，在此记录完整过程
1、首先如果你u-boot还没有一直也没有关系，这里上传了一个已经移植好的u-boot，版本问2010.03，多谢tekkaman分享的这个源码
分享下载地址：u-boot-2010.03
编译uboot的过程就不在多说了，解压到你希望的目录下执行make，当时事前安装好交叉编译工具，这个相信大家都会
编译完成之后生成uboot.bin文件，使用mini2440自带的USB下载方式下载到开发板，选择v命令下载即可
开机界面如下，你的可能不完全显示的一样，这是经过我修改的
U-Boot 2010.03 (Jun 20 2013 - 08:43:59) Modified by Seal (king_haitao@163.com) Study Linux and love linux forever!! Study u-boot I2C: ready DRAM: 64 MB Flash: 2 MB NAND: 256 MiB Video: 240x320x16 20kHz 62Hz In: serial Out: serial Err: serial USB slave is enable! Net: dm9000 Hit any key to stop autoboot: 0 [u-boot@MINI2440]# 然后就要开始考虑怎么下载内核了，不错，要引导内核首先你需要把内核下载的你的内存中，那么首先配置好你的下载环境是最重要的
2、linux nfs安装与配置
在ubuntu下安装、配置nfs服务的步骤如下： 安装nfs Ubuntu上默认是没有安装nfs服务器的，因此我们首先安装nfs服务器端： $sudo apt-get install nfs-kernel-server 在一些文档中，提出还需要使用apt-get来手动安装nfs的客户端nfs-common，以及端口映射器portmap，但其实这是没有必要的，因为在安装nfs-kernel-server时，apt会自动为我们把它们安装好。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3a1bc354c5fdccff02a85e72147045b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eb44259a0ffd064819973c6c6359e37/" rel="bookmark">
			Camera -- takePicture流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、framework frameworks/base/core/java/android/hardware/Camera.java
/** * Equivalent to takePicture(shutter, raw, null, jpeg). * * @see #takePicture(ShutterCallback, PictureCallback, PictureCallback, PictureCallback) */ public final void takePicture(ShutterCallback shutter, PictureCallback raw, PictureCallback jpeg) { takePicture(shutter, raw, null, jpeg); } private native final void native_takePicture(int msgType); /** * Triggers an asynchronous image capture. The camera service will initiate * a series of callbacks to the application as the image capture progresses. * The shutter callback occurs after the image is captured.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8eb44259a0ffd064819973c6c6359e37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1876f44ae434d9256d11c1ecd47504e/" rel="bookmark">
			新建word文档默认作者如何修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方式一：
安装Office时，提示输入用户名称时输入你想设置的作者姓名，之后每次新建word文档的默认作者就是填写的用户名了。
方式二：
菜单栏--&gt;工具--&gt;选项--&gt;弹出的“选项”框中选择“保存”选项卡--&gt;选中“提示保存文档属性”。
以后再新建word文档，在初次保存的时候，弹出框会问你作者、标题之类的信息，就可以设置了。
方式三：
excel文件的摘要、作者等默认属性值修改办法：工具--&gt;选项--&gt;常规，改用户名成你的名字。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67633489001c7ca394c746607f8e79f7/" rel="bookmark">
			Framebuffer应用程序编程实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Framebuffer应用程序编程实例 转载地址： http://hi.baidu.com/fenhuashu/item/f4e0fa9df1babafb291647f4 编程流程： (1) 打开设备 open("/dev/fb0",O_RDWR); (2) 获取framebuffer设备信息.ioctl(int fb,FBIOGET_FSCREENINFO,&amp;finfo); ioctl函数是实现对设备的信息获取和设定，
第一个参数为文件描述符，第二个参数为具体设备的参数，对于framebuffer,参数在linux/fb.h中定义的。
#define FBIOGET_VSCREENINFO 0x4600 //获取设备无关的数据信息fb_var_screeninfo #define FBIOPUT_VSCREENINFO 0x4601 //设定设备无关的数据信息 #define FBIOGET_FSCREENINFO 0x4602 //获取设备无关的常值信息fb_fix_screeninfo #define FBIOGETCMAP 0x4604 //获取设备无关颜色表信息 #define FBIOPUTCMAP 0x4605 //设定设备无关颜色表信息 #define FBIOPAN_DISPLAY 0x4606 #define FBIO_CURSOR _IOWR('F', 0x08, struct fb_cursor) 第三个参数是存放信息的结构体或者缓冲区 (3) 内存映射 mmap函数。
头文件：sys/mman.h
常用用法：mmap(0,screensize,PROT_RD　｜PROT_WR,MAP_SHARED,int fb,0)返回映射的首地址。
实例:
#include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;fcntl.h&gt; #include &lt;linux/fb.h&gt; #include &lt;sys/mman.h&gt; #include &lt;stdlib.h&gt; int main() { int fbfd = 0; struct fb_var_screeninfo vinfo; struct fb_fix_screeninfo finfo; long int screensize = 0; char *fbp = 0; int x = 0, y = 0; long int location = 0; int sav=0; /* open device*/ fbfd = open("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67633489001c7ca394c746607f8e79f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5e7fccd5895a124a6c9f3b9d59470b9/" rel="bookmark">
			WPF界面加载显示数据库表中内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后台代码 Window1.xaml.cs
private void dataGrid1_Loaded(object sender, RoutedEventArgs e) { DataTable dt= SqlHelper.ExecuteTable("select * from T_user"); dataGrid1.ItemsSource = dt.DefaultView; } 前台使用dataGrid控件绑定
&lt;Grid&gt; &lt;DataGrid AutoGenerateColumns="False" Height="200" HorizontalAlignment="Left" Margin="37,12,0,0" Name="dataGrid1" VerticalAlignment="Top" Width="200" ItemsSource="{Binding}" Loaded="dataGrid1_Loaded"&gt; &lt;DataGrid.Columns&gt; &lt;DataGridTextColumn Header="姓名" Binding="{Binding Path=name}"&gt;&lt;/DataGridTextColumn&gt; &lt;DataGridTextColumn Header="性别" Binding="{Binding Path=sex}"&gt;&lt;/DataGridTextColumn&gt; &lt;DataGridTextColumn Header="住址" Binding="{Binding Path=address}"&gt;&lt;/DataGridTextColumn&gt; &lt;/DataGrid.Columns&gt; &lt;/DataGrid&gt; &lt;/Grid&gt; 转载于:https://blog.51cto.com/redtea/1170263
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e0c09e0a56e2a2289bcbcd35f1be8b6/" rel="bookmark">
			基于单链表的多项式问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上学期的东西了，不想再去细究思路了，直接贴代码，注释很详细
#pragma once #include&lt;iostream&gt; using namespace std; class LinkNode { public: float coef;//系数 int expn;//指数 LinkNode *link;//指向后继的指针域 LinkNode *plink;//指向前驱的指针域 public: LinkNode(); LinkNode(float co,int ex); ~LinkNode(); friend istream&amp; operator&gt;&gt; (istream&amp; input,LinkNode&amp; L);//输入重载 friend ostream&amp; operator&lt;&lt; (ostream&amp; output,LinkNode&amp; L);//输出重载 //friend operator= () }; #include"LinkNode.h" #include&lt;iostream&gt; using namespace std; LinkNode::LinkNode() { expn = -1; } LinkNode::LinkNode(float co,int ex) { coef = co; expn = ex; link = NULL; plink = NULL; } LinkNode::~LinkNode() {} //istream&amp; operator&gt;&gt; (istream&amp; input,LinkNode&amp; L) //{ //input&gt; //} ostream&amp; operator&lt;&lt; (ostream&amp; output,LinkNode&amp; L) { if(L.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e0c09e0a56e2a2289bcbcd35f1be8b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3998c1f92c45d66b6447304c3441a26/" rel="bookmark">
			Wi-Fi直连
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这几天看wifi直连的内容，对其中的api还不熟悉，总是看一个就去网上搜，好麻烦。所以果断的将下面文章(http://wiki.eoeandroid.com/Wi-Fi_Direct)给复制下来供参考使用。 Wi-Fi 直连 Wi-Fi 直连技术允许已经配备了相应硬件并预装了Android 4.0(API level 14)或更后的操作系统的设备在不需要Wi-Fi中间热点的支持下通过Wi-Fi直接互联的技术。使用这些API,你可以发现和连接其他支持此技术的设 备，然后以距离远超蓝牙连接技术且速度更快的方式进行通信。这项技术对于一些多用户共享资料，比如多用户联机游戏或者相片分享等应用非常有用。
Wi-Fi直连技术的API包含以下主要部分：
允许用户发现，请求然后连接对等设备的各种方法，定义在WifiP2pManager类中。允许用户定义收到调用WifiP2pManager类中方法成功或失败的通知的监听器。当用户调用WifiP2pManager类中的方法时，每一个方法都可以收到一个以参数形式传过来的特定监听。通知用户被Wi-Fi直连技术框架检测到的特定事件的意图，比如一个已丢掉的连接或者一个新的对等设备的发现等。 你经常会同时使用这三个主要组件的相关功能。例如，你可以为去调用android.net.wifi.p2p.WifiP2pManager.ActionListener) discoverPeers()方法而提供一个WifiP2pManager.ActionListener的监听器，这样以后你可以收到一个ActionListener.onSuccess()或者ActionListener.onFailure()方法的通知。一个WIFI_P2P_PEERS_CHANGED_ACTION意图同时也是当android.net.wifi.p2p.WifiP2pManager.ActionListener) discoverPeers()方法发现的对等设备列表发生改变时的一个广播。
API 概述 WifiP2pManager类提供了很多方法允许用户通过设备的Wi-Fi模块来进行交互，比如做一些如发现，连接其他对等设备的事情。下列的方法都是可以使用的： 表格1.Wi-Fi直连技术方法
方法名详细描述 initialize()
通过Wi-Fi框架对应用来进行注册。这个方法必须在任何其他Wi-Fi直连方法使用之前调用。
connect()]
开始一个拥有特定设置的设备的点对点连接。
cancelConnect()
取消任何一个正在进行的点对点组的连接。
requestConnectInfo()
获取一个设备的连接信息。
createGroup()
以当前设备为组拥有者来创建一个点对点连接组。
removeGroup()
移除当前的点对点连接组。
requestGroupInfo()
获取点对点连接组的信息。
discoverPeers()
初始化对等设备的发现。
requestPeers()
获取当前发现的对等设备列表。
WifiP2pManager的方法可以让你在一个监听器里传递参数，这样Wi-fi直连框架就可以通知给你的窗体这个方法调用的状态。可以被使用的监听器接口和使用监听器的相应的WifiP2pManager的方法的调用都将在下面这张表中有所描述：
表格 2. Wi-Fi直连监听器方法
监听器接口相关联的方法 WifiP2pManager.ActionListener
connect(), cancelConnect(), createGroup(), removeGroup(), and discoverPeers()
WifiP2pManager.ChannelListener
initialize()
WifiP2pManager.ConnectionInfoListener
requestConnectInfo()
WifiP2pManager.GroupInfoListener
requestGroupInfo()
WifiP2pManager.PeerListListener
requestPeers()
Wi-Fi直连技术的API定义了一些当特定的Wi-Fi直连事件发生时作为广播的意图，比如说当一个新的对等设备被发现，或者一个设备的Wi-Fi状态的改变。你可以在你的应用里通过创建一个处理这些意图的广播接收器来注册去接收这些意图。
Table 3. Wi-Fi 直连意图
意图名称详细描述 WIFI_P2P_CONNECTION_CHANGED_ACTION
当设备的Wi-Fi连接信息状态改变时候进行广播。
WIFI_P2P_PEERS_CHANGED_ACTION
当调用discoverPeers()方法的时候进行广播。在你的应用里处理此意图时，你通常会调用requestPeers()去获得对等设备列表的更新。
WIFI_P2P_STATE_CHANGED_ACTION
当设备的Wi-Fi 直连功能打开或关闭时进行广播。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3998c1f92c45d66b6447304c3441a26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d6fd52205391582e25a2262cce8c85d/" rel="bookmark">
			比较两个文档中的文字的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 比较两段文字的区别的几种方法：
首先，什么时候才需要这个功能，我想，只有当两段文字非常相似的时候才会使用这个功能。比如我昨天看代码，两段代码非常相似，我看了N久也没发现他们的区别。但是，使用软件就能很轻松的知道他们的差异。
第一种方法：使用DOS。
首先，运行（windows+R），输入CMD，进入dos界面。然后输入命令“fc 文件1 文件2”，注意空格，而且文件名中不可以有空格。具体情况可以输入help fc 可以查看fc的帮助。
简单介绍下dos中的复制，粘贴。在dos界面的标题栏上右击，按P，选择属性。弹出如下窗口，选中，选项---编辑选项---快速编辑模式。其实吧，按D，默认值，也同样可以设置。设置完这个就可以快速编辑，在界面上用鼠标一选，回车，就能将所有选中的文字复制下来。而粘贴的话，只需要右击就能将复制的文字粘贴了。
完整演示下整个命令。
fc C:\Users\***\Desktop\新建文本文档(3).txt C:\Users\***\Desktop\新建文本文档(4).txt.
但是由于DOS本身的原因感觉这个不是很直观。
所以从网上找了一个软件。
第二种方法，小软件。这个软件的地址：文本比较器 对比两个TXT文本有什么不相同 ，这个软件下面有人说里面有病毒，不过我用360杀毒查了下，没毒。但是这次我用猎豹浏览器进入这个网站，猎豹显示说那个网站是 ，我郁闷了！
不过，用“文本比较器”做关键字，可以搜到很多其他的文本比较器，应该有一款适合的。 下载完后，解压，打开exe。这个软件的界面相当简单，就是先打开那两个要比较的文件，选完之后点中间蓝色的比较。OK，不同的地方会用红色字体显示，相当直观。
方法3：使用Word自带的功能，比较。
详情请见：word比较 ，点进去文章的下半部分。实在太懒，不想重写。以下请看图。为了保持一致性，所以用的同样两段文字，但是word比较好像只能比较word文档，所以把那两段文字随便找了两个word文档，粘贴了进去。
总结：上面几种方法都能够用来查看两段文字之间的区别。但是都不是我想要的，因为我就想，两段不同的文字，我直接复制粘贴上去，然后就能直接比较。而不用分别将两段文字放到两个文档中，然后对文档进行比较。
方法1：优点，较快捷，系统自带的功能，不用担心中毒神马的。
缺点：显示起来不直观，而且对文件名有要求，不能有空格；而且需要复制粘贴文件路径。
方法2：优点，快捷，显示起来直观。而且，免安装。
缺点：万一有毒怎么办？而且只能比较txt类型的文档
方法3：优点，应该连图片什么的都能比较吧，较直观（其实看起来挺费劲的，不过只看中间的比较文档，还是挺方便的）
缺点：打开word的时间会要了我的老命啊！word开启时间太长！工作起来，也不快。只能比较word类型的文档。
这篇文档写完之后，发现一些问题，然后又去查询了一些文本比较器，普特文本比较器，这个比较器的优点是：网站无毒，至少猎豹显示是安全的；可以支持复制，粘贴，免安装。然后他的显示和Word的是一样的，这点不好，我不是很喜欢想word那样的显示。还有就是选择性比较少，只能完成基本功能。
然后是文本比较器TextDiff3.5，这个的优点是，网站无毒，然后比较完，显示的方法和第二种基本一样，支持复制粘贴（不过将文本粘贴进去后，需要给那两个文本分别保存，自己取名，才能比较，不好用），选项很多，可以支持多种比较（还没怎么用）。缺点，需要安装。
我更喜欢普特文本比较器，可以直接复制粘贴比较文本，方便。 普特文本比较器下载链接： 普特文本比较器 （如果这个不弹出下载项，吐槽下，猎豹是想闹那样啊，用遨游能下载，用你就无网页）就从这下载普特文本比较器 TextDiff3.5下载链接：TextDiff3.5 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3975b8b825f0dfb66c0dd19be18c97d3/" rel="bookmark">
			牛人总结python中string模块各属性以及函数的用法，果断转了，好东西
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：http://blog.chinaunix.net/uid-25992400-id-3283846.html
任何语言都离不开字符，那就会涉及对字符的操作，尤其是脚本语言更是频繁，不管是生产环境还是面试考验都要面对字符串的操作。 python的字符串操作通过2部分的方法函数基本上就可以解决所有的字符串操作需求： python的字符串属性函数python的string模块 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 字符串属性函数 系统版本：CentOS release 6.2 (Final)2.6.32-220.el6.x86_64 python版本：Python 2.6.6 字符串属性方法
字符串格式输出对齐
1.&gt;&gt;&gt; str='stRINg lEArn'2.&gt;&gt;&gt;3.&gt;&gt;&gt; str.center(20) #生成20个字符长度，str排中间4.' stRINg lEArn '5.&gt;&gt;&gt; 6.&gt;&gt;&gt; str.ljust(20) #str左对齐7.'stRINg lEArn ' 8.&gt;&gt;&gt;9.&gt;&gt;&gt; str.rjust(20) #str右对齐10.' stRINg lEArn'11.&gt;&gt;&gt; 12.&gt;&gt;&gt; str.zfill(20) #str右对齐，左边填充013.'00000000stRINg lEArn' 大小写转换
1.&gt;&gt;&gt; str='stRINg lEArn' 2.&gt;&gt;&gt; 3.&gt;&gt;&gt; str.upper() #转大写4.'STRING LEARN'5.&gt;&gt;&gt; 6.&gt;&gt;&gt; str.lower() #转小写7.'string learn'8.&gt;&gt;&gt; 9.&gt;&gt;&gt; str.capitalize() #字符串首为大写，其余小写10.'String learn'11.&gt;&gt;&gt; 12.&gt;&gt;&gt; str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3975b8b825f0dfb66c0dd19be18c97d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d1e9abaa60fc92be1ad1e3fc3c7e035/" rel="bookmark">
			java源码分析之ArrayList
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ArrayList就是传说中的动态数组，就是Array的复杂版本，它提供了如下一些好处：动态的增加和减少元素、灵活的设置数组的大小......
认真阅读本文，我相信一定会对你有帮助。比如为什么ArrayList里面提供了一个受保护的removeRange方法？提供了其他没有被调用过的私有方法？
首先看到对ArrayList的定义：
public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 从ArrayList&lt;E&gt;可以看出它是支持泛型的，它继承自AbstractList，实现了List、RandomAccess、Cloneable、java.io.Serializable接口。
AbstractList提供了List接口的默认实现（个别方法为抽象方法）。
List接口定义了列表必须实现的方法。
RandomAccess是一个标记接口，接口内没有定义任何内容。
实现了Cloneable接口的类，可以调用Object.clone方法返回该对象的浅拷贝。
通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。序列化接口没有方法或字段，仅用于标识可序列化的语义。
ArrayList的属性
ArrayList定义只定义类两个私有属性：
/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. */ private transient Object[] elementData; /** * The size of the ArrayList (the number of elements it contains). * * @serial */ private int size; 很容易理解，elementData存储ArrayList内的元素，size表示它包含的元素的数量。 有个关键字需要解释：transient。 Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。 transient是Java语言的关键字，用来表示一个域不是该对象串行化的一部分。当一个对象被串行化的时候，transient型变量的值不包括在串行化的表示中，然而非transient型的变量是被包括进去的。 有点抽象，看个例子应该能明白。 public class UserInfo implements Serializable { private static final long serialVersionUID = 996890129747019948L; private String name; private transient String psw; public UserInfo(String name, String psw) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d1e9abaa60fc92be1ad1e3fc3c7e035/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20ab49cee933b86a888be75b07734647/" rel="bookmark">
			vncserver的使用简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vncserver的使用简介 (2008-04-22 12:43) 分类： linux服务器 VNC 的使用 1、启动vncserver 用ssh／telnet登录服务器，在终端执行命令vncserver :display# 2、客户端连接vncserver（安装一个vnc客户端，例如TightVNC）
点击start－&gt;Programs－&gt;TightVNC－&gt;TightVNC Viewer，输入vncserver:display# 3、退出vnc客户端 如果在全屏模式下，请退出全屏模式后直接点击窗口右上角的“X”；或点击菜单栏下的红色“X”按钮；或者在窗口左上角的菜单里选择“关闭” 4、关闭vncserver 用ssh／telnet登录服务器，在终端执行命令vncserver -kill :display#
也可以在vnc的客户端的终端提示符下操作。
VNC server常用参数说明 -geometry 用来设定vnc的分辨率，默认是1024x768，如果要在19寸以上的显示器全屏使用vnc，则通常使用该参数：-geometry 1280x1024，这里连接分辨率数值的符号是小写字母“x”。具体要看你打算用多大的分辨率。 -depth 用来设定vnc的色彩，默认是16，由于有些软件使用16位颜色会造成软件无法启动，故建议使用24。 VNC 使用注意事项 1、退出客户端时不能在系统中点击“exit”，按钮。必须使用disconenet按钮，或者直接点击VNC窗口上方的X来关闭窗口。否则将无法再用vnc clinet登录。解决方法为登录到vncserver，关闭vncserver，再启动vncserver。这里所说的是关闭vncserver进程，并不是要关闭服务器的电源！ 2、setdisplay的语法：vncserver:display#.0 3、在linux下登陆solaris出现的退格键兼容性问题解决方法(即vncserver是linux操作系统)：用客户端连到vncserver后，打开终端，菜单上选择Edit-&gt;Profiles-&gt;Edit-&gt;Compatibility，将Backspace key generates的值从ASCII DEL改为Control-H。 4、在linux作为vncserver时，登陆后需要执行xhost +来接受远程主机的信号。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7867124e1b11819880de69d4ba072c53/" rel="bookmark">
			Windows应用程序依赖性检查工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 确定您的Windows应用程序依赖于那些DLL的最全面的方式是使用随VisualC++提供的依赖项查看器（Depends.exe）打开该应用程序。Depends.exe安装在VS(6.0/2005/2008/2010等)安装目录下的CommonX\Tools\Bin中（X根据安装VS的版本不同而不同）。请注意，VS6.0时默认安装该工具的，但是之后的版本，只有当您选择Win32 Windows SDK工具（它位于Visual C++自定义安装的“Visual C++工具”类别中）时，才会安装Depends.exe。 当没有安装Depends.exe时，您可以从http://www.dependencywalker.com/网站上下载。DependencyWalker是一个扫描所有32位和64位Windows模块的免费工具，它创建一个所有依赖模块的层次树。对于每个找到的模块，它会列出所有被该模块导出的函数，这些函数实际上会被其它模块所调用。 X86下载网址：http://www.dependencywalker.com/depends22_x86.zip X64下载网址：http://www.dependencywalker.com/depends22_x64.zip 此外，该工具支持X86、Alpha、AXP64、MIPS和PowerPC架构的Windows操作系统。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e865a01e3f55c4b720a2106bf23e7e63/" rel="bookmark">
			【JAVA基础】RTTI 和 Reflection
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		outline 1) 什么是RTTI？ 2）RTTI应用场景？（什么情况下要直接使用RTTI，什么机制是基于RTTI实现的即间接使用了RTTI) 3) 直接使用RTTI：Class&lt;?&gt;,如何获得类的Class对象 3）Reflection和RTTI的区别 运行时定位class (运行时定位class ；编译时就要定位class) 4）Reflection机制的使用包括Class和Reflection API 5) Reflection机制支持了哪些场景框架、机制？ ------------------------------------splitter---------------------------- 什么是RTTI 在运行时识别一个对象的类型，即RTTI的基本功能 提出RTTI功能需求场景 举例： List&lt;Shape&gt; shapeList = Arrays.asList(new Circle(), new Square(), new Triangle()); 容器把其所容纳的元素都当做Object持有，在取出每个元素时，转换成Shape； 这个例子中RTTI类型转换不彻底，Object只被转化成Shape，而不是具体的Circle等。这是因为编译时，通过容器和泛型系统保证集合中元素中时Shape类型，仅此而已；所以在运行时只会完成类型转换到Shape。 如果有进一步需求，明确集合元素Shape类型更加进一步的类型Circle、Square、Triangle.......这个也需要RTTI机制。 另外，总结来说： 1）传统类型转换，由RTTI确保类型转换的正确性；如”（Shape）“,如果执行了一个错误的类型转换会抛出”ClassCastException“ 2）获取类Class对象，通过这个对象获取运行时需要的类型信息 3）instanceof关键字也需要RTTI支持（Class.isInstance方法） RTTI机制原理 J ava中使用每个类的Class对象来保存运行时类型信息的。 每个新类编译后，其对应产生一个Class对象，被一同保存在对应的.class文件中。 类加载器在加载这个类的同时会创建这个类的Class对象。 Java是动态加载类的，即只有在需要时才加载；对比C++是静态加载的，即程序运行开始就将所有类加载。 Java类动态加载的时机： 1）对该类的第一次静态成员的访问 2）调用该类的构造方法时 如何获取一个类的Class对象？ 1）Class.forName() 2）某个类对象实例getClass()方法【定义在Object类中】 3）某个类的静态成员Foo.class java.lang.Class&lt;T&gt;类 Class 没有公共构造方法。 Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的。 1）Class&lt;?&gt; Class&lt;? extends &gt; Class&lt;? super &gt;用法 2）Class.isInstance 3) instanceof Class对象比较区别 instanceof 可以体现继承层次 Derived instance of Base[TRUE] Derived.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e865a01e3f55c4b720a2106bf23e7e63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb29df3265781e979c3c11a6b536d49e/" rel="bookmark">
			Bash scripting Tutorial
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Hello World Bash Shell Script First you need to find out where is your bash interpreter located. Enter the following into your command line:
$ which bash Open up you favorite text editor and a create file called hello_world.sh. Insert the following lines to a file:
NOTE:Every bash shell script in this tutorial starts with shebang:"#!"which is not read as a comment. First line is also a place where you put your interpreter which is in this case: /bin/bash.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb29df3265781e979c3c11a6b536d49e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0963a310b3c365182c4345a2c4cd702d/" rel="bookmark">
			开源PACS服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		名称：Dcm4che
评级：★★★★★
开源许可：GPL LGPL MPL
功能： 影像处理，影像归档，影像管理，影像传输，Worklist支持
标准：DICOM，HL7，IHE，MPPS，WADO
语言：英语
客户端： 桌面，基于web
平台：跨平台
编程语言：Java
数据库：MySQL，Postgre SQL，Firebird
官方网站：http://www.dcm4che.org/
名称：DCMTK-DICOM Toolkit
评级：★★★★★
开源许可：BSD
功能： 影像处理，影像归档，影像管理，影像传输
标准：DICOM
语言：英语
客户端： 桌面
平台：跨平台
编程语言：C/C++
官方网站：http://dicom.offis.de/
名称：CDMEDIC PACS WEB
开源许可：GPL
功能： 影像处理，影像归档，影像管理，影像传输
标准：DICOM
语言：英语，西班牙语
客户端： 基于web
平台：Unix，Mac OS
官方网站：http://cdmedicpacsweb.sourceforge.net/
名称：Conquest DICOM software
开源许可：Public Domain
功能： 影像处理，影像归档，影像管理，影像传输，数据转换，Worklist支持
标准：DICOM，HL7
语言：英语
客户端： 基于web
平台：Unix，Windows，Mac OS
官方网站：http://www.xs4all.nl/~ingenium/dicom.html
名称：ClearCanvas
评级：★★★★★
开源许可：BSD
功能： 影像处理，影像归档，影像管理，影像传输，影像浏览
标准：DICOM
开发语言：C#
客户端： 桌面
平台：Windows
官方网站：http://www.clearcanvas.ca/
名称：mdcm
评级：★★★★
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0963a310b3c365182c4345a2c4cd702d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d72cbb7e506237a0b9f40d451f310888/" rel="bookmark">
			VNC介绍及相关命令总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		What is VNCserver? VNC stands for Virtual Network Computing. It was originally developed by AT&amp;T as a way to administer machines without using the console. If you have used Windows Terminal Services (RDP), VNC will seem very familiar. Why use VNCserver? In Linux, everything can be done from a shell. However, there may be a time when you need to access the machine as if you were at the console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d72cbb7e506237a0b9f40d451f310888/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4dae2cb234434db86c0ea3b05dc6119/" rel="bookmark">
			运行时类型识别(RTTI)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们知道，有两个操作符可以提供RTTI：
&lt;1&gt;typeid操作符 这个操作符可以与任何类型的表达式使用，如果操作数不是含有虚函数的类对象，则返回操作数的静态类型，如果操作数是含有虚函数的类对象，则返回操作数的动态类型。
&lt;2&gt;dynamic_cast操作符 这个操作符可以安全的将基类类型的指针或者引用转换为派生类类型的指针或者引用。
这两个操作符的应用场景有些区别，dynamic_cast只能用在至少含有一个虚函数的类的指针或引用的转换上，如果这个类不含有虚函数，则会报错：基类不支持多态。而typeid可以用于任何场合。
单纯的理论总是难以理解的，例子才是王道，OK，来几个例子：
1.typeid的使用 （不含虚函数的类中）
#include "stdafx.h"
#include &lt;iostream&gt;
using namespace std;
class Base
{
};
class Derived:public Base
{
};
int _tmain(int argc, _TCHAR* argv[])
{
Base * pb;
Derived d;
pb = &amp;d;
if(typeid(d) == typeid(*pb))
{
cout &lt;&lt; "返回的是动态类型" &lt;&lt; endl;
}
else
{
cout &lt;&lt; "返回的是静态类型" &lt;&lt; endl;
}
return 0;
}
这个的输出是:
返回的是静态类型。
分析：因为这个类不含有虚函数，所以*pb返回的是静态类型，即是一个Base类型的对象，因而自然执行else语句呢。
2.typeid的使用 （含虚函数的类中）
#include "stdafx.h"
#include &lt;iostream&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4dae2cb234434db86c0ea3b05dc6119/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b16853abdfc041aa002ffe5185b721e4/" rel="bookmark">
			Fedora9本地安装配置中文输入法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前虚拟机安装Fedora9的时候，只想用来做嵌入式开发用，因此很多组件都没有安装。后面随着程序的不断增大和算法的不断增加，英文注释难以让人看明白了（主要还是自己英文水平比较差），装一个中文输入法的需求就日益迫切了。网上找了很多东西，但都是需要上网安装的，没办法，只好放弃。后来，一不小心点入了一个博客，他是用iso镜像安装的^_^，遂学习之~~
参考地址http://hi.baidu.com/yuandianliws/blog/item/ec1523de8ca8ab14632798e2.html。
方法是：
1、把安装盘安上（我的是在虚拟机上安装的，选择iso文件到虚拟光驱，并选在虚拟机上）
2、把/etc/yum.repos.d下的所有的文件备份出去，并建立了一个local.repo文件，内容是：
[local]
name=Fedora $releasever - $basearch
failovermethod=priority
baseurl=file:///media/Fedora%209%20i386%20DVD
enabled=1
gpgcheck=1
gpgkey=file:///media/Fedora%209%20i386%20DVD/RPM-GPG-KEY
3、在终端里面输入命令 yum install scim*
4、修改配置文件vim /etc/X11/xinit/xinitrc.d/50-xinput.sh
找到下面的语句： _language_list="as bn gu hi ja kn ko ml mr ne or pa si ta te th ur vi zhen"
在后面添加蓝色的部分（即en）。
5、重启Fedora
6、设置热键切换
依次选择System-&gt;Preferences-&gt;Personal-&gt;Input Method，勾选Enable input method feature，点击Input Method Preferences按键进入，在左边选择FrontEnd-&gt;Global Setup，进入热键设置菜单，点击Trigger后面的...，在弹出的对话框中点击Key Code后面的...，按下Ctrl和空格键，点击Add键，然后一路OK。
但是，还有一个小问题，Fedora9的im-chooser有个小bug，选择Input Method就会崩溃掉，不能进入设置。解决这个问题的方法是对im-chooser进行升级。通过联网方式升级就不说了。对于Fedora不能联网的童鞋，可以去下载这几个rpm包（因为这个版本对其他包的依赖较小，所以就选这个了~~），手动升级。点击下载
具体方法是：
1、先查询是否有安装这几个包的其它版本，有的话就卸载掉（因为其他包有可能会依赖这几个包，所以强制卸载）
例如， 查询 rpm -q im-chooser
强制卸载 rpm -e im-chooser --nodeps 2、因为包的依赖关系，按如下顺序依次安装
rpm -ivh imsettings-libs-0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b16853abdfc041aa002ffe5185b721e4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/124/">«</a>
	<span class="pagination__item pagination__item--current">125/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/126/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>