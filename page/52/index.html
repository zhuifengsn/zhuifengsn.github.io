<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65aac9d3635128a4422860196eaeae23/" rel="bookmark">
			输入一个数，判断为星期几。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里有两种写法，可以用最直观的写法判断，用if语句；
#include&lt;stdio.h&gt; int main() { int day; scanf("%d",&amp;day); if(1==day) printf("星期1\n"); else if (2==day) printf("星期2\n"); else if (3==day) printf("星期3\n"); //....同理写到星期日 return 0; } 第二种语句，使用switch语句实现多分支结果
#include&lt;stdio.h&gt; int main() { int day; scanf("%d",&amp;day); switch(day) { case 1: printf("星期1\n"); break; case 2: printf("星期2\n");break; case 3: printf("星期3\n");break; case 4: printf("星期4\n");	break; case 5: printf("星期5\n");break; case 6: printf("星期6\n");break; case 7: printf("星期日\n");break; } } 这里重点讲一下switch 语句 switch语句的一般形式如下：
switch(表达式）
{
case 常量1：语句1
case 常量2：语句2
case 常量n：语句n
default ：语句n+1 这里说明一下可以没有default标号，此时如果没有与switch表达式匹配的case常量，则不执行任何语句，流程转到switch语句的下一个语句
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65aac9d3635128a4422860196eaeae23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f59e9f1be20adc4992b9b6bc7029ddce/" rel="bookmark">
			STM32F103C8T6基于HAL库移植uc/OS-III
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、UCOS系统简介1.版本介绍2.UCOSIII的任务简介3.UCOSIII的系统任务4.UCOSIII的任务状态5.UCOSIII的任务详解 二、STM32CubeMX工程创建1.创建新项目2.选择芯片3.配置RCC4.配置SYS5.设置GPIO6.设置串口USART17.设置时钟树8.设置工程 三、获取uCOS-III源码四、移植前的文件准备及移植过程1.找到下载好的文件夹2.复制文件到MDK-ARM文件夹下3.打开cubeMX生成的keil文件，将uCOS文件添加到项目中4.分别给新增的文件夹添加文件5.导入文件路径 五、构建多任务环境1.代码添加2.修改部分代码3.初始化管脚4.撰写主函数5.程序编译及生成hex文件6.电路连接7.程序烧录8.串口调试9.运行结果 六、总结七、参考链接 一、UCOS系统简介 1.版本介绍 UCOS是Micrium公司出品的RTOS类实时操作系统， UCOS目前有两个版本：UCOSII和UCOSIII。
◉UCOSIII是一个可裁剪、可剥夺型的多任务内核，而且没有任务数限制。
◉UCOSIII提供了实时操作系统所需的所有功能，包括资源管理、同步、任务通信等。
◉UCOSIII是用C和汇编来写的，其中绝大部分都是用C语言编写的，只有极少数的与处理器密切相关的部分代码才是用汇编写的， UCOSIII结构简洁，可读性很强！最主要的是非常适合初次接触嵌入式实时操作系统学生、嵌入式系统开发人员和爱好者学习。
2.UCOSIII的任务简介 在UCOSIII中任务就是程序实体，UCOSIII能够管理和调度这些小任务（程序）。UCOSIII中的任务由三部分组成：任务堆栈、任务控制块和任务函数。
✦任务堆栈：上下文切换的时候用来保存任务的工作环境，就是STM32的内部寄存器值；
✦任务控制块：任务控制块用来记录任务的各个属性；
✦任务函数：由用户编写的任务处理代码，是实实在在干活的。一般写法如下：
void XXX_task(void *p_arg) {
while(1)
{
… //任务处理过程
}
}
◉可以看出用任务函数通常是一个无限循环，当然了，也可以是一个只执行一次的任务。任务的参数是一个void类型的，这么做的目的是可以可以传递不同类型的数据甚至是函数。
◉可以看出任务函数其实就是一个C语言的函数，但是在使用UCOIII的情况下这个函数不能有用户自行调用，任务函数何时执行执行，何时停止完全有操作系统来控制。
3.UCOSIII的系统任务 UCOSIII默认有5个系统任务：
◉空闲任务：UCOSIII创建的第一个任务，UCOSIII必须创建的任务，此任务有UCOSIII自动创建，不需要用户手动创建;
◉时钟节拍任务：此任务也是必须创建的任务;
◉统计任务：可选任务，用来统计CPU使用率和各个任务的堆栈使用量。此任务是可选任务，由宏OS_CFG_STAT_TASK_EN控制是否使用此任务;
◉定时任务：用来向用户提供定时服务，也是可选任务，由宏OS_CFG_TMR_EN控制是否使用此任务;
◉中断服务管理任务：可选任务，由宏OS_CFG_ISR_POST_DEFERRED_EN控制是否使用此任务。
前两个系统任务时必须创建的任务，而后三者不是。控制后三者任务的宏都是在文件OS_CFG.h中。
4.UCOSIII的任务状态 从用户的角度看，UCOSIII的任务一共有5种状态：
◉休眠态：任务已经在CPU的flash中了，但是还不受UCOSIII管理；
◉就绪态：系统为任务分配了任务控制块，并且任务已经在就绪表中登记，这时这个任务就具有了运行的条件，此时任务的状态就是就绪态；
◉运行态：任务获得CPU的使用权，正在运行；
◉等待态：正在运行的任务需要等待一段时间，或者等待某个事件，这个任务就进入了等待态，此时系统就会把CPU使用权转交给别的任务；
◉中断服务态：当发送中断，当前正在运行的任务会被挂起，CPU转而去执行中断服务函数，此时任务的任务状态叫做中断服务态。
这5种状态之间相互转化的关系如下图：
5.UCOSIII的任务详解 （1）任务堆栈
任务堆栈是任务的重要部分，堆栈是在RAM中按照“先进先出（FIFO）”的原则组织的一块连续的存储空间。为了满足任务切换和响应中断时保存CPU寄存器中的内容及任务调用其它函数时的需要，每个任务都应该有自己的堆栈。
◉任务堆栈创建
代码如下：
#define START_STK_SIZE 512 //堆栈大小 CPU_STK START_TASK_STK[START_STK_SIZE]; //定义一个数组来作为任务堆栈
◉任务堆栈的大小
CPU_STK为CPU_INT32U类型，也就是unsigned int类型，为4字节的，那么任务堆栈START_TASK_STK的大小就为：512 X 4=2048字节。
◉任务堆栈初始化
任务切换回上一个任务并且还能接着从上次被中断的地方开始运行的办法是恢复现场，现场就是CPU的内部各个寄存器。因此在创建一个新任务时，必须把系统启动这个任务时所需的CPU各个寄存器初始值事先存放在任务堆栈中。这样当任务获得CPU使用权时，就把任务堆栈的内容复制到CPU的各个寄存器，从而可以任务顺利地启动并运行。
把任务初始数据存放到任务堆栈的工作就叫做任务堆栈的初始化，UCOSIII提供了完成堆栈初始化的函数：OSTaskStkInit()。
CPU_STK *OSTaskStkInit (OS_TASK_PTR p_task,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f59e9f1be20adc4992b9b6bc7029ddce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aa74c8a53493a4867d68bff0567b5d8/" rel="bookmark">
			单片机控制直流电机(风扇)电路详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单片机引脚为什么无法直接控制电机或风扇？
我们在使用单片机去控制+5V的直流电机或者散热风扇时，可能会有一种疑惑，51单片机的引脚电压为+5V，为什么不直接用单片机引脚去驱动电机或者风扇？
实际上单片机的控制引脚，不管是51单片机或者stm32单片机的引脚一般只是作为信号电流，其引脚驱动能力都比较弱，一般都在10-20mA；我们查看STM32单片机规格书可知，其引脚的驱动电流最大为25mA。
而5V直流电机或者散热风扇工作电流一般都在100mA以上，如果直接接到单片机引脚上，当引脚输出高电平时，引脚的电压可能在1-2V，导致无法驱动电机及风扇。
所以为了提高单片机引脚的驱动能力，我们往往要使用三极管或者MOS管作为驱动元件，单片机通过三极管或MOS管的通断，间接来控制电机或风扇，以此达到增大单片机引脚的驱动能力。
51单片机引脚控制
采用51单片机控制来控制+5V直流电机或者风扇时，一般可采用NPN和PNP两种方式（或NMOS和PMOS两种）；NPN及PNP电路如下图：
NPN驱动电路
PNP驱动电路
NPN（NMOS）驱动电路为高电平导通，低电平截止；PNP（PMS）驱动电路为低电平导通，高电平截止。两种电路的电流驱动能力取决于所使用的三极管或MOS管，而单片机引脚只起到电路开关作用。
Stm32单片机引脚控制
如果采用stm32单片机来控制+5V的电路，由于单片机的电平范围为0-3.3V，其控制电路还需要再改造一下。
在说明改造电路前需说明一下，stm32单片机引脚只有部分引脚能耐受+5V电压，部分是无法耐受+5V电压。至于如何判断该引脚是否能耐受+5V电压，可查看stm32单片机规格书，如果该引脚标注由“FT”字样，表示该引脚可耐受+5V电压。如图：
为了使单片机引脚能匹配驱动电路的控制电平，需让单片机引脚输出高电平时，电压能达到+5V。其方法主要由两种；第一种单片机引脚设置为开漏输出，然后引脚使用10k电阻上拉至+5V，如图：
这样就可使stm32单片机输出高电平时，电压为+5V。
第二种方法是单片机引脚设置为推挽输出，驱动电路采用NPN+PNP（或NPN+NPN）电路，单片机引脚使用+3.3V电压控制NPN电路，NPN电路输出+5V电压来控制NPN电路。(NPN+PNP模式为单片机输出高电平导通；NPN+NPN模式为单片机输出低电平导通)；其控制电路如图：
只要单片机引脚控制电平与驱动电路所要求的控制电压匹配，单片机采用较稳定地控制驱动电路。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13c48270dd9e60bccec9b2d4cd11c988/" rel="bookmark">
			【nginx】快速入门——SpringBoot项目代理及图片代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nginx快速入门 1. 简介2. Ngnix下载2. Nginx启动与停止2.1 启动2.2 关闭2.3 重新启动 3. Ngnix配置文件4. SpringBoot项目代理5. 图片代理6. 代理html页面 1. 简介 nginx(engine x)是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。
Nginx专为性能优化而开发，性能是器最重要的考量，实现上非常注重效率，能经受高负载的考验，据报告能支持高达50,000个并发连接数。
Nginx不仅能做反向代理，实现负载均衡；还能可以作正向代理来进行上网等功能
本文只讲诉nginx如何在windows上配置SpringBoot项目以及图片转发代理，linux配置也类似。
2. Ngnix下载 官网下载链接：下载
选择相应版本即可，本文是在Windows上配置的。因此选择的是windows版本。
下载完成后直接解压即可。
Linux版本安装可以参考这个文章：ubuntu安装nginx
2. Nginx启动与停止 2.1 启动 方法1：直接双击启动
方法二 命令行方式启动：
进入nginx根目录，然后通过start ngnix即可启动
D:\StduyApp\nginx-1.20.2&gt;start nginx 2.2 关闭 进入nginx根目录，通过命令 nginx -s stop即可关闭
D:\StduyApp\nginx-1.20.2&gt;nginx -s stop 2.3 重新启动 进入nginx根目录，通过命令 nginx -s reload即可关闭
D:\StduyApp\nginx-1.20.2&gt; nginx -s reload 3. Ngnix配置文件 在根目录里面有一个conf文件夹，下面有一个nginx.conf文件。
其中，我们主要编写的配置，就是这个 server代码块。这个server，可以有多个，里面配置的location也可以有多个。如下图所示
4. SpringBoot项目代理 启动Springboot项目 首先我们启动两个最简单的springboot项目。第一个端口为8081，返回的是一个字符串我是Nginx代理的页面，端口是8081
在启动第二个Springboot项目，端口是8082，返回字符串为我是8082端口的页面。
修改配置文件 server { listen 80; server_name localhost; # localhost主页，直接访问 http://localhost 就会跳转 location / { root html; index index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13c48270dd9e60bccec9b2d4cd11c988/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/106dc3cf1167611f6e2454ac7262256d/" rel="bookmark">
			黑盒测试的5种方法介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、常见的黑盒测试方法
（1）等价类划分法；
（2）边界值分析法；
（3）错误推断法；
（4）因果图法；
（5）场景法；
（6）正交实验法；
（7）判定表法；.....
2、方法具体介绍
（1）等价类划分法
a.概念：把程序的输入域划分成若子集，从每个部分中选取少数代表性数据作为测试用例。 b.说明：每一类代表性数据在测试中的租用等价于这一类中的其他值；等价类划分法是一种典型的，并且是最基础的黑盒测试用例设计方法；采用等价类划分法时，完全不用考虑程序内部结构，设计测试用例的唯一依据是软件需求规格说明书；被测程序若是正确的，就应该既能接受有效的输入，也能接受无效输入的考验。
c.使用场景：有数据输入（编辑框）的地方，可以使用等价类划分法。例如用户登录、注册、新建、查询。
d.优点：等价类划分的测试用例设计方法减少了穷举法带来的大量测试用例，保证测试效果和测试效率，一般是有输入性需求的被测对象可以采用的方法；
e.缺点：输入与输入之间的关系考虑少，可能产生一些逻辑错误。还需要其他用例设计方法来补充测试。
f.使用步骤：第一，确定等价类；第二，建立等价类表；第三，生成测试用例。
g.分类：有效等价类和无效等价类。有效等价类代表对程序的有效输入，而无效等价类代表的则是其他任何可能的输入条件（即不正确的输入值）。
（2）边界值分析法
a.概念：在长期的测试工作中，人们发现大量的错误都是出现在了输入和输出域的边界范围上，而并不是输入范围的内部。因此要对各种边界情况设计测试用例，以查找出更多的错误。
b.说明：边界值属于等价类方法的特定输入域，包含在有效等价类或无效等价类中，根据等价类推断理论，边界值方法产生的测试数据测试效果和等价类方法相同，只是边界值方法产生的数据更具有针对性，通常选取输入域的边界值。
c.使用场景：通常情况下，软件测试所包含的边界检验有几种类型，数字、字符、位置、重量、大小、速度、方位、尺寸、空间等。
d.使用方法：相应的，以上类型的边界值应该在：最大/最小、首位/末位、上/下、最快/最慢、最高/最低、最长/最短、空/满 等情况下。
（3）错误推断法
a.概念：错误推测法就是基于经验和直觉推测程序中所有可能存在的各种错误，有针对性地设计测试用例的方法。
b.说明 ：列举出程序中所有可能有的错误和容易发生错误的特殊情况，根据它们选择测试用例。
（4）因果图法
a.概念：因果图法是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法。
b.说明：等价类划分和边界值分析方法都是着重考虑输入条件，但没有考虑输入条件的各种组合、输入条件之间的相互制约关系。
c.使用场景：在界面中有多个控件，控件之间有一定的组合关系和限制关系，不同的控件组合会产生不同的输出结果的组合，为了弄清什么样的输入组合会产生怎样的输出结果组合，可以使用“因果图法”——因果图法主要解决控件组合问题。
d.符号说明：
恒等：原因和结果都只能取 2 个值，1 代表条件成立，0 代表条件不成立。恒等相当于原因成立，则结果出现；若原因不成立，则结果也不出现。恒等关系“—”来表示。
非：原因和结果相反。若原因成立，则结果不出现；若原因不成立，则结果出现。非的关系用 “ ~ ” 表示。
或：有多个原因。若几个原因中有一个成立，则结果出现；若几个原因都不成立，则结果不出现。或的关系用 “ V ” 来表示。
与：有多个原因。只有几个原因都成立，结果才或出现；若其中一个原因不成立，则结果不出现。与的关系用 “ ^ ” 来表示。
（5）场景法
a.概念：场景法是一种通过使用“场景”对软件系统的功能点或业务流程进行描述，即针对需求模拟出不同的场景进行所有功能点及业务流程的覆盖，从而提高测试效率并达到良好效果的方法。
b.说明：测试人员要熟悉所测软件的业务逻辑，成为该行业“业务上的专家”。对于单点功能来说，利用等价类划分、边界值分析、判定表等用例设计方法就能够解决大部分问题。而涉及业务流程的软件系统，采用场景法比较合适。
技术层面：
基本流：也叫有效流或正确流，模拟用户正确的业务操作流程备选流：也叫无效流或错误流，模拟用户错误的业务操作流程 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c5f63a841f88082d8a32a98dae47116/" rel="bookmark">
			stm32f103最小系统板详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.什么是单片机最小系统
常见的单片机最小系统为单片机能独立运行程序及控制外围电路的最简单电路，主要由单片机、晶振电路、复位电路三部分构成。Stm32f103c8t6也不例外，构成最小的运行电路也需要以上三部分。
Stm32f103最小系统板原理图如下：
二.最小系统电路
Stm32单片机最小系统电路有单片机、晶振电路、复位电路。
1. 单片机
Stm32f103系列单片机主要资源如图：
Stm32f103c8t6工作电压为2-3.6V（一般采用3.3V），内置64-128KBytes Flash，20KBytesSRAM，带有37个通用GPIO口（含特殊功能IO）。在最小系统板上主要连接晶振电路、复位电路、工作电源、以及配置BOOT启动方式。
BOOT启动方式主要有三种，主闪存存储器启动、系统存储器启动、内置SRAM启动，对应的BOOT引脚状态如下图：
最常用的模式为主闪存存储器启动，即内部Flash启动，BOOT1=0，BOOT1=x(x表示0或1均可)。（注意三种模式的对应启动地址均不一样，内部Flash启动的地址为0x0800000）
2. 晶振电路
（1）主时钟晶振
Stm32单片机内部自带一个8MHz的RC时钟，在符合设计需求的情况下，可通过程序在初始化时钟函数内，选择采用内部时钟。
外部主时钟晶振主要作为供单片机内核的时钟源，官方推荐晶振电路主要参数如下：
Stm32单片机外部晶振为4-16MHz，常用8MHz，电路图如下：
（2）RTC时钟晶振
同样，RTC时钟在符合设计需求的情况下，可选用内部自带的40kHz RTC时钟。外部晶振32.768KHz主要作为单片机内部RTC时钟的时钟源，电路图如下：
3. 复位电路
复位电路由RC电路及按键构成，10k电阻及1uF电容组成的RC电路；stm32单片机复位引脚为低电平有效，复位电路的作用是使单片机复位引脚在上电时，确保复位引脚至少有1ms以上的低电平状态。复位按键的作用是当按键按下，复位引脚的被拉至低电平，单片机触发复位。
以上的单片机、晶振电路、复位电路，亦可构成stm32的最小系统电路，但需使用+3.3V电源给其供电。由于常见采用USB给其供电源，USB电源为+5V，所以为了增加最小系统板的使用方便性，需增加以下外围电路。
三.外围电路
1. +5V转3.3V稳压电路
稳压电路的作用是将输入的+5V电源降压到+3.3V，给单片机最小系统电路供电。
2. 状态指示灯
最小系统板上有两个LED灯，D1为+3.3V电源指示灯，如果板卡上电正常，D1灯常亮。如果D1不亮，则可能板卡电源异常。D2灯为程序状态指示灯，可供软件调试或者程序运行指示用。
3. SWD烧录接口
SWD接口为单片机的程序烧录、软件调试接口，使用ST-Link、或者JLink可通过SWD接口进行程序烧录或调试。
4. USB电源接口
USB电源接口采用了Micro USB接口，最小系统板可通过USB接口连接至电脑上或者+5V电源适配器上，实现板卡的供电。但有点需要注意的是，虽然USB接口连接至单片机的USB引脚上，但单片机USB功能需要程序带有USB驱动，否则单片机的USB引脚只是为普通IO，无法与电脑的USB进行数据交互。其中电阻R9、R11为限流电阻，R10为上拉电阻。
四.实物图及对应电路
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e5168fc9e7364a0d1df4da73bad734d/" rel="bookmark">
			基于STM32的温湿度的OLED（4SPI）显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、SPI协议简介1.SPI协议的含义2.SPI 物理层3.SPI协议层4.SPI 基本通讯过程5.通讯的起始和停止信号6.数据有效性 二、OLED显示数据1. OLED相关资料2. 下载厂家Demo程序 三、显示自己的学号和姓名1.生成中文点阵及点阵编码2.编写代码3.编译程序及生成hex文件4.电路连接5.程序烧录6.运行结果 四、显示AHT20的温度和湿度1.生成中文点阵及点阵编码2.编写代码3.编译程序及生成hex文件4.电路连接5.程序烧录6.运行结果 五、上下或左右的滑动显示长字符1.生成中文点阵及点阵编码2.编写代码3.编译及生成hex文件4.电路连接5.程序烧录6.运行结果 六、总结七、参考链接 一、SPI协议简介 1.SPI协议的含义 SPI 协议是由摩托罗拉公司提出的通讯协议(Serial Peripheral Interface)，即串行外围设备接口，是一种高速全双工的通信总线。它被广泛地使用在 ADC、LCD 等设备与 MCU 间，要求通讯速率较高的场合。
2.SPI 物理层 SPI 通讯设备之间的常用连接方式见下图：
SPI 通讯使用 3 条总线及片选线，3 条总线分别为 SCK、MOSI、MISO，片选线为 SS，它们的作用介绍如下：
(1) SS( Slave Select)：从设备选择信号线，常称为片选信号线，也称为 NSS、CS，以下用 NSS 表示。当有多个 SPI从设备与 SPI主机相连时，设备的其它信号线 SCK、MOSI及MISO同时并联到相同的 SPI总线上，即无论有多少个从设备，都共同只使用这 3条总线；而每个从设备都有独立的这一条 NSS信号线，本信号线独占主机的一个引脚，即有多少个从设备，就有多少条片选信号线。I2C 协议中通过设备地址来寻址、选中
总线上的某个设备并与其进行通讯；而 SPI 协议中没有设备地址，它使用 NSS 信号线来寻址，当主机要选择从设备时，把该从设备的 NSS 信号线设置为低电平，该从设备即被选中，即片选有效，接着主机开始与被选中的从设备进行 SPI通讯。所以 SPI通讯以 NSS 线置低电平为开始信号，以 NSS 线被拉高作为结束信号。
(2) SCK (Serial Clock)：时钟信号线，用于通讯数据同步。它由通讯主机产生，决定了通讯的速率，不同的设备支持的最高时钟频率不一样，如 STM32 的 SPI 时钟频率最大为fpclk/2，两个设备之间通讯时，通讯速率受限于低速设备。
(3) MOSI (Master Output， Slave Input)：主设备输出/从设备输入引脚。主机的数据从这条信号线输出，从机由这条信号线读入主机发送的数据，即这条线上数据的方向为主机到从机。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e5168fc9e7364a0d1df4da73bad734d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54284390ecd5fce65a569442356fd17d/" rel="bookmark">
			在springboot中使用mybatis-plus的分页功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在springboot中使用mybatis-plus的分页功能 一、测试分页功能： 编写测试代码：
@Test public void testPage(){ //设置分页参数，页码为1，大小为5 Page&lt;Employee&gt; page = new Page&lt;&gt;(1, 5); //传入page对象，条件构造为null employeeMapper.selectPage(page, null); //获取分页数据 List&lt;Employee&gt; list = page.getRecords(); //输出分页数据 list.forEach(System.out::println); System.out.println("当前页："+page.getCurrent()); System.out.println("每页显示的条数："+page.getSize()); System.out.println("总记录数："+page.getTotal()); System.out.println("总页数："+page.getPages()); System.out.println("是否有上一页："+page.hasPrevious()); System.out.println("是否有下一页："+page.hasNext()); } 可以看到，很轻松的实现了分页功能。
二、实际使用场景： 1、编写一个mybatis-plus配置类： @Configuration public class MybatisPlusConfig { @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { // MyBatis Plus分页插件 MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; } } 2、编写mapper接口： 注：（实体类代码不再给出，请自己添加）
@Mapper public interface EmployeeMapper extends BaseMapper&lt;Employee&gt; { } 3、编写Controller层后端接口： @RestController @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54284390ecd5fce65a569442356fd17d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5afb31b341edae7f1b787b964aec39da/" rel="bookmark">
			IOS开发者自带弱网测试工具界面说明NETWORK LINK CONDITIONER
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IOS手机的开发者自带了弱网模拟工具，以下是界面说明，便于大家使用时自行配置使用。测试工具NETWORK LINK CONDITIONER。
1、准备环境，设置中调出：开发者选项（如果没有，需要真机联xcode）
2、选择NETWORK LINK CONDITIONER
3、将ENABLE打开
4、选择对应的网络环境，100% Loss、3G、Very Bad Network、WiFi等
5、自定义网络环境：Add a profile
Choose a profile…列表示意:
100%Loss ： 全丢包
3G ： 3G网络
DSL ： 电话线上网
Edge ： 2G网络
High Latency DNS ： 高延迟
Very Bad Network ： 网络状况不稳定
Wifi ： Wifi网络
最后，底部有个Add a profile…手动配置，这里可以自定义1个网络状态，如下：
in bandwidth 下行带宽
in packet loss 下行丢包率
in delay 下行延迟，单位为ms
out bandwidth 上行带宽
out packet loss 上行丢包率
out delay 上行延迟
DNS delay DNS解析延迟，这个功能安卓不知道怎么模拟
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5afb31b341edae7f1b787b964aec39da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a86d231a362d8461d2757cf539009b71/" rel="bookmark">
			C语言警告warning: ‘b’ may be used uninitialized in this function [-Wmaybe-uninitialized]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		warning:'b'may be used uninitialized in this function 出现这个的原因是因为‘b’没有初始化
如：int b=1;
就能解除警告（可以把你觉得对的一个数赋值给b)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5732193834697706d57cc9cd2bc2c326/" rel="bookmark">
			Docker命令大全（带思维导图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker镜像命令思维导图 初衷1、docker服务思维导图源文件 2、docker整体思维导图源文件 3、docker镜像思维导图源文件 4、docker容器思维导图源文件 5、补充一个redis-cli命令思维导图源文件 6、解释说明 初衷 这篇文章主要用来记录，Docker命令的思维导图，用于回顾复习使用。知识学了，实际工作中如果没有用到，慢慢就忘了。所以有了这篇文章，隔三岔五拿出来看看，哪些命令忘记了，就去再查一下。免得真正使用的时候，两眼一黑，只记得零星几个词，却串不起来了。文章附有有思维导图源文件，画图时，使用的是XMIND22.09版本。 1、docker服务 思维导图 源文件 https://download.csdn.net/download/bzu_mei/86881927
2、docker整体 思维导图 源文件 https://download.csdn.net/download/bzu_mei/86881949
3、docker镜像 思维导图 源文件 https://download.csdn.net/download/bzu_mei/86868498
4、docker容器 思维导图 源文件 https://download.csdn.net/download/bzu_mei/86868892
5、补充一个redis-cli命令 思维导图 源文件 https://download.csdn.net/download/bzu_mei/86881984
6、解释说明 以镜像命令的第一个images为例，后面跟了三个子标题，一个是空（啥也不跟），一个是-a，一个是-q。
所以命令连起来，即为：
docker images
docker images -a
docker images -q
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dab722ce1b09674e0b8ddb68df2bb2b2/" rel="bookmark">
			大学毕业1年，从监工转行软件测试，我拿到了人生第一份8k的offer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是小静，是一名IT转行人，2015年毕业于某所XXXX大专，大学学的专业是土木工程，毕业也是不出意外的来到了工地，从事的是一份监工的工作，就是工地上带白帽子的，每个月拿着4000块钱的工资，加上工地环境差，我还是放弃了这份工作！吃不了苦的真是不建议学习土木工程专业。
2016年年初，这个时候我已经在家混了3个月时间了，意识到自己也该找一份工作了，过完年就匆匆的找工作，发现并没有自己能够从事的高薪行业，除了进厂工资高一点，其余都是服务行业了。生活的压迫，让我出社会第一次感受到了压力，当时的我每天都很焦虑，最后通过身边的朋友推荐，选择了软件测试行业，刚听到了这个行业名称时，和大家的反应是一样的，根本不知道这是个什么样子的行业，后面也是通过系统的学习进入了软件测试行业，最后也是拿到了一份8k的offer...现在也是过了5年的时间，如今的我已然是一位自动化测试工程师，薪资也是到了16k..回头看看这条路我很幸运....关于软件测试怎么学习，对自身又有什么要求？接下来向大家一一解惑
零基础转行软件测试，硬性要求是：学历、年龄、学习能力。转行者，以就业和发展为目的。目前市场上，企业对软件测试者的学历要求是大专及大专以上，学历不够，即使学会了，在就业的时候也有一定的困难。
虽说学历不等同于能力，但是在软件测试岗位上，学历也算是用人单位的一个硬性要求，如果年龄不大，可以先考个学历证书，再入坑IT技术岗。
一、软件测试是干什么的？ 软件测试，英文Software Testing，指的是对软件进行正确性、完整性、安全性和质量的验证过程。经典定义是：在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程。
其实从本质上来讲，软件测试就是为了保证软件质量，对软件功能及六大特性进行验证。软件的六大特性：
二、软件测试行业前景如何？ 当今时代，随着软件整个产业的发展，软件产品的质量控制与质量管理成为了一个软件最重要的一部分，每个大中型IT企业的软件产品在上市前都需要大量的质量控制、测试和文档工作，而这些工作必须依靠拥有娴熟技术的专业软件测试人才来完成。软件测试工程师就是这样的一个重头的
然而，现状是：一方面IT企业对高质量的测试人员需求量越来越大，另一方面国内以前对测试工程师的职业重视程度不够，许多人并不了解测试工程师具体是从事什么工作的。
这使得许多IT公司只能通过自己培训或者实际工作中进行淘汰的方式对测试工程师进行筛选，因此国内在短期内将出现测试工程师严重短缺的现象。
根据招聘IT人才情况的了解，大部分招聘软件测试工程师的企业很难招到合适的人才。所以前景是一片光明
三、如何转行软件测试？ 作为一个过来人来讲，如果大家想转行，一定要系统的学习，没有学习资源的朋友可以私信我获取
我按照薪资的不同大致划分成2个档位：
月薪5-9k：从零基础入门到能够找到工作月薪15-25k：测试在职搞定性能测试和自动化测试 第一阶段：月薪5-9k，刚刚入行，先学会功能测试！ 可能你是刚毕业的学生，也可能你是打算转行进入软件测试这个行业，那么首先以下基本的理论你是必须要掌握的：
软件测试的定义、生命周期、工作流程、需求分析； 测试用例的设计、编写、评审； bug的基本知识以及禅道的使用； 测试计划、测试报告的编写； SVN、Git版本控制工具的使用； 搞定上上面的这些基本必备内容，就已经知道可以做具体的实战内容，这个时候最好是先找一个web测试项目去做一下，假如一个项目拿到手之后，按照下面的一套流程跑一遍：
发布项目进行立项，建立项目组进行分工； 需求评审，学会如何看需求文档，进行需求分析，罗列测试点； 整理测试点，编写测试用例，然后进行用例评审； 执行测试，比如功能、界面、前后台、兼容性、数据库，对于发现的bug提交到禅道； 分析、总结、编写测试报告； 这个流程完整的跑一遍之后，只能说对于整体的测试流程算是掌握了，但是仍然不足以找到一份合适的工作，想要学会做功能测试，以下的内容也是必须掌握的：
Linux、数据库、接口测试、APP测试等 OK，搞定了这些，恭喜你已经可以投出你的简历去寻找一份测试的工作了！
嗯，大概就是以上的内容吧，以上全部都是理论和文档能力、只要你肯背、肯写，都是能独立的掌握的。
会了以上这些内容，只能说是能够获得一份工作，但是现在行业招人的要求原来越高，搞定自动化或者性能测试，才能拿到10k以上的月薪。
第二阶段：月薪15-25k，搞定性能、自动化测试，独当一面！（我目前也是在这个阶段不过是属于经验比较浅的那一批，所以才20k左右） 先说性能测试，行业内是有很多误区和痛点的：
只测不调，无法给出研发和运维人员执行建议无法定位问题，缺乏清晰的逻辑和数据证明价值性能测试工具≠性能测试性能测试技术体系落后（loadrunner），急需拥抱开源软件 如果要搞定这些问题，那么性能测试你得这么去学：
性能测试的概念和流程：常见问题剖析、流行工具、方案设计 性能测试工具：jmeter工具的使用、实战；jmeter多协议、拓展与定制；分布式压测与任务调度； 性能监控：性能监控体系与监控数据采集 性能实施：分布式服务压测，场景设计、场景执行；测试结果关联分析，TPS、响应时间、线程关联分析，压力和资源使用率关联分析 性能分析与报告：jvm调试与系统调试；性能瓶颈分析 性能测试你能到这个程度，15k那是妥妥的了，如果下面自动化测试的学习内容你能够掌握，那就可以直接冲击月薪25k！
搞定Python或者Java语言，建议先从Python入手，先学习Python的基本语法等。
web端的自动化测试：selenium安装、录制、处理；web控件、JavaScript脚本、PO模式； 移动端APP自动化测试：appium使用、录制、元素定位方法；APP控件定位、交互，参数化用例；appium问题定位分析、源码分析、二次封装； 服务端接口自动化测试：接口自动化测试框架request；接口请求构造、断言；json/xml请求、响应断言；headcookie处理、认证体系； 如果你还是没有思绪，还有一个捷径走，就是去我下面推荐的测试学习群去请教，学习群都是测试同行和一些前辈，有很多资历老有经验的人，这样精准去问会更有效率，如果你怕麻烦我建议你采取这种办法，我当时的学习资料就是这么搞来的，我天生怕麻烦，进了交流群之后就天天问，混的熟悉之后，就有朋友直接给我拷了一套资料，我就直接顺着资料的思路逻辑学就行。
这些都放了我的学习交流企鹅群，文末小卡片进群自行免费获取 四、结束语 如果你只为薪水而工作，你的生活将因此而陷入平庸之中，你找不到人生中真正的成就感，工作的目的虽然是为了获得报酬，但工作能给你带来的远比工资要多的多。努力工作并且学习，你会收获很多。选对行业很重要，人生要有踏出第一步的勇气，过去的，让它过去，永远不要回顾；未来的，等来了时再说，不要空想；我们只抓住了现在，用我们现在的理想，做我们所应该做的。祝福每一位IT转行人都能够如愿转行...
既然都看到这里啦，请你帮个忙：
1、点赞，让更多小伙伴看到；
2、关注我，持续更新测试干货。
敲字不易，如果此文章对你有帮助的话，点个赞收个藏，给作者一个鼓励。也方便你下次能够快速查找。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4481c88e0108547d2862c43419d9c9f0/" rel="bookmark">
			Centos7安装Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos7安装Redis 1.单机安装Reids 多数情况下我们都需要基于Linux服务器来部署项目，而且redis官方也没有提供Windows版本的安装包。所以我们就可以在centos虚拟机来部署redis
1.1.安装Redis依赖 Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖：
yum install -y gcc tcl
1.2.上传安装包并解压 这里我们上传的是redis6的版本，将它上传到/usr/local/src目录下
解压缩：
tar -xzf redis-6.2.6.tar.gz
进入redis目录，运行编译命令
cd redis-6.2.6
make &amp;&amp; make install
默认的安装路径是在 /usr/local/bin目录下，查看目录下的内容确保安装成功
1.3.启动 redis的启动方式有很多种，例如默认启动，指定配置启动，开机自启
若要方便使用最好的方式就是配置开机自启
1.3.1.默认启动 安装完成后，在任意目录输入redis-server命令即可启动Redis
redis-server
1.3.2.指定配置启动 如果要让Redis以后台方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（/usr/local/src/redis-6.2.6），名字叫redis.conf
我们先将这个配置文件备份一份：
cp redis.conf redis.conf.bck
然后修改redis.conf文件中的一些配置
vim redis.conf
#允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0
bind 0.0.0.0
#守护进程，修改为yes后即可后台运行
daemonize yes
#设置后访问Redis必须输入密码
requirepass 123456
其他的常见配置可以选择配置，比如监听的端口、工作目录、指定日志文件名开启日志的保存功能，不必要
启动Redis
进入redis安装目录
cd /usr/local/src/redis-6.2.6
启动
redis-server redis.conf
查看运行状态
ps -ef | grep redis
停止服务
通过杀死进程的方式（这里使用shutdown命令没有停止服务）
kill -9 16038
1.3.3.开机自启 可以通过配置来实现开机自启
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4481c88e0108547d2862c43419d9c9f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da7ed80731909636c95ff9f336eae3a8/" rel="bookmark">
			ubuntu18.04 NFS挂载远程服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景:
本地计算机访问远程服务器，并且改写服务器上的文件，通过NFS把服务器上文件所在的目录挂载到本地计算机目录，从而可以在本地目录改写。
1. 配置配置 NFS 服务端 首先服务端将自己的文件挂载出来,然后才能被客户端访问
在服务器上操作：
1.1 安装 NFS 服务端
sudo apt-get install nfs-kernel-server 如果出现错误：
dpkg: error processing package nfs-common (--configure): subprocess installed post-installation script returned error exit status 10 dpkg: dependency problems prevent configuration of nfs-kernel-server: nfs-kernel-server depends on nfs-common (= 1:1.2.8-9ubuntu12.3); however: Package nfs-common is not configured yet. dpkg: error processing package nfs-kernel-server (--configure): dependency problems - leaving unconfigured Errors were encountered while processing: nfs-common nfs-kernel-server E: Sub-process /usr/bin/dpkg returned an error code (1) 参考解决方案：Ubuntu dpkg报错: dpkg: error processing package
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da7ed80731909636c95ff9f336eae3a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8df37468a3eeab3f076880db4c7c22c8/" rel="bookmark">
			java中snakeyaml工具包操作yaml文件，什么是yaml文件，yaml如何解析转换为实体，实体如何生成yaml文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是yaml文件 这里就不去搞yaml的书面意思了，其实就可以理解为一种数据文件，里面的数据是以键值对的方式存储的。java中map就是键值对的形式，我们带着这个概念去理解。举个例子：
school: classroom: student: - 小明 - 小红 teacher: 老王 playground: - 足球场 - 篮球场 school有两个属性：classroom和playground
class有两个属性：student和teacher
对应的java实体就是这样的：
public class YamlPojo { private School school; public static class School { private Classroom classroom; private List&lt;String&gt; playground; } public static class Classroom { private List&lt;String&gt; student; private String teacher; } } 这样呢，就把yaml文件和java实体对应了起来，有了对应关系，接下来就是通过snakeyaml来进行操作了。
当然，少不了依赖哦，我用的1.26版本，相对稳定，其他版本的也满足使用需求
&lt;dependency&gt; &lt;groupId&gt;org.yaml&lt;/groupId&gt; &lt;artifactId&gt;snakeyaml&lt;/artifactId&gt; &lt;version&gt;1.26&lt;/version&gt; &lt;/dependency&gt; snakeyaml解析yaml文件 如何将yaml文件转成java实体呢，超级简单啦，上代码！
File file = new File("yaml文件路径"); Yaml yaml = new Yaml(); YamlPojo yamlPojo = yaml.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8df37468a3eeab3f076880db4c7c22c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b1896488e67f67a8b9a975e047f805f/" rel="bookmark">
			23届双非秋招指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人23届双非硕女，现已上岸，非常满意，私信有很多uu问我怎么准备的，现在把我的秋招经验给uu们分享一下，按照现在这个形式，24届情况应该也很艰难，uu们需要早做准备~
前期准备 4~6月 （1）硕士课题：首先你要明确自己以后找工作的方向，积极向导师争取自己课题就是那个方向的，这样你的课题就可以作为一个项目。如果你的实验室没法给你这种课题，那么你要积极去争取一些有前人积淀的课题，这样你的工作会少很多，总之你要争取在中期的时候把毕设完成（完成到可以写大论文的程度）
（2）简历准备：简历建议一页纸，上面要突出自己的技能+项目，如果想投多个岗位就要准备多个简历，所以简历需要提前做，并且做好润色
（3）笔试面试准备：这个推荐牛客网，上面可以练习选择题，还有编程题，都是笔试里面常考的，需要一些时间才能刷完，所以也建议早早开始
参与提前批 7~8月 不要觉得自己是双非就不配提前批，其实公司这个阶段也是在练习，所以面试的概率还是挺高的。参与提前批不是为了入选，而是为秋招积攒笔试面试经验：
（1）把面试官问的问题都做好总结记录，因为大多数问题都是围绕项目提问，所以会出现一个问题被反复问到的情况，（这些问题可能第一次被问到的时候你不会，但是如果再被问到还是不会就是不用心了）还要注意一点就是，这一阶段如果在面试中被问到不易百度到的问题（一些经验问题），建议谦虚地问面试官答案，因为还可能会再被其他公司问，不要不好意思
（2）简历还是需要在不断面试的过程中进行修改，比如多个面试官对你简历上某个地方疑惑，那么不要偷懒，抓紧对简历进行修改
秋招 9~10月 经历了2个月的磨练，已经能比较熟练的面试了，不过可以因为已经投递了2个月，会非常疲惫，这个时候一定要把心态稳住，再坚持2个月
（1）海投：今年我和我的小伙伴一开始都是只投递某个地方，或者某几个地方的公司，最后发现要凉，转而到处投递；此外不要总是盯着大厂，多拿offer再比较；再一个就是一定要趁早投，最好招聘一开启就投；投递渠道要多样化，不要看不起智联，BOSS，猎聘，或许比官网投递的进程还快点呢
（2）对不同类型的公司展示不同的自己
私企：重点是技术能力+项目 需要突出自己完成的工作 加分项是实习经历
国企：重点是学历+学校 需要突出自己拥有良好基础 加分项是干部经历和才艺
研究所：重点是学历+学校 需要强调自己干过xx国家科研项目还有发过xx论文 加分项是男生
外企：重点是学历+学校+技术能力+项目 需要突出自己的英语能力 加分项是留学经历
（3）对offer的处理
拿到offer之后不要着急签也不要着急拒，找借口和hr耗时间，先积攒几个offer，然后来比较这些offer，找找自己的定位，不要高估自己也不要低估自己
此外，毁约还是很麻烦的，所以签约要慎重
最后见好就收，先进入行业，度过寒气
祝uu们都能找到心仪工作~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76e94c922e0954061def7ee37afe452c/" rel="bookmark">
			自学软件测试最常用的七个网站！建议收藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 不知道大家有没有发现一个现象，技术行业更新换代的速度，远远快于我们追赶的脚步，两三年前，只需要掌握基础的软件测试技术，会一些功能测试，就可以找到一份不错的工作，但是从2021年来看，只会纯功能测试，很难找到满意的工作。如果你想拿高薪，还需要掌握自动化测试相关技术。
推荐一 51ste软件测试部 每天会更新一些技术文章、测试工具，以及国外文章译文，还有很多优秀的测试工程师在该网站交流。
推荐二 51Testing软件测试网站 51Testing是国内较大的软件测试网站，有很多基础软件测试文章，适合刚入行的菜鸟。
推荐三 测试窝 测试窝也有很多的技术文章，不过主要以转载为主，原创文章相对少一些，利用空闲时间，多看几篇技术博客，也可以提升自己的测试水平哦。
推荐四 testerhome 该网站专注于移动互联网测试，有很多深度的技术文章，但是也有一些水贴，所以不要在网站上花费太多时间，只找自己需要的。
推荐五 CSDN CSDN是一个开发者社区，程序员之家，包罗万象的语言都可以在该网站找到，也有很多测试技术文章。你也可以动手写博客哦，不断地总结知识，对自己所学到的知识进行强化。
推荐六 知乎 知乎是个问答社区，有很多技术达人在知乎上探讨问题，你可以在知乎上找到很多的优质回答，其中测试领域相关的问答也非常多。缺点就是太多培训机构在知乎上卖课了。
推荐七 B站 如果你不喜欢看文章，而想看视频的话，我推荐你去Ｂ站，该网站关于软件测试相关的视频也非常多，还可以跟志同道合的朋友，在Ｂ站一起学习。
最后我可能给你的帮助 面试资料 我们学习软件测试必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
上面是我整理的配套资源，这些资源对于软件测试的的朋友来说应该是最全面最完整的备战仓库，为了更好地整理每个模块，我也参考了很多网上的优质博文和项目，力求不漏掉每一个知识点，很多朋友靠着这些内容进行复习，拿到了BATJ等大厂的offer，这个仓库也已经帮助了很多的软件测试的学习者，希望也能帮助到你
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb66b8fdc07c4b777e66e516735c9630/" rel="bookmark">
			2022年软件设计师考试复习资料（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、计算机组成与体系结构 知识点导图+考情分析
1.数据的表示 1.1 进制转换 考点：10 - 2 - 16 进位转换
电流高低被电脑识别为[0 1] 2进制
其它进制转10进制-按权展开法：
10进制转其它进制 - 短除法 （除基取余，直到商为0）
10进制转16进制
这个 H表示16进制数
10转2简便运算法：
2转8快转方法- 3位1组法
注意最高位不足3位，可以补位0
原理：对于8进制来说，不进位的最大值为 7 ，二进制表示为 111，得出一位8进制数至少需要3位2进制数表示。
同理可得 2 转 16 的方式为 ： 4位一组。
推导： 16进制最大数为 F（15） , 2进制表示为 1111，即1位16进制数需要4位2进制数表示。
1.2 码制 最高位都是符号位。正数的原反补相同。
原码：实际的2进制数
补码：计算机的计算结果使用补码表示才是正确的。
考点： 原码反码 0有两种表示方式，补码移码人为指定了-2^(n-1)的值
定点整数：-128的补码为 1000 0000 是人为规定的
定点小数：-1的补码为 1000 0000 是人为规定的
所以补码的表示范围举例： n=8时 ，是 -128 ~ 127，负数多一位！
小数点不占用数位，整数放在最后如 1111.小数放在符号位后如 ，1.111
定点小数的表示方法推导：（便于理解）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb66b8fdc07c4b777e66e516735c9630/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa10fd561c1dd304c938f3ccb25e2c1c/" rel="bookmark">
			黑盒测试之场景法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 场景法概述 场景法就是模拟用户操作软件时的场景，主要用于测试系统的业务流程
1.1 基本流 按照正确的业务流程来实现的一条操作路径
1.2 备选流 导致程序出现错误的操作流程
2. 场景法用例设计步骤 根据需求规格说明，画出功能模块流程图根据流程图，描述出程序的基本流及备选流根据基本流和备选流生成不同的场景，构造场景列表对每一个场景生成对应的测试用例对生成的所有测试用例重新评审，去掉多余的测试用例测试用例确立后，为每一个测试用例确定测试数据值 3.场景法案例 3.1 对淘宝网购流程设计测试用例 按照操作，确认基本流，
进入淘宝首页浏览商品进入商品单个页面选择商品规格和数量加入购物车前往购物车选择商品结算，进入确认订单页提交订单付款成功等待收获确认收货 确定备选流
13. 加入购物车时，不选择商品规格，返回基本流第四步
14. 加入购物车时 ，商品库存不足，返回基本流第四步
15. 加入购物车时，未登录，登录后返回基本流第三步
16. 加入购物车后，继续选购，返回基本流第四步
17. 加入购物车，未选择商品，结算，返回，返回基本流第七步
18. 支付失败，返回基本流第八步
19. 未选择商品加入购物车，退出购物，结束
4.构造场景 登陆后成功购物未选择商品规格和型号就添加购物车选择的商品库存不足未登录添加购物车商品添加购物车后继续购物进入购物车支付过程出错没有添加商品到购物车 5.总结 场景法适应于流程，但是对于单个功能点，无法测试，所以我们是要将等价类划分，边界值，判定表等方法对其单个功能点进行测试，然后再结合场景法，将测试完善。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90f02276dce946f2fc28de930e25e432/" rel="bookmark">
			一文看懂自编码器、堆叠自编码器、稀疏自编码器、降噪自编码器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的小程序： 待办计划：给自己立个小目标吧！ 自从Hinton 2006年的工作之后，越来越多的研究者开始关注各种自编码器模型相应的堆叠模型。实际上，自编码器（Auto-Encoder）是一个较早的概念了，比如Hinton等人在1986, 1989年的工作。（说来说去都是这些人呐。。。）
自编码器简介
先暂且不谈神经网络、深度学习，仅是自编码器的话，其原理很简单。自编码器可以理解为一个试图去还原其原始输入的系统。如下图所示：
图中，虚线蓝色框内就是一个自编码器模型，它由编码器（Encoder）和解码器（Decoder）两部分组成，本质上都是对输入信号做某种变换。编码器将输入信号x变换成编码信号y，而解码器将编码y转换成输出信号，即：
而自编码器的目的是，让输出尽可能复现输入x，即tries to copy its input to its output。但是，这样问题就来了——如果f和g都是恒等映射，那不就恒有=x了？不错，确实如此，但这样的变换——没有任何卵用啊！因此，我们经常对中间信号y（也叫作“编码”）做一定的约束，这样，系统往往能学出很有趣的编码变换f和编码y。
这里强调一点，对于自编码器，我们往往并不关系输出是啥（反正只是复现输入），我们真正关心的是中间层的编码，或者说是从输入到编码的映射。可以这么想，在我们强迫编码y和输入x不同的情况下，系统还能够去复原原始信号x，那么说明编码y已经承载了原始数据的所有信息，但以一种不同的形式！这就是特征提取啊，而且是自动学出来的！实际上，自动学习原始数据的特征表达也是神经网络和深度学习的核心目的之一。
为了更好的理解自编码器，下面结合神经网络加以介绍。
自编码器与神经网络
神经网络的知识不再详细介绍，相信了解自编码器的读者或多或少会了解一些。简单来讲，神经网络就是在对原始信号逐层地做非线性变换，如下图所示：
该网络把输入层数据x∈Rn转换到中间层（隐层）h∈Rp，再转换到输出层y∈Rm。图中的每个节点代表数据的一个维度（偏置项图中未标出）。每两层之间的变换都是“线性变化”+“非线性激活”，用公式表示即为：
h=f(W(1)x+b(1))
y=f(W(2)h+b(2)) 神经网络往往用于分类，其目的是去逼近从输入层到输出层的变换函数。因此，我们会定义一个目标函数来衡量当前的输出和真实结果的差异，利用该函数去逐步调整（如梯度下降）系统的参数（W(1),b(1),W(2),b(2)），以使得整个网络尽可能去拟合训练数据。如果有正则约束的话，还同时要求模型尽量简单（防止过拟合）。
那么，自编码器怎么表示呢？前面已说过，自编码器试图复现其原始输入，因此，在训练中，网络中的输出应与输入相同，即y=x，因此，一个自编码器的输入、输出应有相同的结构，即：
我们利用训练数据训练这个网络，等训练结束后，这个网络即学习出了x→h→x的能力。对我们来说，此时的h是至关重要的，因为它是在尽量不损失信息量的情况下，对原始数据的另一种表达。结合神经网络的惯例，我们再将自编码器的公式表示如下：（假设激活函数是sigmoid，用s表示）
其中，L表示损失函数，结合数据的不同形式，可以是二次误差（squared error loss）或交叉熵误差（cross entropy loss）。如果，一般称为tied weights。
为了尽量学到有意义的表达，我们会给隐层加入一定的约束。从数据维度来看，常见以下两种情况：
n&gt;p，即隐层维度小于输入数据维度。也就是说从x→h的变换是一种降维的操作，网络试图以更小的维度去描述原始数据而尽量不损失数据信息。实际上，当每两层之间的变换均为线性，且监督训练的误差是二次型误差时，该网络等价于PCA！没反应过来的童鞋可以反思下PCA是在做什么事情。 n&lt;p，即隐层维度大于输入数据维度。这又有什么用呢？其实不好说，但比如我们同时约束h的表达尽量稀疏（有大量维度为0，未被激活），此时的编码器便是大名鼎鼎的“稀疏自编码器”。可为什么稀疏的表达就是好的？这就说来话长了，有人试图从人脑机理对比，即人类神经系统在某一刺激下，大部分神经元是被抑制的。个人觉得，从特征的角度来看更直观些，稀疏的表达意味着系统在尝试去特征选择，找出大量维度中真正重要的若干维。 堆叠自编码器
有过深度学习基础的童鞋想必了解，深层网络的威力在于其能够逐层地学习原始数据的多种表达。每一层的都以底一层的表达为基础，但往往更抽象，更加适合复杂的分类等任务。
堆叠自编码器实际上就在做这样的事情，如前所述，单个自编码器通过虚构x→h→x的三层网络，能够学习出一种特征变化h=fθ(x)（这里用θ表示变换的参数，包括W,b和激活函数）。实际上，当训练结束后，输出层已经没什么意义了，我们一般将其去掉，即将自编码器表示为：
之前之所以将自编码器模型表示为3层的神经网络，那是因为训练的需要，我们将原始数据作为假想的目标输出，以此构建监督误差来训练整个网络。等训练结束后，输出层就可以去掉了，我们关心的只是从x到h的变换。
接下来的思路就很自然了——我们已经得到特征表达h，那么我们可不可以将h再当做原始信息，训练一个新的自编码器，得到新的特征表达呢？当然可以！这就是所谓的堆叠自编码器（Stacked Auto-Encoder, SAE）。Stacked就是逐层垒叠的意思，跟“栈”有点像。UFLDL教程将其翻译为“栈式自编码”，anyway，不管怎么称呼，都是这个东东，别被花里胡哨的专业术语吓到就行。当把多个自编码器Stack起来之后，这个系统看起来就像这样：
亦可赛艇！这个系统实际上已经有点深度学习的味道了，即learning multiple levels of representation and abstraction(Hinton, Bengio, LeCun, 2015)。需要注意的是，整个网络的训练不是一蹴而就的，而是逐层进行。按题主提到的结构n,m,k结构，实际上我们是先训练网络n→m→n，得到n→m的变换，然后再训练m→k→m，得到m→k的变换。最终堆叠成SAE，即为n→m→k的结果，整个过程就像一层层往上盖房子，这便是大名鼎鼎的layer-wise unsuperwised pre-training（逐层非监督预训练），正是导致深度学习（神经网络）在2006年第3次兴起的核心技术。
关于逐层预训练与深度学习，将在本文最后探讨。
自编码器的变种形式
上述介绍的自编码器是最基本的形式。善于思考的童鞋可能已经意识到了这个问题：隐层的维度到底怎么确定？为什么稀疏的特征比较好？或者更准确的说，怎么才能称得上是一个好的表达（What defines a good representation）？
事实上，这个问题回答并不唯一，也正是从不同的角度去思考这个问题，导致了自编码器的各种变种形式出现。目前常见的几种模型总结如下（有些术语实在不好翻译，看英文就好。。。）
下面简介下其中两种模型，以对这些变种模型有个直观感受。
稀疏自编码器
UFLDL-自编码算法与稀疏性对该模型有着比较详细的介绍。如前所示，这种模型背后的思想是，高维而稀疏的表达是好的。一般而言，我们不会指定隐层表达h中哪些节点是被抑制的（对于sigmoid单元即输出为0），而是指定一个稀疏性参数ρ，代表隐藏神经元的平均活跃程度（在训练集上取平均）。比如，当ρ=0.05时，可以认为隐层节点在95%的时间里都是被一直的，只有5%的机会被激活。实际上，为了满足这一条件，隐层神经元的活跃度需要接近于0。
那么，怎么从数学模型上做到这点呢？思路也不复杂，既然要求平均激活度为ρ，那么只要引入一个度量，来衡量神经元ii的实际激活度与期望激活度ρ之间的差异即可，然后将这个度量添加到目标函数作为正则，训练整个网络即可。那么，什么样的度量适合这个任务呢？有过概率论、信息论基础的同学应该很容易想到它——相对熵，也就是KL散度（KL divergence）。因此，整个网络所添加的惩罚项即为：
具体的公式不再展开，可以从下图（摘自UFLDL）中直观理解KL散度作为惩罚项的含义。图中假设平均激活度ρ=0.2。
可以看出，当^ρiρ^i一旦偏离期望激活度ρρ，这种误差便急剧增大，从而作为惩罚项添加到目标函数，指导整个网络学习出稀疏的特征表达。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90f02276dce946f2fc28de930e25e432/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/51/">«</a>
	<span class="pagination__item pagination__item--current">52/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/53/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>