<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fa4cc152037faad47726b74b275ea10/" rel="bookmark">
			http网络传输协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、http是什么？
二、http协议的主要内容
2.1、三次握手
2.2、四次挥手
2.3、请求报文
4、响应报文
2.5、http状态码
附：本文只是简单的理解一下http协议主要的内容和使用方法
有兴趣的小伙伴可以进入此网站 https://www.runoob.com/http/http-status-codes.html（http教程的网址）具体了解学习http协议
一、http是什么？ HTTP: HyperText Transfer Protocol超文本传输协议，是互联网上应用最为广泛的有线网络传输协议的一种，是客户端和服务器进行传输内容时遵守的规则规范。
http协议是非常复杂的计算机程序，我们不需要刻意的去研究http协议的源代码，只需要研究http协议主要的内容和使用方法，为了解ajax技术的执行原理。
二、http协议的主要内容 三次握手、四次挥手、请求报文、响应报文、http协议状态码
2.1、三次握手 三次握手是http协议的一部分，通过TCOP/IP协议完成的，在客户端和服务器正式创建链接之前执行执行的程序内容
为了确保客户端和服务器都能正常工作
客户端 需要 确定
客户端 可以正常的 接收 发送 请求
服务器 可以正常的 接收 发送 请求
服务器 需要 确定
客户端 可以正常的 接收 发送 请求
服务器 可以正常的 接收 发送 请求
三次握手的步骤过程
1、客户端 给 服务器 发送请求
客户端可以确定
客户端 可以正常 发送请求
服务器可以确定
客户端 可以正常 发送请求
服务器 可以正常 接收请求
2、服务器 给 客户端 发送请求
服务器 可以确定
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fa4cc152037faad47726b74b275ea10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f773aca78281eb1df6259bbcb994b0ff/" rel="bookmark">
			链表实操（多项式的创建，加法，减法，求值）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、链表结构定义： #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; typedef struct Lnode{ float coef; //系数 int expn; //指数 struct Lnode *next; }Lnode ,*Linklist; 对于多项式的运算，存在系数冲突（删除）和系数不冲突（插入）运算，所以使用链表最为方便。
并且，数据部分要定义一个系数和一个指数，将二者分开来记录。
二、多项式的创建 与单链表的创建类似，不过相对来说复杂一点，对于多项式可优先采用尾插法。
代码如下：
//尾插法建立多项式单链表 Linklist Create(Linklist &amp;L){ Linklist rear,s; L=(Linklist)malloc(sizeof(Lnode)); //申请头结点 L-&gt;next=NULL; //初始链表置空 rear=L; //尾插法的尾指针 float c; //取系数 int e,num; for(int i=1;;i++){ printf("请输入第%d项的系数：",i); scanf("%f",&amp;c); printf("请输入第%d项的指数：",i); scanf("%d",&amp;e); if(c!=0){ s=(Linklist)malloc(sizeof(Lnode)); //申请新结点 s-&gt;coef=c; //以下是尾插步骤 s-&gt;expn=e; rear-&gt;next=s; rear=s;	}else{ break; //如果为0则跳出循环结束 } } rear-&gt;next=NULL; //一定要将创建好的最后结点的后续置空，否则系统将误判 printf("创建成功！"); return L; } 运行结果：个人以输入0视为结束，大家可自定。
三、多项式的遍历 思路：从单链表第一个元素开始，逐项读出系数和指数，按多项式的形式进行输出。
但是，此过程口头叙述有点麻烦。
上图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f773aca78281eb1df6259bbcb994b0ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a383946e8d7c47907998bade2884b011/" rel="bookmark">
			（Python十二讲）、Turtle画图练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 # Turtle画图练习 # # 2021/12/23 15:06 # GQ import turtle import turtle as t # 彩色多边形 # t = turtle.Pen() t.bgcolor("black") sides = eval(input("输入要绘制的边的数目，请输入2-10的数字！")) #colors = ["red","yellow","green","blue","orange","purple"] colors = [ 'lightcoral', 'coral', 'darkorange', 'gold', 'palegreen', 'paleturquoise', 'skyblue', 'plum', 'hotpink', 'pink'] for x in range(150): t.pencolor(colors[x%sides]) t.forward(x*3/sides+x) t.left(360/sides+1) t.width(x*sides/200) # exitonclick()点击后关闭绘图板 t.exitonclick() print("####结束####") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da5540f7e69c57df4802352e0fadc3d6/" rel="bookmark">
			（Python十一讲）、Tuple数据类型元组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #Tuple数据类型元组 # GQ, 2022/01/04 tup1 = ('Google','Python3',100,200) tup2 = (1,2,3,4,5) tup3 = ('a','b','c') tup4 = () #空元组 print(type(tup1)) print(tup1 + tup2) print(tup4) print(tup1[1]) print(tup1[1:]) #元组中只包含一个元素时，需要在元素后加,号分隔，否则会被当成运算符使用 tup5 = (50) print(tup5) #不加,号，类型为整型 tup6 = (50,) print(tup6) #加,号，类型为元组 #删除元组, 元组中的元素值是不允许删除的 tup7 = ('Google','Python3','GaoQiang',1000,2000) print(tup7) # del tup7[0] #元组中的元素值是不允许删除的 print(tup7) #作业练习,请分别计算出： - 过去七天每天的平均温度 - 本周的最高与最低温度 - 本周的平均温度 maximum_temperature = (30,28,29,31,33,35,32) minimum_temperature = (23,19,19,22,18,24,22) day1_average_temperature = (maximum_temperature[0] + minimum_temperature[0]) / 2 day2_average_temperature = (maximum_temperature[1] + minimum_temperature[1]) / 2 day3_average_temperature = (maximum_temperature[2] + minimum_temperature[2]) / 2 day4_average_temperature = (maximum_temperature[0] + minimum_temperature[0]) / 2 day5_average_temperature = (maximum_temperature[1] + minimum_temperature[1]) / 2 day6_average_temperature = (maximum_temperature[2] + minimum_temperature[2]) / 2 day7_average_temperature = (maximum_temperature[2] + minimum_temperature[2]) / 2 print(day1_average_temperature) print(day2_average_temperature) print(day3_average_temperature) print(day4_average_temperature) print(day5_average_temperature) print(day6_average_temperature) print(day7_average_temperature) #过去七天每天的平均温度 average_temperature = (day1_average_temperature, day2_average_temperature, day3_average_temperature, day4_average_temperature, day5_average_temperature, day6_average_temperature, day7_average_temperature) print('过去七天每天的平均温度是：',average_temperature) #最大温度最小温度 temperature = maximum_temperature + minimum_temperature max_temperature = max(temperature) min_temperature = min(temperature) print('最大温度是：',max_temperature,'\n最小温度是：',min_temperature ) #本周的平均温度 week_average_temperature = round(((day1_average_temperature +day2_average_temperature +day3_average_temperature +day4_average_temperature +day5_average_temperature +day6_average_temperature +day7_average_temperature)/7),1) print('本周的平均温度是：',week_average_temperature) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c64cd93ba2e4815fcee27dfa46b0c367/" rel="bookmark">
			Windows server 2012R2系统备份教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows server 2012R2系统备份教程
在日常的服务器运维中，经常遇到服务器安装补丁、软件等情况，当然也就难免系统奔溃和操作系统回退的情况了，如补丁不兼容蓝屏奔溃，业务软件安装出问题奔溃或者业务软件安装不合适需要回退等等，如果服务器没有设置系统备份那就非常棘手了，可能面对重做系统的囧境，那么如何给服务器设置系统备份，创建还原点呢以备不时之需呢？
window server操作系统备份与windows 7操作系统备份创建还远点的方法和步骤大不相同，下面以Windows server 2012R2的系统备份为例进行讲解。
步骤一：安装windows server backup
打开服务器桌面左下角开始菜单-&gt;服务器管理器-&gt;添加角色和功能-&gt;下一步-&gt;基于角色或基于功能的安装-&gt;下一步，选择“Windows server essentials体验”，在“Windows server essentials体验”弹出页面选择“windows server backup”添加功能，接着一直默认下一步直到开始安装，安装完成后即可关闭该页面。
步骤二：利用Windows server backup创建一次性备份
打开服务器桌面左下角开始菜单-&gt;管理工具-&gt;Windows server backup-&gt;本地备份-&gt;一次性备份-&gt;其它选项-&gt;整个服务器-&gt;本地驱动器。
选择要将备份存放的磁盘，此处我们为服务器备份单独建立了一块H盘，备份目标为H盘后下一步，此时会提示我们将要备份的项目中包含H盘，是否要将H盘从备份计划中排除，意思就是备份的时候不用再将H盘备份进来，选择确定。
点击备份后开始备份，备份完毕后点击关闭，此时我们可以在本地备份页面看到创建成功的备份。
步骤三：创建备份计划
一次性备份计划是我们手工创建的，同是还可以通过备份计划实现周期性自动备份。
在本地备份界面打开备份计划-&gt;下一步-&gt;整个服务器，然后选择备份时间，可以选择每日一次或者每日多次备份下一步选择备份数据存储位置，由于没有设置单独的备份磁盘，也没有设置网络路径，因此将备份数据存放到服务器逻辑卷中，然后添加逻辑卷H盘为存放备份数据的位置，点击下一步并完成。
步骤四：备份参数设置
默认的备份是普通备份性能，在备份是根据实际情况选择普通备份性能、快速备份性能和自定义。简答的说普通备份就是数据越多备份时间越长，快速备份相对于普通备份时间较短但是会影响现有磁盘的吞吐量，而自定义备份可以选择增量备份还是完整备份，当然完整备份的时间肯定要比增量备份的时间相对长了。如果大家不理解的话就不用设置，采用默认的普通备份就好了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d35bedcfb19f195df13293bbdc1baa76/" rel="bookmark">
			洛谷上的 AtCoder 水(难)题(C&#43;&#43;)【第一到五题】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 蒟蒻尹：啊啊啊~~要疯啦！ 为了不让我们玩得太high，我们的教练给我们布置了30题的AtCoder经典题当作业，还要写10篇题解。。。
可事实上。。。教练我们还有寒假作业啊 QAQ 555~~
这次我选了五道题来做讲解，后面会再出五道题;
这次讲解为了方便理解，我把一些题面改得通俗了一点，有的原题实在看不下去
好了废话不多说，开始奋斗吧&gt;o&lt;
第一题：おいしいたこ焼きの売り方 - 洛谷 题目描述：
高桥烦恼着怎样按顺序卖章鱼烧。因为知道做了的章鱼烧不好吃，所以高桥不想卖那样的章鱼烧，但是只卖刚做好的话，卖的章鱼烧的数量减少了。 另外，高桥君认为，光让客人等的话，客人会逐渐离开的。 于是，他就把在T秒内制作的章鱼烧继续卖下去，就决定调查客人是否能卖掉。 章鱼烧是A1、A2、…、AN秒后开始烤。 客人是B1、B2、…、在BM秒后来。 对于一个客人，卖一个章鱼烧。如果所有的客人都卖章鱼烧的话，请输出yes，如果卖不出去的话，请输出no。
输入输出格式
输入格式：
第一行输入一个 TT 代表章鱼烧的保质期，也就是说章鱼烧放置的超过 t秒就算过期，不能卖了。
第二行输入一个 nn 代表章鱼烧的数量。
第三行输入从 到 的 n个正整数，代表每个章鱼烧做出来的时间。
第四行输入一个 m 代表客人的数量。
第五行输入从 ​ 到 的 m 个正整数，表示每个客人来的时间。
输出格式：
如果所有的客人都会卖章鱼烧的话，请输出yes，如果卖不出去的话，请输出no。 另外，请在输出的末尾加入换行。
说明：
Sample Explanation 1
-每一个客人都买了一秒前做成的章鱼烧，可以给所有的客人卖章鱼烧。
Sample Explanation 2
-不能卖给最后的客人章鱼烧。
Sample Explanation 3
-高桥君的章鱼烧店很受欢迎。
Sample Explanation 4
-让第三位客人久等了。
输入输出样例：
样例1
输入：
1 3 1 2 3 3 2 3 4 输出：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d35bedcfb19f195df13293bbdc1baa76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5fe6f764797609010014a13b3963c25/" rel="bookmark">
			C&#43;&#43; 第五周
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类和动态内存分配 动态内存和类 C++ 使用 new 和 delete 运算符来动态内存分配。遗憾的是，在类中使用这些运算符将导致许多新的编程问题。这时，析构函数是必不可少的，有时候还必须重载运算符。
新的存储类型静态类成员.
下面是一个示例：
// strngbad.h #include&lt;iostream&gt; #ifnedf STRNGBAD_H_ #define STRNGBAD_H_ class StringBad { private: char * str; int len; static int num; public: StringBad(const char * s); StringBad(); ~StringBad(); // friend function friend std::ostream &amp; operator&lt;&lt;(str:ostream &amp; os, const StringBad &amp; st); }; #endif 静态类成员有一个特点：无论创建了多少对象，程序都只创建一个静态类变量副本。也就是说，类的所有对象共享同一个静态成员，这对于所有类对象都具有相同值的类私有数据是非常方便。
// strngbad.cpp #include&lt;cstring&gt; #include "strngbad.h" using std::cout; int String::num = 0; // class methods StringBad::StringBad(const char * s) { len = std::strlen(s); str = new char[len + 1]; std::strcpy(str,s); num++; cout &lt;&lt; num &lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5fe6f764797609010014a13b3963c25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b09fc222ee22bae3ee950cd6bf064fe/" rel="bookmark">
			MFC界面背景颜色（改暗黑系列）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在.h头文件里声明一个方法RefreshControl() void RefreshControl(UINT uCtlID); 在.cpp创建void xxxxDlg::RefreshControl(UINT uCtlID) void xxxxDlg::RefreshControl(UINT uCtlID) { CRect rc; GetDlgItem(uCtlID)-&gt;GetWindowRect(&amp;rc); ScreenToClient(&amp;rc); InvalidateRect(rc); UpdateWindow(); } 在void xxxxDlg::OnPaint()方法中添加代码刷新界面 void xxxxDlg::OnPaint() { if (IsIconic()) { ...... ... } else {//添加背景色 CRect rc; GetClientRect(&amp;rc);// 获取客户区 CPaintDC dc(this); dc.FillSolidRect(&amp;rc, RGB(64, 64, 64)); // 填充客户区颜色 CDialogEx::OnPaint(); } } 由于背景为黑色，则需要将文本字体改为白色； 在类向导添加WM_CTCOLOR消息 在刚添加的OnCtlColor中加入代码
if (pWnd-&gt;GetDlgCtrlID() == 要改变颜色的文本控件ID) { pDC-&gt;SetBkMode(TRANSPARENT); //设置背景透明 pDC-&gt;SetTextColor(RGB(255, 255, 255)); return HBRUSH(GetStockObject(HOLLOW_BRUSH)); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dd9bf01211c061d6b6544d6856450ab/" rel="bookmark">
			[小米电视][原创]小米电视播放mkv没声音解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小米电视自带的高清播放器功能有限所以需要下载其他播放器，经过查询得知，需要先在网上下载一个当贝市场，去官网下载就行，注意安装时候我是把apk放到U盘插到电视USB接口上直接打开安装的，安装后在里面搜索MX播放器，下载完毕后打开后发现还是没声音，这是因为MX播放器需要设置2个参数。
第一个是软解码还是硬解码，我们一定要选软解码
第二个如果你是双语的，需要在三个点选择音轨即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18588e076ef0b21d420baab2d7303aa5/" rel="bookmark">
			数理知识：偏t分布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hello，大家好！最近有在学习一些有关偏态分布的数理知识，但在搜偏 t t t分布的相关资料的时候感觉比较散，所以做个整理，主要参考的书籍是Azzalini在2014年出版的一本有关偏态分布族的书《The Skew-Normal and Related Families》，大家可以文末获取，有哪里理解不对的地方，还请各位大佬多多指正。
目录 偏 t t t分布定义资源获取 偏 t t t分布定义 偏 t t t分布的生成，可以通过调节 t t t分布的尾部厚度来实现，那么我们先来写下 t t t分布的概率密度函数
t ( x ; ν ) = Γ ( ν + 1 2 ) π ν Γ ( ν 2 ) ( 1 + x 2 ν ) − ν + 1 2 , x ∈ R , t(x;\nu)=\frac{\Gamma(\frac{\nu+1}{2})}{\sqrt{\pi \nu}\Gamma(\frac{\nu}{2})}\big( 1+\frac{x^2}{\nu} \big)^{-\frac{\nu+1}{2}},\qquad x \in \mathbb{R}, t(x;ν)=πν ​Γ(2ν​)Γ(2ν+1​)​(1+νx2​)−2ν+1​,x∈R,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18588e076ef0b21d420baab2d7303aa5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f12bc5f748790a38dfff81cc151286e9/" rel="bookmark">
			IntelliJ IDEA必会的几个常用设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA 全称 IntelliJ IDEA，是java编程语言开发的集成环境。IntelliJ在业界被公认为最好的java开发工具，以下归纳了初学者使用idea的一些常用设置。
一、ctrl+滚轮调整页面大小
File/Settings/Editor/General
二、自动导包/自动移除不用包
File/Settings/Editor/General/Auto Import
三、设置主题
File/Appearance &amp; Behavior/Appearance
四、忽略大小写进行提示
File/Settings/Editor/General/Code Completion
五、设置默认字体大小
File/Settings/Editor/font
六、修改注释颜色
File/Settings/Editor/Color Scheme/Language Defaults
七、添加文档开头注释
File/Settings/Editor/Code Style/File and Code Templates
八、自动编译
File/Settings/Build,Execution,Deploy/Compiler
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c22dd4da53db3bb418d3b68a4d967ec/" rel="bookmark">
			STM32F10X（库版本）串口发送字符串到上位机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 通讯的三种方式 2异步同步的区别 3 代码 1 通讯的三种方式 1）单工通讯 ：一端只能是接收 一端也只能发送 只能单向传输 比如 打印机
2）半双工 ：两边都可以作为发送和接收 但是 是在某个时刻 比如 对讲机 一端是接收而一端只能发送 反过来也是可以的 3）全双工 ：也就是和半双工的时间端相反 任意时刻都可以。
2异步同步的 区别 我们只需看它本身有没有自带时钟 如果有 就是 同步 没有 就 不是 3 代码
时钟 我们用的是 GPIOA 并且 用了 串口一
RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOA,ENABLE); RCC_APB2PeriphClockCmd( RCC_APB2Periph_USART1,ENABLE); GPIOA 结构体成员配置 PA10 是接收（RX）PA9 发送 (TX) GPIO_InitStruct.GPIO_Mode =GPIO_Mode_AF_PP; GPIO_InitStruct.GPIO_Pin =GPIO_Pin_9; GPIO_InitStruct.GPIO_Speed =GPIO_Speed_50MHz; GPIO_Init(GPIOA,&amp;GPIO_InitStruct); GPIO_InitStruct.GPIO_Mode =GPIO_Mode_IN_FLOATING; GPIO_InitStruct.GPIO_Pin =GPIO_Pin_10; GPIO_InitStruct.GPIO_Speed =GPIO_Speed_50MHz; GPIO_Init(GPIOA,&amp;GPIO_InitStruct); 配置的话 我们需要看相关中文参考手册
串口的结构体配置
USART_InitStruct.USART_BaudRate =115200; USART_InitStruct.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c22dd4da53db3bb418d3b68a4d967ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2450ec3551d76e801ddc16d110dd3a01/" rel="bookmark">
			如何在 Go (Golang) 中重用 HTTP 连接（复用TCP）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Golang中想要复用之前的TCP连接，必须要把上一个连接的Body读取完毕才能复用
检查工具：httptrace.ClientTrace
测试代码：
package main import ( "context" "io" "io/ioutil" "log" "net/http" "net/http/httptrace" ) func main() { // client trace to log whether the request's underlying tcp connection was re-used clientTrace := &amp;httptrace.ClientTrace{ GotConn: func(info httptrace.GotConnInfo) { log.Printf("conn was reused: %t", info.Reused) }, } traceCtx := httptrace.WithClientTrace(context.Background(), clientTrace) // 1st request req, err := http.NewRequestWithContext(traceCtx, http.MethodGet, "http://test.com/test.php", nil) if err != nil { log.Fatal(err) } res, err := http.DefaultClient.Do(req) if err !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2450ec3551d76e801ddc16d110dd3a01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d61cbbb1548c95cc299bd63b5f9ee14b/" rel="bookmark">
			Linux httpd配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.使用域名访问
1）修改Linux中的 /etc/hosts文件(windows在)
[root@localhost /]# vim /etc/hosts 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 192.168.10.100 www.rhce.com www.rhcsa.com #添加IP对应的域名 2）创建文件
[root@localhost /]# mkdir -p /www/name/{rhce,rhcsa} [root@localhost /]# echo "this is rhce page" &gt; /www/name/rhce/index.html [root@localhost /]# echo "this is rhcsa page " &gt; /www/name/rhcsa/index.html 3)在/etc/httpd/conf.d/目录下创建name.conf文件并进行配置
[root@localhost conf.d]# vim name.conf &lt;Directory "/www/name"&gt; AllowOverride none Require all granted &lt;/Directory&gt; &lt;VirtualHost 192.168.10.100:80&gt; DocumentRoot "/www/name/rhce" ServerName www.rhce.com &lt;/VirtualHost&gt; &lt;VirtualHost 192.168.10.100:80&gt; DocumentRoot "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d61cbbb1548c95cc299bd63b5f9ee14b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/027f21784c12663e600a236630406400/" rel="bookmark">
			虾皮一面 2022.1.14
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.mysql相关，查询慢，索引没问题怎么优化。答：具体分析sql
2.mysql主从怎么备份。答：从机管主机要redo.log
3.redis除了做缓存有啥用。 答：分布式锁、限流
4.堆排序
5.http是默认tcp还是udp。答：http只能用tcp或者其他可靠协议，udp不可靠
6.dubbo是tcp还是udp。答：tcp。因为可靠
7.算法题：n的阶乘 。答：数值大，用String存储。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/589d0b7c847bfd302d3614c4e803afad/" rel="bookmark">
			洛谷 P1443 马的遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		到达某个点最少走几步，涉及广度优先搜索（BFS），要用到队列。
做题思路：
由输出的矩阵看出这个马只能按照象棋中的走法跳，由此可以定义一个移动的数组：
int dir[8][2]={{2,1},{1,2},{-1,2},{-2,1},{-2,-1},{-1,-2},{1,-2},{2,-1}};//可以跳八个方向 不能到达则输出 -1，那么可以用数组标记
bool vis[410][410]; 不用数组标记也可以直接把矩阵初始化为-1，可用双重for循环，也可以用memset函数
int mp[410][410];//矩阵 memset(mp,-1,sizeof(mp));//将mp[][]初始化为-1 因为是一层层搜索，可以直接得到最短步数用mp[][]来记录，不用额外定义变量记录最短步数
for(int i=0;i&lt;8;i++)//八个方向 { int nx = S.front().zx + dir[i][0]; int ny = S.front().zy + dir[i][1]; if( nx&gt;=1 &amp;&amp; nx&lt;=n &amp;&amp; ny&gt;=1 &amp;&amp; ny&lt;=m &amp;&amp; mp[nx][ny]==-1 ) //一层层搜该层的点八个方向可以到达且没有到过的点 { S.push((Node){nx,ny,S.front().step+1}); mp[nx][ny]=S.front().step+1; //记录到达该点所用步数，并且可使下层搜索不再搜索到该点，即已得到最短步数 } } 两组数据测试完没问题，结果交上去全WA，然后发现格式不对，场宽5注意到了，没注意到左对齐
这下OK了
#include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;cstring&gt;//memset()要用到的头文件 #include&lt;iomanip&gt;//setw()要用到的头文件 using namespace std; int n,m,x,y;//1≤x≤n≤400，1≤y≤m≤400 int mp[410][410];//矩阵 int dir[8][2]={{2,1},{1,2},{-1,2},{-2,1},{-2,-1},{-1,-2},{1,-2},{2,-1}};//可以跳八个方向 struct Node//定义个结构体储存变量用到队列中 { int zx,zy,step; } ; int main() { cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y; memset(mp,-1,sizeof(mp)); mp[x][y]=0; queue &lt; Node &gt; S; S.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/589d0b7c847bfd302d3614c4e803afad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffa2b69a6848af8497f7561074c91f01/" rel="bookmark">
			动态语言和静态语言的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 动态语言和静态语言的区别 区别一 静态类型语言是指在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型，像java，c#就是静态语言动态类型语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明，像javaScript，PHP就是动态语言 区别二 静态类型语言编译时会进行类型匹配检查，所以不能给变量赋予不同类型的值（除非用向上转型的技术来取得多态的效果）。动态类型语言的变量类型在运行期是可变的，这意味着对象的多态性是与生俱来的。 优势 静态语言的优势 静态类型语言因为类型强制声明，在代码感知能力上要强很多，在开发大型系统，复杂系统比较有保障 动态语言的优势 编写的代码数量少，看起来更简洁，可以把精力更多地放在业务逻辑上。动态语言更加灵活 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7af9cab0e05a347733c2626f87e185da/" rel="bookmark">
			刷穿力扣 | 2. 两数相加
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		龙哥主动看的第一道算法题，必须安排一篇博客
java语言实现，击败100%
题目 原题链接：点这里
难度：中等
思路 两个链表，每一个节点就是一位数字，然后相加，两个小于10的数字相加，有两种可能。
大于等于10，需要进位小于10，不需要进位 运算肯定是从各位开始计算，而题目恰好链表的头节点都是个位的节点，那么我们同时遍历两个链表，遍历过程中的节点就是同一位上的节点，个位、十位、百位、千位。直接相加即可，当然，有可能是10000 + 1，如果链表在那个位上为空，我们当做0来处理即可。
那么如果大于10要进位怎么办，我们可以定义一个变量moreTen，用来记录上一位的计算是不是大于10，如果是的话，本位的计算还要多加一个1。本位计算的时候，如果结果大于10，我们就取个位，然后把变量moreTen置位true即可，如果不是大于十记得把变量moreTen复位。
运算完了之后如果moreTen还是true，那就是类似这种情况99 + 99，最高位应该是1，我们要特殊处理一下。
最后要注意的是，遍历链表的时候不要出现空指针。
代码 class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { // 哨兵节点，避免首节点为空的校验 ListNode temp = new ListNode(-1); // 持有哨兵节点的引用 final ListNode ans = temp; // 上一次的计算结果是否超过了10 boolean moreTen = false; while (l1 != null || l2 != null) { // 获取相加的两数，如果为空就当做0处理 int num1 = (l1 == null) ? 0 : l1.val; int num2 = (l2 == null) ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7af9cab0e05a347733c2626f87e185da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/267865658f3a6391535a40df7e39989c/" rel="bookmark">
			centos7.5 搭建VNC服务，并设置自启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【需要软件】：tigervnc-server
1、安装VNC软件。
yum –y install tigervnc-server 2、将VNC配置文件复制到/etc/systemd/system下，为vnc配置systemd服务。并启用2端口。
3、修改/etc/systemd/system/vncserver@ :2.server 文件
4、root用户访问vnc，设置密码。
5、启动VNC服务，并设置开机自启动。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7db5cb18474aa033f33064d575980698/" rel="bookmark">
			云计算与大数据技术应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是云计算
云计算的定义
PC时代以前，计算机用户主要通过终端分享主机（可以理解为服务器）的计算和存储，获得有限的服务。这样的模式就好比一个家庭里有许多孩子，每一笔零花钱都要朝父母要，用多少要多少。家里的钱都锁在保险柜里，可以想象对孩子来说想买些小零食小玩具都是比较不自在的体验。1979年IBM推出了IBM-PC，计算机从企业普及到个人，用户可以拥有自己的个人电脑。如果还拿零花钱举例，这个时代就好比让孩子有了自己的小钱包，虽然远不如保险柜里的钱多，但完全由自己掌控，一定程度上摆脱了父母的约束。问题也随之而来，一如钱包可能丢失，个人电脑的数据也会因为电脑病毒而付之一炬。而且一台电脑的文件可能在另一台电脑无法使用，就像没法在美国花人民币一样。再后来，也就进入了云计算最早的阶段。大型数据中心的出现给了IBM机会，IBM开始专门出售用于云计算的服务器。而亚马逊此时则开始购买IBM的服务器建立数据中心，提供网站托管服务。想要提供互联网服务的公司不用自己费心，只要租用亚马逊的服务即可。我们可以认为亚马逊开设了自己的银行，从IBM大量购买“保险柜”，然后将管理存款、计账、提供交易明细的服务卖给客户。自此钱便不需要放在自家保险柜，可以直接交给亚马逊，用户没有了保险柜的概念，只知道自己有一个账户，里面是自己的存款。而作为互联网巨头的谷歌，解决了云计算的关键技术问题，其中包括海量数据存储、计算资源管理和信息安全三方面。我们可以认为，谷歌直接搭建了整个银行系统，设置了央行和各个商业银行的分行，组织了专门的银行柜员，让客户的钱可以在全国银行实现统一调度，不用去管自己的钱到底是放在哪家银行的哪个分行、哪个保险柜。同时谷歌还设置了安保系统，防止有人抢银行。至此账户和保险柜完全分离，用户只要享受存取款的服务即可。
云计算的特点
第一，云计算保证用户可以随时随地访问和处理信息，并且可以方便地与人共享信息”：在过去分享文件只能通过U盘拷贝，而且到了别人的电脑上还未必可以打开。想要处理信息的话，用户一定要电脑在手边，现在在任何终端都可以完成，而且在线应用软件分享数据功能比个人电脑强得多。这就好比支付宝的存在让我们从此免去了去银行取钱的过程，想要借钱给别人只需要在线转账即可。而且即使在海外消费，也可以直接按实时汇率把美元折合成人民币扣费。“第二，云计算保证用户可以使用大量在云端的计算资源，而无需自己购入设备，压低了用户成本，且用户不用担心数据丢失、病毒入侵等麻烦”：这一点不难理解，如果还要类比的话，我们把钱存在银行就免去了过去自己选购保险柜的过程和费用，而且把钱放在银行也方便保管，不必承担失窃的风险，反倒是那些藏在自家土炕里的钱全部发霉腐坏了。“第三，云计算让全社会的计算资源得到最有效的利用”：我们可以想象，银行的保险柜利用率肯定要远比家庭的高，同样一大笔财宝，放在银行要比分放在零散的家庭占用的保险柜数量少得多。同时银行还可以灵活周转，若是现在每个家庭都把钱从银行取出来放回自己家里，那世界经济得倒退百年都不止。云计算的出现就好比加速了这百余年的经济发展，让互联网服务进一步迎来一个井喷的时代。“第四，云计算可以让用户完成以前根本完成不了的任务”：现在，云计算工具可以把工作并行地安排到互联网上闲置的服务器中，几分钟之内完成任务。还是同样的例子，身家上亿的富翁要是把钱都放在自己家里自己数，每消费一笔巨款也要再数一笔钱出来，那可能真要数钱数到死了，而现在银行负责了一切，用户只需要在线查看自己账户的余额和交易明细就可以了。“第五，云计算把整个云端的服务器资源作为整体保存，然后根据用户的需求动态分派这些资源”：现在公司购买计算资源，只需要指定需要的资源数目，而无需考虑设备问题。就好比银行的储户不必去管自己的钱到底是放在银行的哪个分行、哪个保险柜，消费时直接刷卡消费，不用考虑整存争取，买买买就是了。简单讲云计算的几大优点就是，省心、省心和省心，解放了所有基于互联网的业务。
经典的云计算基础架构
云计算架构——显示层　这层主要是用于以友好的方式展现用户所需的内容，并会利用到下面中间件层提供的多种服务，主要有五种技术：　HTML：标准的Web页面技术，现在主要以HTML4为主，但是将要推出的HTML5会在很多方面推动Web页面的发展，比如视频和本地存储等方面。　JavaScript：一种用于Web页面的动态语言，通过JavaScript，能够极大地丰富Web页面的功能。　CSS：主要用于控制Web页面的外观，而且能使页面的内容与其表现形式之间进行优雅地分离。　Flash：业界最常用的RIA(Rich Internet Applications)技术，能够在现阶段提供HTML等技术所无法提供的基于Web的富应用，而且在用户体验方面，非常不错。　Silverlight：来自业界巨擎微软的RIA技术，虽然其现在市场占有率稍逊于Flash，但由于其可以使用C#来进行编程，所以对开发者非常友好。　云计算架构——中间层　这层是承上启下的，它在下面的基础设施层所提供资源的基础上提供了多种服务，比如缓存服务和REST服务等，而且这些服务即可用于支撑显示层，也可以直接让用户调用，并主要有五种技术：　REST：通过REST技术，能够非常方便和优雅地将中间件层所支撑的部分服务提供给调用者。　多租户：就是能让一个单独的应用实例可以为多个组织服务，而且保持良好的隔离性和安全性，并且通过这种技术，能有效地降低应用的购置和维护成本。　并行处理：为了处理海量的数据，需要利用庞大的X86集群进行规模巨大的并行处理，Google的MapReduce是这方面的代表之作。　应用服务器：在原有的应用服务器的基础上为云计算做了一定程度的优化，比如用于Google App Engine的Jetty应用服务器。　分布式缓存：通过分布式缓存技术，不仅能有效地降低对后台服务器的压力，而且还能加快相应的反应速度，最著名的分布式缓存例子莫过于Memcached。　云计算架构——基础设施层　这层作用是为给上面的中间件层或者用户准备其所需的计算和存储等资源，主要有四种技术：　虚拟化：也可以理解它为基础设施层的“多租户”，因为通过虚拟化技术，能够在一个物理服务器上生成多个虚拟 机，并且能在这些虚拟机之间能实现全面的隔离，这样不仅能减低服务器的购置成本，而且还能同时降低服务器的运维成本，成熟的X86虚拟化技术有 VMware的ESX和开源的Xen。　分布式存储：为了承载海量的数据，同时也要保证这些数据的可管理性，所以需要一整套分布式的存储系统。　关系型数据库：基本是在原有的关系型数据库的基础上做了扩展和管理等方面的优化，使其在云中更适应。　NoSQL：为了满足一些关系数据库所无法满足的目标，比如支撑海量的数据等，一些公司特地设计一批不是基于关系模型的数据库。云计算架构——管理层　这层是为横向的三层服务的，并给这三层提供多种管理和维护等方面的技术，主要有下面这六个方面：　帐号管理：通过良好的帐号管理技术，能够在安全的条件下方便用户地登录，并方便管理员对帐号的管理。　SLA监控：对各个层次运行的虚拟机，服务和应用等进行性能方面的监控，以使它们都能在满足预先设定的SLA(Service Level Agreement)的情况下运行。　计费管理：也就是对每个用户所消耗的资源等进行统计，来准确地向用户索取费用。　安全管理：对数据，应用和帐号等IT资源采取全面地保护，使其免受犯罪分子和恶意程序的侵害。　负载均衡：通过将流量分发给一个应用或者服务的多个实例来应对突发情况。　运维管理：主要是使运维操作尽可能地专业和自动化，从而降低云计算中心的运维成本。 云计算架构其中有三层是横向的，分别是显示层、中间件层和基础设施层，通过这三层技术能够提供非常丰富的云计算能力和友好的用户界面，云计算架构还有一层是纵向的，称为管理层，是为了更好地管理和维护横向的三层而存在的。
云计算主要服务模式
对于企业来说，可能会需要一套OS系统来解决办公自动化的问题；或者通过使用ERP系统帮助提升管理效率；再者用到定制化的CRM系统助力工作的精准度等等。最初想要实现这些应用，需要企业自己购买服务器、硬件以及开发团队，自从云计算出现以后，想要得到这样一套应用变得简单了，没有专业的团队也能够得到满足自己搭建需求的应用。根据NIST（美国国家标准与技术研究院）的权威定义，云计算的服务模式SPI，即SaaS、PaaS和IaaS。 SaaS软件即服务SaaS系统，英文全称“Software-as-a-Service”，中文全称“软件即服务”。常见的SaaS产品种类包括ERP（企业资源计划）、CRM（客户关系管理）、OA（办公自动化）、EHR（人力资源管理）、SCM（供应链管理）等。传统软件系统基于本地，而云计算系统将本地服务器搬到了云端，通过软件连接互联网使用。主要有以下特点：软件系统的运行不受限于本地物理主机的性能，而是高速运行在云端服务器上；云端服务器24小时开机运行，只要连接互联网便可实现“随时”、“随地”的访问使用；方便随时在线收集用户需求，对SaaS平台进行集中维护更新；基于模块化功能开发，企业可根据不同行业用户需求快速迭代产品。最容易接触到关于SaaS的小程序或者软件，如H5应用、阿里钉钉、腾讯企业微信、云创办公等，这些应用平台上可提供各类SaaS小软件，从OA到ERP，再到CRM等等，可涵盖企业运行所需的几乎所用应用。 PaaS平台即服务PaaS系统，英文全称“Platform-as-a-Service”，中文全称“平台即服务”，也可以称之为“中间件”服务。传统软件离不开本地配置开发环境和服务器等设备，PaaS平台可以提供基础架构，开发者可以在此之上构建新的应用，或者二次开发新的功能，缩短应用的开发周期。主要有以下特点：提供已经开发完成的功能模块“中间件”，缩短开发者开发周期；节省本地开发硬件设备采购与维护费用；基于Web的开发环境，方便不同开发者、工作室跨区域、跨空间协作；PaaS平台可为应用提供实时的管理与监控，开发者可通过具体数值观察应用的运行状态。PaaS能够提供各种开发和分发应用的解决方案，如虚拟服务器和特定的操作系统。能够节省硬件上的费用，也让各类应用的开发更加便捷，让不同工作间的打通变得容易。熟知的PaaS平台就有百度BAE、新浪SAE、阿里Ali、腾讯云、云创办公等等，很多电商平台、视频网站等都可以通过PaaS实现快速部署。IaaS基础设施即服务IaaS系统，英文全称“Infrastructure-as-a-Service”，也可称之为“Hardware-as-a-Service”，中文全称“基础设施即服务”。IaaS服务一般分为三类：公有云（置于Internet上，面向注册、付费用户，核心属性是共享资源服务）、私有云（置于私有环境中，服务于单个客户，对数据、安全性和服务质量的提供最有效控制）、混合云（融合了公有云和私有云，将内部重要数据保存在本地数据中心，同时也可以使用公有云的计算资源）。IaaS提供的场外服务器，存储和网络硬件，可以进行租用，降低成本和办公场地费用，可随时通过这些硬件来运行其应用。熟知的IaaS服务有服务器托管业务，多数的IDC都提供这样的服务，用户自己不想要再采购价格昂贵的服务器和磁盘阵列了，所有的硬件都由IaaS提供，并且还能获得品质更高的网络资源。
云计算主要部署模式
公有云：众多企业公用一个云服务器，可以理解为共享资源服务。如果公有云比喻成出租公寓，那么企业就是其中的租户之一，当企业选择停止租用时，空间将被清理并释放出来租给下个租户。公有云的优点是价格低廉、使用便捷、节省维护成本，所以用户多以创业公司和个人居多。缺点是不够安全，容易发生文件泄露的风险，而且当需要移动大量数据的时候，企业面临的将是很大一笔费用。私有云：服务器可以是企业自己建立也可以是租用第三方服务器，企业独享服务器只为该企业提供数据服务。如果公有云是出租公寓，那么私有云就是独门独户的小别墅。私有云的优点是提供了更加安全的环境，用户可以根据需求选择定制其资源。缺点是安装成本高，高度安全性可能会使部分功能操作有局限性。混合云：混合了公有云和私有云的一种解决方式，企业可以将重要文件放置私有云，普通文件放置公有云，两者之间可以进行数据和应用的移植。混合云的优点是可以满足企业多样化需求，节省必要的开支。缺点是开发过程中因兼容等问题会变得比较复杂，后期的维护也需要花费时间和人力，对于企业的实力要求较高。
经典的云计算产品
亚马逊AWS（Amazon Web Services (AWS) ）是亚马逊提供的专业云计算服务，于2006年推出，以Web服务的形式向企业提供IT基础设施服务，通常称为云计算。其主要优势之一是能够以根据业务发展来扩展的较低可变成本来替代前期资本基础设施费用。亚马逊网络服务所提供服务包括：亚马逊弹性计算网云（Amazon EC2）、亚马逊简单储存服务（Amazon S3）、亚马逊简单数据库（Amazon SimpleDB）、亚马逊简单队列服务（Amazon Simple Queue Service）以及Amazon CloudFront等。
IBM在2007年11月15日推出了蓝云计算平台，为客户带来即买即用的云计算平台。它包括一系列的云计算产品，使得计算不仅仅局限在本地机器或远程服务器农场（即服务器集群），通过架构一个分布式、可全球访问的资源结构，使得数据中心在类似于互联网的环境下运行计算。通过IBM的技术白皮书，我们可以一窥蓝云计算平台的内部构造。“蓝云”建立在IBM大规模计算领域的专业技术基础上，基于由IBM软件、系统技术和服务支持的开放标准和开源软件。简单地说，“蓝云”基于IBM Almaden研究中心（Almaden Research Center）的云基础架构，包括Xen和PowerVM虚拟化、Linux操作系统映像以及Hadoop文件系统与并行构建。“蓝云”由IBM Tivoli软件支持，通过管理服务器来确保基于需求的最佳性能。这包括通过能够跨越多服务器实时分配资源的软件，为客户带来一种无缝体验，加速性能并确保在最苛刻环境下的稳定性。IBM新近发布的“蓝云（Blue Cloud）”计划，能够帮助用户进行云计算环境的搭建。它通过将Tivoli、DB2、WebSphere与硬件产品（目前是x86刀片服务器）集成，能够为企业架设一个分布式、可全球访问的资源结构。根据IBM的计划，首款支持Power和x86处理器刀片服务器系统的“蓝云”产品将于2008年正式推出，并且计划随后推出基于System z“大型主机”的云环境，以及基于高密度机架集群的云环境。
阿里云服务大概分两个方面：1、把传统的计算机系统（包括软件、硬件等）SAAS化，终端用户不再关心底层建设，只需要按需求购买服务即可。比如云服务器ECS、云数据库RDS、云存储OSS/NAS、云防火墙等等，原来都是需要自建购买软硬件来完成相应的业务，现在可以全部以服务形式购买、使用；2、把分散、独立的服务聚合在一起。比如域名注册、企业邮箱服务、短信服务、安全验证服务、大数据服务等等再针对性举例：云服务器ECS云服务器ECS相当于一台虚拟服务器，基于庞大的物理服务器集群虚拟出来的，但可以像独立服务器一样使用，常见的是作为应用服务器（基于容器提供web服务）或数据库服务器（当然，阿里有专业的云数据库，在此不做多述）。应用服务器中最简单的一种应用方式是，比如个人博客、企业官网、web业务系统等，邮件服务之外（ECS默认禁用邮件SMTP服务25 端口，特殊情况需报备审核后使用）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7db5cb18474aa033f33064d575980698/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/69/">«</a>
	<span class="pagination__item pagination__item--current">70/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/71/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>