<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/564236510b293d9a0a686ca21bea7274/" rel="bookmark">
			Fiddler工具 — 19.Fiddler抓包HTTPS请求（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5、查看证书是否安装成功 方式一： 点击Tools菜单 —&gt; Options... —&gt; HTTPS —&gt; Actions
选择第三项：Open Windows Certificate Manager打开Windows证书管理器。
打开Windows证书管理器，选择操作—&gt;查看证书，在搜索框中输入Fiddler来查看证书。
查看结果：
然后可以选择一个证书，进行打开、删除、导出等操作。
方式二： WIN+R打开电脑命令提示符，输入certmgr.msc并回车，打开Windows证书管理器。
之后步骤同上。
6、HTTPS选项界面说明 Fiddler can decrypt HITTPS sessions by re-signing traffic using self-generated certificates.
Fiddler可以使用自行生成的证书对流量进行重新签名，从而对HITTPS会话进行解密。
Capture HTTPS CONNECTs：建立HTTPS连接通信。
这个就是我们之前常看到有tunnel to...443请求的原因，他是HTTPS建立通信时候所发出的请求。
我们使用Rules菜单 —&gt; Hide CONNECTs操作，把这些请求隐藏了。
Decrypt HTTPS traffic：解密HTTPS请求。
下拉列表
from all processes : 抓取所有的HTTPS程序, 包括本机和手机 。
from browsers only : 只抓取浏览器中的HTTPS请求。
from non-browsers only : 只抓取除了浏览器之外的所有HTTPS请求。
from remote clients only ： 抓取远程的客户端的HTTPS,可以代表手机。
Ignore server certificate errors (unsafe)：忽略服务器证书错误（不安全）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/564236510b293d9a0a686ca21bea7274/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49df2646867c6808b0220f6b04950562/" rel="bookmark">
			【数据结构】单向循环链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、mian函数 #include &lt;stdio.h&gt; #include "./3.looplinklist.h" int main(int argc, const char *argv[]) { looplinklist* head = create_looplinklist(); insertHead_looplinklist(head,100); insertHead_looplinklist(head,200); insertHead_looplinklist(head,300); show_looplinklist(head); insertEnd_looplinklist(head,999); insertEnd_looplinklist(head,888); insertEnd_looplinklist(head,666); show_looplinklist(head); delHead_looplinklist(head); show_looplinklist(head); delEnd_looplinklist(head); show_looplinklist(head); insertByindex_looplinklist(head,2,55555); show_looplinklist(head); insertByindex_looplinklist(head,20,10086); show_looplinklist(head); delByindex_looplinklist(head,4); show_looplinklist(head); delByindex_looplinklist(head,16); show_looplinklist(head); return 0; } 二、功能函数 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include "./3.looplinklist.h" looplinklist* create_looplinklist() { looplinklist* head =(looplinklist*)malloc(sizeof(looplinklist)); if(NULL == head) { printf("头结点创建失败，链表创建失败\n"); return NULL ; } head-&gt;text.len = 0; head-&gt;next= head; return head; } //遍历 void show_looplinklist(looplinklist*head) { looplinklist*p=head; while(p-&gt;next !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49df2646867c6808b0220f6b04950562/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2efe3b9eff31425e5cf1e7a6b217da81/" rel="bookmark">
			有方机器人 STM32智能小车 项目学习笔记2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天是学习有方机器人课程的第二天，通过课程复习GPIO相关知识点，很有收获，老师讲的非常好！
处理器控制硬件原理 处理器在日常工作时有两种功能，第一个是负责基本的数据运算和逻辑运算，第二是控制硬件外设。
对于处理器来说，正常工作时需要去运行程序，而处理器本身只能运行程序，不能存储程序，程序是存储在内部的只读存储器（ROM）中，处理器如何执行程序呢？从ROM里读一条执行一条程序，程序中涉及到的运算就通过RSV来执行，运算结果的数据就存在了RAM里面；
RAM和ROM最大的区别就是RAM掉电后就丢失数据，ROM掉电后不丢失，下次上电后依旧运行之前的程序。
RAM：随机存取存储器（random access memory），又称作“随机存储器”，是与CPU直接交换数据的内部存储器，也叫主存(内存)。
ROM：只读存储器（Read Only Memory），是一种只能读出事先所存的数据的固态半导体存储器。ROM中所存数据稳定，一旦存储数据就再也无法将之改变或者删除，断电后所存数据也不会消失。其结构简单，因而常用于存储各种固化程序和数据。
处理器不只是简单的进行数据运算操作，还要进行复杂的控制硬件外设操作
处理器如何控制硬件外设呢？由于CPU 本身是不能直接控制硬件的，硬件一般由其对应的控制器来控制，每一个硬件控制器内部都有其自己的寄存器，开发人员通过向某一硬件控制器内部的寄存器写入特定的值配置该寄存器，依次到达控制该硬件控制器的目的。
在处理器中将各个硬件控制器映射到了 CPU 地址空间中的一段范围，这样 CPU 就可以通过读写寄存器来间接控制硬件。通过IO来实现。比如开发人员想要控制GPIO，需要往GPIO内部寄存器中写入特定的值来配置寄存器，配置好后硬件就会实现对应的功能。
硬件寄存器的本质就是存储器，把开发人员写入的值存在里面，这样硬件就会按照写入值得寄存器的功能执行相应的工作，开发人员通过写入或读取相应寄存器实现数据交互过程，相当于与单片机进行“对话”。
对于处理器来讲，读取存储器里的数据有一个范围，这个范围就是由处理器内部的地址空间决定，对于RAM32位处理器来说，它的读写的范围就是2的32次方=4G，即地址空间大小=4G。
当我们要控制某一外设时，往对应寄存器中写入一个值就可以，以上就是处理器控制硬件原理。
地址映射表 处理器分配地址空间的这一过程就叫做映射，把相应外设寄存器对应的地址映射到处理器的内部地址空间中。在一个处理器中，一般会将 ROM、RAM、寄存器存储设备分别映射到寻址空间中的不
同地址段，我们将这个映射关系称为处理器的地址映射表。简单的来说就是处理器读取程序就去 ROM 对应的地址段读取，存储数据就到 RAM 对应的地址段存储，控制硬件控制器就到其内部的寄存器所对应的地址段进行读写操作，而 ROM、RAM、寄存器这三者的地址段会形成一张表，将其称为处理器的地址映射表。
启动模式 程序通过ST-Link下载到ROM里，启动模式为主闪存存储模式。
STM32F10X.H 头文件 STM32F10X 系列单片机内部的寄存器数量多且复杂，而此文件是对 STM32 寄存器地址、结构体类型定义的底层头文件，由ST 公司提供，使用 STM32 库时都要包含该文件。
GPIO 的输入输出 通过参考手册，我们知道GPIO的内部结构如下。
输出：
开漏模式下，输出驱动器的P-MOS管失效，当写入0到对应寄存器时，输出控制会响应寄存器里的配置，由于N-MOS管导通，IO引脚被拉低；当写入1时，由于P-MOS失效，呈现高阻态，需要外接上拉电阻才能把IO引脚拉高。低电平有驱动能力，高电平呈高阻态无驱动能力。
推挽模式下，P-MOS和N-MOS都是有效的。写入1，IO引脚拉高；写入0，IO引脚拉低。低电平和高电平都有效有驱动能力
输入：
模拟输入不经过TTL施密特触发器，施密特触发器本质上来讲就是用来滤波，当信号高于上限值就转换为高电平，低于下限值为低电平。
复用功能输入通过TTL施密特触发器，达到一个滤波的作用。
IO引脚处的两个二极管，起到保护电路的作用。
代码部分(知识点查漏补充) 1、 在对应外设的.h文件里，能找到该外设所有封装函数声明。
/** * @brief Writes data to the specified GPIO data port. * @param GPIOx: where x can be (A.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2efe3b9eff31425e5cf1e7a6b217da81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c95cfa63f23a9138b3c45d3aa89183e2/" rel="bookmark">
			进度条小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 铺垫回车换行缓冲区概述强制冲刷缓冲区 简单实现倒计时功能进度条小程序版本一实例代码效果展示分析 版本二 铺垫 回车换行 回车和换行是两个独立的动作
回车是将光标移动到当前行的最开始（最左侧）
换行是竖直向下平移一行
在C语言中，\n是同时进行了回车换行，\r实现了回车操作
缓冲区 概述 先来看一个小现象：
实例代码：
#include&lt;stdio.h&gt; #include&lt;unistd.h&gt; int main() { printf("hello gwj,hello Linux...\n"); sleep(3); return 0; } 运行mytest.exe执行程序，会输出hello gwj,hello Linux...，紧接着调用sleep函数，休眠三秒
如果将printf函数中\n删掉，会出现什么结果呢？？
现象：先休眠三秒，在最后结束的狮虎打印出内容
这这种场景中，sleep函数和printf函数，哪一个先运行的呢？？
答案是printf先运行，在休眠的这三秒时间里，printf已经执行完了，字符串被保存在缓冲区
缓冲区的概念需要在操作系统层面上理解，单纯在语言基础上是很难理解的
缓冲区是一个内存空间，当休眠的时候，字符串在缓冲区里，当程序结束return 0时，，强制冲刷缓冲区，再打印出字符串。
强制冲刷缓冲区 任何一个C语言程序都会默认打开三个流：
stdin：标准输入流stdout：标准输出流stderr比爱准错错误 可以通过fflush函数来刷新缓冲区
示例代码：
#include&lt;stdio.h&gt; #include&lt;unistd.h&gt; int main() { printf("hello gwj,hello Linux..."); fflush(stdout); sleep(3); return 0; } 现象：
简单实现倒计时功能 示例代码：
1 #include&lt;stdio.h&gt; 2 #include&lt;unistd.h&gt; 3 int main() 4 { 5 int cnt=9; 6 while(cnt&gt;=0) 7 { 8 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c95cfa63f23a9138b3c45d3aa89183e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63cd87ec49470994d3e6ee337fae619f/" rel="bookmark">
			趣学贝叶斯统计：条件概率(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 到目前为止，我们只讨论了独立事件的概率。当一个事件的结果不影响另一个事件的结果时，这两个事件就是独立事件。例如，掷硬币时出现正面并不影响掷骰子是否会掷出6点。计算独立事件的概率要比计算非独立事件的概率容易得多，但独立事件往往并不能反映现实生活。例如，闹钟不响和上班迟到就不是独立事件。如果闹钟没有响，你上班迟到的可能性就要比其他时候大得多。
在本章中，你将学习如何分析条件概率，即事件的概率不是独立的，而是取决于特定事件的结果。此外，我还将介绍条件概率最重要的应用之一：贝叶斯定理。
一、条件概率 通常，人们患上GBS的概率为2/100 000。
如果你在那一年接种了流感疫苗，患上GBS的概率就会上升到3/100 000
P(患上GBS|接种流感疫苗)= 3 10000 \frac{3} {10000} 100003​
1. 为什么条件概率很重要 条件概率是统计学的重要组成部分，因为它使我们能够证明信息是如何改变信念的。
P ( G B S ｜接种流感疫苗 ) P ( G B S ) = 1.5 \frac{P(GBS｜接种流感疫苗)} {P(GBS)}=1.5 P(GBS)P(GBS｜接种流感疫苗)​=1.5
如果你在2010年接种过流感疫苗，我们就有足够的信息相信你比一个随机挑选的人患GBS的可能性高50%
2. 依赖性与概率法则的修订 在普通人群中，大约有4.25%的人是色盲。绝大多数的色盲病例是遗传性的。色盲症是由X染色体上的基因缺陷引起的。由于男性只有一条X染色体，而女性有两条X染色体，因此男性更易受到X染色体缺陷的不良影响，从而患有色盲的概率约为女性的16倍。因此，虽然整个人群的色盲率为4.25%，但女性是0.5%，而男性则是8%。
P(色盲)=0.0425
P(色盲｜女性)=0.005
P(色盲｜男性)=0.08
如果想求人群中男性的色盲概率，难道是
P(男性，色盲)=P(男性)*P(色盲)吗？那男女色盲的概率不就一样了？
乘法法则只有在事件独立的情况下才有效，而这里的性别和患有色盲症并不是独立的事件。
男性色盲出现的真正概率是男性出现的概率乘以他是色盲的概率。
P(男性，色盲)=P(男性)*P(色盲|男性)
P(A,B)=P(A)*P(B|A)
关于条件概率和统计的依赖性，需要注意的一个重要问题是，在现实中要知道两个事件的关系往往是很困难的。例如，我们可能想知道某人拥有一辆皮卡且上下班时间超过一小时的概率。虽然我们可以提出很多理由表明其中一个事件可能依赖另外一个事件（比如，很多拥有皮卡的人住在郊区，很少通勤），但我们可能找不到数据来证明这一点。假设两个事件独立（即使它们很可能不是）是统计学中非常常见的做法。但是，就像前面计算男性色盲概率的例子一样，这种假设有时会产生非常严重的错误。虽然独立性假设通常是出于实际需要，但我们不能忘记依赖性的影响有多大。
逆概率和贝叶斯定理 除了现有的概率，现在我们只有一条数据：客服代表是色盲。下一步就需要求出总人口中色盲的比例，然后，我们就可以搞清楚色盲人群中有多少是男性了。
为了帮助分析，我们增加一个新的变量N，用它代表总人口的数量。如前所述，首先需要计算出色盲人群的总数。我们知道出现色盲的概率[插图]色盲[插图]，因此可以写出下面这部分等式：
P ( 男性 ∣ 色盲 ) = ? P ( 色盲 ) ∗ N P(男性|色盲)=\frac{?}{P(色盲)*N} P(男性∣色盲)=P(色盲)∗N?​
群体中男性色盲人数？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63cd87ec49470994d3e6ee337fae619f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb47bb6fe5ab4082500c87f2a0dab84e/" rel="bookmark">
			头结点的含义以及引入头结点的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概念
头结点:是虚拟出来的一个节点，不保存数据。头结点的next指针指向链表中的第一个节点。对于头结点，数据域可以不存储任何信息，也可存储如链表长度等附加信息。头结点不是链表所必需的。
头指针:是指向第一个结点的指针,如果链表没有引入头结点，那么头指针指向的是链表的第一个结点。头指针是链表所必需的。
[注意]无论是否有头结点，头指针始终指向链表的第一个结点。如果有头结点，头指针就指向头结点。
二、为何引入头结点
1）对链表的删除、插入操作时，第一个结点的操作更方便
如果链表没有头结点，那么头指针指向的是链表的第一个结点，当在第一个结点前插入一个节点时，那么头指针要相应指向新插入的结点，把第一个结点删除时，头指针的指向也要更新。也就是说如果没有头结点，我们需要维护着头指针的指向更新。因为头指针指向的是链表的第一个结点，如果引入头结点的话，那么头结点的next始终都是链表的第一个结点。
带头结点的单链表
不带头结点的单链表
引入头结点后，头指针指向头结点，那么无论链表是否为空，头指针均不为空。
2）统一空表和非空表的处理
有了头结点之后头指针指向头结点，不论链表是否为空，头指针总是非空，而且头结点的设置使得对链表的第一个位置上的操作与在表中其它位置上的操作一致，即统一空表和非空表的处理。
当你需要创造一条新链表的时候，可以使用头结点简化边界情况的处理。
比如说，让你把两条有序链表合并成一条新的有序链表，是不是要创造一条新链表？再比你想把一条链表分解成两条链表，是不是也在创造新链表？这些情况都可以使用虚拟头结点简化边界情况的处理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/267b4189c017ac69ba685633a163527f/" rel="bookmark">
			npm设置淘宝镜像库为默认库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置淘宝镜像库为默认库
npm config set registry https://registry.npmmirror.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b3b2d106e9e6cf21f6a62a30379e0a4/" rel="bookmark">
			http和https的区别（简述）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP（HyperText Transfer Protocol）和HTTPS（HTTP Secure）都是用于在客户端和服务器之间传输数据的协议，但它们在安全性方面有重要的区别。
1.HTTP: 概述： HTTP是一种用于传输超文本的协议（超文本传输协议），是Web中最基础、最常用的协议之一。工作原理： 数据在客户端和服务器之间以明文形式传输，不加密，可能会被中间人截取和窃听。端口： 默认使用端口80。示例代码（Node.js）： const http = require('http'); const server = http.createServer((req, res) =&gt; { res.writeHead(200, {'Content-Type': 'text/plain'}); res.end('你好HTTP!'); }); server.listen(80, () =&gt; { console.log('端口80'); }); 2.HTTPS : 概述： HTTPS是在HTTP基础上添加了安全性支持的协议，使用TLS/SSL进行数据加密传输。工作原理： 通过使用SSL/TLS协议，对传输的数据进行加密，确保数据在传输过程中的安全性。端口： 默认使用端口443。示例代码（Node.js）： //引入了Node.js中的https模块，该模块提供了创建HTTPS服务器和发起HTTPS请求的功能 const https = require('https'); //这一行引入了Node.js中的fs模块，该模块提供了文件系统相关的功能，例如读取文件内容。 const fs = require('fs'); //这两个模块是 Node.js 的核心模块，通常不需要额外安装。 //它们是 Node.js 提供的基本文件系统和 HTTPS 操作的模块 const options = { key: fs.readFileSync('private-key.pem'), cert: fs.readFileSync('public-cert.pem') }; const server = https.createServer(options, (req, res) =&gt; { res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b3b2d106e9e6cf21f6a62a30379e0a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/452e26e321337f7ea25aeec99ca3932e/" rel="bookmark">
			有向图的邻接表和邻接矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		邻接表 有向图的邻接表是一种常用的表示方法，用于表示图中各个节点之间的关系。在有向图中，每条边都有一个方向，因此邻接表中的每个节点记录了该节点指向的其他节点。
具体来说，有向图的邻接表由一个由节点和它们的邻居节点列表组成的集合构成。对于每个节点，邻接表记录了该节点指向的所有邻居节点。这种表示方法可以用一个哈希表或数组来实现，其中哈希表或数组的键或索引表示节点，对应的值是一个列表，存储了该节点的所有邻居节点。
举例来说，考虑以下有向图：
A -&gt; B, C B -&gt; C, D C -&gt; D D -&gt; A 对应的邻接表表示如下：
A: [B, C] B: [C, D] C: [D] D: [A] 在邻接表中，每个节点及其邻居列表的组合表示了整个有向图的结构。使用邻接表可以有效地表示稀疏图，并且支持快速查找节点的邻居。
java表示这样的邻接表：
在 Java 中，可以使用 Map 来表示有向图的邻接表。具体来说，可以使用 Map&lt;String, List&gt;，其中键是节点的名称（如字符串表示），值是一个列表，存储了该节点指向的所有邻居节点的名称。以下是一个示例代码：
import java.util.*; public class DirectedGraph { private Map&lt;String, List&lt;String&gt;&gt; adjacencyList; public DirectedGraph() { this.adjacencyList = new HashMap&lt;&gt;(); } public void addEdge(String source, String target) { adjacencyList.computeIfAbsent(source, k -&gt; new ArrayList&lt;&gt;()).add(target); } public List&lt;String&gt; getNeighbors(String node) { return adjacencyList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/452e26e321337f7ea25aeec99ca3932e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e909840096fa7715ea6a6af1ee17b8f7/" rel="bookmark">
			数据结构——链表OJ题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。
2.给定一个带有头结点 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。
3.变形题：找到链表中倒数第k个节点
4.经典题：将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
结语
个人主页：大耳朵土土垚-CSDN博客
所属专栏：数据结构学习笔记
1.给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 示例 1：
输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5] 解题思路：
创建指针遍历链表找到对应节点删除；
创建两个指针变量cur和pre用来记录，cur表示当前遍历的节点，pre表示上一个节点如图所示
不要忘了有两种情况，当第一个节点就是对应节点时需要将头指针head改变 ；
如果忘记第一种情况就会发现以下示例：
图中null就是指pre为空指针的情况；
以下是完整代码实现： struct ListNode { int val; struct ListNode* next; }; struct ListNode* removeElements(struct ListNode* head, int val) { struct ListNode* cur = head; struct ListNode* pre = NULL; while (cur) { if (cur-&gt;val == val)//找到val值相同的节点时 { if (pre == NULL)//如果是第一个节点，也就是图中第②种 { cur = head-&gt;next; free(head); head = cur; } else//其他情况 { pre-&gt;next = cur-&gt;next; free(cur); cur = pre-&gt;next; } } else//不相同时 { pre = cur; cur = cur-&gt;next; } } return head; } 另外一种思路：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e909840096fa7715ea6a6af1ee17b8f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae51bb45e21e7fe3beadcbf432c16312/" rel="bookmark">
			小程序--事件处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、事件对象 给小程序的事件传递参数，有以下两种方法： 1、自定义属性 &lt;view class="item" wx:for="{{ 5 }}" wx:key="*this" data-index="{{index}}" bind:tap="onClick"&gt;&lt;/view&gt; Page({ onClick(e) { // 自定义属性 console.log(e.target.dataset.index) } }) 2、mark属性 &lt;view class="item" wx:for="{{ 5 }}" wx:key="*this" mark:index="{{index}}" bind:tap="onClick"&gt;&lt;/view&gt; Page({ onClick(e) { // mark属性 console.log(e.mark.index) } }) 3、实现tab切换高亮 小程序中，只能写一个class，否则会出现覆盖现象
&lt;view class="item {{activeIndex === index ? 'active' : ''}}" wx:for="{{ 5 }}" wx:key="*this" mark:index="{{index}}" bind:tap="onClick"&gt;&lt;/view&gt; Page({ data: { activeIndex: 0 }, onClick(e) { this.setData({ activeIndex: e.mark.index }) } }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a58cda5db5a5944ee4c37db61d49b759/" rel="bookmark">
			iOS开发 之 isEqual与hash
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要有isEqual方法? isEqual方法的作用大家肯定是知道的:
判断两个对象是否相等
但是判断相等不是已经有==运算符了么, 为什么还要isEqual方法?
这是因为:
对于基本类型, == 运算符比较的是值; 对于对象类型, ==运算符比较的是对象的地址(即是否为同一对象)
注意: 上述==运算符的说明适用于Objective-C和Java等不支持运算符重载的语言, 支持运算符重载的语言有C++
所以要理清==运算符和isEqual方法的区别, 问题就集中在
什么叫比较对象的地址, 什么叫比较对象
我们通过下面的例子来说明这个问题
UIColor *color1 = [UIColor colorWithRed:0.5 green:0.5 blue:0.5 alpha:1.0]; UIColor *color2 = [UIColor colorWithRed:0.5 green:0.5 blue:0.5 alpha:1.0]; NSLog(@"color1 == color2 = %@", color1 == color2 ? @"YES" : @"NO"); NSLog(@"[color1 isEqual:color2] = %@", [color1 isEqual:color2] ? @"YES" : @"NO"); 打印结果如下
color1 == color2 = NO [color1 isEqual:color2] = YES 从上面的例子可以看出, ==运算符只是简单地判断是否是同一个对象, 而isEqual方法可以判断对象是否相同, 例如UIColor对象表示的color是否相同
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a58cda5db5a5944ee4c37db61d49b759/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41611231b5cf231ecb23b234c57688af/" rel="bookmark">
			db-gpt docker部署进坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.docker 不支持gpu，参考之前文章
2.docker 容器启动就关闭，docker ps -a 查看容器状态为exited 停止
定位问题：
（1） 查看日志
docker logs dbgpt -f
（2） 日志错误最后一行：
ValueError: Path /app/models/text2vec-large-chinese not found
发现没有embedding模型，就启动docker image时，docker 因为是ipc模型，映射到系统环境目录下model目录找不到text2vec。。。模型
查看dbgtp的quickstart说明Quickstart | DB-GPT， 需要自行下载text2vec。
（3）下载embedding模型（略）
如果不知道怎么下载，可以私新我
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66ccabddbfec9a2c4e2d8354f3b7fc60/" rel="bookmark">
			JVM调优
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 调优层次
性能调优包含多个层次，比如:架构调优、代码调优、JVM调优、数据库调优、操作系统调优等。 架构调优和代码调优是JVM调优的基础，其中架构调优是对系统影响最大的。
2 调优指标 吞吐量：运行用户代码的时间占总运行时间的行例 （总运行时间=程序的运行时间+内存回收的时间）；
暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间；
内存占用：java堆区所占的内存大小；
这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。
简单来说，主要抓住两点:
吞吐量 吞吐量优先，意味着在单位时间内，STW的时间最短
暂停时间 暂停时间优先，意味这尽可能让单次STW的时间最短
在设计(或使用)GC算法时，必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找一个二者的折衷。
现在标准，在最大吞吐量优先的情况下，降低停顿时间。
3 JVM调优原则 3.1 优先原则 优先架构调优和代码调优，JVM优化是不得已的手段，大多数的Java应用不需要进行JVM优化
3.2 堆设置 参数-Xms和-Xmx，通常设置为相同的值，避免运行时要不断扩展JVM内存，建议扩大至3-4倍FullGC后的老年代空间占用。
3.3 年轻代设置 参数-Xmn，1-1.5倍FullGC之后的老年代空间占用。
避免新生代设置过小，当新生代设置过小时，会带来两个问题：一是minor GC次数频繁，二是可能导致 minor GC对象直接进老年代。当老年代内存不足时，会触发Full GC。 避免新生代设置过大，当新生代设置过大时，会带来两个问题：一是老年代变小，可能导致Full GC频繁执行；二是 minor GC 执行回收的时间大幅度增加。
3.4 老年代设置 注重低延迟的应用
老年代使用并发收集器，所以其大小需要小心设置，一般要考虑并发会话率和会话持续时间等一些参数
如果堆设置偏小，可能会造成内存碎片、高回收频率以及应用暂停
如果堆设置偏大，则需要较长的收集时间
吞吐量优先的应用 一般吞吐量优先的应用都有一个较大的年轻代和一个较小的老年代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而老年代尽可能存放长期存活对象
3.5 方法区设置 基于jdk1.7版本，永久代：参数-XX:PermSize和-XX:MaxPermSize； 基于jdk1.8版本，元空间：参数 -XX:MetaspaceSize和-XX:MaxMetaspaceSize； 通常设置为相同的值，避免运行时要不断扩展，建议扩大至1.2-1.5倍FullGc后的永久带空间占用。
3.6 GC设置 3.6.1 GC发展阶段 SerialParallel（并行) CMS（并发) G1ZGC 截至jdk1.8 ，一共有7款不同垃圾收集器。每一款不同的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选择不同的垃圾回收器
3.6.2 G1的适用场景 面向服务端应用，针对具有大内存、多处理器的机器。(在普通大小的堆里表现并不惊喜)
最主要的应用是需要低GC延迟并具有大堆的应用程序提供解决方案(G1通过每次只清理一部分而不是全部Region的增量式清理来保证每次GC停顿时间不会过长)
在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒
用来替换掉JDK1.5中的CMS收集器，以下情况，使用G1可能比CMS好
超过50% 的java堆被活动数据占用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66ccabddbfec9a2c4e2d8354f3b7fc60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b91e04830843906eaebe377249541337/" rel="bookmark">
			一些内网渗透总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows命令收集 信息收集: 查看系统版本和补丁信息: systeminfo
查看系统开放端口: netstat -ano
查看系统进程: tasklist /svc
列出详细进程: tasklist /V /FO CSV
查看ip地址和dns信息: ipconfig /all
查看当前用户: whoami /user
查看计算机用户列表: net user
查看计算机用户组列表: net localgroup
查看当前登陆用户: query user
查看当前用户保存的凭证: cmdkey /list
查看路由信息: route print
查看arp: arp -a
查看当前用户保存的票据凭证: klist
搜索D盘磁盘名字为logo.jpg的文件: cd /d D:\ &amp;&amp; dir /b /s logo.jpg
搜素C盘文件夹下后缀conf内容有password: findstr /s /i /n /d:C:\ "password" *.conf
查看3389端口: for /f "tokens=2" %i in ('tasklist /FI "SERVICES eq TermService" /NH') do netstat -ano | findstr %i | findstr LISTENING
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b91e04830843906eaebe377249541337/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fce15fb3313d95ce4cb588006248a106/" rel="bookmark">
			LLM 模型融合实践指南：低成本构建高性能语言模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编者按：随着大语言模型技术的快速发展，模型融合成为一种低成本但高性能的模型构建新途径。本文作者 Maxime Labonne 利用 mergekit 库探索了四种模型融合方法：SLERP、TIES、DARE和passthrough。通过配置示例和案例分析，作者详细阐释了这些算法的原理及实践操作。
作者的核心观点是：相比训练全新模型，融合现有模型可以以更低计算成本获取类似或更优异的效果。
文章通过模型融合生成了性能优异的 Marcoro14-7B-slerp 。在 Open LLM Leaderboard 和 NousResearch 两个基准测试上，它都是同参数量模型中的佼佼者。案例验证了作者主张的模型融合存在的高性价比。当然模型融合也存在一定问题，如训练数据污染和可能在各种评测排行榜的分数偏高。本文提供了模型融合技术与工程实践的详尽指南，对AI实践者具有重要参考价值。
作者 | Maxime Labonne
编译 | 岳扬
Image by author
模型融合（Model merging）是一种将两个或更多个大语言模型（LLM）合并为一个模型的技术。这是一种相对较新的实验性方法，可以以较低成本（无需 GPU）创建新模型。 令人惊讶的是，这种技术的效果还比较出奇，使用模型融合技术在 Open LLM Leaderboard[1]上产生了许多最先进的模型。
在本教程中，我们将使用 mergekit [2]库来实现这一技术。更具体地说，我们将回顾四种模型融合方法，并提供相关的配置示例。然后，我们将使用 mergekit 创建一个模型：Marcoro14–7B-slerp[3]，该模型已成为 Open LLM Leaderboard（02/01/24）上表现最佳的模型。
相关代码已上传至 GitHub[4] 和 Notebook[5]。个人建议使用 LazyMergekit[6] 项目，来轻松运行 mergekit。
特别感谢 mergekit 库的作者 Charles Goddard[7] 审阅本文。
Image by author
01 🤝 融合算法 在本节，我们将重点介绍 mergekit 库目前实现的四种模型融合方法。请注意，还有其他方法，比如 linear [8]和 Task Arithmetic [9]。如果你对模型融合的相关论文感兴趣，我推荐阅读Hugging Face上的这本优秀论文集[10]。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fce15fb3313d95ce4cb588006248a106/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a18189bcbdfb3937e6606403527ed28/" rel="bookmark">
			每天一个数据分析题（一百六十四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于OLAP系统，下列选项不正确的是（）
A. 是基于数据仓库的信息进行分析处理过程
B. 用户数量相对较少，其用户主要是业务决策人员与管理人员
C. 对响应时间要求非常高。
D. 基础数据来源于生产系统的操作数据，也就是说，OLAP系统的数据来源与OLTP系统。
题目来源于CDA模拟题库
点击此处获取答案
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a1e958a7ba3a36ff8eafbc2d6c6976f/" rel="bookmark">
			java基础-List常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 常用方法逆序升序List&lt;自定义类&gt;排序List删除元素List转String数组List的add函数查找一个,分隔的字符串中是否有某值根据`.`分割字符串根据空格分隔字符串 常用方法 逆序 Collections.reverse(List)
升序 Collections.sort(List)
List&lt;自定义类&gt;排序 首先让自定义类实现Comparable&lt;自定义类名称&gt;，举例：
public class Order implements Comparable&lt;Order&gt; { … @Override public int compareTo(Order o) { return this.createTime.compareTo(o.getCreateTime()); } // 注意java.util.Date不能用&lt;=&gt;比较，但是该类实现了Comparable接口 } 在需要排序处：
List&lt;Order&gt; orders = new ArrayList&lt;&gt;(); // 填充数据 // 升序： Collections.sort(orders); //降序： Collections.sort(orders, Collections.reverseOrder()); List删除元素 单一删除的话，可以用List自带的remove，然后break。不然如果是删index0，有可能死循环没结果。
推荐使用Iterator删除，因为不需要跳出循环
import java.util.ArrayList; import java.util.List; import java.util.Iterator; class Rextester { public static void main(String[] args) { List&lt;String&gt; list1 = new ArrayList&lt;&gt;(); list1.add("aa"); list1.add("bb"); list1.add("cc"); System.out.println(list1.size()); Iterator&lt;String&gt; it = list1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a1e958a7ba3a36ff8eafbc2d6c6976f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96fb80a07f613f373f690b8dee126ef9/" rel="bookmark">
			如何使用Python读取文本文件并回答问题？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要使用Python读取文本文件并回答问题，您可以按照以下步骤进行：打开文本文件—读取文件内容—解析文件内容以回答问题—根据问题提取所需信息并给出答案。其实大体上使用Python读取文本文件并回答问题也就这几个步骤，前期部署也是很重要得，但是如果遇到下面这样得问题，其实也很好解决。
1、问题背景：
用户想使用 Python 读取一个文本文件 animallog1.txt，并使用文件中的信息来回答问题。但是，用户在尝试读取文件时遇到了一个错误: “FileNotFoundError: [Errno 2] No such file or directory: ‘animallog1.txt’”。
2、解决方案：
为了解决这个问题，我们需要检查以下几点：
确保文件 animallog1.txt 确实存在于您指定的目录中。确保您在代码中使用了正确的路径来打开文件。如果文件不在当前目录中，您需要提供完整的路径。确保您正在使用正确的模式来打开文件。在您的代码中，您使用了 'r' 模式，这表示以只读模式打开文件。如果文件不存在，该模式将引发 FileNotFoundError 异常。 以下是一些可能的解决方法：
检查您是否在正确的目录中运行脚本。如果您不确定，可以使用 os.getcwd() 函数来获取当前目录的路径。检查您是否使用了正确的路径来打开文件。如果文件不在当前目录中，您需要提供完整的路径。例如，您可以使用 os.path.join() 函数来拼接文件路径。检查您是否正在使用正确的模式来打开文件。在您的代码中，您使用了 'r' 模式，这表示以只读模式打开文件。如果文件不存在，该模式将引发 FileNotFoundError 异常。您可以改为使用 'w' 模式来创建文件，或者使用 'a' 模式来向现有文件追加内容。 以下是一个修改后的代码示例：
import os # 检查文件是否存在 if os.path.isfile('animallog1.txt'): # 打开文件 with open('animallog1.txt', 'r') as myfile: # 读取文件内容 lines = myfile.readlines() # 处理文件内容 animal_names, dates, locations = [], [], [] for line in lines: animal_name, date, location = line.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96fb80a07f613f373f690b8dee126ef9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d9dc4b30453ba0e12b30057f35a4a0e/" rel="bookmark">
			C&#43;&#43;(12) 模板类、模板继承(严格模式和自由模式)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 模版类1. 模版类2. 模版参数限制3. 模版继承3.1 严格模式3.2 自由模式 4. 模版类的模版函数5. 返回值类型带有模版 模版类 1. 模版类 #include &lt;iostream&gt; using namespace std; /* 当前 Person 类型，声明了连个模版分别对应 NameType 模版类型，名称可以看出，用于约束成员变量 name 的类型 AgeType 模版类型，名称可以看出，用于约束成员变量 age 的类型 模版类型充当数据类型占位符，在整个类中，成员变量，成员函数，构造函数都可以使用 */ template &lt;typename NameType, typename AgeType&gt; class Person { public: Person() {} Person(NameType name, AgeType age) : name(name), age(age) {} Person(const Person &amp; person) : name(person.name), age(person.age) {} ~Person() {} NameType getName() { return name; } void setName(NameType name) { this-&gt;name = name; } AgeType getAge() { return age; } void setAge(AgeType age) { this-&gt;age = age; } private: NameType name; AgeType age; }; int main(int argc, char const *argv[]) { /* Person 类型带有模版修饰，需要在使用之前明确模版对应的具体类型 模版具备数据类型支持的多样性，同时一旦确定模版类型，严格遵守数据类型一致化原则 Person 类型如何确定模版对应的具体数据类型 格式： 类名&lt;模版对应具体数据类型&gt; * 对象 = new 类型&lt;模版对应具体数据类型&gt;(.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d9dc4b30453ba0e12b30057f35a4a0e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/9/">«</a>
	<span class="pagination__item pagination__item--current">10/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/11/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>