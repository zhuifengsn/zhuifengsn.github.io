<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd1cf8c0162ffcc48b47c269f6dd81e0/" rel="bookmark">
			python输出HelloWorld
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习编程语言的第一步几乎都是输出“Hello World”，而python也是如此。想要使用python语言输出"Hello World",需要使用python的heapq包中的heappush和heappop函数，heapq模块来实现最小堆，最小堆用于每次从所有列表的当前元素中选择最小的元素，再从最小堆中取出元素并合并。总体采用分治策略，将问题分解成更小的部分，递归地解决它们，然后将结果合并起来，这里输入是字符的嵌套列表，可以直接处理字符列表：
from heapq import heappush, heappop def mergeKLists(lists): min_heap = [] for i, lst in enumerate(lists): if lst: heappush(min_heap, (lst[0], i, 0)) merged = [] while min_heap: val, list_ind, element_ind = heappop(min_heap) merged.append(val) if element_ind + 1 &lt; len(lists[list_ind]): next_tuple = (lists[list_ind][element_ind + 1], list_ind, element_ind + 1) heappush(min_heap, next_tuple) return merged #定义字符 a = "H" b = "e" c = "l" d = "o" e = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd1cf8c0162ffcc48b47c269f6dd81e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8207ad29ed52c9a32544cb3991fec5b9/" rel="bookmark">
			算法沉淀——哈希算法（leetcode真题剖析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法沉淀——哈希算法 01.两数之和02.判定是否互为字符重排03.存在重复元素04.存在重复元素 II05.字母异位词分组 哈希算法（Hash Algorithm）是一种将任意长度的输入（也称为消息）映射为固定长度的输出的算法。这个输出通常称为哈希值或摘要。哈希算法的主要目的是快速、高效地检索数据，因为哈希值可以用作数据的唯一标识。 哈希算法的特点包括：
固定输出长度： 无论输入的数据大小如何，哈希算法都会生成固定长度的哈希值。快速计算： 对于给定的输入，哈希算法应该迅速生成相应的哈希值。不可逆性： 从哈希值不能逆向推导出原始输入的内容。即使输入的数据发生微小变化，生成的哈希值也应该是大不相同的。雪崩效应： 输入数据的微小变化应该导致输出哈希值的巨大变化，以确保输入数据的任何改变都能产生不同的哈希值。 在算法题中，哈希算法有许多实际运用。以下是一些常见的应用场景：
查找和检索： 使用哈希表（HashMap）来快速查找元素。通过将元素的键映射到哈希表中的索引，可以在常量时间内执行查找操作。去重： 利用哈希集合（HashSet）来检测和删除重复元素。通过将元素的哈希值映射到集合中，可以轻松检测是否已经存在相同的元素。缓存： 使用哈希表来实现缓存，以快速检索先前计算的结果。这种方法被称为缓存哈希。字符串匹配： 使用哈希算法来加速字符串匹配过程。例如，Rabin-Karp字符串匹配算法使用哈希值来比较字符串，以快速检测是否匹配。数据校验： 哈希算法用于验证数据的完整性。通过生成数据的哈希值并将其与已知的哈希值进行比较，可以确保数据在传输或存储过程中没有被篡改。分布式系统： 在分布式系统中，哈希算法被用于负载均衡和数据分片。通过将资源或数据的标识哈希到一组节点上，可以实现均匀分布和高效的访问。密码学： 在密码学中，哈希算法用于生成密码的摘要，以便安全地存储密码或验证用户身份。图算法： 在图算法中，哈希算法可用于快速判断两个图是否相同或是否存在同构关系。 01.两数之和 题目链接：https://leetcode.cn/problems/two-sum/
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
示例 1：
输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2：
输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3：
输入：nums = [3,3], target = 6 输出：[0,1] 提示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8207ad29ed52c9a32544cb3991fec5b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd621f09a6b11b150cf4707d5093c14d/" rel="bookmark">
			问题：我国专家呼吁学校进行死亡教育的时间段是（?）。 #学习方法#经验分享#其他
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：我国专家呼吁学校进行死亡教育的时间段是（?）。
参考答案如图所示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acb5dfe9f8c7dff3f1da92a02d2723d6/" rel="bookmark">
			Mybatis开发辅助神器p6spy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mybatis什么都好，就是不能打印完整的SQL语句，虽然可以根据数据来判断一二，但始终不能直观的看到实际语句。这对我们想用完整语句去数据库里执行，带来了不便。
怎么说呢不管用其他什么方式来实现完整语句，都始终不是Mybatis真实的语句替换。Mybatis自己不做这事，那就只能自己实现了，然而实现的结果却不是那么准确。
这款p6spy算是里面专业一点的。
p6spy打印完整Mybatis的SQL语句
pom.xml
&lt;!-- 用于打印完整mybatis语句--&gt; &lt;dependency&gt; &lt;groupId&gt;p6spy&lt;/groupId&gt; &lt;artifactId&gt;p6spy&lt;/artifactId&gt; &lt;version&gt;3.9.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; application.yml
spring: datasource: ##================================================ type: com.zaxxer.hikari.HikariDataSource driver-class-name: com.p6spy.engine.spy.P6SpyDriver url: jdbc:p6spy:mysql://localhost:3306/ry?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;useSSL=false username: root password: 123 spy.properties
modulelist=com.baomidou.mybatisplus.extension.p6spy.MybatisPlusLogFactory,com.p6spy.engine.outage.P6OutageFactory # 自定义日志打印 logMessageFormat=com.baomidou.mybatisplus.extension.p6spy.P6SpyLogger #日志输出到控制台 appender=com.baomidou.mybatisplus.extension.p6spy.StdoutLogger # 使用日志系统记录 sql #appender=com.p6spy.engine.spy.appender.Slf4JLogger # 设置 p6spy driver 代理 deregisterdrivers=true # 取消JDBC URL前缀 useprefix=true # 配置记录 Log 例外,可去掉的结果集有error,info,batch,debug,statement,commit,rollback,result,resultset. excludecategories=info,debug,result,commit,resultset # 日期格式 dateformat=yyyy-MM-dd HH:mm:ss # 实际驱动可多个 #driverlist=org.h2.Driver # 是否开启慢SQL记录 outagedetection=true # 慢SQL记录标准 2 秒 outagedetectioninterval=2 p6spy 建议在开发环境使用，生产不使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acb5dfe9f8c7dff3f1da92a02d2723d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4384597d1aad2d2751e8f411342ce152/" rel="bookmark">
			问题：路基施工时以下哪种情况可以不用铺筑试验路段。（ ） #经验分享#其他#微信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：路基施工时以下哪种情况可以不用铺筑试验路段。（ ）
A.高速公路和一级公路
B.特殊土质地区公路
C.采用新技术、新材料和新工艺的路基
D.三、四级公路
参考答案如图所示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94391df43bc775e80b57ff6cd094b2fd/" rel="bookmark">
			Seurat - 聚类教程 (1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置 Seurat 对象 在本教程[1]中，我们将分析 10X Genomics 免费提供的外周血单核细胞 (PBMC) 数据集。在 Illumina NextSeq 500 上对 2,700 个单细胞进行了测序。可以在此处[2]找到原始数据。
我们首先读取数据。 Read10X() 函数从 10X 读取 cellranger 管道的输出，返回唯一的分子识别 (UMI) 计数矩阵。该矩阵中的值表示在每个细胞（列）中检测到的每个特征（即基因；行）的分子数量。请注意，较新版本的 cellranger 现在也使用 h5 文件格式进行输出，可以使用 Seurat 中的 Read10X_h5() 函数读取该格式。
接下来我们使用计数矩阵来创建 Seurat 对象。该对象充当容器，其中包含单细胞数据集的数据（如计数矩阵）和分析（如 PCA 或聚类结果）。例如，在 Seurat v5 中，计数矩阵存储在 pbmc[["RNA"]]$counts 中。
library(dplyr)
library(Seurat)
library(patchwork)
# Load the PBMC dataset
pbmc.data &lt;- Read10X(data.dir = "/brahms/mollag/practice/filtered_gene_bc_matrices/hg19/")
# Initialize the Seurat object with the raw (non-normalized data).
pbmc &lt;- CreateSeuratObject(counts = pbmc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94391df43bc775e80b57ff6cd094b2fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44db7f8902a6dc723e6ca27c47a3a528/" rel="bookmark">
			C# 实现微信自定义分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
需求与调整
代码实现
获取令牌
生成合法票据
获取有效签名
客户端准备 客户端实现
小结
需求与调整 在微信中打开网页应用后，可以选择将地址发送给朋友进行分享，如下图：
在实际的应用中，我们可能不是简单的将该网页的链接直接分享出去，而是生成符合实际需要的URL，微信称其为自定义分享。意思即，在用户点击“转发给朋友”按钮之前，进行URL等内容的更新 ，经过调整后，再把链接发送给要分享的朋友。微信给出的关键方法是：updateAppMessageShareData。
需要注意的是：
最好不要再使用 wx.onMenuShareTimeline、wx.onMenuShareAppMessage、wx.onMenuShareQQ、wx.onMenuShareQZone 接口，请尽快迁移使用客户端6.7.2及JSSDK 1.4.0以上版本而支持 wx.updateAppMessageShareData、wx.updateTimelineShareData接口。
代码实现 获取令牌 获取令牌是调用API的基础，请提供合法的APPID和APPSECRET，示例代码如下：
public string GetAccessToken() { string accessToken = ""; //获取配置信息Datatable string respText = ""; //获取appid和appsercret string wechat_appid = ""; string wechat_appsecret = ""; //获取josn数据 string getAccessTokenUrl = "https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid={0}&amp;secret={1}"; string url = string.Format(getAccessTokenUrl, wechat_appid, wechat_appsecret); HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url); HttpWebResponse response = (HttpWebResponse)request.GetResponse(); using (Stream resStream = response.GetResponseStream()) { StreamReader reader = new StreamReader(resStream, Encoding.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44db7f8902a6dc723e6ca27c47a3a528/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5511dd5ec9d4f36bc6e92448d75c4a8f/" rel="bookmark">
			Sublime Text 3配置 Node.js 开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《开发工具系列》
Sublime Text 3配置 Node.js 开发环境 一、引言二、主要内容2.1 初识 Sublime Text 32.2 初识 Node.js2.3 接入 Node.js2.3.1 下载并安装 Node.js2.3.2 环境变量配置 2.4 配置 Node.js 开发环境2.5 编写 Node.js 代码2.6 运行 Node.js 代码 三、总结 一、引言 Node.js 是基于 Chrome JavaScript 运行时建立的一个平台，它简单理解就是运行在服务端的 JavaScript。它的开发环境有很多，比如 VS Code、Atom 等等，相信大家多多少少都有接触过；而本篇 Huazie 将要介绍一个比较轻量级的开发工具 Sublime Text 3，并用它来配置 Node.js 的开发环境。
二、主要内容 2.1 初识 Sublime Text 3 Sublime Text 3 是一款流行的文本编辑器，它的特点是体积小巧、启动速度快、界面简洁美观。它具有强大的代码编辑功能，支持多种编程语言。此外，Sublime Text 3 还具有丰富的插件生态系统，用户可以根据自己的需求安装各种插件来扩展其功能。
Sublime Text 3 的一些主要特点，如下所示：
强大的代码编辑功能：Sublime Text 3 提供了许多实用的代码编辑功能，如自动完成、代码高亮、代码片段等，大大提高了编程效率。
支持多种编程语言：Sublime Text 3 支持多种编程语言，包括 HTML、CSS、JavaScript、Python、Ruby、PHP 等，用户可以根据需要选择不同的语言模式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5511dd5ec9d4f36bc6e92448d75c4a8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2323d634a634d04fd2c95c5c8b979c6a/" rel="bookmark">
			c语言字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一字符串 概述：顾名思义是一连串的字符组成
在c语言中字符串实际上是使用空字符 \0 结尾的一维字符数组。因此，\0 是用于标记字符串的结束。
空字符（Null character）又称结束符，缩写 NUL，是一个数值为 0 的控制字符，\0 是转义字符，意思是告诉编译器，这不是字符 0，而是空字符。
补充：也许有人看到这样的定义：
char *ptr="hello_word"; 那这样写对不对呢?刚刚我们定义还强调是一维字符数组 这是历史遗留问题 在const关键字被引入c语言之前这样写是可以的 但是现在 我们已经不用这样的方式去表示字符串了 统一使用一维数组来表示字符串
下面的声明和初始化创建了一个 RUNOOB 字符串。由于在数组的末尾存储了空字符 \0，所以字符数组的大小比单词 RUNOOB 的字符数多一个
char site[7] = {'R', 'U', 'N', 'O', 'O', 'B', '\0'}; 注意的是每个字符数组的最后一个元素必须是\0 标识字符串的结束 当然也不用我们自己去写\0 C 编译器会在初始化数组时，自动把 \0 放在字符串的末尾
示例：
#include &lt;stdio.h&gt; int main () { char pdx[4]={'P','D','X'}; printf("%s\n",pdx); return 0; } C 中有大量操作字符串的函数：
序号函数 &amp; 目的1strcpy(s1, s2);
复制字符串 s2 到字符串 s1。2strcat(s1, s2);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2323d634a634d04fd2c95c5c8b979c6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f37c66f1327b74f923463550019a2909/" rel="bookmark">
			MongoDB从入门到实战之.NET Core使用MongoDB开发ToDoList系统（1）-后端项目框架搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 前面的四个章节我们主要讲解了MongoDB的相关基础知识，接下来我们就开始进入使用.NET7操作MongoDB开发一个ToDoList系统实战教程。本章节主要介绍的是如何快熟搭建一个简单明了的后端项目框架。
MongoDB从入门到实战的相关教程 MongoDB从入门到实战之MongoDB简介👉
MongoDB从入门到实战之MongoDB快速入门👉
MongoDB从入门到实战之Docker快速安装MongoDB👉
MongoDB从入门到实战之MongoDB工作常用操作命令👉
MongoDB从入门到实战之.NET Core使用MongoDB开发ToDoList系统（1）-后端项目框架搭建👉
YyFlight.ToDoList项目源码地址 欢迎各位看官老爷review，有帮助的别忘了给我个Star哦💖！！！
GitHub地址：GitHub - YSGStudyHards/YyFlight.ToDoList: 【.NET8 MongoDB 待办清单系统】.NET8 MongoDB从入门到实战基础教程，该项目后端使用的是.NET8、前端页面使用Blazor、使用MongoDB存储数据，更多相关内容大家可以看目录中的MongoDB从入门到实战的相关教程。该系列教程可作为.NET Core入门项目进行学习，感兴趣的小伙伴可以关注博主和我一起学习共同进步。
为什么选择ASP.NET Core？ 首先请你不要再停留在ASP.NET 4.x时代了，不要一听到.NET就是性能不行、不能跨平台、拖控件等等各种诟病。首先ASP.NET Core是对 ASP.NET 4.x 的重新设计（包括体系结构上的更改），是一个跨平台的高性能、精简、模块化、更支持云原生的开源框架。
ASP.NET Core 具有如下优点： 生成 Web UI 和 Web API 的统一场景。针对可测试性进行构建。Razor Pages 可以使基于页面的编码方式更简单高效。Blazor 允许在浏览器中使用 C# 和 JavaScript。 共享全部使用 .NET 编写的服务器端和客户端应用逻辑。能够在 Windows、macOS 和 Linux 上进行开发和运行。开放源代码和以社区为中心。集成新式客户端框架和开发工作流。支持使用 gRPC 托管远程过程调用 (RPC)。基于环境的云就绪配置系统。内置依赖项注入。轻型的高性能模块化 HTTP 请求管道。能够托管于以下各项： KestrelIISHTTP.sysNginxApacheDocker并行版本控制。简化新式 Web 开发的工具。 各大编程语言性能测试结果的可视化图表： 开发者根据 The Benchmarks Game 的测试数据制作了一份可视化图表，如下所示，灰色反映的是时间效率，越短代表性能越好，棕色则是基于执行时间和内存开销的加权值。
可视化图表来源：各大编程语言性能测试结果的可视化图表 - OSCHINA - 中文开源技术交流社区
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f37c66f1327b74f923463550019a2909/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/812e90bbae986cbf5c3ad6073da32548/" rel="bookmark">
			excel 导出 The maximum length of cell contents (text) is 32767 characters
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 导出excel报错。错误日志提示：:The maximum length of cell contents (text) is 32767 characters
排查后，发现poi有单元格最大长度校验，超过32767会报错。
解决方案：
通过java反射机制，设置单元格最大校验限制为Integer.MAX_VALUE(2147483647)。导出生成excel文件之前调用下边设置单元格最大限制方法。 /** * @Description: 利用反射强制将EXCEL2007中的_maxTextLength属性值修改为Integer.MAX_VALUE * @author: ly * @date: 2024/2/6 **/ public static void resetCellMaxTextLength() { SpreadsheetVersion excel2007 = SpreadsheetVersion.EXCEL2007; if (Integer.MAX_VALUE != excel2007.getMaxTextLength()) { Field field; try { field = excel2007.getClass().getDeclaredField("_maxTextLength"); field.setAccessible(true); field.set(excel2007,Integer.MAX_VALUE); } catch (Exception e) { e.printStackTrace(); } } } 使用 ExcelUtils.resetCellMaxTextLength(); ResponseUtils.writeExcel(response, workbook, "反馈结果统计信息.xlsx"); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dbf049748e81dc83f809e6cdf392528/" rel="bookmark">
			Godot 游戏引擎个人评价和2024年规划(无代码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言Godot C# .net core 开发简单评价Godot相关网址可行性 Godot(GDScirpt) Vs CocosGodot VS UnityUnity 的裁员Unity的股票Unity的历史遗留问题：Mono和.net core.net core的开发者，微软 个人的独立游戏Steam平台分成说明独立游戏的选题美术风格：2D+像素PC端，Steam发布目前的游戏规划 总结 前言 今天是上班的最后一天，我也学不动了，暂时也不想学什么新东西了。这篇文章就简单来说明一下我对于Godot的评价和之后的规划
Godot C# .net core 开发简单评价 Godot相关网址 Godot Twitter 账号
Godot 社区
Godot 官网
Godot 4.2 更新文档:Current state of C# platform support in Godot 4.2
对应的翻译
随着。net新版本的出现，平台支持变得更好。对移动平台的NativeAOT支持仍处于试验阶段，目前还没有对web平台的支持。. net 9.0版本将包括对NativeAOT的一些改进，我们可能会看到对web平台的初步支持。我们将在2024年11月看到它的发布。
使用NativeAOT只是我们为Godot c#项目添加更多平台支持的方法之一，使用Mono运行时是另一种可能性。在未来的Godot版本中，我们想尝试重新引入一些在Godot 3中可用的Mono嵌入，作为支持移动和web平台的另一种方式。
请尝试Godot 4.2，如果你发现任何bug，请告诉我们。
可行性 Godot 的.net core 开发是可行的。问题就是C# 对应的文档有点少，至少中文互联网的教程是十分缺失的。而且由于.net core 8.0刚刚发布不到半年，Godot 从Mono 架构转化为.net core 的架构到稳定也需要一段的时间。但是我已经测试过了，可以使用Visual Studio和nuget进行对Godot的开发。详细的可以看我的Godot 专栏。能使用.net core和Nuget的意义非常大，
Godot CSDN 专栏
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dbf049748e81dc83f809e6cdf392528/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5984a9c43b20bbd8472bab9ba9c29af/" rel="bookmark">
			MySQL学习五、使用代码操作数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31062e0bdb754b32f7ca0a3554b93dfd/" rel="bookmark">
			比较两次从接口获取的数据，并找出变动的字段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：有这么一个接口数据，每次会返回这么一个数据: [{Id:1,pending:65,queued:0,completed:0},{Id:2,pending:0,queued:0,completed:0}]，请问再次请求这个接口的时候如何将获取的数据和上一次获取到的数据进行比较，找出变动的字段。
解析：
要比较两次从接口获取的数据，并找出变动的字段，你可以按照以下步骤进行：
存储上一次的数据：首先，你需要有一个地方来存储上一次从接口获取的数据。这可以是一个变量、数据库或任何其他存储机制。获取新的数据：当你再次调用接口时，你将获得一组新的数据。比较数据：将新的数据与旧的数据进行比较，以找出任何变动的字段。
以下是一个简化的JavaScript示例，展示了如何执行此操作： // 假设这是上一次从接口获取的数据 let previousData = [ {Id:1,pending:65,queued:0,completed:0}, {Id:2,pending:0,queued:0,completed:0} ]; // 假设这是新从接口获取的数据 let newData = [ {Id:1,pending:66,queued:0,completed:1}, {Id:2,pending:0,queued:1,completed:0} ]; // 用于存储变动字段的结果 let changes = []; // 遍历每个数据项 newData.forEach((newItem, index) =&gt; { let oldItem = previousData[index]; if (oldItem) { // 遍历每个字段 for (let key in newItem) { if (newItem.hasOwnProperty(key) &amp;&amp; oldItem.hasOwnProperty(key) &amp;&amp; newItem[key] !== oldItem[key]) { // 字段有变动，记录下来 changes.push({ Id: newItem.agentId, field: key, oldValue: oldItem[key], newValue: newItem[key] }); } } } }); console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31062e0bdb754b32f7ca0a3554b93dfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14573ac0afefc7b9048065330ee71d60/" rel="bookmark">
			在 MacOS 上虚拟化 x86Linux 的最佳方法(通过 Rosetta)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		categories: [VM]
tags: MacOS VM 写在前面 买了 ARM 的 mac, 就注定了要折腾一下虚拟机了…
之前写过一篇文章是通过 utm 虚拟化archlinux, 其实本质上还是调用了 qemu-system-x86_64, 所以速度并不快, 后来想着能不能借用 Rosetta 的优势即原生转译, 来虚拟化 Intel 的 Linux.
看了一些文章, 提到过用lima 管理虚拟机, 然后配置, 应该是最便捷的方法了, 不过这里先以 utm 的最新版设置为例讲讲, 之后再说 lima.
环境支持:
MacOS13+ (为了使用 apple 的虚拟化, 这个虚拟化支持在ARM 架构的 Linux 上使用 Rosetta跑 Intel 架构的程序)
m系列芯片
一些看过的博客 算是一个引子, 可以看看 Apple 官方的消息
苹果M系列处理器上的Linux虚拟机内Rosetta转译初体验 - wvbCommunity;(感觉写的比较详细的博客, 还附了图就很棒)Running Intel Binaries in Linux VMs with Rosetta | Apple Developer Documentation;Rosetta | UTM Documentation; 这篇算是 utm 支持, 其实很多内容在 Apple 官方的文档有写了 开始折腾…
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14573ac0afefc7b9048065330ee71d60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40eaaf5e4dce4862a186ddc2678f662d/" rel="bookmark">
			MongoDB从入门到实战之Docker快速安装MongoDB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在上一篇文章中带领带同学们快速入门MongoDB这个文档型的NoSQL数据库，让大家快速的了解了MongoDB的基本概念。这一章开始我们就开始实战篇教程，为了快速把MongoDB使用起来我将会把MongoDB在Docker容器中安装起来作为开发环境使用。然后我这边MongoDB的可视化工具用的是Navicate。废话不多说，我们先花了几分钟开始的把MongoDB环境搭建起来。
MongoDB从入门到实战的相关教程 MongoDB从入门到实战之MongoDB简介👉
MongoDB从入门到实战之MongoDB快速入门👉
MongoDB从入门到实战之Docker快速安装MongoDB👉
YyFlight.ToDoList项目源码地址 GitHub地址：GitHub - YSGStudyHards/YyFlight.ToDoList: 【.NET8 MongoDB 待办清单系统】.NET8 MongoDB从入门到实战基础教程，该项目后端使用的是.NET8、前端页面使用Blazor、使用MongoDB存储数据，更多相关内容大家可以看目录中的MongoDB从入门到实战的相关教程。该系列教程可作为.NET Core入门项目进行学习，感兴趣的小伙伴可以关注博主和我一起学习共同进步。
查看可用的MongoDB版本 访问DokcerHub中的MongoDB镜像库地址：https://hub.docker.com/_/mongo/tags
可以通过 Sort by 查看其他版本的MongoDB，查看最新版本MongoDB镜像(mongo:latest)：https://hub.docker.com/_/mongo/tags?page=1&amp;name=latest
此外，我们还可以用docker search mongo命令来查看可用版本： 拉取最新版本的MongoDB镜像 docker pull mongo:latest 注意：tag是可选的，tag表示标签，多为软件的版本，默认是latest版本（最新版）
验证MongoDB镜像是否成功拉取到本地 使用以下命令来查看MongoDB镜像是否成功拉取到本地：
docker images 创建并运行一个MongoDB容器 docker run -itd --name mongo-test -p 27017:27017 mongo --auth 参数说明：
-itd：其中，i是交互式操作，t是一个终端，d指的是在后台运行。--name mongo-test：容器名称-p 27017:27017 ：映射容器服务的 27017 端口到宿主机的 27017 端口。外部可以直接通过 宿主机 ip:27017 访问到 mongo 的服务。--auth：需要密码才能访问容器服务（注意：安全问题，MongoDB默认是不开启权限验证的，不过设置了这里就相当于修改MongoDB的配置auth=ture启用权限访问）。 进入创建的MongoDB容器 docker exec -it mongo-test mongosh MongoDB报错"ongoServerError: not authorized on admin to execute command"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40eaaf5e4dce4862a186ddc2678f662d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af726264cf6e0316bdf46f57012cd1ae/" rel="bookmark">
			MySQL学习四、索引和事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.索引（index）
1.1 索引的理解
索引存在的主要意义，就是为了提高查询的效率
索引就相当于目录
大多数情况下，查询的频率是高于增删改的，所以索引的存在是很有必要的
索引付出的代价：
1. 消耗更多的空间
2. 虽然提高了查找效率，但是降低了增 删 改的效率
（比如插入新记录，需要既能够插入硬盘的数据，又要调整索引）
1.2 查看索引
show index from 表名；
1.3 创建索引
create index 索引名 on 表名 (列名);
创建索引操作，也是一个低效操作，如果表中数据少不影响，如果表中数据多，创建索引操作，就可能会非常耗时，并且带来大量的硬盘IO
1.4 删除索引
drop index 索引名 on 表名;
删除操作和创建操作都是比较低效的操作 SQL可以支持一些 定义变量，定义函数，条件，循环，库函数等 但是这些很少用到
SQL 一般都是单纯的去 增删查改 1.5 索引的数据结构 （B+树）
索引能够提高查询效率，具体是怎么提高的
索引背后的数据结构是怎么样的
数据结构中，查询效率高的有 哈希表 和 二叉搜索树，但是这两种不适合用于数据库索引
因为
（1）哈希表虽然增删查改都快 O(1)
但是只能查询 值 相等的情况，但是如果是&lt; &gt; between and 这种比较大小的范围查询就不适合了
（2）二叉搜索树，查询速度 O(N)最坏情况
AVL 树 / 红黑树 （比较平衡的二叉搜索树）O(logN)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af726264cf6e0316bdf46f57012cd1ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a29971fbb1e84f86bf40129d258eabf/" rel="bookmark">
			使用PHPStudy搭建本地web网站并实现任意浏览器公网访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 @[toc]使用工具1. 本地搭建web网站1.1 下载phpstudy后解压并安装1.2 打开默认站点，测试1.3 下载静态演示站点1.4 打开站点根目录1.5 复制演示站点到站网根目录1.6 在浏览器中，查看演示效果。 2. 将本地web网站发布到公网2.1 安装cpolar内网穿透2.2 映射内网端口2.3 实现公网访问本地web网站 本教程为快速在本地环境下搭建web网站，同时实现可在外网环境下访问！！
使用工具 phpstudy（本地搭建web网站）cpolar内网穿透（将网站发布到公网可访问） 1. 本地搭建web网站 1.1 下载phpstudy后解压并安装 官网下载：https://www.xp.cn/download.html
安装后的效果，如图：
点击，一键启动 WNMP 旁边的启动按钮，会默认启动nginx，MYSQL 5.7，在启动过程中，如有提示防火墙提示，允许即可。
1.2 打开默认站点，测试 在PHPStudy面版–网站–选择localhost 80的默认站点，点击管理，弹出下拉菜单，选择打开网站，会弹出浏览器，打开本地默认站点http://localhost
如下图，说明安装成功。
1.3 下载静态演示站点 下载:https://www.cpolar.com/static/downloads/meditation-app-master.zip
下载后，解压缩，复制目录下的所有文件，如下图
1.4 打开站点根目录 我们找到并打开网站的根目录
默认在 D:\phpstudy_pro\WWW, 我们将目录里所有文件删除，如下图
1.5 复制演示站点到站网根目录 复制我们的演示站点所有文件到该目录下,复制后如下图：
1.6 在浏览器中，查看演示效果。 这个网站此时只能在本地局域网内访问，公网暂时还无法访问到。
2. 将本地web网站发布到公网 要将在本地搭建的网站发布到公网可访问，可以做内网穿透来实现，我这里选择用cpolar内网穿透，支持http/https/tcp协议，不限制流量，可以免费使用，不用公网IP，也不用设置路由器，使用比较简单。
2.1 安装cpolar内网穿透 cpolar内网穿透官网：https://www.cpolar.com/
点击进入cpolar官网，点击免费使用注册一个账号，并下载最新版本的cpolar
Windows系统下载zip压缩包，解压后得到cpolar安装包，然后双击安装包一路默认安装即可；linux系统支持一键自动安装脚本；macOS系统下载zip压缩包，解压后得到cpolar，然后通过命令行带参数运行即可。 linux系统以及macOS系统安装cpolar可参考官网文档教程————→https://www.cpolar.com/docs
2.2 映射内网端口 cpolar安装完成后，在浏览器上访问127.0.0.1:9200，使用cpolar账号登录web UI
登录成功进入主界面后，点击左侧仪表盘的隧道管理——创建隧道
隧道名称：可自定义命名，注意不要重复协议：选择http本地地址：80（填写你想要映射的内网端口）域名类型：免费用户选择随机域名，付费用户可以配置固定的二级子域名或者自定义域名地区：选择China vip 然后点击创建
2.3 实现公网访问本地web网站 隧道创建成功后，可以在左侧仪表盘的状态——在线隧道列表，查看到刚刚所创建隧道的公网地址，有两行，一个是http协议，一个是https协议。
将公网地址复制到浏览器访问即可，成功实现公网访问本地网站。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a29971fbb1e84f86bf40129d258eabf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a8e3951661338f10aeab30a09729247/" rel="bookmark">
			MySQL学习三、数据库约束
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 数据库约束
约束：对于数据库中的记录做出更详细的检查
（1）not null：指示某列不能为null值
（2）unique：唯一约束，保证某列的每行必须有唯一值
（3）default：默认值约束，规定没有给列赋值时的默认值
（4）primary key：主键约束，确保某列（或多个列的结合）有唯一的标识，有助于更容易快速找到表中的一个特定的记录
（5）foreign key：外键约束，保证一个表中的数据匹配另一表中的值的参照完整性
（6）check：保证列中的值符合指定的条件
1.1 null约束
not null 要求指定列，非空
创建表时如果约束这列非空，那么新增时，这列就不可以为空。
1.2 unique：唯一约束
unique 值唯一，每次插入、修改数据，都会针对当前数据在表里进行查找，看这个值是否能查到，如果能查到，那么不是唯一的，就会导致插入或修改失败
如果使用unique后，会先查询，再插入！！！ 所以效率比较低
entry 在数据结构出现过，Map时entry叫做入口、条目
Map没有实现Iterable接口，没法直接遍历，所以把键值对转换成一个Set ，entrySet 1.3 default：默认值约束
default：作用是修改默认值
本来表的默认值是null，可以使用 default 把默认值修改成其他值
1.4 primary key：主键约束 primary key 主键 针对每一天记录，作为身份标识
主键要保证唯一性，主键也不能为空
使用主键，需要给这个列设置一个唯一的值，我们自己进行分配值的工作，并且还要保证值不会重复，这样会比较麻烦，MySQL提供了一个机制，叫自增主键，来方便分配值
自增主键 跟在primary key 后面 （primary key auto_increment），
通过这样的机制，来给主键设置值
自增主键，都是从最大值之后进行增加的
（虽然这样可能会有空间上的浪费，但从大量数据看，这点浪费不影响）
1.5 foreign key：外键约束
外键 foreign key：将两种表联系起来
........foreign key (当前表的那一列) references 另外一张表(那一列);
约束别的表的表，叫父表（parent，例子中的班级表）
被约束的表，叫子表（child，例子中的学生表）
（1）创建班级表，创建外键约束的学生表 （2）给学生表插入数据，失败 （3）给班级表插入数据，然后再给学生表插入数据，成功
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a8e3951661338f10aeab30a09729247/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd3d32f4265c7df94d05289942a7067a/" rel="bookmark">
			MySQL学习二、表的增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、表中数据操作 1.向表中插入数据 单行数据+全列插入：
insert into 表名 values(...);
多行数据+指定列插入：
insert into 表名(指定列...) values (...), (...);
2.查询表中数据 全列查询：
select * from exam_result;
通常情况下不推荐使用 * 进行全列查询，因为查询的列越多，意味着需要传输的数据量越大，可能会影响到索引的使用。
指定列查询：
select id, nam, english from exam_result;
查询字段为表达式：
select id, name, english+10 from exam_result;
别名：
select id, name, chinese + math + english as 总分 from exam_result;
去重：
select distinct math from exam_result;
排序：
select name, english from exam_result order by english;//（若在最后加desc则为降序）
1.没有order by子句的查询时，返回的顺序是未定义的，不要依赖这个顺序。
2.NULL数据排序，视为比任何值都小。
select name, chinese + english as total from exam_result order by total desc;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd3d32f4265c7df94d05289942a7067a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/13/">«</a>
	<span class="pagination__item pagination__item--current">14/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/15/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>