<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91d119437cb66f16433576d3abc534ce/" rel="bookmark">
			【建议收藏】产品经理面试真题大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2020年，筛了2400份简历，面了100来个产品经理，帮助了20多位同学找到了新工作。
这里就用这篇文章，分享一些关于面试的思考和积累。
接下来主要从10个方面分享，共82题。
1、面试前准备（6个问题）
2、个人情况（3个问题）
3、公司情况（8个问题）
4、项目深挖（4个问题）
5、行业知识（2个问题）
6、产品基础知识（28个问题）
7、软能力考查（24个问题）
8、人事的问题（5个问题）
9、定向题目（1个问题）
10、提问环节（1个问题） 01
面试前的准备
1、我要找什么行业的工作
求职前，首先要明确自己的目标行业。
首先明确一个概念，隔行如隔山。
跨行业面试的难度远远高于同行互跳。
企业招人的一个需求就是需要求职者在相同行业的采坑经验。
避免企业在开展工作中的试错成本。
2、我的求职目标是什么
求职目标一般就2个。钱和发展。
对于0-3年的产品经理，建议发展＞钱。
对于3年+的产品经理，建议钱=发展。
如果产品经理有创业计划，不妨去创业公司试试。
但我个人建议，初入职场，先去大公司锻炼。
因为小公司，各种资源都是相对短缺的，可能你还没热呢，公司就黄了。
创业公司基本定律：九死一生。
3、邀请我面试的公司活的怎么样
首先要看行业知名度。
一线公司一般没有活着的问题。一线公司是指BATTMD这类的。
BATTMD=百度、阿里、腾讯、头条、美团、滴滴。
二线公司风险也不大。这种公司一般是细分领域的龙头几家。也叫独角兽。
三线公司是指有一定知名度，但华而不实。比如蛋壳。
剩下的事创业公司，市面上查不到的信息。
这类就要比较警惕了。
首先要看查下公司的基本信息。百度一下就可以。
看下注册时间、注册实缴资本、法人以及在保人数。
然后看下和HR\联系人问下公司的营收情况。
要是支支吾吾保密不回答之类，一般有鬼。这类数据上市公司是公开透明的。
其次去问问公司有多少人，假如说公司有500人，那么1年的人力成本最低是1000万。
收入减掉成本，你大概能知道老板还能剩多少钱。
4、对比职位JD，看看我能否胜任
有些职位JD会明确写出这个职位要背的指标，比如增长产品经理这个岗位，一般就背拉新、转化、营收的全部或者某一个。
比如让你背给公司创造1000万营收的KPI，完不成走人，你有信心吗？
如果没有信息建议就别投简历了。
但是有个误区，大部分JD（职位简介）和实际工作是有差异的。
百分之八十的JD是复制+编辑来的。
所以不能明确知道背什么KPI的话，以面试信息为准。
5、公司/猎头跟我要简历，我给不给？
先说一段个人经历吧，我从百度走的时候，简历给过猎头。
然后之后的每一年，我都会接到猎头电话，问我，你还看机会吗？
简历给猎头是一定风险的。
如果猎头不靠谱，他可能帮你海投了。或者进入猎头数据库
如果猎头给你海投到大厂，第二个面试官会看到你简历筛选未通过的记录。
这里建议大家猎头不先给目标职位的话，不要提供简历。
6、公司给我发offer，我去不去
如果这家公司，你面试通过了，发了offer也不去。
这里建议就别投简历，浪费时间。
有一种情况可以例外，很久没有找工作了，需要面试练练手的。
即使确定不去的公司，也可以去练练手。 02
个人情况
1、自我介绍（必考题）
这个问题几乎是面试必考题。大部分面试官的客套开场。
［考点］逻辑能力、表达能力
面试者在回答这个问题的时候，面试官一般在快速温习简历。
通过这个问题，面试官会对求职者建立第一印象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91d119437cb66f16433576d3abc534ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/122d065ee5878cbedb1314179c28a6d9/" rel="bookmark">
			java中的回调函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CALLBACK，即回调函数，是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。---百度百科
上面的解释是在C++中对回调函数的解释。
在java中也是存在回掉函数的，我们可以把回调函数理解为一个被作为参数传递的函数。
就英语单词的角度上，我们把CALLBACK这个单词拆开，即CALL和BACK，分别可以理解打电话和回来，也就是回拨电话
用打电话的例子来解释回调函数：
我给某个人打电话，但是这个人现在没有时间，那么我会告诉他：你忙完回电话给我。那么这个人做完事情之后就会给我回电话。这个过程就是回调函数。换成编程语言来说，可以这样理解：我调用一个函数，但是需要先执行这个函数，我让这个函数在执行完之后，调用我传给他的另一个函数，开始是我调用这个函数，最后变成了这个函数调用我传给他的函数。
为了大家更能深入理解，举一个现实中的例子，我去某个商场买衣服，但是到了之后发现我们要买的衣服断货了，那么这个时候，我们会把电话号留给销售人员，等货品到货的时候销售人员通过电话号码联系我，在这个例子中，电话号码就叫回调函数，到货销售人员给我打电话就叫做调用回调函数。在这个时间，我可以做任何事情，而不是一直你在那等到衣服到。
现在，大家对于回调函数大概了解了，那么，回调函数的使用场景是什么呢？ ---在类A调用类B方法时，类B的方法需要执行很长时间的时候才能有反馈的时候。
回调函数的作用呢？解耦，可以把调用者与被调用者分开，调用者不用关心谁是被调用者。在上面的例子中，调用者是我，被调用者是销售人员，我们通过电话号码解耦。
例子：
类A：
public class A implements Callback { public void a(){ System.out.println("这是A类的a方法"); B b=new B(); b.b(this); System.out.println("A类"+this); } @Override public void callback(){ System.out.println("回调函数"); } } 类B：
public class B { public void b(Callback callback){ System.out.println("这是类B的b方法"); callback.callback(); System.out.println("B类"+this); } } 回调函数接口：
public interface Callback { void callback(); } 客户端：
public class Client { public static void main(String[] args) { A a=new A(); a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/122d065ee5878cbedb1314179c28a6d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a13df9ad28b51bd912d3851bb596762/" rel="bookmark">
			java比对文字重复_Java编程实现比对两个文本文件并标记相同与不同之处的方法...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文实例讲述了Java编程实现比对两个文本文件并标记相同与不同之处的方法。分享给大家供大家参考，具体如下：
使用需求：
文件1里面是需要比较的内容，文件2是被比较的文本，现在需要找到在文件1中每一行的文本在文件2中是否存在并相等，如果相等，就在一份结果文件中输出，文件1的哪一行与文件2的哪一行相同，反之不相同就输出文件1的哪一行不相同货不存在。
Java代码如下，输出的是result.txt文件，这个文件的行号和文件1保持一致，所以result中某一行的结果就是对应的文件1中这行数据在文件2中比较之后的结果。
(需要注意文件1和文件2是通过每一行的内容进行比较)
最后为了方便查看可以通过Notepad++查看：
package com.it.aron;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
/**
* check repetitive text
* @author: aronxu
* @version: 1.0,Sep 22,2015
*/
public class AutocheckText {
private static final String FILE_PATH = "D:/text1.txt";
private static final String COMPARED_FILE_PATH = "D:/text2.txt";
private static final String RESULT_FILE_PATH = "D:/result.txt";
public static void main(String[] args) {
System.out.println("======Start Search!=======");
long startTime = System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a13df9ad28b51bd912d3851bb596762/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13de21858ebde81ac3db38e67f3334a6/" rel="bookmark">
			Centos7下安装、配置Redis5.0.3以及redis详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装 1.官网下载Redis
Redis官网(有时候需要翻墙)
2.上传下载好的包到Centos上并解压（本人上传到了usr/local目录下）
3.进入redis-5.0.3目录里，执行编译命令
&lt;span style="color:#000000"&gt;&lt;code&gt;make &lt;/code&gt;&lt;/span&gt; 1 4.编译完成之后，将redis安装到指定目录
&lt;span style="color:#000000"&gt;&lt;code&gt;make PREFIX=/usr/local/redis install &lt;/code&gt;&lt;/span&gt; 1 5.此时/usr/local/redis下生成了一个bin目录
至此安装完成；
二、启动 1.启动方式一
前台启动,不推荐使用，进入/usr/local/redis/bin里执行启动命令(默认端口号:6379)
&lt;span style="color:#000000"&gt;&lt;code&gt;./redis-server &lt;/code&gt;&lt;/span&gt; 1 2.启动方式二
后台启动，推荐使用，将redis-5.0.3目录下的redis.conf文件复制到 /usr/local/redis/bin 下
&lt;span style="color:#000000"&gt;&lt;code&gt;cp redis.conf /usr/local/redis/bin/ &lt;/code&gt;&lt;/span&gt; 1 修改redis.conf 设置为后台启动，将daemonize no改为daemonize yes即可(redis.conf文件内容较多，全局搜索：/daemonize 然后回车，再不断敲N即可)
启动Redis：进入/usr/local/redis/bin目录，执行下边命令
&lt;span style="color:#000000"&gt;&lt;code&gt;./redis-server /usr/local/redis/bin/redis.conf 由于redis.conf与redis-serve在同一级目录，所以执行下边命令即可 ./redis-server redis.conf &lt;/code&gt;&lt;/span&gt; 123 关闭Redis：进入/usr/local/redis/bin目录，执行下边命令
&lt;span style="color:#000000"&gt;&lt;code&gt;./redis-cli shutdown &lt;/code&gt;&lt;/span&gt; 1 3.查看redis进程：
&lt;span style="color:#000000"&gt;&lt;code&gt;ps -ef | grep -i redis &lt;/code&gt;&lt;/span&gt; 1 看到如下信息：
&lt;span style="color:#000000"&gt;&lt;code&gt;root 1218 1 0 12:04 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13de21858ebde81ac3db38e67f3334a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/087c1825479e62169ceccd8cd4553938/" rel="bookmark">
			windows下格式化内存卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经常玩树莓派的小伙伴都会涉及到系统烧录，系统烧录自然需要用到空的SD卡，现在教大家一个不用任何软件就可以把SD卡格式化的方法，记住终生受益。
windows下格式化内存卡 一、材料准备二、格式化SD卡 一、材料准备 1.非空的SD卡x1
2.读卡器x1
3.Windows电脑x1
二、格式化SD卡 1.打开cmd窗口：win键+R键，输入cmd
2.回车进入以下界面，输入：diskpart，注：不要输入中文
3.回车进入以下界面，输入：list disk，查看磁盘列表，其中磁盘1是我的SD卡
4.输入：select disk 1 选择SD卡，我的是磁盘1，切忌选错。
5.查看磁盘1分区，输入：list partition
6.选择分区1，输入：select partition 1
7.删除分区1，输入：delete partition
若还有分区2，重复6、7步骤即可删除
有问题下方留言，谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/894038740668ad8be0d89bd7a6ca06e5/" rel="bookmark">
			树莓派红外线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知识点：
1.树莓派GPIO引脚控制
2.红外线传感器的使用
这就是我所用的红外线传感器，这个传感器有三个端口，VCC端口是外接3.3V-5V的电压，GND端口接地，OUT接树莓派的GPIO通用输入输出接口（这里我用的是GPIO的BOARD编号，即13号引脚）
如果有人对BOARD编号方式不熟悉，这里我直接上图
对于这种红外线传感器来说，OUT端口是数字量输出接口即输出0或1，当前方出现障碍物时，其输出低电平即输出0；反之，输出1。
明白这个后，就可以对其进行编程控制，代码如下：
import RPi.GPIO as GPIO from PIL import Image zhangaiout = 13 def jiance(): while True: if (0 == GPIO.input(zhangaiout)): # 当检测到障碍物时，输出低电平信号0 print('zhangai') else: print('wuzhangai') def destroy(): GPIO.cleanup() if __name__ == '__main__': GPIO.setmode(GPIO.BOARD) GPIO.setup(zhangaiout, GPIO.IN, pull_up_down=GPIO.PUD_UP) try: jiance() except KeyboardInterrupt: destroy() 学习体会：对于这种传感器，一定要认真的看使用说明，当然，这类红外线传感器不算太难，还有就是要明白树莓派GPIO的各种编号及引脚功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f201d9f87ec5483e1c8db0947baf6e7b/" rel="bookmark">
			树莓派与OpenCV实现人脸识别（OpenCV安装篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要看了以下两位博客的文章完成的，也遇到了不少的坑，在这里一一填补说明。
链接: https://blog.csdn.net/weixin_42163073/article/details/107308759.
链接: https://blog.csdn.net/weixin_42573595/article/details/108526850.
树莓派与OpenCV实现人脸识别（OpenCV安装篇） 一、材料准备：二、系统烧录三、安装OpenCV依赖项四、下载OpenCV和OpenCV_contrib（三种办法，云盘下载最快）五、为OpenCV配置Python3虚拟环境六、编译OpenCV（耗时较长）七、安装与检查 一、材料准备： 1.树莓派x1（含16g卡）
2.USB高清摄像头x1
3.键盘、鼠标、屏幕
二、系统烧录 只提供树莓派raspbian系统镜像，自己解压烧录即可，烧录步骤省略
系统镜像链接: https://pan.baidu.com/s/1ACxvVdpYYJ0OAg7nqVXJmA .
提取码：ms45
三、安装OpenCV依赖项 1.为了加快后面下载速度，换国内源
点击看此文
2.更新系统及源：
sudo apt-get update &amp;&amp; sudo apt-get upgrade 3.切换Python版本
点击看此文
4.安装开发工具：
sudo apt-get install build-essential cmake unzip pkg-config 5.安装图像和视频库、安装GTK，GUI后端：
sudo apt-get install libjpeg-dev libpng-dev libtiff-dev sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev sudo apt-get install libxvidcore-dev libx264-dev 6.安装免除GTK警告的包
sudo apt-get install libcanberra-gtk* 四、下载OpenCV和OpenCV_contrib（三种办法，云盘下载最快） 下载OpenCV和OpenCV_contrib，注意：若安装的是OpenCV-4.3.0，则下载OpenCV_contrib时，必须也是OpenCV_contrib-4.3.0
（1）命令行下载，速度很慢，容易中断
1.下载压缩包，注意观察是否下载成功
cd ~ wget -O opencv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f201d9f87ec5483e1c8db0947baf6e7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bd39ef01da6268e10d51958fb090f09/" rel="bookmark">
			量纲与无量纲，标准化、归一化、正则化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		量纲与无量纲，标准化、归一化、正则化 1 量纲与无量纲1.1 量纲1.2 无量纲 2 标准化3 归一化4 正则化5 总结 1 量纲与无量纲 1.1 量纲 量纲我觉得最重要的一句话是：物理量的大小与单位有关。
从这句话我们来思考下最核心的两个单词：大小、单位。就是说量纲是有两部分组成：数、单位。就比如1块钱和1分钱，就是两个不同的量纲，因为度量的单位不同了。
1.2 无量纲 结合上面的内容来说，那么无量纲就是：物理量大小与单位无关。
那么我们来考虑下，哪些内容是无量纲的。首先标量肯定是无量纲的，因为只有大小，没有单位。其次就是比值，因为一般来说比值都是由一个量纲除以了某个量纲后得到的，比如速度可以有“k m / s km/skm/s”，“m / s m/sm/s”等等。还有一个很显眼的无量纲，就是协方差的相关系数，因为协方差的相关系数是协方差归一化后得到的结果，可以用来衡量相关性，既然能够直接拿来衡量相关性，那么就是无量纲的。
2 标准化 标准化（standardization）是一种特征缩放（feature scale）的方法，在书《python machine learning》中，关于标准化的定义如下：
用我粗糙的英语翻译一下就是：
梯度下降是受益于特征缩放的算法之一。有一种特征缩放的方法叫标准化，标准化使得数据呈现正态分布，能够帮助梯度下降中学习进度收敛的更快。标准化移动特征的均值（期望），使得特征均值（期望）为0，每个特征的标准差为1。
标准化公式如下：
我们先翻译解释，再解释图片：
3 归一化 归一化（normalization）和标准化（standardization）区别不是很大，都是特征缩放（feature scale）的方式。
有的资料中说的，归一化是把数据压缩到[ 0 , 1 ] [0,1][0,1]，把量纲转为无量纲的过程，方便计算、比较等。
在书本《python machine learning》中对归一化的定义为：
翻译如下：
4 正则化 正则化（regularization）是与标准化还有归一化完全不同的东西。正则化相当于是个惩罚项，用于惩罚那些训练的太好的特征。
在书《python machine learning》中，对于正则化的描述如下：
我们来翻译一下：
正则化就是用来处理collinearity的，这个collinearity指的是与特征高度相关，清理掉数据的噪声，最终阻止过拟合。而正则化实际上就是引入一个额外的信息（偏置）来惩罚极端的参数（权重）值。
我们借用吴恩达老师的PPT来说：
我们看到图三这个曲线非线性拟合的太完美了，那么就造成了过拟合，造成的原因是因为特征过多，训练的太好了，而这个特征过多，我个人认为就对应了上面英文中的collinearity (high correlation among features)。
减少特征个数（特征约减）：
手工保留部分特征（你觉得你能做到么？反正我觉得我做不到）模型选择算法（PCA，SVD，卡方分布） 正则化：保留所有特征，惩罚系数θ ，使之接近于0，系数小，贡献就小。 所以也就对应了书本上的惩罚极端参数值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bd39ef01da6268e10d51958fb090f09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2145fa898108e95c62dd994f895e937b/" rel="bookmark">
			Leetcode链表4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode* mergeInBetween(struct ListNode* list1, int a, int b, struct ListNode* list2){ struct ListNode *fast = list1; struct ListNode *slow = list1; struct ListNode *temp = list2; for(int i =0;i&lt;b+1;i++) { fast = fast-&gt;next; } for(int i = 0;i&lt;a-1;i++) { slow = slow-&gt;next; } slow-&gt;next = list2; while((temp !=NULL) &amp;&amp; (temp-&gt;next !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2145fa898108e95c62dd994f895e937b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c4296ab5c357819dc70d7fc5cfc93ad/" rel="bookmark">
			Leetcode链表3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解法一：遍历求总长,再循环
/** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode* getKthFromEnd(struct ListNode *head, int k){ struct ListNode *p = head; int a = 1; while(p-&gt;next){ a++; p = p-&gt; next; } p = head; for(int i = 1; i &lt; a-k+1; i ++) p = p-&gt;next; return p; } 解法二：双指针法
struct ListNode* getKthFromEnd(struct ListNode* head, int k){ struct ListNode*slow_p=head,*p=head; while(k--) p=p-&gt;next; while(p!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c4296ab5c357819dc70d7fc5cfc93ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/502930a0cd241f105058d27c7a9fec21/" rel="bookmark">
			Netty源码环境搭建与流程初步梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境说明
&lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-parent&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;4.1.60.Final-SNAPSHOT&lt;/version&gt; apache-maven-3.5.2 虽然编译报错不影响基本流程
[INFO] ------------------------------------------------------------------------ [INFO] Reactor Summary: [INFO] [INFO] [INFO] Netty/Dev-Tools .................................... SUCCESS [ 1.515 s] [INFO] Netty .............................................. SUCCESS [ 13.971 s] [INFO] Netty/Common ....................................... SUCCESS [ 27.839 s] [INFO] Netty/Buffer ....................................... SUCCESS [ 12.523 s] [INFO] Netty/Resolver ..................................... SUCCESS [ 3.941 s] [INFO] Netty/Transport .................................... SUCCESS [ 16.720 s] [INFO] Netty/Codec ........................................ SUCCESS [ 18.790 s] [INFO] Netty/Codec/DNS .................................... SUCCESS [ 8.716 s] [INFO] Netty/Codec/HAProxy .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/502930a0cd241f105058d27c7a9fec21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd16d7d9713886aa8e712c393692fac6/" rel="bookmark">
			java 什么是回调函数_Java回调函数的理解与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回调函数，或简称回调，是指通过函数参数传递到其它代码的，某一块可执行代码的引用。这一设计允许了底层代码调用在高层定义的子程序。
在Java里面，我们使用接口来实现回调。举个例子
所谓的回调，就是程序员A写了一段程序(程序a)，其中预留有回调函数接口，并封装好了该程序。程序员B要让a调用自己的程序b中的一个方法，于是，他通过a中的接口回调自己b中的方法。
举个例子：
1. 首先定义一个类Caller，按照上面的定义就是程序员A写的程序a，这个类里面保存一个接口引用。
public classCaller {privateMyCallInterface callInterface;publicCaller() {
}public voidsetCallFunc(MyCallInterface callInterface) {this.callInterface =callInterface;
}public voidcall() {
callInterface.printName();
}
}
2. 接口的定义，方便程序员B根据定义编写程序实现接口。
public interfaceMyCallInterface {public voidprintName();
}
3. 第三是定义程序员B写的程序b
public class Client implementsMyCallInterface {
@Overridepublic voidprintName() {
System.out.println("This is the client printName method");
}
}
4. 测试
public classTest {public static voidmain(String[] args) {
Caller caller= newCaller();
caller.setCallFunc(newClient());
caller.call();
}
}
这样我们可以看到程序a中保留有接口成员变量，使得程序a可以通过这个接口变量调用这个接口任意实现类的方法。而程序b被调用的方法就是回调函数。
接下来在看一个具体的实现：
下面使用java回调函数来实现一个测试函数运行时间的工具类：
如果我们要测试一个类的方法的执行时间，通常我们会这样做：
public classTestObject {/*** 一个用来被测试的方法，进行了一个比较耗时的循环*/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd16d7d9713886aa8e712c393692fac6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02a6910484db3b5828a4699e12d36e88/" rel="bookmark">
			错误: 编码 GBK 的不可映射字符 (0xA1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决：
javac -encoding UTF-8 FileName.java 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6214db990e7ec9fc2568769405381e90/" rel="bookmark">
			深入理解java线程池_深入理解Java之线程池
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文归作者海子和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。
在前面的文章中，我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：
如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。
那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？
在Java中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下Java的线程池，首先我们从最核心的ThreadPoolExecutor类中的方法讲起，然后再讲述它的实现原理，接着给出了它的使用示例，最后讨论了一下如何合理配置线程池的大小。
以下是本文的目录大纲：
一.Java中的ThreadPoolExecutor类
二.深入剖析线程池实现原理
三.使用示例
四.如何合理配置线程池的大小
若有不正之处请多多谅解，并欢迎批评指正。
请尊重作者劳动成果，转载请标明原文链接：
http://www.cnblogs.com/dolphin0520/p/3932921.html
一.Java中的ThreadPoolExecutor类
java.uitl.concurrent.ThreadPoolExecutor类是线程池中最核心的一个类，因此如果要透彻地了解Java中的线程池，必须先了解这个类。下面我们来看一下ThreadPoolExecutor类的具体实现源码。
在ThreadPoolExecutor类中提供了四个构造方法：
public class ThreadPoolExecutor extends AbstractExecutorService {
.....
public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
BlockingQueue workQueue);
public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
BlockingQueue workQueue,ThreadFactory threadFactory);
public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
BlockingQueue workQueue,RejectedExecutionHandler handler);
public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
BlockingQueue workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler);
...
}
从上面的代码可以得知，ThreadPoolExecutor继承了AbstractExecutorService类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。
下面解释下一下构造器中各个参数的含义：
corePoolSize：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；
maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；
keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；
unit：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性：
TimeUnit.DAYS; //天
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6214db990e7ec9fc2568769405381e90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc5958400253af48fb8d0deb0fdae224/" rel="bookmark">
			深入理解java线程池_深入理解Java线程池
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入理解Java线程池
线程池初探
所谓线程池，就是将多个线程放在一个池子里面(所谓池化技术)，然后需要线程的时候不是创建一个线程，而是从线程池里面获取一个可用的线程，然后执行我们的任务。线程池的关键在于它为我们管理了多个线程，我们不需要关心如何创建线程，我们只需要关系我们的核心业务，然后需要线程来执行任务的时候从线程池中获取线程。任务执行完之后线程不会被销毁，而是会被重新放到池子里面，等待机会去执行任务。
我们为什么需要线程池呢？首先一点是线程池为我们提高了一种简易的多线程编程方案，我们不需要投入太多的精力去管理多个线程，线程池会自动帮我们管理好，它知道什么时候该做什么事情，我们只要在需要的时候去获取就可以了。其次，我们使用线程池很大程度上归咎于创建和销毁线程的代价是非常昂贵的，甚至我们创建和销毁线程的资源要比我们实际执行的任务所花费的时间还要长，这显然是不科学也是不合理的，而且如果没有一个合理的管理者，可能会出现创建了过多的线程的情况，也就是在JVM中存活的线程过多，而存活着的线程也是需要销毁资源的，另外一点，过多的线程可能会造成线程过度切换的尴尬境地。
对线程池有了一个初步的认识之后，我们来看看如何使用线程池。
// 创建一个线程池
ExecutorService executorService = Executors.newFixedThreadPool(1);
// 提交任务
executorService.submit(() -&gt; System.out.println("run"));
Future stringFuture = executorService.submit(() -&gt; "run");
// 创建一个调度线程池
ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1);
// 提交一个周期性执行的任务
scheduledExecutorService.scheduleAtFixedRate(() -&gt; System.out.println("schedule"),0,1, TimeUnit.SECONDS);
// shutdown
executorService.shutdown();
scheduledExecutorService.shutdown();
可以发现使用线程池非常简单，只需要极少的代码就可以创建出我们需要的线程池，然后将我们的任务提交到线程池中去。我们只需要在结束之时记得关闭线程池就可以了。本文的重点并非在于如何使用线程池，而是试图剖析线程池的实现，比如一个调度线程池是怎么实现的？是靠什么实现的？为什么能这样实现等等问题。
Java线程池实现架构
Java中与线程池相关的类都在java.util.concurrent包下，如下展示了一些：
Executor
ExecutorService
ScheduledExecutorService
ThreadPoolExecutor
ScheduledThreadPoolExecutor
Executors
通过上面一节中的使用示例，可以发现Executors类是一个创建线程池的有用的类，事实上，Executors类的角色也就是创建线程池，它是一个工厂类，可以产生不同类型的线程池。而Executor是线程池的鼻祖类，它有两个子类是ExecutorService和ScheduledExecutorService，而ThreadPoolExecutor和ScheduledThreadPoolExecutor则是真正的线程池，我们的任务将被这两个类交由其所管理者的线程池运行，可以发现，ScheduledThreadPoolExecutor是一个万千宠爱于一身的类，下面我们可以看看它的类关系图：
ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，ThreadPoolExecutor实现了一般的线程池，没有调度功能，而ScheduledThreadPoolExecutor继承了ThreadPoolExecutor的实现，然后增加了调度功能。
最为原始的Executor只有一个方法execute，它接受一个Runnable类型的参数，意思是使用线程池来执行这个Runnable，可以发现Executor不提供有返回值的任务。ExecutorService继承了Executor，并且极大的增强了Executor的功能，不仅支持有返回值的任务执行，而且还有很多十分有用的方法来为你提供服务，下面展示了ExecutorService提供的方法：
ScheduledExecutorService继承了ExecutorService，并且增加了特有的调度(schedule)功能。关于Executor、ExecutorService和ScheduledExecutorService的关系，可以见下图：
总结一下，经过我们的调研，可以发现其实对于我们编写多线程代码来说，最为核心的是Executors类，根据我们是需要ExecutorService类型的线程池还是ScheduledExecutorService类型的线程池调用相应的工厂方法就可以了，而ExecutorService的实现表现在ThreadPoolExecutor上，ScheduledExecutorService的实现则表现在ScheduledThreadPoolExecutor上，下文将分别剖析这两者，尝试弄清楚线程池的原理。
ThreadPoolExecutor解析
上文中描述了Java中线程池相关的架构，了解了这些内容其实我们就可以使用java的线程池为我们工作了，使用其提供的线程池我们可以很方便的写出高质量的多线程代码，本节将分析ThreadPoolExecutor的实现，来探索线程池的运行原理。下面的图片展示了ThreadPoolExecutor的类图：
private final BlockingQueue workQueue; // 任务队列，我们的任务会添加到该队列里面，线程将从该队列获取任务来执行
private final HashSet workers = new HashSet();//所有工作线程的集合，来消费workQueue里面的任务
private volatile ThreadFactory threadFactory;//线程工厂
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc5958400253af48fb8d0deb0fdae224/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/171f3a2a548a5446576c817d124fc51c/" rel="bookmark">
			java数组删除元素_java中删除 数组中的指定元素方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java中删除 数组中的指定元素要如何来实现呢，如果各位对于这个算法不是很清楚可以和小编一起来看一篇关于java中删除 数组中的指定元素的例子。
java的api中，并没有提供删除数组中元素的方法。虽然数组是一个对象，不过并没有提供add()、remove()或查找元素的方法。这就是为什么类似ArrayList和HashSet受欢迎的原因。
不过，我们要感谢Apache Commons Utils，我们可以使用这个库的ArrayUtils类来轻易的删除数组中的元素。不过有一点需要注意，数组是在大小是固定的，这意味这我们删除元素后，并不会减少数组的大小。
所以，我们只能创建一个新的数组，然后使用System.arrayCopy()方法将剩下的元素拷贝到新的数组中。对于对象数组，我们还可以将数组转化为List，然后使用List提供的方法来删除对象，然后再将List转换为数组。
为了避免麻烦，我们使用第二种方法：
我们使用Apache commons库中的ArrayUtils类根据索引来删除我们指定的元素。
Apache commons lang3下载地址：
http://commons.apache.org/proper/commons-lang/download_lang.cgi
下载好后，导入jar。
import java.util.Arrays;
import org.apache.commons.lang3.ArrayUtils;
/**
*
* Java program to show how to remove element from Array in Java
* This program shows How to use Apache Commons ArrayUtils to delete
* elements from primitive array.
*
*/
public class RemoveObjectFromArray{
public static void main(String args[]) {
//let's create an array for demonstration purpose
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/171f3a2a548a5446576c817d124fc51c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f73f339c41051fb37f59c1762342cef/" rel="bookmark">
			小型网站，服务器需要的配置。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学生搭建网站，服务器需要什么配置呢？
这点各大云厂商早都替广大学生想好了，那就是学生机啊，学生机标配1核2G1M带宽，磁盘为40G或50G，略有差别，价格基本也都在120元以内，平均每月10块钱，可以购买一台服务器供大学生使劲造，也是一件很爽的事情。
学生机是最便宜的吗？
NO！
在竞争激烈的云计算市场，任何一个巨头都不会错过任何拉新的机会，开始只是争夺学生市场，纷纷推出学生机，但发现学生市场毕竟有限，于是开启新一轮的价格战争夺个人及中小企业用户产品众多。具体内容可参考：
腾讯云1核2G1Mcloud.tencent.com
购买完服务器后该如何搭建网站呢？
这个可以参考我之前的回答，
如何利用wordpress搭建网站如何用云服务器建立一个wordpress网站？​www.zhihu.com
如果您在服务器配置及应用中有任何疑问，欢迎随时留言讨论；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9914e33082758153e93557bacffdd4af/" rel="bookmark">
			关于Maven 报红问题——解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 情况一：pom.xml文件没有报红，但是maven窗口的Dependencies报红： 步骤：
将报红的依赖在pom.xml文件中注释或者先删掉刷新 pom.xml文件（reimport 依赖）重新写入先前报红的依赖 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85797dec843f600ceda6a5cf71bc2880/" rel="bookmark">
			CDA数据分析师认证辅导课
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【CDA认证介绍】
CDA（Certified Data Analyst），即“CDA数据分析师”，是在数字经济大背景和人工智能时代趋势下，面向全行业的专业权威国际资格认证，旨在提升全民数字技能，助力企业数字化转型，推动行业数字化发展。
“CDA数据分析师认证”是一套科学化，专业化，国际化的人才考核标准，共分为CDA LEVELⅠ ，LEVEL Ⅱ，LEVEL Ⅲ三个等级，涉及行业包括互联网、金融、咨询、电信、零售、医疗、旅游等，涉及岗位包括大数据、数据分析、市场、产品、运营、咨询、投资、研发等。该标准符合当今全球数据科学技术潮流，可以为各行业企业和机构提供数据人才参照标准。CDA数据分析师行业标准由国际范围数据科学领域的行业专家、学者及知名企业共同制定并每年修订更新，确保了标准的公立性、权威性、前沿性。通过CDA认证考试者可获得CDA数据分析师中英文认证证书。
【课程介绍】
CDA LEVEL I认证考试辅导视频：由业界专家李奇老师讲解，涵盖考试知识点，经典例题，内容相关及案例分析题目等内容，讲解深入浅出，全面丰富。为考生解决备考过程中的重难点，助力提升考试通过率！
CDA数据分析师®认证 LEVEL I考试辅导精讲课：点击进入
CDA LEVEL II认证考试辅导视频：由业界专家常国珍老师讲解，涵盖考试知识点，经典例题，内容相关及案例分析题目等内容，讲解深入浅出，全面丰富。为考生解决备考过程中的重难点，助力提升考试通过率！
CDA数据分析师®认证 LEVEL II考试辅导精讲课：点击进入
CDA LEVEL III认证考试辅导视频：由业界专家李御玺老师讲解，涵盖CDA LEVEL III考试知识点，经典例题，内容相关及案例实操题目等内容，讲解深入浅出，全面丰富。为考生解决备考过程中的重难点，助力提升考试通过率！
CDA数据分析师®认证 LEVEL III考试辅导精讲课：点击进入
【课程面向与岗位去向】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e6144b630ad4df48f2dce8e911c80b7/" rel="bookmark">
			用python怎么读文件_如何使用Python读取大文件？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里以读取txt大文件为例，简单介绍一下Python是如何读取大文件的，系统内存在8G左右，txt文件的大小为5G，实验环境win10+python3.6+pycharm2018，主要内容如下：
1.首先，按照最原始的方法读取txt文件，即用open函数直接打开txt文件，一次将所有数据读入到内存中，这里如果文件大于系统运行内存，会直接报Memery Error错误，测试代码如下，非常简单：
运行这个程序，读取花费时间大概在41s左右，如下：
2.最基本的方法，为了提高读取速度，以二进制方式打开文件，测试代码如下，对上面的代码只需要稍微修改一下就行，open打开时，设置方式为rb：
运行这个程序，截图如下，读取时间大概在7s左右，明显比直接读取快6倍左右：
3.为了更快的提高读取速度，这里我们在read读取文件的时候，可以按块大小读取，每次读取一定大小的块，依次循环，直到整个文件读完，测试代码如下，也非常简单：
运行这个程序，截图如下，读取时间大概在3.5s左右，比上面直接读取快2倍左右：
4.这里还有一种提高读取的方法就是使用with open打开文件，把文件对象视为一个迭代器，系统会自动使用缓冲IO和内存管理，所以读取速度也会有一定提升，测试代码如下：
运行程序，读取时间大概在26s左右，比直接读取快1倍左右，如下：
5.当然，对于其他类型的大文件，像CSV，Excel等，读取时也可以按块读取，速度也会有明显的提升，基本代码如下，每次读取一定块大小的文件，直到整个文件读完：
至此，我们就完成了使用Python读取大文件。总的来说，基本思想就是按块读取，每次只读取一定块大小的数据，这样读取速度会有明显提升，网上也有相关教程和资料，介绍的非常详细，感兴趣的话，可以搜一下，希望以上分享的内容能对你有所帮助吧，也欢迎大家评论、留言进行补充。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/85/">«</a>
	<span class="pagination__item pagination__item--current">86/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/87/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>