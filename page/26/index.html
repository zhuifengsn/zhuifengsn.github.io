<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cf64836f5319be63c10cc252dd57577/" rel="bookmark">
			VNC如何调整分辨率？（切换到全屏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 首先查看自己显示屏的分辨率 以win11为例，可以看到是1920×1080
2. 在vnc的终端中查看分辨率 # 在命令行输入xrandr xrandr # 结果大致如下 Screen 0: minimum 32 x 32, current 1280 x 800, maximum 32768 x 32768 VNC-0 connected 1024x768+0+0 0mm x 0mm 1024×768	60.00 +* 1920×1200	60.00 1920×1080	60.00 可以看到当前是1024×768
3. 修改分辨率 xrandr --output VNC-0 --mode 1920×1080 修改成功
4. 如果xrandr列表里没有想要的分辨率 需要自己创建，命令行输入cvt 1920 1080 60
#命令行输入如下命令： cvt 1920 1080 60 # 结果如下： # 1920x1080 59.96 Hz (CVT 2.07M9) hsync: 67.16 kHz; pclk: 173.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cf64836f5319be63c10cc252dd57577/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9371face64b07d6300b60eca0c91923/" rel="bookmark">
			【C语言】实现通讯录管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是苏貝，本篇博客带大家实现通讯录，如果你觉得我写的还不错的话，可以给我一个赞👍吗，感谢❤️
目录 一. 前言二. 通讯录的实现2.1 写出基本框架2.2 制作menu菜单2.3 创建联系人和通讯录结构体2.4 定义通讯录并初始化2.5 使用枚举常量优化代码2.6 增加联系人信息2.7 删除联系人信息2.8 查找联系人信息2.9 修改联系人信息2.10 打印所有联系人信息2.11 以名字排序所有联系人 三. 模块化代码实现3.1 test.c3.2 contact.h3.3 contact.c3.4 结果演示 四. 存在的问题 一. 前言 本文将使用C语言来实现通讯录管理系统，该通讯录包括若干联系人，和每个联系人的姓名、年龄、性别、电话、地址。此通讯录的功能包括：增加联系人信息，删除联系人信息，查找联系人信息，修改联系人信息，显示所有联系人信息，根据名字顺序给所有联系人信息排序
二. 通讯录的实现 首先，我们建立1个contact.h文件，即一个头文件，用来声明。建立1个test.c文件，用来测试代码。再建立1个contact.c文件，用来写实现上述6个功能的代码
2.1 写出基本框架 下面的代码就是通讯录的基本框架，很多程序的基本框架和下面代码相似，用do-while循环来决定实现什么功能。变量input作为循环的判断条件，如果选择0，则退出循环，选择1~6之间的数则执行对应的功能，选择其它数则提示输入错误，再进入循环
int main() { int input = 0; do { menu(); printf("请选择："); scanf("%d", input); switch (input) { case 1: break; case 2: break; case 3: break; case 4: break; case 5: break; case 6: break; case 0: printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9371face64b07d6300b60eca0c91923/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d714471c2f69b8d9c92b2afd44918793/" rel="bookmark">
			水一篇看看能不能混一个1024勋章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		纯水，没有任何价值的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f84e3ae906683c342492a22450e3e8c7/" rel="bookmark">
			Oracle19c Database Concepts数据库零基础随便看看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
官方文档：Oracle Database Database Concepts, 19c
1 Oracle简介
物理存储结构
逻辑存储结构
oracle流程架构
实例内存结构
一、oracle关系数据结构
2 表和表簇
架构对象
表概述
数值类型
日期时间数据类型
Rowid数据类型
表存储
表压缩
表集群
临时表
外部表区块链表
3 索引和按索引组织的表
索引
索引类型
B树索引
索引扫描
索引压缩
位图索引
基于函数的索引
二级索引
4 分区、视图和其他架构对象
分区partition
分区特征
分区策略
分区表
分区索引
视图
物化视图（实例化视图）
实例化视图的刷新方法
序列
维度Dimensions
5 数据完整性
6 数据字典和动态性能视图
数据字典
动态性能视图
二 Oracle数据访问
7 SQL
SQL语句
DLL 语句
连接joins
事务控制语句
优化器
优化器的使用
优化器组件
访问路径
Hints
SQL处理
8 服务器端编程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f84e3ae906683c342492a22450e3e8c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32a677e89643ff43e451df0d2d3177c2/" rel="bookmark">
			【Web系列二十六】el-input内容约束的一些方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
写在前面
方案介绍
使用正则表达式实现约束函数
参考资料
写在前面 前端开发会涉及很多输入框，通常都需要根据需求限制输入框的输入内容，其中最常用的就是element ui的el-input，本文就以el-input为例说明，但如果有其他类似的需求也可参考本文的实现方案。
方案介绍 &lt;el-input v-model="form.plan" type="number" step="0.5" min="0" max="5" @keyup="proving($event)" @keyudown="proving($event)" @input="editInput($event,'plan')" oninput="if(value&gt;5)value=5;if(value&lt;0)value=0" /&gt; 方案一：第一~四属性共同使用 type=“number” input的原生属性，标明input框的类型step=“0.5” input的原生属性，type=“number” 时生效， 标明输入字段的合法数字间隔（假如 step=“0.5”，则合法数字应该是 -0.5、0、0.5、1，以此类推）min=“0” max=“5” min 属性规定输入字段所允许的最小值。 max 属性规定输入字段所允许的最大值。 min 属性与 max 属性配合使用，可创建合法值范围。方案二：第五/六个属性@keyup/keydown="proving($event)"，可在按键抬起或按下时触发 proving(e){ var val=e.target.value; //限制只能输入一个小数点 if (val.indexOf(".") != -1) { var str = val.substr(val.indexOf(".") + 1); if (str.indexOf(".") != -1) { val = val.substr(0, val.indexOf(".") + str.indexOf(".") + 1); } } e.target.value = val.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32a677e89643ff43e451df0d2d3177c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32773cf187f7680ac75674366f9d4696/" rel="bookmark">
			【Web系列二十五】前后端使用proto&#43;grpc实现数据传输
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
写在前面
简介
定义
编码
使用过程
环境配置
后端
开发环境
pom配置
前端
开发环境
安装依赖
建立通信
定义Proto结构
编译proto文件
后端
前端
使用proto
后端
前端
参考资料
简介 定义 protocol buffers 是一种语言无关、平台无关、可扩展的序列化结构数据的方法，它可用于（数据）通信协议、数据存储等。通信时所传递的信息是通过Protobuf定义的message数据结构进行打包，然后编译成二进制的码流再进行传输或者存储。
Protocol buffers 是一种灵活，高效，自动化机制的结构数据序列化方法－可类比 XML，但是比 XML 更小（3 ~ 10倍）、更快（20 ~ 100倍）、更为简单。
Protobuf 使用的时候必须写一个 IDL（Interface description language）文件，在里面定义好数据结构，只有预先定义了的数据结构，才能被序列化和反序列化。其中，序列化是将对象转换二进制数据，反序列化是将二进制数据转换成对象。
编码 ProtoBuf 编码格式类似于TLV 格式(Tag | Length | Value)，Tag为字段唯一标识，Length为Value域的长度，Value为数据本身。其中，Tag由field_number和wire_type两个部分组成，field_number是message定义字段时指定的字段编号，wire_type是ProtoBuf 编码类型，根据这个类型选择不同的 Value 编码方案。wire_type最多可表达8种编码类型(因为是3bit的)，目前已经定义了六种(Varint,64-bit,Length-delimited,Start group,End group,32-bit，其中Start group和End group已经弃用)。
在ProtoBuf 中，Length是可选的，即有些类型的数据结构编码后格式是(Tag | Value)，如Varint,64-bit和32-bit。为确定这种格式的数据边界引入了Varint编码。
使用过程 第一步，创建 .proto 文件，定义数据结构。第二步，protoc 编译 .proto 文件生成读写接口第三步，调用接口实现序列化、反序列化以及读写 环境配置 后端 开发环境 spring boot + maven
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32773cf187f7680ac75674366f9d4696/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/904f7448c563f0721ac5f82ded7c87f5/" rel="bookmark">
			Windows 10系统升级后，右键菜单中的“管理员取得所有权”选项消失了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你的Windows 10系统升级后，右键菜单中的“管理员取得所有权”选项消失了，可能是由于以下原因之一：
更改了Windows 10版本或升级：某些Windows 10版本或升级可能会删除该选项，或者可能会更改其位置或名称。
安全设置：在某些情况下，系统管理员可能会更改计算机的安全设置，以防止用户获得管理员权限。
如果你想要重新启用“管理员取得所有权”选项，请尝试以下步骤：
确认你使用的是管理员账户：如果你没有管理员权限，则无法使用“管理员取得所有权”选项。
尝试使用其他方法获取所有权：在“管理员取得所有权”选项消失的情况下，你可以尝试使用其他方法获取文件或文件夹的所有权，例如使用“icacls”命令或者通过属性选项卡的“安全”选项卡。
重新启用“管理员取得所有权”选项：你可以通过修改注册表来重新启用“管理员取得所有权”选项。打开注册表编辑器，导航到“HKEY_CLASSES_ROOT\Directory\shell\runas”键，然后将“HideBasedOnVelocityId”键的值从“1”更改为“0”。
请注意，更改注册表可能会对系统造成不良影响，因此在进行此操作之前，请务必备份注册表并谨慎行事。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11be7916047aa57fd4648648ee87c939/" rel="bookmark">
			关于Mysql中的索引与事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		索引 定义 索引：为了提高查找效率而使用的一种数据结构把数据组织起来，可以把索引理解在书的目录或字典的检索表（拼音检索）
索引是一种特殊的文件，可以包含着对数据表里的所有记录的引用指针，对表中的一列或多列创建索引，并指定索引类型，各类索引有各自的数据结构实现
为什么要用索引 使用索引的主要目的是提高数据检索性能和查询效率。以下是一些使用索引的重要原因：
1. 快速数据访问：索引允许数据库系统快速定位和访问表中的数据行，而无需扫描整个表。这对于大型数据集和复杂查询尤为重要，可以显著减少查询的执行时间。
2. 加速搜索操作：当执行搜索、过滤和排序操作时，索引可将数据库系统的工作量大大降低，因为它们提供了一种有效的方式来查找匹配特定条件的数据（使用B+树）。
3. 提高性能：通过减少查询的时间复杂度，索引可以显著提高数据库的性能和响应时间。这对于需要快速响应用户请求的应用程序尤为重要。
4. 减少磁盘I/O：索引通常存储在内存中，这可以减少磁盘I/O的需求。磁盘I/O通常是数据库查询中的性能瓶颈之一，因此索引可以显著降低I/O操作的次数。
5. 支持唯一性约束：索引可以用于确保数据库表中的数据列具有唯一值，这是通过唯一性约束来实现的。唯一索引可防止重复的数据。
6. 支持外键约束：索引可以用于支持外键约束，确保在不同表之间的引用完整性。外键通常涉及到索引的创建，以提高引用表的查询性能。
7. 支持复杂查询：索引可帮助优化复杂查询，包括联接操作、聚合函数和多个筛选条件的查询。它们可以加速这些查询的执行。
尽管索引提供了这些重要的性能优势，但也需要权衡。索引的创建和维护会占用额外的存储空间和计算资源，并且可能会导致写入操作的性能开销。因此，索引的设计和维护需要仔细考虑，以满足特定应用程序的需求，并确保不会引入不必要的复杂性。
索引使用的数据结构 索引使用的数据结构是B+树，在了解B+树前，我们先了解一下B树
B树 我们学习B树之前一定学过二叉搜索树与二叉平衡树这两种数据结构，这里简单提及一下
二叉平衡树（Balanced Binary Tree）和二叉搜索树（Binary Search Tree）是两种不同的二叉树数据结构，它们具有一些相似之处，但也有重要的区别。
二叉搜索树 (Binary Search Tree，BST)：
特性： 二叉搜索树是一种二叉树，其中每个节点的左子树包含的所有节点的值都小于该节点的值，而右子树包含的所有节点的值都大于该节点的值。这个特性使得在BST中进行快速的查找、插入和删除操作成为可能。
性能： 在平均情况下，BST的查找、插入和删除操作的时间复杂度为O(log N)，其中N是树中节点的数量。但如果树失衡，最坏情况下时间复杂度可达O(N)，这是因为BST没有保证平衡。
二叉平衡树 (Balanced Binary Tree)：
特性： 二叉平衡树是一种二叉树，它在BST的基础上添加了一个重要的性质，即树的高度保持平衡。这意味着树的左子树和右子树的高度差不会太大，通常不超过1。
性能： 由于保持平衡的性质，二叉平衡树的查找、插入和删除操作在最坏情况下也能保持O(log N)的时间复杂度。这使得它在数据结构中的性能更加稳定，而不容易出现极端情况。
二叉搜索树和二叉平衡树是一种很优秀的排序算法，但是这里也是存在一种问题，我们在实际应用的时候，面对的数据是海量的，那么树的深度会大大提升，花费的时间也会变得很大，所以我们就引入了多叉搜索树来解决问题。
特点
1.每个节点可以有多个子树，M 阶 B 树表示该树每个节点最多有 M 个子树
2.每个中间节点有 k-1 个关键字（可以理解为数据）和 k 个子树 (k 介于阶数 M 和 M/2 之间，M/2 向上取整)
3.所有叶子节点都在同一层，并且叶子节点只有关键字，指向孩子的指针为 null
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11be7916047aa57fd4648648ee87c939/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36242bb0b45ffd830df4b427b93e026f/" rel="bookmark">
			如何通过postMessage实现跨源和跨窗口通信？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、语法 otherWindow.postMessage(message, targetOrigin, [transfer]);
otherWindow：目标窗口（你想发送跨域消息的那个窗口），并非当前窗口message：将要发送到其他 window 的数据targetOrigin：通过窗口的 origin 属性来指定哪些窗口能接收到消息事件transfer：可选参数，用的不多，可直接参考文档，此处忽略 二、示例 1、iframe和父窗口之间相互通信 父窗口（http://127.0.0.1:5500/aaaaaaaaa.html）
html部分
&lt;div&gt;测试页面aaaaaaa&lt;/div&gt; &lt;iframe id="iframe" src="http://127.0.0.1:5501/bbbbb.html" width="1200" height="900"&gt;&lt;/iframe&gt; js部分
// 向iframe发送数据 const iFrame = document.getElementById('iframe') iFrame.onload = () =&gt; { iFrame.contentWindow.postMessage('我是来自于父窗口的数据，可在iframe嵌入窗口中获取到', 'http://127.0.0.1:5501') } // 从iframe里获取数据 window.addEventListener('message', e =&gt; { if (e.origin !== 'http://127.0.0.1:5501') return; console.log(e.data) }, false) 子窗口（http://127.0.0.1:5501/bbbbb.html）
js
window.parent.postMessage('我是来自于子窗口的数据，可在父窗口中获取到','http://127.0.0.1:5500') window.addEventListener('message',e=&gt;{ if(e.origin !== 'http://127.0.0.1:5500') return; console.log(e.data) },false) 1、不同窗口之间相互通信 窗口一(http://127.0.0.1:5500)
html部分
&lt;button onclick='onTest()'&gt;测试页面aaaaaaa&lt;/button&gt; js部分
const targetWindow = window.open('http://127.0.0.1:5501/bbbbb.html'); function onTest() { // 接收消息 window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36242bb0b45ffd830df4b427b93e026f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa47c2d698fb0cda21b129502918ee59/" rel="bookmark">
			微服务框架TraceId方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微服务框架TraceId方案 一、背景与目的二、MDC机制三、dubbo框架下TraceId方案3.1 一次用户请求链路跟踪3.1.1 web层3.1.2 RPC调用层 3.2 线程池3.3 其他 一、背景与目的 在项目中随着项目的业务越来越复杂，以及项目的微服务化等，导致平常的项目中出现如：同一次操作日志散乱等现象，对通过查询日志的方式排查问题造成极大困扰。因此迫切需要一种可以追溯当前链路操作日志的手段。
通过实现traceId功能，获取当前操作链路的以下日志信息:
当前操作http请求web端有traceId的日志信息当前操作java服务端有traceId的dubbo consumer日志信息当前操作java服务端有traceId的dubbo provider日志信息其他可以串起来的服务日志信息，如MQ、异步线程等… 二、MDC机制 MDC（Mapped Diagnostic Context，映射诊断上下文）是 log4j 和 logback 提供的一种方便在多线程条件下记录日志的机制。MDC 可以看成是一个与当前线程绑定的Map，类似于 ThreadLocal 可以往其中添加键值对。MDC 中包含的内容可以被同一线程中执行的代码所访问。当前线程的子线程会继承其父线程中的 MDC 的内容(只有子线程创建的时候初始化一次并不适用于线程池)。当需要记录日志时，只需要从 MDC 中获取就行。
三、dubbo框架下TraceId方案 先定义一个通用的 TraceId 生成工具类，如下：
import org.springframework.util.StringUtils; public class TraceIdUtils { public static final String X_TRACE_ID = "X-TraceId"; /** * 通过 ThreadLocal 存储 traceId，保证同一个线程，可以获取到同一个 traceId */ private static final ThreadLocal&lt;String&gt; TRACE_ID_LOCAL = new ThreadLocal(); private TraceIdUtils() { } // 生成一个traceId public static String genTraceId() { String traceId = genTraceIdNotCached(); TRACE_ID_LOCAL.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa47c2d698fb0cda21b129502918ee59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2319ab86378f285095a17d0e67070c3f/" rel="bookmark">
			前端日常开发常见坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、关于nth-of-type、nth-child选择失败的问题
如下示例：会发现.b:nth-of-type(1) { color: red; }失效
&lt;div class="demo"&gt; &lt;div class="a"&gt;aa&lt;/div&gt; &lt;div class="b"&gt;b1&lt;/div&gt; &lt;div class="b"&gt;b2&lt;/div&gt; &lt;div class="c"&gt;cc&lt;/div&gt; &lt;/div&gt; .class:nth-of-type(i) 的真正意义是：
要选中的元素的类名是class
这个元素是它的父元素下同一个标签名的元素中的第 i 个
2、every方法判断空数组失效
[].every(i =&gt; i === 1) // 打印出来是true，并不是false [2, 1].every(i =&gt; i === 1) // 打印出来是false [1, 1].every(i =&gt; i === 1) // 打印出来是true 3、持续更新中。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ea8a1f9d87f2537c81162406b5323b8/" rel="bookmark">
			实现STM32采集电压值并显示在串口屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include "stdio.h"
#define LED1_ON() HAL_GPIO_WritePin(GPIOE,GPIO_PIN_1,GPIO_PIN_SET)
#define LED1_OFF() HAL_GPIO_WritePin(GPIOE,GPIO_PIN_1,GPIO_PIN_RESET)
uint16_t ADC_Value=0,ADC_Volt=0;
uint8_t str_buff[64];
void Send()
{
printf("t0.txt=\"%d.%d%dV\"\xFF\xFF\xFF",ADC_Volt/100,(ADC_Volt%100)/10,ADC_Volt%10); printf("n0.val=%d\xFF\xFF\xFF",ADC_Value);
}
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc)
{
if(hadc-&gt;Instance==ADC1)
{
ADC_Value=HAL_ADC_GetValue(&amp;hadc1);
ADC_Volt=ADC_Value*330/4096;
Send();
LED1_OFF();
}
}
int fputc(int ch,FILE *f)//重定向
{
HAL_UART_Transmit(&amp;huart1,(uint8_t*)&amp;ch,1,1000);
return ch;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15c17f9410b1230b35462fb68d21b295/" rel="bookmark">
			游戏文本本地化【Unity / Luban / QFramework】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于 Luban + QFramework 的本地化 Luban：主要用于将 Excel 数据转换为可供游戏使用的数据（如 Json 格式），因此可将各国语言存储在 Excel 中便于管理，可用其他同类方案代替
QFramework：本案例主要使用它的事件机制（观察者模式），实现语言的即时切换，可用其他同类方案代替
一、建立多语言 Excel 表 ##varidsimplified_chineseenglish##typeintstringstring10000穿甲弹Pierce Bullet10001医疗包Medical Kit10002兴奋剂Dope10003荆棘Thorn10005近视眼Myopia10006印钞机Money Printing Machine10007撬棍Crowbar10008弹匣Gun Magazine 然后通过 Luban 生成代码：
该表作为数据表 local.TbTextLocalization.cs
该表的条目的对象为：LocalizedText.cs（大致内容如下）
public sealed partial class LocalizedText : Luban.BeanBase { public readonly int Id; public readonly string SimplifiedChinese; public readonly string English; } 二、创建本地化控制器/文本本地化模块组件 using cfg; namespace XXX { public enum Language { SimplifiedChinese, English, } public static class LocalizationController { private static Language _curLanguage = Language.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15c17f9410b1230b35462fb68d21b295/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1151c51dec9e102c934a02ad1970e05b/" rel="bookmark">
			Go语言学习17-功能测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go语言学习系列
功能测试 引言主要内容1. 编写功能测试函数2. 常规记录3. 错误记录4. 致命错误记录5. 失败标记6. 立即失败标记7. 失败判断8. 忽略测试9. 并行运行10. 功能测试的运行11. 关于测试运行的时间12. 测试的并发执行 结语 引言 Go语言中提供了 go test 命令，它不仅仅可以对代码包进行测试，还可以对个别源码文件进行测试，只要存在针对这些测试的测试源码文件。除此之外，Go语言还在标准库中提供了一个专门用于测试的代码包 testing，它提供了编写测试源码文件所需的一切。
主要内容 1. 编写功能测试函数 测试源码文件总应该与被它测试的源码文件处于同一代码包内。在编写测试源码文件的时候，总是会用到标准库代码包 testing 中的 API。testing 包为Go语言的代码包提供了自动化测试支持。它的目标是与 go test 命令协同使用，以自动执行目标代码包中的任何测试函数。
在测试源码文件中，针对其他源码文件中的程序实体的功能测试程序总是以函数为单位的。被用于测试程序实体功能的函数的名称和签名形如：
func TestXxx(t *testing.T) 其中，Xxx 应该是大写字母开头的若干字母或数字的组合，通常情况下会将 Xxx 替换成被测试的程序实体的名称。可以利用 *testing.T 类型的参数 t 上的一些方法对功能测试的过程进行记录和控制。使用 t 的值上的方法记录的信息会在测试结束之后（不论成败），一并打印到标准输出上。
2. 常规记录 参数 t 上的 Log 和 Logf 方法一般用于记录一些常规信息，以展示测试程序的运行过程以及被测试程序实体的实时状态。调用语句如下：
t.Log("Tomorrow is a ", "good ", "day ") // 类似于fmt.Println t.Logf("Tomorrow is a %s"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1151c51dec9e102c934a02ad1970e05b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f5d5f8888990ae7e36f905cf4b63caa/" rel="bookmark">
			如何快速集成讯飞星火 2.0 API ？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是二哥呀。
之前带大家体验了两波科大讯飞的星火认知大模型，真没想到，反馈远超我的预期，大家普遍都说好，不仅注册方便，工作和学习的效率也得到了极大的提升。
今天继续给大家带来重磅体验，讯飞 API 2.0，个人用户不用注册就可以免费领取 20 万 token，注册用户更是高达 200 万，相较于 ChatGPT 预付费模式，讯飞星火这个决定，不仅胆大，并且良心啊。也不藏着掖着了，二哥是个关系户，所以直接拿到了 600 万 token！
01、领取讯飞 API 大家也别不好意思，先把免费额度领取了，尤其是开发者，不管现在用不用得上，先把坑给占了，免得以后要用了，却申请不到，懊悔就来不及了。
PC 端的小伙伴直接复制二哥的专属邀请地址到浏览器打开。
https://xinghuo.xfyun.cn/sparkapi?ch=blapi_ep6QPI
通过二哥的专属二维码和链接会触发以下被动技能（😁）：
注册免费，即刻上手；0 门槛领取 20 万讯飞星火认知大模型 API Tokens；认证后的用户最高可再申请 400 万 Tokens。 之后就可以在控制台看到领取的 token 数，以及应用的 appid、APISecret、APIKey 了。
不过，要是企业来购买就贵了呀，1 个小目标的 token 需要 3600 元呢？（突然有一个大胆的想法，你懂的）
02、体验讯飞 API 好了，不废话，为了能让大家直观感受到讯飞星火大模型 2.0 的牛逼之处，二哥花了一周的时间把这 600 万的 token 直接集成到技术派的派聪明AI助手当中了，效果那是相当炸裂，一起来围观下。
体验地址：https://paicoding.com/chat
直接问“沉默王二是谁？”，他竟然能回答个七七八八，着实厉害了呀。
一些原则性的问题，它也能回答的很正确，比如问河南有几所 211 大学，回答只有一所郑大，不错。
生活化的问题它也能轻松驾驭，比如说天气。
尤其是代码能力 2.0 在 1.5 的基础上有了很大的改观。
看到这大家是不是很心动，是不是也想自己拥有一个讯飞认知大模型，专供自己使用，无论是开发还是学习，我相信大家都已经迫不及待了。
好，接下来，二哥来手把手带大家在本地搭建一个讯飞的聊天系统，全程不到 5 分钟。
03、拉取技术派仓库 为了方便大家集成讯飞星火大模型的 API，二哥已经帮大家封装好了，代码已经提交到 GitHub，大家可以通过下面的链接直接拉取。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f5d5f8888990ae7e36f905cf4b63caa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37a21efcd88b2f22e0a96732a3bc9981/" rel="bookmark">
			[linux]vncserver常用终端命令合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开启vnc服务：systemctl start vncserver@:1.service
关闭vnc服务：systemctl stop vncserver@:1.service
重启vnc服务：systemctl restart vncserver@:1.service
设置VNC密码: vncpasswd
开启VNC： vncserver :1
关闭VNC： vncserver -kill :1
查看vnc是否在进程：ps -ef | grep vnc
查看5901端口是否在进程：netstat -antulp | grep 5901
杀死进程：sudo kill -9 进程号
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/768dcbdce768fa5f46efec28a2ce1739/" rel="bookmark">
			xfs ext4 结合lvm 扩容、缩容 —— 筑梦之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ext4 文件系统扩容、缩容操作 扩容系统根分区 根文件系统在 /dev/VolGroup/lv_root 逻辑卷上，文件系统类型为ext4，大小为10G，现在要将其扩容成20G。
给空闲空间分区 # 调整分区类型为LVM，也就是8e类型 fdisk /dev/sdb # 选定分区后使用 t 选项，然后选择8e类型 # 通知内核重读分区表 partx -a /dev/sdb # 查看 cat /proc/partitions lsblk 扩容操作 # 1. 创建pv pvcreate /dev/sdb7 # 2. 对根 / 所在的vg进行扩容，将/dev/sdb7这个pv添加到VolGroup这个vg中去 vgextend VolGroup /dev/sdb7 # 3. 对根 / 所在的lv进行扩容 # 先通过vgdisplay命令查看对应vg中空闲的pe数量，然后再将这些空闲的pe添加到lv中去 lvextend -l +2194 /dev/VolGroup/lv_root # 4. 扩容文件系统 resize2fs /dev/VolGroup/lv_root # 自动扩容，将可分配的空间全部分配完 # 或者扩容成指定的大小 resize2fs /dev/VolGroup/lv_root 15G # 5. 查看是否扩容成功 df -hT 注意：LV扩容前最好先卸载挂载的设备，然后再使用 lvextend 进行扩容，这里因为是对根文件系统进行扩容，故而没有卸载 缩容 /dev/sdb6 和 /dev/sdb4 一共分区大小为5G，分区类型为8e，它们被添加到了卷组VolGroup中，并做成 lv_mnt 逻辑卷挂载在了 /mnt 目录。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/768dcbdce768fa5f46efec28a2ce1739/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8eba6c40065f69f9bcf1dcb83d3565e/" rel="bookmark">
			.NET Framework 介绍及版本查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.NET Framework 由两个组件构成： 一组程序集，它们是为应用提供功能的类型与资源的集合。 .NET Framework 和程序集使用相同的版本号。公共语言运行时 (CLR)，可管理并执行应用代码。 单个 CLR 版本通常可支持多个 .NET Framework 版本。 例如，CLR 版本4.0.30319.xxxxx（其中 xxxxx 小于42000）支持 .NET Framework 版本 4 到 4.5.2。 大于或等于4.0.30319.42000 的 CLR 版本支持从 .NET Framework 4.6 开始的 .NET Framework 版本。 注册表查看 .NET Framework 版本： 在“开始”菜单中，选择“运行”，输入“regedit”，然后选择“确定” 。
（必须具有管理凭据才能运行 regedit。）在注册表编辑器中，打开以下子项：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Full。 如果“Full”子项不存在，则表示尚未安装 .NET Framework 4.5 或更高版本。请检查名为“Release”的 REG_DWORD 条目。 如果存在，则已安装 .NET Framework 4.5 或更高版本。 PowerShell 查看 .NET Framework 版本： PowerShell 查看 .Net Framework 版本：
Get-ChildItem 'HKLM:\SOFTWARE\Microsoft\NET Framework Setup\NDP' -Recurse | ` Get-ItemProperty -Name version -EA 0 | Where { $_.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8eba6c40065f69f9bcf1dcb83d3565e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97ecaca6e03d3f9f6cd0510bd3db1712/" rel="bookmark">
			51单片机（六）：矩阵键盘的扫描
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、独立式按键与矩阵式按键
常用的键盘电路有两种形式：独立式按键和矩阵式按键。
1. 独立式按键
独立式按键比较简单，它们各自与独立的输入线相连接，如上图所示。4条输入线接到单片机的 I / O 口上，当按下按键K1时，+5V依次通过电阻R1和按键K1最终进入 GND 形成一条通路，这条线路的全部电压都加到电阻R1上，引脚 KeyInl 就是一个低电平。当松开按键后，线路断开，不会有电流通过， KeyInl 和＋5V应该是等电位，是一个高电平。因此，可以通过引脚 KeyInl 这个 I / O 口的高低电平来判断是否有按键按下。
实际上在单片机 I / O 口内部，也有一个上拉电阻。按键是接到P2口上，P2口上电默认是准双向 I / O 口，下面来简单了解一下准双向 I / O 口的电路，电路如上图所示。方框内的电路都是指单片机内部部分，方框外的就是外接的上拉电阻和按键。这个地方大家要注意一下，就是当要读取外部按键信号的时候，单片机必须先给该引脚写"1"，也就是高电平，这样才能正确读取到外部按键信号，下面来分析一下缘由。
当内部输出是高电平时，经过一个反向器变成低电平， NPN 三极管不会导通，单片机 I / O 口从内部来看，由于上拉电阻 R 的存在，所以是一个高电平。当外部没有按键按下将电平拉低， VCC 也是＋5V，它们之间虽然有两个电阻，但是没有压差，就不会有电流，线上所有的位置是高电平，这时就可以正常读取按键的状态了。
当内部输出是低电平时，经过一个反相器变成高电平， NPN 三极管导通，单片机的内部 I / O 口就是一个低电平，这时，外部虽然也有上拉电阻的存在，但是两个电阻是并联关系，不管按键是否按下，单片机的 I / O 口上输入单片机内部的状态都是低电平，因此无法正常读取按键的状态。
2. 矩阵式按键
在某一个系统设计中，当需要使用很多按键时，做成独立按键会大量占用I / O口，因此引入了矩阵按键的设计。如下图所示的矩阵按键电路原理图，使用8个 I / O 口实现16个按键。
如果理解了独立按键，就不难理解矩阵按键，下面来分析一下。图中一共有4组按键，我们只看其中一组，如下图所示。大家认真看一下，如果 KeyOutl 输出一个低电平，则KeyOut1相当于 GND ，此时，K1、K2、K3、K4相当于4个独立按键。当然这时KeyOut2、KeyOut3、KeyOut4必须都输出高电平，才能保证与它们相连的3路按键不会对这一路产生干扰，大家可以对照两张原理图分析一下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97ecaca6e03d3f9f6cd0510bd3db1712/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32c889b55968c25496c79e8cd0bb82c9/" rel="bookmark">
			Linux 下查看 VNC 连接状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows 系统下进行远程连接的时候，往往会使用 VNC，VNC (Virtual Network Computing) 是一种跨平台的远程图形系统，它可以使 Windows，Linux，MacOS 进行远程图形操作系统，尤其是在 Linux 操作系统下，需要远程控制 Linux 系统时，更是不可缺少。本文详细介绍了 Linux 系统下查看 VNC 连接状态的方法。
一、检查 VNC 连接状态
要检查 VNC 连接状态，首先需要确认已经安装 VNC Server。在 Linux 系统上，可以使用如下命令查看是否已经安装 VNC：
$ rpm -qa | grep vnc 如果已经安装 VNC，会返回相关的信息。比如：
$ rpm -qa | grep vnc tigervnc-server-1.3.1-4.el7_1.x86_64 这样就证明已经安装了 VNC。
接下来要检查 VNC 连接的状态，需要使用以下命令：
$ netstat -an | grep 5900 这里 5900 表示 VNC 默认使用的端口号，如果有连接请求进行或者正在连接，会返回有关信息，比如：
$ netstat -an | grep 5900 tcp 0 0 0.0.0.0:5900 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32c889b55968c25496c79e8cd0bb82c9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/25/">«</a>
	<span class="pagination__item pagination__item--current">26/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/27/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>