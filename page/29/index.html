<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fce973ed0832eaa9a8f1cfbe3d7b4f73/" rel="bookmark">
			TCP原理（全网最详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、确认应答（可靠性机制） TCP诞生的初衷就是可靠传输
可靠传输是TCP最核心的部分，TCP内部很多机制都是在保证可靠传输（可以理解为发一条消息，上面显示已读未读，可靠传输就是发一条消息我知道对方是否收到）。
确认应答，要针对数据进行编号，然后才能明确，应答报文实在应答那个数据，应对了网络传输的“后发先至”
TCP就引入了“序号”
32位序号：给发送的每一条数据，都进行了编号
32位确认序号：如果当前报文是一个普通的报文。确认序号不生效，但是如果当前报文是一个应答报文，确认序号就表示应答的是哪个普通报文。
报文字节：
由于TCP是面向字节流的，编号的时候，不是按照条编号，而是按照字节来编号。 图中的主机A发送了100字节的数据（一个TCP数据报，长度是1000，序号是1）
应答报文中的确认序号就是1001。应答报文，可以视为只有TCP报头，没有载荷。其中的确认序号字段填写的是1001，意思就是&lt;1001的数据，主机B全部都收到了，接下来A就要从1001开始往后发送。
此时有人就会问，TCP不是传输的字节流呢？怎么传输的数据报呢？
例如在我们的UDP中：
B这边调用一个recv方法：
第一次读取的是1111第二次读取的是2222第三次读取的是3333 每次调用recv方法就是从接收缓冲区中取走一个数据，UDP的接受缓冲区，相当于一个链表，里面三个节点，每次都以一个节点为单位进行读取，这就是面向数据报。
在TCP中：
用InputStream.read(buffer)
byte[1] buffer 读出来的就是 1byte[3] buffer 读出来的就是 111byte[5] buffer 读出来的就是 11112byte[7] buffer 读出来的就是 1111222 TCP的接收缓冲区，就i像一个数组，若干个TCP数据报的载荷会一直追加到这个数组里，这就是面向字节流。
如何区分，一个报文是普通报文还是应答报文呢？
在TCP报头中有6个非常重要的比特位，其中第二个ACK就是表达的应答报文。
ACK是0表达不是应答报文ACK是1表带是应答报文 URG（Urgent）：URG标志位占据TCP头部的第13位（最左边的位），用于指示紧急数据。如果URG标志位被设置为1，那么TCP包含的数据被标记为紧急数据，需要被尽快传送和处理。
ACK（Acknowledgment）：ACK标志位占据TCP头部的第14位，用于确认对方已经成功接收到了之前发送的数据。当ACK标志位被设置为1时，表示这是一个包含确认信息的TCP报文。
PSH（Push）：PSH标志位占据TCP头部的第15位，用于指示接收方应该尽快将数据交给应用程序，而不是等到缓冲区充满或等待定时器触发。
RST（Reset）：RST标志位占据TCP头部的第16位，用于重置连接。如果RST标志位被设置为1，它表示连接出现了异常，需要立即关闭，并且后续的数据传输将被终止。
SYN（Synchronize）：SYN标志位占据TCP头部的第17位，用于建立连接。当客户端尝试与服务器建立连接时，它会将SYN标志位设置为1，表示请求建立连接。
FIN（Finish）：FIN标志位占据TCP头部的第18位，用于关闭连接。当一方希望关闭连接时，它会将FIN标志位设置为1，表示它已经不再发送数据，并且希望进行优雅的连接关闭。
在确认应答的情况下，如果收到了ACK就好办，但是如果没有收到呢?还需要通过其他途径来处理。
二、超时重传（可靠性机制） 确认应答是一种很理想的状态，但是数据开发的过程中很容易出现丢包的情况。
发送请求丢失
ACK丢失
业务数据已经到了主机B，反馈的ACK没有回去，发送方等待了一会之后，就会触发重传。对于发送方来说，无法区分是发送请求丢失还是ACK丢失，因此发送方能做的就是到达一定时间超时重传。
ACK丢失的情况下，进行超时重传，接收方会收到两份相同的数据，这个时候就会涉及到去重。根据序列号，把序列号相同的去除掉。
丢包操作，还有一个超时时间，超时时间具体是多少，在操作系统内核是可以配置的。
第一次丢包，超时时间是 T1
第二次丢包，超时时间是 T2
T2 &gt; T1 这里等待的时间间隔随着时间的推移越来越大，连续两次没发过去，意味着当前单次丢包的概率已经相当大了，很可能是网络上遇到了非常严重的事故，短期内恢复不了，发送的再频繁也没用。超时重传也不会无限制的重传下去，尝试几次之后，仍然无法传送过去，此时就会放弃重传，然后尝试断开重连，如果重连还没连上去，就彻底放弃了。
超时的时间如何确定？
最理想的情况下，找到一个最小的时间，保证 “确认应答一定能在这个时间内返回”。但是这个时间的长短，随着网络环境的不同，是有差异的。如果超时时间设的太长，会影响整体的重传效率；如果超时时间设的太短，有可能会频繁发送重复的包； TCP为了保证无论在任何环境下都能比较高性能的通信，因此会动态计算这个最大超时时间
Linux中（BSD Unix和Windows也是如此），超时以500ms为一个单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍。
如果重发一次之后，仍然得不到应答，等待 2*500ms 后再进行重传。
如果仍然得不到应答，等待 4*500ms 进行重传。依次类推，以指数形式递增。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fce973ed0832eaa9a8f1cfbe3d7b4f73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37ef3d08410f13801b08a46ab14cc8f2/" rel="bookmark">
			【Python】关于自定义对象的Json序列化和反序列化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 最近使用Ptyon爬虫数据时，遇到对象无法转换为JSON序列化对象问题TypeError: Object of type Main is not JSON serializable
意思： 就是对象不能转换为JSON序列化对象
原因： 是对象没有自定义实现转换为JSON序列化对象的方法没有。
实现 class Main(object): def __init__(self, name, age): self.name = name self.age = age def __str__(self): return 'Main(name={}, age={})'.format(self.name, self.age) def __repr__(self): return 'Main(name={}, age={})'.format(self.name, self.age) def to_json(self): return {'name': self.name, 'age': self.age} @classmethod def from_json(cls, json_data): return cls(**json_data) if __name__ == '__main__': main = Main('zhangsan', 18) # 因为Main是自定义对象，如果没有指定default方法，则无法转换为JSON序列化对象，并且报错`TypeError: Object of type StockData is not JSON serializable` # jsonStr = json.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37ef3d08410f13801b08a46ab14cc8f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77ae187e0369c7f08da0f73c5cd32808/" rel="bookmark">
			【Python】关于自定义对象的字符串输出问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 背景 由于自定义对象如果没有指定toString方式，则控制台print打印是就是内存地址型式，如：&lt;__main__.Main object at 0x0000023507367A30&gt;
demo class Main: def __init__(self): self.name = "main" def __str__(self): return "Main Str" def __repr__(self): return "Main Repr" if __name__ == '__main__': main = Main() print(main) # 没有实现__str__和__repr__方法会输出内存地址: &lt;__main__.Main object at 0x0000023507367A30&gt; # 实现了__str__会输出字符串内容: Main Str # 没有实现__str__但实现了__repr__会输出字符串内容: Main Repr mains = [Main() for i in range(10)] print(mains) # 没有实现__repr__方法会输出内存地址: [ &lt;__main__.Main object at 0x000001827D543DF0&gt;,...] # 实现__repr__就会输出字符串内容: [Main Repr,...] 总结 对象字符串输出需要实现__str__或__repr__方法对象字符串输出优先级：__str__ &gt; __repr__对象列表字符串输出必需实现__repr__方法 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/960a78d2a6cc9bdd41f80bbb93c383ee/" rel="bookmark">
			Task :app:compileDebugKotlin FAILED
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gradle.properties 里面加上 android.enableJetifier=true
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a90e901e0c7b81fdfb525d835b1973d9/" rel="bookmark">
			GROUP BY 使用方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 group by是开发中经常用到的SQL语句，从字面意思来看就是根据哪个字段或者哪几个字段对查询到的数据进行分组统计，既然是分组统计那如何分组呢？所以group by通常都是和聚合函数还有having一起使用。
一、语法 select 聚合函数(字段1)，字段2 from 表名 where 条件 group by 字段2,字段3
或者
select 聚合函数(字段1)，字段2 from 表名 where 条件 group by 字段2,字段3 having 过滤条件
使用了group by 后，要求select出的结果字段都是可汇总的，否则就会出错。
group by 有一个原则,就是 select 后面的所有列中,没有使用聚合函数的列,必须出现在 group by 后面。
二、举个例子 CREATE TABLE Sales (commodity VARCHAR(50), region VARCHAR(50), salesVolume INT); INSERT INTO Sales VALUES (N'电视机', N'河北省', 10000); INSERT INTO Sales VALUES (N'电视机', N'山东省', 20000); INSERT INTO Sales VALUES (N'电视机', N'山东省', 30000); INSERT INTO Sales VALUES (N'冰箱', N'浙江省', 15000); SELECT * FROM Sales SELECT region,SUM(salesVolume) 销量 from Sales GROUP BY region 返回结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a90e901e0c7b81fdfb525d835b1973d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ef7ae61ded8a39436893cd4fa48d37b/" rel="bookmark">
			Java 数组删除一个元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 根据下标删除一个数组元素
public static void main(String[] args) { int[] arr = {1,2,3,4}; arr = rem(arr, 3); System.out.println(JSONObject.toJSONString(arr)); } private static int[] rem (int[] arr, int index){ // 创建一个新数组 int[] arr2 = new int[arr.length-1]; for (int i = 0; i &lt; arr.length-1; i++) { // 如果下标大于等于要删除的元素下标，新数组的元素等于旧数组往后一个位置的元素 if (i &gt;= index) { arr2[i] = arr[i+1]; } else { arr2[i] = arr[i]; } } return arr2; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8d6c49b3feeb76ca443a490b2679967/" rel="bookmark">
			JavaScript之清除数组空值项、包括空数组、空对象、去除、去掉、过滤、isArray、stringify、push、continue、length、filter、includes
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、方案一2、方案二 1、方案一 function cleanArray(actual) { let newArray = [], i = 0, item = null; for (; i &lt; actual.length; i++) { item = actual[i]; if (item != null &amp;&amp; item != undefined &amp;&amp; item != '') { if (Array.isArray(item) &amp;&amp; !item.length) continue; if (JSON.stringify(item) == "{}") continue; newArray.push(item); } } return newArray; } let data = [3, undefined, 6, null, 7, '', [9], [], {name: '舒冬'}, {}, 5, '半晨']; console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8d6c49b3feeb76ca443a490b2679967/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee94eb9fe415c1ceaa82c28596b486eb/" rel="bookmark">
			OpenWRT固件安装到普通计算机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备工作： 下载所需的OpenWRT固件镜像，确保选择与您的计算机架构相匹配的版本。例如，如果您的计算机是x86_64架构，您可以在OpenWRT镜像站点下载合适的版本。
获取OpenWRT镜像：
wget https://mirrors.cloud.tencent.com/lede/releases/23.05.0-rc3/targets/x86/64/openwrt-23.05.0-rc3-x86-64-generic-ext4-combined.img.gz 解压镜像文件：
gunzip openwrt-23.05.0-rc3-x86-64-generic-ext4-combined.img.gz 查看镜像分区信息：
sudo parted openwrt-23.05.0-rc3-x86-64-generic-ext4-combined.img unit B print 记下输出中的两个"start"值，通常是 boot 分区和 root 分区的偏移值。
挂载镜像并获取文件系统：
创建临时目录：
mkdir tmp 挂载 boot 分区：
mount -o loop,offset=&lt;boot分区的start值&gt; openwrt-23.05.0-rc3-x86-64-generic-ext4-combined.img tmp cp tmp/boot boot -a umount tmp/ 挂载 root 分区：
mount -o loop,offset=&lt;root分区的start值&gt; openwrt-23.05.0-rc3-x86-64-generic-ext4-combined.img tmp cp tmp/ rootfs -a sync umount tmp/ 移动 boot 目录到 rootfs 目录下：
mv boot/ rootfs/ 压缩根文件系统：
cd rootfs/ tar cvzf ../rootfs.tar.gz * cd - 创建可引导的U盘：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee94eb9fe415c1ceaa82c28596b486eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/928f68346e47f4c216c9b54e2fb113f7/" rel="bookmark">
			OpenWAF配置SSL访问本地资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenWAF配置Https访问本地资源 介绍 OpenWAF（Web Application Firewall）是一个开源的Web应用防火墙，用于保护Web应用程序免受各种网络攻击。它通过与Web服务器集成，监控和过滤对Web应用程序的流量，识别和阻止潜在的攻击和恶意行为。
OpenWAF拥有一系列强大的安全功能，旨在提供全面的保护，包括以下方面：
攻击防护：OpenWAF能够检测和阻止常见的Web攻击，如跨站脚本（XSS）、SQL注入、命令注入、跨站请求伪造（CSRF）和路径遍历等。它分析输入和输出的数据，通过识别恶意的请求和特定的攻击模式来防止攻击的发生。
访问控制：OpenWAF可以根据配置的规则对流量进行筛选和控制，允许合法的请求通过，并阻止潜在的恶意请求。你可以设置IP白名单和黑名单，限制特定的访问来源或阻止已知的恶意IP地址。
会话保护：通过OpenWAF，你可以保护Web应用程序的会话机制，防止会话劫持和会话固定攻击。它可以验证会话的合法性、检测异常活动并阻止恶意的会话操作。
热点防护：OpenWAF可以对网站中的热点资源进行保护，防止因频繁请求而导致的资源滥用和服务不可用。它可以限制特定资源的访问频率，并对异常的访问行为进行监测和阻止。
日志和监控：OpenWAF提供了日志记录和监控功能，记录每个请求的详细信息，包括访问来源、请求的URL、攻击尝试和阻止的恶意行为等。通过分析日志数据，可以及时发现潜在的安全隐患和异常行为。
OpenWAF作为开源项目，具有灵活性和可定制性，你可以根据自己的需要对其进行配置和扩展。它与常见的Web服务器（如Nginx和Apache）兼容，并提供了丰富的插件和扩展库，以满足不同的安全需求。
总的来说，OpenWAF是保护Web应用程序安全的重要工具，可以帮助你减少潜在的攻击威胁，保护用户数据的安全性。如果你运营着一个Web应用程序，并且关注安全性，不妨考虑使用OpenWAF来增加你的应用程序的防护能力。
希望这个简介能给你对OpenWAF有一个初步的了解。如果你还有其他问题，我随时都能为你提供帮助！保护你的Web应用程序，让黑客无从下手！
本地资源nginx配置 以下除了location内的配置以及server_name配置，其他都是固定就可以
server { listen 443 ssl; server_name _; ssl_certificate /opt/OpenWAF/conf/ssl/nginx.crt; ssl_certificate_key /opt/OpenWAF/conf/ssl/nginx.key; ssl_protocols TLSv1.1 TLSv1.2; include /opt/OpenWAF/conf/twaf_server.conf; #添加 WAF 防护 ssl_certificate_by_lua_file /opt/OpenWAF/app/twaf_ssl_cert.lua; #动态指定 SSL 证书 location / { root 目录; index index.html; } } access_rule 中指定 SSL 证书 { "twaf_access_rule": [ "rules": [ { "ngx_ssl": true, "ngx_ssl_cert": "opt/OpenWAF/conf/ssl/abc.crt", #证书所在目录 "ngx_ssl_key": "/opt/OpenWAF/conf/ssl/abc.key", #证书所在目录 "host": "域名", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/928f68346e47f4c216c9b54e2fb113f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d12283dd0ab07d63e8a654b78959758/" rel="bookmark">
			Centos7安装Redis(超详细)与Redis的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 ​ Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。
​ 下载地址：https://github.com/microsoftarchive/redis/releases
安装 第一步，先在Windows上下载 Redis, 下载地址：https://redis.io/download&gt;，传输到Centos的/data/redis目录下，或者在/data/redis目录下使用wget命令：wget https://download.redis.io/releases/redis-7.0.2.tar.gz
mkdir -r /data/redis cd /data/redis wget https://download.redis.io/releases/redis-7.0.2.tar.gz 第二步，解压，然后进入到解压目录，执行如下命令：
tar -zxvf redis-7.0.2.tar.gz 第三步，进入到redis-7.0.2目录下执行如下命令，编译并检查安装环境：
cd /data/redis/redis-7.0.2 make 如果执行 make令报错，redis是由C语言开发，因此安装之前必须要确保服务器已经安装了gcc，那么执行如下命令，安装 c 语言的编译器：
yum install -y cpp binutils glibc glibc-kernheaders glibc-common glibc-devel gcc 执行完如上命令，再试着执行 make 命令，如果还是报错，再执行如下命令：
yum -y install centos-release-scl yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils scl enable devtoolset-9 bash 执行完如上的命令，再执行 make 命令，还是报错，就执行如下命令：
make MALLOC=libc 解决如上的问题的方式参照网址：https://blog.csdn.net/realize_dream/article/details/106483499
第四步，执行如下命令进行安装：
make install PREFIX=/data/redis ## 注意PREFIX=/data/redis指定安装目录，可指定可不指定，如果不指定默认是在/data/redis/redis-7.0.2/src/目录下,如果指定则会在/data/redis目录下创建一个bin文件夹，会安装在/data/redis/bin目录下 第五步，验证是否安装成功：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d12283dd0ab07d63e8a654b78959758/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e99502844e78c880a0316c4655831fd/" rel="bookmark">
			对于视觉图像检测的认知，真的需要有所提高才行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCV数字图像处理学习平台获取——淘宝地址：
链接: OpenCV数字图像处理学习平台
OpenCV视觉应用31例获取——淘宝地址：
链接: OpenCV视觉应用31例获取地址
很久以前，专门介绍过关于图像的基础知识，包括什么是数字图像，什么是二值图、灰度图、彩色图、图像通道、图像的位数等。如果对这些概念不清楚的，可以在网上查一下，到处都可以找得到相关的资料。今天我不谈这个问题，我以为了解了这些图像处理基础，能够对视觉图像检测有比较清晰的认识，实际上并非如此。经常和一些不了解数字图像处理的人打交道，因此有一些感触，实际上是想让不了解视觉图像处理的人，明白图像处理并不是想象的那么简单。同时，也想给那些想学视觉图像处理的人一些建议。
在实施视觉图像检测项目的时候，经常会和企业里面很多不懂数字图像的人员打交道。有时候交流起来真的有些困难。比如有些人说，这个我眼睛都看得见，检测肯定没问题，有些人一上来就说我这个检测很简单，就是做个对比结果就出来了。遇到这样的情况，真的很无语。有一次遇到一个人给我说，他觉得中文识别可能有难度，但是字符和数字识别肯定简单，因为数字和字符就那么几个，直接匹配或者对比就出来了。还有一次，遇到做药企说明书检测的，要求检测印刷的说明书上面的文字是否有缺陷，说明书是在线实时打印装盒的。他认为直接模板匹配或者和标准的图像进行相减就可以得到结果。遇到这种情况，做视觉的人能怎么办？根本解释不通，人家觉得你的图像处理根本没什么技术含量，只有不解释了。还有一次遇到一个企业老总，需要做视觉测量，说别人都是用深度学习做的，问我用什么方法做，我说不用深度学习，人家觉得你技术不行，我也只能说我也可以用深度学习做。当然，实际怎么做的，也就不告诉他了，只说也是用深度学习实现的。这篇文章主要是让那些有视觉检测需求的人明白，图像处理并不是那么简单，对于完全没有数字图像基础，又想学习相关知识的人，也想让他们明白，应该学习哪些东西。
对于没有了解过数字图像处理的人来说，判断图像能否处理是靠直觉，靠自己的眼睛，觉得眼睛能看得见，就可以检测。然而实际情况并不是这样。您眼中看到的图像，对于搞图像的人来说，看到的图像是图1所示的样子，是一堆数字，是要从这一堆数字中找出您想要的东西。图1对应在您眼中的图像是什么样子的呢？其实是一个字符“D”，就是图2所示的样子。如果只看到图2，您肯定觉得把“D”提取出来很简单。但是，如果我给您的是图1所示的一堆数字，怎么从这一堆数字中把对应的数字提取出来了呢。这就是搞图像的人做的事情，您是否还是觉得很简单？
这还只是一个极其简单的例子。原图2448×2048，是500万像素，这里截图的只有61×51大小的图像，在这3000多个数字中提取出我们想要的数字。对于做图像处理的人来说，不是难事。但是，如果图像稍微复杂一点，就不是随随便便就可以实现的。
随着深度学习进入大众视野，人们觉得图像处理好像是万能的一样，觉得什么问题都可以用视觉图像来解决，其实远远不够。就以图3所示的药盒为例，上面的字符相对还比较少。如果要识别上面的字符，采用现有的技术基本上没有什么问题。但是，如果要检测上面的字符是否缺失某些笔画，就不是那么简单了，而这才是一些企业实际需要解决的问题。这只是拿这个药盒做一个例子，有很多产品需要检测的是字符缺陷，而不是识别字符，比如酒瓶上的字符缺陷检测等。识别和缺陷检测两种是不一样的，很多时候就算字符少了某些笔画，还是能够识别出来，但是识别结果无法判断是否有缺陷。不了解图像处理的人可能会说，拿一张没有缺陷的图像，和检测图像进行对比，做个减法不就可以了吗？事实上可行吗？也有人可能说用深度学习进行缺陷检测也可以啊。
针对上面说的检测方法，我来说一下有什么问题。首先，和标准图像做对比，进行相减的方法，需要保证两幅图像对应位置完全对齐，要有相同的基准点，而实时采集的图像，每张图像位置都会不一样，角度和大小都会有一点变化，所以是没法相减的，需要想办法将两者变换到相同的位姿，这就不是轻易可以做到的。可能有人会说用仿射变换和透视变换啊。这个问题我不想解释，不然又要写一大堆文字，感兴趣的可以亲自动手试一下，在线采集十几张图像就可以试出结果。对于第二种采用深度学习进行缺陷检测的方法，我想说的是，缺陷是什么样子的？会出现在哪些地方？如果这些无法明确，那怎么训练呢？如果对检测精度要求不高，那没什么可说的。当然，针对这种字符缺陷检测的问题，也是有办法解决的，我想表达的意思是，很多视觉检测不是某些人想的那么简单，做图像检测的人有很多艰辛的付出，别人只看到结果出来了，凭直觉认为检测很简单，实际上并非如此。不可否认，有些视觉检测很简单。但是，每种检测到底是简单还是复杂，只有通过专业的光源打光和专业的相机拍照，拿到图像进行分析才能够判断，而不是凭眼睛看，或者用手机拍几张图像来判断是否能检测。某些检测拿到检测对象凭经验可以判断是否可以检测，对于大部分检测而言，建议都要经过专业的图像采集进行分析来判断。
对于大部分视觉检测要求，都不是采用某种单一的图像图像处理算法可以实现的。比如下面这张图，找出圆心位置，这是一个网友发给我的。可能不少人一开始想到的就是霍夫变换。实际上恐怕不行，首先在时间上可能就无法满足要求，其次，检测准确率可能也会有影响。单一的霍夫变换很难满足这个检测要求。对于这个检测，有些人也会觉得很简单，当然，这个图本身也不难。但是，如果对图像处理函数不能熟练应用，估计也要弄半天看能不能出来结果。对于没有学过视觉图像检测的人，可能会提出不少不切实际的想法，觉得这样或者那样等等都可以实现检测。这个图是应该用几何方法绘制后打印出来的，但是拍成图像之后圆已经变成了椭圆，如果用找圆的方法去找圆心，实际上已经有问题了。图4是原图，图5是我检测出来的结果，有兴趣的也可以把这个图下载下来，然后试下怎么找圆心。
说实话，最近心里有点烦，所以很久都没有更新了。上面也是我想到哪就说到哪，没有什么章法。对于那些认为视觉检测很简单的人，如果您真的了解图像处理，就不应该有这种想法。您眼睛所看到的的图像以及您所认为的图像处理方法，与实际的图像处理方法，可能完全不同。如果您没有做过视觉图像处理，您所认为的简单的视觉检测，可能最后都没有办法实现，所以最好听一下有经验的人的判断。
对于那些想从事视觉图像处理的人而言，我想说的还是和原来一样，拿图像多练习，熟练掌握每种图像处理函数的用法，深度学习只是众多图像处理算法的一种，包括深度学习在内的各种传统图像处理算法，都需要熟练掌握，运用自如，才能够在这个行业里面走下去。各种传统的图像处理方法我已经集成在这个学习平台上了，有付出才有收获，以前学习的时候，也是自己买了好多书来照着学的。如果只是在网上查一些零散的资料来学习的话，是很难有收获的，反而会失去的是大量宝贵的时间。
OpenCV数字图像处理学习平台获取地址：
链接: OpenCV数字图像处理学习平台
OpenCV视觉应用31例获取地址：
链接: OpenCV视觉应用31例
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f749c2d797ec9d0aefbfccf2b9cb0716/" rel="bookmark">
			linux实现CP指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 实现CP指令只需要五步
1.打开Src文件（源文件）
2.读Src到Buf
3.打开Des文件（目标文件）
4.写Buf到Des
5.关闭Src和Des文件
代码如下：
#include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char **argv) { int fdSrc; int fdDes; char *readBuf=NULL; if(argc != 3){ printf("pararm error\n"); exit(-1); } fdSrc = open(argv[1],O_RDWR); int size = lseek(fdSrc,0,SEEK_END); lseek(fdSrc,0,SEEK_SET); readBuf=(char *)malloc(sizeof(char)*size + 8); int n_read = read(fdSrc, readBuf, size); //O_TRUNC 属性去打开文件时，如果这个文件中本来是有内容的，而且为只读或只写成功打开，则将其长度截短为0。 fdDes = open(argv[2],O_RDWR|O_CREAT|O_TRUNC,0600); //strlen（）计算字符串长度 int n_write = write(fdDes,readBuf,strlen(readBuf)); close(fdSrc); close(fdDes); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd53ef1f1aeaca947b61a01ff53b52d1/" rel="bookmark">
			神经网络学习入门（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		继上一篇：
关于感知机，既有好消息，也有坏消息。好消息是，即便对于复杂的函数，感知机也隐含着能够表示它的可能性。上一章已经介绍过，即便是计算机进行的复杂处理，感知机（理论上）也可以将其表示出来。坏消息是，设定权重的工作，即确定合适的、能符合预期的输入与输出的权重，现在还是由人工进行的。 神经网络的出现就是为了解决刚才的坏消息。具体地讲，神经网络的一个重要性质是它可以自动地从数据中学习到合适的权重参数。
从感知机到神经网络 神经网络和前面介绍的感知机有很多共同点。这里，我们主要以两者的差异为中心，来介绍神经网络的结构。 用图来表示神经网络的话，如图所示。我们把最左边的一列称为输入层，最右边的一列称为输出层，中间的一列称为中间层。中间层有时也称为隐藏层。“隐藏”一词的意思是，隐藏层的神经元（和输入层、输出层不同肉眼看不见）
我们再回顾一下上一篇讲的感知机
感知机的图像表达
感知机接收x1和x2两个输入信号，输出y
感知机的数学表达
b是被称为偏置的参数，用于控制神经元被激活的容易程度；而w1和w2 是表示各个信号的权重的参数，用于控制各个信号的重要性。
我们将上述数学表达式改写一下： y = h(b + w1x1 + w2x2) 此处
刚才登场的h（x）函数会将输入信号的总和转换为输出信号，这种函数一般称为激活函数（activation function）。如“激活”一词所示，激活函数的作用在于决定如何来激活输入信号的总和。
我们将上面的数学表达式按照下述过程从左至右再转化一下
到了最右边就是完整的神经网络啦！无论是RNN(循环神经网络)，LSTM（长短期记忆网络），GAN（对抗神经网络） ，他们的共同基础都是基础神经网络。因此牢记神经网络最最基本的结构和原理非常必要。
下面我们来了解一下上述公式中常用的的h（）
常用的激活函数 阶越函数 阶越函数的数学表达式：
阶越函数的图像
如图 3-6 所示，阶跃函数以 0 为界，输出从 0 切换为 1 （或者从 1 切换为 0 ）。 它的值呈阶梯式变化，所以称为阶跃函数。 sigmoid函数 sigmoid函数的数学表达式
sigmoid函数的函数图像
ReLU函数 ReLU函数的数学表达式
ReLU函数的数学表达式
在实际搭建神经网络的过程中我们可以根据实际需求（主要是根据任务类型-回归问还是分类）选择不同的激活函数。但是选择对于激活函数也不是全无要求
神经网络的激活函数必须使用非线性函数。换句话说，激活函数不能使用线性函数。为什么不能使用线性函数呢？因为使用线性函数的话，加深神经网络的层数就没有意义了。线性函数的问题在于，不管如何加深层数，总是存在与之等效的“无隐藏层的神经网络”。
神经网络需要掌握的工具 1. 编程语言 Python： Python是一个简单、易读、易记的编程语言，而且是开源的，可以免费地自由使用。Python可以用类似英语的语法编写程序，编译起来也不费力，因此我们可以很轻松地使用Python。在科学领域，特别是在机器学习、数据科学领域，Python也被大量使用。Python除了高性能之外，凭借着 NumPy、SciPy等优秀的数值计算、统计分析库，在数据科学领域占有不可动摇的地位。深度学习的框架中也有很多使用Python的场景，比如Caffe、TensorFlow、Chainer、Theano等著名的深度学习框架都提供了Python接口。
2. NumPy：一个用python实现的科学计算，包括：1、一个强大的N维数组对象Array；2、比较成熟的（广播）函数库；3、用于整合C/C++和Fortran代码的工具包；4、实用的线性代数、傅里叶变换和随机数生成函数。numpy和稀疏矩阵运算包scipy配合使用更加方便。numpy内置了并行运算功能，当系统有多个核心时，做某种计算时，numpy会自动做并行计算。Numpy底层使用C语言编写，数组中直接存储对象，而不是存储对象指针，所以其运算效率远高于纯Python代码。 3.Matplotlib: 是一个 Python 的 2D绘图库。方便我们观察学习效果。
4.pytorch： 主流的开源深度学习框架，可以通过简单的配置实现神经网络模型，相较于 tensorflow 有着易用，简洁，的优点。 为什么使用Numpy 下面我们对一个简化神经网络推理过程进行演示，神经网络图如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd53ef1f1aeaca947b61a01ff53b52d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29a148ca9f7ad2fc96069d9d4b6e4ae4/" rel="bookmark">
			新书推荐：《人机环境系统智能：超越人机融合》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目　录
前　言... 2
上篇　人机交互... 14
第一章　人机交互概述... 15
第一节　人机交互工程的形成和发展... 15
第二节　人机交互工程的研究方向... 21
第三节　人－机－环境关系发展变迁... 27
第四节　人机工程学研究的基本原则与研究方法... 30
本章参考文献... 36
第二章　人机交互中的情境认知... 38
第一节　人的感知... 39
第二节　人的认知... 51
第三节　人的决策... 74
第四节　机的决策... 77
第五节　情境认知的理论与思考... 80
第六节　推荐系统情境决策实验... 100
本章参考文献... 129
第三章　人机交互中的交互设计... 140
第一节　交互设计的经典理论与原则... 140
第二节　交互设计的常规流程与基本方法... 157
第三节　语言交互与非语言交互... 172
第四节　人机界面交互设计... 193
本章参考文献... 204
第四章　人机交互中的环境因素... 221
第一节　现实环境与虚拟环境.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29a148ca9f7ad2fc96069d9d4b6e4ae4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51bb10165b47cd32cbc7a0ad507eeeee/" rel="bookmark">
			c&#43;&#43;入门——变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		专栏简介：为什么我要重新介绍c++的相关知识，在此之前，我对于c++的了解也仅仅是在表面。而在后来与c++慢慢的接触中，c++编程语言越来越让我觉得深奥，所以还是想要重新开创一个专栏来介绍c++。对于c++的介绍，本专栏会先介绍98版的c++知识，之后会介绍11版的c++知识。
日常分享：每天努力一点，不为别的，只是为了日后，能够多一些选择，选择舒心的日子，选择自己喜欢的人！
目录
1.1、变量定义
1.1.1、初始值
1.1.2、列表初始化
1.1.3、默认初始化
1.2、变量声明和定义
1.3、标识符
1.4、名字的作用域
变量的概念，简单的说就是一个具有名称，可以供程序员操作的一个存储空间。由于c++是静态型编译语言，所以在定义变量时必须明确指明变量的数据类型，这样才能让程序在编译的时候分配合适的内存空间。
1.1、变量定义 变量的定义的基本格式是：首先是类型说明符，然后是变量名组成的列表，变量也可以赋初值，每个同类型的变量之间用逗号分开，结束时用分号隔开。
int i=-30; std::string name("Tom"); //name通过一个string字面值初始化 注意：
在c++中，存在对象和变量这两种说法，很多人分不清对象和变量的区别，对象是指的是一块能存放数据并具有某种类型的存储空间。单单从定义上来说，其实都是一个东西。只是有人习惯的把与类有关的称为对象，实际上都可以称为对象，如何称呼完全依据个人的爱好。就像方法和函数的区分。
1.1.1、初始值 当对象在创建时获得一个特定的值，我们称为这个对象被初始化了。对于变量的定义，从定义的那一刻开始，在作用域类都是起作用的。
double price=10.98,Alcount=price*3; //初始化格式正确，price从初始化开始就已经生效。 double sum=add(price,Alcount); //调用函数add，将函数计算的值的返回给变量，正确。 在这里要注意一下，对于用函数来进行初始化这个问题，在后面会讲到常量表达式，这里会有一点冲突，一定要分清两者之间的差别。在一个就是关于赋值和初始化这两者的差别，虽然说不会影响编写程序，但是可以作为一个知识了解。赋值是指的是把对象（变量）当前的值擦除用新的值来代替，而初始化指的是创建变量时赋予一个初始值，二者之间有本质的差别。
1.1.2、列表初始化 对于对象（变量）的初始化，c++提供了多种初始化的方式，关于这些初始化的方式，如果能全部掌握更好，至于喜欢哪种就看个人喜欢。
int untiled=0; int untiled={0}; int untiled{0}; int untiled(0); 在这几种初始化方式中，我比较推荐的是列表初始化（{}）。列表初始化虽然会有局限，但是却能帮助我们提高代码的合理性和准确性。
double first=3.1415926; int second{first},third={first}; 像上面这种情况，由于可能存在数据丢失的情况，所以使用列表初始化会导致报错，如果用其他的初始化方式，则不会出现问题：
double first=3.1415926; int second(first),third=first; 1.1.3、默认初始化 说到变量初始化，就必须谈到一个问题，那就是当你定义了一个变量而没有初始化的时候，当你去输出他的值的时候，会出现奇怪的数值,甚至会出现报错，这是由于c++中有一个默认初始化。在任何的函数体内，变量如果不人为的初始化，则变量不会被初始化，但是定义在任何函数体之外的变量被初始化为0。
注意：
虽然c++有默认初始化机制，但是还是建议变量进行初始化，这样才能保证程序的安全，也能养成好的编程习惯。
1.2、变量声明和定义 关于变量声明和定义这个问题，很多刚入门的小伙伴都不是很了解，因为大家写代码的时候都不会用到太多的文件，变量都是在cpp文件中定义，即使两个文件需要使用相同的变量值，很多人也只是重新定义一个变量。但是在c++中，有一个声明（extern）的功能。
c++中，声明和定义是区分开的，声明使得名字被程序所知，一个文件如果想使用别的文件中的变量，则必须包含对那个变量的声明。定义则是负责创建与名字关联的实体。
变量的声明规定了变量的类型和名字，但是没有声明存储空间，而定义则是为变量开辟了内存空间。
extern int i; //声明i而非定义i int i=100; //声明且定义i 在使用extern的时候要注意，不要给变量赋初始值，一旦初始化，就不再是声明，而是定义。所以，一旦声明某个变量，就不要给这个变量显示初始化，因为这样会导致extern失去作用。
注意：
变量只能被定义一次，但是可以被声明多次。
1.3、标识符 c++的表示符由字母，数字和下划线组成。数字不能作为开头，只有字母和下划线可以作为开头。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51bb10165b47cd32cbc7a0ad507eeeee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41870fdb886ef7972abc1e237b83b7a3/" rel="bookmark">
			【C&#43;&#43;】入门基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、命名空间1.1、命名空间的概念1.2、命名空间的定义1.3、命名空间的使用 2、初识cout和cin2.1、标准输入输出对象简介2.2、缓冲区2.3、cout2.4、cin 3、缺省参数3.1、全缺省参数3.2、半缺省参数3.3、注意事项 4、函数重载4.1、函数重载的概念4.2、函数重载的定义4.3、函数重载的原理 5、内联函数5.1、内联函数的概念5.2、内联函数的特性 6、引用6.1、引用的概念6.2、引用的定义6.3、引用的特性6.4、常引用6.5、使用场景6.6、值和引用的比较6.6.1、值和引用做参数类型的效率比较6.6.2、值和引用做返回值类型的性能比较 6.7、引用和指针的区别 1、命名空间 1.1、命名空间的概念 在C/C++中，变量、函数和类都是大量存在的，而这些变量、函数和类的名称大多数都存在于全局作用域中，这就很容易导致出现相同的名称。而命名空间的目的是对标识符的名称进行本地化，以避免命名冲突或名字污染，namespace关键字就可以很好的解决这一问题。
如下问题：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int scanf = 10; int main() { printf("%d\n", scanf); return 0; }// 编译后后报错：error C2365: “scanf”: 重定义；以前的定义是“函数 C语言没办法解决类似这样的命名冲突问题，所以C++就提出了用namespace来解决。
1.2、命名空间的定义 定义命名空间，需要使用到namespace关键字，后面在写上命名空间的名字，然后接一对{ }即可，{ }中即为命名空间的成员。
说明：
（1）命名空间里面可以定义变量，函数，类。模板，和其他命名空间，即可以出现在全局作用域中的声明就可以置在命名空间中！
（2）命名空间分割了全局作用域，每个命名空间都是不同的作用域，我们可以在命名空间里面定义我们需要的变量，函数，类，模板或其他命名空间。
如下：
namespace ikun { int a = 10;//定义变量 int add(int a,int b)//定义函数 { return a+b; } class cxk//定义类 { public: int test() { return 5; } private: int n; char ch; }; } 上面的 “ikun” 是命名空间的名字，命名空间里面我们定义了变量a、函数add，类cxk。当我们定义完命名空间后，就产生了一个新的作用域，即该作用域的名称为ikun，该作用域里有变量a、函数add、类cxk。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41870fdb886ef7972abc1e237b83b7a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d5b16334e5084e2c6048ee95fdc92cd/" rel="bookmark">
			nginx配置https
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装nginx 安装完成后检查
nginx -V 2.申请证书与上传 阿里云申请免费的证书 然后上传到某个目录
3.修改nginx配置 #user nobody; worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { listen 443 ssl; server_name xxx.cn; ssl_certificate /home/web/ssl/xxx.pem; ssl_certificate_key /home/web/ssl/xxx.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / { if ($host = xxx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d5b16334e5084e2c6048ee95fdc92cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fecef8674c940f7885541e668b4c0d53/" rel="bookmark">
			TEngine 配置表模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		6.配置表模块 - ConfigLoader 接入最佳游戏配置解决方案 - Luban 在TEngine中Luban工具集位于以下目录 TEngine内置默认使用懒加载配置，也支持基于UniTask的异步加载，同步加载，包括服务器的Task异步加载，使用对应转表的bat即可。
介绍 luban是你的最佳游戏配置解决方案。
luban高效地处理游戏开发中常见的excel、json、xml之类的数据，检查数据错误，生成c#等各种语言的代码，导出成bytes或json等多种格式。
luban统一了游戏配置开发工作流，极大提升了策划和程序的工作效率。
核心特性 强大的数据解析和转换能力 {excel(csv,xls,xlsx)、json、bson、xml、yaml、lua、unity ScriptableObject} =&gt; {binary、json、bson、xml、lua、yaml、erlang、 custom format} 增强的excel格式，可以简洁地配置出像简单列表、子结构、结构列表，以及任意复杂的深层次的嵌套结构。 完备的类型系统，支持OOP类型继承，搭配excel、json、lua、xml等格式数据灵活优雅表达行为树、技能、剧情、副本之类复杂GamePlay数据 支持生成c#、java、go、c++、lua、python、javascript、typescript、erlang、rust、gdscript 代码 支持生成 protobuf(schema + binary + json)、flatbuffers(schema + json)、msgpack(binary) 强大的数据校验能力。ref引用检查、path资源路径、range范围检查等等 完善的本地化支持。静态文本值本地化、动态文本值本地化、时间本地化、main-patch多地区版本 强大灵活的自定义能力，支持自定义代码模板和数据模板 通用型生成和缓存工具。也可以用于生成协议、数据库之类的代码，甚至可以用作对象缓存服务。
** 使用案例**
/// &lt;summary&gt; /// 道具配置表管理器。 /// &lt;/summary&gt; public class ItemConfigMgr: Singleton&lt;ItemConfigMgr&gt; { /// &lt;summary&gt; /// 道具Table。 /// &lt;/summary&gt; private TbItem TbItem =&gt; ConfigLoader.Instance.Tables.TbItem; /// &lt;summary&gt; /// 获取道具配置表。 /// &lt;/summary&gt; /// &lt;param name="itemId"&gt;道具Id。&lt;/param&gt; /// &lt;returns&gt;道具配置表。&lt;/returns&gt; public ItemConfig GetItemConfig(int itemId) { TbItem.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fecef8674c940f7885541e668b4c0d53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acf1c521e5f6587249c8212f41e75ed5/" rel="bookmark">
			c&#43;&#43;中的基本类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		专栏简介：为什么我要重新介绍c++的相关知识，在此之前，我对于c++的了解也仅仅是在表面。而在后来与c++慢慢的接触中，c++编程语言越来越让我觉得深奥，所以还是想要重新开创一个专栏来介绍c++。对于c++的介绍，本专栏会先介绍98版的c++知识，之后会介绍11版的c++知识。
日常分享：每天努力一点，不为别的，只是为了日后，能够多一些选择，选择舒心的日子，选择自己喜欢的人！
目录
一、基本内置类型
1.1、算术类型
1.1.1、带符号类型和无符号类型
1.2、类型转换
1.2.1、无符号类型表达式
1.3、字面值常量
1.3.1、整型和浮点型字面值
1.3.2、字符和字符串字面值
1.3.3、转义序列
1.3.4、指定字面值的类型
1.3.5、布尔字面值和指针字面值
一、基本内置类型 c++中的内置数据类型包括算术类型和空类型。其中算术类型包含了字符、整数、布尔和浮点数。
1.1、算术类型 算术类型分为两类，一类是整型，一类是浮点型。而无论是哪种类型。均有一个数值大小限制，而数据类型的大小是以字节来作为单位的。
算术类型 类型含义最小尺寸int整型16位（最低来两字节）bool布尔类型未定义char字符8位（1字节）wchar_t宽字符16位char16_tunicode字符16位char32_tunicode字符32位short短整型16位long长整型32位long long长整型64位float单精度浮点型6位有效数字double双精度浮点型10位有效数字long double扩展精度浮点型10位有效数字 上面说的位指的是比特位，8个比特位为一个字节8个字节为一个字（通常情况）。由于计算机是通过二进制来进行存储的，所以说，对于不同数值大小的数据也要用不同的数据类型来定义，具体的大小参考上表。
1.1.1、带符号类型和无符号类型 除了布尔型和扩展的字符型外，其他整型可以划分为有符号类型（signed）和无符号类型（unsigned）。有符号类型表示的是所有整数，包括负数，0，正数。而无符号类型则只能表示大于等于0的正数。
在数据类型的前面添加unsigned就可以表示无符号类型，而对于字符型char，也被分为三种，char、signed char、unsigned char。注意类型char和signed char是不一样的，虽然说有三种类型，但是一般只认为有符号和无符号两种类型，类型char至于具体是那一种，要看编译器。
特别注意一下，unsigned所定义的数据类型，他的所有比特位均用来放置数值，也就是高位不会存在用于判别正数还是负数的符号位。比如8比特的unsigned char可以存放0～255之间的值，而8比特位的signed char存放的是-128～127之间的数值。
对于编程过程中，在选用数据类型的时候要个根据具体的变量需求来进行选择。但是有一些经验准则是可以用的：
🕐、在确定是否要选择无符号类型时，先要确定数值是否不可能为负。
🕑、进行整数运算的时候，尽量使用int类型，如果不够长就是用long long。
🕒、在进行算术运算时，不要使用char类型，不同的编译器对char的定义不同，可能会出现在这个机器上能跑，另一个机器上就不能跑的情况。
🍀、在选择浮点类型时，建议选择double类型，float类型的精度太低，而且在目前这种情况下，float和double消耗的资源差距不是特别大，而long double则不推荐使用，消耗的资源太大。
1.2、类型转换 类型转换说白了就是将原本定义的对象的数据类型转化成其他数据类型。关于类型转换这个问题，很多人都会遇到类型转换失败导致资源浪费，甚至出现数据泄漏问题。所以说关于数据类型转换这个问题对于新手还是存在很大的问题。很多人看书，书上会说int可以转为double，但是有时候double又不能转为int，如果只是去背诵转换准则，则显得比较困难。所以对于类型和转换，我给出我的编程经验。
类型转换准则：
🕐、内存小的数据类型可以转化为大内存的数据类型，比如4字节的int类型可以转换成double类型。而对于高内存的数据类型转换成小内存的时候，必须要判断数值大小是否超过了转换后数据类型的大小。
类型转换过程：
🕐、当我们把非布尔型转化成布尔型时，如果初始值为0，则为false，否则为true。
🕑、把布尔值赋值给非布尔的时候，初始值为true则结果位1，否则为0.
🕒、浮点数赋值给整数的时候，结果仅保留浮点数中的整数部分，小数点后面的数值直接摒弃。
🕔、当我们赋值给无符号类型一个超出他表示的范围后，结果是初始值对无符号类型表示的数值总数取模后的余数。
🕕、当我们赋值给有符号类型一个超过他本身表示范围的值时，结果是未定义的。很有可能导致程序崩溃，这就和上面我讲的大范围转小范围时要注意数值。
1.2.1、无符号类型表达式 在讲解无符号类型表达式之前，我们先来看一段代码：
#include&lt;iostream&gt; int main() { unsigned u=10; int i=-30; std::cout&lt;&lt;i+i&lt;&lt;std::endl; std::cout&lt;&lt;i+u&lt;&lt;std::endl; return 0; } 最后运行结果是：
-60
4294967276
为什么是这个答案喃？这是由于，在无符号表达式中，会将有符号数值变为无符号数值， 负数转化成无符号数值时，就是将该数值加上无符号数的模。就比如上面的例子，int占据4个字节，也就是32位，那么无符号数最大是2的32次方，也就是4294967296,加上-30，就是转化后的无符号数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acf1c521e5f6587249c8212f41e75ed5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c6f1cf9d4b25cc4de20ff8c6bb04d6f/" rel="bookmark">
			Vcenter安装部署及主机资源添加
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装Vcenter Server 8.0 环境准备 ： 1.VCSA安装镜像（即Vcenter 安装介质） 3.已经安装完成的ESXI8.0虚拟化 3.Vcenter 安装环境（官网下载的镜像可支持MAC、Linux、Windows本次以windows举例） ，即镜像的运行环境，可使用Win7、win10 、win2016等等。。。 4.DNS解析，能够解析到在安装服务时创建的域名（可以在HOSTS文件内写，也可以加一个DNS服务，写两个正向和反向的解析），这步在第二部分安装时很重要，如果不能实现域名解析，需要在第一步完成后修改虚机的HOSTS文件，实现内部解析。 这里说一嘴这次的Vcenter大致的运行环境 1、先找一个安装镜像的运行环境（低版本的以往都是新建个windows server 机器，然后再机器里跑，8有些不同，这个运行环境只在安装时用！！！没有其余功能，就是给安装镜像提供运行环境的，等安装完成后就没什么用了），可以用自己windows，也可以特意下发一台windows机器，等Vcenter全部安装完成后就可以删除了，这机器就只是镜像的运行环境！！！
2、运行安装镜像内的执行文件，开始安装；
3、安装分两块，第一块是创建一个虚拟机，用作于Vcenter的运行和管理，后面访问和管理Vcenter都是在这个虚拟里的。第二块是等这个虚机创建完成后再找个虚机里部署Vcenter环境，当然这步不需要人为干预，自己就给干了
开始安装 1.找到镜像，打开方式选择windows资源管理器，然后打开我的计算机，就能看到镜像了 2.找到安装程序，双击运行即可，可参考文件路径 3.选择“install”开始安装 4.点击下一步 5.同意协议，点击下一步 6.这里填写你ESXI主机地址和密码，像安装步骤里说的，会在你ESXI里创建个虚拟机（其实这虚机也是一个ESXI），用于部署VCenter 这里有一个指纹校验，用于确认目的是否是你需要添加的主机（一般只要IP对就没问题） 7.这里填写虚机的主机名，和满足复杂度的密码，这里的密码是虚机底层的密码。 8.选择你数据中心的量级。根据自身情况写，一般小型环境就是第一个（10台主机+100台虚机） 9.这里选择创建虚机的存储位置，和硬盘模式，勾了下面的那个就是精简，表示硬盘大小根据实际空间占 10.填写网络配置，这里重点关注下所写的域名，IP、和DNS，因为在安装第二步的时候是靠域名去通讯的，其次到时候需要你先在DNS加这个域名的解析，保证能够正确的解析到域名IP。 确认下信息就可以安装了 点击下一步开始安装，大概需要半小时左右 在第一部分安装完成之后，点击完成之前，如果想要第二部分不依赖于或者使用域名进行解析，需要按一下两种方式做。 第一种 依赖于域名访问安装之前必须要确保能够正常解析到域名！！！！ 可在cmd里nslookup 域名，试下能不能解析出来 第二种，不依赖于域名：如果不能实现域名解析，需要修改刚创建出虚机的HOSTS文件，实现内部解析。（这里借鉴一下其他博主的内容） 第一步安装完成后的样子 11.这时候就可以浏览器访问ESXI，就可以看到新增了一个虚拟机了，主机名、IP、也都跟上面步骤写得内容对的上 13.第一步安装完成后自动会跳转到开始第二步（如果在第二步过程安装程序中断了或者不小心关了，可以https://xxxx:5480，就可安装第二步了，加上第七步那个密码即可访问） 14.这里第一列可以配置NTP，第二列是否需要开始SSH，这些看需求，也可安装后在页面里打开。 16.这块就是写你Vcenter的WEB页面登录用户密码了，创建一个OSS域，如果已有OSS的可以选下面那个选项，Vcenter的web页面用户名的组成是administrator+@OSS名字，例如我下面写得信息，登录时用户名应为administrator@ccdi.local 17.点击下一步 添加资源至Vcenter管理平台 Vcenter平台安装完成后使用IP或者域名访问 添加Vcenter许可 点击图片上方标黄列，点击“管理您的许可证”添加授权 许可证 “0Z20K-07JEH-08030-908EP-1CUK4” 分配许可 许可添加后，将此许可分配给Vcenter Server实例 选中添加的许可，点击确定 分配完成后可刷新页面，许可临期提示就消失了，同时，许可列表内就只有一个永久授权了。 创建数据中心，添加计算主机 点击创建好的数据中心，进入添加主机 点击主机和集群，点击操作，添加主机 这里的主机就是ESXI了，写入需要纳管的ESXI主机地址 对应ESXI的账户密码 这里会弹出安全警告，点击是 这可就可以读取到对应ESXI内的虚机了，点击下一页 这项为利用vLCM管理主机，但很快就会淘汰掉了，所以取消勾选，点击下一步 这块是给ESXI分配许可，（许可1 2 是我单独在vcenter里添加的ESXI的授权，不添加是没有的）当然，如果你的ESXI是已经激活过秘钥的也可以不写，这类貌似用于，批量分配ESXI授权，不用再去一个一个登录分配ESXI分配授权了。 这项就看个人需要了，有些公司处于安全考虑可以能直接选择严格模式，看需要 选择数据中心，这里就只有咱们刚创建的一个，然后，也可以创建多个 下一步然后点击确定，完成后就可以看到咱们新加的主机了，刚添加时需要稍等一会让Vcenter和ESXi进行状态协商，期间主机状态是下图，稍等30秒可以变为正常。 选择数据中心，这里就只有咱们刚创建的一个，然后，也可以创建多个 下一步然后点击确定，完成后就可以看到咱们新加的主机了，刚添加时需要稍等一会让Vcenter和ESXi进行状态协商，期间主机状态是下图，稍等30秒可以变为正常。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/28/">«</a>
	<span class="pagination__item pagination__item--current">29/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/30/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>