<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0051196078a56e84539101c881eccd62/" rel="bookmark">
			Here document使用方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可能很多人都熟悉cat &lt;&lt;EOF的写法和功能，但是对于这个被称为Here Document的可能还不是非常清楚，这篇文章稍微整理一下相关知识，并结合简单使用示例来进行说明。
什么是Here Document Here Document也被称为here-document/here-text/heredoc/hereis/here-string/here-script，在Linux/Unix中的shell中被广泛地应用，尤其在于用于传入多行分割参数给执行命令。除了shell（包含sh/csh/tcsh/ksh/bash/zsh等），这种方式的功能也影响和很多其他语言诸如Perl，PHP以及Ruby等。这篇文章以bash为例进行使用说明。
使用方式&amp;限制 使用格式如下所示： 命令 &lt;&lt; 分隔串（最为常见的为EOF）
字符串1
…
字符串n
分隔串
使用限制 分割串常见的为EOF，但不一定固定为EOF，可以使用开发者自行定义的，比如LIUMIAO缺省方式下第二个分割串（EOF）必须顶格写，前后均不可有空格或者tab缺省方式下第一个分割串（EOF）前后均可有空格或者tab，运行时会自动剔除，不会造成影响 使用示例 liumiaocn:~ liumiao$ cat &lt;&lt; LIUMIAO &gt; hello &gt; world &gt; LIUMIAO hello world liumiaocn:~ liumiao$ 使用场景示例：交互式命令行的多行输入转换为batch方式 这个场景的说明可能比较绕口，但是一旦涉及实际的使用例子就会非常清晰。
交互式的命令行：比如sftp或者oracle的sqlplus，或者mysql的命令控制台，以sftp为例子，当我们输入sftp 用户名@sftp服务器登录之后，需要在sftp&gt;的提示下进行各种sftp命令的操作。多行输入：在sftp登录之后，如果希望进行（确认当前目录=&gt;确认文件aa是否存在=&gt;下载aa文件）操作的话，这需要按顺序执行pwd=&gt;ls aa=&gt;get aa三条命令。转化为batch方式：很多时候上述的sftp命令可能是应用处理到某个时点被自动触发，这种人工逐行输入命令的方式不再适合。 上述实际操作示例如下：
liumiaocn:~ liumiao$ sftp root@host131 Connected to root@host131. sftp&gt; pwd Remote working directory: /root sftp&gt; ls aa anaconda-ks.cfg sftp&gt; get aa Fetching /root/aa to aa /root/aa 100% 9 0.7KB/s 00:00 sftp&gt; exit liumiaocn:~ liumiao$ cat aa aa infor liumiaocn:~ liumiao$ 可以看到，用户操作时需要输入密码，然后需要分别输入三条命令，如果希望一次执行完毕，可以使用如下Here Document方式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0051196078a56e84539101c881eccd62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a2bd3b32f1c68e4b8c2633acdc3f575/" rel="bookmark">
			C&#43;&#43;类中的特殊成员函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请注明文章出处：tlanyan.me/special-mem…
C++类中有几个特殊的非静态成员函数，当用户未定义这些函数时，编译器将给出默认实现。C++11前有四个特殊函数，C++11引入移动语义特性，增加了两个参数为右值的特殊函数。这六个函数分别是：
默认构造函数
默认构造函数指不需要参数就能初始化的构造函数。包含无参和所有参数有默认值两种类型的构造函数。
复制构造函数
复制构造函数指使用该类的对象作为参数的构造函数。可以有其他参数，但必须提供默认值。
复制赋值运算符
重载等号=，将该类的对象赋值给已定义对象。
析构函数
没啥可说的。
移动构造函数
C++11新增，该类的右值对象为参数的构造函数，其余同复制构造函数。
移动复制运算符
同复制赋值运算符，唯一不同是参数为右值。
看定义容易迷糊，上代码就会很清晰：
#include &lt;iostream&gt; #include &lt;string&gt; class Foo { public: std::string s; // 默认构造函数 Foo() { std::cout &lt;&lt; "default constructor" &lt;&lt; std::endl; } // 复制构造函数 Foo(const Foo&amp; foo) { std::cout &lt;&lt; "copy constructor" &lt;&lt; std::endl; s = foo.s; } // 复制赋值运算符 Foo&amp; operator=(const Foo&amp; foo) { std::cout &lt;&lt; "copy assignment operator" &lt;&lt; std::endl; s = foo.s; return * this;} // 移动构造函数 Foo(Foo&amp;&amp; foo) { std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a2bd3b32f1c68e4b8c2633acdc3f575/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6829ed78003312df9439f37acfe369ec/" rel="bookmark">
			如何将QQ音乐SQ品质FLAC格式转换成MP3音乐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信腾讯公司旗下的QQ音乐大家都应该用过吧，QQ音乐客户端中有很多实用的功能，比如：可以将音乐传到手机上，可以制作铃声，可以自定义皮肤，还可以将音乐保存到腾讯微云中。当然，QQ音乐还可以设置音效，以前有免费的DTS音效，现在只能使用Super Sound音效。
FLAC格式在音频格式中是无损的，所以占用内存就非常大，FLAC格式的歌曲比MP3格式的要大两到三倍，有些人的手机内存不多，肯定无法使用FLAC文件，所以只能将FLAC格式转换成MP3。那么，如何将QQ音乐SQ品质FLAC格式转换成MP3音乐呢？
第一步，首先在QQ音乐中下载SQ品质的音乐文件，搜索“许嵩”，选择第一个最新音乐《飞驰与你》点击下载按钮，然后单击SQ无损品质；
注意：下载SQ品质的音乐需要开通付费音乐包或者绿钻。
第二步，单击“立即体验”或者双击桌面上的快捷方式，运行迅捷视频转换器V2.0.0.1版本，打开后可以看到软件简洁明了，此软件可以转换所有格式的音视频格式；
第三步，打开软件后，添加FLAC格式的音频文件，单击软件左上角的“添加文件”或者点击软件中间的图标添加文件，然后选中FALC格式的音频拖拽到软件中；当然，如果转换的文件很多，可以一次性添加或者全部拖拽到软件中；
第四步，单击左下角“自定义”，然后将转换之后的音频保存到桌面上，点击文件夹，然后再单击“桌面”，再点击“选择文件夹”即可；软件默认保存到原文件夹的地方，如果音频保存到桌面则不用修改；
第五步，点击软件右上角“输出格式”中的“音频”，然后再选择“MP3”格式，MP3格式只有四个取样频率，不过单击后面的高级设置可以选择其他的音频参数，如：声道和比特率，还可以修改输出音频的名称；
​
第六步，在转换之前，如果觉得音频文件或者视频文件太长了，可以单击软件中的“分割视频”，虽然叫分割视频，但也可以针对音频文件剪切，单击“添加文件，然后再点击“剪辑”进入剪辑音频页面；
第七步，可以选择手动移动播放进度条或者自定义开始和结束的时间来设置剪辑的片段，（画面的宽度和高度也可以自行设置，不过修改后视频画面可能会模糊）；
第八步 ，最后就开始将FLAC格式的音频转为MP3了，直接点击开始转换，然后只需要等待进度条到达100%，FLAC转换MP3就完成了，在转换过程中，此软件会极消耗CPU，所以如果需要做其他的事情，可以单击暂停；
第九步，转换之前的FLAC文件的大小为50M，而转换之后的文件却只有4M，足足少了12倍不止，所以转换音频格式还是很有必要的。
以上就是使用视频转换器将QQ音乐SQ品质FLAC格式转换成MP3音乐的方法步骤了。迅捷视频转换器虽然可以分割合并视频文件，但终究不是专业的软件，可以使用迅捷视频合并分割软件。
文章来源https://www.xunjieshipin.com/...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e47dce48f03eb5679ad052ebfb56f95/" rel="bookmark">
			Java实现代码计时功能（Spring计时工具类--StopWatch学习总结）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用场景 计算某段程序的执行时间、计算每段线程所耗时间、计算方法调用的执行时间，等等。
传统方式 使用java代码实现计时功能
long startTime = System.currentTimeMillis(); // 需计算执行时间的代码段 long endTime = System.currentTimeMillis(); long totalTime = endTime -startTime; System.err.println("该段代码执行耗时：" + totalTime + " ms"); 缺点：定义过多处理时间，不好管理代码，显得冗余
使用Spring的工具类--StopWatch类 介绍 StopWatch类是Spring框架下的一个工具类，对应的包：
org.springframework.util.StopWatch 变量定义 private final String id; //记录当前task的ID private boolean keepTaskList; private final List&lt;StopWatch.TaskInfo&gt; taskList; private long startTimeMillis; //开始时间 private boolean running; //是否正在计时 private String currentTaskName; //当前任务名称 private StopWatch.TaskInfo lastTaskInfo; private int taskCount; private long totalTimeMillis; //所耗时间 主要方法 start(String taskName) //计时开始，taskName可选，不填则为"" stop() //计时结束 currentTaskName() //获取当前任务名称 getTotalTimeMillis() //获取总时间 shortSummary() //获取概要任务信息 prettyPrint() //获取详细信息 使用步骤 引入spring的依赖 &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e47dce48f03eb5679ad052ebfb56f95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3af3fe16212e3fd9e2290ffd15267c4/" rel="bookmark">
			C语言程序设计精髓（MOOC第7周 ）题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第7周练兵区编程题 NOTE: 尾递归：当递归调用是整个函数体中最后执行的语句且它的返回值不属于任何表达式的一部分（即在回归阶段不需要任何计算）时，这种递归调用就是尾递归。尾递归的精髓就是 通过参数传递结果，达到不压栈的目的。变量的作用域是指变量的作用范围，即在程序中可以被读写访问的区域，它取决于变量被定义的位置。形参也是局部变量，形参变量和实参变量的作用域是不同的，因此形参变量和实参变量同名时，二者互不干扰。只要同名的变量出现在不同的作用域内，二者互不干扰，编译器有能力区分不同作用域中的同名变量。变量的存储类型决定变量的生存周期—静态存储区中的变量生存期是整个程序，类似于学校的宿舍；动态存储区中的变量生存期是定义它的语句块，类似于外面的酒店宾馆。 extern int i; //声明，不是定义
int i; //声明，也是定义
经典递归算法题—汉诺塔问题 汉诺塔问题是指：一
块板上有三根针 A、B、C。A 针上套有 64 个大小不等的圆盘，按照大的在下、小的在上的顺序排列，要把这 64 个圆盘从 A 针移动到 C 针上，每次只能移动一个圆盘，移动过程可以借助 B 针。但在任何时候，任何针上的圆盘都必须保持大盘在下，小盘在上。从键盘输入需移动的圆盘个数，给出移动的过程。
算法思想： 对于汉诺塔问题，当只移动一个圆盘时，直接将圆盘从 A 针移动到 C 针。若移动的圆盘为 n(n&gt;1)，则分成几步走：把 (n-1) 个圆盘从 A 针移动到 B 针（借助 C 针）；A 针上的最后一个圆盘移动到 C 针；B 针上的 (n-1) 个圆盘移动到 C 针（借助 A 针）。每做一遍，移动的圆盘少一个，逐次递减，最后当 n 为 1 时，完成整个移动过程。
程序代码： #include&lt;stdio.h&gt; void move(char a,char b) //移动函数，从a移到b { static int k = 1; printf("%2d: %c ---&gt; %c\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3af3fe16212e3fd9e2290ffd15267c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/459dba8dadb1db0d4027445ba68c5265/" rel="bookmark">
			视频伪原创的常见方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：剪切：将原视频进行剪切；
2、混编：将剪切后的几段视频打乱顺序排列，原前现后，原来中间现在片头或结尾；
3、消音：消除原视频或者降低原视频音量；
4、配乐：重新添加背景音乐；
5、配音：添加配音解说或台词。
6、字幕：在片头、片尾、相关内容加上字幕，对配音加上字幕。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/135e0755f759f4245f4507492128ea66/" rel="bookmark">
			【C&#43;&#43;】类和对象（4）类的六个默认成员函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、类的六个默认成员函数 下面是一个Date类，但是它类中什么成员也没有，这就是空类。但是它虽然看起来什么都没有，实际上不是的，在我们什么都不写的情况下，它会自动生成六个默认的成员函数。如图所示的构造函数、析构函数、拷贝构造函数、赋值重载函数、普通对象取地址函数、const对象取地址函数这六个函数，就算我们自己不写，也会默认生成。
class Date {}; 二、构造函数 构造函数虽然名字是构造，但是其实它并不是构造了对象，而是完成了对象的初始化。我们以Date类为例：
class Date { public: void Print() { cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl; } void Init(int year, int month, int day) { _year = year; _month = month; _day = day; } private://封装起来不允许随便修改 int _year;//年 //用_区分成员变量和参数 int _month;//月 int _day;//日 }; int main() { Date d1; d1.Init(2018, 11, 11);//用Init函数初始化来间接修改值 d1.Print(); Date d2; d2.Init(2019, 2, 4); d2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/135e0755f759f4245f4507492128ea66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56e73cb7fdcc33c8715456ce4bec3d85/" rel="bookmark">
			如何调优sql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何定位并优化慢sql 根据慢日志定位慢查询sql 慢日志就是用来记录我们查询比较慢的sql
show variables like %quer%;
11：slow_query_log off 慢日志关闭
2：slow_query_log_file 文件记录慢日志
3：long_query_time sql执行多长时间会记录到慢日志文件中
show status like '%slow_queries%'
slow_queries：慢查询的数量 即有多少个sql执行的比较慢
打开慢查询：
set global slow_query_log = on;
设置慢查询的时间：
set global long_query_time = 1;（重新连接之后才能看到修改的状态）
(也可以通过配置文件来修改这些配置my.ini，修改配置是永久修改的)
使用explian等分析工具分析sql explain一般放在关键之的前面，用来描述mysql如何执行查询操作，以及mysql成功返回结果集需要执行的行数。explian可以帮助我们分析select语句，让我们知道查询效率低下的原因，从而改进我们的查询，让查询优化器更好的工作
id：标明sql的执行顺序，越大，越先执行
explian关键字段 type：mysql需要找到数据行的方式
性能是从最优到最差。index/all标明本次的查询走的是全表扫描
extra：辅助我们了解语句的执行方式
Using filesort ：没有使用表中的索引去排序，而是使用表外部的一个索引
修改sql，尽量让sql走索引 修改sql让查询的sql走索引
执行上面的sql并没有走主键索引（密集索引）。为什么不用id而是用account（索引）？
之所以走这个索引，是查询优化器做的决定，mysql查询优化器的最终目标是走索引，并且使用最严格的索引来消除尽可能多的数据行，最红是提交select查询数据行，而不是排除数据行，优化器试图排除数据行是原因排除数据行的速度越快，那么找到与条件匹配的数据行就越快，因袭查询优化器会根据它的分析和判断的标准决定走哪个索引。没有选择走主键索引大致原因：应该是因为密集索引的叶子结点把其他数据也存储到叶子节点当中，所以这里就变成他的一个缺点，这样查询的效率，因为我们的数据都放在一起，所以他是效率要比稀疏索引要低，因为稀疏索引存储关键字和以及主键的值，这样我们在内存里就能加载更多的关键字和主键的值，来进行count。我们也可以强制让sql查询走主键索引，如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afbaba5dd04491b73d25e07cbf043c18/" rel="bookmark">
			python安装报错error writing to file：......
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天换了win10 64电脑，安装python3.6.8时，报错：error writing to file：......
安装时，右键--以管理员身份运行，安装成功。
转载于:https://www.cnblogs.com/shuaishuaidefeizhu/p/10196882.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7f99d1392c466e1e16a2f44f59d7a96/" rel="bookmark">
			VS2012&#43;ArcGIS Engine10.2安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装ArcGIS Desktop
1、安装包里找到应用程序
2、双击setup安装 按照以下顺序安装
注意安装路径尽量按照以下方式设置，否则会出现安装失败的情况。
正确的安装路径：
以下是安装错误的路径方式，安装是按照上图路径安装，可以不在C盘
修改默认安装路径
整个安装过程比较慢 二、安装ArcGIS License Manager
这是破解软件的关键一步
1、从软件包中找到以下安装路径
2、破解
（1）开始中打开License Serve Administrator
（2）点击停止服务 （3）开始里面找到ArcGIS管理器，并打开ArcGIS管理器，选择Advance浮动版，注意此时先不要点击确定
再一次打开ArcGIS License Server Administrator,选择启动服务，并点击确定
回到ArcGIS管理器，更改许可管理器为localhost
（4）替换破解文件
找到破解包里的以下两个文件
打开serve.txt ，红色标出的部分修改为localhost 将以上两个文件替换到安装目录的bin文件里
（5）查看是否已经破解
运行License Manager，点击开始即可，如果为了确保成功，可以点击重新读取许可
4、安装ArcGIS Engine 10.2
（1）选择以下路径中的ESRI.exe 点击安装
三、安装ArcObjects SDKs
四、安装完之后，安装ArcGIS Engine
再一次打开ArcGIS管理器导向，选择ArcGIS Engine浮动版
五、VS2012来测试是否成功以及相关工具是否可用
1、新建一个windows 窗体应用程序
2、打开工具箱后ArcGIS的相关控件已将加载进来
3、选择一个ArcGIS控件拖到窗口中 只要选一个窗口成功拖到窗体中不报错，即可证明安装破解成功。
控件添加之后会出现一个错误
解决方法：
添加如下一句
即
ESRI.ArcGIS.RuntimeManager.Bind(ESRI.ArcGIS.ProductCode.EngineOrDesktop); 参考资料，资料中有安装包的下载地址：
https://www.cnblogs.com/lalaxiaoming/p/5608644.html
https://blog.csdn.net/SUNBOYmxbsH/article/details/79027639
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d46a34add115a0d508d70d79713c7d15/" rel="bookmark">
			树莓派设置开机启动vnc教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要总结设置树莓派开机自动启动vnc教程，具体内容如下所述。
1.1输入下面命令进入root模式
sudo su 1.2打开文件/etc/init.d/tightvncserver并且编辑，输入下面命令，结果如下图所示：
sudo nano /etc/init.d/tightvncserver #!/bin/sh ### BEGIN INIT INFO # Provides: tightvncserver # Required-Start: $syslog $remote_fs $network # Required-Stop: $syslog $remote_fs $network # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 # Short-Description: Starts VNC Server on system start. # Description: Starts tight VNC Server. Script written by James Swineson. ### END INIT INFO # /etc/init.d/tightvncserver VNCUSER='pi' case "$1" in start) su $VNCUSER -c '/usr/bin/tightvncserver :1' echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d46a34add115a0d508d70d79713c7d15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ec4e88452ef12515cae9b276ae89ad8/" rel="bookmark">
			PICT工具的安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、PICT简介
1、结对测试
结对测试(Pairwise Testing)这一概念是曼德尔在测试Aad编译程序时提出来的一种测试思想，它能在保证测试覆盖率的前提下控制测试用例的数量。官网 http://www.pairwise.org/ 对pairwise testing的解释是：
Pairwise (a.k.a. all-pairs) testing is an effective test case generation technique that is based on the observation that most faults are caused by interactions of at most two factors. Pairwise-generated test suites cover all combinations of two therefore are much smaller than exhaustive ones yet still very effective in finding defects.
生成pairwise testing测试用例的工具有很多，http://www.pairwise.org/tools.asp 有详细的介绍。
2、PICT工具简介
PICT全称Pairwise Independent Combinatorial Testing tool，是微软开发的一款结对测试用例生成工具，现在已经对外提供，可以在互联网上下载到。PICT 可以有效地按照两两测试的原理，进行测试用例设计。在使用PICT时，需要输入与测试用例相关的所有参数，以达到全面覆盖的效果。
二、PICT工具安装
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ec4e88452ef12515cae9b276ae89ad8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2144a8088a0fb6b63b4a831d237ead6/" rel="bookmark">
			什么叫MD5，MD5通常做什么用处
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里是修真院后端小课堂，每篇分享文从
【背景介绍】【知识剖析】【常见问题】【解决方案】【编码实战】【扩展思考】【更多讨论】【参考文献】
八个方面深度解析后端知识/技能，本篇分享的是：
【return的用法是什么？若在for循环中，还会执行下一次循环吗？】
【修真院java小课堂】什么叫MD5，MD5通常做什么用处，为什么MD5不可逆，用做密码加密的时候仍然可能会被解密？
大家好，我是IT修真院成都分院第13期的学员，一枚正直纯洁善良的java程序员，今天给大家分享一下，修真院官网java任务5，深度思考中的知识点——什么叫MD5，MD5通常做什么用处，为什么MD5不可逆，用做密码加密的时候仍然可能会被解密？
（1）背景介绍：
什么是MD5?
MD5消息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。MD5由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于1992年公开，用以取代MD4算法。
密码散列函数（Cryptographic hash function），又译为加密散列函数，是散列函数的一种。
MD4算法在安全上有大的漏洞，但它对在其后才被开发出来的好几种信息安全加密算法的出现却有着不可忽视的引导作用,比如MD5加密算法.
（2）知识剖析：
主要应用:
2.1一致性验证
MD5的典型应用是对一段信息（Message）产生信息摘要（Message-Digest），以防止被篡改。比如，在Unix下有很多软件在下载的时候都有一个文件名相同，文件扩展名为.md5的文件，在这个文件中通常只有一行文本，大致结构如：
MD5 (tanajiya.tar.gz) = 38b8c2c1093dd0fec383a9d9ac940515
MD5将整个文件当作一个大文本信息，通过其不可逆的字符串变换算法，产生了这个唯一的MD5信息摘要。
举例描述:
我们常常在某些软件下载站点的某软件信息中看到其MD5值，它的作用就在于我们可以在下载该软件后，对下载回来的文件用专门的软件（如Windows MD5 Check等）做一次MD5校验，以确保我们获得的文件与该站点提供的文件为同一文件。
具体来说文件的MD5值就像是这个文件的“数字指纹”。每个文件的MD5值是不同的，如果任何人对文件做了任何改动，其MD5值也就是对应的“数字指纹”就会发生变化。比如下载服务器针对一个文件预先提供一个MD5值，用户下载完该文件后，用我这个算法重新计算下载文件的MD5值，通过比较这两个值是否相同，就能判断下载的文件是否出错，或者说下载的文件是否被篡改了。
利用MD5算法来进行文件校验的方案被大量应用到软件下载站、论坛数据库、系统文件安全等方面。
2.2数字签名
MD5的典型应用是对一段Message(字节串)产生fingerprint(指纹），以防止被“篡改”。举个例子，你将一段话写在一个叫 readme.txt文件中，并对这个readme.txt产生一个MD5的值并记录在案，然后你可以传播这个文件给别人，别人如果修改了文件中的任何内容，你对这个文件重新计算MD5时就会发现（两个MD5值不相同）。如果再有一个第三方的认证机构，用MD5还可以防止文件作者的“抵赖”，这就是所谓的数字签名应用。
2.3安全访问认证
MD5还广泛用于操作系统的登陆认证上，如Unix、各类BSD系统登录密码、数字签名等诸多方面。如在Unix系统中用户的密码是以MD5（或其它类似的算法）经Hash运算后存储在文件系统中。当用户登录的时候，系统把用户输入的密码进行MD5 Hash运算，然后再去和保存在文件系统中的MD5值进行比较，进而确定输入的密码是否正确。通过这样的步骤，系统在并不知道用户密码的明码的情况下就可以确定用户登录系统的合法性。这可以避免用户的密码被具有系统管理员权限的用户知道。
2.4算法原理
对MD5算法简要的叙述可以为：MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值
（3）常见问题：
（4）解决方案：
（5）编码实战：
@Test
public void MD5Test(){
String password = "!ytd1129097428";
String md1 = MD5Util.MD5(password);
String md2 = MD5Util.generate(password);
System.out.println("加密前:"+password);
System.out.println("普通MD5加密后:"+md1);
System.out.println("加盐MD5加密后:"+md2);
System.out.println("比较原文和加盐MD5加密之后是否一致:"+MD5Util.verify(password,md2));
}
输出结果：
加密前:!ytd1129097428
普通MD5加密后:add4ff4fb01ace59713390dc5876d5d0
加盐MD5加密后:96b911880466d91d3244f37bd56c4531967c28d65181f191
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2144a8088a0fb6b63b4a831d237ead6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4c3af35621afece61afa8fe34d69206/" rel="bookmark">
			7-1 两个有序链表序列的合并 （20 分）-吉吉不是古古-CSDN博客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		7-1 两个有序链表序列的合并 （20 分） 注意：本文仅供学习交流使用
已知两个非降序链表序列S1与S2，设计函数构造出S1与S2合并后的新的非降序链表S3。
输入格式:
输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用−1表示序列的结尾（−1不属于这个序列）。数字用空格间隔。
输出格式:
在一行中输出合并后新的非降序链表，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出NULL。
输入样例:
1 3 5 -1 2 4 6 8 10 -1 输出样例:
1 2 3 4 5 6 8 10 提示：
尽量将操作步骤写入函数当中，便于调试找出错误，注意链表末尾Next赋值为NULL
头文件&lt;bits/stdc++.h&gt;可包含所有c++头文件，节省写头文件时间
#include&lt;bits/stdc++.h&gt; using namespace std; typedef struct LNode{ int Data; struct LNode* Next; }*LinkList; LinkList CreatList()//创建链表 { LinkList head=NULL,p,tail=NULL; p=new LNode; cin&gt;&gt;p-&gt;Data; while(p-&gt;Data!=-1) { if(!head) { head=p; p-&gt;Next=NULL; } if(tail) tail-&gt;Next=p;//使用尾插法创建链表 tail=p; tail-&gt;Next=NULL; p=new LNode; cin&gt;&gt;p-&gt;Data; } return head; } void Print(LinkList L) { if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4c3af35621afece61afa8fe34d69206/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cf7cd08391b674e6874b025ded9680e/" rel="bookmark">
			为什么说人机融合智能是强人工智能？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一
智能是什么？人具有智能的一部分，而不是全部。
智能是东西方文明一直共同关注的对象，孟子曰:“是非之心，智也”（《告子上》）；米塞斯说:区别A与非A即是知识，是非在西方可以用“to be or not to be”来替代，两者之间的活动——应该（should）即是智能。西方人偏哲学科学是为了反对迷信（神太多），中国人好历史伦理是以人为本（人不少），其实智能里这些成分都有。智能里包含了逻辑，同时也存在着大量的非逻辑成分，如直觉、非公理、模糊等因素。智能里不仅存在着逻辑/伦理悖论的对抗，而且还隐藏着逻辑/伦理悖论的妥协，本质上是用多元（一切）的可能性通过一元的现实性不失其意的表征，简言之，就是把万千的可能性用唯一的现实性表达出来，以简示繁，弥聚有度。
智能是相关无关化的应该存在，即把表面上无关（本质上存在着千丝万缕关系）的事物应该相关在一起去发现、分析、解决问题的能力。评价智能好坏的指标是处理问题的复杂程度。首要的关系不是智能和事物的关系，而是：智能就是事物的关系，智能把每一物拥入存在并保持在存在里，就此而言，智能本身即是关联，不考虑因果的关联。狭义的智能有时空性（如人工智能），要求在资源有限的情况下适应性地处理信息；广义的智能则没有时空性（如智慧），用无限的材质方法去达到目的——这种有无时空的跨界也是智能很难被定义的原因之一。
智能是关系主观的建构，智能同时也是对客观存在的反映，是一种主客观融合的产物。所谓对客观存在的描述实际上就是把人物（机）环境系统之间的交互关系梳理清楚、分析干净。仅以当前的数学模型确实很难，有不完备的成分在。从这个意义上说，大家对智能的突破期待，实际上是对崭新描述方法和手段的渴望。尽管主客观二元划分的方法虽然为人类提供了不少解释世界的便利，但同时也为改造世界设置了一定的障碍，如何打破之（比如除了主客体之外设立第三体角度），可能是未来的一个突破方向吧！
当前的智能本身就不是单独的科学或数学或哲学或人文能解决的一个学问。比如说数学，现在的数学可以比较好比较精确描述物理对象，但是比较难描述复杂过程，尤其是心理、社会、认知方面的过程，所以有人用这样一句话来形容数学的局限：“数学可以很好地解决问题的精确性，但不容易解决问题的方向性”。未来的智能本身也不是以后的某个学科单独能解决的一个学问。它本质是复杂性问题，需要多领域的不断地交叉融合。当然，通过一些学科的努力会取得一些进步，但这些进步也许会造成一些隐形的退步或阻碍，简而言之——进步的退步。
二
“强人工智能”一词最初是约翰·罗杰斯·希尔勒（John Rogers Searle）针对计算机和其它信息处理机器创造的，其定义为：
“强人工智能观点认为计算机不仅是用来研究人的思维的一种工具；相反，只要运行适当的程序，计算机本身就是有思维的。”（J Searle in Minds Brains and Programs. The Behavioral and Brain Sciences, vol. 3, 1980。但事实上，Searle本人根本不相信计算机能够像人一样思考，在这个论文中他不断想证明这一点。他在这里所提出的定义只是他认为的“强人工智能群体”是这么想的，并不是研究强人工智能的人们真正的想法。因此反驳他的人也不少。）
拥有“强人工智能”的机器不仅是一种工具，而且本身拥有思维。“强人工智能”有真正推理和解决问题的能力，这样的机器将被认为是有知觉，有自我意识。
强人工智能可以有两类：
类人的人工智能，即机器的思考和推理就像人的思维一样。
非类人的人工智能，即机器产生了和人完全不一样的知觉和意识，使用和人完全不一样的推理方式。
三
约翰·罗杰斯·希尔勒（John Rogers Searle，1932年7月31日出生于美国丹佛），哲学教授。
他主要研究语言的“目的性”。他不同意“强人工智能”的提法，认为感知出现于一个生物整个物理特性，人的意识是有目的性的，而电脑没有目的性，因此电脑没有意识。
他发现了一个目的现象的特性并称之为“适合方向”。比如某人看到一朵花，他的意识状态就适合了外部世界的状态。这个过程的适合方向是从意识向世界。但假如他伸手去采这朵花的话，那么他就要使的外部世界的状态适合他的意识状态。因此这时的适合方向是从世界向意识。他还提出了一个称为“背景”的技术概念。这个概念引起了一些哲学探讨。简而言之“背景”是一个目的性的行动的周围环境，其中包括行动者对世界的认识以及别人对他的目的的了解和认识。
他从理论上证明了一个社会环境中的集体目的性。提出五个论点：
1、集体目的性的活动是存在的，它与不是个人目的性活动的总和不是一回事。
2、集体目的不能被简化为个人目的。
3、上述两个论点有两个限制：
A、一个社会只是由其个人组成的，一个社会没有独立的团体意识或团体知觉；
B、个人或团体的目的性与个人信仰的真实性无关。
为了满足这些论点，他发明了一种描写集体目的性的方式来将集体目的性与个人目的性联系起来，而同时又将两者区分开来。其结果是个人目的性可以构成集体目的性。要构成一个集体目的性，一个人必须知道别人可以参加他的目的性，因此：
4、集体目的性的前提是对他人作为社会成员的一个背景了解：他人能够参加集体运动。
将这些论点集中在一起我们获得：
5、目的性理论加上上述的背景可以解释集体目的性。
他将他对目的性的分析运用到社会构造上。他的兴趣在于我们这个世界的一定方面是怎样成为利用这些方面人共同的目的性的。比如一张五元钱的纸币只是凭集体目的性才成为一张五元钱的纸币的[缺乏这个集体目的性，比如在另一个国家（地区）中，这张纸币仅是一张印有花纹的纸而已]。只有因为社会中所有的人都认为它值五元钱，它才能够完成它的贸易作用。这与政府是否支持它的价值无关（假如大家都不信任它的价值，那么即使政府强制，它依然不会获得它的价值，这是为什么会出现黑市价的原因）。这样的社会构造充斥着我们的生活。我们使用的语言、我们对我们私有财产的拥有以及我们与其他人之间的关系都根本地建立在这样的目的性上。
他对社会构造的研究成果与其他不认同有这样的与意识无关的事实的论点非常不同。他认为我们所称的真理是一种社会构造。
四
人机融合智能不是简单的人+机器，而是人*机器，简单地说就是充分利用人和机器的长处形成一种新的智能形式，是各种“有限理性”与“有限感性”相互叠加和往返激荡的结果。
人机融合智能就是由人、机、环境系统相互作用而产生的新型智能系统。之所以说它与人的智慧、人工智能不同，具体表现在三个方面: 首先是在智能输入端，它是把设备传感器客观采集的数据与人主观感知到的信息结合起来，形成一种新的输入方式；其次是在智能的数据／信息中间处理过程，机器数据计算与人的信息认知融合起来，构建起一种独特的理解途径；最后是在智能输出端，它把机器运算结果与人的价值决策相互匹配，形成概率化与规则化有机协调的优化判断。人机融合智能也是一种广义上的“群体”智能形式，这里的人不仅包括个人还包括众人，机不但包括机器装备还涉及机制机理，除此之外，还关联自然和社会环境、真实和虚拟环境等。着重解决上述人机融合过程中产生的智能问题。比如诸多形式的数据/信息表征、各种逻辑/非逻辑推理和混合性的自主优化决策等方面。
人机融合智能研究是智能技术发展到一定程度的产物，它既包括人工智能的技术研究，也包括机器与人、机器与环境及人、机、环境之间关系的探索。
人机融合需要界定角色和责任，以及制定人机协作的规则，这种功能分配的根源在于如何想办法把人类的需求、功能及策略转换成机器感知、能力和执行。即如何把人的感知/理解/预测/反馈与机器的输入/处理/输出/迭代有机地融合在一起。
五
在人类的历史长河中，古埃及的象形文字、古巴比伦的楔形文字、古印度河流域的印章文字和中国的甲骨文共同形成了世界四大古文字体系。唯有中国的甲骨文穿越时空，至今仍在使用并且充满活力。其根本原因在于西汉时期出现了隶书—这一表意性文字，自此，中文文字完成了由表形（图画）到表意的惊险一跳，成为世界上唯一一个连绵不断的文明！智能科学的核心和关键依旧是何时能够完成“得意忘形”这一惊险的一跳，目前科技进展的种种迹象表明：人的意向性+机的形式化是实现智能的最高形式——“得意忘形”可能性最大的方式。
人工智能领域的先驱、贝叶斯网络之父Judea Pearl 认为AI深陷于概率关联的泥潭，而忽视了因果。Pearl 认为研究者应该研究因果（Cause and Effect），这可能是实现真正智能的机器的可能路径。
目前人机融合智能系统的本质就是：“物是人非”。机器这个人造物可以处理一定程度的相关、关联关系，而人类自己则可以拟合出风俗、习惯关系甚至更厉害的因果关系。
Pearl在其新书《The book of why》中阐述机器不能只有把发烧和疟疾联系起来的能力，还要有推理「疟疾引起发烧」的能力。一旦这种因果框架到位，机器就有可能提出反事实的问题——询问在某种干预下因果关系将如何变化，允许机器进行概率思维，而人则是有目的的概率思维。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cf7cd08391b674e6874b025ded9680e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2fb6d2e072e944f2d4040dc85ceeba1/" rel="bookmark">
			C语言算符优先级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言优先级： 编辑
优先级
运算符
名称或含义
使用形式
结合方向
说明
1
[]
数组下标
数组名[整型表达式]
左到右
()
圆括号
（表达式）/函数名(形参表)
.
成员选择（对象）
对象.成员名
-&gt;
成员选择（指针）
对象指针-&gt;成员名
2
-
负号运算符
-算术类型表达式
右到左
单目运算符
(type)
强制类型转换
(纯量数据类型)纯量表达式
++
自增运算符
++纯量类型可修改左值表达式
单目运算符
--
自减运算符
--纯量类型可修改左值表达式
单目运算符
*
取值运算符
*指针类型表达式
单目运算符
&amp;
取地址运算符
&amp;表达式
单目运算符
!
逻辑非运算符
!纯量类型表达式
单目运算符
~
按位取反运算符
~整型表达式
单目运算符
sizeof
长度运算符
sizeof 表达式
sizeof(类型)
3 /
除
表达式/表达式
左到右 双目运算符
*
乘
表达式*表达式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2fb6d2e072e944f2d4040dc85ceeba1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb5ffca53300e00da30295396b2c49ae/" rel="bookmark">
			GTest之TEST_F
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义一个测试用例：
class TestCase：public ::testing::Test { ........ }; TEST_F(TestCase, proc_name) { ........ } 实际TEST_F宏定义展开如下：
class test_case_name_test_name_Test : public test_case_name { public: test_case_name_test_name_Test(test_case_name, test_name) { } private: virtual void TestBody(); static ::testing::TestInfo* const test_info_ __attribute__((unused)); test_case_name_test_name_Test(const test_case_name_test_name_Test&amp;) delete; void operator=(test_case_name_test_name_Test const&amp;) delete; }; ::testing::TestInfo* const test_case_name_test_name_Test::test_info_ = ::testing::internal::MakeAndRegisterTestInfo( ::testing::internal::MakeAndRegisterTestInfo(test_case_name, test_name, nullptr, nullptr, ::testing::internal::CodeLocation(__FILE__, __LINE__), bool, test_case_name::SetUpTestCase, test_case_name, TearDownTestCase, new ::testing::internal::TestFactoryImpl&lt;test_case_name_test_name_Test&gt;); void test_case_name_test_name_Test::TestBody() { } 说明：
1、test_case_name：TestCase、test_name：proc_name
2、TEST_F实际定义了一个TestCase的之类，在执行单测时，调用虚函数 virtual void TestBody();
实际的宏定义代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb5ffca53300e00da30295396b2c49ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/411ea7ff5dcea5b9851dcf01adffbd90/" rel="bookmark">
			RAID 0, RAID 1, RAID 5, RAID 10图解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 什么是RAID
RAID全称是独立磁盘冗余阵列（Redundant Array of Independent Disks），基本思想是把多个磁盘组合起来，组合一个磁盘阵列组，使得性能大幅提高。
最初是为了组合小的廉价磁盘来代替大的昂贵磁盘，同时希望磁盘失效时不会使对数据的访问受损 失而开发出一定水平的数据保护技术。RAID就是一种由多块廉价磁盘构成的冗余阵列，在操作系统下是作为一个独立的大型存储设备出现。RAID可以充分发 挥出多块硬盘的优势，可以提升硬盘速度，增大容量，提供容错功能够确保数据安全性，易于管理的优点，在任何一块硬盘出现问题的情况下都可以继续工作，不会 受到损坏硬盘的影响。
最常用的四种RAID为 RAID 0、RAID 1、RAID 5、RAID 10，下面以图解的方式解释RAID的特点和区别。
2 RAID的实现方式
外接式磁盘阵列：通过扩展卡提供适配能力内接式RAID：主板集成RAID控制器安装OS前在BIOS里配置软件RAID：通过OS实现
3 标准的RAID
3.1 RAID0
RAID0称为条带化存储，将数据分段存储在各个磁盘中，读写均可以并行处理，因此读写速率为单个磁盘的N倍，没有冗余功能，任何一个磁盘的损坏就会导致的数据不可用。
RAID 0的特点：
最少需要两块磁盘数据条带式分布没有冗余，性能最佳(不存储镜像、校验信息)不能应用于对数据安全性要求高的场合 3.2 RAID1
RADI1是镜像存储，没有数据校验，数据被同等的写入到2个或者多个磁盘中，写入速度相对慢， 但是读取速度比较快。
以下为RAID 1的特点：
最少需要2块磁盘提供数据块冗余性能好 3.3 RAID 4
RADI4在RAID1的基础上，N个盘用于数据存储，另外加入了1个磁盘作为校验盘。一共N+1个盘，任何一个盘坏掉也不影响数据的访问
3.4 RAID 5
RAID5在RAID4的基础上，由原来的一个盘来存储校验数据，改为每个盘都有数据和校验信息的。
RAID 5特点：
最少3块磁盘数据条带形式分布以奇偶校验作冗余适合多读少写的情景，是性能与数据冗余最佳的折中方案 4 混合RAID
4.1 RAID01
先组成RAID0,然后组成RAID1.
4.2 RAID10
先组成RAID1,然后组成RAID0
RAID 10(又叫RAID 1+0)特点：
最少需要4块磁盘先按RAID 0分成两组，再分别对两组按RAID 1方式镜像兼顾冗余(提供镜像存储)和性能(数据条带形分布)在实际应用中较为常用 总体区别：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aefb9a16f9299928e03e4445980cd4a/" rel="bookmark">
			WPF下多线程的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、WPF的线程
对于初学wpf的人来说，一般会把所有的程序都在一个线程中运行，当数据量较大，需要频繁刷新界面时，界面会出现卡顿的情况。
1、当我们打开一个WPF应用程序即开启了一个进程，该进程中都会加载两个重要的线程：一个用于呈现用户界面，另一个用于管理用户界面。呈现线程是一个在后台运行的隐藏线程，因此您通常面对的唯一线程 就是 UI线程。WPF 要求将其大多数对象与 UI 线程进行关联,这称之为线程关联，意味着要使用一个 WPF 对象，只能在创建它的线程上使用,在其他线程上使用它会导致引发运行时异常。
一个线程用于处理呈现：隐藏在后台运行一个线程用于管理用户界面：接收输入、处理事件、绘制屏幕以及运行应用程序代码,即UI线程。不管是WinForm应用程序还是WPF应用程序，实际上都是一个进程，一个进程可以包含多个线程，其中有一个是主线程，其余的是子线程。 2、在 WPF 中绝大部分控件都继承自 DispatcherObject，甚至包括 Application。这些继承自 DispatcherObject 的对象具有线程关联特征，也就意味着只有创建这些对象实例，且包含了 Dispatcher 的线程(通常指默认 UI 线程)才能直接对其进行更新操作。
在 WPF 中，DispatcherObject 只能通过与它关联的 Dispatcher 进行访问。 例如，后台线程不能更新由 UI 线程创建的 Label的内容。
二、 Dispatcher类
1、在UI线程中有一个Dispatcher对象，管理每一个需要执行的工作项。Dispatcher会根据每个工作项的优先级排队。向Dispatcher列队中添加工作项时可指定10个不同的级别。那么问题来了，如果遇到耗时操作的时候，该操作如果依旧发生在UI线程中，Dispatcher 列队中其他的需要执行的工作项都要等待，从而造成界面假死的现象。为了加快响应速度，提高用户体验，我们应该尽量保证Dispatcher 列队中工作项要小。所以，对于耗时操作，我们应该开辟一个新的子线程去处理，在操作完成后，通过向UI线程的Dispatcher列队注册工作项，来通知UI线程更新结果。
Dispatcher类详细介绍
2、Dispatcher提供两个注册工作项的方法：Invoke 和 BeginInvoke。
这两个方法均调度一个委托来执行。Invoke 是同步调用，也就是说，直到 UI 线程实际执行完该委托它才返回。BeginInvoke是异步的，将立即返回。
Dispatcher实际上并不是多线程子线程不能直接修改UI线程，必须通过向UI线程中的Dispatcher注册工作项来完成Dispatcher 是单例模式，暴露了一个静态的CurrentDispatcher方法用于获得当前线程的Dispatcher每一个UI线程都至少有一个Dispatcher，一个Dispatcher只能在一个线程中执行工作。 3、UI线程中创建的对象，如何在非UI线程中更新
参考：https://www.cnblogs.com/chillsrc/p/4482691.html
（1）前台，创建对象
&lt;Window x:Class="WpfApp1.WindowThd" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" Title="WindowThd" Height="300" Width="400"&gt; &lt;Grid&gt; &lt;StackPanel&gt; &lt;Label x:Name="lblHello"&gt;欢迎你光临WPF的世界!&lt;/Label&gt; &lt;Button Name="btnThd" Click="btnThd_Click" &gt;多线程同步调用&lt;/Button&gt; &lt;Button Name="btnAppBeginInvoke" Click="btnAppBeginInvoke_Click" &gt;BeginInvoke 异步调用&lt;/Button&gt; &lt;/StackPanel&gt; &lt;/Grid&gt; &lt;/Window&gt; （2）后台创建非UI线程，若直接更新UI线程的对象就会报错
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2aefb9a16f9299928e03e4445980cd4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0d3e5a1232ec71a0fd5e3cd11bdf3d6/" rel="bookmark">
			Android WebView嵌套H5下载失效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WebView中嵌套h5进行下载失效 项目混合开发app，页面中有个下载。一直失效的。经过查询发要设置下载监听。代码如下：
/** * 当下载文件时打开系统自带的浏览器进行下载，当然也可以对捕获到的 url 进行处理在应用内下载。 **/ private class FileDownLoadListener implements DownloadListener { @Override public void onDownloadStart(String url, String userAgent, String contentDisposition, String mimetype, long contentLength) { Uri uri = Uri.parse(url); Intent intent = new Intent(Intent.ACTION_VIEW, uri); startActivity(intent); } } 设置监听器
//下载监听 webView=(WebView)findViewById(R.id.web_view); webView.setDownloadListener(new FileDownLoadListener()); 新人小白，记录总结。轻喷。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/110/">«</a>
	<span class="pagination__item pagination__item--current">111/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/112/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>