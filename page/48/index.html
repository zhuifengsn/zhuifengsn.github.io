<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/709d6f5aed5289a1779ac36cce22ed1a/" rel="bookmark">
			sql语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sql语句（sqlserver——数据库—右键—新建查询） sql语言作为一种大小写不敏感的语言，对大小写的并没有严格的区分，即：“Hello”和“hello”在sql语言的眼里是一样的，即使你写的是大写字母，它也会当做对应的小写字母来处理，并不会报错。而且细心的同学会发现，如果存储时存入的为大写字母（列名、表名等，不包括表中的字符型数据），再查询时查到的都是小写字母了。表中的数据会正常存储（下面代码中'值'的部分），原理是：存储数据时会将数据根据数据类型变成二进制数存储，读取时同理，而字母大小写对应的数是不同的。表名、列名允许设为中文，但不建议！本文中注释部分表示非必须部分（不写也能正常运行） 一、表中数据的增删改查 1.增 （1）格式1
insert into 表名/*(列名,列名,……)*/ values('值','值',……) 表示将批量的值插入对应的列中。若不刻意写（列名，列名，……）则默认表示表中所有列 （2）格式2
insert into 表名 set 列名='值',列名='值',…… 表示将对应的值填入对应的列中，作用同上优势在于表述更清晰，更容易阅读 （3）格式3
insert into 表名1 select * from 表名2 表示获取表2的数据，插入到表1中。要求两表对应列的数据类型一致 2.删 delete from 表名/* where ……*/ 若语句为“delete from 表名”，则表示清空表中内容
※where语法 多条件查询
select 列名，列名，…… from 表名 where 列名='值'/* and/or 列名='值'*/ 模糊查找 select 列名，列名，…… from 表名 where 列名 like '_csdn%' “_”代表一个字符，“%”代表0到n个字符
3.改 update 表名 set 列名='值',列名='值',……/* where ……*/ 4.查 select 列名 from 表名/* where ……*/ （1）求和 select sum(列名) /*as 临时列名 */from 表名/* where ……*/ 表示求得某一列的值的和，显示为“临时列名”的值 临时列名1查询到的值 若不设置临时列名，则默认显示为“（无列名）” （无列名）1查询到的值 （2）平均值 select avg(列名) /*as 临时列名 */from 表名/* where ……*/ （3）最大 select max(列名) /*as 临时列名 */from 表名/* where ……*/ （4）最小 select min(列名) /*as 临时列名 */from 表名/* where ……*/ （5）计数 select 性别,count(性别) as 人数 from 表名 group by 性别 会得到：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/709d6f5aed5289a1779ac36cce22ed1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d8fecd98414e24aa7a5d91b2229ec07/" rel="bookmark">
			SpringBoot2.7.4集成Flowable6.7.2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.4&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.bool&lt;/groupId&gt; &lt;artifactId&gt;workflow&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;workflow&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;mysql-connector-java.version&gt;8.0.30&lt;/mysql-connector-java.version&gt; &lt;flowable.version&gt;6.7.2&lt;/flowable.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.flowable&lt;/groupId&gt; &lt;artifactId&gt;flowable-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;${flowable.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加flowable-ui-modeler核心依赖项--&gt; &lt;dependency&gt; &lt;groupId&gt;org.flowable&lt;/groupId&gt; &lt;artifactId&gt;flowable-ui-modeler-rest&lt;/artifactId&gt; &lt;version&gt;${flowable.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--添加flowable-ui-modeler配置依赖项--&gt; &lt;dependency&gt; &lt;groupId&gt;org.flowable&lt;/groupId&gt; &lt;artifactId&gt;flowable-ui-modeler-conf&lt;/artifactId&gt; &lt;version&gt;${flowable.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加flowable-ui依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.flowable&lt;/groupId&gt; &lt;artifactId&gt;flowable-spring-boot-starter-ui-modeler&lt;/artifactId&gt; &lt;version&gt;${flowable.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d8fecd98414e24aa7a5d91b2229ec07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58a6ce85811d74a975ab10b43505e724/" rel="bookmark">
			计算机网络 | 湖科大教书匠
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、因特网概述 1、网络、互联网和因特网 网络是由若干结点和连接这些结点的链路组成
多个网络还可以通过路由器互联起来，这样就构成了一个覆盖范围更大的网络，互联网
因此，互联网是网络的网络（Network of Networks）
因特网是世界上最大的互联网络（用户数以亿计，互联的网络数以百万计）
2、因特网发展三个阶段 因特网服务提供者ISP（Internet Service Provider）
3、因特网的标准化工作 4、因特网的组成 边缘部分：由所有连接在因特网上的主机组成。这部分是用户直接使用的，用来进行通信(传送数据、音频或视频)和资源共享
核心部分：由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的(提供连通性和交换)。
二、三种交换方式 1、电路交换 2、分组交换（重点） 在发送报文之前，会先把较长的报文分为较小的数据段，在每个数据段前加上一些必要的控制信息组成的首部后，就构成分组，简称包。分组交换机收到分组后就会根据句首部的信息进行转发，最终发到目标主机，主机收到后去掉首部，组合各个数据还原原始报文。
3、报文交换 早期使用，现在已经被分组交换替代，不介绍
4、三者对比 三、网络的定义和分类 1、定义 计算机网络定义：一些互连的、自治的计算机集合
互联：计算机之间可以通过有线或无限的方式进行数据通信自治：指独立的计算机，他有自己的硬件和软件，可以单独运行集合：至少需要两台计算机 上图中没有独立的软硬件，只是单纯输入输出设备，所以构成的不属于计算机网络
比较好的定义：计算机网络主要是一些通用的、可编程的硬件互连而成，而这些硬件并非专门用来实现某一特定目的。这些可编程的硬件能够用来传输多种不同类型的数据，并能支持广泛和日益增长的应用。
2、分类 四、网络的性能指标 1、速率 2、带宽 3、吞吐量 4、时延 发送时延和传播时延都可能占主导，要具体分析
5、时延带宽积 6、往返时间RTT 7、利用率 8、丢包率 四、计算机网络体系结构 1、常见的网络体系结构 2、分层的必要性 计算机网络是个非常复杂的系统，分层可以将庞大而复杂的问题，转化为若干个较小的局部问题，这些较小的局部问题就比较易于研究和处理。
如何分？
3、网络体系结构分层思想举例 4、专用术语 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d23b203ae2c34cafa627748668267653/" rel="bookmark">
			Pycharm中解决安装包失败问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Pycharm中安装第三方库失败的时候，会出现红色的安装失败，以下有两种解决的方法！
一、在官网上下载对应的安装包 1、在https：//pypi.org 搜索对应的安装包 2、再点击navigation下的download files,选择对应的下载安装 Ps:下载好的文件后缀如果是Whl，要改成zip后解压
3、将解压后的文件复制粘贴到Libs下的scripts文件夹下（看自己是具体在什么路径） 二、添加国内镜像源 1、点击左下角的python packages 2、再点击设置按钮 3、在插件库url搜索框中输入镜像源的网址 ps:常用的国内镜像源有
清华大学：https://pypi.tuna.tsinghua.edu.cn/simple/
中国科学技术大学：http://pypi.mirrors.Ustinov.edu.cn/simple/
华中科技大学：http://pypi.hustunique.com/
阿里云：http://mirrors.aliyun.com/pypi/simple/
豆瓣：https://pypi.douban.com/simple/
4、点击确定即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/099bdf200b9179a2f772c2c0b56f911f/" rel="bookmark">
			王道第二章链表相关oj题及之后的练习(详解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.设计一个递归算法，删除不带头结点的单链表L中所有值为X的结点
ListNode* Del_x(ListNode* L,int x) { if(L == NULL) { return NULL; } ListNode* res = Del_x(L-&gt;next,x); //如果该头指针的值为x,那么将下一层返回过来的节点返回给本层的上一层 if(L-&gt;val == x) { return res; } else//如果值不为x，则将上一层的节点，链接到本层，然后将本层的节点返回给上一层 { L-&gt;next = res; return L; } } 递归展开图:
相关题目:
力扣https://leetcode.cn/problems/remove-linked-list-elements/2.在带头结点的单链表中,删除所有值为x的结点,并释放其空间,假设值为x的结点不唯一,试编写算法以实现上述操作
思路:
设置三个指针,cur用来指向当前结点,prev用来指向cur的前一个结点,next用来指向cur的后一个结点，当cur == NULL时,链表删除完成
void Del_x2(ListNode* L,int x) { if(L-&gt;next == NULL) { return L; } ListNode* prev = L; ListNode* cur = L-&gt;next; while(cur) { next = cur-&gt;next; if(cur-&gt;val == x) { perv-&gt;next = next; free(cur); } else { prev = cur; } cur = next; } } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/099bdf200b9179a2f772c2c0b56f911f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48f37f59dff1d5aeed933d72c1cf9da0/" rel="bookmark">
			C语言基础--操作符详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、操作符1. 算数操作符2. 移位操作符（1）右移操作符举例补充 （2）左移操作符举例分析 （3）警告 3.位操作符（1）按位与（2）按位或（3）按位异或（4）案例案例一案例二1）错误示范2）方法13）方法2 4.赋值操作符（1）赋值操作符（2）复合赋值符 5.单目操作符（1）逻辑反操作（2）正值与负值（3）取地址和解引用（4）sizeof（5）按位取反（6）++和--（7）强制类型转换（8）小案例 6.关系操作符7.逻辑操作符8.条件操作符9.逗号表达式10.下标引用、函数调用和结构成员（1）下标引用操作符（2）函数调用操作符（3）访问一个结构的成员 二、表达式求值1.隐式类型转换（1）案例一（2）案例二（3）案例三 2.算术转换 三、操作符的属性1.操作符优先级2.有问题的表达式 一、操作符 1. 算数操作符 + - * / %
1. 除了%操作符之外，其他的几个操作符可以作用于整数和浮点数。
2. 对于/操作符，如果两个操作数都为整数，执行整数除法。而只要有浮点数执行的就是浮点数除法。
3. %操作符的两个操作数必须为整数。返回的是整数之后的余数。
若除数与被除数都是整数，结果也是整数。
若除数与被除数有一个是浮点数，得到的就是小数。
%操作符两侧有一个不是整数时
2. 移位操作符 &gt;&gt;右移操作符 --&gt;移动的是二进制位
&lt;&lt;左移操作符
（1）右移操作符 举例 看一个例子：（正整数）
int a = 16; int b = a &gt;&gt; 1; printf("%d\n",b); 结果如何呢？
我们先来分析一下（内存中以补码存储）：
看一下运行结果：
补充 正数无论是算术右移还是逻辑右移，左侧补得都是0，我们用负数来测试一下电脑是算术右移还是逻辑右移：
可以看到，结果是-1，即：使用的是算术移位。
🍰知识补充
整数的二进制表示有：原码、反码、补码。
存储到内存中的是补码。
（1）正数的原码、反码、补码都是一样的，没有差别。
（2）来看一下负数：（以-1为例）
最高位是符号位，正数为0，负数为1。
那么就可以写出-1的原码：（int类型4个字节，1个字节8个bit，那么int类型就是32bit）
1000 0000 0000 0000 0000 0001
反码就是原码的符号位（最高位）不变，其余取反（1变0，0变1）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48f37f59dff1d5aeed933d72c1cf9da0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f851ffc8462a6602ad1cb97a13e4582d/" rel="bookmark">
			try/catch捕获不到的异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		try/catch捕获不到的异常 捕获不到的异常这种情况finally块会执行吗？spring中的@Transactional事务还会会滚吗？该如何捕获这种异常？ Throwable可以看做是异常世界中的Object，在Java中所有异常都有一个共同的祖先：Throwable，
Throwable有两个重要的子类：Error错误和Exception异常，二者都是异常处理重点类。
我们看一下普通的try/catch，
package com.example.duohoob.test; public class ExceptionTest { public static void main(String[] args) { try { System.out.println(1/0); } catch (Exception e) { // TODO Auto-generated catch block // e.printStackTrace(); System.out.println("捕获异常，" + e.getMessage()); } } } 接下来这种情况可能会有点特殊，
捕获不到的异常 package com.example.duohoob.test; public class ExceptionTest { public static void main(String[] args) { try { throw new UnknownError(); } catch (Exception e) { // TODO Auto-generated catch block // e.printStackTrace(); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f851ffc8462a6602ad1cb97a13e4582d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17162590528b8cc58c6e8e25cb3ce479/" rel="bookmark">
			实测STM32 DMA的数据传输速率不如CPU
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试平台：STM32F407ZGT6
测试内容：用CPU和DMA同样搬运32KB的数据（内存到内存），对比搬运耗时
测试代码：
1.DMA初始化
void SRAM_DMA_Config(u8 *sbuf,u8 *aimbuf,u32 bufsize) { DMA_InitTypeDef DMA_InitStructure; RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2,ENABLE); while (DMA_GetCmdStatus(DMA2_Stream3) != DISABLE){}//等待DMA可配置 DMA_DeInit(DMA2_Stream3);//清空之前该stream3上的所有中断标志 DMA_InitStructure.DMA_Channel = DMA_Channel_4; //通道选择 DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)sbuf;//DMA外设地址 DMA_InitStructure.DMA_Memory0BaseAddr = (u32)aimbuf;//DMA 存储器0地址 DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToMemory;//存储器到外设模式 DMA_InitStructure.DMA_BufferSize = bufsize;//数据传输量 DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Enable;//外设非增量模式 DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;//存储器增量模式 DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;//外设数据长度:32位 DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;//存储器数据长度:32位 DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;// 使用普通模式 DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;//最高优先级 DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Enable; //FIFO使能 DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_Full;//全FIFO DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_INC4;//外设突发4次传输 DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_INC4;//存储器突发4次传输 DMA_Init(DMA2_Stream3, &amp;DMA_InitStructure);//初始化DMA Stream //	DMA_FlowControllerConfig(DMA2_Stream3,DMA_FlowCtrl_Peripheral);//外设流控制 // DMA_Cmd(DMA2_Stream3 ,ENABLE);//开启DMA传输 } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17162590528b8cc58c6e8e25cb3ce479/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2837e362dc039dfaf267c37b53ee6e1d/" rel="bookmark">
			洛谷——p1443 马遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做这个题的时候，写了挺久，因为比较熟悉深搜，所以一下就想用深搜解题，但是题目不适合用这个深搜，因为不仅会重复搜索多次，还会因为数据较大而时间超限。
题目是这样的：
【题目描述】
有一个 n×m 的棋盘，在某个点 (x,y) 上有一个马，要求你计算出马到达棋盘上任意一个点最少要走几步。
【输入】
输入只有一行四个整数，分别为 n , m , x , y 。
【输出】
一个 n×m 的矩阵，代表马到达某个点最少要走几步（不能到达则输出 −1）。
样例输入
3 3 1 1
样例输出
0 3 2
3 -1 1
2 1 4
题目很短，用广搜简单粗暴。但是还是想试试深搜，如果数字不大的话，深搜也可以实现，思路是这样：把每一个点（马当前的点(x,y)除外）都当做起点进行一遍深搜，听起来有点吓人，因为这样操作还要判断到达这点的最短路径是多少，就是说每个点的深搜都包括若干次比较，找出最小的路径，存入数组，一个点接着一个点的深搜，很复杂...
深搜解题代码如下：（但是过不了）
#include&lt;stdio.h&gt; int n,m,x0,y0; int book[405][405],flag[405][405]; int min=99999999; void fun(int x1,int y1,int step) { //记录方向数组，一共八个方向 int next[8][2]={2,1,-1,-2,-1,2,2,-1,1,2,1,-2,-2,1,-2,-1}; int i,tx,ty; for(i=0;i&lt;8;i++) { tx=x1+next[i][0]; ty=y1+next[i][1]; if(tx==x0&amp;&amp;ty==y0) { if(step&lt;min) min=step; return ; } //如果越界，就进入下一循环 if(tx&lt;=0||tx&gt;n||ty&lt;=0||ty&gt;m) continue; if(book[tx][ty]==0) { book[tx][ty]=1; fun(tx,ty,step+1); book[tx][ty]=0;//每一轮结束，取消标记 } } return ; } int main() { int i,j; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2837e362dc039dfaf267c37b53ee6e1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/034fb478fcae4ff1e0fa926320b00f6c/" rel="bookmark">
			Linux系统下用date指令进行时间显示和设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		date指令 显示当前日期 date：显示当前时间date +%Y：显示当前年份date +%m：显示当前月份date +%d：功能描述:显示当前是哪一天date "+%Y-%m-%d %H:%M:%S"：显示年月日时分秒 举例
date:显示当前时间信息datedate "+%Y-%m-%d":显示当前时间年月日date "+%Y-%m-%d %H:%M:%S":显示当前时间年月日时分秒，为什么要加“”，这样能把空格输出，不加也能输出时间 设置当前日期 date -s "2022-2-22 19:45:00"：设置当前时间，
重启即可恢复
日历 cal：显示本月日历
cal 2022：显示2022年的日历
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f7821a24dd8e8db1621617dda565f04/" rel="bookmark">
			统计字符串中英文字母和数字分别有多少个
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		训练目标：请编写程序，由键盘录入一个字符串，统计字符串中英文字母和数字分别有多少个。比如：Hello12345World中字母：10个，数字：5个。 训练提示 1、键盘录入一个字符串，用 Scanner 实现
2、要统计两种类型的字符个数，需定义两个统计变量，初始值都为0
3、遍历字符串，得到每一个字符
4、判断该字符属于哪种类型，然后对应类型的统计变量+1，判断字母时需要考虑大小写，条件比较复杂，怎样做才能使判断更简单呢？
一、实现步骤 1、创建键盘录入Scanner对象，使用nextLine方法接收输入的字符串。
2、为方便后续判断，使用String的toLowerCase方法，将字符串中的字符都转为小写。
3、需定义两个统计变量，初始值都为0
4、遍历字符串，得到每一个字符
5、判断该字符属于哪种类型，然后对应类型的统计变量+1，次数判断英文字母时只需判断小写即可。
二、代码实现 代码如下（示例）：
import java.util.Scanner; public class Test { public static void main(String[] args) { //键盘录入一个字符串，用 Scanner 实现 Scanner sc = new Scanner(System.in); System.out.println("请输入一个字符串："); String line = sc.nextLine(); // 为方便统计，将字符串中的字母都转为小写 line = line.toLowerCase(); //要统计两种类型的字符个数，需定义两个统计变量，初始值都为0 int letterCount = 0; int numberCount = 0; // 遍历字符串，得到每一个字符 for(int i=0; i&lt;line.length(); i++) { char ch = line.charAt(i); // 判断该字符属于哪种类型，然后对应类型的统计变量+1 if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') { letterCount++; } else if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') { numberCount++; } } //输出两种类型的字符个数 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f7821a24dd8e8db1621617dda565f04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab9dacfcb82e02515fe1ca50391c585f/" rel="bookmark">
			【用pycharm安装第三方库时出现错误】【‘pip‘ 不是内部或外部命令，也不是可运行的程序或批处理文件。】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、问题描述
二、解决过程
1、pip的版本不是最新版本导致安装不了第三方库
2、pip最新版本安装出错
3、pip' 不是内部或外部命令，也不是可运行的程序或批处理文件”
4、 ERROR: Could not find a version that satisfies the requirement PIL (from versions: none)
一、问题描述 今天用pycharm做作业时，在安装第三方库时出现了一系列问题（我安装第三方库时优先在 File——&gt;Settings——&gt;Python interpreter 里进行）。比如，提示pip的版本太老导致安装不了第三方库、pip最新版本安装出错、“pip' 不是内部或外部命令，也不是可运行的程序或批处理文件”、“ERROR: Could not find a version that satisfies the requirement PIL (from versions: none)” 。
但因为没有及时截图，目前我也忘了前两个问题具体是怎么描述的（因为是英文的，大概看得懂就没去百度翻译，所以没留下英文版的原问题提示）。
接下来我就按照遇到问题的顺序来分享自己的解决方法和想法。
二、解决过程 1、pip的版本不是最新版本导致安装不了第三方库 【方法】安装最新版本
File——&gt;Settings——&gt;Python interpreter——&gt; + ——&gt; 输入“pip” ——&gt; install Package
【结果】
平常情况下pip能更新成功，然后就可以继续成功安装想要的第三方库。但这次pip最新版本安装出错。
2、pip最新版本安装出错 【方法】复制所给的命令（比如：python -m pip install --upgrade pip）去电脑的终端运行
Win + R ——&gt; CMD ——&gt; python -m pip install --upgrade pip
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab9dacfcb82e02515fe1ca50391c585f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7157f4832b4e91f301cdf2abe7dc1fb/" rel="bookmark">
			【Vue 快速入门系列】如何更优雅的使用vuex进行组件间通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、vuex是什么？二、vuex的使用三、四个重要的映射函数四、多组件数据共享五、模块化使用vuex 前言 前面介绍过几种可以实现组件间通信的方式props、ref、自定义事件绑定、全局事件总线、插槽…，这些要么就是实现组件间通信只能在特定条件下使用，要么就是实现起来太复杂，今天介绍到的vuex是Vue中一款强大的插件，使用vuex后可以实现任意组件间通信，并且支持模块化管理。接下来将会围绕一个计数案例进行展开，逐步引入vuex如何使用。
核心代码：
&lt;template&gt; &lt;div&gt; &lt;h2&gt;目前的数值结果是：{{n}}&lt;/h2&gt; &lt;div class="container1"&gt; &lt;select v-model.number="step"&gt; &lt;option value="1"&gt;1&lt;/option&gt; &lt;option value="2"&gt;2&lt;/option&gt; &lt;option value="3"&gt;3&lt;/option&gt; &lt;/select&gt; &lt;button @click="addNum"&gt;增加&lt;/button&gt; &lt;button @click="subNum"&gt;减少&lt;/button&gt; &lt;button @click="oddNum"&gt;偶数再加&lt;/button&gt; &lt;button @click="longTimeAdd"&gt;延迟增加&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { // eslint-disable-next-line vue/multi-word-component-names name:"Counts", data(){ return { n:0, step:1 } }, methods:{ addNum(){ this.n+=this.step }, subNum(){ this.n-=this.step }, oddNum(){ if (this.n%2==0){ this.n+=this.step } }, longTimeAdd(){ setTimeout(() =&gt; { this.n+=this.step }, 1000); } } } &lt;/script&gt; &lt;style&gt; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7157f4832b4e91f301cdf2abe7dc1fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f0d2c4e8cde4a2bae1aca0ef90c426a/" rel="bookmark">
			基于协同过滤的学生在线考试推荐系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 简介 今天向大家介绍一个帮助往届学生完成的毕业设计项目，基于协同过滤的学生在线考试推荐系统。
计算机毕业生设计,课程设计需要帮助的可以找我
2 设计概要 随着计算机技术的飞速发展，学生的题目练习方式也变得多样化，也已进入信息化时代。为了使习题练习更高效、更科学，因此决定开发在线习题推荐管理系统。
本文采用自顶向下的结构化系统分析方法，阐述了一个功能较为全面的在线习题推荐管理系统的开发过程、操作流程及其一些核心的技术。本文首先进行了项目概述，简单介绍了项目开发的背景、项目开发的目的和项目开发的意义。接下来是系统的阶段性规划，通过实际的业务流程调研，分析了系统的组织结构，具体完成了在线习题推荐系统的需求分析、可行性分析、现行业务流程分析，并通过对现行业务流程的优化，得出了系统的业务流程。之后是系统分析，具体完成了数据流分析和数据字典。系统设计阶段主要完成了功能模块的划分、数据库的设计和系统界面设计。该阶段对各个模块的功能进行了详细设计，形成了本系统的功能模块图，在此基础上选择了合适的开发模式。数据库的设计先进行了概念结构设计，之后进行了逻辑结构设计，最后完成了数据库表的设计。
根据前几个阶段的分析和设计，本系统在设计方面采用B/S模式，后端使用SSM技术架构，同时使用JSP技术进行基本页面的设计与功能实现，后台数据库选用MySQL数据库。
关键词：结构化分析；SSM，JSP，MySQL
本系统主要分成前台实现学生登陆在线习题推荐系统，完成考试成绩查询功能，显示个人考试成绩,在线考试功能，更具自己的专业，选择相对应的考试试卷，完成相对应的考试题目,修改学生的个人信息功能；而后台主要负责教师成功登陆系统后，完成对考生信息的管理功能、试卷信息的管理功能、题目信息的管理功能，以及完成对考生成绩查询的功能。角色的不同完成相对应的功能，共同组成一个完整的在线考试系统。
3.1.1 前台功能描述
（1）试题列表
该功能包含着考生的待考列表，已考列表，其中已考列表会展示考生的用时，得分等基本信息；待考列表的考试点击进去可以参加考试。
（2）题型练习
学生系统登录成功后，点击“题型练习”按钮，系统弹出练习题选择的界面，学生根据自己的需要选择相对应的练习题，然后就会跳转到对应界面，执行对应的联系操作。每个练习题考虑到题量较多，将加入筛选功能按钮。
（3）学生信息修改功能
学生在登录系统后，点击右上角的个人头像，下拉框展示修改密码，点击进去会输入旧密码一次，新密码两次，同时系统会针对旧密码做正确性校验。
（4）个性推荐
学生在登录系统后，基于用户的协同过滤算法，实现习题的个性化推荐，默认推荐10道题，展示在用户的页面上。
（5）错题本
学生在登录系统后，点击选择题详情之后，页面添加了加入错题本按钮，加入同时，后台数据库新增记录，完成新增错题本的操作。
3.1.2 后台功能描述
（1）试题列表
该功能包含着考生的待考列表，已考列表，其中已考列表会展示考生的用时，得分等基本信息；待考列表的考试点击进去可以参加考试。
（2）题型练习
教师系统登录成功后，点击“题型练习”按钮，系统弹出练习题选择的界面，学生根据自己的需要选择相对应的练习题，然后就会跳转到对应界面，执行对应的联系操作。每个练习题考虑到题量较多，将加入筛选功能按钮。
（3）教师信息修改功能
教师在登录系统后，点击右上角的个人头像，下拉框展示修改密码，点击进去会输入旧密码一次，新密码两次，同时系统会针对旧密码做正确性校验。
（4）抽题组卷功能
教师在登录系统后，页面不同于学生，会多三个选择项，点击抽题组卷，会有固定组卷和随机抽题组卷两部分。固定组卷包括选择原有组卷信息和教师现场组卷两部分功能，而随机抽题组卷，将由系统随机生成
（5）导入导出功能
教师学生在登录系统后，点击主页面导入导出，可以批量导入选择题，填空题，判断题和学生信息。
（6）试题分析功能
教师在登录系统后，点击主页面试题分析，展示三个功能模块，分别是成绩列表，成绩柱状图，题目分析，点击不同的功能块将执行不同的操作，进行不同的效果分析。
本系统基于java技术，使用UML建模，采用springboot框架组合进行设计，Mysql数据库存储数据。
本系统的功能主要包括本系统的功能主要包括：
用户注册、登录、信息维护、会员搜索、个性化推荐管理员进行信息管理等考试题管理错题管理协同过滤推荐题目学生管理错题分析 3 系统关键技术 使用springboot，vue，mysql, mybaties, typescript, html ,css, js，协同过滤算法 等进行开发
4 开发工具 开发工具主要有：idea、jdk1.8、maven、mysql5.7、Navicat等。
5 代码展示 @RequestMapping("/strategy") @RestController @Scope("prototype") public class StrategyController { @Autowired private StrategyService strategyService; @Value("${web.upload-path}") private String path; @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f0d2c4e8cde4a2bae1aca0ef90c426a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eb5041b048c50804852895b80877b0d/" rel="bookmark">
			C语言如何退出多重循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我们在敲代码时经常可以碰见嵌套循环的情况，同时也会碰见想一次退出多重循环。
那么怎么退出多重循环呢？
方法一：通过多个if和break退出
#include&lt;stdio.h&gt; int main(){ int m=1; int i,j,k; for( i=0;i&lt;10;i++){ for( j=0;j&lt;20;j++){ for( k=0;k&lt;30;k++){ if(i==2&amp;&amp;j==5&amp;&amp;k==10){ m=0; break; } } if(m==0){ break; } } if(m==0){ break; } } printf("%d,%d,%d",i,j,k); } 方法二：使用goto
#include&lt;stdio.h&gt; int main(){ int i,j,k; for( i=0;i&lt;10;i++){ for( j=0;j&lt;20;j++){ for( k=0;k&lt;30;k++){ if(i==2&amp;&amp;j==5&amp;&amp;k==10){ goto out；//去往标识符 } } } } out:（标识符） printf("%d,%d,%d",i,j,k); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9224dadd468342fdec2f63ed533f958a/" rel="bookmark">
			语音识别芯片LD3320介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		语音识别芯片LD3320简介 LD3320 芯片是一款“语音识别”芯片,集成了语音识别处理器和一些外部电路，包括AD、DA 转换器、麦克风接口、声音输出接口等。LD3320不需要外接任何的辅助芯片如Flash、RAM 等，直接集成在LD3320中即可以实现语音识别/声控/人机对话功能。并且，识别的关键词语列表是可以任意动态编辑的。
语音识别芯片LD3320实物图
语音识别芯片LD3320主要特征 1、特有的快速而稳定的优化算法，完成非特定人语音识别。不需要用户事先训练和录音，识别准确率95%。 2、不需要外接任何辅助的Flash芯片，RAM芯片和AD芯片，就可以完成语音识别功能。真正提供了单芯片语音识别解决方案。 3、每次识别最多可以设置50项候选识别句，每个识别句可以是单字，词组或短句，长度为不超过10个汉字或者79个字节的拼音串。另一方面，识别句内容可以动态编辑修改, 因此可由一个系统支持多种场景。 4、芯片内部已经准备了16位A/D转换器、16位D/A转换器和功放电路，麦克风、立体声耳机和单声道喇叭可以很方便地和芯片管脚连接。立体声耳机接口的输出功率为20mW，而喇叭接口的输出功率为550mW，能产生清晰响亮的声音。 5、支持并行和串行接口，串行方式可以简化与其他模块的连接。 6、可设置为休眠状态，而且可以方便地激活。 7、支持MP3播放，无需外围辅助器件，主控MCU将MP3数据依次送入LD3320芯片内部就可以从芯片相应PIN输出声音。可以选择从立体声耳机或者单声道喇叭获得声音输出。支持MPEG1(ISO/IEC11172-3), MPEG2(ISO/IEC13818-3) 和MPEG 2.5 layer 3等格式。 8、工作供电为3.3V，如果用于便携式系统，使用3节AA电池就可以满足供电需要。
语音识别芯片LD3320内部电路的简单逻辑图
说明如下： 一、电压要求：
1、VDD 数字电路用电源输入 3.0 V–3.3 V。
2、VDDIO 数字I/O电路用电源输入 1.65 V–VDD。
3、VDDA 模拟电路用电源输入 3.0 V–4.0 V。 可以用统一的3.3v电压输入以简化设计。数字电压和模拟电压进行隔离可以使得芯片有更好的效果。 芯片管脚输入电压范围：
高电压 （逻辑“1”）:0.7*VDDIO～VDDIO。 低电压（逻辑“0”）：0～0.3*VDDIO。 因此，需要保证使用的主控MCU同样工作在3.3V，保证主控MCU向LD3320的管脚输出的高电压不超过3.3V。 二、时钟（Clock）：芯片必须连接外部时钟，频率范围是4～48MHz。芯片内部有PLL频率合成器，可产生特定频率供内部模块使用。 三、复位：复位信号（RSTB*）必须在VDD/VDDA/VDDIO稳定后进行。无论芯片在进行何种运算，复位信号可以使它恢复初始状态，并使各寄存器复位。如没有后续指令（对寄存器的设置），复位后芯片进入休眠状态。此后，一个CSB*信号可以重新激活芯片进入工作状态。 四、并行接口：可通过并行方式和外部主CPU连接，此时使用8根数据线（P0-P7），4个控制信号（WRB*, RDB*, CS*， A0）， 以及一个中断返回信号（INTB*）。 五、串行接口：串行接口通过SPI协议和外部主CPU连接，首先要将MD接高电平，而将（SPIS*）接地。此时只使用4个管脚：片选（SCS*）、SPI时钟（SDCK）、SPI输入(SDI)和SPI输出（SDO）。 六、寄存器：芯片的设置和命令、包括传送和接受数据，都是通过对寄存器操作来完成。如进行语音识别时，设置识别关键词语列表，设定芯片识别模式，识别完成后获得识别结果都是通过读/写寄存器来完成。播放声音时，将MP3格式数据循环放入FIFO对应寄存器。（识别结果是通过寄存器返回识别出的关键词语在关键词语列表中的排列序号Index数值，该Index数值是在设置关键词语列表时指定）。 七、喇叭音量的外部控制：除了特定寄存器来控制音量以外，芯片外部电路可以控制喇叭音量增益。使用EP1、EP2、EP3对应管脚。
语音识别芯片LD3320管脚说明
说明： IO方向： I表示输入； O表示输出。 AD分类： A表示模拟信号； D表示数字信号。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4454165244e8d776dabbb6652ebb10e7/" rel="bookmark">
			HC-SR501人体感应模块介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HC-SR501人体感应模块简介
HC-SR501是基于红外线技术的自动控制模块，采用德国原装进口 LHI778 探头设计，灵敏度高，可靠性强，超低电压工作模式，广泛应用于各类自动感应电器设备，尤其是干电池供电的自动控制产品。
HC-SR501人体感应模块实物
HC-SR501人体感应模块电气参数
HC-SR501人体感应模块功能特点
1、全自动感应:人进入其感应范围则输出高电平， 人离开感应范围则自动延时关闭高电平，输出低电平。
2、光敏控制（可选择，出厂时未设）可设置光敏控制，白天或光线强时不感应。
3、温度补偿(可选择，出厂时未设)：在夏天当环境温度升高至30～32℃，探测距离稍变短，温度补偿可作一定的性能补偿。
4、两种触发方式：（可跳线选择）
a、不可重复触发方式:即感应输出高电平后，延时时间段一结束，输出将自动从高电平变成低电平；
b、可重复触发方式：即感应输出高电平后，在延时时间段内，如果有人体在其感应范围活动，其输出将一直保持高电平，直到人离开后才延时将高电平变为低电平。
5、具有感应封锁时间(默认设置:2.5S 封锁时间)：感应模块在每一次感应输出后（高电平变成低电平），可以紧跟着设置一个封锁时间段，在此时间段内感应器不接受任何感应信号。此功能可以实现“感应输出时间”和“封锁时间”两者的间隔工作，可应用于间隔探测产品；同时此功能可有效抑制负载切换过程中产生的各种干扰。(此时间可设置在零点几秒—几十秒钟)。
6、工作电压范围宽：默认工作电压DC4.5V-20V。
7、微功耗:静态电流&lt;50 微安。
8、输出高电平信号：可方便与各类电路实现对接。
HC-SR501人体感应模块使用说明
1、感应模块通电后有一分钟左右的初始化时间，在此期间模块会间隔地输出0-3 次，一分钟后进入待机状态。
2、避免灯光等干扰源近距离直射模块表面的透镜，以免引进干扰信号产生误动作；尽量避免流动的风，风也会对感应器造成干扰。
3、感应模块采用双元探头，探头的窗口为长方形，双元（A 元B 元）位于较长方向的两端，当人体从左到右或从右到左走过时,红外光谱到达双元的时间、距离有差值，差值越大，感应越灵敏，当人体从正面走向探头或从上到下或从下到上方向走过时，双元检测不到红外光谱距离的变化，无差值，因此感应不灵敏或不工作；所以安装感应器时应使探头双元的方向与人体活动最多的方向尽量相平行，保证人体经过时先后被探头双元所感应。为了增加感应角度范围，本模块采用圆形透镜，也使得探头四面都感应，但左右两侧仍然比上下两个方向感应范围大、灵敏度强，安装时仍须尽量按以上要求。
HC-SR501人体感应模块感应范围
HC-SR501人体感应模块外形与调节
注：
1、调节距离电位器顺时针旋转，感应距离增大（约7 米），反之，感应距离减小（约3 米）。
2、调节延时电位器顺时针旋转，感应延时加长（约300S），反之，感应延时减短（约0.5S）。
HC-SR501人体感应模块应用范围
1、安防产品2、人体感应玩具。
2、人体感应灯具4、工业自动化控制等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc8229b48ec9f9e797a32442cd572bec/" rel="bookmark">
			[ubuntu]ubuntu安装指定版本GCC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		客户要求安装gcc5.4但是直接使用sudo apt install gcc-5安装时5.5版本，一种是下载5.4版本源码编译这个耗时费力，一种就是使用ppa去安装具体步骤
先查看自己gcc版本
gcc --version
g++ --version
加入ppa源：
sudo add-apt-repository ppa:ubuntu-toolchain-r/test
sudo apt-get update
查看源里面有的gcc版本：
sudo apt-cache policy gcc-5
安装：
sudo apt-get install gcc-5=5.4.0-6ubuntu1~16.04.12
如果安装报错可以使用
sudo aptitude install gcc-5=5.4.0-6ubuntu1~16.04.12
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9cb7f963c832023d1045e9f1ea15508/" rel="bookmark">
			HBuilder X的下载与使用(详细步骤)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、HBuilder X的下载 这里我们前往HBuilder下载官网地址：https://www.dcloud.io/进入官网后，我们可以看到HBuilder目前有两个版本，一个是windows版，一个是mac版。下载一个自己电脑适合的版本，这里我下载步骤用的是windows版本，mac版本下载安装步骤同理。 1. 点击链接进入网站后会看到如下页面 2.这里点击左上角HBuilderX极客开发工具 显示如下
右击more按钮弹出弹窗,注意这里有正式版和Alpha版,选择第二个Alpha版，Mac用户同理
选择D盘保存安装文件,做好文件分类,以便于查找文件和文件管理(尽量不使用中文做文件名)
4. 解压安装包 这里我用的是7-Zip进行解压,选择好要解压到的文件夹后,点击确定
找到解压好的文件,点进去,找到"HBuilderX.exe"可执行文件
双击文件,进入HBuilder X开发编辑器,(注意,HBuilderX不需要安装,解压完成即可使用)
如果桌面上没有HBuilderX的快捷键,这里就需要我们手动进行快捷方式的创建了（右击"HBuilderX.exe"&gt;显示更多选项&gt;发送到&gt;桌面快捷方式）
二、HBuilder X的使用 打开HBuilder X 在桌面找到快捷方式双击或进入文件夹找到【HBuilder.exe】可执行文件进入HBuilder X开发编辑器,如下所示:
第一次登录需要你登录HBuilder账号,如果没有账户的可以进行注册,嫌麻烦不想登录的可以选择暂不登录,根据个人意愿即可,不会有什么影响,这个不是强制性的 了解HBuilder X编辑器 进入后能看见HBuilder X的编辑器风格是卡其色为主，对眼睛保护较友好,里面有许多新手入门提示，不会的新手码农可以详细看看，也能起到对这个软件的一定认识作用
如果不喜欢这个颜色的主题,可以到选项栏找到工具,点击打开弹窗找到主题,选择自己喜欢的颜色,切换即可
新建项目 新建一个项目，依次点击 文件&gt;新建&gt;项目,也可以使用快捷组合键Ctrl+N，选择 项目 快速新建
点击项目后,取名,我选择的是一个空项目,后续可以进行其他文件创建,根据个人选择,然后点击创建 (尽量不使用中文)
点击创建好的项目,右击进行需要创建的文件类型,这里可以创建一个目录(也可以不需要),对文件进行划分,可以更好的归纳文件类型
这里演示一个HTML文件创建
点击html文件后,取名,然后创建最后如下所示
那么HBuilder X的下载和使用就大致讲这么多了,有不懂的可以留言评论,记得一键三连,点赞收藏加关注 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c23af2a66f79ec4bd91850b4eaf072ba/" rel="bookmark">
			Java Timer(定时器)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述： Timer是一种定时器工具，用来在一个后台线程计划执行指定任务。它可以安排任务“执行一次”或者定期“执行多次”。 然而在实际的开发过程当中，经常需要一些周期性的操作，比如每5分钟执行某一操作等。 对于这样的操作最方便、高效的实现方式就是使用java.util.Timer工具类。 方法摘要： schedule(TimerTask task, Date time) // 安排在 "指定的时间" 执行 指定的任务。（只执行一次） schedule(TimerTask task,long delay) // 安排在指定延迟后执行指定的任务 schedule(TimerTask task, Date firstTime , long period) // 安排指定的任务在 "指定的时间 " 开始进行 "重复" 的固定延迟执行 schedule(TimerTask task,long delay,long period)// 安排指定的任务指定的延迟后开始进行重复的固定延迟执行． scheduleAtFixedRate(TimerTask task,Date firstTime,long period)// 安排指定的任务在指定的时间开始进行重复的固定速率执行． scheduleAtFixedRate(TimerTask task,long delay,long period)//安排指定的任务在指定的延迟后开始进行重复的固定速率执行． Timer.cancal()// 终止此计时器，丢弃所有当前已安排的任务。 Timer.purge()// 从此计时器的任务队列中移除所有已取消的任务。 TimerTask.cancal()// 把当前任务取消 固定延迟：意味着执行将在最后一次执行开始后的一段时间内开始，即使它被延迟（因此它本身被延迟）。也就是说任务的 下一次执行时间 是相对于 上一次实际执行完成的时间点 ，因此执行时间会不断延后
固定频率：意味着每次执行都将遵守初始计划，无论之前的执行是否被延迟。也就是说任务的 下一次执行时间 是相对于 上一次开始执行的时间点 ，因此执行时间不会延后
关于这两种调度方式，让我们看看如何使用它们：
为了使用固定延迟调度，schedule（）方法还有两个重载，每个重载都使用一个额外的参数来表示以毫秒为单位的周期性。为什么两次重载？因为仍然有可能在某个时刻或某个延迟之后开始执行任务。
至于固定频率调度，我们有两个scheduleAtFixedRate（）方法，它们的周期也是以毫秒为单位的。同样，我们有一种方法可以在给定的日期和时间启动任务，还有一种方法可以在给定的延迟后启动任务。
注意一点：如果一个任务的执行时间超过了执行周期，那么无论我们使用固定延迟还是固定速率，它都会延迟整个执行链。(固定速率会连续执行，固定延迟会等待延迟再执行)
具体代码 schedule(TimerTask task, Date time) /** * @PROJECT_NAME: demo * @DESCRIPTION: 指定时间执行 */ public class TimerDemo { public static void main(String[] args) { Calendar ca = Calendar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c23af2a66f79ec4bd91850b4eaf072ba/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/47/">«</a>
	<span class="pagination__item pagination__item--current">48/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/49/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>