<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bfb91574627dba86f3b0d1b5e5e34c4/" rel="bookmark">
			分位数的简单理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分位数理解1： 假设有一千名学生参加了某次考试，
学生A得了75分，排名603，603/1000＝60.3%
学生B得了94分，排名28，28/1000=2.8%
此时，A大约在60.3%的位置上，而B大约在2.8%的位置上。即在60.3%的位置上约75分, 2.8%的位置上约94分。
对应四分位数的就很好解释了，分别在25%, 50%, 75%位置上的数。假设考生甲乙丙丁考试成绩分别为80,71,61，对应的名次分别为250,500,750名，那么对应的四分位数分别就为80,71,61
分位数理解2： 假如有1000个数字(正数)，这些数字的5%, 30%, 50%, 70%, 99%分位数分别是 [3.0,5.0,6.0,9.0,12.0]，这表明有5%的数字分布在0-3.0之间，有25%的数字分布在3.0-5.0之间，有20%的数字分布在5.0-6.0之间，有20%的数字分布在6.0-9.0之间，有29%的数字分布在9.0-12.0之间，有1%的数字大于12.0，这就是分位数的统计学理解
因此求解某一组数字中某个数的分位数，只需要将该组数字进行排序，然后再统计小于等于该数的个数，除以总的数字个数即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30bca4822e413ebb6d666b19449e83c1/" rel="bookmark">
			SpringBoot(33) ——用户认证和授权
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Security 是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型，他可以实现强大的Web安全控制，对于安全控制，我们仅需要引入 spring-boot-starter-security 模块，进行少量的配置，即可实现强大的安全管理！
记住两个类和一个注解：
WebSecurityConfigurerAdapter：自定义Security策略AuthenticationManagerBuilder：自定义认证策略@EnableWebSecurity：开启WebSecurity模式 Spring Security的两个主要目标是 “认证” 和 “授权”(访问控制)
“认证”（Authentication）
身份验证就是验证您的身份凭据，如用户名/用户ID和密码，以验证您的身份是否合法身份验证通常通过用户名和密码完成，有时与身份验证因素结合使用 “授权” （Authorization）
授权发生在系统成功验证您的身份后(即你需要先通过认证证明你的身份合法性，spring security才会去检查你的身份对应的角色，spring security才会对你进行授权验证，对比你请求的资源是不是你对应的角色的权限范围内的，是就返回资源，不是就403) 这两个概念是通用的，而不是只在Spring Security 中存在
目录 1.导入依赖2.简单上手1.授权(Authorization/or)2.认证(Authentication/en) 3.小结4.补充：使用JDBC实现认证 1.导入依赖 导入依赖，只需要导入启动器即可，我们可以在原来有的启动器依赖上面修改即可导入，这是因为springBoot的启动器依赖格式都是spring-boot-starter-XXX &lt;!--Spring Security的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; 我们可以观察一下这个依赖为我们导入的其他依赖
可以发现它导入了aop依赖和安全配置和安全web依赖 2.简单上手 spring securty官方doc
@EnableWebSecurity	//使用注解@EnableWebSecurity public class Config extends WebSecurityConfigurerAdapter {	//继承WebSecurityConfigurerAdapter @Override protected void configure(HttpSecurity http) throws Exception {	//覆写configure()即可 http .apply(customDsl()) .flag(true) .and() ...; } } 按照官方模板创建一个configpackage com.thhh.config; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30bca4822e413ebb6d666b19449e83c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/074cbf21fc0f0c5afeecc3d659b752bf/" rel="bookmark">
			MACOS 格式化后重装系统提示 无法与恢复服务器获得联系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到这个问题时主要有以下几个解决方式：
1、进入终端，输入date ，如果时间和当前时间不一致的话，需要输入date 0927101020,这是相当于设置时间，时间格式是：月、日、时、分、年，每个都是两位，如果是单数，要前面加0.
2、可能是硬盘的格式不一致，需要格式化硬盘，进入MACOS 系统安装自带的硬盘管理，格式化即可。
3、正常进入重新安装系统是command + r ,换一种方式，用command+option+r,这两个有区别，第一个是查找最近安装的系统版本，第二个是直接安装最新的。
4、网络问题，用手机开个热点，用电脑连上试试。如果觉得自己网络没问题，强烈建议用第三种方式再试一下。
5、再说一个问题，就是网上查的资料有网友说可能是服务器架在国外被墙了，我问苹果客服了，他说国内的恢复服务器是在国内的云上贵州运营，不会被墙。
6、苹果客服发的 恢复指南，网友可以参考一下：https://support.apple.com/zh-cn/HT204904
7、如果非必要，不要先尝试格式化硬盘。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cf23c932f8f03a654e9e6f5042fc120/" rel="bookmark">
			简述http与https的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 简述http与https的区别 https协议需要申请证书。http是明文传输，https是具有安全性的ssl加密传输协议。http端口是80，https端口号是443。http连接简单无状态，https由ssl+http协议构件的可进行加密传输身份验证的网络协议。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a15274e40feeee0b38b5deb290d7a14a/" rel="bookmark">
			Nginx官方文档(五十)【ngx_google_perftools_module|ngx_stream_upstream_module】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ngx_stream_ssl_preread_module 示例配置指令 ssl_preread 内嵌变量 ngx_stream_ssl_preread_module 模块（1.11.5）允许从 ClientHello 消息中提取信息，而不会终止 SSL/TLS，例如提取通过 SNI 请求的服务器名称。默认情况下不构建此模块，您可以在构建时使用 --with-stream_ssl_preread_module 配置参数启用此模块。
示例配置 map $ssl_preread_server_name $name { backend.example.com backend; default backend2; } upstream backend { server 192.168.0.1:12345; server 192.168.0.2:12345; } upstream backend2 { server 192.168.0.3:12345; server 192.168.0.4:12345; } server { listen 12346; proxy_pass $name; ssl_preread on; } 指令 google_perftools_profiles -说明语法ssl_preread on | off;默认ssl_preread off;上下文stream、server 启用在预读阶段 从 ClientHello 消息中提取信息。
内嵌变量 $ssl_preread_server_name
返回通过 SNI 请求的服务器名称
原文档 http://nginx.org/en/docs/ngx_google_perftools_module.html
ngx_stream_upstream_module 示例配置指令 upstreamserverzonestatehashleast_connleast_timerandomresolverresolver_timeout 内部变量 ngx_stream_upstream_module 模块（1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a15274e40feeee0b38b5deb290d7a14a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3a66a845ee883a6d85f1acefd18f75a/" rel="bookmark">
			Kubernetes K8S之kubectl命令详解及常用示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kubernetes kubectl命令详解与常用示例，基于k8s v1.17.4版本
kubectl常用示例 查看类命令 1 # 获取节点和服务版本信息 2 kubectl get nodes 3 # 获取节点和服务版本信息，并查看附加信息 4 kubectl get nodes -o wide 5 6 # 获取pod信息，默认是default名称空间 7 kubectl get pod 8 # 获取pod信息，默认是default名称空间，并查看附加信息【如：pod的IP及在哪个节点运行】 9 kubectl get pod -o wide 10 # 获取指定名称空间的pod 11 kubectl get pod -n kube-system 12 # 获取指定名称空间中的指定pod 13 kubectl get pod -n kube-system podName 14 # 获取所有名称空间的pod 15 kubectl get pod -A 16 # 查看pod的详细信息，以yaml格式或json格式显示 17 kubectl get pods -o yaml 18 kubectl get pods -o json 19 20 # 查看pod的标签信息 21 kubectl get pod -A --show-labels 22 # 根据Selector（label query）来查询pod 23 kubectl get pod -A --selector="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3a66a845ee883a6d85f1acefd18f75a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17edc0411cb3eb062ec6d3fe3a9f7b5b/" rel="bookmark">
			Linux系统设置vnc开机自启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装tigervnc服务器
yum install -y tigervnc-server 2、启动vncserver
vncserver 命令输出如下：
You will require a password to access your desktops. Password: Verify: Would you like to enter a view-only password (y/n)? n A view-only password is not used New 'hdp1:1 (root)' desktop is hdp1:1 Creating default startup script /root/.vnc/xstartup Creating default config /root/.vnc/config Starting applications specified in /root/.vnc/xstartup Log file is /root/.vnc/hdp1:1.log 首次启动vncserver时提示输入设置远程连接密码，可以不同于本地密码，该密码以后可以使用vncpasswd命令重置。注意当出现 Would you like to enter a view-only password (y/n)? 提示时输入n。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17edc0411cb3eb062ec6d3fe3a9f7b5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a53a57ee93c502fc9df3b43c72acf16/" rel="bookmark">
			hdu1495 非常可乐 （bfs）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		非常可乐 Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 38624 Accepted Submission(s): 15103
Problem Description 大家一定觉的运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N 毫升和M 毫升 可乐的体积为S （S&lt;101）毫升　(正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且 S==N+M，101＞S＞0，N＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出"NO"。 Input 三个整数 : S 可乐的体积 , N 和 M是两个杯子的容量，以"0 0 0"结束。 Output 如果能平分的话请输出最少要倒的次数，否则输出"NO"。 Sample Input 7 4 3 4 1 3 0 0 0 Sample Output NO 3 Author seeyou Source “2006校园文化活动月”之“校庆杯”大学生程序设计竞赛暨杭州电子科技大学第四届大学生程序设计竞赛 Recommend LL | We have carefully selected several similar problems for you: 1175 1072 1372 1180 1016 经典bfs，不多说了。两年前刚入门写了一次，没调出来，少了一个&amp;。今天重新写了一次，惊喜的发现了之前的代码，发现写的还不错，写的比现在认真多了（现在太菜了），调完发出来，纪念一下曾经刚开始写代码的时光。 先来一个最近写的： #include&lt;iostream&gt; #include&lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a53a57ee93c502fc9df3b43c72acf16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1edd1887db799395f930a286d1ff4e2/" rel="bookmark">
			页面一次性加载数据过多时，页面卡死怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：当后端一次性返回数据(array)过多时（例如1000条或者更多），会导致页面卡顿
优化思路之方案一：（推荐使用）
思路：利用插件pl-table
解决方案：https://developer.aliyun.com/mirror/npm/package/pl-table
示例：请看官方文档，里面描述很清楚，就不重复说了
推荐理由：dom结构固定，不是累加似加到页面
注意：基于element-ui但是不代表你需要安装element-ui才能使用pl-table，你可以不安装任何UI库，就可以使用pl-table。但是必须在集成vue框架下使用
优化思路之方案二：
思路：将这1000条数据划分为多个小数组，然后一段一段的加到页面上
解决方案：利用window.requestAnimationFrame()或者setInterval()
示例：以window.requestAnimationFrame()为例
window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行；
// data为所有数据的数组，callback 拿到当前数据要做的操作 ,pageSize 一次取多少条 UtilHandleBigData(data, callback, pageSize = 20) { const totalCount = data.length // 共多少条 // 可分多少页,就是分割为多少个小数组 const totalPageNumer = Math.ceil(totalCount / pageSize) let currentPageNumber = 1 // 当前页数 const handler = () =&gt; { const start = (currentPageNumber - 1) * pageSize const end = currentPageNumber * pageSize const currentData = data.slice(start, end) // 当前页的数据 if (typeof callback === 'function') { callback(currentData, { totalCount, totalPageNumer, currentPageNumber, pageSize }) } if (currentPageNumber &lt; totalPageNumer) { window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1edd1887db799395f930a286d1ff4e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8512ba52afee9b4068f0f2015e8d7e40/" rel="bookmark">
			iOS进阶之多线程--NSThread详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iOS进阶之多线程–NSThread详解
https://www.jianshu.com/p/686dbf4bbb52
一个默默无闻的程序猿
1
2018.04.02 17:06:56
字数 1,856
阅读 8,643
NSThread简介
NSThread是苹果官方提供面向对象操作线程的技术，简单方便，可以直接操作线程对象，不过需要自己控制线程的生命周期。在平时使用很少，最常用到的无非就是 [NSThread currentThread]获取当前线程。
NSThread使用
1、 实例初始化、属性和实例方法
初始化
//创建线程
NSThread *newThread = [[NSThread alloc]initWithTarget:self selector:@selector(demo:) object:@“Thread”];
//或者
NSThread newThread=[[NSThread alloc]init];
NSThread newThread= [[NSThread alloc]initWithBlock:^{
NSLog(@“initWithBlock”);
}];
属性
线程字典
/
每个线程都维护了一个键-值的字典,它可以在线程里面的任何地方被访问。
你可以使用该字典来保存一些信息,这些信息在整个线程的执行过程中都保持不变。
比如,你可以使用它来存储在你的整个线程过程中 Run loop 里面多次迭代的状态信息。
NSThread实例可以使用一下方法
*/
@property (readonly, retain) NSMutableDictionary threadDictionary;
NSMutableDictionary dict = [thread threadDictionary];
优先级
@property double threadPriority ; //优先级
线程优先级
/ NSQualityOfService:
NSQualityOfServiceUserInteractive：最高优先级,主要用于提供交互UI的操作,比如处理点击事件,绘制图像到屏幕上
NSQualityOfServiceUserInitiated：次高优先级，主要用于执行需要立即返回的任务
NSQualityOfServiceDefault：默认优先级，当没有设置优先级的时候，线程默认优先级
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8512ba52afee9b4068f0f2015e8d7e40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26baad0cb25467ef3e890d55aa996631/" rel="bookmark">
			人机交互基础教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		9月：
第一遍纯理论补习基础知识 这本书主要结合了大部分市面上的技术要点：学习整理框架自学能力 10月：
第二遍重点回答习题第三遍从应用角度拓展知识，设计实例与分析——自我实践 有志于从事人机交互研究的读者，在学习和掌握计算机科学理论知识的同时，也必须广泛地学习和涉猎最新的电子、光学及物理技术，这是人机交互的交叉学科本质所决定的 1. 什么是人机交互：正式回答自己的体系框架 信息技术的一个重要组成部分（都belong to“认知世界，改造世界”的科学） 人机交互：Human-Computer Interaction HCI：关于设计、评价和实现供人们使用的交互式计算机系统，并围绕相关的主要现象进行研究的学科 狭义：研究人与计算机之间的信息交换：
人到计算机：借助键盘、鼠标、操纵杆、数据服装、眼动跟踪器、位置跟踪器、数据手套、压力笔等设备，用手、脚、声音、姿势或身体的动作、眼镜甚至脑电波等向计算机传递信息
计算机到人：打印机、绘图仪、显示器、头盔式显示器（HMD）、音箱、大屏幕投影灯输出或显示设备向人们提供可理解的信息
人机交互是一门综合学科，与认知心理学、人机工程学、多媒体技术、虚拟现实技术等密切相关 认知心理学和人机工程学是人机交互技术的理论基础
多媒体技术、虚拟现实技术是互相交叉和渗透的
研究内容 涵盖了建模、设计、评估等理论和方法，以及在Web、移动计算、虚拟现实等方面的应用研究：
人机交互界面的表示模型与设计方法可用性分析与评估多通道交互技术：视觉、听觉、触觉和力觉，自然交互方式与计算机系统进行通信。多通道交互的表示模型、交互界面的评估方法以及多通道信息的融合（融合是用户界面研究的重点和难点）等认知与智能用户界面（Intelligent User Interface，IUI）：最终目标是人机交互和人人交互一样自然方便——上下文感知、三维输入、语音识别、手写识别、自然语言理解等要解决的重要问题群件：为群组协同工作提供计算机支持的协作环境，主要涉及人或群组间的信息传递、群组内的信息共享、业务过程自动化与协调以及人和过程之间的交互活动等——群件系统的体系结构、计算机支持的交流与共享信息的方式、交流中的决策支持工具、应用程序共享以及同步实现方法等内容Web设计：Web界面的信息交互模型和结构、Web界面设计的基本思想和原则、工具与技术、以及Web界面设计的可用性分析与评估方法等内容移动界面设计：移动计算（Mobile Computing）、普适计算（Ubiquitous Computing）等技术的更高要求：面向移动应用的界面设计：移动设备的便携性、位置不固定性、计算能力有限性以及无线网络的低带宽、高延迟等诸多限制。——移动界面的设计方法、可用性与评估原则、导航技术、移动界面的实现技术和开发工具 人机交互的发展历史 伴随着计算机的发展而发展：从人适应计算机到计算机不断适应人的发展过程
交互的信息也由精确的输入输出信息变成非精确的输入输出信息
命令行界面图形用户界面交互（Graphical User Interface，GUI）：桌面隐喻、WIMP(Window、 Icon、Menu、Pointing Device)技术、直接操纵和“所见即所得”
tips：自然性和交互效率都有较大提高。图形用户界面很大程度上依赖于菜单选择和交互构件(Widget)；输入信息时只能使用“手”这种输入通道，自然和谐的人机交互阶段：在使用多媒体终端时，有着更便捷、更符合他们使用习惯同时又比较美观的操作界面。
tips：利用人的多种感觉通道和动作通道（如语音、手写、姿势、视线、表情等输入），以并行、非精确的方式与（可见/不可见）计算机环境进行交互，进入自然和谐的人机交互时期。 自然和谐的人机交互阶段的主要研究内容（概念明确）： 多通道交互（Multi Modal Interaction，MMI） 目前最常使用的多通道交互技术：手写识别、笔式交互、语音识别、语音合成、数字墨水、实现跟踪技术、触觉通道的力反馈装置、生物特征识别技术和人脸表情识别技术
情感计算 明斯基：赋予计算机情感能力，并让计算机能够理解和表达情感的研究、探讨
工作首推： MIT媒体实验室Rosalind Picard教授的研究小组。“情感计算”：关于情感、情感产生以及影响情感方面的计算。IBM公司“蓝眼计划”：人的眼睛瞄向电视时，知道人想打开电视机；情感鼠标，根据手部的血压及温度等传感器感知用户的情感日本软银公司“Pepper”2014机器人：读懂人类情感，与人类交流——搭载“感情识别功能”的机器人，可以通过分析人的表情和声调，推测出人的情感，并采取行动。 虚拟现实 Virtual Reality VR以计算机技术为核心，结合相关科学技术，生成与一定范围真实环境在视、听、触感等方面高度近似的数字化环境（认识自然、模拟自然，进而更好地适应和利用自然的科学方法和科学技术）
新的交互设备：
麻省理工头盔式例题显示器，加州VPL数据手套用于手势输入、沉浸式虚拟现实环境——CAVE系统（一个房间大小的四面立方体投影显示空间），Facebook的Oculus头盔式显示器虚拟现实接入游戏，微软的HoloLens全息眼镜，投影在现实世界达到增强现实的效果；且能够追踪用户的声音、动作和周围环境，用户通过眼神、声音指令和手势进行控制 智能用户界面Intelligent User Interface，IUI 致力于达到人机交互的高效率、有效性和自然性的人机界面。通过表达、推理，并按照用户模型、领域模型、任务模型、谈话模型和媒体模型来实现人机交互。
智能用户界面主要使用人工智能技术去实现人机通信，提高了人机交互的可用性知识表示技术支持基于模型的用户界面生成规划识别和生成支持用户界面的对话管理、语言、手势和图像理解支持多通道输入的分析、用户建模实现对自适应交互的支持 代理（agent）：能够感知外界环境并具有自主行为能力的、以实现其设计目标的自治系统。智能的agent系统可以根据用户的喜好和需要配置具有个性化特点的应用程序。基于此技术，我们可以实现： 自适应用户系统：帮助用户获得信息，推荐产品，界面自适应，支持协同，接管例行工作用户建模：机器学习如神经网络自适应脑界面：如神经分类器通过分析用户的脑电波识别出用户想要执行什么任务，该任务可运动相关，也可是认知活动 自然语言理解 “计算机文化”社会到来，语言也是人机对话的基础。自然语言处理（Natural Language Processing，NLP）是使用自然语言同计算机进行通信的技术。
处理自然语言的关键是要让计算机“理解”自然语言，所以NLP又称为自然语言理解NLU/计算机语言学（Computational Linguistics）（近年来AI的核心课题之一）近年来在搜索技术方面得到了广泛的应用。以一定策略在互联网中搜集、发现信息，对信息进行理解、提取、组织和处理，为用户提供采用自然语言进行信息的检索 人机交互的应用 工业：产品论证、设计、装配、人机工效和性能评价等教育：沉浸式虚拟世界系统（3D投影技术）军事：对环境的“透视”文化娱乐：游戏厅、展览馆等场馆的地面式互动投影系统，奥运会/全运会开幕式；任天堂的WII操作手柄（包含固态加速计合陀螺仪）、Kinect（3D体感摄影机）、影视制作和动作捕捉等人机交互设备生活：苹果手机：Multi-Touch屏幕感知手指触碰并将感应到的信息传送到LCD屏幕；内置方向感应器来对动作作出反应、距离感应距离、自动关屏以节省电力并防止意外触碰、自动调节亮度、输入法预测单词或词组、语音控制功能；生物特征识别技术：人脸表情识别技术应用于人们日常生活的通信或者安全保护中医疗：虚拟现实交互技术：虚拟手术训练、远程会诊、手术规划及导航、远程协作手术等 二、感知和认知基础 一、感知模型：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26baad0cb25467ef3e890d55aa996631/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88219086e0aa6f78939ea41c807522fb/" rel="bookmark">
			专业课错题记录（王道的操作系统）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第1章 计算机系统概述1.1 操作系统的基本概念1.2 操作系统的发展与分类1.3操作系统的运行环境 第2章 进程管理2.1进程与线程2.2 处理机调度2.2.1一些易错点2.2.2 错题记录 2.3 进程同步2.3.1反思和总结2.3.2错难题 2.4 死锁 第3章 内存管理3.1内存管理概念3.1.2覆盖与交换错难题记录 3.2 虚拟内存管理 第4章 文件管理4.1 文件系统基础4.2 文件系统实现4.3 磁盘组织与管理 第5章 输入输出管理5.1 IO管理概述5.2 IO核心子系统 第1章 计算机系统概述 1.1 操作系统的基本概念 3和4选的都是D。先来看3，源程序是一种代码，编译器解释后会形成距有一定功能的可执行文件；我们用水杯和水来类比一下文件和文件内容，水杯就是文件，水就是文件内容，而操作系统关心的是文件的逻辑结构、物理结构和水杯之间的组织方式，而不关心水杯里的是水还是饮料。编译器则是一种建立在操作系统之上的软件，操作系统管不了它
1.2 操作系统的发展与分类 1.
解析：选C。首先要明确一点，一个CPU是可以有多个核心的，这样就可以单CPU同时运行多道程序了，从而在单CPU机子上实现并行
1.3操作系统的运行环境 解析：DAA
第7题解析：地址映射中的重定位离不开硬件支持
解析：BCD
解析：BC
24题解析：外中断处理时，PC值由中断隐指令自动保存
第2章 进程管理 2.1进程与线程 解析：D。这个题相当于是在问运行态在什么情况下会转到其它状态。你一开始犯的错误是，以为进程只有在进入阻塞态或者就绪态时才会放弃CPU，而实际上只要脱离了运行态，就会放弃CPU，然后CPU就会被其它进程使用
解析：B。这个题的意思是，同一个线程被不同进程调用后还是不是同一个线程。线程的调用是这样的：系统只会在内存中建立一份DLL映像（这是多进程共享的），不同进程调用线程时，都会通过系统调用跳到这个DLL映像上运行
解析：C。处理器的效率=忙的时间/（忙的时间+闲的时间）。就算就绪进程多了，CPU也会一直处于忙的状态，这与就绪进程的数量无关
解析：C。整个系统只有1个键盘，由人输入，速度很慢，完全可以用单独一个线程来处理整个键盘输入
解析：C。不选D是因为一个管道可以有多个缓冲区，这样就可以有多个读写进程了。管道的容量大小通常为内存上的一页，它的大小不受磁盘容量大小的影响
2.2 处理机调度 2.2.1一些易错点 1.计算周转时间
1）把作业到达时间和作业到达内存的时间弄混
2）计算平均周转时间时代入了错误的作业数，即比如只有4道作业，你却把总周转时间除了5
3）计算某一个作业的周转时间的时候，你容易看错某一个进程的结束时间、弄混两个进程的运行时间
4）时间片轮转算法中，你要注意的是作业A在完成了某个时间片后，如果有些作业还没有到达，比如作业B；那么作业A的下一次运行是不会排在作业B后面的
5）你容易把各作业的到达时间默认为0，解决办法是求周转时间时把到达时间和完成时间都列出来
6）看错作业的运行时间，比如0.4看成1.4，这也是01混淆的问题
2.2.2 错题记录 解析：B。作业也可以并发提交，比如mapdeduce作业提交。或者说，选最佳选项
解析：A。记住就行
解析：A。III错在中断向量本身就是中断服务例程的入口地址，因此中断向量地址便是中断服务例程入口地址的地址；IV，主要目的是快速进入中断处理程序并正确返回被中断的程序
解析：D。这道题你错在以为P2运行时，是不需要进行进程调度和切换的，这你犯了两个错误：
1）没看题，没注意到3个进程都在就绪队列里
2）不知道进程调度和切换就是对于就绪队列里的进程而言的
2.3 进程同步 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88219086e0aa6f78939ea41c807522fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce05328d204004e539c253b762f80bd8/" rel="bookmark">
			C# 委托调用带参的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Application.Current.Dispatcher.Invoke(System.Windows.Threading.DispatcherPriority.Normal, new CY_Method(NewUcTruckSampling_BrushTwice_V5_0),cardno); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/582796e902f49946d4acf10155189f25/" rel="bookmark">
			poj 1062 昂贵的聘礼
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昂贵的聘礼
Time Limit: 1000MS Memory Limit: 10000KTotal Submissions: 64699 Accepted: 19696 Description
年轻的探险家来到了一个印第安部落里。在那里他和酋长的女儿相爱了，于是便向酋长去求亲。酋长要他用10000个金币作为聘礼才答应把女儿嫁给他。探险家拿不出这么多金币，便请求酋长降低要求。酋长说："嗯，如果你能够替我弄到大祭司的皮袄，我可以只要8000金币。如果你能够弄来他的水晶球，那么只要5000金币就行了。"探险家就跑到大祭司那里，向他要求皮袄或水晶球，大祭司要他用金币来换，或者替他弄来其他的东西，他可以降低价格。探险家于是又跑到其他地方，其他人也提出了类似的要求，或者直接用金币换，或者找到其他东西就可以降低价格。不过探险家没必要用多样东西去换一样东西，因为不会得到更低的价格。探险家现在很需要你的帮忙，让他用最少的金币娶到自己的心上人。另外他要告诉你的是，在这个部落里，等级观念十分森严。地位差距超过一定限制的两个人之间不会进行任何形式的直接接触，包括交易。他是一个外来人，所以可以不受这些限制。但是如果他和某个地位较低的人进行了交易，地位较高的的人不会再和他交易，他们认为这样等于是间接接触，反过来也一样。因此你需要在考虑所有的情况以后给他提供一个最好的方案。
为了方便起见，我们把所有的物品从1开始进行编号，酋长的允诺也看作一个物品，并且编号总是1。每个物品都有对应的价格P，主人的地位等级L，以及一系列的替代品Ti和该替代品所对应的"优惠"Vi。如果两人地位等级差距超过了M，就不能"间接交易"。你必须根据这些数据来计算出探险家最少需要多少金币才能娶到酋长的女儿。
Input
输入第一行是两个整数M，N（1 &lt;= N &lt;= 100），依次表示地位等级差距限制和物品的总数。接下来按照编号从小到大依次给出了N个物品的描述。每个物品的描述开头是三个非负整数P、L、X（X &lt; N），依次表示该物品的价格、主人的地位等级和替代品总数。接下来X行每行包括两个整数T和V，分别表示替代品的编号和"优惠价格"。
Output
输出最少需要的金币数。
Sample Input
1 4 10000 3 2 2 8000 3 5000 1000 2 1 4 200 3000 2 1 4 200 50 2 0 Sample Output
5250 Source
浙江
老早看到的一道题，一直没有机会做，老经典题了。
可以把每个物品看做一个点，然而由于每个物品本身具有价值，因此我们引入点0，将物品本身的价值看做点0到该物品的价值。然后如果一个物品A可以换另一个物品B，则画一条A到B的边，最后计算点0到每个点的最短距离。（注意是谁到谁，如果弄不清楚最好画一个图再写）。
关于等级限制的问题，这里采用枚举的方法。限制是一条路中任意两个点等级差距不能超过m。然后我们每次列举当前最小等级minrank，然后去掉超出等级限制的点，最后直接跑迪杰特斯拉。
#include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;queue&gt; using namespace std; const int MAXN=120; const int inf=0x3f3f3f3f; int ma[MAXN][MAXN]; int price[MAXN],rk[MAXN]; int vis[MAXN]; void ini(int n){ memset(ma,0x3f,sizeof(ma)); for(int i=0;i&lt;=n;i++){ ma[i][i]=0; } } int dji(int n){ int dis[MAXN]; memset(dis,0,sizeof(dis)); for(int i=0;i&lt;=n;i++){ dis[i]=ma[0][i]; } vis[0]=1; for(int i=0;i&lt;n-1;i++){ int u=-1,minn=inf; for(int j=0;j&lt;=n;j++){ if(vis[j]==0&amp;&amp;minn&gt;dis[j]){ u=j;minn=dis[j]; } } vis[u]=1; for(int j=0;j&lt;=n;j++){ if(vis[j]==0&amp;&amp;dis[j]&gt;dis[u]+ma[u][j]){ dis[j]=dis[u]+ma[u][j]; } } } return dis[1]; } int main(){ int m,n; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/582796e902f49946d4acf10155189f25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adb8983ba3a439675a43f80d872d25b5/" rel="bookmark">
			什么是数据库引擎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 https://blog.csdn.net/qq_29168493/article/details/79066399
ENGINE即引擎，这指的当然不是汽车引擎，而是数据库存储引擎什么是数据库存储引擎? 数据库存储引擎：是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。MySQL的核心就是插件式存储引擎。
MySQL给用户提供了许多不同的存储引擎。在MySQL中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。Support列的值表示某种引擎是否能使用：YES表示可以使用、NO表示不能使用、DEFAULT表示该引擎为当前默认的存储引擎。
MySQL - 常见的三种数据库存储引擎
InnoDB： 支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。MyISAM： 插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比较低，也可以使用。MEMORY： 所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。同一个数据库也可以使用多种存储引擎的表。如果一个表要求比较高的事务处理，可以选择InnoDB。这个数据库中可以将查询要求比较高的表选择MyISAM存储。如果该数据库需要一个用于查询的临时表，可以选择MEMORY存储引擎。在创建表的时候通过engine=…或type=…来指定所要使用的引擎；show table status from DBname来查看指定表的引擎。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d020ecd8ea4dd00459ba83ff0c741a0/" rel="bookmark">
			Redis自动生成根据时间自增长业务序列号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.support.atomic.RedisAtomicLong; import java.text.SimpleDateFormat; import java.util.concurrent.TimeUnit; private String incr() { SimpleDateFormat f = new SimpleDateFormat("yyyyMMdd"); String key = "DH" + f.format(new Date()); String packageName = "ServiceProduct:"; RedisAtomicLong entityIdCounter = new RedisAtomicLong(packageName + key, redisTemplate.getConnectionFactory()); Long increment = entityIdCounter.getAndIncrement(); //自增长从1开始 if(increment&lt;1){ increment=entityIdCounter.getAndIncrement(); } //过期时间为一天 Integer liveTime = 1; //初始设置过期时间 if (null == increment || increment.longValue() == 0|| increment.longValue() == 1) { entityIdCounter.expire(liveTime, TimeUnit.DAYS); } //填充位数6位 return key + String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d020ecd8ea4dd00459ba83ff0c741a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95556e601f327cfc0916e22acc560bf4/" rel="bookmark">
			matlab处理时间数据绘图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 直接绘制图像函数介绍datenumdateaxis 举例一举例二 读取表格时间数据绘图 直接绘制图像 函数介绍 datenum datenum: 将日期和时间转化为日期序列值，即把日期转化成普通实数
% 常用形式：DateNumber = datenum(DateString) 将表示日期和时间的文本转换为日期序列值 % DateNumber = datenum(DateString,formatIn) 使用 formatIn 解析 DateString 所表示的日期和时间 %%%%% 举例: datenumber1=datenum('2020,9,7') datestring='24-Oct-2003 12:45:07'; formatin='dd-mmm-yyyy HH:MM:SS'; datenumber2=datenum(datestring,formatin) % 输出： % datenumber1 = % 738041 % datenumber2 = % 7.3188e+05 常用格式:
了解更多datenum
dateaxis dateaxis: 将序列日期轴标签转换为日历日期轴标签
%常用形式:dateaxis（Tickaxis，DateForm） % Tickaxis:坐标轴 % DateForm:要使用的日期格式 % 不方便单独举例,后面一起举例 日期格式对应表:
了解更多dateaxis
举例一 绘制横坐标为年月日的数据图,时间为2018.1.1到2019.1.1，以一天为时间间隔
x=linspace(datenum(2018,1,1),datenum(2019,1,1),365);%把时间以数值形式分成365份 y=rand(1,365); plot(x,y); dateaxis('x',17);%转化横坐标为相应的日期格式 xlabel('时间'); ylabel('数据'); 结果展示:
举例二 绘制横坐标为时分的数据图,时间为6:30到9:30,以15min为时间间隔
x=linspace(datenum('6:30','HH:MM'),datenum('9:30','HH:MM'),12);% 时间分成12份，使得时间间隔为15min y=rand(1,12); plot(x,y,'-o'); xlabel('时间'); ylabel('数据'); dateaxis('x',15); 结果展示:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95556e601f327cfc0916e22acc560bf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79bb1b10c5e090a21148ef5bbf1890bd/" rel="bookmark">
			白噪声检验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		白噪声检验：
对数据序列的随机性做假设检验。
可以用的方法：Ljung_Box检验。 python acorr_ljungbox()函数。
from statsmodels.stats.diagnostic import acorr_ljungbox print(u'白噪声检验结果：',acorr_ljungbox(data, lags=2))#返回统计量和p值 lags为检验的延迟数 原假设：是随机的，既是白噪声序列。
它主要返回一个p值。
p值大，接受原假设；p值小，拒绝原假设。分割线：0.05。
0.05置信区间以下，可以认为出现显著的自回归关系，且序列为非白噪声。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cb7a9812bc3b28c22603e53a357aa39/" rel="bookmark">
			剑指大厂 | 线程的交替打印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载本文章请标明作者和出处
本文出自《爱喝纯净水的南荣牧歌》
开始行动，你已经成功一半了，献给正在奋斗的我们 一个线程持有1到26,一个线程持有a到z，如何让这两个线程交替打印，输出1 a 2 b … 26 z
这道题最简单的做法就是使用信号量Semaphore。
Semaphore中初始的许可个数是Semaphore s1 = new Semaphore(1)，构造函数中的数字。
每执行一次acquire()方法，则需要消耗一个许可，每执行一次release()就会释放一个许可。
利用这个特性，就可以写出如下的代码。
/** * 线程交替打印样例 * * @author yanghang */ public class AlternatePrintingDemo { public static void main(String[] args) { Semaphore s1 = new Semaphore(1); Semaphore s2 = new Semaphore(0); Thread t1 = new Thread(() -&gt; { try { for (int i = 1; i &lt; 27; i++) { s1.acquire(); System.out.println(i); s2.release(); } } catch (Exception ex) { ex.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cb7a9812bc3b28c22603e53a357aa39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d5711d1a08e406b147694a5fd06b407/" rel="bookmark">
			剑指大厂 | 如何让线程按照顺序执行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转载本文章请标明作者和出处
本文出自《爱喝纯净水的南荣牧歌》
本文题目和部分解题思路来源自《剑指offer》第二版
开始行动，你已经成功一半了，献给正在奋斗的我们 这道题很简单，主要考察你对join函数的认知，一般会在大厂面试的时候第一轮电话面试的时候考察。
ps： join方法要在start之后调用，调用之后，当前线程会等待join的线程执行之后再执行。
public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -&gt; { System.out.println("t1被执行了"); }); Thread t2 = new Thread(() -&gt; { System.out.println("t2被执行了"); }); Thread t3 = new Thread(() -&gt; { System.out.println("t3被执行了"); }); t2.start(); t2.join(); t1.start(); t1.join(); t3.start(); t3.join(); } 打印結果：
t2被执行了 t1被执行了 t3被执行了 喜欢的朋友可以加我的个人微信，我们一起进步 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/93/">«</a>
	<span class="pagination__item pagination__item--current">94/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/95/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>