<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c62e0f6521d0339d0b49db96984596d/" rel="bookmark">
			Oracle 分页查询方法和效率分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Oracle 12c fetch抓取记录
查询前10行记录
# fetch first 10 rows only
查询6至10行记录
# offset 5 rows fetch next 5 rows only
按百分比查询
# offset 10 rows fetch next 10 percent rows only
2.利用伪列rownum嵌套分页抓取记录
select * from
(select rownum as rn,t1.* from where rownum &lt;= 10) t2
where rn &gt;= 5
注:效率最高,几乎不受影响,但是SQL主体和分页操作不分离,不利于程序开发
select * from
(select rownum as rn,t1.* from
(select * from test) t1 where rownum &lt;= 10) t2
where rn &gt;= 5
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c62e0f6521d0339d0b49db96984596d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0abccf4c8326d5c3e7f6a0eb8f9cc6a3/" rel="bookmark">
			window 10 环境下Python 2与Python 3共存以及virtualenv的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载安装在这里不累述了，去官网下载安装即可，注意安装时候选择添加到系统的环境变量。
Python 2 和 Python 3安装好之后，打开安装的路径，将对应的python.exe文件改成各自的版本号的python2.exe python3.exe 。
使用时候直接在cmd中输入python 2或者 python 3 ：
pip的使用：
pythonX -m pip install/list 在python3环境下新建env（要先安装vritualenv模块），对开发环境进行隔离：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93d29163cbdaac9115b66c48aeabcd62/" rel="bookmark">
			spring boot 过滤器、拦截器的区别与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拦截器与过滤器的区别： 1、过滤器和拦截器触发时机不一样，过滤器是在请求进入容器后，但请求进入servlet之前进行预处理的。请求结束返回也是，是在servlet处理完后，返回给前端之前。 如下图： 2、拦截器可以获取IOC容器中的各个bean，而过滤器就不行，因为拦截器是spring提供并管理的，spring的功能可以被拦截器使用，在拦截器里注入一个service，可以调用业务逻辑。而过滤器是JavaEE标准，只需依赖servlet api ，不需要依赖spring。
过滤器拦截器运行先后步骤： 其中第2步，SpringMVC的机制是由DispaterServlet来分发请求给不同的Controller，其实这一步是在Servlet的service()方法中执行的.
3、过滤器的实现基于回调函数。而拦截器（代理模式）的实现基于反射，代理分静态代理和动态代理，动态代理是拦截器的简单实现。
何时使用拦截器？何时使用过滤器？
如果是非spring项目，那么拦截器不能用，只能使用过滤器。如果是处理controller前后，既可以使用拦截器也可以使用过滤器。如果是处理dispaterServlet前后，只能使用过滤器。 spring boot 使用过滤器 两种方式： 1、使用spring boot提供的FilterRegistrationBean注册Filter 2、使用原生servlet注解定义Filter 两种方式的本质都是一样的，都是去FilterRegistrationBean注册自定义Filter
方式一: ①、先定义Filter：
package com.hwm.filter; import javax.servlet.*; import java.io.IOException; public class MyFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { // do something 处理request 或response System.out.println("filter1"); // 调用filter链中的下一个filter filterChain.doFilter(servletRequest,servletResponse); } @Override public void destroy() { } } ②、注册自定义Filter
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93d29163cbdaac9115b66c48aeabcd62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/988727a4cb402988ced86e7ac7fc300d/" rel="bookmark">
			gcc警告选项汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考资料:https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options
请求或取消警告的选项
警告是诊断消息，报告的结构本质上不是错误的，但是有风险或表明可能有错误。
以下与语言无关的选项不会启用特定的警告，但会控制GCC生成的诊断类型。
-fsyntax-only
检查代码中的语法错误，但除此之外不要做任何事情。
-fmax-errors= n
将错误消息的最大数量限制为n ，此时GCC会缓存，而不是尝试继续处理源代码。 如果n为0（默认值），则生成的错误消息数量不受限制。 如果还指定了-Wfatal-errors ，则重大错误优先于此选项。
-w
禁止所有警告消息。
-Werror
使所有的警告进入错误。
-Werror=
将指定的警告转换为错误。 附加警告的说明符; 例如-Werror =开关将由-Wswitch控制的警告转换为错误。 此开关采用否定形式，用于否定-针对特定警告的错误; 例如-Wno-error =开关使得-wswitch警告不是错误，即使在-Werror有效时也是如此。
每个可控警告的警告消息都包含控制警告的选项。 那么该选项可以与-Werror =和-Wno-error =一起使用 ，如上所述。 （可以使用-fno-diagnostics-show-option标志禁用警告消息中的选项打印。）
请注意，指定-Werror = foo会自动隐含-W foo 。 但是， -Wno-error = foo并不意味着什么。
-Wfatal-errors
此选项会导致编译器在发生第一个错误时中止编译，而不是尝试继续并打印更多错误消息。
例如，您可以使用以“ -W ”开头的选项来请求许多特定的警告 - 可以隐式地请求隐式声明的警告。 这些特定警告选项中的每一个都有一个以“ -Wno- ”开始的否定形式来关闭警告; 例如， -Wno-implicit 。 本手册仅列出两种形式中的一种，无论哪种都不是默认值。 有关其他语言特定的选项，还可以参考C ++ Dialect Options和Objective-C以及Objective-C ++ Dialect Options 。
某些选项（如-Wall和-Wextra ）会打开其他选项，例如-Wunused ，这可能会启用其他选项，例如-Wunused-value 。 正面和负面形式的综合作用是，更具体的选项优先于不特定的选项，与命令行中的位置无关。 对于相同特征的选项，最后一个生效。 通过编译指示启用或禁用的选项（请参阅诊断编译指示 ）将起作用，就好像它们出现在命令行末尾一样。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/988727a4cb402988ced86e7ac7fc300d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91e097994378152edd48eb5fbac99317/" rel="bookmark">
			TreeSize Free 软件简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TreeSize Free 是一个免费的检查文件夹大小的工具，便于找出哪个文件占用了较多的磁盘空间。
主页地址： https://www.jam-software.de 下载地址： https://www.jam-software.com/treesize_free/TreeSizeFree-Portable.zip
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83fa1cf0cacc49ba7118f17de352e1bf/" rel="bookmark">
			django搭建一个小型的服务器运维网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 不管是运维还是开发抑或是测试，工作中不免会和Linux服务器打交道，常见的操作譬如：查看CPU或内存状态、查看和修改服务器时间、查看或者修改服务器配置文件、实时查看或回看系统的日志、重启服务器中某个进程等。如果不在服务器旁，一般会选择利用Xshell这样的远程SSH工具登陆到服务器去执行所需操作。如果有一个Web工具，该工具将会很方便的给目标用户提供服务，对于开发来说，可以更注重自己代码本身，对于运维而言可以方便直接的知道服务器的状态，对于测试人员而言，提高测试的效率。
本人在开发这个基于django的Web工具前并没有网站开发经验，都是摸着石头过河，所以在开发过程中遇到很多的问题，并且逐个解决并达成需求，其中也直接拿来一些代码复用。这些文章中会包含一些前端的技术(websocket、ajax、路由)和一些后端的小模块(paramiko、openid、webserver、MySQL)，在这些小零件的拼凑中又会衍生很多小的细节和方法。此篇文章会做一个回顾，虽然很多功能有更好的实现方法，里面涉及的技术难度也不大，但是也希望能够帮助到有需求的童鞋。
内容介绍 文章默认读者已经具备了django的开发经验，文章直接略过了纷繁的初学内容，直接开始小项目，主要内容包括：
拿来即用的bootstrap模板； 服务器SSH服务配置与python中paramiko的使用； 用户登陆与session; 最简单的实践之修改服务器时间； 查看和修改服务器配置与数据库的路由； 基于websocket的实时日志实现； 查看服务器中的日志与前端的datatable的利用； 重启服务器进程。 这些功能其实都很简单，就像搭积木一样，关键是遇到和解决的问题是否可以让需要的童鞋少走一点弯路。网站风格如下图1和图2所示(这里是主页面，没有截登陆界面和其他功能界面):
源码 环境 python版本：python2.7
django版本：python-django-1.11
数据库：Mysql
MySQL_python连接库：https://pan.baidu.com/s/14WpD... 密码：0h5h
源码 网站的源码链接：https://pan.baidu.com/s/1uix-... 密码：j4sw
DASHGUM前端模板：https://pan.baidu.com/s/1FHCX... 密码：bo8d
用法 本地把网站跑起来需要改改下列这些地方。
settings中的服务器登陆配置：
有私钥的需要把私钥放在WebTool/WebTool下面：
在functions中修改一些服务器路径和命令行：
结语 这个小项目用到的技术并不多，但是基本上可以实现和服务器的交互，都是通过网站调用python中的paramiko模块和服务器交互。虽然网站的功能不多，但是其中的交互思路可以举一反三写出更多的功能页(例如：CPU，内存预警等等)，有些复杂的服务器功能最好是在服务器中写好shell脚本供给网站后台调用，前端的部件基本都可以在DASHGUM中找到适合的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c6f30992cad3f7588e2583428f6f507/" rel="bookmark">
			C#子类重写父类函数的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）使用Virtual关键字Override从写
父类子类代码如下，不能修改public 为其它权限
public virtual void Clear() { UpdateView(); } public override void Clear() { base.Clear(); } （2）使用new覆盖
可以从写public 为private
public void Clear() { UpdateView(); } private new void Clear() { base.Clear(); } 转载于:https://www.cnblogs.com/zhaogaojian/p/8658377.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8f118b0f8c038430638d91504127a37/" rel="bookmark">
			域环境下普通用户权限无法运行程序解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了更好的对客户端权限进行管理和控制，推荐的做法是，我们只赋予终端用户Domain User组的权限。但有些需要Local Administrator权限的软件就无法安装和运行。我目前能想到的办法是：
a.所有软件都安装在固定的Program Files目录，并通组策略赋予Program Files目录Domain Users组完全控制权限
b.通过组策略赋予注册表HKLM_SOFTWARE键Domain Users组完全控制权限
c.通过组策略赋予Domain Users组system32目录完全控制权限
通过以上3个地方的修改，90%的软件都可以正常运行了
转载于:https://blog.51cto.com/terry520/2089468
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c92bf73159dfdf8d75bacae9c118d9b/" rel="bookmark">
			C与OC、C&#43;&#43;的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C与OC、C++的区别 C语言的特点：
1）C语言是结构化语言，层次清晰，调试和维护比较容易
2）表现能力和处理能力比较强，可直接访问内存的物理地址
3）c语言实现对硬件的编辑，c语言课用语系统软件的开发，也可用语应用软件的开发，是集高级语言和低级语言的功能一体。
4）C语言效率高，可移植性强。
C++语言特点：
1、在C语言的基础上进行扩充和完善，使C++兼容了C语言的面向过程特点，又成为了一种面向对象的程序设计语言；
2、可以使用抽象数据类型进行基于对象的编程；
3、可以使用多继承、多态进行面向对象的编程；
4、可以担负起以模版为特征的泛型化编程。
OC的特点：
2、Objective-C，扩展了C 语言使它具备面向对象设计的能力，例如类、消息、继承；同时在Objective-C的代码中可以有C和C++语句，它可以调用C的函数，也可以通过C++对象访问方法；
3、Objective-C可以实现底层系统编程，另一方面可以支持利用动态架构进行开发。
OC与C语言的区别
OC里中兼容C语言的语法可以两者混合编码。 OC是面向对象的,有类,对象的概念，C语言没有
C是面向过程的语言
OC的和C++的区别：
1、继承：Objective-C与不支持多重继承，而C++语言支持多重继承（从侧面可以说明多重继承的效率不高）；
2、函数调用：Objective-C通过互相传递消息实现函数调用，而C++直接进行函数调用
3、定型：Objective-C是动态定型。所以它的类库比C++要容易操作。Objective-C 在运行时可以允许根据字符串名字来访问方法和类，还可以动态连接和添加类。而C++，对象的静态类型决定你是否可以发送消息给它。
4、接口：Objective-C采用protocol协议（非正式和正式）的形式来定义接口，而C++采用虚函数的形式来定义接口。
5、方法重载：c++中允许两个方法的名字相同，参数个数相同，但是参数类型不同，以及不同的返回值类型。而OC中不允许同一个类中两个方法有相同的名字，参数个数相同，参数类型不同。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfeba605f0fcc624da42f290f7086316/" rel="bookmark">
			PostgreSQL报pg_dump: no matching tables were found错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚导出表时，发现找不到这个表，但是表是存在的，所以找了一圈，发现是要加\才行，
例如：\"T_TABLES\"
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7db6a6312bc4db9b7bf28a6513f358f5/" rel="bookmark">
			ok实例项目vs2010下报错的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		同样的代码实例vc6.0编译的正常运行，在vs2010及以上版本新建的项目中编译的不能运行。当调用okConvertRect时总是返回0，
表示转化错误。没有说明原因。经过多方实验只要将编译环境设置一下就可.
1 :项目属性中 c++--&gt;代码生成 --&gt;结构成员对其--&gt;1个字节或者2字节.
2: 或者局部块级结构体对齐,
#pragma pack (push,2)
typedef struct _blockinfo {
SHORT iType; //=BK or SQ, BM
//struct _blocksize;
SHORT iWidth; //width *
SHORT iHeight; //height *
SHORT iBitCount; //pixel bytes iBitCount *
SHORT iFormType; //rgb format type, need to fill when RGB565 or RGB 555
union {
struct {
SHORT lBlockStep; //block stride (step to next image header)
SHORT iHiStep;// HIWORD of block stride
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7db6a6312bc4db9b7bf28a6513f358f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8767c2475da19a43df6803c3497c69c1/" rel="bookmark">
			mysql创建数据库，并且指定编码utf8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 CREATE DATABASE `mydb` CHARACTER SET utf8 COLLATE utf8_general_ci; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18590f04680f15b76799cdce643ea2cb/" rel="bookmark">
			C#中的static静态变量的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		静态全局变量 定义：在全局变量前，加上关键字 static 该变量就被定义成为了一个静态全局变量。
特点： A、该变量在全局数据区分配内存。 B、初始化：如果不显式初始化，那么将被隐式初始化为0。
静态局部变量 定义：在局部变量前加上static关键字时，就定义了静态局部变量。
特点： A、该变量在全局数据区分配内存。 B、初始化：如果不显式初始化，那么将被隐式初始化为0。 C、它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。
静态数据成员 特点： A、内存分配：在程序的全局数据区分配。 B、初始化和定义： a、静态数据成员定义时要分配空间，所以不能在类声明中定义。 b、为了避免在多个使用该类的源文件中，对其重复定义，所以，不能在类的头文件中定义。 c、静态数据成员因为程序一开始运行就必需存在，所以其初始化的最佳位置在类的内部实现。 C、特点 a、对相于 public,protected,private 关键字的影响它和普通数据成员一样， b、因为其空间在全局数据区分配，属于所有本类的对象共享，所以，它不属于特定的类对象，在没产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它。 D、访问形式 a、 类对象名.静态数据成员名 E、静态数据成员，主要用在类的所有实例都拥有的属性上。比如，对于一个存款类，帐号相对于每个实例都是不同的，但每个实例的利息是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局区的内存，所以节省存贮空间。第二，一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了，因为它们实际上是共用一个东西。
静态成员函数 特点： A、静态成员函数与类相联系，不与类的对象相联系。 B、静态成员函数不能访问非静态数据成员。原因很简单，非静态数据成员属于特定的类实例。 作用： 主要用于对静态数据成员的操作。
调用形式： 类对象名.静态成员函数名（）
static静态变量的实例与分析 class class1 { static int i = getNum(); int j = getNum(); static int num = 1; static int getNum() { return num; } static void Main(string[] args) { Console.WriteLine("i={0}",i); Console.WriteLine("j={0}", new class1().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18590f04680f15b76799cdce643ea2cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/533f6c955b3e8001bc4b3d85be9468b2/" rel="bookmark">
			C语言数据结构之利用栈进行括号匹配的检验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		括号匹配的检验:
eg: [([][][)]] 不匹配
[([][])] 匹配
思路： 0x0.首先建立两个栈，并对其初始化 0x1.对表达式进行遍历，将相邻两个不能匹配的入栈到栈A，然后检测栈空间A是否为偶数，如果是表明有存在的可能，如果不是则提示不匹配。
0x2.检测栈空间A是否为偶数，如果是表明有存在的可能，如果不是则提示不匹配，遍历栈A，将不匹配的入栈到栈B，如果匹配则判断是否是最后两个元素，如果是表明匹配
0x3.判断出栈前的A和栈B长度是否相等，如果相等表明不匹配。
0x4.栈A和栈B互换，重复步骤0x2,直到都为空.
运行截图： 代码：
Stack.h
#ifndef _STACK_H_ #define _STACK_H_ #include &lt;stdbool.h&gt; #define STACK_INIT_SIZE 100 //栈控件初始化大小 #define STACK_INCREMENT 10 //栈控件增量 typedef struct{ void * base;//栈底 void * top;//栈顶 int stackSize;//当前已经分配的存储空间 int elementLength; }SqStack; typedef enum{ FAILED,SUCCESS }Status; Status initStack(SqStack * pStack,int elength); void destroyStack(SqStack * pStack); void clearStack(SqStack * pStack);//将栈置空 bool stackIsEmpty(SqStack * pStack); int stackLength(const SqStack * pStack); void * getTop(SqStack * pStack); void push(SqStack * pStack,void *data);//压栈 void pop(SqStack * pStack,void *data);//出栈,若不空删除栈顶元素并将其值返回 void * get(SqStack * pStack,int i);//获取栈的第i个位置的元素 /** * 输出栈中每个元素，如果direction为正则从头到尾输出，反之从尾到头输出.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/533f6c955b3e8001bc4b3d85be9468b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ae7dcf01597bd4df7acd6032ed34026/" rel="bookmark">
			x射线图像去坏点算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		void ShotNoise(unsigned short *data,int width,int height) { int hei_1 = height - 1; int wid_1 = width - 1; double value,tmpval; unsigned short *pixel=new unsigned short[width*height]; memcpy(pixel,data,width*height*2); if (hei_1&gt;1) { //第二行第二个 unsigned short * des1_1=data+width+1; unsigned short * src1=pixel+2; unsigned short * src2=pixel+width+2; unsigned short * src3=pixel+width+width+2; int i=0; int hei_2=hei_1-1; int wid_2 = wid_1 - 1; double d1_1,d1_2,d1_3,d2_1,d2_3,d3_1,d3_2,d3_3; for (i=0;i&lt;hei_2;i++) { unsigned short *s1=src1; unsigned short *s2=src2; unsigned short *s3=src3; unsigned short *desp=des1_1; for (int j=0;j&lt;wid_2;j++) { d1_1 = (double)*(s1 - 2); d1_2 = (double)*(s1 - 1); d1_3 = (double)*s1; d2_1 = (double)*(s2 - 2); d2_3 = (double)*s2; d3_1 = (double)*(s3 - 2); d3_2 = (double)*(s3 - 1); d3_3 = (double)*s3; value = (d3_1 + d3_3 + d3_2 + d2_3 + d2_1 + d1_3 + d1_2 + d1_1) * 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ae7dcf01597bd4df7acd6032ed34026/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce14496beceb177bd6bb2eac1afb9cf5/" rel="bookmark">
			浅谈  %*c  的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在一次偶然的机会接触到了%*c ，整理了这篇博文，希望能给大家带来帮助，如果大家有不同的借鉴，希望能够加以评论
- - - - - - - - - - - - - - - - - - 正题分割线- - - - - - - - - - - - - - - - - - - - - - 用在scanf中的格式符号，%d 是很常见的输入一个整形数据，并存在一个整形变量中
%*c 带有 * 表示忽略，在输入流中，读取一个字符，但是不会赋值给任何变量
举个栗子
描述 已知w是一个大于10但不大于1000000的无符号整数，若w是n(n≥2)位的整数，则求出w的后n-1位的数。
输入 第一行为M，表示测试数据组数。 接下来M行，每行包含一个测试数据。 输出 输出M行，每行为对应行的n-1位数（忽略前缀0）。如果除了最高位外，其余位都为0，则输出0。 样例输入 4 1023 5923 923 1000 样例输出 23 923 23 0 #include&lt;bits/stdc++.h&gt; using namespace std; int main(){ int T,n; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce14496beceb177bd6bb2eac1afb9cf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05cb11da1ad38adccbca0b3cc08b2ab0/" rel="bookmark">
			P3313 [SDOI2014]旅行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树链剖分+有颜色的线段树
// luogu-judger-enable-o2 #include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; const int M=4120000,N=420000; int tot,cnt,n,m,root[N],nex[2*N],head[N],to[2*N],c[N],d[N],f[N],dep[N]; int size[N],son[N],top[N],id[N],cnt2,v1[N],v2[N],q; struct node{ int ls,rs,sum,maxn,num; node(){ls=rs=maxn=sum=0;} }t[M]; void add(int x,int y){nex[++tot]=head[x];to[tot]=y;head[x]=tot;} void dfs1(int x){ size[x]=1;dep[x]=dep[f[x]]+1; for(int i=head[x],tmp;i;i=nex[i]){ if((tmp=to[i])==f[x]) continue; f[tmp]=x;dfs1(tmp); if(size[son[x]]&lt;size[tmp]) son[x]=tmp; size[x]+=size[tmp]; } } void dfs2(int x,int t){ top[x]=t;id[x]=++cnt2;v1[cnt2]=c[x];v2[cnt2]=d[x]; if(!son[x])return;dfs2(son[x],t); for(int i=head[x];i;i=nex[i]) if(!id[to[i]]) dfs2(to[i],to[i]); } void update(int x){ t[x].sum=t[t[x].ls].sum+t[t[x].rs].sum; t[x].maxn=max(t[t[x].ls].maxn,t[t[x].rs].maxn); } void modify(int &amp;o,int l,int r,int id,int d){ if(id&gt;r||id&lt;l) return ;if(!o) o=++cnt; if(l==r&amp;&amp;l==id){ t[o].sum=t[o].maxn=d;return ; } int mid=(l+r)&gt;&gt;1; modify(t[o].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05cb11da1ad38adccbca0b3cc08b2ab0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f5ba8b70ffead91ef52e146bf2f3998/" rel="bookmark">
			C语言数据结构之逆波兰表达式求值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		逆波兰表达式又叫做后缀表达式。在通常的表达式中，二元运算符总是置于与之相关的两个运算对象之间，这种表示法也称为中缀表示。波兰逻辑学家J.Lukasiewicz于1929年提出了另一种表示表达式的方法，按此方法，每一运算符都置于其运算对象之后，故称为后缀表示。
eg:1+1
逆波兰表达式：1 1 +
eg:1+(2-1)*3
逆波兰表达式:1 2 1 - 3 * +
实现截图：
Stack.h
#ifndef _STACK_H_ #define _STACK_H_ #include &lt;stdbool.h&gt; #define STACK_INIT_SIZE 100 //栈控件初始化大小 #define STACK_INCREMENT 10 //栈控件增量 typedef struct{ void * base;//栈底 void * top;//栈顶 int stackSize;//当前已经分配的存储空间 int elementLength; }SqStack; typedef enum{ FAILED,SUCCESS }Status; Status initStack(SqStack * pStack,int elength); void destroyStack(SqStack * pStack); void clearStack(SqStack * pStack);//将栈置空 bool stackIsEmpty(SqStack * pStack); int stackLength(const SqStack * pStack); void * getTop(SqStack * pStack); void push(SqStack * pStack,void *data);//压栈 void pop(SqStack * pStack,void *data);//出栈,若不空删除栈顶元素并将其值返回 void * get(SqStack * pStack,int i);//获取栈的第i个位置的元素 /** * 输出栈中每个元素，如果direction为正则从头到尾输出，反之从尾到头输出.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f5ba8b70ffead91ef52e146bf2f3998/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfec4dac38a17b394a61f5859ff01c31/" rel="bookmark">
			C语言实现Vigenere(维吉利亚)加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		维吉尼亚密码 人们在单一 恺撒密码的基础上扩展出多表密码，称为“维吉尼亚”密码。该方法最早记录在 吉奥万·巴蒂斯塔·贝拉索（ Giovan Battista Bellaso）于1553年所著的书《吉奥万·巴蒂斯塔·贝拉索先生的密码》（意大利语：La cifra del. Sig. Giovan Battista Bellaso）中。 维吉尼亚密码引入了“ 密钥”的概念，即根据密钥来决定用哪一行的密表来进行替换，以此来对抗字频统计。假如以上面第一行代表明文字母，左面第一列代表密钥字母，对如下明文加密： TO BE OR NOT TO BE THAT IS THE QUESTION 当选定RELATIONS作为密钥时，加密过程是：明文一个字母为T，第一个密钥字母为R，因此可以找到在R行中代替T的为K，依此类推，得出对应关系如下： 密钥:RELAT IONSR ELATI ONSRE LATIO NSREL 明文:TOBEO RNOTT OBETH ATIST HEQUE STION 密文:KSMEH ZBBLK SMEMP OGAJX SEJCS FLZSY 历史上以维吉尼亚密表为基础又演变出很多种加密方法，其基本元素无非是密表与密钥，并一直沿用到二战以后的初级电子密码机上。 公元16世纪晚期，想要获得更高的保密度的人获得了一种设计更加精细的密码表。 实现图片：
实现代码：
#include &lt;stdio.h&gt; #include &lt;malloc.h&gt; #include &lt;stdlib.h&gt; #include &lt;memory.h&gt; #define MAXSIZE 1000 typedef struct duplexNode{ char alphabet; struct duplexNode * previous; struct duplexNode * next; }DuplexNode,*DuplexLinkList; typedef enum{ FAILED,SUCCESS }Status; Status initDuplexLinkList(DuplexLinkList * duplexLinkList); void vigenere(DuplexLinkList *duplexLinkList,char al,int n); char * s_gets(char * s,int n); int main(void) { char str_temp[MAXSIZE] = {'\0'}; int rand_temp[MAXSIZE] = {0}; int j = 0; DuplexLinkList duplexLinkList = NULL; if(initDuplexLinkList(&amp;duplexLinkList) == FAILED) { fprintf(stderr,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfec4dac38a17b394a61f5859ff01c31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d534b60c4601c31d657d066d6299b6a6/" rel="bookmark">
			C语言数据结构之如何快速查找链表的中间节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腾讯面试题：如何快速查找指定链表的中间节点？
解法1：遍历法。
先遍历一遍统计链表长度，然后再遍历长度的1/2便即是中间节点。
时间复杂度O(3n/2)
解法2：快慢指针。（推荐）
设置两个指向链表头结点的指针，一个指针的遍历速度是另一个指针的2倍，当快的指针遍历完毕，慢指针即是中间节点。
时间复杂度O(n/2)
解法二比解法一速度快了足足3倍，可见算法的威力。
解法二代码：
LinkList.h
#ifndef _LINK_LIST_H_ #define _LINK_LIST_H_ #include &lt;stdbool.h&gt; struct Node{ int key; int value; struct Node * next; struct Node * previous; }; typedef struct linkList{ int length; struct Node * item; }LinkList; //初始化链表 void initLinkList(LinkList * pLinkList); //销毁链表 void destroyLinkList(LinkList * pLinkList); //在链表尾部添加节点 bool addNode(LinkList * pLinkList,struct Node * node); //在指定位置插入节点 bool insertNode(LinkList * pLinkList,struct Node * node,int pos); //通过key移除指定节点 bool removeById(LinkList * pLinkList,int key); //通过key修改指定节点的value bool updateById(LinkList * pLinkList,int key,int value); //通过key查找指定节点 struct Node * findByKey(LinkList * pLinkList,int key); //将每个函数应用于节点 void Traverse(LinkList * pLinkList,void (*pfun)(struct Node * node)); //判断位置是否在链表范围内 bool isObtains(LinkList * pLinkList,int pos); //key所在节点是否存在 bool isExistKey(LinkList * pLinkList,int key); #endif LinkList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d534b60c4601c31d657d066d6299b6a6/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/115/">«</a>
	<span class="pagination__item pagination__item--current">116/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/117/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>