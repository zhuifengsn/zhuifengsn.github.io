<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/495551d6ce0e2c2d9da16e0218e6c78a/" rel="bookmark">
			STM32采用串口DMA方式，用115200bps或更高速率向上位机连续发送数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、DMA的基本介绍1.DMA的定义2.DMA传输方式3.DMA传输参数4.DMA的主要特征5.DMA库函数配置过程6.STM32中的DMA7.DMA中断8.DMA方式的接口函数 二、DMA方式实现串口通信1.STM32CubeMX工程创建2.程序编写3.程序编译及hex文件创建4.电路连接5.程序烧录6.串口调试7.运行结果 三、总结四、参考链接 一、DMA的基本介绍 1.DMA的定义 DMA，全称Direct Memory Access，即直接存储器访问。DMA用来提供在外设和存储器之间或者存储器和存储器之间的高速数据传输。无须CPU的干预，通过DMA数据可以快速地移动。这就节省了CPU的资源来做其他操作。
2.DMA传输方式 ◉DMA的作用就是实现数据的直接传输，而去掉了传统数据传输需要CPU寄存器参与的环节，主要涉及四种情况的数据传输，但本质上是一样的，都是从内存的某一区域传输到内存的另一区域（外设的数据寄存器本质上就是内存的一个存储单元）。四种情况的数据传输如下：外设到内存、内存到外设、内存到内存、外设到外设
◉（1）方法1：DMA_Mode_Normal，正常模式，
当一次DMA数据传输完后，停止DMA传送 ，也就是只传输一次　（2）方法2：DMA_Mode_Circular ，循环传输模式
当传输结束时，硬件自动会将传输数据量寄存器进行重装，进行下一轮的数据传输。 也就是多次传输模式
3.DMA传输参数 我们知道，数据传输，首先需要的是1 数据的源地址 2 数据传输位置的目标地址 ，3 传递数据多少的数据传输量 ，4 进行多少次传输的传输模式 DMA所需要的核心参数，便是这四个。当用户将参数设置好，主要涉及源地址、目标地址、传输数据量这三个，DMA控制器就会启动数据传输，当剩余传输数据量为0时 ，达到传输终点，结束DMA传输 ，当然，DMA 还有循环传输模式 ，当到达传输终点时会重新启动DMA传输。也就是说只要剩余传输数据量不是0，而且DMA是启动状态，那么就会发生数据传输。
4.DMA的主要特征 每个通道都直接连接专用的硬件DMA请求，每个通道都同样支持软件触发。这些功能通过软件来配置；
◉在同一个DMA模块上，多个请求间的优先权可以通过软件编程设置（共有四级：很高、高、中等和低），优先权设置相等时由硬件决定（请求0优先于请求1，依此类推）；
◉独立数据源和目标数据区的传输宽度（字节、半字、全字），模拟打包和拆包的过程。源和目标地址必须按数据传输宽度对齐；
◉支持循环的缓冲器管理；
◉每个通道都有3个事件标志（DMA半传输、DMA传输完成和DMA传输出错），这3个事件标志逻辑或成为一个单独的中断请求；
◉存储器和存储器间的传输、外设和存储器、存储器和外设之间的传输；
◉闪存、SRAM、外设的SRAM、APB1、APB2和AHB外设均可作为访问的源和目标；
◉可编程的数据传输数目：最大为65535。
5.DMA库函数配置过程 （1）使能DMA时钟：RCC_AHBPeriphClockCmd();
（2）初始化DMA通道：DMA_Init();
//设置通道；传输地址；传输方向；传输数据的数目；传输数据宽度；传输模式；优先级；是否开启存储器到存储器。
（3）使能外设DMA；
（4）使能DMA通道传输；
（5）查询DMA传输状态。
6.STM32中的DMA 对于大容量的STM32芯片有2个DMA控制器 两个DMA控制器，DMA1有7个通道，DMA2有5个通道。每个通道都可以配置一些外设的地址。
上方的框图，我们可以看到STM32内核，存储器，外设及DMA的连接，这些硬件最终通过各种各样的线连接到总线矩阵中，硬件结构之间的数据转移都经过总线矩阵的协调，使各个外设和谐的使用总线来传输数据。
7.DMA中断 每个DMA通道都可以在DMA传输过半、传输完成和传输错误时产生中断。为应用的灵活性考虑，通过设置寄存器的不同位来打开这些中断。
使没开启，我们也可以通过查询这些位来获得当前 DMA 传输的状态。这里我们常用的是 TCIFx位，即数据流 x 的 DMA 传输完成与否标志。
可编程的数据传输宽度、对齐方式和数据大小端
当PSIZE和MSIZE不相同时，DMA模块按照下图进行数据对齐。
注意：在大容量产品中， DMA2 通道 4 和 DMA2 通道 5 的中断被映射在同一个中断向量上。在互联型产品 中， DMA2 通道 4 和 DMA2 通道 5 的中断分别有独立的中断向量。所有其他的 DMA 通道都有自己的中断向量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/495551d6ce0e2c2d9da16e0218e6c78a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89715876c5ba756f1f39d86f16f01d40/" rel="bookmark">
			采用串口中断方式实现串口通信：停止/持续发送“hello windows!”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、stm32接收到字符“s”/“t”时停止/持续发送“hello windows!”1.STM32CubeMX工程创建2.程序编写3.程序编译及hex文件创建4.电路连接5.程序烧录6.串口调试7.运行结果 二、stm32接收到字符串“stop stm32!”/“go stm32!”时停止/持续发送“hello windows!”1.STM32CubeMX工程创建2.程序编写3.程序编译及hex文件创建4.电路连接5.程序烧录6.串口调试7.运行结果 三、总结四、参考链接 一、stm32接收到字符“s”/“t”时停止/持续发送“hello windows!” 1.STM32CubeMX工程创建 （1）打开STM32CubeMX主界面，点击“ACCESS TO MCU SELECTOR”,创建新项目
（2）在“Commerical Part Number”里面选择自己需要的芯片，点击信息栏中的具体芯片信息选中，再点击“Start Project”
（3）先点击System Core将其展开，再点击RCC，将HSE设置为Crystal/Ceramic Resonator
（4）点击SYS，将Debug设置为Serial Wire
（5）先点击Connectivity将其展开，再点击USART1，将Mode设置为Asynchronous
（6）点击NVIC，勾选USART1 global interrupt
（7）勾选PLLCLK和HSE，将晶振频率设置为最大值72MHz
（8）点击Project Manager→Project，配置好自己的项目名和项目存放路径，然后将Application Structure设置为Basic，将IDE设置为MDK-ARM
（9）点击Code Generate界面，选择生成初始化文件.c/.h，之后再点击GENERATE CODE即可成功创建工程
2.程序编写 （1）在点击GENERATE CODE之后弹出来的界面点击Open Project即可跳转到Keil5进行程序编写
（2）打开main.c文件
在main函数前定义全局变量
char c;//指令 0:停止 1:开始 char message[]="hello windows!\n";//输出信息 char tips[]="CommandError\n";//提示1 char tips1[]="Start.....\n";//提示2 char tips2[]="Stop......\n";//提示3 int flag=0;//标志 0:停止发送 1.开始发送 在main函数中设置接收中断
函数说明
◉函数原型
HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size) ◉功能
功能：串口中断接收，以中断方式接收指定长度数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89715876c5ba756f1f39d86f16f01d40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/502af27111c731ac919f3d42d92f6d53/" rel="bookmark">
			无法自动装配/未找到“XXX“类型的Bean解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现报错：（这里我出现的问题是出现了多个，不是无法自动装配，但是不影响为大家解决这个问题。另外为了显示这个问题，我电脑不能截图，只能拿手机拍照再传过来......）
解决方法1： 找到这个接口的页面（ctrl+左键）
在接口上一行写上 @Service 就行了。
解决方法2： 把Bean类的自动装配 取消选择，不过这个方法......emmmmm，有点掩耳盗铃的感觉。
解决方法3： 产生的原因：
当我们在使用@Autowired注解的时候，默认required=true,表示注入的时候bean必须存在，否则注入失败。
在自动转配的注解后面添加(required=false)
这是小编根据自己情况总结出来的解决方法，不一定适配所有人的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ec6644cc3e0bb49c3f31f53616b7219/" rel="bookmark">
			单链表设置头结点的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 便于首元结点的处理：增加头结点后，首元结点的地址保存在头结点的指针域中，则对链表的第一个元素的操作和其他元素相同，无需进行特殊处理。（若单链表不带头结点，则首元结点无前驱结点，在其前插入结点和删除该结点操作复杂些。）
2. 便于空表和非空表的统一处理：增加头结点后，无论链表是否为空，头指针都是指向头结点的非空指针。
注：首元结点是指链表中存储线性表中第一个数据元素a1的结点（头结点的下一个结点）。为了操作方便，通常在链表的首元结点之前附设一个结点（头结点）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2760d0061aca8154b5d676902e7c52c/" rel="bookmark">
			Keil嵌入式开发环境的搭建与配置及基于STM32汇编程序的编写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、搭建与配置Keil嵌入式开发环境1.安装mdk2.安装STM32芯片包 二、基于STM32汇编程序的编写1.新建工程2.配置环境3.程序编写及调试 三、分析hex文件1.打开hex文件2.hex文件分析 四、总结五、参考链接 一、搭建与配置Keil嵌入式开发环境 1.安装mdk （1）打开下载的keil5文件夹，点击运行mdk531
（2）在弹出的界面，点击next
（3）勾选I agree，点击next
（4）自定义安装路径，然后点击next
（5）填写用户信息（可随便填写），然后点击next
（6）开始安装，安装完成后点击Finish
2.安装STM32芯片包 （1）在安装文件中点击Keil.STM32F1xx_DFP.2.1.0
（2）点击Next进行安装
（注：我已经安装过，所以会弹出如图片左下角所示的警告）
（3）开始安装，安装完成后点击Finish
至此，Keil嵌入式开发环境已全部搭建与配置完成。
二、基于STM32汇编程序的编写 1.新建工程 打开keil，点击菜单栏Project–&gt;New μVision Project，新建项目，在弹窗中设置工程项目的名称和路径
2.配置环境 （1）选择设备
点击菜单中的Project，找到Options for Target ‘Target 1’并点击，在弹窗中选择相应的目标环境，此处我选的是STM32F103ZE
（2）选择运行环境
（3）设置仿真器模式
点击菜单中的Project，找到Options for Target ‘Target 1’并点击，选择Debug–&gt;Use Simulator,将Dialog DLL以及Parameter处修改为自己选择的设备。
3.程序编写及调试 （1）添加源文件
右键单击Source Group 1，选择Add New Item to Group,添加Asm File (.s)文件，命名为test3并保存。
为其添加如下代码：
AREA MYDATA, DATA AREA MYCODE, CODE ENTRY EXPORT __main __main MOV R0, #10 MOV R1, #11 MOV R2, #12 MOV R3, #13 ;LDR R0, =func01 BL	func01 ;LDR R1, =func02 BL	func02 BL func03 LDR LR, =func01 LDR PC, =func03 B .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2760d0061aca8154b5d676902e7c52c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b57d9bd3b2cb6c5137c280d74a5096e/" rel="bookmark">
			基于STM32的USART串口通讯程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、串口协议和RS-232、485标准，以及RS232、485电平与TTL电平的区别，USB/TTL转232模块的工作原理1.串口协议2.RS-232、RS-485标准3.RS232、485电平与TTL电平的区别4."USB/TTL转232"模块（以CH340芯片模块为例）的工作原理 二、使用HAL库&amp;寄存器完成3只LED红绿灯的周期闪烁三、使用HAL库串口输出"hello windows!"1.新建项目2.编写程序3.连接电路4.程序烧录5.串口调试6.运行结果7.观察串口输出波形 四、用寄存器方式串口输出"hello windows!"1.新建项目2.编写程序3.连接电路4.程序烧录5.串口调试6.运行结果7.观察串口输出波形 五、总结六、参考链接 一、串口协议和RS-232、485标准，以及RS232、485电平与TTL电平的区别，USB/TTL转232模块的工作原理 1.串口协议 串口通信指串口按位（bit）发送和接收字节。尽管比特字节（byte）的串行通信慢，但是串口可以在使用一根线发送数据的同时用另一根线接收数据。串口通信协议是指规定了数据包的内容，内容包含了起始位、主体数据、校验位及停止位，双方需要约定一致的数据包格式才能正常收发数据的有关规范。在串口通信中，常用的协议包括RS-232、RS-422和RS-485。
2.RS-232、RS-485标准 （1）RS-232标准
①介绍
RS-232-C是美国电子工业协会EIA（Electronic Industry Association）制定的一种串行物理接口标准。RS（Recommended Standard）是英文“推荐标准”的缩写，232为标识号，C表示修改次数。RS-232-C总线标准设有25条信号线，包括一个主通道和一个辅助通道。
RS-232-C标准规定，驱动器允许有2500pF的电容负载，通信距离将受此电容限制。例如，采用150pF/m的通信电缆时，最大通信距离为15m；若每米电缆的电容量减小，通信距离可以增加。传输距离短的另一原因是RS-232属单端信号传送，存在共地噪声和不能抑制共模干扰等问题，因此一般用于20m以内的通信。
②电气特性
在TxD和RxD上：
逻辑“1”：-3V～-15V
逻辑“0”：+3～+15V
③信号和管脚定义
④设置
串行通信在软件设置里需要做多项设置，最常见的设置包括波特率（Baud Rate）、奇偶校验（Parity Check）和停止位（Stop Bit）。
1）波特率（Baud Rate）：
是指从一设备发到另一设备的波特率，即每秒钟多少比特bits per second (bit/s)。典型的波特率是300, 1200, 2400, 9600, 19200, 115200 等bit/s。一般通信两端设备都要设为相同的波特率，但有些设备也可以设置为自动检测波特率。
2）奇偶校验（Parity Check）：
是用来验证数据正确性的。奇偶校验一般不使用，如果使用，那么既可以做奇校验（Odd Parity）也可以做偶校验（Even Parity）。
3）停止位（Stop Bit）：
是在每个字节数据传输之后发送的，它用来帮助接收信号方硬件重同步。
（2）RS-485标准
①介绍
电子工业协会(EIA)于 1983 年制订并发布 RS-485 标准，并经通讯工业协会(TIA)修订后命名为 TIA/EIA-485-A，习惯地称之为 RS-485 标准。
RS-485 标准是为弥补 RS-232 通信距离短、速率低等缺点而产生的。RS-485 标准只规定了平衡发送器和接收器的电特性，而没有规定接插件、传输电缆和应用层通信协议。
RS-485 标准通常被用作为一种相对经济、具有相当高噪声抑制、相对高的传输速率、传输距离远、宽共模范围的通信平台。同时，RS-485 电路具有控制方便、成本低廉等优点。
②性能
RS-485 标准的数据信号采用差分传输方式(Differential Driver Mode)，也称作平衡传输,它使用一对双绞线，将其中一线定义为 A，另一线定义为 B。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b57d9bd3b2cb6c5137c280d74a5096e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95091d00acf6aa40a6b1e12445d5bd91/" rel="bookmark">
			Numpy基础入门知识点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、ndarray创建与索引
1.1创建ndarray对象
1.1.1ndarray数据类型
1.1.2 ndarray创建
1.1.3 ndarray的索引与切片
2.2 ndarray 的基础操作
2.2.1 设置 ndarray的形状
2.2.2展平ndarray
2.2.3组合 ndarray
2.2.4 分割 ndarray
2.2.5排序
2.2.6搜索
2.2.7字符串操作
2、ufunc
2.1 广播机制
2.2 常用运算
2.2.1 算术运算
2.2.2 三角函数
2.2.3集合运算
2.2.4比较运算
2.2.5逻辑运算
2.2.6统计计算
3、 matrix 与 线性代数
3.1创建NumPy矩阵
3.2矩阵的属性和基本运算
NumPy提供了两种基本的对象：ndarry 和 ufunc。ndarray是一个具有矢量算术运算和复杂广播能力的、快速且节省空间的多维且数组，ufunc则提供了对ndarray进行快速运算的标准数学函数。
1、ndarray创建与索引 1.1创建ndarray对象 在Numpy中，创建ndarray的方法根据创建的ndarray不同，可以有函数array、arange、linspace、logspace、zeros、eye、diag、ones等。此外，Numpy还提供随机数相关函数，，也可以用于创建ndarray。
1.1.1ndarray数据类型 import numpy as np print(f"整数42转为浮点数结果为：{np.float64(42)}") print(f"整数42转为布尔值结果为：{np.bool_(42)}") 运行结果：
整数42转为浮点数结果为：42.0 整数42转为布尔值结果为：True 1.1.2 ndarray创建 创建一维ndarray和二维ndarray
import numpy as np arr0 = np.array((1, 2, 3, 4, 5)) # 括号内为元组 arr1 = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95091d00acf6aa40a6b1e12445d5bd91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2614d31e566f089aff673bf5053978fc/" rel="bookmark">
			Ubuntu18.04 下图像处理开源软件库Opencv3.4.16的安装及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、安装Opencv3.4.161.安装Ubuntu图形界面2.下载Opencv3.4.16安装包3.使用cmake安装opencv4.使用make创建编译5.配置环境6.查看opencv的版本信息 二、编写图片进行特效显示的代码1.创建代码存放文件夹code并进入2.编写程序test1.cpp3.编译程序test1.cpp4.图片显示 三、编写打开摄像头压缩视频的程序1.虚拟机获取摄像头权限2.编写程序test2.cpp3.编译程序test2.cpp4.播放视频 四、编写录制视频的程序1.编写程序test3.cpp2.编译程序test3.cpp3.录制视频 五、总结六、参考资料 一、安装Opencv3.4.16 1.安装Ubuntu图形界面 输入命令sudo apt-get install ubuntu-desktop安装Ubuntu图形界面
等待安装完成之后重启虚拟机并登陆即可看到如下界面
2.下载Opencv3.4.16安装包 打开火狐浏览器，输入网址https://opencv.org/releases/
点击Sources下载OpenCV3.4.16压缩包，下载完成后将其复制到home文件夹下再解压缩。
输入命令unzip opencv-3.4.16.zip解压缩
3.使用cmake安装opencv （1）输入命令cd opencv-3.4.16进入解压后的文件夹opencv-3.4.16，然后输入命令sudo su进入root用户并输入命令sudo apt-get update更新
（2）输入命令sudo apt-get install cmake安装cmake
（3）安装依赖库，命令如下：
sudo apt-get install build-essential libgtk2.0-dev libavcodec-dev libavformat-dev libjpeg.dev libtiff5.dev libswscale-dev （4）创建build文件夹并进入
（5）使用cmake编译参数
4.使用make创建编译 （1）输入命令sudo make编译
（2）输入命令sudo make install安装
5.配置环境 （1）修改opencv.conf文件，打开后添加opencv库的安装路径：/usr/local/lib
添加完成后点击保存并关闭当前页面
显示的警示信息属于正常情况，不用担心。
（2）更新系统共享链接库
sudo ldconfig （3）配置bash，修改bash.bashrc文件
输入如下命令：
sudo gedit /etc/bash.bashrc 在文件末尾加入如下代码：
PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig export PKG_CONFIG_PATH 加入后点击保存并关闭当前页面
（4）执行命令source /etc/bash.bashrc使得配置生效
输入命令sudo updatedb更新
6.查看opencv的版本信息 输入命令pkg-config --modversion opencv查看opencv的版本信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2614d31e566f089aff673bf5053978fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c422f645428649e546419208daaca041/" rel="bookmark">
			编写一段程序，对通过键盘输入的一串字符,分别统计其中字母(a-ZA-Z) 、数字(0 -9)和其他类型字符的个数，结果以字典保存并输出。如{‘alpha‘:3,‘digit‘:5,‘other‘:7}
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		str = input("请输入一个字符串:")
length1 = len(str)
letter = 0
digit = 0
others = 0
i = 0
for each in str:
str1 = str[i]
i += 1
if str1.isalpha():
letter += 1
elif str1.isdigit():
digit += 1
else:
others += 1
int1={"alpha":letter,"digit":digit,"others":others}
print(int1)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b8360308cdf576904b8dbc7c87b22af/" rel="bookmark">
			黑盒测试-场景法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		黑盒测试-场景法 1.场景法 1.1简介 1.简介：软件系统要想获得用户的认可，必须站在用户的角度， 以用户的使用逻辑及操作习惯为出发点，设计测试用例时 考虑用户使用软件的流程。然后，依据这些流程设计用例 设计才能更贴近实际，才能在最大程度上满足用户的需求。
现在的软件几乎都是由事件触发来控制流程的，事件触发时的情景便形成了场景，而同一事件不同的触发顺序和处理结果形成事件流。
场景法适用于业务流程或事件比较复杂的程序。主要是 从用户的角度出发，考虑用户是怎样使用软件的。通过分 析用户的使用过程，形成各种事件流，然后设计测试用例 来覆盖这些事件流。因此，场景法测试的流程性比较强。
当然，在实际的测试过程中，我们也不能只是一个功能 点一个功能点的测试，当所有功能点单独执行没有问题后， 我们也需要考虑各功能点之间的数据流的流动是否正常
2.案例：假设要测试一个创建贺卡的功能。
从功能测试的角度出发，要测试的功能点大致为：
1.为卡片添加文本信息
2.为卡片添加图片
3.从卡片库中获取草图
4.发送卡片：
1) 通过email发送2) 打印卡片。 这些可以通过我们常用的等价类等手段进行测试
站在用户使用的角度出发则偏重于：
1.发送生日贺卡
2.发送圣诞贺卡
3.从一张空白卡片开始制作贺卡， 并通过前面提供的这一堆功能创建一张自己需要的卡片。
这就是场景 测试的一个缩影，场景其实就是对每一个活动进行再细化描述活动执行的过程。
1.2场景 1.简介：场景就是事件流，一个场景描述 了一种事务的流程。流程分基本流程和备选流程。比如：提款操作。 基本流就是用户插入卡片——输入密码——输入提款额——提款成功。 备选流有很多，代表了各种异常情况，比如先查询后取款、密码输入错误、提款机没钱等等。
1.3案例：场景法案例-ATM取款机 1.3.1生成基本流
ATM取款操作：
ATM 处于准备就绪状态。准备提款 - 客户将银行卡插入 ATM 机的读卡机。验证银行卡 - ATM 机从银行卡的磁条中读取帐户代码，并检查它 是否属于可以接收的银行卡。输入密码 - 客户输入密码，系统验证帐户代码和密码以确定该帐 户是否有效以及所输入的 密码对该帐户来说是否正确。对于此事 件流，帐户是有效的而且密码对此帐户来说正确无误。ATM 选项 - ATM 显示在本机上可用的各种选项。在此事件流中， 银行客户通常选择“提款”。输入金额 - 要从 ATM 中提取的金额。ATM 通过将卡ID、PIN、金额以及帐户信息作为一笔交易发送给银
行系统来启动验证过程。对于此事件流，银行系统处于联机状态，
而且对授权请求给予答复，批准完成提款过程，并且据此更新帐户余额。出钞 - 提供现金。返回银行卡 - 银行卡被返还。收据 - 打印收据并提供给客户。ATM 相应地更新内部记录。用例结束时 ATM 又回到准备就绪状态。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b8360308cdf576904b8dbc7c87b22af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d121c79ccedd00721ba466ea54d00621/" rel="bookmark">
			Docker离线安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker离线安装
一、安装步骤
1. 下载 Docker 二进制文件（离线安装包）
下载地址：https://download.docker.com/linux/static/stable/x86_64/
注：本文使用 /x86_64/docker-18.06.1-ce.tgz，注意对应操作系统类型。
2. 通过 FTP工具将 docker-18.06.1-ce.tgz 上传到服务器上
3. 解压安装包
tar zxf docker-18.06.1-ce.tgz
4. 将docker 相关命令拷贝到 /usr/bin，方便直接运行命令
sudo cp docker/* /usr/bin/
5. 启动Docker守护程序
sudo dockerd &amp;
6. 验证是否安装成功，执行docker info命令，若正常打印版本信息则安装成功。
docker info
二、将docker注册成系统服务（记得kill docker服务后，再执行这一步哦）
1. 在 /usr/lib/systemd/system/ 目录下创建docker.service 文件
sudo vi /usr/lib/systemd/system/docker.service
1
[Unit]
Description=Docker Application Container Engine
Documentation=https://docs.docker.com
After=network-online.target firewalld.service
Wants=network-online.target
[Service]
Type=notify
ExecStart=/usr/bin/dockerd
ExecReload=/bin/kill -s HUP $MAINPID
LimitNOFILE=infinity
LimitNPROC=infinity
TimeoutStartSec=0
Delegate=yes
KillMode=process
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d121c79ccedd00721ba466ea54d00621/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c71ccc5d2c784d88867f0b4049d35d54/" rel="bookmark">
			Ribbon如何自定义实现负载均衡策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Ribbon作为Spring Cloud全家桶核心组件之一，是一套基于客户端的软负载工具，主要是基于Netfilx发布的开源项目，功能主要是应用于客户端软件的负载均衡算法、服务之间调用的桥梁。作为客户端的组件，提供了一系列的配置，如拒绝策略、超时重试、服务发现策略….主要的核心组件也是基于Load Balancer，会提供一些负载均衡策略，如轮询、加权轮询、随机连接、重试等策略。
注册中心、负载均衡、生产者服务之间的注册与调用情况
Ribbon负载均衡策略核心 IRule 接口定义了一系列的负载均衡策略
核心接口ILoadBalance定义了一系列的方法，包括获取服务列表、选择、添加、选择服务。
自定义负载均衡策略 1:代码方式配置新策略 首先定义Configuration的MyRule类，定义myRule方法返回IRule接口。
public class CustomRule extends AbstractLoadBalancerRule { private int total = 0; //被调用的次数 private int currentIndex = 0; //当前是谁在提供服务 public Server choose(ILoadBalancer lb, Object o) { if (lb == null) { return null; } Server server = null; while (server == null) { if (Thread./interrupted/()) { return null; } List&lt;Server&gt; upList = lb.getReachableServers(); //获得还活着的服务 List&lt;Server&gt; allList = lb.getAllServers(); //获取全部服务 int serverCount = allList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c71ccc5d2c784d88867f0b4049d35d54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0079ed3238a7c3df2b7845ae9147cb56/" rel="bookmark">
			意外收获！阿里技术官私库中的Spring全家桶小册，源码实战都有
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于Java工程师来说，几乎没有没听过大名鼎鼎的Spring框架的，Spring框架早已成为了Java后端开发事实上的行业标准，可以说，是Spring成就了Java，Spring也成为Java程序员必修课之一。同时，随着Spring Boot和Spring Cloud的出现，使得开发工程师能更高效地利用Spring和其他基础设施快速搭建系统，Spring全家桶的诞生又一次解放了大家的生产力。
经常有小伙伴后台留言有关Spring全家桶学习的问题，大家遇到的困惑无非是这些方面：
刚刚入行或转行的兄弟，不明白为什么要用这些框架来进行开发，直接new一个对象不行吗？
深陷于CRUD的程序员，非常想系统地学一下Spring全家桶，但组件太多，不知如何下手。
目标为技术大牛的程序员，发现一入源码深似海，自己作为主角演了一出《从入门到放弃》。
期望跳槽升职加薪的朋友，面试过程中总是会被Spring全家桶相关的面试题给难住。
核心岗位的技术架构师，对如何更好、更高效、正确地使用Spring全家桶仍有很多不确定。
很多粉丝问我有没有教程，能由点到线、由线到面的对Spring全家桶进行讲解，如果还能深入到源码讲解Spring全家桶中所有技术的关键机制和实现原理就更好了，这里我特地给大家分享这套Spring全家桶学习笔记，分别有Spring 、Spring Boot、Spring Cloud及Alibaba等等！由于篇幅原因，本文只展示了目录和内容截图，有需要学习的小伙伴只需添加小助理VX：mxs7k7k 即可获取这份资料！
​
Spring源码高级笔记 作为 Spring 技术生态的基石，Spring Framework 无论在设计，还是在实现上，都是一个优秀的框架，许多细节方面都是非常值得我们学习的。说了这么多那有没有学习的途径呢？推荐这份《Spring源码分析笔记手册》，非电子书籍，从基础到源码深入讲解，断点明确！先来看看目录！
​
Spring源码高级笔记内容展示
​
Spring Boot源码进阶笔记 企业对 SpringBoot 技术和经验都有一定要求，如果一直都停留在简单使用阶段，迟早会被淘汰，SpringBoot 提升势在必行。但目前网上关于 SpringBoot 信息多而杂，学习如果没有体系，那么到最后也只是徒劳一场。为了让大家快速有效提升，在这分享了这份《 SpringBoot 技术整合秘籍》分别为入门到实战篇和源码解析篇！先来看看目录
​
Spring Boot源码进阶笔记内容展示
​
Spring Cloud微服务学习笔记 后台都是在问微服务架构的面试题怎么答，想聊聊微服务架构了。微服务架构一跃成为 IT 领域炙手可热的话题也就这两年的事，大量一线互联网公司因为庞大的业务体量和业务需求，纷纷投入了微服务架构的建设中，像阿里巴巴、百度、美团等大厂，很早就已经开始了微服务的实践和应用。一线大厂的带动，让微服务成为了Java程序员面试的必备考点。其中是否具有 Spring Cloud 技术能力的程序员，也是企业招聘中影响薪资的核心要素之一。在这特地分享这套Spring Cloud微服务学习笔记给小伙伴们！
主要内容分四个大模块：
第一部分：微服务架构之服务注册Eureka与服务调用Ribbon篇
这部分主要章节内容包括：
​
内容展示：
​
第二部分：微服务架构之服务调用Feign与服务熔断Hystrix篇
​
内容展示：
​
第三部分：微服务架构之网关篇
这部分主要章节内容包括：
​
第四部分：Spring Cloud Stream与SpringCloud Config及开源配置中心Apollo
​
SpringCloud Alibaba学习笔记 市面上系统的SpringCloud Alibaba学习资料确实非常少，都是些零散的博客，这份Spring Cloud Alibaba 学习笔记文档可以说能给很多想学习还没方向的朋友提供到帮助！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0079ed3238a7c3df2b7845ae9147cb56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a1077f13b465c4b5e6c989d63d953fb/" rel="bookmark">
			2021年西部数据叠瓦(SMR)、垂直型号(PMR)机械硬盘大全（防踩雷！）仅供参考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021年西部数据叠瓦(SMR)、垂直型号(PMR)机械硬盘大全（防踩雷！）仅供参考
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cdaae4af6735f2791e46c6cadc9c207/" rel="bookmark">
			通过ssh建立两台主机的远程连接实现免密登陆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、ssh的建立原理 ssh远程连接
作用：远程端的主机基于网络通过标准的远程协议远程登录到对应的主机，类似于直接在本地端操作
应用层和传输层之间连接SSL/TLS安全认证层（SSL握手协议 SSL记录协议）
身份伪装
信息泄露
信息改
对称密钥： 加密和解密用的同一密钥（安全性较低，执行效率较高）---数据传输
非对称密钥： 公钥--数据加密 私钥--数据解密（安全性较高，执行效率较低）---握手阶段
ssh连接的原理过程： 1.版本协商阶段：客户端向服务端发起TCP初始连接请求，客户端收到服务端的请求，建立连接，向客户端发送报文，客户端收到报文后，解析该数据包，决定使用谁的版本协议号；之后，客户端回应服务端决定使用的版本号，服务器比较客户端发送的版本号，决定是否一起工作，协商成功后进入密钥算法协商阶段，否则断开TCP连接 。
2.服务器传送公钥给客户端： 接收到客户端的要求后，服务器便将第一个步骤取得的公钥传送给客户端使用 (此时应是明码传送，反正公钥本来就是给大家使用的)。
3.客户端记录并比对服务器的公钥数据及随机计算自己的公私钥： 若客户端第一次连接到此服务器，则会将服务器的公钥记录到客户端的用户家目录内的 ~/.ssh/known_hosts 。若是已经记录过该服务器的公钥，则客户端会去比对此次接收到的与之前的记录是否有差异。若接受此公钥， 则开始计算客户端自己的公私钥。
4.回传客户端的公钥到服务器端： 用户将自己的公钥传送给服务器。此时服务器：具有服务器的私钥与客户端的公钥，而客户端则是： 具有服务器的公钥以及客户端自己的私钥，你会看到，在此次联机的服务器与客户端的密钥系统 (公钥+私钥) 并不一样，所以才称为非对称加密系统。
5.开始双向加解密： (1)服务器到客户端：服务器传送数据时，拿用户的公钥加密后送出。客户端接收后，用自己的私钥解密 (2)客户端到服务器：客户端传送数据时，拿服务器的公钥加密后送出。服务器接收后，用服务器的私钥解密，这样就能保证通信安全。
ssh连接的过程： 二、配置两台主机的远程连接实现免密登陆 主机A：192.168.114.138 主机B：192.168.114.147 第一步：生成密钥对 在A机下产生密钥：ssh-keygen -t RSA -b 4096，一直按enter [root@A ~]# ssh-keygen -t RSA 检查是否产生密钥对： id_rsa 私钥
id_rsa.pub 公钥
[root@A ~]# cd /root/.ssh/ [root@A .ssh]# ll total 8 -rw-------. 1 root root 2590 Oct 15 04:43 id_rsa -rw-r--r--.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cdaae4af6735f2791e46c6cadc9c207/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e53db092688a0b90b26cd8a6e1de869c/" rel="bookmark">
			linux内核安装编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux内核下载及编译 下载Linux内核 可以从官网下载linux内核，也可以通过第三方网站进行下载。
官网网址：https://www.kernel.org/。
由于官网可能存在被墙的原因，所以下在很慢，这里也提供一个更加便捷的下载地址：http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/。
根据自己的需求下载相应的版本，我这里下载在的是“linux-5.19.tar.gz”版本。
解压linux内核 使用以下命令进行加压下载的linux内核压缩包：
tar -zxvf linux-5.19.tar.gz 解压后使用ls命令展示文件夹类存在的文件。
在清理多余的中间配置文件，使用make distclean命令。清理后文件夹内部信息将会发生变化。
选择参考配置文件 使用以下命令选择配置文件，便于后续config配置：
cp /boot/config-5.15.0-46-generic .config 具体操作如下图所示：
配置内核 在使用make命令前，需要先安装一些相关的依赖库，便于后续的运行。主要需要执行以下命令：
sudo apt-get update sudo apt install make sudo apt-get install gcc sudo apt-get install libncurses5-dev sudo apt-get install flex sudo apt-get install bison 使用“make manuconfig“进行打开可视化终端，按照自己的需要进行更改参数设置。如果不需要更改，则保存退出就可以继续执行后面操作。
编译内核 执行make bzImage命令，需要较长的时间（1～2小时左右，耐心等待）。
其中可能会出现scripts/sign-file.c:25:10: fatal error: openssl/opensslv.h: 没有那个文件或目录等问题。于是执行以下命令安装相关的依赖，应该一次性全部安装完相关的所有依赖，要不然耗时更长。
sudo apt-get install libssl-dev sudo apt-get install libelf-dev sudo apt-get install dwarves sudo apt-get install zstd 如果中间出现以下等错误：make[1]: *** 没有规则可制作目标“[debian](https://so.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e53db092688a0b90b26cd8a6e1de869c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ee81422bfe908b6e288c95ee12a8727/" rel="bookmark">
			计算机网络：应用层 知识点汇总（简化版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明
博客作为笔记备份，不定时更新参考内容为王道考研《计算机网络考研复习指导2023》简化版仅进行了知识点汇总，详细知识点没有记录，主要用来搭知识体系框架 文章目录 思维导图版文字版应用层网络应用模型域名系统文件传输协议 FTP电子邮件万维网WWW和超文本传输协议HTTP 思维导图版 文字版 应用层 网络应用模型 C/S模型 工作特征 客户程序必须知道服务器程序的地址；服务器程序无需知道客户程序的地址系统启动后服务器一直运行，被动等待并接收来自客户端的请求 使用C/S模型的应用 WebFTP远程登录电子邮件 特点 网络中各个计算机地位不平等客户机之间不直接通信可扩展型不佳 P2P模型 网络中各个计算机地位相同，都可以既做服务器，也做客户端优点（相比C/S） 减轻了服务器的计算压力，可将任务分配到各个结点上客户机之间可直接共享文件可扩展性好网络健壮性强 域名系统 作用 是因特网使用的命名系统，将便于人们记忆的主机名转换为便于机器处理的IP地址 细节说明 DNS采用C/S模型其协议运行在UDP之上使用53号端口 组成 层次域名空间 除了“.”和“-”不允许使用其他符号每个标号不超过63个字符域名从左到右，级别依次升高顶级域名分类 国家顶级域名通用顶级域名基础结构域名 域名服务器 作用 一个域名服务器管理的范围称为区，一个区中的所有结点能够连通域名服务器负责进行域名到IP地址的解析域名服务器具有连向其他域名服务器的信息 4种类型 根域名服务器 最高层次的，本地域名服务器无法解析时，首先求助于根域名服务器因特网上有13个，所有的都知道所有的顶级域名服务器的IP地址根域名服务器一般不将待查询的域名转化为IP地址，而是告诉本地域名服务器下一步该找哪个顶级域名服务器 顶级域名服务器授权/权限域名服务器 每台主机都必须在授权域名服务器处登记，一台主机最好有两个授权域名服务器它总能将其管辖的主机名转化为该主机的IP地址 本地域名服务器 主机将DNS查询请求报文发给该主机的本地域名服务器 解析器（域名解析过程） 解析方式 递归查询递归迭代相结合 主机向本地域名服务器的查询采用递归查询本地域名服务器向根域名服务器查询采用迭代查询 文件传输协议 FTP 工作原理 提供的功能 提供不同种类主机系统之间的文件传输能力 允许用户指明文件的类型、格式 以用户权限管理的方式提供用户远程管理FTP服务器上的文件以匿名FTP方式提供公共文件共享的能力 采用C/S模型使用TCP一个FTP服务器进程可同时为多个用户进程提供服务 主进程：负责接收新的请求若干从属进程：负责处理单个请求主从进程并发执行 FTP服务器在整个会话期间保留用户的状态信息 控制连接和数据连接 控制连接 服务器21号端口控制连接在整个会话期间保持打开 数据连接 服务器20号端口传输模式 主动模式PORT被动模式PASV 电子邮件 组成结构 用户代理UA 用户和电子邮件的接口 邮件服务器 负责发送和接收邮件 电子邮件使用的协议 邮件发送协议：SMTP邮件读取协议：POP3、IMAP 信息格式 信封内容 协议 简单邮件传输协议SMTP 特点 使用C/S方式使用TCP连接端口号25 通信阶段 连接建立 STMP不使用中间的邮件服务器，TCP连接直接建立在收发服务器之间 邮件传送连接释放 POP3（邮局协议） 特点 使用C/S方式传输层使用TCP端口号110 工作方式 下载并保留下载并删除 IMAP（因特网报文存取协议） 比POP复杂的多特性 IMAP服务器维护了会话用户的状态信息允许用户代理获取报文的某些部分 基于万维网的电子邮件 特点 用户浏览器与邮件服务器之间进行收发邮件时使用HTTP仅在不同邮件服务器之间传送邮件时才使用SMTP 例如：Hotmail、Gmail 多用途网际邮件扩充MIME 在SMTP的基础上，增加了邮件主体的结构允许邮件包含音频、视频等，也允许使用不同的文字 万维网WWW和超文本传输协议HTTP 万维网 组成 统一资源定位符URL超文本传输协议HTTP超文本标记协议HTML HTTP协议 连接 服务器进程监听TCP的端口80（默认）连接方式 非持久连接 每个网页元素（如JPEG、Flash等）的传输都要单独建立一个TCP连接 持久连接 万维网服务器发送响应后仍保持这条连接分为非流水线方式、流水线方式HTTP/1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ee81422bfe908b6e288c95ee12a8727/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca8b1dda9f90909ebd3b0bf356ada38d/" rel="bookmark">
			C&#43;&#43; proj库使用说明与字符串说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		proj使用说明 PROJ github:
https://github.com/OSGeo/PROJ
1. 引用proj头文件 #include "proj_api.h" 2. 构建坐标系定义指针 构建所需的proj_string字符串可参见： https://epsg.io/
字符串搜索用例：
首先在首页搜索栏输入所需坐标系名称，点击search搜索。
之后选择所需的坐标系统。
在页面下方export中选择PROJ4可以在右边获取到proj_string字符串。
字符串各个字段含义可参见：https://blog.csdn.net/u013240519/article/details/113243000
projPJ pWGS84 = nullptr; // WGS84坐标系指针 projPJ pGKP = nullptr; //高斯克鲁格坐标系指针 const char* wgs84_string = "+proj=longlat +ellps=WGS84 +datum=WGS84"; pWGS84 = pj_init_plus(wgs84_string); // 以40度带中央经度120为例 const char* gk_string = "+proj=temrc +ellps=WGS84 +datum=WGS84 +x_0=500000 +lon_0=120 +units=m"; pGKP = pj_init_plus(gk_string); 3. 坐标转换 // GKP to WGS84 bool WGS842GKP(const double dLon/*rad*/, const double dLat/*rad*/, double&amp; dX, double &amp;dY) { dX = dLon; dY = dLat; int iRev = pj_transform(pWGS84, pGKP, 1, 1, &amp;dX, &amp;dY, nullptr); if(iRev !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca8b1dda9f90909ebd3b0bf356ada38d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34390c997eaef62dbc91eef0e032c445/" rel="bookmark">
			Spring Boot源码学习：自动配置与自定义注解详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		入门
@RestContrller :此注解标记的类下的 所有 方法均会返回一个 domain 对象以代替视图@Controller、@ResponseBody 的缩写使用 Jackson2 以及 MappingJackson2HttpMessageConverter 类自动转换对象为 JSON
@SpringBootApplication：快捷注释，包含以下内容@Configuration：将该类标记为上下文 bean 对象的源@EnableAutoConfiguration：@ComponentScan
Spring Boot ？
Spring Boot 基于 spring framework之上，可以整合所有spring 生态的技术
快速构建生产级别的 spring 应用
spring boot 是整合 spring 技术栈的一站式框架、脚手架
系统要求
Name
Version
Java
JDK 8+
Maven
3.3+
Gradle
6 (6.3 or later). 5.6.x is also supported but in a deprecated form
Name
Servlet Version
Tomcat 9.0
4.0
Jetty 9.4
3.1
Undertow 2.0
4.0
IDEA 的支持
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34390c997eaef62dbc91eef0e032c445/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c541396f86871c3f54b17e20a8187c3/" rel="bookmark">
			查看本地MYSQL数据库的IP地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在自己电脑建立了MYSQL数据库，但是想在其它的电脑进行连接，那如何查找MYSQL数据库的IP地址？（也就是建立了数据库电脑的IP地址）
方法一：在电脑设置中查看电脑iP地址
通过查看电脑硬件属性，可以很方便且准确的查看自己的IP地址。操作步骤如下：
步骤1.在电脑上左侧打开【设置】，选择“打开‘网络和internet”设置选项。
步骤2.打开“网络和internet”设置，点击“硬件属性”,打开"WLAN“窗口。
步骤3.在“WLAN”窗口中的IPv4地址，即可查看到自己电脑的IP地址。
方法二：通过运行程序查看电脑IP地址
步骤1.在键盘上按“WIN+R”组合键，打开运行窗口，之后在运行窗口中输入“cmd”，点击确定；
步骤2.在打开的窗口中，输入ipconfig/all，按下Enter键。
步骤3.查看IPv4地址，即为本地电脑上IP地址。
方法三：通过浏览器查看电脑IP地址
通过浏览器（任何浏览器均可）在搜索栏中输入“IP”关键词，点击搜索，就能看您的电脑IP地址了。
参考自（做个备忘）：
https://baijiahao.baidu.com/s?id=1720378010076682798&amp;wfr=spider&amp;for=pc
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/52/">«</a>
	<span class="pagination__item pagination__item--current">53/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/54/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>