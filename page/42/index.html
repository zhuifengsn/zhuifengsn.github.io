<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="追风少年的博客">
		<meta property="og:title" content="追风少年的博客" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f807181c8c43b9caf9efa4ecf738426b/" rel="bookmark">
			运维36讲第27课：应用安全：基于 HTTP、HTTPS 请求过程中常见 waf 攻防策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上个课时讲解的 iptables 安全主要是4 层协议规则。除了 4 层安全外，7 层的安全攻击也是我们必须掌握的。那么在本课时我们基于 HTTP、HTTPS 请求过程中常见的安全防护问题来讲解 7 层应用安全。
常见的 7 层安全类攻击疑难点 对于 7 层安全攻击行为，作为运维工程师可能会遇到哪些痛点？
无法了解代码的逻辑，这种攻击更多贴合代码或者业务逻辑漏洞，由于我们很少能了解代码，所以很难定位到代码层次的具体问题。黑客的攻击行为多样，7 层的攻击行为会非常多样，所以就运维来说我们可能需要提前储备多种防护技能。 常见 HTTP、HTTPS 攻击行为 本课时我们主要讲解 HTTP、HTTPS 协议的攻击行为，常见种类如下：
暴力破解，这里主要对弱口令漏洞来进行攻击；HTTP 内容劫持；CSRF 跨站请求伪造；SQL 注入；XSS 跨站脚本攻击，等等。 这都属于常见的 HTTP、HTTPS 请求类的攻击行为，我们将重点讲解其中的一些类型，并讲解一个运维工程师该如何去进行防范？
暴力破解及其防护策略 首先我们讲的是暴力破解攻击类型。暴力破解是指攻击者通过系统组合的所有可能性（网站登录时的账户、密码）尝试破解用户的账户名、密码等敏感信息。攻击者会经常使用自动化脚本或工具攻击，拿出正确的用户名和密码。它的特点有两个，一是会持续很长时间，因为要不断尝试多种用户名和密码组合；二是访问的次数会很多，因为访问的时间越长，那么它顺利破解可能性就会越大。 如果我们的用户名和密码口令设置得越弱，也就越容易被破解。
常见的暴力破解工具有以下几种：hydra、htpwdScan、Playload，你可以在网上查询下，其实都是通过海量的用户密码不断尝试后台访问。
对于这种攻击，我们应该从如下两个维度去防范：
运维工程师维度，需要对用户的后台，也就是我们常见的既有用户名密码的管理后台，或者是一些后台的登录接口添加一些安全策略，如：基于访问控制添加一个白名单访问，只允许某一个 IP 地址进行访问，这就大大减少了直接暴露后台接口，对所有公网都可以降低访问的隐患。
或者要限制用户的访问频率，不能让用户频繁地尝试登录后台，所以可以对这种攻击的过程进行频次的限制，这都是我们常会做的一些防范策略。
对于开发人员维度而言，首先需要把管理后台的密码设置得更加复杂，大小写字母加特殊字符加数字多种组合，让你的密码长度更长，这样尝试的时间周期就会更长，而且也越难进行破解。
第二就是设置一些密码校验失败的策略，比如同一个 IP，在单位时间限定其访问校验次数，如果超出了次数，就把基于 IP 或一些相关信息的后续访问限制，不让它频繁进行访问了，这也是可以在后台程序里实现的。
第三就是不使用用户密码的校验行为，加入一些更复杂的校验方式，如电子口令卡、动态密码等，这些都是非常有助于保护网站后台访问的，不至于把整个后台沦落到黑客手中。以上就是开发人员常常可以去做的一些防护的策略。
接下来为你举一个例子，我们以 Nginx 的设置为例，如果 Nginx 作为你公司服务架构的代理网关，那么在 Nginx 来做一些防范策略，具体包含： Nginx 实现管理后台的白名单控制，限流配置。
limit_req_zone $binary_remote_addr zone=limiter:10m rate=20r/s; server { .... location /admin { proxy_pass http://127.0.0.1:8080; limit_req zone=limiter burst=1 nodelay; } location / { proxy_pass http://127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f807181c8c43b9caf9efa4ecf738426b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc434e7d6a69865a444fcf79a305da31/" rel="bookmark">
			SQL调优的几个方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.为什么调优，好处是什么？ SQL语句在编写之后，对于数据量较少的表基本没有什么性能上的需求，但是如果考虑到性能方面的话，SQL语句优化就是必须的。
2.如何调优？调有点方法有哪些？
1、对查询进行优化，应尽量避免全表扫描，首先考虑在where及order by上建立索引。
2、应尽量避免在where子句中进行以下操作：对字段进行null判断；使用！=或&lt;&gt;操作符；使用or连接条件；使用in或not in；使用like；等号左侧使用算术运算；对字段进行函数运算等。以上操作将导致引擎放弃索引而进行全表扫描。
3、不要写一些没有意义的查询，如生成一个空表。
4、使用exists替代in，用not exists替代not in。not in 是低效的，因为它对子查询中的表执行了一个全表遍历，他执行了一个内部的排序和合并。select num from a where exists（select 1 from b where num=a.num）
5、对只含数值信息的字段尽量使用数值型代替字符型，否则会降低查询和连接性能。
6、尽可能使用varchar代替char，节约存储空间，提高效率。
7、尽量用具体字段代替*进行查询。
8、在使用索引字段作为条件时，如果索引是复合索引，必须使用该索引的第一个字段作为条件才能保证系统使用该索引。
9、当索引中有大量重复数据时，索引是无效的。
10、当进行update或insert操作时，索引的存在会降低该操作的效率。
11、尽量避免频繁创建或删除临时表，减少系统资源消耗。
12、在新建临时表时，如果一次性插入数据量很大，那么可以使用select into代替create table，避免产生大量log，提高效率。
13、如果使用到了临时表，在存储过程的最后务必将所有的临时表显示的删除，先truncate table ，然后drop table，避免系统表长时间锁定。
14、尽量避免使用游标，因为游标效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。
15、对于小型数据集使用fast_forward游标要优于其他逐行处理方法，尤其是在必须引用几个表才能获取所需要的数据时。
16、表名顺序。选择最有效率的表名顺序，from后面先跟大表，再跟小表，因为from子句中写在最后的表被优先处理，from后跟多个表的情况下，应该选择记录条数最少的表作为优先处理的表；
17、where子句连接顺序。那些可以过滤最大数量记录的条件必须写在where子句的末尾；
18、高效删除重复记录。最高效的删除重复记录方法 ( 因为使用了ROWID)例子：delete from emp a where a.rowid&gt;(select min(b.rowid) from emp b where a.emp_no=b.emp_no);
19、使用truncate替代delete。当用delete删除表中记录时，回滚段rollback用来被存放可以被恢复的信息，如果你不执行commit，oracle会将数据恢复到删除之前的状态；当运行truncate时，回滚段不再存放任何可被恢复的信息，当运行truncate时，数据不再被恢复，此时很少的资源被调用，执行时间也会很短；
20、尽量多使用commit。随着commit的多次使用，系统资源被释放，性能会提高；
21、用where子句替换having子句。having只会在检索出所有记录之后才对结果集进行过滤。on、where、having这三个都是删选条件的子句，on最先执行，where次之，hiving最后；on先把不符合条件的记录过滤才进行统计，它可以减少中间运算要处理的数据，on的使用仅限于多表连接；where也是过滤数据后才进行sum；hiving是在计算之后才启作用；
22、使用表的别名。当sql语句中连接多个表时，请使用表的别名并用别名前缀识别每个column，这样可以减少sql解析时间，避免歧义；
23、用&gt;=替代&gt;
高效：SELECT * FROM EMP WHERE DEPTNO &gt;=4 低效: SELECT * FROM EMP WHERE DEPTNO &gt;3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc434e7d6a69865a444fcf79a305da31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cecafb248ad1b9fcb0fe3872b0513c1/" rel="bookmark">
			【数据结构】为什么说二分查找是很牛的算法？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么说二分查找是很牛的算法？ 文章目录 为什么说二分查找是很牛的算法？一、二分查找是什么？二、为什么说二分查找是很牛的算法二分查找的优缺点总结 一、二分查找是什么？ 在学习数据结构的过程中我们会学很多数据结构，例如：二叉树、AVLTree、哈希表、B数，而今天我要给大家介绍在有序的情况下的一种排序——二分查找，接下来请看代码实现。
代码如下（示例）：
int BinarySearch(int arr[], int k, int sz) { int left = 0; int right = sz - 1; while (left &lt;= right) { int mid = (left + right) / 2; if (arr[mid] &lt; k) { left = mid + 1; } else if (arr[mid] &gt; k) { right = mid - 1; } else { return mid; } } if (left &gt; right) { return -1; } } int main() { int arr[10] = { 1,2,3,4,5,6,7,8,9,10 }; int sz = sizeof(arr) / sizeof(arr[0]); int k = 0; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cecafb248ad1b9fcb0fe3872b0513c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb217343d54bf284c4c3eb9b06d6dc9f/" rel="bookmark">
			在pycharm中使用chatgpt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、插件安装
二、使用步骤
总结
前言 ChatGPT是目前最强大的AI，不仅能够聊天、写小说，甚至码代码也不在话下。
但是在国内要使用chatgpt很麻烦，国内一家团队开发了一款idea插件NexChatGPT，用数据代理的方式，让我们在国内也能轻松的使用chatgpt。
一、插件安装 pycharm版本不低于2020.2，在插件搜索NexChatGPT
点击安装，应用即可，重启浏览器即可使用插件
二、使用步骤 使用步骤很简单，插件安装完成后，点击右侧扩展栏多出来的窗口，完成登录后即可
在search栏输入想要的问题，chatgpt就会返回答案
点击chat栏，则会弹出对话窗口
轻轻松松就能完成各类sql语句的编写。
总结 以前是面向搜索引擎编程，现在是面向chatgpt编程了。可以说是极大的解放的生产力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bc97966fc25a67ed6fc5119c347b2a2/" rel="bookmark">
			【计算机网络微课堂】湖科大教书匠笔记——第一章概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第一章概述1.1计算机网络在信息时代的作用1.2因特网概述1.3三种交换方式分组交换名词：过程： 电路交换、报文交换、分组交换的对比： 1.4计算机网络定义和分类1.5计算机网络的性能指标1. 速率2. 带宽3. 吞吐量4. 时延5. 时延带宽积6. 往返时间RTT7. 利用率8. 丢包率 1.6计算机网络体系结构（重难点）常见结构结构分层的必要性分层思想举例主机中：路由器中：Web服务器： 专用术语 本博客笔记基于P1-P11计算机网络微课堂——湖科大教书匠
第一章概述 1.1计算机网络在信息时代的作用 1.2因特网概述 ISP：用户主机通过ISP获得IP地址接入因特网。
1.3三种交换方式 分组交换 名词： 路由器：最重要的分组交换机，负责将各种网络互连起来，并对接收到的分组进行转发。
报文：表示消息的整块数据。
分组（包）：在发送报文之前，先将其划分成为一个个更小的等长数据段，加上一些由必要的控制信息组成的首部（包头）后形成分组。
首部：包含分组的目的地址。
过程： 发送方：构造和发送分组。
路由器：存储和转发分组。
接收方：接收分组和还原报文。
电路交换、报文交换、分组交换的对比： 电路交换： 通信之前首先要建立连接，使用已建立好的连接进行数据传送，
数据传送结束后，需要释放连接，以归还之前建立连接所占用的通信线路资源。
报文交换： 可以随时发送报文，而不需要事先建立连接，
整个报文先传送到相邻结点交换机，全部存储下来后进行查表转发到下一个结点交换机。
分组交换： 可以随时发送报文，而不需要事先建立连接，
构成原始报文的一个个分组，依次在各结点交换机上存储转发，结点交换机在发送分组的同时，还缓存接收到的分组。
分组相比报文交换：提高了可靠性，减少了转发时延。
1.4计算机网络定义和分类 WAN：广域网
MAN：城域网
LAN：局域网
1.5计算机网络的性能指标 1. 速率 注意区分数据量和速率中表示相同而大小、单位不同。
2. 带宽 3. 吞吐量 4. 时延 发送速率：由网卡的发送速率、信道带宽和接口速率最小值决定。
电磁波的传播速率：
自由空间: 3x108m/s
铜线: 2.3x108m/s
光纤: 2.0x108m/s
5. 时延带宽积 6. 往返时间RTT 7. 利用率 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bc97966fc25a67ed6fc5119c347b2a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1bb975af7d880bf1c4931cad076616f/" rel="bookmark">
			Python截图自动化工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、展示部分源码(写的比较乱，哈哈)
2、功能展示
1）首页 2）按钮截图(用于自动翻页)
3）保存位置按钮(选择图片保存的位置)
4）重复次数，就是要截取多少次
5）定位截屏(截取的内容，在截图时电脑屏幕会变灰，选中的区域会变清楚，在松开左键时截的图片会在GUI窗口展示并消息框提示)
6）循环截屏会将截屏图片下载到用户指定目录中，并以001,002,003这样命名 3、适用场景：
多页面在线PPT等，不能直接下载图片，页面由多个图片组成没有成品页
......
非常实用的工具！博主在工具里设置了说明书按钮，根据说明可以快速掌握工具。
需要私信，(有偿，哈哈)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9b934cb1ea62fb5c080af65cc9f714a/" rel="bookmark">
			java 每日一练 (8)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 单选题2. 编程题 1. 单选题 1. 下列选项中关于 java 中 super 关键字的说法正确的是 () A： super 关键字是在子类对象内部指代父类对象的引用.
B ： super 关键字不仅可以指代子类的直接父类，还可以直接指代父类的父类.
C ： 子类通过 super 关键字只能调用父类的方法，而不能调用父类的属性.
D ： 子类通过 super 关键字只能调用父类的属性，而不能调用父类的方法 .
答案 ： A 正确 ，我们可以通过 super 访问父类的 方法和属性 以及 父类的构造函数
B ： 错误 ， super 直接指向子类的父类，而不能直线子类的爷爷辈 (父类的父类)
C , D 都错 ，super 关键字 可以访问 父类的属性和 方法
2. A派生出子类B，B派生出子类C，并且在java源代码中有如下声明： A a0=new A(); // 1 A a1=new B(); // 2 A a2=new C(); // 3 以下哪个说法是正确的？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9b934cb1ea62fb5c080af65cc9f714a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ffc8a23b5dd224f4de525a6a821861f/" rel="bookmark">
			【深度学习保姆级教学】学习笔记（一）：机器学习与深度学习&#43;神经网络基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 机器学习与深度学习：机器学习流程：主要区别：深度学习应用领域：机器学习常规套路：KNN(最邻近结点算法)流程： 神经网络基础：前向传播（得出损失）![请添加图片描述](https://img-blog.csdnimg.cn/77864b8cefe6438081bf491ab846df21.png)线性函数：f(x,W)=Wx+b损失函数：计算预测值和真实值的差距的一类型函数Softmax归一化指数函数： 反向传播（降低损失）反向传播计算：门单元：影响梯度分配 笔记基于以下视频P1-P9： 【深度学习保姆级教学】草履虫都能看懂！理论到实战、入门到起飞！
机器学习与深度学习： 机器学习流程： 数据获取特征工程（关键）建立模型评估与应用 主要区别： 机器学习：传统的人工进行特征工程
深度学习：通过神经网络自动的进行特征提取
深度学习应用领域： 计算机视觉CV和自然语言处理NLP
机器学习常规套路： 收集数据并给定标签训练一个分类器测试，评估 KNN(最邻近结点算法)流程： 计算已知类别数据集中的点与当前点的距离按照距离依次排序选取与当前点距离最小的K个点确定前K个点所在类别的出现概率返回前K个点出现频率最高的类别作为当前点预测分类
KNN不能用来图像分类：距离为像素点对应位置相减求和，导致背景成为主导，不能识别前景（主体） 神经网络基础： 前向传播（得出损失） 线性函数：f(x,W)=Wx+b W：权重参数（关键）
b：偏置项
损失函数：计算预测值和真实值的差距的一类型函数 正则化惩罚项：指由权重参数带来的损失，防止过拟合
Softmax归一化指数函数： 步骤：
指数处理：使得分区别更大，使分类效果更明显归一化：将得分值映射到(0,1)之间得到概率负对数函数：求损失，数值越小越好 sigmoid函数：将得分值映射到(0,1)之间
反向传播（降低损失） 反向传播计算： 过程：从后往前一步步按照链式法则求偏导。
目的：计算出W参数对于最终的损失值的重要程度。
梯度：梯度的本意是一个向量（矢量），表示某一函数在该点处的方向导数沿着该方向取得最大值。
门单元：影响梯度分配 加法门单元：均匀分配，各个参数的反向传播梯度是一样的。Max门单元：前向传播中Max门单元将最大值传播了过去，那么反向传播，梯度只会分配给最大值乘法门单元：反向传播的梯度分配是按照前向传播的参数互换后的比值来分配的 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64d5524804eac7434b7005317b01e133/" rel="bookmark">
			conda冗余package的清理（.conda/pkgs）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天跑一个论文的代码，结果环境给我报错
说我numpy的版本太高，我删掉重新pip install，结果又出其他问题，问了学长，学长说是把tensorflow和pytorch放一起了，冲突，又是一个血的教训…只好重新配环境。
结果一看自己的pkg文件夹居然有20多G！
这怎么可能，我就一个base环境，刚把那个装了tf和torch的环境删掉！
一看，发现全是重复的包。
查了一下，好像是因为每次conda update --all的时候，他都会先在这里下一份，真的坑，也不自动清理。
conda clean -p // 删除没有用的包 conda clean -a // 推荐，直接把所有没用的包全部删掉 天，13G
清完以后…
所以，如果你的C盘红了，试着输入那行神秘代码：
conda clean -a 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2458b07e1b24130ea76fdc66376f12f/" rel="bookmark">
			【轻量级标记语言】Markdown完整语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Markdown是一种轻量级的标记语言，它可以用简单的文本语法来实现文档的格式化。Markdown具有易读、易写的特点，同时又可以转换为HTML等其他格式，因此被广泛应用于写作、博客、文档编写等领域。比如在GitHub上，README文件就是使用Markdown语言编写的。 标题 在文本开头加上一个或多个 # 号表示文本是标题，# 的数量表示标题的级别，一共有六级标题。
示例：
# 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 段落和换行 Markdown 将连续的文本视为一个段落，段落之间用一个空行分隔。如果需要强制换行，可以在行末添加两个或以上的空格，然后回车。
示例：
这是第一个段落。 这是另一个段落。 这行文字会换行 因为它以两个空格结尾。 加粗和斜体 要将文本加粗，可以用两个 ** 包含文本；要将文本变成斜体，可以用一个 * 包含文本。
示例：
**这是加粗的文字** *这是斜体的文字* 列表 Markdown 支持有序列表和无序列表。
无序列表：用 *、+ 或 - 表示，后面加上一个空格。
示例：
- 这是一个无序列表项 - 这是另一个无序列表项 有序列表：用数字和 . 表示，后面加上一个空格。
示例：
1. 第一项 2. 第二项 3. 第三项 引用 用 &gt; 表示引用文本，可以嵌套多层。
示例：
&gt; 这是一段引用的文字。 &gt; &gt; &gt; 这是一个嵌套的引用。 &gt; &gt; 这是引用的另一段文字。 链接 用 链接名称 表示一个链接。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2458b07e1b24130ea76fdc66376f12f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91a0f2a81347be97e038101037b92e5a/" rel="bookmark">
			Springboot框架08 上传文件并且存到数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		业务层代码
@Override public JsonResult savefind(Find find, MultipartFile file,HttpServletRequest request) { //获取上传图片的相对路径 String img = LoadAndGetPath(file); //若返回为空 则报错文件过大 if (img==""||img.equals("")){ return new JsonResult(0,"文件不能超过50M"); } //将获取的图片路径存入find 后期存入数据库 find.setImage(img); int res; try { //存入数据库 res = infoMapper.savefind(find); }catch (Exception e){ return new JsonResult(0,"输入数据错误，请完善"); } if (res!=1){ return new JsonResult(0,"发布招领信息失败"); } return new JsonResult(1,"发布招领信息成功"); } private String LoadAndGetPath(MultipartFile file) { //获取初始文件名 String filename=file.getOriginalFilename(); //获取文件后缀 String suffix=filename.substring(filename.lastIndexOf(".")+1); //设置新文件创建路径 String newpath=""; //限制文件大小不超过50M if (file.getSize()&gt;52428800){ return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91a0f2a81347be97e038101037b92e5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80f86022cc0929ee5e2b2b79eb6d767b/" rel="bookmark">
			解决warning: ‘p‘ is used uninitialized in this function
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在练习数据结构，线性表顺序表的时候，
int main()
{
List *p;
initList(p);
InitList(p);
Print(*p);
int len = ListLength(*p);
}
Status initList(List *L)
{
L-&gt;data=(Elemtype*) malloc(LIST_INIT_SIZE*sizeof(Elemtype));
if(!L-&gt;data)
{
exit(OVERFLOW);
}
L-&gt;length = 0;
L-&gt;listsize = LIST_INIT_SIZE;
return OK;
}
这时，会报错，warning: 'p' is used uninitialized in this function
解决方法是
List p;
initList(&amp;p);
InitList(&amp;p);
Print(p);
int len = ListLength(p);
初始化一个List,再把List的地址传入函数，并用指针接收。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30bdd51dbfe0540a521258177426ec39/" rel="bookmark">
			异或与字符串反转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异或运算可以实现两个二进制位的交换，而不影响其他位。例如： // 假设a=3,b=5，用二进制表示为： a = 00000011 b = 00000101 // 第一步：a=a^b，相当于把a和b的每一位都异或一次，结果如下： a = 00000110 // a的第2位和第3位变成了1，其余不变 b = 00000101 // b不变 // 第二步：b=a^b，相当于把新的a和原来的b的每一位都异或一次，结果如下： a = 00000110 // a不变 b = 00000011 // b的第2位和第3位变成了0，其余不变，此时b等于原来的a // 第三步：a=a^b，相当于把新的a和新的b的每一位都异或一次，结果如下： a = 00000101 // a的第2位和第3位变成了0，其余不变，此时a等于原来的b b = 00000011 // b不变 可以看出，在这个过程中，只有两个数相同位置上不同的二进制位被交换了。这就是通过异或可以交换两个变量的原理。
使用异或运算符来交换两个变量的值的技巧 异或运算符的特点是：
任何数和0异或，结果仍然是原来的数，即a^0=a。任何数和自身异或，结果是0，即a^a=0。异或运算满足交换律和结合律，即ab=ba，(ab)c=a(bc)。 利用这些性质，可以实现不使用临时变量来交换两个变量的值。例如：
int a = 3; int b = 5; // 交换前：a=3,b=5 a = a ^ b; // a=(3^5)=6,b=5 b = a ^ b; // a=6,b=(6^5)=3 a = a ^ b; // a=(6^3)=5,b=3 // 交换后：a=5,b=3 字符串反转 #include &lt;iostream&gt; // 反转字符串的函数 void ReverseString(char* buf, int n) { if (n &lt; 2) return; *buf ^= *(buf + n - 1); // 交换首尾字符 *(buf + n - 1) ^= *buf; *buf ^= *(buf + n - 1); return ReverseString(buf + 1, n - 2); //递归调用 } int main(int argc, char* argv[]) { char x[] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30bdd51dbfe0540a521258177426ec39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fa0b8f3e137e62a56c905efd16399c6/" rel="bookmark">
			Tomcat的Connector启动过程分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 前言 前面分析了tomcat的整体架构和tomcat的启动过程，在分析启动过程的时候只讲了整体的启动过程，本篇来重点分析一下tomcat的Connector(连接器)组件的启动过程。
二.从Connector的构造开始 那么org.apache.catalina.connector.Connector是在什么时候被创建出来的呢？在上一篇tomcat的启动过程中我们跟进过了Digester解析tomcat的server.xml配置文件，在org.apache.catalina.startup.Catalina#createStartDigester方法中有一个段代码是：
// 此处使用的tomcat版本为8.0 digester.addRule("Server/Service/Connector", new ConnectorCreateRule()); 所以当解析到server.xml配置文件中的Connector标签之后，就会创建一个ConnectorCreateRule来执行Connector的相关操作。那么这个org.apache.catalina.startup.ConnectorCreateRule其实是一个org.apache.tomcat.util.digester.Rule，这个Rule接口主要是实现了在匹配相应的XML元素嵌套模式时要采取的操作，简单说就是他是规定XML解析的元素是如何被加载处理的，Rule有一个方法org.apache.tomcat.util.digester.Rule#begin，就是用来处理XML配置文件中的标签开头部分的，也就初始化之类的。
默认是空实现，所以我们来看org.apache.catalina.startup.ConnectorCreateRule的begin方法。
public void begin(String namespace, String name, Attributes attributes) throws Exception { Service svc = (Service)digester.peek(); Executor ex = null; if ( attributes.getValue("executor")!=null ) { ex = svc.getExecutor(attributes.getValue("executor")); } // 从配置文件中的Connector标签中获取protocol属性的值，那么默认我们的protocol值就是HTTP/1.1 Connector con = new Connector(attributes.getValue("protocol")); if (ex != null) { setExecutor(con, ex); } String sslImplementationName = attributes.getValue("sslImplementationName"); if (sslImplementationName != null) { setSSLImplementationName(con, sslImplementationName); } digester.push(con); } 由上面这段代码注释可以知道是通过xml的配置内容进行Connector的创建的，那么跟进到org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fa0b8f3e137e62a56c905efd16399c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2957f834eec0c1d454194cc5411c5606/" rel="bookmark">
			QT串口助手开发2之串口程序编写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 QT串口助手开发2之串口程序编写
QT串口助手开发2 系列文章目录一、前期准备工作1.1给选择框添加子选项1.2给控件命名ID 二、自动识别系统端口程序三、响应打开函数 一、前期准备工作 1.1给选择框添加子选项 书接上文
绘制好界面后，需要给每个控制命个名，再继续编写串口程序
直接对label直接更改标签名字即可同理pushbutton
设置选项框里面的子选项，设置波特率，串口号用程序的方式动态识别
设置方式见设置选项框的方法
同理校验位，数据位，停止位
1.2给控件命名ID 点击串口号后面的Combo Box 控件给其ID为cboxSerialPort
同理波特率更名为CboxBaudrate
校验位更名为CboxParity
数据位更名为CboxDataBits
停止位更名为CboxStopBits
pushbutton更名为打开和发送
Text Edit命名为TeditRecv、TeditSend
ctrl + r运行看下效果，如果觉得不是很好看，就在SizePolicy调整策略
二、自动识别系统端口程序 自动识别当前系统有效的端口，让你选择（在串口号那栏有子选项可以选择）
去帮助文档查看帮助文档查看方法
首先需要给头文件加功能模块可参考文档
QList列表里的每个成员都是SerialPortInfo，其实这个表就是有效端口的列表
类内的静态成员，可以直接通过类来调用不需要对象，直接调用就是两个::
availablePorts()这个函数返回一个列表到serialportInfo
接下来遍历这个列表，把列表里面的内容填到串口号后面的combo box里面去
帮助文档查看QList（列表或者数组）如何使用当作一个数组访问
在for循环里面，返回一个数组下标，at返回一个串口的信息
最详细写法参考参考写法
ctrl + r运行测试效果
测试成功，再添加2个模拟串口测试
ctrl + r 运行，测试成功
三、响应打开函数 参考文章添加链接描述
右键点击打开按钮转到槽
当打开按钮按下后，其余比如波特率…等等这些就不能在选择子选择，按钮就变成断开按钮类似这样
m开头是类内成员
写个函数，alt + enter 鼠标放在写的函数上，选择添加一个定义，界面就跳转了
这样就可以不用直自己写一个函数
我们要获取5个配置
并且设置进去（转到头文件）
再写其类内的成员
写.cpp文件
默认情况就是115200，你没选择波特率就是115200，以免没设置波特率
同理写其它位
校验位只写三种去除两种，太麻烦了（在ui界面也去掉）
这两种去掉
写.cpp文件
同理其它位
停止位：
写完后要返回open的结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2957f834eec0c1d454194cc5411c5606/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dd4194ca0ab013f6711dd01cd99db9c/" rel="bookmark">
			二叉树的创建与存储，以及遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树的定义 树是n个节点的集合，在任何一棵非空树中有且仅有一个被称为根的结点，当n&gt;1时，其余结点可以被分为m个互不相交的子集，其中每个子集又是一棵树，称其为根的子树 树的基本术语 结点：一个数据元素以及若干指向其子树的分支结点的度：结点所拥有的子树的棵树树的度：树中各个结点度的最大值叶子：度为0的结点称为叶子结点，又称为终端结点分支结点：度不为0的结点，又称为非终端结点结点的孩子：结点的子树的根称为该结点的孩子，该结点称为孩子结点的双亲根：没有双亲的结点结点的层次：从根开始定义，根为第一层，根的孩子所在的层为第二层，根的孩子的孩子所在的层为第三层，以此类推树的深度：树的叶子结点所在的最大层次兄弟结点：双亲一样的结点堂兄弟：双亲位于同一层的结点结点祖先：从根到该结点所经过的分支上的所有结点均称为该结点的祖先子孙：某个结点的子树上的所有结点都称为该节点的子孙有序树：若将树中各结点的各子树看成从左至右是有顺序的不能任意交换位置，则称该树为有序树，否则为无序树森林：m（m&gt;=0)棵互不相交的树的集合，所以任意一棵树都可以看成是由根和其子树森林所构成的 二叉树的定义 二叉树是n个节点的集合 ,在任何一棵非空二叉树中有且仅有一个被叫做根的节点，若n&gt;1，则其余节点被分成两个互不相交的子集，其中每一个子集又是一棵二叉树，分别称为左子树和右子树，所以二叉树的定义是递归的可以用递归算法来创建一棵二叉树。满二叉树：除了叶子结点以外其余结点的度全为2的二叉树完全二叉树：在满二叉树的最后一层上从右至左连续去除若干个叶子结点便得到了一棵完全二叉树。 二叉树的特点 二叉树中各结点的度小于等于2二叉树是有序树二叉树的每一层至多有pow(2,n-1)个结点深度为k的二叉树至多有pow(2,k)-1个结点 若二叉树中叶子结点即度为0的结点的个数为n0，度为2的结点的个数为n2，则n0=n2+1对于一棵有n个节点的完全二叉树其深度为([log2(n)]+1)将完全二叉树从左至右从上至下按层次编号1，2.....则对任意节点i，满足若i=1，则该结点为根节点无双亲，若i&gt;1则i的双亲为[i/2]；若2i&gt;n则结点i无左孩子反之结点i的左孩子为2i，若(2i+1 )大于n，则结点i无右孩子反之结点i的右孩子为(2i+1) 二叉树的存储结构 二叉树的顺序存储表示 对于完全二叉树而言，我们用一组地址连续的存储单元即一维数组依次从上至下从左至右的存储该完全二叉树 中的节点元素，对于普通的二叉树我们将其结点与其对应的完全二叉树相对照，存储在一维数组中，例如：
二叉树的顺序存储的特点
结点间的关系蕴含在其存储位置中浪费空间，适用于存储满二叉树或者完全二叉树 说明：鉴于顺序存储的二叉树比较简单，读者可以自己尝试定义二叉树的结点，然后将结点存储在一维数组中即可。
二叉树的链式存储表示 二叉树的结点可以用结构体类型来表示，定义不同的结点结构，可以构成不同的链式存储结构。
二叉链表：存储该二叉树的链表的结点的指针域有两个，分别指向该节点的左右孩子结点
三叉链表： 存储该二叉树的链表的结点的指针域有三个，分别指向左孩子结点，双亲结点，以及右孩子结点
二叉树的三种遍历方法 先序遍历：先访问根节点，再访问左子树和右子树，对左子树和右子树的访问也遵循根左右的原则中序遍历：先访问左子树，再访问根节点，最后访问右子树，对左子树和右子树的访问也遵循左根右的原则后序遍历：先访问左子树，再访问右子树，最后访问根节点，对左子树和右子树的访问也遵循左右根的顺序 由以上定义可知对二叉树的三种遍历方法都是递归的所以设计遍历方法时需要用到递归 下面演示用二叉链表来表示如图所示的二叉树，以及采用三种遍历方法遍历该二叉树的过程，在程序代码中给出了完整的注释：
第一步定义二叉树的结点，用结构体类型来定义节点结构 typedef struct BitNode { char value; //数据域，用于存放该节点的值 struct BitNode* lchild, * rchild; //二叉链表的节点中有两个指针与分别指向该节点的左右孩子节点 }BitNode,*Bitree; //为定义的结构体类型起别名为BitNode,以及为该结构体类型的指针起别名为Bitree,此时执行语句"BitNode a"相当于执行语句"struct BitNode a",执行语句"Bitree a"相当于执行语句"BitNode *a" 第二步创建该二叉树
Bitree CreateTree(Bitree head) { char value; Bitree p; //p = head = NULL; //相当于每次调用该函数都会把头指针设置为空指针；这显然是错误的 printf("请输入节点的值\n"); scanf("%c", &amp;value); getchar(); if (value == '#') return NULL; //创建二叉树，当输入#号时表示不再继续输入返回空指针给上一级调用对象，即将上一级节点没有左孩子或者没有右孩子，理解这一点很重要，函数的返回值是所定义的结构体类型的指针 else { p = (Bitree)malloc(sizeof(BitNode)); p-&gt;value = value; if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dd4194ca0ab013f6711dd01cd99db9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3d7c17d5d34188820a5aaed497d6f95/" rel="bookmark">
			SQL Server 字段去除空格&amp;特殊方法汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		------空格的ascii值为9
1.去除左边空格 LTRIM()
2.去除右边空格 RTRIM()
3. 去除回车符 REPLACE(@str, CHAR(13) , '') 4.去除换行符 REPLACE(str, CHAR(10), '') 5.去除回车换行符 REPLACE(str, CHAR(13) + CHAR(10), '')
6.替换空格 REPLACE(@str,' ','')
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f30dbc654e1f3432b98f316fe793d859/" rel="bookmark">
			BFS和DFS入门题 洛谷B3625
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接：https://www.luogu.com.cn/problem/B3625 题目描述： 解题思路： 用一个数组记录能到的点，用DFS或者用BFS从起点开始遍历，将所有的能到的点对应的数组置为1，写代码的时候注意边界处理。
BFS代码 首先将起点入队列，然后通过起点扩展其他节点，标记所有能到的节点。最后通过vis[n][m]就能得出答案了。用BFS还可以求最短路径，最小消费。因为BFS第一次到达的一定是最短的。
#include&lt;bits/stdc++.h&gt; using namespace std; int n,m; char arr[105][105]; int vis[105][105]; int fx[4][2]={{1,0},{-1,0},{0,1},{0,-1}};//定义上下左右四个方向 struct node{ int x,y; }; queue&lt;node&gt;q; int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ cin&gt;&gt;arr[i][j]; } } q.push({1,1});//将起点加入队列 vis[1][1]=1;//标记起点已经访问过，防止往回走 while(q.size()){ node p; p=q.front();//取队头 q.pop();//弹出队头 for(int i=0;i&lt;4;i++){ int x,y; x=p.x+fx[i][0]; y=p.y+fx[i][1]; if(x&gt;0&amp;&amp;x&lt;=n&amp;&amp;y&gt;0&amp;&amp;y&lt;=m&amp;&amp;vis[x][y]==0&amp;&amp;arr[x][y]!='#'){ q.push({x,y});//符合条件的入队列 vis[x][y]=1;//标记访问过 } } } if(vis[n][m]){ cout&lt;&lt;"Yes" ; }else{ cout&lt;&lt;"No"; } return 0; } DFS代码 思路同BFS差不多，拿起点去扩展，直到把所有能到的节点遍历完。
#include&lt;bits/stdc++.h&gt; using namespace std; int n,m; char arr[105][105]; int vis[105][105]; int fx[4][2]={{1,0},{-1,0},{0,1},{0,-1}}; void dfs(int x,int y){ vis[x][y]=1; for(int i=0;i&lt;4;i++){ int x1,y1; x1=x+fx[i][0]; y1=y+fx[i][1]; if(x1&gt;0&amp;&amp;x1&lt;=n&amp;&amp;y1&gt;0&amp;&amp;y1&lt;=m&amp;&amp;vis[x1][y1]==0&amp;&amp;arr[x1][y1]!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f30dbc654e1f3432b98f316fe793d859/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ece8d83e78aec5159cdab04bad5700a/" rel="bookmark">
			【软件模块】适用于所有单片机的按键扫描算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		适用于所有单片机的按键扫描算法 前言一、算法设计二、代码实现参考资料 前言 单片机按键扫描是指利用微控制器（MCU）的数字输入口，定期检测按键的电平状态并进行去抖动处理（防止误操作），判断按键是否被按下或松开。
常用的按键有两种：自复式按键和自锁式按键。自复式按键按下就通，松开就断，不会锁住。自锁式按键按下一次就通并锁住，再按一次就断并弹回，需要两次操作。
本文介绍一种用于自复式按键的扫描算法，它有软件消抖功能，可以检测按键的短按和长按检测。
一、算法设计 针对每一个独立按键，使用三个bits来标志按键的各个状态的转换：
TrigFlag：按键被按下的触发标志，仅在按键被第一次检测到按下时置位为1，其它状态保持为0IdleFlag：按键被松开的触发标志，仅在按键被第一次检测到松开时置位为1，其它状态保持为0ContFlag：按键实时的状态标志，按键被检测到按下时为1，被检测到松开时为0ReadBit：扫描检测到的按键状态，按下时为1，松开时为0 以下一次按键过程中，这三个标志的状态变化情况：
过程分析：
初始状态下，扫描按键状态ReadBit = 0，状态标志TrigFlag = 0,IdleFlag = 0,ContFlag = 0;按下按键后，扫描按键状态ReadBit = 1，经计算处理TrigFlag = 1,IdleFlag = 0,ContFlag = 1;再次扫描按键状态（消抖）ReadBit = 1，经计算处理TrigFlag = 0,IdleFlag = 0,ContFlag = 1，
标志由TrigFlag = 1,IdleFlag = 0,ContFlag = 1变到TrigFlag = 0,IdleFlag = 0,ContFlag = 1可以判断按键被按下;保持按键按下，扫描按键状态ReadBit = 1，状态标志也将保持TrigFlag = 0,IdleFlag = 0,ContFlag = 1不再变化;状态标志将保持为TrigFlag = 0,IdleFlag = 0,ContFlag = 1的时间达到设置的按键长按时间，可以判断按键被长按;当松开按键后，扫描按键状态ReadBit = 0，经计算处理TrigFlag = 0,IdleFlag = 1,ContFlag = 0;再次扫描按键状态（消抖）ReadBit = 0，经计算处理TrigFlag = 0,IdleFlag = 0,ContFlag = 0，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ece8d83e78aec5159cdab04bad5700a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4105d225a08224e488da128fb7530074/" rel="bookmark">
			Java Stream 实用特性：排序、分组和 teeing
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排序 基本数据类型排序 基本数据类型就是字符串、整型、浮点型这些，也就是要排序的列表中的元素都是这些基本类型的，比如 List&lt;Integer&gt;的。
下面就用一个整型列表举例说明。
正序排序
正序排序，也可以叫做按照自然顺序排序，对于整型来说就是从小到大的。
List&lt;Integer&gt; integerList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) { integerList.add(i); } List&lt;Integer&gt; collect = integerList.stream() .sorted() .collect(Collectors.toList()); System.out.println(collect); 复制代码 输出结果是 [0, 1, 2, 3, 4]，这很简单没什么好说的。
倒序排序
List&lt;Integer&gt; integerList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) { integerList.add(i); } List&lt;Integer&gt; collect2 = integerList.stream() .sorted(Comparator.reverseOrder()) .collect(Collectors.toList()); System.out.println(collect2); 复制代码 倒序排就是从大到小排序，也很简单在 sorted()方法中添加 Comparator.reverseOrder() 就可以了。
非基本类型实体排序 基本类型的列表排序很简单，但是在实际项目中用到的情况不太多，经常用到的还是我们自定义类型的排序，比如项目中有一个用户实体、一个订单实体、一个产品实体等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4105d225a08224e488da128fb7530074/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/41/">«</a>
	<span class="pagination__item pagination__item--current">42/128</span>
	<a class="pagination__item pagination__item--next btn" href="/page/43/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>