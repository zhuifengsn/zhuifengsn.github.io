<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>页面一次性加载数据过多时，页面卡死怎么办 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="页面一次性加载数据过多时，页面卡死怎么办" />
<meta property="og:description" content="问题：当后端一次性返回数据(array)过多时（例如1000条或者更多），会导致页面卡顿
优化思路之方案一：（推荐使用）
思路：利用插件pl-table
解决方案：https://developer.aliyun.com/mirror/npm/package/pl-table
示例：请看官方文档，里面描述很清楚，就不重复说了
推荐理由：dom结构固定，不是累加似加到页面
注意：基于element-ui但是不代表你需要安装element-ui才能使用pl-table，你可以不安装任何UI库，就可以使用pl-table。但是必须在集成vue框架下使用
优化思路之方案二：
思路：将这1000条数据划分为多个小数组，然后一段一段的加到页面上
解决方案：利用window.requestAnimationFrame()或者setInterval()
示例：以window.requestAnimationFrame()为例
window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行；
// data为所有数据的数组，callback 拿到当前数据要做的操作 ,pageSize 一次取多少条 UtilHandleBigData(data, callback, pageSize = 20) { const totalCount = data.length // 共多少条 // 可分多少页,就是分割为多少个小数组 const totalPageNumer = Math.ceil(totalCount / pageSize) let currentPageNumber = 1 // 当前页数 const handler = () =&gt; { const start = (currentPageNumber - 1) * pageSize const end = currentPageNumber * pageSize const currentData = data.slice(start, end) // 当前页的数据 if (typeof callback === &#39;function&#39;) { callback(currentData, { totalCount, totalPageNumer, currentPageNumber, pageSize }) } if (currentPageNumber &lt; totalPageNumer) { window." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/b1edd1887db799395f930a286d1ff4e2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-16T09:35:00+08:00" />
<meta property="article:modified_time" content="2020-09-16T09:35:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">页面一次性加载数据过多时，页面卡死怎么办</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>问题：</strong>当后端一次性返回数据(array)过多时（例如1000条或者更多），会导致页面卡顿</p> 
<p><strong>优化思路之方案一：（推荐使用）</strong></p> 
<p>思路：利用插件pl-table</p> 
<p>解决方案：<a href="https://developer.aliyun.com/mirror/npm/package/pl-table" rel="nofollow">https://developer.aliyun.com/mirror/npm/package/pl-table</a></p> 
<p>示例：请看官方文档，里面描述很清楚，就不重复说了</p> 
<p>推荐理由：dom结构固定，不是累加似加到页面</p> 
<p>注意：基于element-ui但是不代表你需要安装element-ui才能使用pl-table，你可以不安装任何UI库，就可以使用pl-table。但是必须在集成vue框架下使用</p> 
<p><strong>优化思路之方案二：</strong></p> 
<p>思路：将这1000条数据划分为多个小数组，然后一段一段的加到页面上</p> 
<p>解决方案：利用window.requestAnimationFrame()或者setInterval()</p> 
<p>示例：以window.requestAnimationFrame()为例</p> 
<p><strong><code>window.requestAnimationFrame()</code></strong> 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行；</p> 
<pre><code>// data为所有数据的数组，callback 拿到当前数据要做的操作 ,pageSize 一次取多少条
UtilHandleBigData(data, callback, pageSize = 20) {
   const totalCount = data.length // 共多少条
   // 可分多少页,就是分割为多少个小数组
   const totalPageNumer = Math.ceil(totalCount / pageSize)
   let currentPageNumber = 1 // 当前页数

   const handler = () =&gt; {
      const start = (currentPageNumber - 1) * pageSize
      const end = currentPageNumber * pageSize
      const currentData = data.slice(start, end) // 当前页的数据
      if (typeof callback === 'function') {
        callback(currentData, {
          totalCount,
          totalPageNumer,
          currentPageNumber,
          pageSize
        })
      }
      if (currentPageNumber &lt; totalPageNumer) {
          window.requestAnimationFrame(handler)
      }
      currentPageNumber++
  }
  handler()
}</code></pre> 
<p>使用</p> 
<pre><code>let allData = [0, 1, 2, ......]; // 接口所得的所有数据
let tableData = []; // 显示在页面的列表
UtilHandleBigData(allData, (data) =&gt; {
  tableData.push(...data);
}
</code></pre> 
<p><strong>优化思路之方案三：</strong></p> 
<p>思路：写个vue指令，给table滚动区域添加指令，绑定方法，达到要求，就滚动加载数据</p> 
<p>用法：</p> 
<pre><code>// directive.js文件
Vue.directive('loadMore', {
  bind(el, binding) {
    const bodyWrapper = el.querySelector('.el-table__body-wrapper')
    bodyWrapper.addEventListener('scroll', function() {
      const scrollDistance = this.scrollHeight - this.scrollTop - this.clientHeight
      // 触底加载下一页
      if (scrollDistance &lt;= 10) {
        binding.value()
      }
    })
  }
})
</code></pre> 
<p>然后再去main.js文件里注册</p> 
<pre><code>…………
import * as directives from '@/directive'

// 注册
Vue.use(directives)</code></pre> 
<p>具体文件使用</p> 
<pre><code>&lt;template&gt;
    &lt;el-table
       :data="tableData"
       v-loadMore="loadMore"
    &gt;
        ………………
    &lt;/el-table&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
    data() {
        allData: [], // 所有数据
        tableData: [], // 当前显示的数据
        pageNum: 1,   // 当前页数
        pageSize: 10  // 一次性展示多少条数据
    }
    methods: {
        loadMore() {
          if (this.pageNum * this.pageSize &lt; this.allData.length) {
            this.pageNum++
            this.tableData= this.allData.slice(0, this.pageNum * this.pageSize)
          }
        }

    }
}
&lt;/script&gt;</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8512ba52afee9b4068f0f2015e8d7e40/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">iOS进阶之多线程--NSThread详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2a53a57ee93c502fc9df3b43c72acf16/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">hdu1495 非常可乐 （bfs）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>