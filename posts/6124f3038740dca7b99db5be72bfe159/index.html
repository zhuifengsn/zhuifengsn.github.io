<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>排序——归并排序（Merge sort） - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="排序——归并排序（Merge sort）" />
<meta property="og:description" content="1945年，约翰·冯·诺依曼（John von Neumann）发明了归并排序，这是典型的分治算法的应用。
定义 归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。
算法思路 归并排序算法有两个基本的操作，一个是分，也就是把原数组划分成两个子数组的过程。另一个是治，它将两个有序数组合并成一个更大的有序数组。
将待排序的线性表不断地切分成若干个子表，直到每个子表只包含一个元素，这时，可以认为只包含一个元素的子表是有序表。将子表两两合并，每合并一次，就会产生一个新的且更长的有序表，重复这一步骤，直到最后只剩下一个子表，这个子表就是排好序的线性表。 图解算法 假设我们有一个初始数列为{8, 4, 5, 7, 1, 3, 6, 2}，整个归并排序的过程如下图所示。
分而治之 可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。
合并两个有序数组流程 再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。
动画展示 算法性能 速度仅次于快速排序。
时间复杂度 O(nlogn)。
空间复杂度 O(N)，归并排序需要一个与原数组相同长度的数组做辅助来排序。
稳定性 稳定。
代码实现 C和C&#43;&#43; void Merge(int sourceArr[],int tempArr[], int startIndex, int midIndex, int endIndex){ int i = startIndex, j=midIndex&#43;1, k = startIndex; while(i!=midIndex&#43;1 &amp;&amp; j!=endIndex&#43;1) { if(sourceArr[i] &gt; sourceArr[j]) tempArr[k&#43;&#43;] = sourceArr[j&#43;&#43;]; else tempArr[k&#43;&#43;] = sourceArr[i&#43;&#43;]; } while(i !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/6124f3038740dca7b99db5be72bfe159/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-02-09T19:16:13+08:00" />
<meta property="article:modified_time" content="2020-02-09T19:16:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">排序——归并排序（Merge sort）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1945年，约翰·冯·诺依曼（John von Neumann）发明了归并排序，这是典型的分治算法的应用。</p> 
<h2>定义</h2> 
<p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。</p> 
<h2>算法思路</h2> 
<p>归并排序算法有两个基本的操作，一个是<span style="color:#f33b45;"><strong>分</strong></span>，也就是把原数组划分成两个子数组的过程。另一个是<span style="color:#f33b45;"><strong>治</strong></span>，它将两个有序数组合并成一个更大的有序数组。</p> 
<ol><li>将待排序的线性表不断地切分成若干个子表，直到每个子表只包含一个元素，这时，可以认为只包含一个元素的子表是有序表。</li><li>将子表两两合并，每合并一次，就会产生一个新的且更长的有序表，重复这一步骤，直到最后只剩下一个子表，这个子表就是排好序的线性表。</li></ol> 
<h2>图解算法</h2> 
<p>假设我们有一个初始数列为{8, 4, 5, 7, 1, 3, 6, 2}，整个归并排序的过程如下图所示。</p> 
<h3>分而治之</h3> 
<p><img alt="" class="has" height="1200" src="https://images2.imgbox.com/90/12/oNH7PgKO_o.png" width="1200"></p> 
<p>可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。<strong>分</strong>阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。</p> 
<h3>合并两个有序数组流程</h3> 
<p>再来看看<strong>治</strong>阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。</p> 
<p><img alt="" class="has" height="1200" src="https://images2.imgbox.com/57/8a/uMnGpDrc_o.png" width="1200"></p> 
<h2>动画展示</h2> 
<p><img alt="" class="has" height="505" src="https://images2.imgbox.com/8d/bf/LUQxZ55r_o.gif" width="811"></p> 
<h2>算法性能</h2> 
<p>速度仅次于快速排序。</p> 
<h3><a name="t8"></a>时间复杂度</h3> 
<p><span style="color:#f33b45;"><strong>O(nlogn)</strong></span>。</p> 
<h3>空间复杂度</h3> 
<p><span style="color:#f33b45;"><strong>O(N)</strong></span>，归并排序需要一个与原数组相同长度的数组做辅助来排序。</p> 
<h3>稳定性</h3> 
<p><span style="color:#f33b45;"><strong>稳定</strong></span>。</p> 
<h2>代码实现</h2> 
<h3><a name="t12"></a>C和C++</h3> 
<pre class="has"><code class="language-cpp">void Merge(int sourceArr[],int tempArr[], int startIndex, int midIndex, int endIndex){
    int i = startIndex, j=midIndex+1, k = startIndex;
    while(i!=midIndex+1 &amp;&amp; j!=endIndex+1) {
        if(sourceArr[i] &gt; sourceArr[j])
            tempArr[k++] = sourceArr[j++];
        else
            tempArr[k++] = sourceArr[i++];
    }
    while(i != midIndex+1)
        tempArr[k++] = sourceArr[i++];
    while(j != endIndex+1)
        tempArr[k++] = sourceArr[j++];
    for(i=startIndex; i&lt;=endIndex; i++)
        sourceArr[i] = tempArr[i];
}
 
//内部使用递归
void MergeSort(int sourceArr[], int tempArr[], int startIndex, int endIndex) {
    int midIndex;
    if(startIndex &lt; endIndex) {
        midIndex = startIndex + (endIndex-startIndex) / 2;//避免溢出int
        MergeSort(sourceArr, tempArr, startIndex, midIndex);
        MergeSort(sourceArr, tempArr, midIndex+1, endIndex);
        Merge(sourceArr, tempArr, startIndex, midIndex, endIndex);
    }
}

int main(int argc, char * argv[]) {
    int a[8] = {50, 10, 20, 30, 70, 40, 80, 60};
    int i, b[8];
    MergeSort(a, b, 0, 7);
    for(i=0; i&lt;8; i++)
        printf("%d ", a[i]);
    printf("\n");
    return 0;
}</code></pre> 
<h3>Java</h3> 
<pre class="has"><code class="language-java">package MergeSort;
public class MergeSort {   
    public static int[] mergeSort(int[] nums, int l, int h) {
        if (l == h)
            return new int[] { nums[l] };
         
        int mid = l + (h - l) / 2;
        int[] leftArr = mergeSort(nums, l, mid); //左有序数组
        int[] rightArr = mergeSort(nums, mid + 1, h); //右有序数组
        int[] newNum = new int[leftArr.length + rightArr.length]; //新有序数组
         
        int m = 0, i = 0, j = 0; 
        while (i &lt; leftArr.length &amp;&amp; j &lt; rightArr.length) {
            newNum[m++] = leftArr[i] &lt; rightArr[j] ? leftArr[i++] : rightArr[j++];
        }
        while (i &lt; leftArr.length)
            newNum[m++] = leftArr[i++];
        while (j &lt; rightArr.length)
            newNum[m++] = rightArr[j++];
        return newNum;
    }
    public static void main(String[] args) {
        int[] nums = new int[] { 9, 8, 7, 6, 5, 4, 3, 2, 10 };
        int[] newNums = mergeSort(nums, 0, nums.length - 1);
        for (int x : newNums) {
            System.out.println(x);
        }
    }
}</code></pre> 
<h3>Python</h3> 
<pre class="has"><code class="language-python">def MergeSort(lists):
    if len(lists) &lt;= 1:
        return lists
    num = int( len(lists) / 2 )
    left = MergeSort(lists[:num])
    right = MergeSort(lists[num:])
    return Merge(left, right)

def Merge(left,right):
    r, l=0, 0
    result=[]
    while l&lt;len(left) and r&lt;len(right):
        if left[l] &lt;= right[r]:
            result.append(left[l])
            l += 1
        else:
            result.append(right[r])
            r += 1
    result += list(left[l:])
    result += list(right[r:])
    return result

print MergeSort([1, 2, 3, 4, 5, 6, 7, 90, 21, 23, 45])</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eb4c49f76f29c3f2aacb6310804ba13e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MWL/Modality Worklist SCP、Wordlist成像设备工作列表</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6c04c31e3d786af1fb0c3af49252da3c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Cpp 基础知识</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>