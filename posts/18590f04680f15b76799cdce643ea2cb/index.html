<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C#中的static静态变量的用法 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C#中的static静态变量的用法" />
<meta property="og:description" content="静态全局变量 定义：在全局变量前，加上关键字 static 该变量就被定义成为了一个静态全局变量。
特点： A、该变量在全局数据区分配内存。 B、初始化：如果不显式初始化，那么将被隐式初始化为0。
静态局部变量 定义：在局部变量前加上static关键字时，就定义了静态局部变量。
特点： A、该变量在全局数据区分配内存。 B、初始化：如果不显式初始化，那么将被隐式初始化为0。 C、它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。
静态数据成员 特点： A、内存分配：在程序的全局数据区分配。 B、初始化和定义： a、静态数据成员定义时要分配空间，所以不能在类声明中定义。 b、为了避免在多个使用该类的源文件中，对其重复定义，所以，不能在类的头文件中定义。 c、静态数据成员因为程序一开始运行就必需存在，所以其初始化的最佳位置在类的内部实现。 C、特点 a、对相于 public,protected,private 关键字的影响它和普通数据成员一样， b、因为其空间在全局数据区分配，属于所有本类的对象共享，所以，它不属于特定的类对象，在没产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它。 D、访问形式 a、 类对象名.静态数据成员名 E、静态数据成员，主要用在类的所有实例都拥有的属性上。比如，对于一个存款类，帐号相对于每个实例都是不同的，但每个实例的利息是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局区的内存，所以节省存贮空间。第二，一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了，因为它们实际上是共用一个东西。
静态成员函数 特点： A、静态成员函数与类相联系，不与类的对象相联系。 B、静态成员函数不能访问非静态数据成员。原因很简单，非静态数据成员属于特定的类实例。 作用： 主要用于对静态数据成员的操作。
调用形式： 类对象名.静态成员函数名（）
static静态变量的实例与分析 class class1 { static int i = getNum(); int j = getNum(); static int num = 1; static int getNum() { return num; } static void Main(string[] args) { Console.WriteLine(&#34;i={0}&#34;,i); Console.WriteLine(&#34;j={0}&#34;, new class1()." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/18590f04680f15b76799cdce643ea2cb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-03-04T15:03:15+08:00" />
<meta property="article:modified_time" content="2018-03-04T15:03:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C#中的static静态变量的用法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="静态全局变量">静态全局变量</h3> 
<p>定义：在全局变量前，加上关键字 <code>static</code> 该变量就被定义成为了一个静态全局变量。</p> 
<p>特点： <br> 　　A、该变量在全局数据区分配内存。 <br> 　　B、初始化：如果不显式初始化，那么将被隐式初始化为0。</p> 
<h3 id="静态局部变量">静态局部变量</h3> 
<p>定义：在局部变量前加上<code>static</code>关键字时，就定义了静态局部变量。</p> 
<p>特点： <br> 　　A、该变量在全局数据区分配内存。 <br> 　　B、初始化：如果不显式初始化，那么将被隐式初始化为0。 <br> 　　C、它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。</p> 
<h3 id="静态数据成员">静态数据成员</h3> 
<p>特点： <br> 　　A、内存分配：在程序的全局数据区分配。 <br> 　　B、初始化和定义： <br> 　　　 a、静态数据成员定义时要分配空间，所以不能在类声明中定义。 <br> 　　　 b、为了避免在多个使用该类的源文件中，对其重复定义，所以，不能在类的头文件中定义。 <br> 　　　 c、静态数据成员因为程序一开始运行就必需存在，所以其初始化的最佳位置在类的内部实现。 <br> 　　C、特点 <br> 　　　 a、对相于 <code>public,protected,private</code> 关键字的影响它和普通数据成员一样， <br> 　　　 b、因为其空间在全局数据区分配，属于所有本类的对象共享，所以，它不属于特定的类对象，在没产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它。 <br> 　　D、访问形式 <br> 　　　 a、 类对象名.静态数据成员名 <br> 　　E、静态数据成员，主要用在类的所有实例都拥有的属性上。比如，对于一个存款类，帐号相对于每个实例都是不同的，但每个实例的利息是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局区的内存，所以节省存贮空间。第二，一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了，因为它们实际上是共用一个东西。</p> 
<h3 id="静态成员函数">静态成员函数</h3> 
<p>特点： <br> 　　A、静态成员函数与类相联系，不与类的对象相联系。 <br> 　　B、静态成员函数不能访问非静态数据成员。原因很简单，非静态数据成员属于特定的类实例。 <br> 作用： <br> 　　主要用于对静态数据成员的操作。</p> 
<p>调用形式： <br> 　　类对象名.静态成员函数名（）</p> 
<h3 id="static静态变量的实例与分析">static静态变量的实例与分析</h3> 
<pre class="prettyprint"><code class=" hljs vala"> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">class1</span>
    {<!-- --></span>
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = getNum();
        <span class="hljs-keyword">int</span> j = getNum();

        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;

        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> getNum()
        {
            <span class="hljs-keyword">return</span> num;
        }

        <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> Main(<span class="hljs-keyword">string</span>[] args)
        {
            Console.WriteLine(<span class="hljs-string">"i={0}"</span>,i);
            Console.WriteLine(<span class="hljs-string">"j={0}"</span>, <span class="hljs-keyword">new</span> class1().j);
            Console.Read();
        }
    }</code></pre> 
<p>分析：<code>Console.WriteLine("i={0}",i);</code>这里<code>i</code>是<code>static</code>变量，而且类<code>class1</code>是第一次被引 用，要先为<code>class1</code>里面所有的<code>static</code>变量分配内存。尽管现在有超线程技术，但是指令在逻辑还是一条一条的按顺序执行的，所以先为<code>static int i</code>分配内存，并且在该内存中保持<code>int</code>的缺省值<code>0</code>，接着再为<code>static int num</code> 变量分配内存，值当然也为<code>0</code>。</p> 
<p>然后执行第二步，为变量赋值：先为<code>static int i</code>变量赋值，<code>i＝getNum（）</code>，看<code>getNum</code>里面的代码，就是<code>return num</code>，这个时候<code>num</code>的值是<code>0</code>，于是<code>i</code>就为<code>0</code>了。然后对变量<code>num</code>赋值，<code>num＝1；</code>这行代码执行后，<code>num</code>就为<code>1</code>了。</p> 
<p>所以最后的结果为：</p> 
<pre class="prettyprint"><code class=" hljs matlab"> <span class="hljs-built_in">i</span>＝<span class="hljs-number">0</span> <span class="hljs-built_in">j</span>＝<span class="hljs-number">1</span></code></pre> 
<p><strong>当以一次引用类的时候，会对类中的静态变量先按顺序进行分配内存空间，当全部分配完内存空间之后，在对静态变量按顺序赋值。</strong></p> 
<hr> 
<h3 id="static的优点是什么为什么要使用static-变量或函数">static的优点是什么？为什么要使用static 变量或函数？？</h3> 
<p>有一些频繁使用的东西，如果你每次使用都重新<code>new</code>一下，那么这个开销可能会很高，如果使用<code>static</code>，一直放在内存中，那么想用就直接用，而不需要重新<code>new</code>一块空间初始化数据。那么<code>static</code>就是为了实现一个系统的缓存作用的，其生命周期直到应用程序退出结束。</p> 
<p><strong>静态成员包括静态字段和静态属性，静态成员和类相关联，不依赖于对象而存在，只能由类访问，而不能由对象访问；</strong></p> 
<p>静态成员属于类所有，无认创建多少实例对象，静态成员在内存中只有一份；实例成员属于类的实例所有，每创建一个实例对象，实例成员都会在内存中分配一块内存区域。 <br> 所以静态成员一般用于存放共享的数据段，如数据库连接字符串等。</p> 
<p>一个类如果只包含静态成员和静态方法，则该类可以定义为静态类，给类加上<code>static</code>修饰符；</p> 
<h4 id="静态方法和非静态方法">静态方法和非静态方法：</h4> 
<p>一、性能上：静态方法和实例方法差别不大。所有方法，不管是静态方法还是实例方法，都是在JIT加载类时分配内存，不同的是静态方法以类名引用，而实例方法对对象实例引用。创建实例时，不会再为类的方法分配内存，所有的实例对象共用一个类的方法代码。因此静态方法和实例方法的调用，在性能上的差别微乎其微。</p> 
<p>二、静态方法只能由类访问；实例方法只能由对象访问。</p> 
<blockquote> 
 <p>优点： <br> <strong>1，静态变量在类载入时，就装入内存</strong> <br> <strong>2，使用时不用 New 就意味的不必 创建类中 所有对象，就可以调用 某个方法</strong> </p> 
 <p>缺点： <br> <strong>1，垃圾回收机制 不能 回收 静态变量，静态类变量 会常驻内存</strong></p> 
</blockquote> 
<hr> 
<h3 id="c中静态类的优缺点">c#中静态类的优缺点</h3> 
<h4 id="缺点">缺点：</h4> 
<blockquote> 
 <p>1、整个类型在程序运行期间只加载一次。 这样是对于那些经常使用的类型来说的，那就不用每次使用前都先加载。效率高些。但是对那些不常用的类型来说。 <br> 2、<strong>如果是静态类型，那就要一直占用相当的内存；一直到程序停止。或者应用程序域被卸载。所以应该只对那些常用的类型定义成静态类型。</strong></p> 
</blockquote> 
<h4 id="优点">优点：</h4> 
<blockquote> 
 <p>1、它们仅包含静态成员。 <br> 2、它们不能被实例化。 <br> 3、它们是密封的。 <br> 4、它们不能包含实例构造函数（C# 编程指南）。</p> 
</blockquote> 
<p>因此创建静态类与创建仅包含静态成员和私有构造函数的类大致一样。私有构造函数阻止类被实例化。</p> 
<p>使用静态类的优点在于，编译器能够执行检查以确保不致偶然地添加实例成员。编译器将保证不会创建此类的实利。</p> 
<p>静态类是密封的，因此不可被继承。静态类不能包含构造函数，但仍可声明静态构造函数以分配初始值或设置某个静态状态。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/533f6c955b3e8001bc4b3d85be9468b2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言数据结构之利用栈进行括号匹配的检验</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8767c2475da19a43df6803c3497c69c1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mysql创建数据库，并且指定编码utf8</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>