<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C#dynamic 类型】 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【C#dynamic 类型】" />
<meta property="og:description" content="在通过 dynamic 类型实现的操作中，该类型的作用是绕过编译时类型检查，改为在运行时解析这些操作。dynamic 类型简化了对 COM API（例如 Office Automation API）、动态 API（例如 IronPython 库）和 HTML 文档对象模型 (DOM) 的访问。
在大多数情况下，dynamic 类型与 object 类型的行为是一样的。但是，不会用编译器对包含dynamic 类型表达式的操作进行解析或类型检查。编译器将有关该操作信息打包在一起，并且该信息以后用于计算运行时操作。在此过程中，类型dynamic 的变量会编译到类型 object 的变量中。因此，类型dynamic 只在编译时存在，在运行时则不存在。
运用例子：如果我们在现实开发中遇到参数传递不确定性字段时候，可以通过dynamic创建运行时解析的对象，避免去创建更多的实体类对象！
如：我要计算店铺的租金，每个店铺的衡量标准不一样，计算该商店的算法需求的变量类型，个数不一样，难要为每个算法创建对应的对象进行传递，获取相应的参数进行技术吗？考虑到这样的问题我们可以通过dynamic 类型进行约束。
1.创建算法行为类，构造方法中传递要计算的参数对象。
using System; using System.Collections.Generic; using System.Linq; using System.Text; namespace ConsoleApplication1 { /// &lt;summary&gt; /// 计算行为类 /// &lt;/summary&gt; public class calculate { /// &lt;summary&gt; /// 运行时的参数传递对象 /// &lt;/summary&gt; private dynamic _obj; public calculate(dynamic obj) { this._obj = obj; } /// &lt;summary&gt; /// A类型算法的计算租金=monthnum*monthprice&#43;Commissionpric /// &lt;/summary&gt; public double AtypRental() { Console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/4b5e2637a112f7390f5da4e2e427c289/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-04-19T15:05:56+08:00" />
<meta property="article:modified_time" content="2016-04-19T15:05:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C#dynamic 类型】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span id="mt1" class="sentence">在通过 <strong>dynamic</strong> 类型实现的操作中，该类型的作用是绕过编译时类型检查，</span><span id="mt2" class="sentence">改为在运行时解析这些操作。</span><span id="mt3" class="sentence"><strong>dynamic</strong> 类型简化了对 COM API（例如 Office Automation API）、动态 API（例如 IronPython 库）和 HTML 文档对象模型 (DOM) 的访问。</span></p> 
<p><span id="mt4" class="sentence">在大多数情况下，<strong>dynamic</strong> 类型与 <strong>object</strong> 类型的行为是一样的。</span><span id="mt5" class="sentence">但是，不会用编译器对包含<strong>dynamic</strong> 类型表达式的操作进行解析或类型检查。</span><span id="mt6" class="sentence">编译器将有关该操作信息打包在一起，并且该信息以后用于计算运行时操作。</span><span id="mt7" class="sentence">在此过程中，类型<strong>dynamic</strong> 的变量会编译到类型 <strong>object</strong> 的变量中。</span><span id="mt8" class="sentence">因此，类型<strong>dynamic</strong> 只在编译时存在，在运行时则不存在。</span></p> 
<p>运用例子：如果我们在现实开发中遇到参数传递不确定性字段时候，可以通过<span id="mt8" class="sentence"><span id="mt1" class="sentence"><strong>dynamic</strong></span>创建运行时解析的对象，避免去创建更多的实体类对象！</span></p> 
<p><span id="mt8" class="sentence">如：我要计算店铺的租金，每个店铺的衡量标准不一样，计算该商店的算法需求的变量类型，个数不一样，难要为每个算法创建对应的对象进行传递，获取相应的参数进行技术吗？考虑到这样的问题我们可以通过<span id="mt1" class="sentence"><strong>dynamic</strong> 类型</span>进行约束。</span></p> 
<p>1.创建算法行为类，构造方法中传递要计算的参数对象。<br> <span id="mt8" class="sentence"></span><span id="mt8" class="sentence"></span><span id="mt8" class="sentence"></span></p> 
<p></p> 
<pre><code class="language-csharp">using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace ConsoleApplication1
{
    /// &lt;summary&gt;
    /// 计算行为类
    /// &lt;/summary&gt;
    public class calculate
    {
        /// &lt;summary&gt;
        /// 运行时的参数传递对象
        /// &lt;/summary&gt;
        private dynamic _obj;
        
        public calculate(dynamic obj)
        {
            this._obj = obj;
        }

        /// &lt;summary&gt;
        /// A类型算法的计算租金=monthnum*monthprice+Commissionpric
        /// &lt;/summary&gt;
        public double AtypRental()
        {
            Console.WriteLine("A类型算法的计算租金=monthnum*monthprice+Commissionpric");
            return (int)this._obj.monthnum * (double)this._obj.monthprice + (double)this._obj.Commissionpric;
        }

        /// &lt;summary&gt;
        /// B类型算法租金=daynum*dayprice
        /// &lt;/summary&gt;
        public double BtypRental()
        {
            Console.WriteLine("B类型算法租金=daynum*dayprice");
            return (int)this._obj.daynum * (double)this._obj.dayprice;
        }
    }
}
</code></pre>2.调用如下： 
<p></p> 
<p></p> 
<pre><code class="language-csharp">using System;
using System.Collections.Generic;
using System.Dynamic;
using System.Linq;
using System.Text;

namespace ConsoleApplication1
{
    class Program
    {
        static void Main(string[] args)
        {
            dynamic aobj = new ExpandoObject();//创建运行时解析的对象，用于传递A类型计算方法的参数
            aobj.monthnum = 30;     
            aobj.monthprice = 6000;
            aobj.Commissionpric = 3000;

            calculate cs = new calculate(aobj);
            double aprice=cs.AtypRental();
            Console.WriteLine("A类型计算结果：" + aprice);

            dynamic bobj = new ExpandoObject();//创建运行时解析的对象，用于传递B类型计算方法的参数
            aobj.daynum = 300;
            aobj.dayprice = 30;

            calculate cs2 = new calculate(aobj);
            double bprice= cs2.BtypRental();
            Console.WriteLine("B类型计算结果：" + bprice);

            //在通过 dynamic 类型实现的操作中，该类型的作用是绕过编译时类型检查，改为在运行时解析这些操作。
            //dynamic 类型简化了对 COM API（例如 Office Automation API）、动态 API（例如 IronPython 库）和 
            //HTML 文档对象模型 (DOM) 的访问。

            //所有我们在使用dynamic时类型进行参数传递时候要做好变量名称的约束。
        }
    }
}
</code></pre> 
<br> 这样就可以解决合理的进行参数传递约束。避免了开发工程中传递参数不确定属性所带来的困惑。 
<p></p> 
<p>这里的参数传递可以运用到 <span style="color:#3366FF"><a target="_blank" href="http://blog.csdn.net/heyangyi_19940703/article/details/51188966" rel="noopener noreferrer">C# 设计模式—工厂方法模式</a></span> Demo里面的算法参数传递改进上.<br> </p> 
<p><br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b21afdf5f4a44617e5b31def48839578/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">安装arm-linux-gdb</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/242ff73794b53b424310ef566a260d98/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">gdb命令学习</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>