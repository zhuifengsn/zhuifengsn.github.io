<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>矩阵的秩（Rank） - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="矩阵的秩（Rank）" />
<meta property="og:description" content="定义 一个矩阵 A 的列秩是 A 的线性无关的纵列的极大数目。类似地，行秩是 A 的线性无关的横行的极大数目。矩阵的列秩和行秩总是相等的，因此它们可以简单地称作矩阵 A 的秩。通常表示为 r(A)，rank(A) 或 rk(A)。
可替代定义 用行列式定义 设 A 为 m*n 矩阵，若 A 至少有一个 r 阶非零子式，而其所有 r&#43;1 阶子式全为零，则称 r 为 A 的秩。
性质 m × n 矩阵的秩不大于m且不大于n的一个非负整数，表示为 rk(A) ≤ min(m, n)。有尽可能大的秩的矩阵被称为有满秩；类似的，否则矩阵是秩不足（或称为“欠秩”）的。只有零矩阵有秩 0。A的秩最大为 min(m,n)。如果方块矩阵 A 是可逆的，当且仅当 A 有秩 n（也就是 A 有满秩）。A 的秩等于 r，当且仅当存在一个可逆的 m*m 矩阵 X 和一个可逆的 n*n 矩阵 Y 使得 。西尔韦斯特不等式：如果 A 是一个 m*n 的矩阵，且 B 是 n*k 的矩阵，则 。如果 AB，ABC 和 BC 有定义，则 。。如果 A 是实数上的矩阵，那么 。如果 A 是复数上的矩阵，那么 。 举例 计算矩阵 A 的秩最容易的方法就是高斯消元法，即利用矩阵的初等变换生成一个行阶梯形矩阵，由于矩阵的初等变化不会改变矩阵的秩。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/568ae30064ad34f4300926468f4f886c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-24T16:58:58+08:00" />
<meta property="article:modified_time" content="2020-11-24T16:58:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">矩阵的秩（Rank）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>定义</h2> 
<p>一个矩阵 A  的列秩是 A 的线性无关的纵列的极大数目。类似地，行秩是 A 的线性无关的横行的极大数目。矩阵的列秩和行秩总是相等的，因此它们可以简单地称作矩阵 A 的<strong>秩</strong>。通常表示为 r(A)，rank(A) 或 rk(A)。</p> 
<h2>可替代定义</h2> 
<h3>用行列式定义</h3> 
<p>设 A 为 m*n 矩阵，若 A 至少有一个 r 阶非零子式，而其所有 r+1 阶子式全为零，则称 r 为 A 的秩。</p> 
<h2>性质</h2> 
<ul><li><em>m</em> × <em>n </em>矩阵的秩不大于<em>m</em>且不大于<em>n</em>的一个非负整数，表示为 rk(<em>A</em>) ≤ min(<em>m</em>, <em>n</em>)。有尽可能大的秩的矩阵被称为有<strong>满秩</strong>；类似的，否则矩阵是<strong>秩不足</strong>（或称为“<strong>欠秩</strong>”）的。</li><li>只有零矩阵有秩 0。</li><li><em>A</em>的秩最大为 min(<em>m</em>,<em>n</em>)。</li><li>如果方块矩阵 <em>A</em> 是可逆的，当且仅当<em> A </em>有秩<em> n</em>（也就是<em> A </em>有满秩）。</li><li>A 的秩等于 r，当且仅当存在一个可逆的 m*m 矩阵 X 和一个可逆的 n*n 矩阵 Y 使得 <img alt="XAY=\begin{bmatrix} I_{r} &amp; 0 \\ 0 &amp; 0 \end{bmatrix}" class="mathcode" src="https://images2.imgbox.com/c8/05/bmSAhsjH_o.gif">。</li><li>西尔韦斯特不等式：如果 A 是一个 m*n 的矩阵，且 B 是 n*k 的矩阵，则 <img alt="rank(A)+rank(B)-n\leq rank(AB)" class="mathcode" src="https://images2.imgbox.com/9e/a4/jkb52BqZ_o.gif">。</li><li>如果 AB，ABC 和 BC 有定义，则 <img alt="rank(AB)+rank(BC)\leq rank(B)+rank(ABC)" class="mathcode" src="https://images2.imgbox.com/f8/cf/hYi1VjXg_o.gif">。</li><li><img alt="rank(A+B)\leq rank(A)+rank(B)" class="mathcode" src="https://images2.imgbox.com/fe/80/0oymDiv0_o.gif">。</li><li>如果 A 是实数上的矩阵，那么 <img alt="rank(A^{T}A)=rank(AA^T)=rank(A)=rank(A^T)" class="mathcode" src="https://images2.imgbox.com/dd/08/0sOxNci5_o.gif">。</li><li>如果 A 是复数上的矩阵，那么 <img alt="rank(A)=rank(\overline{A})=rank(A^T)=rank(A^*)=rank(A^*A)" class="mathcode" src="https://images2.imgbox.com/19/0f/jM38oMah_o.gif">。</li></ul> 
<h2>举例</h2> 
<p>计算矩阵 A 的秩最容易的方法就是高斯消元法，即利用矩阵的初等变换生成一个行阶梯形矩阵，由于矩阵的初等变化不会改变矩阵的秩。</p> 
<p><img alt="A=\begin{bmatrix} 2 &amp; 4 &amp; 1 &amp; 3\\ -1 &amp; -2 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp;2 &amp; 2\\ 3 &amp; 6 &amp; 2 &amp; 5 \end{bmatrix}" class="mathcode" src="https://images2.imgbox.com/bd/ac/eXRhx3pm_o.gif">，可以看到第 2 纵列是第 1 纵列的两倍，而第 4 纵列-等于第 1 和第 3 纵列的总和。第 1 和第 3 纵列是线性无关的，所以 <em>A </em>的秩是 2。这可以用高斯算法验证。它生成下列<em>A</em>的行阶梯形矩阵：<img alt="A=\begin{bmatrix} 1 &amp; 2 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 1 &amp; 1\\ 0 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix}" class="mathcode" src="https://images2.imgbox.com/aa/c5/LAHj7nmj_o.gif">，它有两个非零的横行。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5d2c7de3944b2486d112f5b22e527a83/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">逆矩阵和伴随矩阵（Inverse matrix and adjoint matrix）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/42b143633c3bbcd7f1ff5ffe8aa8083c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">矩阵的迹（Trace）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>