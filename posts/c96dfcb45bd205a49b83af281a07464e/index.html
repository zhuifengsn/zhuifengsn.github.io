<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构实验：链表的插入与删除 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构实验：链表的插入与删除" />
<meta property="og:description" content="实验1 链表的插入和删除
一、【实验目的】
了解单链表、循环链表和双链表的基本知识；掌握算法思想和数据结构的描述；掌握链表的插入、删除的相关语句及基本方法。 二、【实验内容】
设有两个无头结点的单链表，分别为ha，hb，其链中有数据域data，链域next，两链表的数据都按递增序存放。现要求将hb表归到ha表中，且归并后ha仍按递增排序，归并中ha表中已有的数据若与hb相同，则hb中的数据不归并到ha中，hb的链表在算法中不允许破坏。
#include&lt;iostream&gt; using namespace std; typedef struct LNode { int data;//数据域 LNode* next;//指针域 }LNode,*LinkList; void CreatList(LinkList&amp; L, int n) { //从创建一个不带头结点的链表 if (n &gt; 0) { L = new LNode; L-&gt;next = NULL;//创造一个首元结点 if (n == 1) { cin &gt;&gt; L-&gt;data;//一个元素直接用头指针创造的头结点存 } else if (n &gt; 1) { LNode* r = L;//指针r记录最后一个结点所在位置 cin &gt;&gt; r-&gt;data;//首元结点数据赋值 for (int i = 0; i &lt; n - 1; i&#43;&#43;) { LNode* p = new LNode;//开辟一个新结点 p-&gt;next = NULL; cin &gt;&gt; p-&gt;data;//数据域赋值 r-&gt;next = p;//原尾结点指针域指向p r = p;//尾结点地址r更新 } } } } void PrintList(LinkList&amp; L) { //输出链表 LNode* p = L; while (p) { cout &lt;&lt; p-&gt;data &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/c96dfcb45bd205a49b83af281a07464e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-22T22:26:07+08:00" />
<meta property="article:modified_time" content="2021-11-22T22:26:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构实验：链表的插入与删除</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0;text-align:center;"><strong>实验1 链表的插入和删除</strong></p> 
<p style="margin-left:0;text-align:center;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>一、【实验目的】</strong></p> 
<ol><li style="text-align:justify;">了解单链表、循环链表和双链表的基本知识；</li><li style="text-align:justify;">掌握算法思想和数据结构的描述；</li><li style="text-align:justify;">掌握链表的插入、删除的相关语句及基本方法。</li></ol> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>二、【实验内容】</strong></p> 
<p style="margin-left:0;text-align:justify;">设有两个无头结点的单链表，分别为ha，hb，其链中有数据域data，链域next，两链表的数据都按递增序存放。现要求将hb表归到ha表中，且归并后ha仍按递增排序，归并中ha表中已有的数据若与hb相同，则hb中的数据不归并到ha中，hb的链表在算法中不允许破坏。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<pre><code>#include&lt;iostream&gt;
using namespace std;

typedef struct LNode {
	int data;//数据域
	LNode* next;//指针域
}LNode,*LinkList;

void CreatList(LinkList&amp; L, int n) {
	//从创建一个不带头结点的链表
	if (n &gt; 0) {
		L = new LNode;
		L-&gt;next = NULL;//创造一个首元结点
		if (n == 1) {
			cin &gt;&gt; L-&gt;data;//一个元素直接用头指针创造的头结点存
		}
		else if (n &gt; 1) {
			LNode* r = L;//指针r记录最后一个结点所在位置
			cin &gt;&gt; r-&gt;data;//首元结点数据赋值
			for (int i = 0; i &lt; n - 1; i++) {
				LNode* p = new LNode;//开辟一个新结点
				p-&gt;next = NULL;
				cin &gt;&gt; p-&gt;data;//数据域赋值
				r-&gt;next = p;//原尾结点指针域指向p
				r = p;//尾结点地址r更新
			}
		}
	}
}

void PrintList(LinkList&amp; L) {
	//输出链表
	LNode* p = L;
	while (p) {
		cout &lt;&lt; p-&gt;data &lt;&lt; "\t";
		p = p-&gt;next;
	}
	cout &lt;&lt; endl;
}

void LinkSort(LinkList&amp; L) {
	//BubbleSort
	LNode* p = L;
	int n = 0;
	while (p) {//找到链表的长度
		p = p-&gt;next;
		n++;
	}
	int i, j, temp;
	for (i = 0; i &lt; n; i++) {
		p = L;//指针归首元结点
		for (j = 0; j &lt; n-i-1; j++) {
			if (p-&gt;data &gt; p-&gt;next-&gt;data) {//大于就交换值域
				temp = p-&gt;next-&gt;data;
				p-&gt;next-&gt;data = p-&gt;data;
				p-&gt;data = temp;
			}
			p = p-&gt;next;//p指针后移
		}
	}
}

void AddList(LinkList&amp; La, LinkList&amp; Lb) {//已排序好的Lb插入已排序好的La
	LNode* pa = La, * pb = Lb;//pa,pb指向首元
	LNode* q = La;//已插入完成部分最后一个数
	//首元结点操作
	if (La-&gt;data &gt; Lb-&gt;data) {//如果b的首元小于a，则p存Lb首元，插入La
		LNode* p = new LNode;
		p-&gt;data = pb-&gt;data;//存值
		p-&gt;next = La;//插到la首元前面
		La = p;//La指向p，p成为新首元
		pb = pb-&gt;next;//pb指向下一个结点
	}
	else {
		pa = La-&gt;next;//pa未排序指针向前一位
	}
	while (pb&amp;&amp;pa) {
		if (pa-&gt;data &gt; pb-&gt;data) {
			LNode* p = new LNode;
			q-&gt;next = p;//p接入已排序处
			p-&gt;data = pb-&gt;data;//pb数据录入p
			pb = pb-&gt;next;//pb向前挪一位
			q = q-&gt;next;// q向前挪一位
		}
		if (pa-&gt;data &lt; pb-&gt;data) {
			q-&gt;next = pa;//q后接pa的链
			pa = pa-&gt;next;
			q = q-&gt;next;//pa和q都向前挪一位
		}
		if (pa-&gt;data == pb-&gt;data) {
			q-&gt;next = pa;//q后接pa的链
			pa = pa-&gt;next;
			pb = pb-&gt;next;
			q = q-&gt;next;//pa,pb和q都向前挪一位
		}
	}
	while (pb) {
		LNode* p = new LNode;
		q-&gt;next = p;//p接入已排序处
		p-&gt;data = pb-&gt;data;//pb数据录入p
		pb = pb-&gt;next;//pb向前挪一位
		q = q-&gt;next;// q向前挪一位
	}
	q-&gt;next = NULL;
}

int main() {
	int na,nb;
	LinkList La, Lb;

	cout &lt;&lt; "请输入链表La元素个数：" &lt;&lt; endl;
	cin &gt;&gt; na;
	CreatList(La, na);

	cout &lt;&lt; "请输入链表Lb元素个数：" &lt;&lt; endl;
	cin &gt;&gt; nb;
	CreatList(Lb, nb);

	PrintList(La);//测试CreatList
	PrintList(Lb);

	LinkSort(La);//测试LinkSort
	LinkSort(Lb);

	cout &lt;&lt; "排序后" &lt;&lt; endl;

	PrintList(La);
	PrintList(Lb);

	cout &lt;&lt; "并入后" &lt;&lt; endl;
	AddList(La, Lb);
	PrintList(La);
	PrintList(Lb);

	system("pause");
	return 0;
}

//3 5 2 3
//4 5 6 4 3</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/be3258e6fd94cb7d304ee94e635f7cea/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">哈夫曼编码C&#43;&#43;实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d3baab712ee9b31f94821fe2079403a3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构实验：线性表（一元多项式相加）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>