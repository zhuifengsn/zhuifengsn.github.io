<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构——多项式的加减乘法以及合并同类项的算法 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构——多项式的加减乘法以及合并同类项的算法" />
<meta property="og:description" content="测试数据（这里只测试了一组数据，小伙伴们可以自行测试其他数据喔）
2 2 3 3 4 4 0 0
1 2 2 2 0 0
1 2 1 1 0 0 1 2 1 3 0 0
-1 2 -5 3 -4 2 0 0 2 3 -4 2 -3 6 0 0
2 2 4 4 3 3 6 6 5 5 0 0 8 7 4 5 6 1 1 3 3 5 0 0
1 2 3 4 5 6 7 8 0 0 2 2 4 4 6 6 8 8 0 0" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/88dc036fc2f4153e90fee733f22d7466/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-18T19:56:35+08:00" />
<meta property="article:modified_time" content="2022-11-18T19:56:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构——多项式的加减乘法以及合并同类项的算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>测试数据（这里只测试了一组数据，小伙伴们可以自行测试其他数据喔）</p> 
<p>2 2 3 3 4 4 0 0<br> 1 2 2 2 0 0</p> 
<p>1 2 1 1 0 0 <br> 1 2 1 3 0 0</p> 
<p>-1 2 -5 3 -4 2 0 0 <br> 2 3 -4 2 -3 6 0 0</p> 
<p>2 2 4 4 3 3 6 6 5 5 0 0 <br> 8 7 4 5 6 1 1 3 3 5 0 0</p> 
<p>1 2 3 4 5 6 7 8 0 0 <br> 2 2 4 4 6 6 8 8 0 0</p> 
<p>1 2 3 4 5 6 7 8 0 0<br> 1 1 3 3 5 5 7 7 0 0</p> 
<p><img alt="" height="957" src="https://images2.imgbox.com/a0/bc/cQ370vsc_o.png" width="1200"></p> 
<p>这里插入链表使用的是尾插法</p> 
<p>加减法（其实减法和加法的思路差不多，都是判断指数相同与否，然后对系数实现加减法）</p> 
<p>乘法主要是遍历两遍链表（因为一个多项式中每一项都要乘一遍另一个多项式的每一项，因此需要遍历两遍），系数相乘，指数相加</p> 
<p>合并同类项（主要采用了迭代的思想，用head保存p1节点的下一节点，这样在p2遍历完后还可以回到p1的下一加点处）</p> 
<p>打印多项式（只需要判断第一项的正负就可以啦，后面的都可以直接遍历）</p> 
<pre><code class="language-cpp">​
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;math.h&gt;
#include&lt;iostream&gt;
struct node {
	int exp;//指数
	int coe;//系数
	struct node *next;
} ;
typedef struct node *List;

struct node *create();
struct node *insert(List L);
struct node *add(List L1,List L2,List L3);
struct node *sub(List L1,List L2,List L3);
struct node *mul(List L1,List L2,List L3);
void print(List L);
List merge(List L);

int main() {
	List L1=create();
	List L2=create();
	List L3;
	printf("请输入多项式1(输入以0 0为结尾)：\n");
	insert(L1);
	printf("多项式1为：\n");
	print(merge(L1));
	printf("\n");

	printf("请输入多项式2（输入以0 0为结尾）：\n");
	insert(L2);
	printf("多项式2为：\n");
	print(merge(L2));
	printf("\n");

	printf("相加后的多项式为：\n");
	print(add(L1,L2,L3));
	printf("\n");

	printf("相减后的多项式为：\n");
	print(sub(L1,L2,L3));
	printf("\n");

	printf("相乘后的多项式为：\n");
	print(merge(mul(L1,L2,L3)));
	printf("\n");
}

//初始化链表
struct node *create() {
	List head=(List)malloc(sizeof(struct node));
	if(head!=NULL) {
		head-&gt;coe=0;
		head-&gt;exp=0;
		head-&gt;next=NULL;
	}
	return head;
}
//插入链表
struct node *insert(List L) {
	List s,t;
	int e,c;
	int count=0;
	t=L;
	scanf("%d %d",&amp;c,&amp;e);
	while(e!=0&amp;&amp;c!=0) {
		if(c&lt;0){
			count++;
		}
		s=(List)malloc(sizeof(struct node));
		s-&gt;coe=c;
		s-&gt;exp=e;
		s-&gt;next=NULL;
		t-&gt;next=s;
		t=s;
		scanf("%d %d",&amp;c,&amp;e);
	}
	printf("系数为负的个数为：%d\n",count);
	return L;
}
//加法
struct node *add(List L1,List L2,List L3) {
	List a=L1;
	List b=L2;
	List t;
	struct node *s;
	L3=(List)malloc(sizeof(struct node));
	L3-&gt;next=NULL;
	t=L3;
	//同时输入了L1,L2链表
	while(a-&gt;next!=NULL&amp;&amp;b-&gt;next!=NULL) {
		if(a-&gt;next-&gt;exp==b-&gt;next-&gt;exp) {
			s=(List)malloc(sizeof(struct node));//创建一个新节点存放L1与L2相加后的数据
			s-&gt;coe=a-&gt;next-&gt;coe+b-&gt;next-&gt;coe;
			s-&gt;exp=a-&gt;next-&gt;exp;
			s-&gt;next=NULL;
			t-&gt;next=s;
			t=s;
			a=a-&gt;next;
			b=b-&gt;next;
		} else if(a-&gt;next-&gt;exp &lt; b-&gt;next-&gt;exp) {
			s=(List)malloc(sizeof(struct node));
			s-&gt;coe=a-&gt;next-&gt;coe;
			s-&gt;exp=a-&gt;next-&gt;exp;
			s-&gt;next=NULL;

			t-&gt;next=s;
			t=s;
			a=a-&gt;next;
		} else  {
			s=(List)malloc(sizeof(struct node));
			s-&gt;coe=b-&gt;next-&gt;coe;
			s-&gt;exp=b-&gt;next-&gt;exp;
			s-&gt;next=NULL;
			t-&gt;next=s;
			t=s;
			b=b-&gt;next;
		}
	}
	//只输入了L1链表
	while(a-&gt;next!=NULL) {
		s=(List)malloc(sizeof(struct node));
		s-&gt;coe=a-&gt;next-&gt;coe;
		s-&gt;exp=a-&gt;next-&gt;exp;
		s-&gt;next=NULL;
		t-&gt;next=s;
		t=s;
		a=a-&gt;next;
	}
	//只输入了L2链表
	while(b-&gt;next!=NULL) {
		s=(List)malloc(sizeof(struct node));
		s-&gt;coe=b-&gt;next-&gt;coe;
		s-&gt;exp=b-&gt;next-&gt;exp;
		s-&gt;next=NULL;
		t-&gt;next=s;
		t=s;
		b=b-&gt;next;
	}

	return L3;
}
//减法
struct node *sub(List L1,List L2,List L3) {
	List a=L1;
	List b=L2;
	List t;
	struct node *s;
	L3=(List)malloc(sizeof(struct node));
	L3-&gt;next=NULL;
	t=L3;
	//同时输入了L1,L2链表
	while(a-&gt;next!=NULL&amp;&amp;b-&gt;next!=NULL) {
		if(a-&gt;next-&gt;exp==b-&gt;next-&gt;exp) {
			s=(List)malloc(sizeof(struct node));//创建一个新节点存放L1与L2相加后的数据
			s-&gt;coe=a-&gt;next-&gt;coe-b-&gt;next-&gt;coe;
			s-&gt;exp=a-&gt;next-&gt;exp;
			s-&gt;next=NULL;
			if(s-&gt;coe==0) {
				free(s);
			}
			t-&gt;next=s;
			t=s;
			a=a-&gt;next;
			b=b-&gt;next;

		} else if(a-&gt;next-&gt;exp &lt; b-&gt;next-&gt;exp) {
			s=(List)malloc(sizeof(struct node));
			s-&gt;coe=a-&gt;next-&gt;coe;
			s-&gt;exp=a-&gt;next-&gt;exp;
			s-&gt;next=NULL;
			t-&gt;next=s;
			t=s;
			a=a-&gt;next;
		} else  if(a-&gt;next-&gt;exp &gt; b-&gt;next-&gt;exp) {
			s=(List)malloc(sizeof(struct node));
			s-&gt;coe=-b-&gt;next-&gt;coe;
			s-&gt;exp=b-&gt;next-&gt;exp;
			s-&gt;next=NULL;
			t-&gt;next=s;
			t=s;
			b=b-&gt;next;
		}
	}
	//只输入了L1链表
	while(a-&gt;next!=NULL) {
		s=(List)malloc(sizeof(struct node));
		s-&gt;coe=a-&gt;next-&gt;coe;
		s-&gt;exp=a-&gt;next-&gt;exp;
		s-&gt;next=NULL;
		t-&gt;next=s;
		t=s;
		a=a-&gt;next;
	}
	//只输入了L2链表
	while(b-&gt;next!=NULL) {
		s=(List)malloc(sizeof(struct node));
		s-&gt;coe=b-&gt;next-&gt;coe;
		s-&gt;exp=b-&gt;next-&gt;exp;
		s-&gt;next=NULL;
		t-&gt;next=s;
		t=s;
		b=b-&gt;next;
	}

	return L3;
}
//乘法
struct node *mul(List L1,List L2,List L3) {
	List a,b,t,head;
	a=L1-&gt;next;
	b=L2-&gt;next;
	head=L2-&gt;next;
	struct node *s;
	L3=(List)malloc(sizeof(struct node));
	L3-&gt;next=NULL;
	t=L3;
	while(a!=NULL) {
		while(b!=NULL) {
			s=(List)malloc(sizeof(struct node));//辅助节点，暂时存储数据 
			s-&gt;coe=a-&gt;coe*b-&gt;coe;
			s-&gt;exp=a-&gt;exp+b-&gt;exp;
			s-&gt;next=NULL;
			t-&gt;next=s;
			t=s;
			b=b-&gt;next;
		}
		a=a-&gt;next;
		b=head;//b链表返回第一个多项式 
	}
	return L3;
}
//多项式合并同类项
List merge(List L) {
	List p1,p2,temp,head;
	p1=L-&gt;next;
	
	while(p1!=NULL) {
		p2=p1-&gt;next;
		head=p1-&gt;next;
		while(p2!=NULL) {
			if(p1-&gt;exp==p2-&gt;exp) {
				p1-&gt;coe=p1-&gt;coe+p2-&gt;coe;
				temp=p2;
				p1-&gt;next=p2-&gt;next;
				free(temp);
				p2=p1-&gt;next;
			} else {
				p2=p2-&gt;next;
			}
		}
		p2=head;//让p2回到 p1节点的下一个节点处 
		p1=p1-&gt;next;
	}
	return L;
}
//打印多项式
void print(List L) {
	List p;
	p=L;
	if(p-&gt;next-&gt;coe&gt;0) {
		printf("%dx^%d",p-&gt;next-&gt;coe,p-&gt;next-&gt;exp);
		p = p-&gt;next;
	}
	while ( p-&gt;next!=NULL) {
		if(p-&gt;next-&gt;coe&gt;0) {
			printf("+%dx^%d",p-&gt;next-&gt;coe,p-&gt;next-&gt;exp);
			p = p-&gt;next;
		} else if(p-&gt;next-&gt;coe&lt;0) {
			printf("%dx^%d",p-&gt;next-&gt;coe,p-&gt;next-&gt;exp);
			p = p-&gt;next;
		}
	}
}



​</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e84ec487776e6774c3ecfd0daaeba4c8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux开发工具VI/VIM</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c5a825a9ae93cd5fba25dff6d645374b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">希望计算机专业同学都知道这些老师</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>