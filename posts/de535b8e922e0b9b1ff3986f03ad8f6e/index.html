<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python函数装饰器 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python函数装饰器" />
<meta property="og:description" content="1.1 python装饰器 装饰器(Decorators)是 Python 的一个重要部分。简单地说：他们是修改其他函数的功能的函数。他们有助于让我们的代码更简短。
python的装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。简单的说装饰器就是一个用来返回函数的函数。
1.2 python装饰器应用场景 比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。 1.3 装饰器语法糖 python提供了@符号作为装饰器的语法糖，使我们更方便的应用装饰函数。但使用语法糖要求装饰函数必须return一个函数对象。因此我们将上面的func函数使用内嵌函数包裹并return。
1.3.1 函数装饰器 （1）不带参数装饰器，不带参数函数
def use_logging(func): def _deco(): print(&#34;%s is running&#34; % func.__name__) func() return _deco @use_logging def bar(): print(&#39;i am bar&#39;) if __name__ == &#39;__main__&#39;: bar() 装饰器相当于执行了装饰函数use_loggin后又返回被装饰函数bar,因此bar()被调用的时候相当于执行了两个函数。等价于use_logging(bar)()。
执行结果：
bar is running
i am ba
（2）不带参数装饰器，带参数函数
def use_logging(func): def _deco(a, b): print(&#34;%s is running&#34; % func.__name__) func(a, b) return _deco @use_logging def bar(a, b): print(&#39;i am bar:%s&#39;%(a&#43;b)) if __name__ == &#39;__main__&#39;: bar(1, 2) 参数需要传入两个参数并计算值，因此我们需要对内层函数进行改动传入我们的两个参数a和b，等价于use_logging(bar)(1,2)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/de535b8e922e0b9b1ff3986f03ad8f6e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-13T00:03:39+08:00" />
<meta property="article:modified_time" content="2022-04-13T00:03:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python函数装饰器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>1.1 python装饰器</h3> 
<p>装饰器(Decorators)是 Python 的一个重要部分。简单地说：他们是修改其他函数的功能的函数。他们有助于让我们的代码更简短。</p> 
<p>python的装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。简单的说装饰器就是一个用来返回函数的函数。</p> 
<h3>1.2 python装饰器应用场景</h3> 
<p>比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。 </p> 
<p></p> 
<h3>1.3 装饰器语法糖</h3> 
<p>python提供了@符号作为装饰器的语法糖，使我们更方便的应用装饰函数。但使用语法糖要求装饰函数必须return一个函数对象。因此我们将上面的func函数使用内嵌函数包裹并return。</p> 
<h4>1.3.1 函数装饰器</h4> 
<p>（1）不带参数装饰器，不带参数函数</p> 
<pre><code class="language-python">def use_logging(func):
  def _deco():
    print("%s is running" % func.__name__)
    func()
  return _deco
@use_logging
def bar():
  print('i am bar')
if __name__ == '__main__':
    bar()</code></pre> 
<p>装饰器相当于执行了装饰函数use_loggin后又返回被装饰函数bar,因此bar()被调用的时候相当于执行了两个函数。等价于use_logging(bar)()。</p> 
<p>执行结果：</p> 
<p>bar is running<br> i am ba</p> 
<p>（2）不带参数装饰器，带参数函数</p> 
<pre><code class="language-python">def use_logging(func):
  def _deco(a, b):
    print("%s is running" % func.__name__)
    func(a, b)
  return _deco
@use_logging
def bar(a, b):
  print('i am bar:%s'%(a+b))
if __name__ == '__main__':
    bar(1, 2)</code></pre> 
<p> 参数需要传入两个参数并计算值，因此我们需要对内层函数进行改动传入我们的两个参数a和b，等价于use_logging(bar)(1,2)</p> 
<p>输出结果：</p> 
<p> bar is running<br> i am bar:3</p> 
<p>（3）不带参数装饰器，带不定参数函数</p> 
<pre><code class="language-python">def use_logging(func):
  def _deco(*args, **kwargs):
    print("%s is running" % func.__name__)
    func(*args, **kwargs)
  return _deco
@use_logging
def bar(a, b):
  print('i am bar:%s'%(a+b))
@use_logging
def foo(a, b, c):
  print('i am bar:%s'%(a+b+c))
if __name__ == '__main__':
    bar(1, 2)
    foo(1, 2, 3)</code></pre> 
<p>输出结果：</p> 
<p>bar is running<br> i am bar:3<br> foo is running<br> i am bar:6</p> 
<p>（4）带参数装饰器，带参数函数</p> 
<pre><code class="language-python">def use_logging(level):
  def _deco(func):
    def __deco(*args, **kwargs):
      if level == "warn":
        print "%s is running" % func.__name__
      return func(*args, **kwargs)
    return __deco
  return _deco
@use_logging(level="warn")
def bar(a,b):
  print('i am bar:%s'%(a+b))
bar(1,3)</code></pre> 
<p> 等价于use_logging(level="warn")(bar)(1,3)</p> 
<p>（5）使用functools.wraps</p> 
<p>使用装饰器极大地复用了代码，但是他有一个缺点就是原函数的元信息不见了，比如函数的docstring、__name__、参数列表</p> 
<pre><code class="language-python">def use_logging(func):
  def _deco(*args,**kwargs):
    print("%s is running" % func.__name__)
    func(*args,**kwargs)
  return _deco
@use_logging
def bar():
  print('i am bar')
  print(bar.__name__)
bar()</code></pre> 
<p>输出结果：</p> 
<p><code>#bar is running</code></p> 
<p><code>#i am bar</code></p> 
<p><code>#_deco</code></p> 
<p>函数名变为_deco而不是bar，即装饰器装饰完之后，我们被装饰的函数的名字会变成装饰器函数。</p> 
<p>增加<code>@functools.wraps(f)</code>, 可以保持当前装饰器去装饰的函数的 <code>__name__</code>的值不变</p> 
<pre><code class="language-python">import functools
def use_logging(func):
  @functools.wraps(func)
  def _deco(*args,**kwargs):
    print("%s is running" % func.__name__)
    func(*args,**kwargs)
  return _deco
@use_logging
def bar():
  print('i am bar')
  print(bar.__name__)
bar()</code></pre> 
<h4> 1.3.2 类装饰器</h4> 
<pre><code class="language-python">class loging(object):
  def __init__(self,level="warn"):
    self.level = level
  def __call__(self,func):
    @functools.wraps(func)
    def _deco(*args, **kwargs):
      if self.level == "warn":
        self.notify(func)
      return func(*args, **kwargs)
    return _deco
  def notify(self,func):
    # logit只打日志，不做别的
    print "%s is running" % func.__name__
@loging(level="warn")#执行__call__方法
def bar(a,b):
  print('i</code></pre> 
<p>继承类装饰器</p> 
<pre><code class="language-python">class email_loging(Loging):
  '''
  一个loging的实现版本，可以在函数调用时发送email给管理员
  '''
  def __init__(self, email='admin@myproject.com', *args, **kwargs):
    self.email = email
    super(email_loging, self).__init__(*args, **kwargs)
  def notify(self,func):
    # 发送一封email到self.email
    print "%s is running" % func.__name__
    print "sending email to %s" %self.email
@email_loging(level="warn")
def bar(a,b):
  print('i am bar:%s'%(a+b))
bar(1,3)</code></pre> 
<p>参考文献：</p> 
<p>【1】<a href="https://www.runoob.com/w3cnote/python-func-decorators.html" rel="nofollow" title="Python 函数装饰器 | 菜鸟教程">Python 函数装饰器 | 菜鸟教程</a></p> 
<p>【2】<a href="https://www.zhihu.com/question/26930016/answer/1047233982" rel="nofollow" title="如何理解Python装饰器？ - 知乎">如何理解Python装饰器？ - 知乎</a> </p> 
<p>【3】<a href="https://www.cnblogs.com/arvin-feng/p/11108799.html" rel="nofollow" title="Python装饰器用法实例总结 - arvin_feng - 博客园">Python装饰器用法实例总结 - arvin_feng - 博客园</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/34c81e5b3f7594fa87bb2d9047094478/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c#调用python</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f6366c87dfe66c40cbc2b2b76d021f98/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">flask sssti lab闯关记录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>