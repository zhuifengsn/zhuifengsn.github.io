<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构 顺序队列的表示和实现 C语言版 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构 顺序队列的表示和实现 C语言版" />
<meta property="og:description" content="#define _CRT_SECURE_NO_WARNINGS 1 #include&lt;stdio.h&gt; #include&lt;malloc.h&gt; #define ERROR 0 #define OK 1 #define MAXQSIZE 20 typedef int QElemType; /*队列元素类型，以整型为例实现*/ typedef struct { QElemType* base; //指向循环队列的存储空间 int front; //队头指针 int rear; //队尾指针 }SqQueue; //初始化队列 int InitQueue(SqQueue* Q) { Q-&gt;base = (QElemType*)malloc(MAXQSIZE * sizeof(QElemType)); if (!Q-&gt;base) return ERROR; //申请存储空间失败 Q-&gt;front = Q-&gt;rear = 0; //设置队头队尾指针 return OK; } //求队长 int QueueLength(SqQueue Q) { return(Q.rear - Q.front &#43; MAXQSIZE) % MAXQSIZE; } //入队 int EnQueue(SqQueue* Q, QElemType e) { if ((Q-&gt;rear &#43; 1) % MAXQSIZE == Q-&gt;front) //判断对是否已满 return ERROR; Q-&gt;base[Q-&gt;rear] = e; //元素e入队 Q-&gt;rear = (Q-&gt;rear &#43; 1) % MAXQSIZE; //修改队尾指针 return OK; } //出队 int DeQueue(SqQueue* Q, QElemType* e) { if (Q-&gt;front == Q-&gt;rear) return ERROR; //判断队空 *e = Q-&gt;base[Q-&gt;front]; //*e返回队头元素值 Q-&gt;front = (Q-&gt;front &#43; 1) % MAXQSIZE; //修改队头指针 return OK; } //判队空 int QueueEmpty(SqQueue* Q) { if (Q-&gt;front == Q-&gt;rear) return OK; else return ERROR; }/*QueueEmpty*/ //取队头 int GetHead(SqQueue* Q, QElemType* e) { if (Q-&gt;front == Q-&gt;rear) return ERROR; *e = Q-&gt;base[Q-&gt;front]; return OK; } //销毁队列 int DestroyQueue(SqQueue* Q) { if (Q-&gt;base) { Q-&gt;rear = Q-&gt;front = 0; free(Q-&gt;base); } return OK; } //打印队列元素 void Print(SqQueue Q) { int len = QueueLength(Q); for (int i = 0; i &lt; len; i&#43;&#43;) { printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/c115ae284dd9b8579ca4078451889236/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-02T22:51:38+08:00" />
<meta property="article:modified_time" content="2023-06-02T22:51:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构 顺序队列的表示和实现 C语言版</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<pre><code class="language-cpp">#define _CRT_SECURE_NO_WARNINGS 1
#include&lt;stdio.h&gt;
#include&lt;malloc.h&gt;
#define ERROR 0
#define OK 1
#define MAXQSIZE 20     
typedef  int QElemType; /*队列元素类型，以整型为例实现*/


typedef struct
{
    QElemType* base;   //指向循环队列的存储空间
    int front;   //队头指针
    int rear;    //队尾指针
}SqQueue;


//初始化队列
int InitQueue(SqQueue* Q)
{
    Q-&gt;base = (QElemType*)malloc(MAXQSIZE * sizeof(QElemType));
    if (!Q-&gt;base) 
        return ERROR;     //申请存储空间失败
    Q-&gt;front = Q-&gt;rear = 0;     //设置队头队尾指针
    return OK;
}


//求队长
int QueueLength(SqQueue Q)
{
    return(Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;
}


//入队
int EnQueue(SqQueue* Q, QElemType e)
{
    if ((Q-&gt;rear + 1) % MAXQSIZE == Q-&gt;front)  //判断对是否已满
        return ERROR;
    Q-&gt;base[Q-&gt;rear] = e;     //元素e入队
    Q-&gt;rear = (Q-&gt;rear + 1) % MAXQSIZE;  //修改队尾指针
    return OK;
}


//出队
int DeQueue(SqQueue* Q, QElemType* e)
{
    if (Q-&gt;front == Q-&gt;rear) 
        return ERROR;   //判断队空
    *e = Q-&gt;base[Q-&gt;front];     //*e返回队头元素值
    Q-&gt;front = (Q-&gt;front + 1) % MAXQSIZE;   //修改队头指针
    return OK;
}


//判队空
int QueueEmpty(SqQueue* Q)
{
    if (Q-&gt;front == Q-&gt;rear)
        return OK;
    else 
        return ERROR;
}/*QueueEmpty*/


//取队头
int GetHead(SqQueue* Q, QElemType* e)
{
    if (Q-&gt;front == Q-&gt;rear)
        return ERROR;
    *e = Q-&gt;base[Q-&gt;front];
    return OK;
}


//销毁队列
int DestroyQueue(SqQueue* Q)
{
    if (Q-&gt;base)
    {
        Q-&gt;rear = Q-&gt;front = 0;
        free(Q-&gt;base);
    }
    return OK;
}


//打印队列元素
void Print(SqQueue Q)
{
    int len = QueueLength(Q);
    for (int i = 0; i &lt; len; i++)
    {
        printf("%d  ", Q.base[Q.front]);
        Q.front++;
    }
    printf("\n");
}


void menu()
{
    printf("-------------请选择-------------\n");
    printf("          1.初始化队列          \n");
    printf("          2.求队长              \n");
    printf("          3.入队                \n");
    printf("          4.出队                \n");
    printf("          5.取队头元素          \n");
    printf("          6.销毁队列            \n");
    printf("          0.退出操作            \n");
    printf("--------------------------------\n");
}


int main()
{
    SqQueue q;
    int e1,e2,e3,e4,e5;
    //使用队列基本操作完成程序功能
    do
    {
        menu();
        scanf("%d", &amp;e1);
        switch (e1)
        {
        case 1:
            InitQueue(&amp;q);
            printf("初始化成功\n");
            break;
        case 2:
            e2 = QueueLength(q);
            printf("队长为:%d\n", e2);
            break;
        case 3:
            printf("请输入入队元素：\n");
            scanf("%d", &amp;e3);
            EnQueue(&amp;q, e3);
            Print(q);
            break;
        case 4:
            DeQueue(&amp;q, &amp;e4);
            printf("出队元素为:%d\n", e4);
            printf("现队列为: ");
            Print(q);
            break;
        case 5:
            GetHead(&amp;q, &amp;e5);
            if (q.rear == q.front)
                printf("队头元素不存在\n");
            else
                printf("队头元素为: %d\n", e5);
            break;
        case 6:
            DestroyQueue(&amp;q);
            printf("队列已销毁\n");
            break;
        }
    } while (e1);
    return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/71245403612a3fcbd62f16223c77eb80/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Operating System Not Found解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/94f85fef33b9a4bc1100e565af17fe1c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于Spring框架中StringUtils常用/易误用方法解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>