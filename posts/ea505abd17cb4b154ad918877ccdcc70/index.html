<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】排序（1） - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【数据结构】排序（1）" />
<meta property="og:description" content="目录
一、概念：
二、直接插入排序：
三、希尔排序：
四、直接选择排序：
五、堆排序：
六、冒泡排序：
一、概念： 排序的概念：
使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。
排序又分为内部排序和外部排序：
内部排序：数据元素全部放在内存中的排序。
外部排序：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。
常见的排序算法：
二、直接插入排序： 基本思想：
把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列 。
例如在我们玩扑克牌斗地主时的码牌操作中就运用到了这个思想。
代码实现：
当插入第i(i&gt;=1)个元素时，前面的a[0],a[1],…,a[i-1]已经排好序，此时用a[i]的排序码与 a[i-1],a[i-2],…的排序码顺序进行比较，找到插入位置即将a[i]插入，原来位置上的元素顺序后移即可。
//时间复杂度: O(N^2)	逆序 //最好的情况: O(N)	顺序有序 void InsertSort(int* a, int n) { for (int i = 0; i &lt; n - 1; i&#43;&#43;)// i小于n-1是为下面条件做铺垫，防止越界 { // 设置end为下标，将其与tmp下标位置的数进行比较，并不断更新end int end = i; int tmp = a[end &#43; 1];// 在单趟排序中，tmp固定 // 设置数组最小数的条件 while (end &gt;= 0) { // 对tmp和end位置数进行比较 if (tmp &lt; a[end]) { // 将end位置数复制在end&#43;1处，本质上是更新去排序后对应的位置 a[end &#43; 1] = a[end]; end--;// 更新end } else { break; } } // 将tmp数放入对应的位置 a[end &#43; 1] = tmp; } } 直接插入排序的特性总结：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/ea505abd17cb4b154ad918877ccdcc70/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-23T17:17:16+08:00" />
<meta property="article:modified_time" content="2024-02-23T17:17:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】排序（1）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E6%A6%82%E5%BF%B5%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%A6%82%E5%BF%B5%EF%BC%9A" rel="nofollow">一、概念：</a></p> 
<p id="%E4%BA%8C%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%9A" rel="nofollow">二、直接插入排序：</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%9A" rel="nofollow">三、希尔排序：</a></p> 
<p id="%E5%9B%9B%E3%80%81%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%9A" rel="nofollow">四、直接选择排序：</a></p> 
<p id="%E4%BA%94%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%9A" rel="nofollow">五、堆排序：</a></p> 
<p id="%E5%85%AD%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%9A" rel="nofollow">六、冒泡排序：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2><span style="color:#ff9900;">一、概念：</span></h2> 
<p><span style="color:#956fe7;"><strong>排序的概念：</strong></span></p> 
<p><strong>        </strong>使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。</p> 
<p><span style="color:#956fe7;"><strong>排序又分为内部排序和外部排序：</strong></span></p> 
<p><strong>内部排序：</strong>数据元素全部放在内存中的排序。</p> 
<p><strong>外部排序：</strong>数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。</p> 
<p><span style="color:#fe2c24;"><strong>常见的排序算法：</strong></span></p> 
<p><img alt="" height="364" src="https://images2.imgbox.com/ff/dd/GMnKRsMt_o.png" width="545"></p> 
<h2 id="%E4%BA%8C%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%9A"><span style="color:#ff9900;">二、直接插入排序：</span></h2> 
<p><span style="color:#956fe7;"><strong>基本思想</strong></span>：</p> 
<p>把<span style="color:#fe2c24;">待排序的记录</span>按其关键码值的大小<span style="color:#fe2c24;">逐个插入到一个已经排好序的有序序列中</span>，直到所有的记录插入完为止，得到一个新的有序序列 。</p> 
<p><strong>例如在我们玩扑克牌斗地主时的码牌操作中就运用到了这个思想。</strong></p> 
<p><img alt="" height="217" src="https://images2.imgbox.com/ba/62/p9mqVYgk_o.png" width="340"></p> 
<p><span style="color:#956fe7;"><strong>代码实现：</strong></span></p> 
<p><strong>当插入第i(i&gt;=1)个元素时，前面的a[0],a[1],…,a[i-1]已经排好序，此时用a[i]的排序码与 a[i-1],a[i-2],…的排序码顺序进行比较，找到插入位置即将a[i]插入，原来位置上的元素顺序后移即可。</strong></p> 
<pre><code class="language-cpp">//时间复杂度: O(N^2)	逆序
//最好的情况: O(N)	顺序有序
void InsertSort(int* a, int n)
{
	for (int i = 0; i &lt; n - 1; i++)// i小于n-1是为下面条件做铺垫，防止越界
	{
		// 设置end为下标，将其与tmp下标位置的数进行比较，并不断更新end
		int end = i;
		int tmp = a[end + 1];// 在单趟排序中，tmp固定

		// 设置数组最小数的条件
		while (end &gt;= 0)
		{
			// 对tmp和end位置数进行比较
			if (tmp &lt; a[end]) 
			{
				// 将end位置数复制在end+1处，本质上是更新去排序后对应的位置
				a[end + 1] = a[end];
				end--;// 更新end
			}
			else
			{
				break;
			}
		}
		// 将tmp数放入对应的位置
		a[end + 1] = tmp;
	}
}</code></pre> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>直接插入排序的特性总结：</strong></span></p> 
 <ol><li>元素集合越接近有序，直接插入排序算法的时间效率越高</li><li>时间复杂度：O(N^2)</li><li>空间复杂度：O(1)，它是一种稳定的排序算法 </li><li>稳定性：稳定</li></ol> 
</blockquote> 
<p></p> 
<h2 id="%E4%B8%89%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%9A"><span style="color:#ff9900;">三、希尔排序：</span></h2> 
<p><span style="color:#38d8f0;"><strong>又称缩小增量排序 </strong></span></p> 
<p><span style="color:#956fe7;"><strong>基本思想：</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>先选定一个整数gap，把待排序文件中所有记录分成gap个组，所有距离为gap的记录分在同一组内，并对每一组内的元素进行排序。</strong></span></p> 
<p><span style="color:#38d8f0;"><strong>gap越大，大的值更快调到后面，小的值可以更快的调到前面，越不接近有序。</strong></span></p> 
<p><span style="color:#38d8f0;"><strong>gap越小，跳的越慢，但是越接近有序，如果gap == 1，就是直接插入排序。</strong></span></p> 
<p><img alt="" height="403" src="https://images2.imgbox.com/c3/78/go9IzxDn_o.png" width="484"></p> 
<p><span style="color:#956fe7;"><strong>代码实现：</strong></span></p> 
<pre><code class="language-cpp">void ShellSort(int* a, int Size)
{
	int gap = Size;
	// gap &gt; 1时是预排序，目的让他接近有序
	// gap == 1是直接插入排序，目的是让他有序
	while (gap &gt; 1)
	{
		gap = gap / 3 + 1;//保证最后一次gap是1，就是直接插入排序，但是数列已经非常接近有序了
						 //gap代表的是有多少组

		// 这里就跟直接插入排序的模板一样
		for (int i = 0; i &lt; Size - gap; i++)
		{
			int end = i;
			int tmp = a[end + gap];
			while (end &gt;= 0)
			{
				if (tmp &lt; a[end])
				{
					a[end + gap] = a[end];
					end -= gap;
				}
				else
				{
					break;
				}
			}
			a[end + gap] = tmp;
		}
	}
}</code></pre> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>希尔排序的特性总结：</strong></span></p> 
 <p></p> 
 <ol><li> <p>希尔排序是对直接插入排序的优化。</p> </li><li> <p>当gap &gt; 1时都是预排序，目的是让数组更接近于有序。当gap == 1时，就是直接插入排序。</p> </li><li> <p>希尔排序的时间复杂度不好计算，因为gap的取值方法很多。</p> </li><li> <p>时间复杂度(平均)：O(N^1.3)</p> </li><li> <p>空间复杂度：O(1)</p> </li><li> <p>稳定性：不稳定。</p> </li></ol> 
</blockquote> 
<h2 id="%E5%9B%9B%E3%80%81%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%9A"><span style="color:#ff9900;">四、直接选择排序：</span></h2> 
<p><span style="color:#956fe7;"><strong>基本思想：</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>每一次从待排序的数据元素中选出最小/最大的一个元素，存放在序列的起始/末尾位置，直到全部待排序的数据元素排完 。</strong></span></p> 
<p><span style="color:#956fe7;"><strong>代码实现：</strong></span></p> 
<ul><li>在元素集合a[i]--a[n-1]中选择关键码最大(小)的数据元素</li><li>若它不是这组元素中的最后一个(第一个)元素，则将它与这组元素中的最后一个（第一个）元素交换</li><li>在剩余的a[i]--a[n-2]（a[i+1]--a[n-1]）集合中，重复上述步骤，直到集合剩余1个元素</li></ul> 
<pre><code class="language-cpp">// 时间复杂度: O(N^2)
// 最好的情况: O(N^2) 即使原本就有序，还是要暴力取数
// 空间复杂度: O(1)
void SelectSort(int* a, int Size)// 升序
{
	//设置下标
	int begin = 0;
	while (begin &lt; Size)
	{
		int min = begin;
		// 暴力选数
		for (int i = begin + 1; i &lt; Size; i++)
		{
			if (a[i] &lt; a[min])
			{
				min = i;
			}
		}

		swap(a[begin], a[min]); //这里的swap使用的是库函数中写好了的，
								// 使用自己写的注意形参与实参
		begin++;
	}
}</code></pre> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>直接选择排序的特性总结：</strong></span></p> 
 <ol><li>直接选择排序思考非常好理解，但是效率不是很好。实际中很少使用</li><li>时间复杂度：O(N^2)</li><li>空间复杂度：O(1)</li><li>稳定性：不稳定</li></ol> 
</blockquote> 
<h2 id="%E4%BA%94%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%9A"><span style="color:#ff9900;">五、堆排序：</span></h2> 
<p><span style="color:#956fe7;"><strong>基本思想：</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>利用堆删除思想来进行排序使用向下调整。需要注意的是排升序要建大堆，排降序建小堆。</strong></span></p> 
<p><span style="color:#956fe7;"><strong>代码实现：</strong></span></p> 
<pre><code class="language-cpp">// 向下调整:升序建大堆
void AdjustDown(int* a, int size, int parent)
{
	int child = parent * 2 + 1;

	// 一层层的往下判别
	while (child &lt; size)
	{
		// 在保证不越界的前提下找出数大的子节点
		if (child + 1 &lt; size &amp;&amp; a[child + 1] &gt; a[child])
		{
			child++;
		}

		if (a[child] &gt; a[parent])
		{
			swap(a[child], a[parent]);// 这里的swap使用的是库函数中写好了的，
                                      // 使用自己写的注意形参与实参
			// 更新父，子节点
			parent = child;
			child = child * 2 + 1;
		}
		else
		{
			break;
		}
	}
}

// 升序
void HeapSort(int* a, int Size)
{
	// O(N)
	// 要排升序，所以建大堆-&gt;找最后一个分叶节点向下调整，然后向前依次操作
	for (int i = (Size - 1 - 1) / 2; i &gt;= 0; i--)
	// Size是个数，要下标所以-1，结合找最后一个分叶结点公式化简
	{
		AdjustDown(a, Size, i);
	}

	// O(N*logN)

	int end = Size - 1;
	while (end &gt; 0)
	{

		swap(a[0], a[end]);

		// 在向下调整使用end时，取的值是小于end，默认忽略最后一位,由前Size-1个数进行向下调整
		AdjustDown(a, end, 0);
		end--;
	}
}</code></pre> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>堆排序的特性总结：</strong></span></p> 
 <ol><li> <p>堆排序使用堆来选数，效率就高了很多。</p> </li><li> <p>时间复杂度：O(N*logN)</p> </li><li> <p>空间复杂度：O(1)</p> </li><li> <p>稳定性：不稳定</p> </li></ol> 
</blockquote> 
<h2 id="%E5%85%AD%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%9A"><span style="color:#ff9900;">六、冒泡排序：</span></h2> 
<p><span style="color:#956fe7;"><strong>基本思想：</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>       </strong></span><span style="color:#fe2c24;"><strong>两两元素相比，前一个比后一个大就交换，直到将最大/最小（升序/降序）的元素交换到末尾位置。这为一趟；</strong></span><span style="color:#fe2c24;"><strong>一共进行 n-1 趟这样的交换将可以把所有的元素排序好。</strong></span></p> 
<p><span style="color:#956fe7;"><strong>代码实现：</strong></span></p> 
<pre><code class="language-cpp">//时间复杂度: O(N^2)	乱序
//最好的情况: O(N)   有序
void BubbleSort(int* a, int Size)
{
	// n个数只需排 n - 1 躺即可
	for (int i = 0; i &lt; Size - 1; i++)
	{
		// 设置一个条件，判断一趟排序下来是否有位置交换
		bool exchange = false;
		for (int j = 1; j &lt; Size - i; j++)
		{
			if (a[j - 1] &gt; a[j])
			{
				swap(a[j - 1], a[j]); // 这里的swap使用的是库函数中写好了的，
                                      // 使用自己写的注意形参与实参
				exchange = true;
			}
		}

		// 如果单趟下来并没有数交换位置则说明这个数列本就有序
		if (exchange = false)
		{
			break;
		}
	}
}</code></pre> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>冒泡排序的特性总结：</strong></span></p> 
 <ol><li>冒泡排序是一种非常容易理解的排序</li><li>时间复杂度：O(N^2)</li><li>空间复杂度：O(1)</li><li>稳定性：稳定 </li></ol> 
</blockquote> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dd93f13d1671794527ce16d8a4912cfb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【VRTK】【Unity】【VR开发】使用注意事项-Simulator没反应</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/38d814c00bce6d1cd2e8ae98557fccec/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">K8S-001-Virtual box - Network Config</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>