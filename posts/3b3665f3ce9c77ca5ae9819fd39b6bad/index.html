<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>高级Bash脚本编程指南 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="高级Bash脚本编程指南" />
<meta property="og:description" content="目录 第一部分. 热身 为什么使用shell编程 带着一个Sha-Bang出发(Sha-Bang指的是#!) 调用一个脚本 初步的练习 第二部分. 基本 特殊字符 变量和参数的介绍 变量替换 变量赋值 Bash变量是不分类型的 特殊的变量类型 引用(翻译的可能有问题,特指引号) 引用变量 转义(\) 退出和退出状态 Tests Test结构 文件测试操作 其他比较操作 嵌套的if/then条件test 检查你的test知识 操作符和相关的主题 操作符 数字常量 第三部分. 超越基本 变量重游 内部变量 操作字符串 参数替换 指定类型的变量:declare或者typeset 变量的间接引用 RANDOM: 产生随机整数 双圆括号结构 循环和分支 循环 嵌套循环 循环控制 测试与分支(case和select结构) 内部命令与内建 作业控制命令 外部过滤器,程序和命令 基本命令 复杂命令 时间/日期 命令 文本处理命令 文件与归档命令 通讯命令 终端控制命令 数学计算命令 混杂命令 系统与管理命令 分析一个系统脚本 命令替换 算术扩展 I/O 重定向 使用exec 代码块的重定向 应用 Here Documents Here Strings 休息时间 第四部份." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/3b3665f3ce9c77ca5ae9819fd39b6bad/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2008-07-24T21:53:00+08:00" />
<meta property="article:modified_time" content="2008-07-24T21:53:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">高级Bash脚本编程指南</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <a name=".E7.9B.AE.E5.BD.95"></a> 
<h3><span class="editsection"></span> <span class="mw-headline">目录</span></h3> 
<a name=".E7.AC.AC.E4.B8.80.E9.83.A8.E5.88.86._.E7.83.AD.E8.BA.AB"></a> 
<h4><span class="editsection"></span> <span class="mw-headline"><a href="http://wiki.ubuntu.org.cn/index.php?title=%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86._%E7%83%AD%E8%BA%AB&amp;amp;action=edit" rel="nofollow" title="第一部分. 热身" class="new">第一部分. 热身</a></span></h4> 
<ol><li>为什么使用shell编程 </li><li>带着一个Sha-Bang出发(Sha-Bang指的是#!) 
  <ol><li>调用一个脚本 </li><li>初步的练习 </li></ol></li></ol> 
<a name=".E7.AC.AC.E4.BA.8C.E9.83.A8.E5.88.86._.E5.9F.BA.E6.9C.AC"></a> 
<h4><span class="editsection"></span> <span class="mw-headline"><a href="http://wiki.ubuntu.org.cn/index.php?title=%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86._%E5%9F%BA%E6%9C%AC&amp;amp;action=edit" rel="nofollow" title="第二部分. 基本" class="new">第二部分. 基本</a></span></h4> 
<ol><li>特殊字符 </li><li>变量和参数的介绍 
  <ol><li>变量替换 </li><li>变量赋值 </li><li>Bash变量是不分类型的 </li><li>特殊的变量类型 </li></ol></li><li>引用(翻译的可能有问题,特指引号) 
  <ol><li>引用变量 </li><li>转义(\) </li></ol></li><li>退出和退出状态 </li><li>Tests 
  <ol><li>Test结构 </li><li>文件测试操作 </li><li>其他比较操作 </li><li>嵌套的if/then条件test </li><li>检查你的test知识 </li></ol></li><li>操作符和相关的主题 
  <ol><li>操作符 </li><li>数字常量 </li></ol></li></ol> 
<a name=".E7.AC.AC.E4.B8.89.E9.83.A8.E5.88.86._.E8.B6.85.E8.B6.8A.E5.9F.BA.E6.9C.AC"></a> 
<h4><span class="editsection"></span><span class="mw-headline"><a href="http://wiki.ubuntu.org.cn/index.php?title=%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86._%E8%B6%85%E8%B6%8A%E5%9F%BA%E6%9C%AC&amp;amp;action=edit" rel="nofollow" title="第三部分. 超越基本" class="new">第三部分. 超越基本</a></span></h4> 
<ol><li>变量重游 
  <ol><li>内部变量 </li><li>操作字符串 </li><li>参数替换 </li><li>指定类型的变量:declare或者typeset </li><li>变量的间接引用 </li><li>RANDOM: 产生随机整数 </li><li>双圆括号结构 </li></ol></li><li>循环和分支 
  <ol><li>循环 </li><li>嵌套循环 </li><li>循环控制 </li><li>测试与分支(case和select结构) </li></ol></li><li>内部命令与内建 
  <ol><li>作业控制命令 </li></ol></li><li>外部过滤器,程序和命令 
  <ol><li>基本命令 </li><li>复杂命令 </li><li>时间/日期 命令 </li><li>文本处理命令 </li><li>文件与归档命令 </li><li>通讯命令 </li><li>终端控制命令 </li><li>数学计算命令 </li><li>混杂命令 </li></ol></li><li>系统与管理命令 
  <ol><li>分析一个系统脚本 </li></ol></li><li>命令替换 </li><li>算术扩展 </li><li>I/O 重定向 
  <ol><li>使用exec </li><li>代码块的重定向 </li><li>应用 </li></ol></li><li>Here Documents 
  <ol><li>Here Strings </li></ol></li><li>休息时间 </li></ol> 
<a name=".E7.AC.AC.E5.9B.9B.E9.83.A8.E4.BB.BD._.E9.AB.98.E7.BA.A7"></a> 
<h4><span class="editsection"></span> <span class="mw-headline"><a href="http://wiki.ubuntu.org.cn/index.php?title=%E7%AC%AC%E5%9B%9B%E9%83%A8%E4%BB%BD._%E9%AB%98%E7%BA%A7&amp;amp;action=edit" rel="nofollow" title="第四部份. 高级" class="new">第四部份. 高级</a></span></h4> 
<ol><li>正则表达式 
  <ol><li>一个简要的正则表达式介绍 </li><li>通配 </li></ol></li><li>子shell(Subshells) </li><li>受限shell(Restricted Shells) </li><li>进程替换 </li><li>函数 
  <ol><li>复杂函数和函数复杂性 </li><li>局部变量 </li><li>不使用局部变量的递归 </li></ol></li><li>别名(Aliases) </li><li>列表结构 </li><li>数组 </li><li>/dev 和 /proc 
  <ol><li>/dev </li><li>/proc </li></ol></li><li>关于Zeros和Nulls </li><li>调试 </li><li>选项 </li><li>Gotchas </li><li>脚本编程风格 
  <ol><li>非官方的Shell脚本风格 </li></ol></li><li>杂项 
  <ol><li>交互式和非交互式的shells和脚本 </li><li>Shell 包装 </li><li>测试和比较: 另一种方法 </li><li>递归 </li><li>彩色脚本 </li><li>优化 </li><li>各种小技巧 </li><li>安全话题 
    <ol><li>被感染的脚本 </li><li>隐藏Shell脚本源码 </li></ol></li><li>移植话题 </li><li>在Windows下进行Shell编程 </li></ol></li><li> Bash, 版本 2 和 3 
  <ol><li>Bash, 版本2 </li><li>Bash, 版本3 </li></ol></li></ol> 
<a name="35._.E5.90.8E.E8.AE.B0"></a> 
<h4><span class="editsection"></span> <span class="mw-headline"><a href="http://wiki.ubuntu.org.cn/index.php?title=35._%E5%90%8E%E8%AE%B0&amp;amp;action=edit" rel="nofollow" title="35. 后记" class="new">35. 后记</a></span></h4> 
<ol><li>作者后记 </li><li>关于作者 </li><li>哪里可以取得帮助? </li><li>制作这本书的工具 
  <ol><li>硬件 </li><li> 软件和排版软件 </li></ol></li><li>Credits </li></ol> 
<font class="f14" id="zoom">Bash 编程 <br>一． Bash特殊字符 <br>1． 通配符： <br> *：匹配任何字符串 <br> ?：匹配任何单个字符 <br> 集合运算符：用一些单个字、一个连续范围或断续的字符集合作为通配符 <br> [set]：用字符集合作通配符匹配单个字符，如：[aeiou]，[a-o]，[a-h, w-z] <br> [!set]：除了集合外的所有字符组成的集合作通配符 <br>2． 花括号展开式（可以嵌套）： <br> 格式：[前导字符串]{字符串1[{嵌套字符串1…}] [, 字符传2…]}[后继字符串] <br> 如：c{a{r, t, n}, b{r, t, n}}s 就等于 cars cats cans cbrs cbts cbns <br>3． 其它特殊字符： <br> &lt; ：输入重定向 <br> &gt;; ：输出重定向(没有文件则创建，有则覆盖) <br> &gt;;&gt;; ：输出重定向(没有则创建，有则追加到文件尾部) <br> ( ：子shell开始，子shell继承父shell部分环境变量 <br> ) ：子shell结束 <br> { ：命令块开始，由当前shell执行，保留所有环境变量 <br> } ：命令块结束 <br> | ：管道 <br> \ ：引用后面的单个字符 <br> ‘ ：强引用字符串，不解释特殊字符 <br> “ ：弱引用字符串，解释所有特殊字符 <br> ~ ：根目录 <br> ` ：命令替换 <br> ; ：命令分隔符（命令终止符），运行在一行里执行多条命令 <br> # ：行注释 <br> $ ：变量表达式 <br> &amp; ：在后台执行命令 <br> * ：字符串通配符 <br> ? ：单个字符通配符 <br>二． Bash变量 <br>1． 自定义变量 <br> 用户自定义的变量由字母、数字和下划线组成，并且变量名的第一个字符不能为数字，且变量名大小写敏感。 <br> varname=value 注意bash不能在等号两侧留空格 <br> shell语言是非类型的解释型语言，给一个变量赋值实际上就是定义了变量，而且可以赋不同类型的值。引用变量有两种方式，$varname和${varname}，为防止变量在字符串中产生歧义建议使用第二种方式，引用未定义的变量其值为空。 <br> 为一个变量赋值一个串，需要用到引号，注意`、’、”的不同，``相当于$() <br> 为了使变量可以在其它进程中使用，需要将变量导出：export varname <br>2． 环境变量 <br> 可以用set命令给变量赋值或查看环境变量值，使用unset命令清除变量值，使用export导出变量将可以使其它进程访问到该环境变量。 <br>3． 位置变量 <br> 位置变量对应于命令行参数，其中$0为脚本名称，$1为第一个参数，依次类推，参数超过9个必须使用${}引用变量。shell保留这些变量，不允许用户 以另外的方式定义它们，传给脚本或函数的位置变量是局部和只读的，而其余变量为全局的（可以用local关键字声明为局部）。 <br>4． 其它变量 <br> $? ：保存前一个命令的返回码 <br> $- ：在Shell启动或使用set命令时提供选项 <br> $$ ：当前shell的进程号 <br> $! ：上一个子进程的进程号 <br> $# ：传给脚本或函数的参数个数，即位置变量数减1，不含脚本名称。 <br> $* ：传给脚本或函数的参数组成的单个字符串，即除脚本名称后从第一个参数开始的字符串，每个参数以$IFS分隔（一般内部域分隔符$IFS为1空格）。形同”…” <br> $@ ：传给脚本或函数的参数列表，这些参数被表示为多个字符串。形同”” “” “”…。$*和$@之间的不同方便使用两种方法处理命令行参数，但是在打印时参数外观没有区别。 <br> 如： #vi posparm.sh <br> function cutparm <br> {echo –e “inside cntparm: $# parms: $*\n”} <br> cntparm “$*” <br> cntparm “$@” <br> #./posparm.sh abc bca cab <br> inside cntparm: 1 parms: abc bca cab <br> inside cntparm: 3 parms: abc bca cab <br>三． Bash操作符 <br>1． 字符串操作符（替换操作符） <br> ${var:-word} 如果var存在且不为空，返回它的值，否则返回word <br> ${var:=word} 如果var存在且不为空，返回它的值，否则将word赋给var， 返回它的值 <br> ${var:+word} 如果var存在且不为空，返回word，否则返回空 <br> ${var:?message} 如果var存在且不为空，返回它的值， <br> 否则显示“bash2:$var:$message”，然后退出当前命令或脚本 <br> ${var:offset[]} 从offset位置开始返回var的一个长为length的子串， <br> 若没有length，则默认到var串末尾 <br>2． 模式匹配操作符 <br> ${var#pattern} 从var头部开始，删除和pattern匹配的最短模式串，然后返回 剩余串 <br> ${var##pattern} 从var头部开始，删除和pattern匹配的最长模式串，然后返回 剩余串，basename path＝${path##*/} <br> ${var%pattern} 从var尾部开始，删除和pattern匹配的最短模式串，然后返回 剩余串，dirname path＝${path%/*} <br> ${var%%pattern} 从var尾部开始，删除和pattern匹配的最长模式串，然后返回 剩余串 <br> ${var/pattern/string} 用string替换var中和pattern匹配的最长模式串 <br>四． Shell中条件和test命令 <br> Bash可以使用[ … ]结构或test命令测试复杂条件 <br> 格式：[ expression ] 或 test expression <br> 返回一个代码，表明条件为真还是为假，返回0为真，否则为假。 <br> 注：左括号后和右括号前空格是必须的语法要求 <br>1． 文件测试操作符 <br> -d file file存在并且是一个目录 <br> -e file file存在 <br> -f file file存在并且是一个普通文件 <br> -g file file存在并且是SGID(设置组ID)文件 <br> -r file 对file有读权限 <br> -s file file存在并且不为空 <br> -u file file存在并且是SUID(设置用户ID)文件 <br> -w file 对file有写权限 <br> -x file 对file有执行权限，如果是目录则有查找权限 <br> -O file 拥有file <br> -G file 测试是否是file所属组的一个成员 <br> -L file file为符号链接 <br> file1 –nt file2 file1比file2新 <br> file1 –ot file2 file1比file2旧 <br>2． 字符串操作符 <br> str1=str2 str1和str2匹配 <br> str1!=str2 str1和str2不匹配 <br> str1&lt;str2 str1小于str2 <br> str1&gt;;str2 str1大于str2 <br> -n str str的长度大于0（不为空） <br> -z str str的长度为0（空串） <br>3． 整数操作符 <br> var1 –eq var2 var1等于var2 <br> var1 –ne var2 var1不等于var2 <br> var1 –ge var2 var1大于等于var2 <br> var1 –gt var2 var1大于var2 <br> var1 –le var2 var1小于等于var2 <br> var1 –lt var2 var1小于var2 <br>4． 逻辑操作符 <br> !expr 对expr求反 <br> expr1 &amp;&amp; expr2 对expr1与expr2求逻辑与，当expr1为假时不再执行expr2 <br> expr1 || expr2 对expr1与expr2求逻辑或，当expr1为真时不再执行expr2 <br> 注：另一种逻辑操作符 逻辑与expr1 –a expr2 逻辑或expr1 –o expr2 <br>五． Shell流控制 <br>1． 条件语句：if <br> if 条件 IFS=: <br> then for dir in $PATH <br> 语句 do <br> [elif 条件 if [ -O dir ]; then <br> 语句] echo –e “\tYou own $dir” <br> [else else <br> 语句] echo –e “\tYou don’t own $dir” <br> fi fi <br>2． 确定性循环：for done <br> for value in list for docfile in /etc/* /usr/etc/* <br> do do <br> statements using $value cp $docfile ${docfile%.doc}.txt <br> done done <br> 注：for var;… 相当于for var in “$@”;… <br>3． 不确定性循环：while和until <br> while 条件 until 条件 <br> do do <br> 语句 语句 <br> done done <br><br> count＝1 count＝1 <br> while [ -n “$*” ] until [ -z “$*” ] <br> do do <br> echo "parameter $count" echo "parameter $count" <br> shift shift <br> count='expr $count + 1' count='expr $count + 1' <br> done done <br> 条件为真执行循环体 条件为假执行循环体 <br> 注：整数变量的定义与算法 <br> declare –i idx 定义整数变量 使用$(())无需定义 <br> idx=1 <br> while [ $idx!=150 ] <br> do <br> cp somefile somefile.$idx <br> idx=$idx+1 整数算法 idx=$(( $idx+1 )) <br> done <br> 另一种算法 echo $(( 100/3 )) 将加减乘除表达式放入$(())中 <br>4． 选择结构：case和select <br> case 表达式 in 表达式和模式依次比较，执行第一个匹配的模式 <br> 模式1) ;;使程序控制流跳到esac后执行，相当于break <br> 语句;; 允许表达式和含有通配符的模式进行匹配 <br> 模式2) <br> 语句;; <br> …… <br> [*) <br> 语句] <br> esac <br><br> select value [ in list ] 按list列表自动生成菜单 <br> do 若没有list则默认为位置变量 <br> statements using $value <br> done <br> 如：IFS=: 设置域分隔符为:号 <br> PS3=”choice&gt;;” 改变select默认提示符 <br> clear <br> select dir in $PATH <br> do <br> if [ $dir ]; then <br> cnt=$(ls –Al $dir | wc -l) <br> echo “$cnt files in $dir” <br> else <br> echo “No such choice !” <br> fi <br> echo –e “\npress ENTER to continue, CTRL-C to quit” <br> read 使程序按回车继续，ctrl＋c退出 <br> clear <br> done <br>5． 命令shift <br> 将存放在位置变量中的命令行参数依次向左传递 <br> shift n 命令行参数向左传递n个串 <br>六． Shell函数 <br> 定义： function fname fname () <br> { { <br> commands commands <br> } } <br> 调用：fname [ parm1 parm2 parm3 ... ] <br> 说明： 函数在使用前定义，两种定义功能相同 <br> 函数名和调用函数参数成为函数的位置变量 <br> 函数中的变量应该使用local声明为局部变量 <br>七． 输入输出 <br>限于篇幅，这里不讨论所有输入输出操作符和功能 <br>1．I/O重定向 <br> &lt; ：输入重定向 <br> &gt;; ：输出重定向(没有文件则创建，有则覆盖) <br> &gt;;&gt;; ：输出重定向(没有则创建，有则追加到文件尾部) <br>&lt;&lt; ：输入重定向(here文档) <br> 格式： command &lt;&lt; label <br> input… <br> label <br> 说明： 使一个命令的输入为一段shell脚本(input…)，直到标号(label)结束 <br>如： cat &lt; $HOME/.profile &gt;; out <br> echo “add to file end !” &gt;;&gt;; $HOME/.profile <br> ftp：USER=anonymous <br> PASS=YC@163.com <br> ftp –i –n &lt;&lt; END -i：非交互模式 -n：关闭自动登录 <br> open ftp.163.com <br> user $USER $PASS <br> cd /pub <br> close <br> END END标记输入结束 <br>2．字符串I/O操作 <br> 字符串输出：echo <br> 命令选项： -e：启动转义序列 -n：取消输出后换行 <br> 转义序列： \a：Alt/Ctrl+G(bell) \b：退格Backspace/Ctrl+H <br>\c：取消输出后换行 \f：Formfeed/Ctrl+J <br>\r：Return/Ctrl+M \v：Vertical tab <br>\n：八进制ASCII字符 \\：单个\字符 \t：Tab制表符 <br> 字符串输入：read <br> 可以用于用户交互输入，也可以用来一次处理文本文件中的一行 <br> 命令选项： -a：将值读入数组，数组下标从0开始 <br> -e：使用GNU的readline库进行读入，允许bash的编辑功能 <br> -p：在执行读入前打印提示 <br> 如： IFS=: <br> read –p “start read from file . filename is : \c” filename <br> while read name pass uid gid gecos home shell &lt; filename <br> do <br> echo –e “name : $name\npass : $pass\n” <br> done <br> 说明：如果行的域数大于变量表的变量数，则后面的域全部追加给最后的变量 <br>八． 命令行处理 <br>命令行处理命令：getopts <br> 有两个参数，第一个为字母和冒号组成的选项列表字符串，第二个为一个变量名 <br> 选项列表字符串以冒号开头的选项字母排列组成，如果一选项需要一个参数则该选项字母后跟一个冒号 <br> getopts分解第一参数，依次将选项摘取出来赋给第二个参数变量 <br> 如果某选项有参数，则读取参数到内置变量OPTARG中 <br> 内置变量OPTIND保存着将被处理的命令行参数（位置参数）的数值 <br> 选项列表处理完毕getopts返回1，否则返回0 <br> 如： while getopts “:xy:z:” opt <br> do <br> case $opt in <br> x) xopt=’-x set’ ;; <br> y) yopt=”-y set and called with $OPTARG” ;; <br> z) zopt=”-z set and called with $OPTARG” ;; <br> \?) echo ‘USAGE: getopts.sh [-x] [-y arg] [-z arg] file…’ <br> exit 1 <br> esac <br> done <br> shift ($OPTING-1) 将处理过的命令行参数移去 <br> echo ${xopt: -‘did not use –x‘} <br> echo ${yopt: -‘did not use –y‘} <br> echo ${zopt: -‘did not use –z‘} <br><br> echo “Remaining command-line arguments are :” <br> for f in “$@” <br> do <br> echo –e “\t$f\n” <br> done <br>九． 进程和作业控制 <br>信号处理命令：trap <br> 格式：trap command sig1 sig2 … <br> trap可以识别30多种信号，如中断(Ctrl+c)、挂起(Ctrl+z)等，可以使用kill -l查看信号清单 <br> 当脚本接受到信号sig1、sig2等，trap就执行命令command，command完成后脚本重新执行 <br> 信号可以通过名称或数字来标识 <br>作业控制命令：bg、fg <br> bg：显示后台进程，即用Ctrl+z挂起或‘命令 &amp;’执行的进程 <br> fg：将后台进程转到前台执行 <br> kill –9 %n：杀掉第n个后台进程 <br>附录： <br>一． Bash支持的命令行参数 <br>-a 将所有变量输出  <br>　　-c "string"从string中读取命令  <br>　　-e 使用非交互式模式  <br>　　-f 禁止shell文件名产生  <br>　　-h 定义  <br>　　-i 交互式模式  <br>　　-k 为命令的执行设置选项  <br>　　-n 读取命令但不执行  <br>　　-r 受限模式  <br>　　-s 命令从标准输入读取  <br>　　-t 执行一命令，然后退出shell  <br>　　-u 在替换时，使用未设置的变量将会出错  <br>　　-v 显示shell的输入行  <br>　　-x 跟踪模式，显示执行的命令 <br>许多模式可以组合起来用,使用set可以设置或取消shell的选项来改变shell环境。打开选项用"-",关闭选项用"+",若显示Shell中已经设置的选项，执行: $echo $- <br>二． .profile中shell的环境变量意思如下:  <br>CDPATH 执行cd命令时使用的搜索路径  <br>HOME 用户的home目录  <br>IFS 内部的域分割符，一般为空格符、制表符、或换行符  <br>MAIL 指定特定文件(信箱)的路径，有UNIX邮件系统使用  <br>PATH 寻找命令的搜索路径(同dos的config.sys的 path)  <br>PS1 主命令提示符，默认是"$"  <br>PS2 从命令提示符，默认是"&gt;;"  <br>TERM 使用终端类型</font>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/31a7b78eeec2920b40d4946040f86f14/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">TCP三次握手</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e9bacf357a114e1264acf1e0a44b8c81/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SQL UNIQUE 约束介绍</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>