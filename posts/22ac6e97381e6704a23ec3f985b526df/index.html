<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Go语言的映射reflect使用大全 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Go语言的映射reflect使用大全" />
<meta property="og:description" content="目录
前言
一、映射的基本用法
1.获取类型信息
2.获取值
3.读取和设置值
4.使用Kind来区分类型
5.操作结构体
6.创建新实例
7.调用方法
8.调用方法
二、使用实例
总结
前言 Go语言作为一个高性能的静态语言，我们在写函数的时候，由于go语言的特性，我们需要定义变量类型，大多情况下，变量类型是固定结构体，这就会导致我们想做一个适配性较高的函数的时候，则需要将变量以及返回值用interface{}接口实现
一、映射的基本用法 1.获取类型信息 使用`reflect.TypeOf()`可以获取任何值的类型信息
var x float64 = 3.4 fmt.Println(&#34;type:&#34;, reflect.TypeOf(x)) 2.获取值 使用`reflect.ValueOf()`可以获取reflect.Value类型表示的实际值：
var x float64 = 3.4 v := reflect.ValueOf(x) fmt.Println(&#34;value:&#34;, v) fmt.Println(&#34;type:&#34;, v.Type()) fmt.Println(&#34;kind:&#34;, v.Kind()) 3.读取和设置值 通过reflect可以对变量的值进行读取和设置：
var x float64 = 3.4 p := reflect.ValueOf(&amp;x) // 注意这里必须要传递x的地址 v := p.Elem() v.SetFloat(7.1) 4.使用Kind来区分类型 `reflect.Kind`可以用来区分基本类型：
v := reflect.ValueOf(x) if v.Kind() == reflect.Float64 { // x是float64类型 } 5." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/22ac6e97381e6704a23ec3f985b526df/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-19T10:53:13+08:00" />
<meta property="article:modified_time" content="2024-01-19T10:53:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Go语言的映射reflect使用大全</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p id="main-toc"><strong>目录</strong></p> 
 <p id="-toc" style="margin-left:0px;"></p> 
 <p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
 <p id="%E4%B8%80%E3%80%81%E6%98%A0%E5%B0%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%98%A0%E5%B0%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95" rel="nofollow">一、映射的基本用法</a></p> 
 <p id="1.%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF-toc" style="margin-left:40px;"><a href="#1.%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF" rel="nofollow">1.获取类型信息</a></p> 
 <p id="2.%E8%8E%B7%E5%8F%96%E5%80%BC-toc" style="margin-left:40px;"><a href="#2.%E8%8E%B7%E5%8F%96%E5%80%BC" rel="nofollow">2.获取值</a></p> 
 <p id="3.%E8%AF%BB%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%80%BC-toc" style="margin-left:40px;"><a href="#3.%E8%AF%BB%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%80%BC" rel="nofollow">3.读取和设置值</a></p> 
 <p id="4.%E4%BD%BF%E7%94%A8Kind%E6%9D%A5%E5%8C%BA%E5%88%86%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#4.%E4%BD%BF%E7%94%A8Kind%E6%9D%A5%E5%8C%BA%E5%88%86%E7%B1%BB%E5%9E%8B" rel="nofollow">4.使用Kind来区分类型</a></p> 
 <p id="5.%E6%93%8D%E4%BD%9C%E7%BB%93%E6%9E%84%E4%BD%93-toc" style="margin-left:40px;"><a href="#5.%E6%93%8D%E4%BD%9C%E7%BB%93%E6%9E%84%E4%BD%93" rel="nofollow">5.操作结构体</a></p> 
 <p id="6.%E5%88%9B%E5%BB%BA%E6%96%B0%E5%AE%9E%E4%BE%8B-toc" style="margin-left:40px;"><a href="#6.%E5%88%9B%E5%BB%BA%E6%96%B0%E5%AE%9E%E4%BE%8B" rel="nofollow">6.创建新实例</a></p> 
 <p id="7.%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#7.%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95" rel="nofollow">7.调用方法</a></p> 
 <p id="8.%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#8.%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95" rel="nofollow">8.调用方法</a></p> 
 <p id="%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B" rel="nofollow">二、使用实例</a></p> 
 <p id="-toc" style="margin-left:40px;"></p> 
 <p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
</blockquote> 
<h2><a id="_7"></a></h2> 
<h2 id="%E5%89%8D%E8%A8%80">前言</h2> 
<p>Go语言作为一个高性能的静态语言，我们在写函数的时候，由于go语言的特性，我们需要定义变量类型，大多情况下，变量类型是固定结构体，这就会导致我们想做一个适配性较高的函数的时候，则需要将变量以及返回值用interface{}接口实现</p> 
<hr> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E6%98%A0%E5%B0%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><a id="pandas_16"></a>一、映射的基本用法</h2> 
<h3 id="1.%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF">1.获取类型信息</h3> 
<p>使用`reflect.TypeOf()`可以获取任何值的类型信息</p> 
<pre><code>var x float64 = 3.4
fmt.Println("type:", reflect.TypeOf(x))
</code></pre> 
<h3 id="2.%E8%8E%B7%E5%8F%96%E5%80%BC"><a id="_19"></a>2.获取值</h3> 
<p>使用`reflect.ValueOf()`可以获取reflect.Value类型表示的实际值：</p> 
<pre><code>var x float64 = 3.4
v := reflect.ValueOf(x)
fmt.Println("value:", v)
fmt.Println("type:", v.Type())
fmt.Println("kind:", v.Kind())</code></pre> 
<h3 id="3.%E8%AF%BB%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%80%BC">3.读取和设置值</h3> 
<p>通过reflect可以对变量的值进行读取和设置：</p> 
<pre><code>var x float64 = 3.4
p := reflect.ValueOf(&amp;x) // 注意这里必须要传递x的地址
v := p.Elem()
v.SetFloat(7.1)</code></pre> 
<h3 id="4.%E4%BD%BF%E7%94%A8Kind%E6%9D%A5%E5%8C%BA%E5%88%86%E7%B1%BB%E5%9E%8B">4.使用Kind来区分类型</h3> 
<p>`reflect.Kind`可以用来区分基本类型：</p> 
<pre><code>v := reflect.ValueOf(x)
if v.Kind() == reflect.Float64 {
    // x是float64类型
}
</code></pre> 
<h3 id="5.%E6%93%8D%E4%BD%9C%E7%BB%93%E6%9E%84%E4%BD%93">5.操作结构体</h3> 
<p>可以通过`reflect`包来动态地读取和设置结构体的字段，甚至可以调用方法：</p> 
<pre><code>type MyStruct struct {
    Field1 int
    Field2 string
}

s := MyStruct{Field1: 10, Field2: "Hello"}
v := reflect.ValueOf(s)
typeOfS := v.Type()

for i := 0; i &lt; v.NumField(); i++ {
    field := v.Field(i)
    fmt.Printf("%d: %s %s = %v
", i, typeOfS.Field(i).Name, field.Type(), field.Interface())
}
</code></pre> 
<h3 id="6.%E5%88%9B%E5%BB%BA%E6%96%B0%E5%AE%9E%E4%BE%8B">6.创建新实例</h3> 
<pre><code>type MyStruct struct {
    Field1 int
}

var msType reflect.Type = reflect.TypeOf(MyStruct{})
msValue := reflect.New(msType).Elem()
msValue.Field(0).SetInt(10)
</code></pre> 
<h3 id="7.%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95">7.调用方法</h3> 
<pre><code>//动态调用方法

v := reflect.ValueOf(s)
m := v.MethodByName("MethodName")
args := []reflect.Value{reflect.ValueOf(arg1), reflect.ValueOf(arg2)}
result := m.Call(args)
</code></pre> 
<h3 id="8.%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95">8.调用方法</h3> 
<p>对于映射、切片和数组类型，`reflect`包提供了额外的函数来动态操作它们；例如可以通过`reflect.Append`、`reflect.MakeSlice`等创建和操作切片：</p> 
<pre><code>a := []int{1,2,3}
v := reflect.ValueOf(a)
newValue := reflect.Append(v, reflect.ValueOf(4))
fmt.Println(newValue.Interface()) // [1 2 3 4]
</code></pre> 
<h2 id="%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B">二、使用实例</h2> 
<p>在GIN+GROM框架中我建立了一个表模板</p> 
<pre><code>type TempGeo struct {
	BSM  string `gorm:"type:varchar(255);primary_key"`
	TBMJ float64
	MAC  string `gorm:"type:varchar(255)"`
	Name string `gorm:"type:varchar(255)"`
	Date string `gorm:"type:varchar(255)"`
	Geom string `gorm:"type:geometry(MultiPolygon,4326)"`
}</code></pre> 
<h3><a id="1_20"></a></h3> 
<p>我写了一个接口，想将这个表转换为Geojson</p> 
<pre><code>func (uc *UserController) ShowTempGeo(c *gin.Context) {
	bsm := c.Query("bsm")
	var mytable []models.TempGeo
	DB := models.DB
	DB.Where("bsm = ?", bsm).Find(&amp;mytable)
	data := methods.MakeGeoJSON(mytable)
	c.JSON(http.StatusOK, data)
}</code></pre> 
<p>其中的MakeGeoJSON函数就是使用了映射实现的，如果不使用映射，就会出现如果我重新造一个表，那么我就需要重写一个MakeGeoJSON函数并新定义变量，这是静态语言很麻烦的一个事情，还好go在这方面有一个映射的口子，让我们能写出泛用性函数。以下代码就是将数据都通过映射实现。</p> 
<pre><code>func MakeGeoJSON(items interface{}) interface{} {
	var FeaturesList []*geojson.Feature
	FeaturesList = []*geojson.Feature{}

	var sliceValue reflect.Value
	if reflect.TypeOf(items).Kind() == reflect.Slice {
		sliceValue = reflect.ValueOf(items)
	} else {
		sliceValue = reflect.MakeSlice(reflect.SliceOf(reflect.TypeOf(items)), 1, 1)
		sliceValue.Index(0).Set(reflect.ValueOf(items))
	}

	for i := 0; i &lt; sliceValue.Len(); i++ {
		t := sliceValue.Index(i).Interface()
		v := reflect.ValueOf(t)
		tt := reflect.TypeOf(t)
		geomField := v.FieldByName("Geom")
		if !geomField.IsValid() {
			continue
		}
		geomStr, _ := geomField.Interface().(string)
		properties := make(map[string]interface{})
		for i := 0; i &lt; v.NumField(); i++ {
			if tt.Field(i).Name != "Geom" {
				properties[strings.ToLower(tt.Field(i).Name)] = v.Field(i).Interface()
			}
		}
		wkbBytes, _ := hex.DecodeString(strings.Trim(geomStr, "  "))
		geom, _ := wkb.Unmarshal(wkbBytes)

		feature := geojson.NewFeature(geom)
		feature.Properties = properties
		FeaturesList = append(FeaturesList, feature)
	}
	features := geojson.NewFeatureCollection()
	features.Features = FeaturesList
	GeoJSON, _ := json.Marshal(features)
	var obj interface{}
	json.Unmarshal(GeoJSON, &amp;obj)
	return obj
}</code></pre> 
<hr> 
<h2 id="%E6%80%BB%E7%BB%93"><a id="_45"></a>总结</h2> 
<p>        在Go语言中，`reflect`包被用来在运行时动态地操作对象。尽管这个包非常强大，但是它通常不建议用于日常编程，因为它会使代码更难理解和维护，同时也会减慢程序运行速度。但是当你需要编写通用代码或者框架，或者需要处理未知类型的数据时，`reflect`  包就显得非常有用。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3d25f364db2ee6d4ea0d368e214986bd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux文件编程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fd8eec9bfb226c094db8b8c89b79422d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python笔记（一）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>