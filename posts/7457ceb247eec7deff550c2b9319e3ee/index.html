<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言第十二弹--扫雷 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言第十二弹--扫雷" />
<meta property="og:description" content="✨个人主页： 熬夜学编程的小林
💗系列专栏： 【C语言详解】 【数据结构详解】
扫雷
1、扫雷游戏分析和设计
1.1、扫雷游戏的功能说明
1.2 游戏的分析和设计
1.2.1、数据结构的分析
1.2.2、文件结构设计
2、扫雷游戏的结构分析
2.1、用户选择
2.2、初始化棋盘
2.3、设置雷
2.4、排雷
3、扫雷游戏分文件的代码实现
3.1、test.c
3.2、game.c
3.3、game.h
4、扫雷游戏的扩展
总结
1、扫雷游戏分析和设计 1.1、扫雷游戏的功能说明 • 使用控制台实现经典的扫雷游戏
• 游戏可以通过菜单实现继续玩或者退出游戏
• 扫雷的棋盘是9*9的格子
• 默认随机布置10个雷
• 可以排查雷
◦ 如果位置不是雷，就显示周围有几个雷
◦ 如果位置是雷，就炸死游戏结束
◦ 把除10个雷之外的所有非雷都找出来，排雷成功，游戏结束
游戏的界面：
1.2 游戏的分析和设计 1.2.1、数据结构的分析 扫雷的过程中，布置的雷和排查出的雷的信息都需要存储，所以我们需要⼀定的数据结构来存储这些信息。
因为我们需要在9*9的棋盘上布置雷的信息和排查雷，我们首先想到的就是创建⼀个9*9的数组来存放信息。
那如果这个位置布置雷，我们就存放1，没有布置雷就存放0.
假设我们排查(2,5)这个坐标时，我们访问周围的⼀圈8个位置，统计周围雷的个数是1
假设我们排查(8,6)这个坐标时，我们访问周围的⼀圈8个位置，统计周围雷的个数时，最下面的三
个坐标就会越界，为了防止越界，我们在设计的时候，给数组扩大⼀圈，雷还是布置在中间的9*9的坐标上，周围⼀圈不去布置雷就行，这样就解决了越界的问题。所以我们将存放数据的数组创建成11*11是比较合适。
再继续分析，我们在棋盘上布置了雷，棋盘上雷的信息（1）和非雷的信息（0），假设我们排查了某个位置后，这个坐标处不是雷，这个坐标的周围有1个雷，那我们需要将排查出的雷的数量信息记录存储，并打印出来，作为排雷的重要参考信息的。那这个雷的个数信息存放在哪里呢？如果存放在布置雷的数组中，这样雷的信息和雷的个数信息就可能或产生混淆和打印上的困难。
这里我们肯定有办法解决，比如：雷和非雷的信息不要使用数字，使用某些字符就行，这样就避免冲突了，但是这样做棋盘上有雷和非雷的信息，还有排查出的雷的个数信息，就比较混杂，不够方便。
这里我们采用另外⼀种方案，我们专门给⼀个棋盘（对应⼀个数组mine）存放布置好的雷的信息，再给另外⼀个棋盘（对应另外⼀个数组show）存放排查出的雷的信息。这样就互不干扰了，把雷布置到mine数组，在mine数组中排查雷，排查出的数据存放在show数组，并且打印show数组的信息给后期排查参考。
同时为了保持神秘，show数组开始时初始化为字符 &#39;*&#39;，为了保持两个数组的类型⼀致，可以使用同⼀套函数处理，mine数组最开始也初始化为字符&#39;0&#39;，布置雷改成&#39;1&#39;。如下如：
对应的数组应该是：
char mine[11][11] = {0};//用来存放布置好的雷的信息
char show[11][11] = {0};//用来存放排查出的雷的个数信息
1.2.2、文件结构设计 之前学习了多文件的形式对函数的声明和定义，这里我们实践⼀下，我们设计三个⽂件：
test.c //文 件中写游戏的测试逻辑 game." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/7457ceb247eec7deff550c2b9319e3ee/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-03T19:47:17+08:00" />
<meta property="article:modified_time" content="2024-02-03T19:47:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言第十二弹--扫雷</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="ce606f06783242e5a2c1c1e273b0c273.jpeg" src="https://images2.imgbox.com/dd/85/Yt7v91Yv_o.jpg"></p> 
<p style="text-align:center;">  ✨<span style="color:#956fe7;">个人主页：</span><a href="https://blog.csdn.net/2201_75584283?spm=1011.2415.3001.5343" title=" 熬夜学编程的小林"> <span style="background-color:#ff9900;">熬夜学编程的小林</span></a></p> 
<p style="text-align:center;">💗<span style="color:#fe2c24;">系列专栏：</span> <a href="https://blog.csdn.net/2201_75584283/category_12556736.html" title="【C语言详解】"><span style="background-color:#38d8f0;">【C语言详解】</span></a> <a href="https://blog.csdn.net/2201_75584283/category_12556751.html" title="【数据结构详解】"><span style="background-color:#38d8f0;">【数据结构详解】</span></a></p> 
<p></p> 
<p id="main-toc"><strong>扫雷</strong></p> 
<p id="1%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%86%E6%9E%90%E5%92%8C%E8%AE%BE%E8%AE%A1-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%86%E6%9E%90%E5%92%8C%E8%AE%BE%E8%AE%A1" rel="nofollow">1、扫雷游戏分析和设计</a></p> 
<p id="1.1%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E7%9A%84%E5%8A%9F%E8%83%BD%E8%AF%B4%E6%98%8E-toc" style="margin-left:40px;"><a href="#1.1%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E7%9A%84%E5%8A%9F%E8%83%BD%E8%AF%B4%E6%98%8E" rel="nofollow">1.1、扫雷游戏的功能说明</a></p> 
<p id="1.2%20%E6%B8%B8%E6%88%8F%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E8%AE%BE%E8%AE%A1-toc" style="margin-left:40px;"><a href="#1.2%20%E6%B8%B8%E6%88%8F%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E8%AE%BE%E8%AE%A1" rel="nofollow">1.2 游戏的分析和设计</a></p> 
<p id="1.2.1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#1.2.1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%86%E6%9E%90" rel="nofollow">1.2.1、数据结构的分析</a></p> 
<p id="1.2.2%E3%80%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1-toc" style="margin-left:80px;"><a href="#1.2.2%E3%80%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1" rel="nofollow">1.2.2、文件结构设计</a></p> 
<p id="2%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90" rel="nofollow">2、扫雷游戏的结构分析</a></p> 
<p id="2.1%E3%80%81%E7%94%A8%E6%88%B7%E9%80%89%E6%8B%A9-toc" style="margin-left:40px;"><a href="#2.1%E3%80%81%E7%94%A8%E6%88%B7%E9%80%89%E6%8B%A9" rel="nofollow">2.1、用户选择</a></p> 
<p id="2.2%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A3%8B%E7%9B%98-toc" style="margin-left:40px;"><a href="#2.2%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A3%8B%E7%9B%98" rel="nofollow">2.2、初始化棋盘</a></p> 
<p id="2.3%E3%80%81%E8%AE%BE%E7%BD%AE%E9%9B%B7-toc" style="margin-left:40px;"><a href="#2.3%E3%80%81%E8%AE%BE%E7%BD%AE%E9%9B%B7" rel="nofollow">2.3、设置雷</a></p> 
<p id="2.4%E3%80%81%E6%8E%92%E9%9B%B7-toc" style="margin-left:40px;"><a href="#2.4%E3%80%81%E6%8E%92%E9%9B%B7" rel="nofollow">2.4、排雷</a></p> 
<p id="3%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%86%E6%96%87%E4%BB%B6%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#3%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%86%E6%96%87%E4%BB%B6%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">3、扫雷游戏分文件的代码实现</a></p> 
<p id="3.1%E3%80%81test.c-toc" style="margin-left:40px;"><a href="#3.1%E3%80%81test.c" rel="nofollow">3.1、test.c</a></p> 
<p id="3.2%E3%80%81game.c-toc" style="margin-left:40px;"><a href="#3.2%E3%80%81game.c" rel="nofollow">3.2、game.c</a></p> 
<p id="3.3%E3%80%81game.h-toc" style="margin-left:40px;"><a href="#3.3%E3%80%81game.h" rel="nofollow">3.3、game.h</a></p> 
<p id="4%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E7%9A%84%E6%89%A9%E5%B1%95-toc" style="margin-left:0px;"><a href="#4%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E7%9A%84%E6%89%A9%E5%B1%95" rel="nofollow">4、扫雷游戏的扩展</a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%86%E6%9E%90%E5%92%8C%E8%AE%BE%E8%AE%A1">1、扫雷游戏分析和设计</h2> 
<h3 id="1.1%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E7%9A%84%E5%8A%9F%E8%83%BD%E8%AF%B4%E6%98%8E"><br> 1.1、扫雷游戏的功能说明</h3> 
<blockquote> 
 <p>• 使用控制台实现经典的扫雷游戏<br> • 游戏可以通过菜单实现继续玩或者退出游戏<br> • 扫雷的棋盘是9*9的格子<br> • 默认随机布置10个雷<br> • 可以排查雷<br><strong>◦ 如果位置不是雷，就显示周围有几个雷<br> ◦ 如果位置是雷，就炸死游戏结束<br> ◦ 把除10个雷之外的所有非雷都找出来，排雷成功，游戏结束</strong></p> 
</blockquote> 
<p><br> 游戏的界面：</p> 
<p><img alt="88ed8a3922264102b536571eccd01014.png" src="https://images2.imgbox.com/27/5a/6EhYxPbg_o.png"></p> 
<h3 id="1.2%20%E6%B8%B8%E6%88%8F%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E8%AE%BE%E8%AE%A1"><br> 1.2 游戏的分析和设计</h3> 
<h4 id="1.2.1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%86%E6%9E%90"><br> 1.2.1、数据结构的分析</h4> 
<p><br> 扫雷的过程中，布置的雷和排查出的雷的信息都需要存储，所以我们需要⼀定的数据结构来存储这些信息。<br> 因为我们需要在9*9的棋盘上布置雷的信息和排查雷，我们首先想到的就是创建⼀个9*9的数组来存放信息。</p> 
<p>那如果这个位置布置雷，我们就存放1，没有布置雷就存放0.<br> 假设我们排查(2,5)这个坐标时，我们访问周围的⼀圈8个位置，统计周围雷的个数是1<br> 假设我们排查(8,6)这个坐标时，我们访问周围的⼀圈8个位置，统计周围雷的个数时，最下面的三<br> 个坐标就会越界，为了防止越界，我们在设计的时候，给数组扩大⼀圈，雷还是布置在中间的9*9的坐标上，周围⼀圈不去布置雷就行，这样就解决了越界的问题。所以我们将存放数据的数组创建成11*11是比较合适。</p> 
<p><br> 再继续分析，我们在棋盘上布置了雷，棋盘上雷的信息（1）和非雷的信息（0），假设我们排查了某个位置后，这个坐标处不是雷，这个坐标的周围有1个雷，那我们需要将排查出的雷的数量信息记录存储，并打印出来，作为排雷的重要参考信息的。那这个雷的个数信息存放在哪里呢？如果存放在布置雷的数组中，这样雷的信息和雷的个数信息就可能或产生混淆和打印上的困难。<br> 这里我们肯定有办法解决，比如：雷和非雷的信息不要使用数字，使用某些字符就行，这样就避免冲突了，但是这样做棋盘上有雷和非雷的信息，还有排查出的雷的个数信息，就比较混杂，不够方便。</p> 
<p><br> 这里我们采用另外⼀种方案，我们专门给⼀个棋盘（对应⼀个数组mine）存放布置好的雷的信息，再给另外⼀个棋盘（对应另外⼀个数组show）存放排查出的雷的信息。这样就互不干扰了，把雷布置到mine数组，在mine数组中排查雷，排查出的数据存放在show数组，并且打印show数组的信息给后期排查参考。</p> 
<p><br> 同时为了保持神秘，show数组开始时初始化为字符 '*'，为了保持两个数组的类型⼀致，可以使用同⼀套函数处理，mine数组最开始也初始化为字符'0'，布置雷改成'1'。如下如：<br> 对应的数组应该是：<br> char mine[11][11] = {0};//用来存放布置好的雷的信息<br> char show[11][11] = {0};//用来存放排查出的雷的个数信息</p> 
<h4 id="1.2.2%E3%80%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><br> 1.2.2、文件结构设计</h4> 
<p><br> 之前学习了多文件的形式对函数的声明和定义，这里我们实践⼀下，我们设计三个⽂件：</p> 
<div>
  test.c 
 <em>//文</em> 
 <em>件中写游戏的测试逻辑</em> 
</div> 
<div>
  game.c 
 <em>//文</em> 
 <em>件中写游戏中函数的实现等</em> 
</div> 
<div> 
 <div>
   game.h 
  <em>//文</em> 
  <em>件中写游戏需</em> 
  <em>要的数据类型和函数声明等</em> 
 </div> 
 <div></div> 
</div> 
<p>建议：写一些代码就测试一些代码。</p> 
<h2 id="2%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90"><br> 2、扫雷游戏的结构分析</h2> 
<h3 id="2.1%E3%80%81%E7%94%A8%E6%88%B7%E9%80%89%E6%8B%A9">2.1、用户选择</h3> 
<p>首先用户选择需要的功能，输入1则进入游戏，输入0则退出游戏，输入其他值则重新输入。</p> 
<p>从这可以知道此处为一个循环，而且一定会进入一次，符号do while的特性，因此使用do while循环，但是此处需要打印一个选项的界面，因此可以使用创建一个菜单。</p> 
<p><img alt="0e09178842444c6a84427b2e3cea2938.png" src="https://images2.imgbox.com/e5/46/RNoM7MWb_o.png"></p> 
<pre><code>#include&lt;stdio.h&gt;
//菜单
void menu()
{
	printf("******************************\n");
	printf("*********   1.play   *********\n");
	printf("*********   0.exit   *********\n");
	printf("******************************\n");
}
int main()
{
	int input = 0;
	do
	{
		menu();
		printf("请选择:&gt;\n");
		scanf("%d", &amp;input);
		switch (input)
		{
		case 1:
			//游戏实现
			break;
		case 0:
			printf("游戏结束\n");
			break;
		default:
			printf("选择错误，请重新输入\n");
			break;
		}
	} while (input);//为假则退出循环，即输入0退出循环，游戏结束
	return 0;
}</code></pre> 
<h3 id="2.2%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A3%8B%E7%9B%98">2.2、初始化棋盘</h3> 
<p>根据前面的分析，创建一个能够对两个棋盘初始化的函数。参数有该数组，数组行号，列号，还有初始化的值(这样才能保证一个函数能够初始化两个棋盘)，一个初始化为'0'，一个初始化为'*'，均为字符。为了测试我们需要将棋盘打印出来，此处需要创建一个打印棋盘的函数。参数有数组，行号，列号。</p> 
<pre><code>//初始化棋盘
void BoardInit(char board[ROWS][COLS], int rows, int cols, char set)
{
	int i = 0;
	int j = 0;
	for (i = 0; i &lt; rows; i++)
	{
		for (j = 0; j &lt; cols; j++)
		{
			board[i][j] = set;//棋盘初始为set字符
		}
	}
}
//打印棋盘
void BoardPrint(char board[ROWS][COLS], int row, int col)
{
	int i = 0;
	int j = 0;
	for (i = 1; i &lt;= row; i++)
	{
		for (j = 1; j &lt;= col; j++)
		{
			printf("%c ", board[i][j]);
		}
		printf("\n");
	}
}
int main()
{

	char mine[ROWS][COLS];//雷棋盘
	char show[ROWS][COLS];//展示棋盘

	//初始化雷棋盘
	BoardInit(mine, ROWS, COLS, '0');
	//初始化展示棋盘
	BoardInit(show, ROWS, COLS, '*');

	//打印雷棋盘
	BoardPrint(mine, ROW, COL);
	//打印展示棋盘
	BoardPrint(show, ROW, COL);
	return 0;
}</code></pre> 
<p><img alt="e80bf1e9d219464094fd06b4b61af1b5.png" src="https://images2.imgbox.com/67/fa/Uc02gxou_o.png"></p> 
<p></p> 
<p>优化之后</p> 
<pre><code>#include&lt;stdio.h&gt;
#define ROW 9 //原棋盘大小
#define COL 9

#define ROWS ROW+2 //将原棋盘周围加一圈，即行列+2
#define COLS COL+2
void BoardInit(char board[ROWS][COLS], int rows, int cols, char set)
{
	int i = 0;
	int j = 0;
	for (i = 0; i &lt; rows; i++)
	{
		for (j = 0; j &lt; cols; j++)
		{
			board[i][j] = set;//棋盘初始为set字符
		}
	}
}
//打印棋盘
void BoardPrint(char board[ROWS][COLS], int row, int col)
{
	int i = 0;
	int j = 0;
	printf("------------扫雷游戏-------------\n");
	for (i = 0; i &lt;= row; i++)
	{
		printf("%d ", i);
	}
	printf("\n");
	for (i = 1; i &lt;= row; i++)
	{
		printf("%d ", i);
		for (j = 1; j &lt;= col; j++)
		{
			printf("%c ", board[i][j]);
		}
		printf("\n");
	}
	printf("------------扫雷游戏-------------\n");
}
int main()
{

	char mine[ROWS][COLS];//雷棋盘
	char show[ROWS][COLS];//展示棋盘

	//初始化雷棋盘
	BoardInit(mine, ROWS, COLS, '0');
	//初始化展示棋盘
	BoardInit(show, ROWS, COLS, '*');

	//打印雷棋盘
	BoardPrint(mine, ROW, COL);
	//打印展示棋盘
	BoardPrint(show, ROW, COL);
	return 0;
}</code></pre> 
<p><img alt="2221914255174ce1ae042ba587a22074.png" src="https://images2.imgbox.com/fe/e7/gx6Nh8sJ_o.png"></p> 
<p></p> 
<h3 id="2.3%E3%80%81%E8%AE%BE%E7%BD%AE%E9%9B%B7">2.3、设置雷</h3> 
<p>按照前面要求，我们需要随机设置10个雷，那就需要用到随机数，C语言中有一个函数可以生成随机数，rand()，但是这个随机数不是真正的随机数(每次程序运行的数是一样的)，因此需要用到一个时间函数才能做到真正的是随机数。即srand((unsigned int)time(NULL));随机数函数的头文件为#include&lt;stdlib.h&gt;，时间函数的头文件为#include&lt;time.h&gt;。</p> 
<pre><code>//设置雷
void MineSet(char board[ROWS][COLS], int row, int col)
{
	int count = MINE_COUNT;//#define定义为10个雷
	while (count)
	{
		int x = rand() % row + 1;
		//生成随机数 rand()%row 区间为0-8 x区间为1-9
		int y = rand() % col + 1;

		//判断是否重复 没有重复则添加雷 即等于'0'则放入雷 '1'
		if (board[x][y] == '0')
		{
			board[x][y] = '1';
			count--;//随机数创建成功则count--
		}
	}
}
int main()
{
	srand((unsigned int)time(NULL));
	char mine[ROWS][COLS];//雷棋盘
	char show[ROWS][COLS];//展示棋盘

	//初始化雷棋盘
	BoardInit(mine, ROWS, COLS, '0');
	//初始化展示棋盘
	BoardInit(show, ROWS, COLS, '*');

	//设置雷
	MineSet(mine, ROW, COL);
	//打印雷棋盘
	BoardPrint(mine, ROW, COL);

	return 0;
}</code></pre> 
<p>打印和初始化棋盘的函数在前面有，此处就没有放上去了。</p> 
<p><img alt="fcb0d58571b145899c490f3bf0967636.png" src="https://images2.imgbox.com/13/b7/9VJn0xxs_o.png"></p> 
<p>此处是在测试所以才需要打印存放雷的棋盘，真实游戏场景是不需要打印的。</p> 
<p></p> 
<h3 id="2.4%E3%80%81%E6%8E%92%E9%9B%B7">2.4、排雷</h3> 
<p>排雷有三种情况：</p> 
<p><strong>1、如果是雷则结束<br> 2、如果胜利则结束<br> 3、不是雷且没有胜利则继续</strong></p> 
<p>根据扫雷游戏的界面，我们如果没有找到雷则需要继续排雷，因此可知此处需要使用循环实现。</p> 
<p>排雷需要先输入坐标，然后判断是什么情况，如果坐标非法则重新输入，符合棋盘范围则判断为上述三种情况的哪种，如果不是雷且没有胜利则在展示棋盘中输出周围雷的个数再继续输入坐标继续排雷；如果是雷，输出游戏结束和打印存放雷的棋盘并退出循环；如果坐标重复了做一个提示并重新输入坐标；如果胜利则结束。</p> 
<p><strong>如何计算不是雷的坐标周围有几个雷呢？</strong></p> 
<blockquote> 
 <p>此处可以创建一个计算几个雷的函数返回int类型，因为此处用的是字符数组，所以将该坐标周围的8个位置的值加起来，就是用字符表示个数，但是我们需要返回整数，所以需要减去8*'0'，这样得到的结果就是整数的个数。</p> 
</blockquote> 
<p><strong>如何在展示棋盘打印该位置周围雷的个数呢？</strong></p> 
<blockquote> 
 <p>在初始化棋盘时，我们的类型为字符类型，因此打印时也需要为字符类型，在上面我们通过函数计算了雷的个数，要将整型数字改成字符数字，只需加字符'0'即可。</p> 
</blockquote> 
<p><strong>如何判断胜利呢？</strong></p> 
<blockquote> 
 <p>首先我们知道棋盘总共有行*列个，雷的个数在此处为10个，如果雷的个数加判断不是雷的个数之和等于棋盘个数，说明胜利。因此我们可以在不是雷且没有胜利的情况下创建一个变量，计算不是雷的个数，只要进入此条件则+1。</p> 
</blockquote> 
<pre><code>//计算雷个数
int COUNT_MINE_OF(char mine[ROWS][COLS], int x, int y)
{
	return mine[x - 1][y] +
		mine[x - 1][y + 1] +
		mine[x][y + 1] +
		mine[x + 1][y + 1] +
		mine[x + 1][y] +
		mine[x + 1][y - 1] +
		mine[x][y - 1] +
		mine[x - 1][y - 1] - 8 * '0';
}

//排雷
void MineFind(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)
{
	//判断结束情况
	//1.如果是雷则结束
	//2.如果胜利则结束
	//3.不是雷且没有胜利则继续

	int x = 0;
	int y = 0;
	int win = 0;//判断不是雷的次数
	//1.先输入一个选择

	//如果符合条件则判断雷 不符合则循环
	while (win&lt;row*col-MINE_COUNT)//如果棋盘-雷小于则进行判断游戏是否结束
	{
		printf("请输入你的坐标\n");
		scanf("%d %d", &amp;x, &amp;y);
		if (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col)
		{
			//被排查情况
			if (show[x][y] != '*')
			{
				printf("该坐标被排查过，请重重新输入坐标\n");
			}
			//区间正确 开始判断 开始找是否是雷 
			//如果是雷 则游戏结束
			else if (mine[x][y] == '1')
			{
				printf("游戏结束\n");
				BoardPrint(mine, ROW, COL);
				break;
			}
			//不是雷 判断周围有几个雷
			else
			{
				win++;//不是雷的个数+1
				int ret = COUNT_MINE_OF(mine, x, y);//计算该坐标周围雷的个数
				show[x][y] = ret + '0';//将字符数字赋值给展示棋盘
				BoardPrint(show, ROW, COL);//打印展示棋盘
			}
		}
		else
		{
			//棋盘区间不正确，则重新输入
			printf("输入错误，请重新输入\n");
		}
	}
	//雷的个数+不是雷的个数==棋盘个数 则胜利
	if (win == row * col - MINE_COUNT)
	{
		printf("恭喜你胜利了\n");
		BoardPrint(mine, ROW, COL);
	}
}</code></pre> 
<p><strong>如何测试赢的情况呢？</strong></p> 
<blockquote> 
 <p>此处雷的个数为10个，不是雷的个数为71个，是不是要输入71次才能测试赢呢？此处博主的办法是直接把雷的个数改为80个，那么只有1个不是雷，我们将存储雷的棋盘打印出来，输入不是雷的下标，如果输出胜利则程序没有问题。</p> 
</blockquote> 
<p> <img alt="f5cb7dec892a43f59a9b0ff97d4079b2.png" src="https://images2.imgbox.com/6c/50/W98qD6Bv_o.png"></p> 
<p>注：该游戏的棋盘大小和雷的个数都是通过#define定义，#define可以定义常数，此处这么定义的意义是如果需要改变棋盘大小或者雷个个数，只需要该#define的那一处就行，提高代码可读性和便捷性。</p> 
<p><img alt="c33d118731e845cf8d044ecb0b60f300.png" src="https://images2.imgbox.com/84/16/MmovMKHr_o.png"></p> 
<h2 id="3%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E5%88%86%E6%96%87%E4%BB%B6%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">3、扫雷游戏分文件的代码实现</h2> 
<blockquote> 
 <div>
   test.c 
  <em>//文</em> 
  <em>件中写游戏的测试逻辑</em> 
 </div> 
 <div>
   game.c 
  <em>//文</em> 
  <em>件中写游戏中函数的实现等</em> 
 </div> 
 <div> 
  <div>
    game.h 
   <em>//文</em> 
   <em>件中写游戏需</em> 
   <em>要的数据类型和函数声明等 </em> 
  </div> 
 </div> 
</blockquote> 
<h3 id="3.1%E3%80%81test.c">3.1、test.c</h3> 
<p>test.c代码</p> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include "game.h"
void menu()
{
	printf("******************************\n");
	printf("*********   1.play   *********\n");
	printf("*********   0.exit   *********\n");
	printf("******************************\n");
}
void game()
{
	//定义两个棋盘 一个表示雷状态 一个表示结果 9*9
	//最后需要判断周围8个元素的状态 但是可能会有越界情况
	//所以创建比原本大2的数组 遍历从1-大小
	char mine[ROWS][COLS];//雷棋盘
	char show[ROWS][COLS];//展示棋盘

	//初始化棋盘
	BoardInit(mine, ROWS, COLS,'0');
	BoardInit(show, ROWS, COLS,'*');
	//打印展示棋盘
	BoardPrint(show, ROW, COL);
    //设置雷
	MineSet(mine, ROW, COL);
	//排雷
	MineFind(mine, show, ROW, COL);
}
int main()
{
	srand((unsigned int)time(NULL));
	int input = 0;
	do
	{
		menu();
		printf("请选择:&gt;\n");
		scanf("%d", &amp;input);
		switch (input)
		{
		case 1:
			game();
			break;
		case 0:
			printf("游戏结束\n");
			break;
		default:
			printf("选择错误，请重新输入\n");
			break;
		}
	} while (input);
	return 0;
}</code></pre> 
<h3 id="3.2%E3%80%81game.c">3.2、game.c</h3> 
<p>game.c代码</p> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS
#pragma once
#include "game.h"
//初始化棋盘
void BoardInit(char board[ROWS][COLS], int rows, int cols,char set)
{
	int i = 0;
	int j = 0;
	for (i = 0; i &lt; rows; i++)
	{
		for (j = 0; j &lt; cols; j++)
		{
			board[i][j] = set;
		}
	}
}
//打印棋盘
void BoardPrint(char board[ROWS][COLS], int row, int col)
{
	int i = 0;
	int j = 0;
	printf("------------扫雷游戏-------------\n");
	for (i = 0; i &lt;= row; i++)
	{
		printf("%d ", i);
	}
	printf("\n");
	for (i = 1; i &lt;= row; i++)
	{
		printf("%d ", i);
		for (j = 1; j &lt;= col; j++)
		{
			printf("%c ", board[i][j]);
		}
		printf("\n");
	}
	printf("------------扫雷游戏-------------\n");
}

//设置雷
void MineSet(char board[ROWS][COLS], int row, int col)
{
	int count = MINE_COUNT;
	while (count)
	{
		int x = rand() % row + 1;
		int y = rand() % col + 1;

		//判断是否重复 被等于'0'则放入雷 '1'
		if (board[x][y] == '0')
		{
			board[x][y] = '1';
			count--;
		}
	}
}
//计算雷个数
int COUNT_MINE_OF(char mine[ROWS][COLS], int x, int y)
{
	return mine[x - 1][y] +
		mine[x - 1][y + 1] +
		mine[x][y + 1] +
		mine[x + 1][y + 1] +
		mine[x + 1][y] +
		mine[x + 1][y - 1] +
		mine[x][y - 1] +
		mine[x - 1][y - 1] - 8 * '0';
}

//排雷
void MineFind(char mine[ROWS][COLS], char show[ROWS][COLS], int row, int col)
{
	//判断结束情况
	//1.如果是雷则结束
	//2.如果胜利则结束
	//3.不是雷且没有胜利则继续

	int x = 0;
	int y = 0;
	int win = 0;//判断不是雷的次数
	//1.先输入一个选择

	//如果符合条件则判断雷 不符合则循环
	while (win&lt;row*col-MINE_COUNT)//如果棋盘-雷小于则进行判断游戏是否结束
	{
		printf("请输入你的坐标\n");
		scanf("%d %d", &amp;x, &amp;y);
		if (x &gt;= 1 &amp;&amp; x &lt;= row &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= col)
		{
			//被排查情况
			if (show[x][y] != '*')
			{
				printf("该坐标被排查过，请重重新输入坐标\n");
			}
			//区间正确 开始判断 开始找是否是雷 
			//如果是雷 则游戏结束
			else if (mine[x][y] == '1')
			{
				printf("游戏结束\n");
				BoardPrint(mine, ROW, COL);
				break;
			}
			//不是雷 判断周围有几个雷
			else
			{
				win++;//不是雷的个数+1
				int ret = COUNT_MINE_OF(mine, x, y);//计算该坐标周围雷的个数
				show[x][y] = ret + '0';//将字符数字赋值给展示棋盘
				BoardPrint(show, ROW, COL);//打印展示棋盘
			}
		}
		else
		{
			//棋盘区间不正确，则重新输入
			printf("输入错误，请重新输入\n");
		}
	}
	//雷的个数+不是雷的个数==棋盘个数 则胜利
	if (win == row * col - MINE_COUNT)
	{
		printf("恭喜你胜利了\n");
		BoardPrint(mine, ROW, COL);
	}
}</code></pre> 
<h3 id="3.3%E3%80%81game.h">3.3、game.h</h3> 
<p>game.h代码</p> 
<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;time.h&gt;
#define ROW 9 //原棋盘大小
#define COL 9

#define ROWS ROW+2 //将原棋盘周围加一圈，即行列+2
#define COLS COL+2

#define MINE_COUNT 10

//初始化棋盘
void BoardInit(char board[ROWS][COLS],int rows,int cols,char set);
//打印棋盘
void BoardPrint(char board[ROWS][COLS], int row, int col);
//设置雷
void MineSet(char board[ROWS][COLS], int row, int col);
//排雷
void MineFind(char mine[ROWS][COLS],char show[ROWS][COLS], int row, int col);
//计算雷个数
int COUNT_MINE_OF(char mine[ROWS][COLS],int x,int y);</code></pre> 
<h2 id="4%E3%80%81%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F%E7%9A%84%E6%89%A9%E5%B1%95">4、扫雷游戏的扩展</h2> 
<p><br> • 是否可以选择游戏难度<br> ◦ 简单 9*9 棋盘，10个雷<br> ◦ 中等 16*16棋盘，40个雷<br> ◦ 困难 30*16棋盘，99个雷<br> • 如果排查位置不是雷，周围也没有雷，可以展开周围的⼀⽚<br> • 是否可以标记雷<br> • 是否可以加上排雷的时间显示<br> 在线扫雷游戏：<a class="link-info" href="http://www.minesweeper.cn/" rel="nofollow" title="http://www.minesweeper.cn/">http://www.minesweeper.cn/</a></p> 
<h2 id="%E6%80%BB%E7%BB%93">总结</h2> 
<p>本篇博客就结束啦，谢谢大家的观看，如果公主少年们有好的建议可以留言喔，谢谢大家啦！</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fcd3f67498558a3e231f31e2c9cc067d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">问题：放松的能力是指在____强度之下的____ #知识分享#笔记#媒体</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/05666c5fd4c99586cffeecfacc2ca6b2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【ACL 2023】Enhancing Document-level EAE with Contextual Clues and Role Relevance</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>