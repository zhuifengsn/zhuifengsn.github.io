<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>gcc/g&#43;&#43; 编译器 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="gcc/g&#43;&#43; 编译器" />
<meta property="og:description" content="gcc/g&#43;&#43; 编译器 1 gcc/g&#43;&#43; 编译器1.1 gcc编译过程1.1.1 预处理1.1.2 编译1.1.3 汇编1.1.4 链接 1.2 其他编译选项1.3 静态库和动态库1.3.1 静态库1.3.2 动态库1.3.3 符号链接生成1.3.4 查看库的依赖关系1.3.5 升级版本 1.4 gcc 优化选项 1 gcc/g&#43;&#43; 编译器 Linux 下最常用的C语言编译器是gcc。g&#43;&#43;是用来编辑C&#43;&#43;程序的，但所有的C&#43;&#43;编译器都可以用来编译C程序。g&#43;&#43;编译器实际上调用的也是gcc，只是以必要的选项参数来调用，使gcc能识别出C&#43;&#43;源代码。
gcc -v：查看gcc的版本，从而确定某些语法特性是否可用。
常用的选项：
-c：表示编译源文件
-o：表示输出目标文件
-g：表示在目标文件中产生调试信息，用于gdb调试
-D：&lt;宏定义&gt;编译时将宏定义传入进去
-Wall：打开所有类型的警告
1.1 gcc编译过程 使用gcc编译程序的过程是预处理、编译、汇编和链接，所使用的工具依次是预处理器、编译器、汇编器as、链接器ld。预处理将源文件中的宏进行展开；gcc将c文件编译成汇编文件，汇编器将汇编文件编译成机器码；链接器将目标文件和外部符号进行连接，得到一个可执行二进制文件。
1.1.1 预处理 gcc -E test.c -o test.i
1.1.2 编译 gcc -S test.i -o test.s
1.1.3 汇编 as test.s -o test.o
利用as命令（汇编器）可以将汇编文件编译成机器码。.o 文件中为目标机器上的二进制文件，使用nm命令可以查看文件中的符号表。
1.1.4 链接 得到.o文件后，如果直接执行这个文件，就会提示无法运行。这是因为前面的符号表当中还有很多U的部分，也就是地址未确定的部分，这种文件是无法执行的。在完成链接以后，各个部分的代码的地址都确定以后，文件才能执行。使用gcc命令可以完成链接。
gcc test.o -o test
ld test.o [其他系统库文件] -o test" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/b28152dcc305e8bd06766d18fa3b23e7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-22T16:08:01+08:00" />
<meta property="article:modified_time" content="2024-02-22T16:08:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">gcc/g&#43;&#43; 编译器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>gcc/g++ 编译器</h4> 
 <ul><li><a href="#1_gccg__1" rel="nofollow">1 gcc/g++ 编译器</a></li><li><ul><li><a href="#11_gcc_12" rel="nofollow">1.1 gcc编译过程</a></li><li><ul><li><a href="#111__18" rel="nofollow">1.1.1 预处理</a></li><li><a href="#112__22" rel="nofollow">1.1.2 编译</a></li><li><a href="#113__26" rel="nofollow">1.1.3 汇编</a></li><li><a href="#114__34" rel="nofollow">1.1.4 链接</a></li></ul> 
   </li><li><a href="#12__46" rel="nofollow">1.2 其他编译选项</a></li><li><a href="#13__69" rel="nofollow">1.3 静态库和动态库</a></li><li><ul><li><a href="#131__73" rel="nofollow">1.3.1 静态库</a></li><li><a href="#132__90" rel="nofollow">1.3.2 动态库</a></li><li><a href="#133__103" rel="nofollow">1.3.3 符号链接生成</a></li><li><a href="#134__105" rel="nofollow">1.3.4 查看库的依赖关系</a></li><li><a href="#135__110" rel="nofollow">1.3.5 升级版本</a></li></ul> 
   </li><li><a href="#14_gcc__112" rel="nofollow">1.4 gcc 优化选项</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1_gccg__1"></a>1 gcc/g++ 编译器</h2> 
<p><font face="Times New Roman,黑体" size="3">Linux 下最常用的C语言编译器是gcc。g++是用来编辑C++程序的，但所有的C++编译器都可以用来编译C程序。g++编译器实际上调用的也是gcc，只是以必要的选项参数来调用，使gcc能识别出C++源代码。<br> <code>gcc -v</code>：查看gcc的版本，从而确定某些语法特性是否可用。</font></p> 
<p><img src="https://images2.imgbox.com/d6/bd/gNYniP0q_o.png" alt="在这里插入图片描述"><br> <font face="Times New Roman,黑体" size="3">常用的选项：</font><br> <font color="#7030A0" face="Times New Roman,黑体" size="2">-c：表示编译源文件<br> -o：表示输出目标文件<br> -g：表示在目标文件中产生调试信息，用于gdb调试<br> -D：&lt;宏定义&gt;编译时将宏定义传入进去<br> -Wall：打开所有类型的警告</font></p> 
<h3><a id="11_gcc_12"></a>1.1 gcc编译过程</h3> 
<p><font face="Times New Roman,黑体" size="3">使用gcc编译程序的过程是预处理、编译、汇编和链接，所使用的工具依次是预处理器、编译器、汇编器as、链接器ld。预处理将源文件中的宏进行展开；gcc将c文件编译成汇编文件，汇编器将汇编文件编译成机器码；链接器将目标文件和外部符号进行连接，得到一个可执行二进制文件。<br> </font><br> <img src="https://images2.imgbox.com/9d/92/Bkfcm3Es_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/9f/d5/CAKriEW5_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="111__18"></a>1.1.1 预处理</h4> 
<p><font face="Times New Roman,黑体" size="3"><code>gcc -E test.c -o test.i</code></font></p> 
<p><img src="https://images2.imgbox.com/52/f6/NnDyBwqP_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/ec/6c/P7l1gu9s_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="112__22"></a>1.1.2 编译</h4> 
<p><font face="Times New Roman,黑体" size="3"><code>gcc -S test.i -o test.s</code></font></p> 
<p><img src="https://images2.imgbox.com/09/5a/X2iyugz0_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="113__26"></a>1.1.3 汇编</h4> 
<p><font face="Times New Roman,黑体" size="3"><code>as test.s -o test.o</code></font></p> 
<p><img src="https://images2.imgbox.com/81/9e/NHe8KCem_o.png" alt="在这里插入图片描述"></p> 
<p><font face="Times New Roman,黑体" size="3">利用as命令（汇编器）可以将汇编文件编译成机器码。.o 文件中为目标机器上的二进制文件，使用<code>nm</code>命令可以查看文件中的<mark>符号表</mark>。</font></p> 
<p><img src="https://images2.imgbox.com/2d/f4/YXhwX4f4_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="114__34"></a>1.1.4 链接</h4> 
<p><font face="Times New Roman,黑体" size="3">得到.o文件后，如果直接执行这个文件，就会提示无法运行。这是因为前面的符号表当中还有很多U的部分，也就是<mark>地址未确定的部分</mark>，这种文件是无法执行的。在完成链接以后，各个部分的代码的地址都确定以后，文件才能执行。使用gcc命令可以完成链接。<br> <code>gcc test.o -o test</code><br> <code>ld test.o [其他系统库文件] -o test</code></font></p> 
<p><img src="https://images2.imgbox.com/58/b4/76fpiMqT_o.png" alt="在这里插入图片描述"><br> <font face="Times New Roman,黑体" size="3"><mark>gcc编译过程参数汇总：</mark></font><br> <font color="#7030A0" face="Times New Roman,黑体" size="2">-c：只编译不链接，如果不指定输出文件，将自动生成后缀为.o的目标文件<br> -S：只编译不汇编，生成汇编代码<br> -E：只进行预处理<br> -o file：将file文件作为输出文件<br> -v：打印编译器的版本信息</font></p> 
<h3><a id="12__46"></a>1.2 其他编译选项</h3> 
<p><font face="Times New Roman,黑体" size="3">在gcc命令之后可以添加一些参数来实现不同的需求。</font><br> ① <font face="Times New Roman,黑体" size="3">-D 参数</font><br> <font color="#7030A0" face="Times New Roman,黑体" size="2">-I：如果代码里面包含的头文件不是位于代码所在的目录之下，那么可以在编译时指定头文件所在的目录。<br> -D：通常测试版本会多一些测试语句，例如调试、报错信息打印等。可以采用测试开关的形式来打开或者关闭测试语句<br> <code>gcc -E test1.c -o test1.i -D DEBUG</code><br> <code>gcc -S test1.i -o test1.s</code><br> <code>gcc -o test1 test1.s</code></font><br> <font face="Times New Roman,黑体" size="3">不添加-D选项，编译出来的文件就不会执行测试语句。</font></p> 
<p><img src="https://images2.imgbox.com/b5/1a/Mbu0oMNy_o.png" alt="在这里插入图片描述"><br> <code>gcc -o test2 test2.c -D</code></p> 
<p><img src="https://images2.imgbox.com/40/7e/ASKIZkLj_o.png" alt="在这里插入图片描述"></p> 
<p><font face="Times New Roman,黑体" size="3">通常来说，在编写程序的时候，一些不规范的写法是不会违背C语言的语法规范的，但是却会很有可能在运行的时候带来意想不到的问题。为了解决这个问题，则会添加警告信息。<br> <font color="#7030A0" face="Times New Roman,黑体" size="3">② -Wall：列出所有的警告信息。</font></font></p> 
<p><img src="https://images2.imgbox.com/5a/6a/i4qWRmGS_o.png" alt="在这里插入图片描述"></p> 
<p><font color="#7030A0" face="Times New Roman,黑体" size="3">③ -ansi：生成标准语法（ANSI C标准）所要求的警告信息，并不列出所有警告。</font><br> <font color="#7030A0" face="Times New Roman,黑体" size="3">④ -pedantic：列出ANSI C标准的全部信息。<br> </font></p> 
<h3><a id="13__69"></a>1.3 静态库和动态库</h3> 
<p><font face="Times New Roman,黑体" size="3">  库是一组预先编译好的函数的集合，这些函数都是按照可重用的原则编写的。它们通常由一组相互关联的函数组成以执行某项常见的任务。<br>   标准系统库文件一般存储在/lib和/usr/lib目录中。C语言编译器（链接程序）需要知道搜索哪些库文件，因为在默认情况下，它只搜索标准C语言库。仅把库文件放在标准目录中，就希望编译器能够找到它是不够的，库文件必循遵守特定的命名规范并且需要在命令行中明确指定。<br>   函数库通常同时以静态库和共享库两种格式存在。库文件的名字总是以lib开头，随后的部分指明这是什么库。文件名的最后部分以.开始，然后给出库文件的类型：.a代表传统的静态函数库；.so代表共享函数库。</font></p> 
<h4><a id="131__73"></a>1.3.1 静态库</h4> 
<p><font face="Times New Roman,黑体" size="3">  函数库最简单的形式是一组处于“准备好使用”状态的目标文件。当程序需要使用函数库中某个函数时，它包含一个声明该函数的头文件。编译器和链接器负责将程序代码和函数库结合在一起以组成一个单独的可执行文件。<br>   静态库，也称作归档文件（archive）。在Linux系统中，静态库以一种称为存档（archive）的特殊文件格式存放在磁盘中。存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。</font><br> <font face="Times New Roman,黑体" size="3">  ① 为每个函数分别创建各自的源文件；为库文件创建一个头文件，这个头文件将声明库文件中的函数；编写调用函数的程序，它包含库的头文件并且调用库中的函数。<br>   ② 编译函数以产生要包含在库文件中的目标文件。通过调用带有-c选项的C语言编译器来完成，-c选项的作用是阻止编译器创建一个完整的程序。<br> 语法：<code>gcc -c function.c</code><br>   ③ 创建并使用一个库文件。使用ar程序创建一个归档文件并将目标文件添加进去。<br> 语法：<code>ar crsv libname.a function.o</code>；<code>gcc -o program program.o libname.a</code></font></p> 
<p><img src="https://images2.imgbox.com/a4/94/Gs0fMRoz_o.png" alt="在这里插入图片描述"><br> <font face="Times New Roman,黑体" size="3">  可以使用<code>-l</code>选项来访问函数库，未保存在标准位置，必须使用<code>-L</code>选项来告诉编译器在何处找到它。<code>-L</code>选项告诉编译器在当前目录（.）中查找函数库。<code>-lname</code>选项告诉编译器使用名为<code>libname.a</code>的函数库。<br> 语法：<code>gcc -o program program.o -L. -lname</code></font></p> 
<p><img src="https://images2.imgbox.com/cc/86/ylWQrayt_o.png" alt="在这里插入图片描述"><br> <font face="Times New Roman,黑体" size="3">  将库文件libname.a拷贝到/lib或者/usr/lib下，这是系统的默认搜素路径。</font></p> 
<p><img src="https://images2.imgbox.com/f1/c5/iYNslWGR_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="132__90"></a>1.3.2 动态库</h4> 
<p><font face="Times New Roman,黑体" size="3">  静态库的一个缺点是，当同时运行许多应用程序并且他们都使用来自同一个函数库的函数时，内存中就会有同一函数的多份副本，而且在程序文件自身中也有多份同样的副本。这将消耗大量宝贵的内存和磁盘空间。<br>   共享库的保存位置与静态库是一样的，但共享库有不同的文件名后缀。当一个程序使用一个共享库时，它的链接方式是这样的：<mark>程序本身不在包含函数代码，而是引用运行时可访问的共享代码。当编译好的程序被装载到内存中执行时，函数引用被解析并产生对共享库的调用，如果有必要，共享库才被加载到内存中。</mark><br>   创建动态库：<br> <code>gcc -fPIC -Wall -c function.c</code>；-fPIC选项指示编译器生成与位置无关的代码。<br> <code>gcc -shared -o libname.so function.o</code>；<br> <code>gcc -o main main.c -lname</code></font><br> <font face="Times New Roman,黑体" size="3">  在运行main前，需要注册动态库的路径，将库文件拷贝到/lib或者/uer/lib下。</font></p> 
<p><img src="https://images2.imgbox.com/e0/85/hgIwFdfd_o.png" alt="在这里插入图片描述"></p> 
<p><font face="Times New Roman,黑体" size="3">  动态库——编译时，动态库不会被复制到最终的二进制可执行文件中；执行时，二进制文件和动态库都会被加载到进程地址空间中，动态库方便更新。<br>   静态库——在执行程序时不依赖静态库是否存在，静态库会使程序臃肿并且难以升级。</font></p> 
<h4><a id="133__103"></a>1.3.3 符号链接生成</h4> 
<p><code>ln -s 源文件 软链接名</code></p> 
<h4><a id="134__105"></a>1.3.4 查看库的依赖关系</h4> 
<p><code>which ls</code>；<br> <code>ldd /bin/ls</code>：<font face="Times New Roman,黑体" size="3">ldd只能检查动态依赖</font></p> 
<p><img src="https://images2.imgbox.com/04/2a/sPunuIup_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="135__110"></a>1.3.5 升级版本</h4> 
<p><font face="Times New Roman,黑体" size="3">  ① 生成新的库文件 ② 将原来的软链接指向新的库文件 ③ 删除旧的库文件</font></p> 
<h3><a id="14_gcc__112"></a>1.4 gcc 优化选项</h3> 
<p><font face="Times New Roman,黑体" size="3">  gcc对代码进行优化通过选项“-On”来控制优化级别（n是整数）。使用优化选项“-O1”主要进行线程跳转和延迟退栈两种优化。使用优化选项“-O2”除了完成所有“-O1”级别的优化之外，还要进行一些额外的调整工作，如处理其指令调度等。选项“-O3”则还包括循环展开或其他一些与处理器特性相关的优化工作。<br>   虽然优化选项可以加速代码的运行速度，但对于调试而言将是一个很大的挑战。因为代码在经过优化之后，原先在源程序中声明和使用的变量很可能不再使用，控制流也可能会突然跳转到意外的地方，循环语句也有可能因为循环展开而变得到处都有，这些对调试来讲都是不好的。所以，在调试的时候最好不要使用任何的优化选项，只有当程序在最终发行的时候才考虑对其进行优化，通常用的是 -O2。</font></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e31bcc4bff92ed0fda4210f892659ed6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python子域名收集工具</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4fed52242bd0565ab1700b7ed213dcb9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Sovit3D数字孪生平台 助力智慧海上风电场项目加速</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>