<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C# 实现网页内容保存为图片并生成压缩包 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C# 实现网页内容保存为图片并生成压缩包" />
<meta property="og:description" content="目录
应用场景
实现代码
扩展功能(生成压缩包)
小结 应用场景 我们在一个求职简历打印的项目功能里，需要根据一定的查询条件，得到结果并批量导出指定格式的文件。导出的格式可能有多种，比如WORD格式、EXCEL格式、PDF格式等，实现方式是通过设置对应的模板进行输出，实际情况是，简历的内容是灵活设置的，没有固定的格式，模板数量是不固定的。
通过动态页面技术，可以实现简历配置后的网页内容输出，但制作对应的各种模板会遇到开发效率和服务跟进的问题。为了保障原样输出，折中而简单的方案就是将动态输出的页面转化为图片格式。
实现代码 创建一个 UrlToImage 类，创建实例的时候传递指定的 URL, 并调用 SaveToImageFile（string outputFilename）方法，该方法传递要输出的文件名参数即可即可。
调用示例代码如下：
string url = &#34;https://&#34; &#43; Request.Url.Host &#43; &#34;/printResume.aspx&#34;; UrlToImage uti = new UrlToImage(url); bool irv = uti.SaveToImageFile(Request.PhysicalApplicationPath &#43; &#34;\\test.jpg&#34;); if(bool==false){ Response.Write(&#34;save failed.&#34;); Response.End(); } 类及实现代码如下：
public class UrlToImage { private Bitmap m_Bitmap; private string m_Url; private string m_FileName = string.Empty; int initheight = 0; public UrlToImage(string url) { // Without file m_Url = url; } public UrlToImage(string url, string fileName) { // With file m_Url = url; m_FileName = fileName; } public Bitmap Generate() { // Thread var m_thread = new Thread(_Generate); m_thread." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/916ff658ad7dc1fcd4d96e17fed8d719/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-24T19:57:19+08:00" />
<meta property="article:modified_time" content="2024-02-24T19:57:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C# 实现网页内容保存为图片并生成压缩包</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">应用场景</a></p> 
<p id="%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81" rel="nofollow">实现代码</a></p> 
<p id="%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD(%E7%94%9F%E6%88%90%E5%8E%8B%E7%BC%A9%E5%8C%85)-toc" style="margin-left:40px;"><a href="#%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD%28%E7%94%9F%E6%88%90%E5%8E%8B%E7%BC%A9%E5%8C%85%29" rel="nofollow">扩展功能(生成压缩包)</a></p> 
<p id="%E5%B0%8F%E7%BB%93%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%B0%8F%E7%BB%93%C2%A0" rel="nofollow">小结 </a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3>应用场景</h3> 
<p>我们在一个求职简历打印的项目功能里，需要根据一定的查询条件，得到结果并批量导出指定格式的文件。导出的格式可能有多种，比如WORD格式、EXCEL格式、PDF格式等，实现方式是通过设置对应的模板进行输出，实际情况是，简历的内容是灵活设置的，没有固定的格式，模板数量是不固定的。</p> 
<p>通过动态页面技术，可以实现简历配置后的网页内容输出，但制作对应的各种模板会遇到开发效率和服务跟进的问题。为了保障原样输出，折中而简单的方案就是将动态输出的页面转化为图片格式。</p> 
<h3 id="%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81">实现代码</h3> 
<p>创建一个 UrlToImage 类，创建实例的时候传递指定的 URL, 并调用 SaveToImageFile（string outputFilename）方法，该方法传递要输出的文件名参数即可即可。</p> 
<p>调用示例代码如下：</p> 
<pre><code class="language-cs">string url = "https://" + Request.Url.Host + "/printResume.aspx";
UrlToImage uti = new UrlToImage(url);
bool irv = uti.SaveToImageFile(Request.PhysicalApplicationPath + "\\test.jpg");
if(bool==false){
    Response.Write("save failed.");
    Response.End();
}</code></pre> 
<p>类及实现代码如下：</p> 
<pre><code class="language-cs">    public class UrlToImage
    {
        private  Bitmap m_Bitmap;
        private string m_Url;
        private string m_FileName = string.Empty;
        int initheight = 0;

        public UrlToImage(string url)
        {
            // Without file
            m_Url = url;
        }

        public UrlToImage(string url, string fileName)
        {
            // With file
            m_Url = url;
            m_FileName = fileName;
        }

        public Bitmap Generate()
        {
            // Thread
            var m_thread = new Thread(_Generate);
            m_thread.SetApartmentState(ApartmentState.STA);
            m_thread.Start();
            m_thread.Join();
            return m_Bitmap;
        }
        public bool SaveToImageFile(string filename)
        {
            Bitmap bt=Generate();
            if (bt == null)
            {
                return false;
            }
            bt.Save(filename);
            return File.Exists(filename);
        }
        private void _Generate()
        {
            var browser = new WebBrowser { ScrollBarsEnabled = false };
            browser.ScriptErrorsSuppressed = true;
            initheight = 0;
            browser.Navigate(m_Url);
            browser.DocumentCompleted += WebBrowser_DocumentCompleted;

            while (browser.ReadyState != WebBrowserReadyState.Complete)
            {
                Application.DoEvents();
            }

            browser.Dispose();
        }

        private void WebBrowser_DocumentCompleted(object sender, WebBrowserDocumentCompletedEventArgs e)
        {
            // Capture
            var browser = (WebBrowser)sender;
            browser.ClientSize = new Size(browser.Document.Body.ScrollRectangle.Width, browser.Document.Body.ScrollRectangle.Bottom);
            browser.ScrollBarsEnabled = false;
            m_Bitmap = new Bitmap(browser.Document.Body.ScrollRectangle.Width, browser.Document.Body.ScrollRectangle.Bottom);
            browser.BringToFront();
            browser.DrawToBitmap(m_Bitmap, browser.Bounds);

            // Save as file?
            if (m_FileName.Length &gt; 0)
            {
                // Save
                m_Bitmap.SaveJPG100(m_FileName);
            }
            if (initheight == browser.Document.Body.ScrollRectangle.Bottom)
            {
                browser.DocumentCompleted -= new WebBrowserDocumentCompletedEventHandler(WebBrowser_DocumentCompleted);
            }
            initheight = browser.Document.Body.ScrollRectangle.Bottom;
        }
    }</code></pre> 
<h3 id="%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD(%E7%94%9F%E6%88%90%E5%8E%8B%E7%BC%A9%E5%8C%85)">生成压缩包</h3> 
<p> 对于批量生成的图片文件，我们可以生成压缩包为客户提供下载功能，压缩功能引用的是ICSharpCode.SharpZipLib.dll，创建 ZipCompress 类的实例，ZipDirectory(zippath, zipfile, password) 方法，需要提供的参数包括，压缩的目录、生成的压缩文件名，压缩包的打开密码。</p> 
<p>示例代码如下：</p> 
<pre><code class="language-cs">    string zippath = Request.PhysicalApplicationPath + "\\des\\" ;
    if (!Directory.Exists(zippath))
    {
        Directory.CreateDirectory(zippath);
    }
    string zipfile = Request.PhysicalApplicationPath + "\\des\\test.zip";
    ZipCompress allgzip = new ZipCompress();
    System.IO.DirectoryInfo alldi = new System.IO.DirectoryInfo(zippath);
    string password = "123456";

    allgzip.ZipDirectory(zippath, zipfile, password);
    //以下是生成完压缩包后，清除目录及文件
    string[] allfs = Directory.GetFiles(zippath);
    for (int i = 0; i &lt; allfs.Length; i++)
    {
        File.Delete(allfs[i]);
    }
    Directory.Delete(zippath);  

</code></pre> 
<p>类及实现代码如下：</p> 
<pre><code class="language-cs"> public class ZipCompress
    {
        
        public  byte[] Compress(byte[] inputBytes)
        {
            using (MemoryStream outStream = new MemoryStream())
            {
                using (GZipStream zipStream = new GZipStream(outStream, CompressionMode.Compress, true))
                {
                    zipStream.Write(inputBytes, 0, inputBytes.Length);
                    zipStream.Close(); //很重要，必须关闭，否则无法正确解压
                    return outStream.ToArray();
                }
            }
        }

        public  byte[] Decompress(byte[] inputBytes)
        {

            using (MemoryStream inputStream = new MemoryStream(inputBytes))
            {
                using (MemoryStream outStream = new MemoryStream())
                {
                    using (GZipStream zipStream = new GZipStream(inputStream, CompressionMode.Decompress))
                    {
                        zipStream.CopyTo(outStream);
                        zipStream.Close();
                        return outStream.ToArray();
                    }
                }

            }
        }
        public  string Compress(string input)
        {
            byte[] inputBytes = Encoding.Default.GetBytes(input);
            byte[] result = Compress(inputBytes);
            return Convert.ToBase64String(result);
        }
        public  string Decompress(string input)
        {
            byte[] inputBytes = Convert.FromBase64String(input);
            byte[] depressBytes = Decompress(inputBytes);
            return Encoding.Default.GetString(depressBytes);
        }
        public  void Compress(DirectoryInfo dir)
        {
            foreach (FileInfo fileToCompress in dir.GetFiles())
            {
                Compress(fileToCompress);
            }
        }
        public  void Decompress(DirectoryInfo dir)
        {
            foreach (FileInfo fileToCompress in dir.GetFiles())
            {
                Decompress(fileToCompress);
            }
        }
        public  void Compress(FileInfo fileToCompress)
        {
            using (FileStream originalFileStream = fileToCompress.OpenRead())
            {
                if ((File.GetAttributes(fileToCompress.FullName) &amp; FileAttributes.Hidden) != FileAttributes.Hidden &amp; fileToCompress.Extension != ".gz")
                {
                    using (FileStream compressedFileStream = File.Create(fileToCompress.FullName + ".gz"))
                    {
                        using (GZipStream compressionStream = new GZipStream(compressedFileStream, CompressionMode.Compress))
                        {
                            originalFileStream.CopyTo(compressionStream);
                        }
                    }
                }
            }
        }
        public  void Decompress(FileInfo fileToDecompress,string desfilename="")
        {
            using (FileStream originalFileStream = fileToDecompress.OpenRead())
            {
                string currentFileName = fileToDecompress.FullName;
                string newFileName = currentFileName.Remove(currentFileName.Length - fileToDecompress.Extension.Length);
                if (desfilename != "")
                {
                    newFileName = desfilename;
                }

                using (FileStream decompressedFileStream = File.Create(newFileName))
                {
                    using (GZipStream decompressionStream = new GZipStream(originalFileStream, CompressionMode.Decompress))
                    {
                        decompressionStream.CopyTo(decompressedFileStream);
                    }
                }
            }
        }


        
        public  void ZipDirectory(string folderToZip, string zipedFileName,string password)
        {
            ZipDirectory(folderToZip, zipedFileName,(password==""?string.Empty:password), true, string.Empty, string.Empty, true);
        }
 
 

        public  void ZipDirectory(string folderToZip, string zipedFileName, string password, bool isRecurse, string fileRegexFilter, string directoryRegexFilter, bool isCreateEmptyDirectories)
        {
             FastZip fastZip = new FastZip();
            fastZip.CreateEmptyDirectories = isCreateEmptyDirectories;
            fastZip.Password = password;
            fastZip.CreateZip(zipedFileName, folderToZip, isRecurse, fileRegexFilter, directoryRegexFilter);
       
        }
        public void UnZipDirectory(string zipedFileName, string targetDirectory, string password,string fileFilter=null)
        {
            FastZip fastZip = new FastZip();
            fastZip.Password = password;
            fastZip.ExtractZip(zipedFileName, targetDirectory,fileFilter);

        }


        public void UnZip(string zipFilePath, string unZipDir)
        {
           
            if (zipFilePath == string.Empty)
            {
                throw new Exception("压缩文件不能为空！");
            }
            if (!File.Exists(zipFilePath))
            {
                throw new FileNotFoundException("压缩文件不存在！");
            }
            //解压文件夹为空时默认与压缩文件同一级目录下，跟压缩文件同名的文件夹  
            if (unZipDir == string.Empty)
                unZipDir = zipFilePath.Replace(Path.GetFileName(zipFilePath), Path.GetFileNameWithoutExtension(zipFilePath));
            if (!unZipDir.EndsWith("/"))
                unZipDir += "/";
            if (!Directory.Exists(unZipDir))
                Directory.CreateDirectory(unZipDir);
 
            using (var s = new ZipInputStream(File.OpenRead(zipFilePath)))
            {
 
                ZipEntry theEntry;
                while ((theEntry = s.GetNextEntry()) != null)
                {
                    string directoryName = Path.GetDirectoryName(theEntry.Name);
                    string fileName = Path.GetFileName(theEntry.Name);
                    if (!string.IsNullOrEmpty(directoryName))
                    {
                        Directory.CreateDirectory(unZipDir + directoryName);
                    }
                    if (directoryName != null &amp;&amp; !directoryName.EndsWith("/"))
                    {
                    }
                    if (fileName != String.Empty)
                    {
                        using (FileStream streamWriter = File.Create(unZipDir + theEntry.Name))
                        {
 
                            int size;
                            byte[] data = new byte[2048];
                            while (true)
                            {
                                size = s.Read(data, 0, data.Length);
                                if (size &gt; 0)
                                {
                                    streamWriter.Write(data, 0, size);
                                }
                                else
                                {
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }

    }</code></pre> 
<h3 id="%E5%B0%8F%E7%BB%93%C2%A0">小结 </h3> 
<p>对于生成的图片文件，我们还可以结合其它的API应用，来判断图片是否有被PS的情况，来提升和扩展应用程序的功能。另外，对于被访问的动态页面，建议使用访问控制，只有正常登录或提供访问令牌的用户才可以生成结果图片，以保证数据的安全性。</p> 
<p>以上代码仅供参考，欢迎大家指正，再次感谢您的阅读！</p> 
<p> </p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f115869cb3ea1ed2ffc46c370f81874b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2024.2.23 模拟实现 RabbitMQ —— 实现消费消息逻辑</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b8267756c8abe8138e8f70bab7e2b33e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【深度学习】Logistic回归算法和向量化编程。全md文档笔记（代码文档已分享）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>