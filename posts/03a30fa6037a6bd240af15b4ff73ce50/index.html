<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据库调优策略 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据库调优策略" />
<meta property="og:description" content="数据库其他调优策略 一、数据库调优的措施1.1 调优的目标1.2 如何定位调优问题1.3 调优的维度和步骤 二、优化MySQL服务器2.1 优化服务器硬件2.2 优化MySQL的参数 三、优化数据库结构3.1 拆分表：冷热数据分离3.2 增加中间表3.3 增加冗余字段3.4 优化数据类型3.5 优化插入记录的速度3.5.1 MyISAM引擎的表3.5.2 InnoDB引擎的表 3.6 使用非空约束3.7 分析表、检查表与优化表3.7.1 分析表3.7.2 检查表3.7.3 优化表 3.8 小结 四、大表优化4.1 限定查询的范围4.2 读/写分离4.3 垂直拆分4.4 水平拆分 一、数据库调优的措施 1.1 调优的目标 尽可能节省系统资源，以便系统可以提供更大负荷的服务。（吞吐量更大）合理的结构设计和参数调整，以提高用户操作响应的速度。（响应速度更快）减少系统的瓶颈，提供MySQL数据库整体的性能。 1.2 如何定位调优问题 随着用户量的不断增加，以及应用程序复杂度的提升，我们很难用“更快”去定义数据库调优的目标，因为用户在不同时间段访问服务器遇到的瓶颈不同，比如双十一促销的时候会带来大规模的并发访问；用户在进行不同业务操作的时候，数据库的事务处理和SQL查询都会有所不同。因此我们需要更精细的定位，去确定调优的目标。
如何确定呢，一般有以下几种方式：
用户的反馈（主要）：用户是我们的服务对象，因此他们的反馈是最直接的。虽然他们不会直接提出技术建议，但是有些问题往往是用户第一时间发现的。我们要重视用户的反馈，找到和数据相关的问题。日志分析（主要）：我们可以通过查看数据库日志和操作系统日志等方式找出异常情况，通过它们来定位遇到的问题。服务器资源使用监控：通过监控服务器CPU、内存、I/O等使用情况，可以实时了解服务器的性能使用，与历史情况进行对比。数据库内部状况监控：在数据库的监控中，活动会话（Active Session）监控是一个重要的指标。通过它，你可以清楚地了解数据库当前是否处于非常繁忙的状态，是否存在SQL堆积等。其他：除了活动会话监控以外，我们也可以对事务、锁等待等进行监控，这些都可以帮助我们对数据库的运行状态由更全面的认识。 1.3 调优的维度和步骤 我们需要调优的对象是整个数据库管理系统，它不仅包括SQL查询，还包括数据库的部署配置、架构等。从这个角度来说，我们思考的维度就不仅仅局限在SQL优化上。通过以下步骤进行梳理：
第一步：选择适合的DBMS
如果对事务性处理以及安全性要求高的话，可以选择商业的数据库产品。这些数据库在事务处理和查询性能上都比较强。比如采用SQL Server、Oracle，那么单表存储上亿条数据是没有问题的。如果数据表设计得好，即使不采用分库分表的方式，查询效率也不差。
除此以外，你也可以采用开源的MySQL进行存储，它有很多存储引擎可以选择，如果进行事务处理的话可以选择InnoDB，非事务处理可以选择MyISAM。
NoSQL阵营包括键值型数据库、文档型数据库、搜索引擎、列式存储和图形数据库。这些数据库的优缺点和使用场景各有不同，比如列式存储数据库可以大幅度降低系统的I/O，适合分布式文件系统，但如果数据需要频繁地增删改，那么列式存储就不适用了。
DBMS的选择关系到了后面的整个设计过程，所以第一步就是选择适合的DBMS。 如果已经确定好了DBMS，那么这步可以跳过。
第二步：优化表设计
数据表的设计方式直接影响了后续的SQL查询语句。RDBMS中，每个对象都可以定义为一张表，表与表之间的关系代表了对象之间的关系。如果用的是MySQL，我们还可以根据不同表的使用需求，选择不同的存储引擎。除此之外，还有一些优化的原则可以参考：
表结构要尽量遵循三范式的原则。这样可以让数据结构更加清晰规范，减少冗余字段，同时也减少了在更新，插入和删除数据时等异常情况的发生。如果查询应用比较多，尤其是需要进行多表联查的时候，可以采用反范式进行优化。反范式采用空间换时间的方式，通过增加冗余字段来提高查询效率。表字段的数据类型选择，关系到了查询效率的高低以及存储空间的大小。一般来说，如果字段可以采用数值类型就不要采用字符类型；字符长度要尽可能设计得短一些。针对字符类型来说，当确定字符长度固定时，就可以采用CHAR类型；当长度不固定时，通常采用VARCHAR类型。 数据表的结构设计很基础，也很关键。好的表结构可以在业务发展和用户量增加的情况下依然发挥作用，不好的表结构设计会让数据表变的非常臃肿，查询效率也会降低。
第三步：优化逻辑查询
当我们建立好数据表之后，就可以对数据表进行增删改查的操作了。这时我们首先需要考虑的是逻辑查询优化。
SQL查询优化可以分为逻辑查询优化和物理查询优化。逻辑查询优化就是通过改变SQL语句的内容让SQL进行效率更高效，采用的方式是对SQL语句进行等价交换，对查询进行重写。
SQL的查询重写包括了子查询优化、等价谓词重写、视图重写、条件简化、连续消除和嵌套连接消除等。
第四步：优化物理查询
物理查询优化是在确定了逻辑查询优化之后，采用物理优化技术（比如索引等），通过技术代价模型对各种可能的访问路径进行估算，从而找到执行方式中代价最小的作为执行计划。在这个部分中，我们需要掌握的重点是对索引的创建和使用。
但索引不是万能的，我们需要根据实际情况来创建索引。SQL查询时需要对不同的数据表进行查询，因此在物理查询优化阶段也需要确定这些查询所采用的路径，具体的情况包括：
1. 单表扫描：对于单表扫描来说，我们可以全表扫描所有的数据，也可以局部扫描。
2. 两张表的连接：常用的连接方式包括了嵌套循环连接、HASH连接和合并连接。
3. 多张表的连接：多张数据表进行连接的时候，顺序很重要，因为不同的连接路径查询的效率不同，搜索空间也会不同。我们在进行多表连接的时候，搜索空间可能会达到很高的数据量级，巨大的搜索空间显然会占用更多的资源，因此我们需要通过调整连接顺序，将搜索空间调整在一个可接受的范围内。
第五步：使用Redis或Memcached作为缓存
除了可以对SQL本身进行优化以外，我们还可以请外援提升查询的效率。
因为数据都是存放到数据库中，我们需要从数据库层中取出数据放到内存中进行业务逻辑的操作。当用户量增大的时候，如果频繁的进行数据查询，会消耗数据库的很多资源。如果我们将常用的数据直接放到内存中，就会大幅提升查询的效率。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/03a30fa6037a6bd240af15b4ff73ce50/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-01T16:27:22+08:00" />
<meta property="article:modified_time" content="2023-03-01T16:27:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据库调优策略</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>数据库其他调优策略</h4> 
 <ul><li><a href="#_3" rel="nofollow">一、数据库调优的措施</a></li><li><ul><li><a href="#11___4" rel="nofollow">1.1 调优的目标</a></li><li><a href="#12__9" rel="nofollow">1.2 如何定位调优问题</a></li><li><a href="#13__21" rel="nofollow">1.3 调优的维度和步骤</a></li></ul> 
  </li><li><a href="#MySQL_66" rel="nofollow">二、优化MySQL服务器</a></li><li><ul><li><a href="#21__69" rel="nofollow">2.1 优化服务器硬件</a></li><li><a href="#22_MySQL_76" rel="nofollow">2.2 优化MySQL的参数</a></li></ul> 
  </li><li><a href="#_101" rel="nofollow">三、优化数据库结构</a></li><li><ul><li><a href="#31__104" rel="nofollow">3.1 拆分表：冷热数据分离</a></li><li><a href="#32__113" rel="nofollow">3.2 增加中间表</a></li><li><a href="#33__123" rel="nofollow">3.3 增加冗余字段</a></li><li><a href="#34__128" rel="nofollow">3.4 优化数据类型</a></li><li><a href="#35__144" rel="nofollow">3.5 优化插入记录的速度</a></li><li><ul><li><a href="#351_MyISAM_147" rel="nofollow">3.5.1 MyISAM引擎的表</a></li><li><a href="#352_InnoDB_165" rel="nofollow">3.5.2 InnoDB引擎的表</a></li></ul> 
   </li><li><a href="#36__187" rel="nofollow">3.6 使用非空约束</a></li><li><a href="#37__193" rel="nofollow">3.7 分析表、检查表与优化表</a></li><li><ul><li><a href="#371__196" rel="nofollow">3.7.1 分析表</a></li><li><a href="#372__211" rel="nofollow">3.7.2 检查表</a></li><li><a href="#373__214" rel="nofollow">3.7.3 优化表</a></li></ul> 
   </li><li><a href="#38__221" rel="nofollow">3.8 小结</a></li></ul> 
  </li><li><a href="#_231" rel="nofollow">四、大表优化</a></li><li><ul><li><a href="#41__234" rel="nofollow">4.1 限定查询的范围</a></li><li><a href="#42__236" rel="nofollow">4.2 读/写分离</a></li><li><a href="#43__241" rel="nofollow">4.3 垂直拆分</a></li><li><a href="#44__244" rel="nofollow">4.4 水平拆分</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_3"></a>一、数据库调优的措施</h2> 
<h3><a id="11___4"></a>1.1 调优的目标</h3> 
<ul><li>尽可能<mark>节省系统资源</mark>，以便系统可以提供更大负荷的服务。（吞吐量更大）</li><li>合理的结构设计和参数调整，以提高用户操作<mark>响应的速度</mark>。（响应速度更快）</li><li>减少系统的瓶颈，提供MySQL数据库整体的性能。</li></ul> 
<h3><a id="12__9"></a>1.2 如何定位调优问题</h3> 
<p>随着用户量的不断增加，以及应用程序复杂度的提升，我们很难用“更快”去定义数据库调优的目标，因为用户在不同时间段访问服务器遇到的瓶颈不同，比如双十一促销的时候会带来大规模的<mark>并发访问</mark>；用户在进行不同业务操作的时候，数据库的<mark>事务处理</mark>和<mark>SQL查询</mark>都会有所不同。因此我们需要更精细的定位，去确定调优的目标。</p> 
<p><strong>如何确定呢，一般有以下几种方式：</strong></p> 
<ul><li><strong>用户的反馈（主要）</strong>：用户是我们的服务对象，因此他们的反馈是最直接的。虽然他们不会直接提出技术建议，但是有些问题往往是用户第一时间发现的。我们要重视用户的反馈，找到和数据相关的问题。</li><li><strong>日志分析（主要）</strong>：我们可以通过查看数据库日志和操作系统日志等方式找出异常情况，通过它们来定位遇到的问题。</li><li><strong>服务器资源使用监控</strong>：通过监控服务器CPU、内存、I/O等使用情况，可以实时了解服务器的性能使用，与历史情况进行对比。</li><li><strong>数据库内部状况监控</strong>：在数据库的监控中，<mark>活动会话（Active Session）监控</mark>是一个重要的指标。通过它，你可以清楚地了解数据库当前是否处于非常繁忙的状态，是否存在SQL堆积等。</li><li><strong>其他</strong>：除了活动会话监控以外，我们也可以对<mark>事务、锁等待</mark>等进行监控，这些都可以帮助我们对数据库的运行状态由更全面的认识。</li></ul> 
<h3><a id="13__21"></a>1.3 调优的维度和步骤</h3> 
<p>我们需要调优的对象是整个数据库管理系统，它不仅包括SQL查询，还包括数据库的部署配置、架构等。从这个角度来说，我们思考的维度就不仅仅局限在SQL优化上。通过以下步骤进行梳理：</p> 
<ul><li> <p><strong>第一步：选择适合的DBMS</strong><br> 如果对<mark>事务性处理</mark>以及<mark>安全性要求高</mark>的话，可以选择商业的数据库产品。这些数据库在事务处理和查询性能上都比较强。比如采用SQL Server、Oracle，那么<mark>单表存储上亿条数据</mark>是没有问题的。如果数据表设计得好，即使不采用<mark>分库分表</mark>的方式，查询效率也不差。<br> 除此以外，你也可以采用开源的MySQL进行存储，它有很多存储引擎可以选择，如果进行事务处理的话可以选择InnoDB，非事务处理可以选择MyISAM。<br> NoSQL阵营包括<mark>键值型数据库、文档型数据库、搜索引擎、列式存储和图形数据库</mark>。这些数据库的优缺点和使用场景各有不同，比如列式存储数据库可以大幅度降低系统的I/O，适合分布式文件系统，但如果数据需要频繁地增删改，那么列式存储就不适用了。<br> <mark>DBMS的选择关系到了后面的整个设计过程，所以第一步就是选择适合的DBMS。</mark> 如果已经确定好了DBMS，那么这步可以跳过。</p> </li><li> <p><strong>第二步：优化表设计</strong><br> 数据表的设计方式直接影响了后续的SQL查询语句。RDBMS中，每个对象都可以定义为一张表，表与表之间的关系代表了对象之间的关系。如果用的是MySQL，我们还可以根据不同表的使用需求，选择不同的存储引擎。除此之外，还有一些优化的原则可以参考：</p> 
  <ul><li>表结构要尽量<mark>遵循三范式的原则</mark>。这样可以让数据结构更加清晰规范，减少冗余字段，同时也减少了在更新，插入和删除数据时等异常情况的发生。</li><li>如果<mark>查询</mark>应用比较多，尤其是需要进行<mark>多表联查</mark>的时候，可以采用<mark>反范式</mark>进行优化。反范式采用<mark>空间换时间</mark>的方式，通过增加冗余字段来提高查询效率。</li><li><mark>表字段的数据类型选择</mark>，关系到了查询效率的高低以及存储空间的大小。一般来说，如果字段可以采用数值类型就不要采用字符类型；字符长度要尽可能设计得短一些。针对字符类型来说，当确定字符长度固定时，就可以采用CHAR类型；当长度不固定时，通常采用VARCHAR类型。</li></ul> </li></ul> 
<p>数据表的结构设计很基础，也很关键。<mark>好的表结构可以在业务发展和用户量增加的情况下依然发挥作用，不好的表结构设计会让数据表变的非常臃肿，查询效率也会降低</mark>。</p> 
<ul><li> <p><strong>第三步：优化逻辑查询</strong><br> 当我们建立好数据表之后，就可以对数据表进行增删改查的操作了。这时我们首先需要考虑的是逻辑查询优化。<br> SQL查询优化可以分为<mark>逻辑查询优化</mark>和<mark>物理查询优化</mark>。逻辑查询优化就是通过改变SQL语句的内容让SQL进行效率更高效，采用的方式是对SQL语句进行等价交换，对查询进行重写。<br> <mark>SQL的查询重写包括了子查询优化、等价谓词重写、视图重写、条件简化、连续消除和嵌套连接消除等。</mark></p> </li><li> <p><strong>第四步：优化物理查询</strong><br> 物理查询优化是在确定了逻辑查询优化之后，采用物理优化技术（比如索引等），通过技术代价模型对各种可能的访问路径进行估算，从而找到执行方式中代价最小的作为执行计划。<mark>在这个部分中，我们需要掌握的重点是对索引的创建和使用。</mark><br> 但索引不是万能的，我们需要根据实际情况来创建索引。SQL查询时需要对不同的数据表进行查询，因此在物理查询优化阶段也需要确定这些查询所采用的路径，具体的情况包括：<br> 1. <mark>单表扫描</mark>：对于单表扫描来说，我们可以全表扫描所有的数据，也可以局部扫描。<br> 2. <mark>两张表的连接</mark>：常用的连接方式包括了嵌套循环连接、HASH连接和合并连接。<br> 3. <mark>多张表的连接</mark>：多张数据表进行连接的时候，<mark>顺序</mark>很重要，因为不同的连接路径查询的效率不同，搜索空间也会不同。我们在进行多表连接的时候，搜索空间可能会达到<mark>很高的数据量级</mark>，巨大的搜索空间显然会占用更多的资源，因此我们需要通过调整连接顺序，将搜索空间调整在一个可接受的范围内。</p> </li><li> <p><strong>第五步：使用Redis或Memcached作为缓存</strong><br> 除了可以对SQL本身进行优化以外，我们还可以请外援提升查询的效率。<br> 因为数据都是存放到数据库中，我们需要从数据库层中取出数据放到内存中进行业务逻辑的操作。当用户量增大的时候，如果频繁的进行数据查询，会消耗数据库的很多资源。如果我们将常用的数据直接放到内存中，就会大幅提升查询的效率。<br> 键值存储数据库可以帮我们解决这个问题。<br> 常用的键值存储数据库有Redis和Memcached，它们都可以将数据库存放到内存中。<br> 从可靠性来说，<mark>Redis支持持久化</mark>，可以让我们的数据保存在硬盘上，不过这样一来性能消耗也会比较大。而Memcached仅仅是内存存储，不支持持久化。<br> 从支持的数据类型来说，Redis比Memcached更多，它不仅支持key-value类型的数据，还支持List、set、Hash等数据结构。当我们有持久化需求或更高级的数据处理需求的时候，就可以使用Redis，如果是简单的key-value存储，则可以使用Memcached。<br> ==通常我们对于查询响应要求高的场景（响应时间段，吞吐量大），可以考虑内存数据库，毕竟术业有专攻。==传统的RDBMS都是将数据存储在硬盘上，而内存数据库则存放在内存中，查询起来要快得多。不过使用不同的工具，也增加了开发人员的使用成本。</p> </li><li> <p><strong>第六步：库级优化</strong><br> 库级优化是站在数据库的维度上进行的优化策略，比如控制一个库中的数据表数量。另外，单一的数据库总会遇到各种限制，不如取长补短，利用“外援”的方式。通过<mark>主从架构</mark>优化我们的读写策略，通过对数据库进行垂直或者水平切分，突破单一数据库或数据表的访问限制，提升查询的性能。</p> <pre><code>  1. 读写分离（主从复制）
  2. 数据分片
</code></pre> </li></ul> 
<h2><a id="MySQL_66"></a>二、优化MySQL服务器</h2> 
<p>优化MySQL服务器主要从两个方面来优化，一方面是对<mark>硬件</mark>进行优化；另一方面是对MySQL<mark>服务参数</mark>进行优化。</p> 
<h3><a id="21__69"></a>2.1 优化服务器硬件</h3> 
<p>==服务器的硬件性能直接决定着MySQL数据库的性能。==硬件的性能瓶颈直接决定MySQL数据库的运行速度和效率。针对性能瓶颈提高硬件配置，可以提高MySQL数据库查询、更新的速度。</p> 
<ol><li>配置较大的内存</li><li>配置高速磁盘系统</li><li>合理分布磁盘I/O</li><li>配置更多处理器</li></ol> 
<h3><a id="22_MySQL_76"></a>2.2 优化MySQL的参数</h3> 
<p>通过优化MySQL的参数可以提高资源利用率，从而达到提高MySQL服务器性能的目的。<br> MySQL服务的配置参数都在my.cnf或者my.ini文件的[mysqld]组中。配置完参数以后，需要重新启动MySQL服务才会生效。</p> 
<ul><li> <p>innodb_buffer_pool_size：表和索引的最大缓存。</p> </li><li> <p>key_buffer_size：索引缓存区的大小，索引缓冲区是所有的<mark>线程共享</mark>。</p> </li><li> <p>table_cache：同时打开的表的个数</p> </li><li> <p>query_cache_size：查询缓冲区的大小</p> </li><li> <p>query_cache_type：0 关闭，1 开启。所有的查询都将使用查询缓存区。</p> </li><li> <p>sort_buffer_size：需要进行排序的线程分配的缓冲区的大小</p> </li><li> <p>join_buffer_size = 8M：联合查询操作所能使用的缓冲区大小</p> </li><li> <p>read_buffer_size：每个线程连续扫描时为扫描的每个表分配的缓冲区的大小（字节）</p> </li><li> <p>innodb_flush_log_at_trx_commit：何时将缓冲区的数据写入日志文件，并且将日志文件写入磁盘中。该参数对于innoDB引擎非常重要。取值有3个，分别为0、1、2等。默认值为1。</p> 
  <ul><li>值为0时，表示每秒1次的频率将数据写入日志文件并将日志文件写入磁盘。</li><li>值为1时，表示每次提交事务时将数据写入日志文件并将日志文件吸入磁盘进行同步。</li><li>值为2时，表示每次提交事务时将数据写入日志文件，每隔1秒将日志文件写入磁盘。</li></ul> </li><li> <p>innodb_log_buffer_size：InnoDB存储引擎的事务日志所使用的缓冲区</p> </li><li> <p>max_connections： 表示允许连接到MySQL数据库的最大数量，默认值是151。</p> </li><li> <p>back_log：用于控制MySQL监听TCP端口时设置的积压请求栈大小。</p> </li><li> <p>thread_cache_size：线程池缓存线程数量的大小。</p> </li><li> <p>wait_timeout：指定一个请求的最大连接时间</p> </li><li> <p>interactive_timeout：表示服务器在关闭连接前等待行动的秒数。</p> </li></ul> 
<h2><a id="_101"></a>三、优化数据库结构</h2> 
<p>一个好的<mark>数据库设计方案</mark>对于数据库的性能常常会起到事半功倍的效果。合理的数据库结构不仅可以使数据库占用更小的磁盘空间，而且能够使查询速度更快。数据库结构的设计需要考虑<mark>数据冗余、查询和更新的速度、字段的数据类型</mark>是否合理等多方面的内容。</p> 
<h3><a id="31__104"></a>3.1 拆分表：冷热数据分离</h3> 
<p>拆分表的思路是，把1个包含很多字段的表拆分成2个或者多个相对较小的表。这样做的原因是，这些表中某些字段的操作频率很高（<mark>热数据</mark>），经常要进行查询或者更新操作，而另外一些字段的使用频率却很低（<mark>冷数据</mark>），冷热数据分离，可减少表的宽度。如果放到一个表里面，每次查询都要读取大记录，会消耗较多的资源。</p> 
<p>MySQL限制每个表最多存储<mark>4096</mark>列，并且每一行数据的大小不能超过<mark>65535</mark>字节。表越宽，把表装载进内场缓冲池时所占用的内存也就越大，也会消耗更多的IO。</p> 
<p><mark><strong>冷热数据分离的目的是：</strong></mark></p> 
<ul><li>减少磁盘IO，保证热数据的内存缓存命中率。</li><li>更有效的利用缓存，避免读入无用的冷数据。</li></ul> 
<h3><a id="32__113"></a>3.2 增加中间表</h3> 
<p>对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，<mark>把需要经常联合查询的数据插入中间表中，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率。</mark></p> 
<p>首先，分析经常联合查询表中的字段，然后使用这些字段建立一个中间表，并将原来联合查询的表的数据插入中间表中；最后，使用中间表来进行查询。</p> 
<p><strong>如何同步数据呢？</strong></p> 
<ul><li>方式1：清空数据 -&gt;重新添加数据</li><li>方式2：使用视图</li></ul> 
<h3><a id="33__123"></a>3.3 增加冗余字段</h3> 
<p>设计数据库表时应尽量遵循范式理论的规约，尽可能减少冗余字段，让数据库设计看起来精致、优雅。但是，合理地加入冗余字段可以提高查询速度。</p> 
<p>表的规范化程度越高，表与表之间的关系就越多。需要连接查询的情况也就越多。尤其在数据量大而且需要频繁进行连接的时候，为了提升效率，我们也可以考虑增加冗余字段来减少连接。</p> 
<h3><a id="34__128"></a>3.4 优化数据类型</h3> 
<p><mark>优先选择符合存储需要的最小的数据类型。</mark></p> 
<p>列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的<mark>数量也就越少</mark>，在遍历时所需要的IO次数也就越多，索引的性能也就越差。</p> 
<ul><li> <p>对整数类型数据进行优化</p> </li><li> <p>既可以使用文本类型也可以使用整数类型的字段，要选择使用整数类型</p> </li><li> <p>避免使用TEXT、BLOB数据类型</p> </li><li> <p>避免使用ENUM类型</p> </li><li> <p>使用TIMESTAMP存储时间</p> </li><li> <p>用DECIMAL代替FLOAT和DOUBLE存储精确浮点数</p> 
  <ul><li>非精准浮点：float、double</li><li>精准浮点：decimal类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每4个字节可以存储9位数字，并且小数点要占用一个字节。可用于存储比bigint更大的整型数据。</li></ul> </li></ul> 
<p><strong>总之，遇到数据量大的项目时，一定要在充分了解需求的前提下，合理优化数据类型，这样才能充分发挥资源的效率，使系统达到最优。</strong></p> 
<h3><a id="35__144"></a>3.5 优化插入记录的速度</h3> 
<p>插入记录时，影响插入速度的主要是索引、唯一性校验、一次插入记录条数等。根据这些情况可以分别进行优化。分为MyISAM引擎和InnoDB存储引擎来说</p> 
<h4><a id="351_MyISAM_147"></a>3.5.1 MyISAM引擎的表</h4> 
<ul><li>禁用索引（插入记录之前禁用索引，数据插入完毕后再开启索引）,若对于空表批量导入数据，则不需要进行此操作，因为MyISAM引擎的表是在导入数据之后才建立索引。</li></ul> 
<pre><code class="prism language-sql"><span class="token comment"># 关闭索引</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name <span class="token keyword">DISABLE</span> <span class="token keyword">KEYS</span><span class="token punctuation">;</span>
<span class="token comment"># 重新开启索引</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name <span class="token keyword">ENABLE</span> <span class="token keyword">KEYS</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>禁用唯一性检查（插入记录之前禁用唯一性检查，插入完毕后再开启）</li></ul> 
<pre><code class="prism language-sql"><span class="token comment"># 禁用唯一性检查</span>
<span class="token keyword">SET</span> UNIQUE_CHECKS <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment"># 开启唯一性检查</span>
<span class="token keyword">SET</span> UNIQUE_CHECKS <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>使用批量插入</li><li>使用LOAD DATA INFILE批量插入</li></ul> 
<h4><a id="352_InnoDB_165"></a>3.5.2 InnoDB引擎的表</h4> 
<ul><li>禁用唯一性检查</li></ul> 
<pre><code class="prism language-sql"><span class="token comment"># 禁用唯一性检查</span>
<span class="token keyword">SET</span> UNIQUE_CHECKS <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment"># 开启唯一性检查</span>
<span class="token keyword">SET</span> UNIQUE_CHECKS <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>禁用外键检查（插入数据之前执行禁止对外键的检查，数据插入完成之后恢复对外键的检查）</li></ul> 
<pre><code class="prism language-sql"><span class="token comment">#禁用外键检查</span>
<span class="token keyword">SET</span> foreign_key_checks <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment">#恢复对外键的检查</span>
<span class="token keyword">SET</span> foreign_key_checks <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>禁止自动提交（插入之前禁止事务的自动提交，数据导入完成后再恢复自动提交）</li></ul> 
<pre><code class="prism language-sql"><span class="token comment">#禁止自动提交</span>
<span class="token keyword">SET</span> autocommit <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>
<span class="token comment"># 恢复自动提交</span>
<span class="token keyword">SET</span> autocommit <span class="token operator">=</span> <span class="token number">1</span>
</code></pre> 
<h3><a id="36__187"></a>3.6 使用非空约束</h3> 
<p><mark>在设计字段的时候，如果业务允许，建议尽量使用非空约束</mark></p> 
<ul><li>进行比较和计算的时候，省去对NULL值的字段判断是否为空的开销，提高存储效率。</li><li>非空字段也容易创建索引。因为索引NULL列需要额外的空间来保存，所以要占用更多的空间。使用非空约束，就可以节省存空间（每个字段1bit）</li></ul> 
<h3><a id="37__193"></a>3.7 分析表、检查表与优化表</h3> 
<p>MySQL提供了分析表、检查表和优化表的语句。<mark>分析表</mark>主要是分析关键字的分分布，<mark>检查表</mark>主要是检查表是否存在错误，<mark>优化表</mark>主要是消除删除或者更新造成的空间浪费。</p> 
<h4><a id="371__196"></a>3.7.1 分析表</h4> 
<pre><code class="prism language-sql"><span class="token comment"># ANALYZE TABLE 语句的基本语法如下：</span>
<span class="token keyword">ANALYZE</span> <span class="token punctuation">[</span><span class="token keyword">LOCAL</span> <span class="token operator">|</span> NO_WRITE_TO_BINLOG<span class="token punctuation">]</span> <span class="token keyword">TABLE</span> tbl_name <span class="token punctuation">[</span><span class="token punctuation">,</span>tbl_name<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre> 
<p>默认的，MySQL服务会将ANALYZE TABLE语句写到binlog中，以便从主从架构中，从服务能够同步数据。可以添加参数LOCAL或者NO_WRITE_TO_BINLOG取消语句写到binlog中。</p> 
<p>使用ANALYZE TABLE分析表的过程中，数据库系统会自动给表加一个<mark>只读锁</mark>。在分析期间，只能读取表中的记录，不能再更新和插入记录。ANALYZE TABLE能够分析InnoDB和MyISAM类型的表，但是不能作用于视图。</p> 
<p>ANALYZE TABLE分析后的统计结果会反应到<mark>cardinality</mark>的值，该值统计了表中某一键所在的列不重复值的个数。<mark>该值越接近表中的总行数，则在表连接查询或者索引查询时，就越优先被优化器选择使用。</mark></p> 
<p>也就是索引列的cardinality的值与表中数据的总条数差距越大，即使查询的时候使用了该索引作为查询条件，存储引擎实际查询的时候使用的概率就越小。</p> 
<p>cardinality可以通过 SHOW INDEX FROM 表名 查看。</p> 
<h4><a id="372__211"></a>3.7.2 检查表</h4> 
<p>CHECK TABLE 语句能够检查InnoDB和MyISAM类型的表是否存在错误。CHECK TABLE语句在执行过程中会给表加上<mark>只读锁</mark>.<br> <img src="https://images2.imgbox.com/30/2e/CqpQurpX_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="373__214"></a>3.7.3 优化表</h4> 
<ul><li>方式一：<strong>OPTIMIZE TABLE</strong><br> <img src="https://images2.imgbox.com/da/cc/86QhecU9_o.png" alt="在这里插入图片描述"><br> 在MyISAM中，是先分析这张表，然后会整理相关的MySQL datafile，之后回收未使用的空间。在InnoDB中，回收空间是简单通过Alter table进行整理空间。在优化期间，MySQL会创建一个临时表，优化完成之后会删除原始表，然后会将临时表rename成为原始表。</li></ul> 
<blockquote> 
 <p>说明：在多数的设置中，根本不需要运行OPTIMIZE TABLE。即使对可变长度的行进行了大量的更新，也不需要经常运行。<mark>每周一次</mark>或<mark>每月一次</mark>即可，并且只需要对<mark>特定的表</mark>运行。</p> 
</blockquote> 
<h3><a id="38__221"></a>3.8 小结</h3> 
<p>上述这些方法都是有利有弊的。比如：</p> 
<ul><li>修改数据类型，节省存储空间的同时，你要考虑到数据不能超过取值范围；</li><li>增加冗余字段的时候，不能忘了确保数据一致性。</li><li>把大表拆分，也意味着你的查询会增加新的连接，从而增加额外的开销和运维的成本。</li></ul> 
<p>因此，要结合实际的业务需求进行权衡。</p> 
<h2><a id="_231"></a>四、大表优化</h2> 
<p><strong>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</strong></p> 
<h3><a id="41__234"></a>4.1 限定查询的范围</h3> 
<p><mark>禁止不带任何限制数据范围条件的查询语句。</mark></p> 
<h3><a id="42__236"></a>4.2 读/写分离</h3> 
<ul><li>一主一从模式：<br> <img src="https://images2.imgbox.com/a9/81/KWxj0Sxu_o.png" alt="在这里插入图片描述"></li><li>双主双从模式<br> <img src="https://images2.imgbox.com/45/28/JVQPMo6o_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="43__241"></a>4.3 垂直拆分</h3> 
<p><strong>垂直拆分的优点：</strong> 可以使得列数据变小，在查询时减速读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。<br> <strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起JOIN操作。此外，垂直拆分会让事务变得更加复杂。</p> 
<h3><a id="44__244"></a>4.4 水平拆分</h3> 
<ul><li>尽量控制单表数据量的大小，建议控制在<mark>1000万以内</mark>。1000万并不是MySQL数据库的限制，过大会造成修改表结构、备份、恢复都会有很大的问题。此时可以用<mark>历史数据归档</mark>（应用于日志数据），<mark>水平分别</mark>（应用于业务数据）等手段来控制数据量的大小。</li><li>主要考虑业务数据的水平分表策略。将大的数据表按照<mark>某个属性维度</mark>分拆成不同的小表，每张小表保持相同的表结构。比如可以按照年份来划分，把不同年份的数据放到不同的数据表中。</li><li>水平分表仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有意义，所以<mark>水平拆分最好分库</mark>，从而达到分布式的目的。</li></ul> 
<p>水平拆分能够支持非常大的数据量存储，应用端改造也少，但<mark>分片事务难以解决，跨节点JOIN性能较差</mark>，逻辑复杂。**尽量不要对数据进行分片，因为拆分会带来逻辑，部署、运维的各种复杂度。**一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。<br> 数据库分片的常见方案：</p> 
<ul><li>客户端代理：分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。如 当当网的Sharding-JDBC和阿里的TDDL。</li><li>中间件代理：在应用和数据中间加一个代理层。分片逻辑统一维护在中间件服务中。如 Mycart，360的Atlas和网易的DDB。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/32b05afa274364783a6c188e65568bcb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【MySQL】聚合函数和GROUP BY</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d539b2122c72ff6905482abf80fd605d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL安装教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>