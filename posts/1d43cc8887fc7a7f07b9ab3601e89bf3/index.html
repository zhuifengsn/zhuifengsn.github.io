<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; #include &lt;algorithm&gt; - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43; #include &lt;algorithm&gt;" />
<meta property="og:description" content="标准模板库：算法
头文件&lt;algorithm&gt;定义了一组专门设计用于元素范围的函数集合。
范围是可以通过迭代器或指针访问的任何对象序列，例如数组或某些STL容器的实例。 但是请注意，算法通过迭代器直接对值进行操作，而不以任何方式影响任何可能容器的结构（它从不影响容器的大小或存储分配）。
参考手册：cplusplus.com
具体包括 1、非修改序列操作 2、修改序列的操作 3、分区操作 4、排序操作 5、二分查找操作 6、合并操作
7、堆操作 8、最大最小值操作 9、其它操作
这里列举几个常见操作：
1、reverse()
// reverse algorithm example #include &lt;iostream&gt; // std::cout #include &lt;algorithm&gt; // std::reverse #include &lt;vector&gt; // std::vector int main () { std::vector&lt;int&gt; myvector; // set some values: for (int i=1; i&lt;10; &#43;&#43;i) myvector.push_back(i); // 1 2 3 4 5 6 7 8 9 std::reverse(myvector.begin(),myvector.end()); // 9 8 7 6 5 4 3 2 1 // print out content: std::cout &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/1d43cc8887fc7a7f07b9ab3601e89bf3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-12-16T13:31:41+08:00" />
<meta property="article:modified_time" content="2019-12-16T13:31:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; #include &lt;algorithm&gt;</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>标准模板库：算法<br> 头文件&lt;algorithm&gt;定义了一组专门设计用于元素范围的函数集合。</p> 
<p>范围是可以通过迭代器或指针访问的任何对象序列，例如数组或某些STL容器的实例。 但是请注意，算法通过迭代器直接对值进行操作，而不以任何方式影响任何可能容器的结构（它从不影响容器的大小或存储分配）。</p> 
<p>参考手册：<a href="http://www.cplusplus.com/reference/algorithm/" rel="nofollow">cplusplus.com</a></p> 
<p>具体包括  1、非修改序列操作  2、修改序列的操作  3、分区操作  4、排序操作 5、二分查找操作  6、合并操作</p> 
<p>7、堆操作  8、最大最小值操作  9、其它操作</p> 
<p>这里列举几个常见操作：</p> 
<p>1、reverse()</p> 
<pre class="has"><code class="language-cpp">// reverse algorithm example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::reverse
#include &lt;vector&gt;       // std::vector

int main () {
  std::vector&lt;int&gt; myvector;

  // set some values:
  for (int i=1; i&lt;10; ++i) myvector.push_back(i);   // 1 2 3 4 5 6 7 8 9

  std::reverse(myvector.begin(),myvector.end());    // 9 8 7 6 5 4 3 2 1

  // print out content:
  std::cout &lt;&lt; "myvector contains:";
  for (std::vector&lt;int&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)
    std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}
</code></pre> 
<p><img alt="" class="has" height="493" src="https://images2.imgbox.com/99/2a/5h5bDZHc_o.png" width="747"></p> 
<p>2、next_permutation()，返回大于等于当前序列的全排列</p> 
<pre class="has"><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
int main(){
    int a[3]={1, 2, 3};
    printf("%d %d %d\n",a[0],a[1],a[2]);
    while(next_permutation(a,a+3)){
        printf("%d %d %d\n",a[0],a[1],a[2]);
    }
    return 0;
}
</code></pre> 
<p><img alt="" class="has" height="390" src="https://images2.imgbox.com/25/a4/Z7TuLaG4_o.png" width="551"></p> 
<p>如果将输入序列变成，3， 1,  2   ，那么最后全排列的结果就发生了变化</p> 
<p><img alt="" class="has" height="334" src="https://images2.imgbox.com/43/04/WyBbEs0z_o.png" width="556"></p> 
<p>3、sort()</p> 
<pre class="has"><code class="language-cpp">// sort algorithm example
#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::sort
#include &lt;vector&gt;       // std::vector

bool myfunction (int i,int j) { return (i&lt;j); }

struct myclass {
  bool operator() (int i,int j) { return (i&lt;j);}
} myobject;

int main () {
  int myints[] = {32,71,12,45,26,80,53,33};
  std::vector&lt;int&gt; myvector (myints, myints+8);               // 32 71 12 45 26 80 53 33

  // using default comparison (operator &lt;):
  std::sort (myvector.begin(), myvector.begin()+4);           //(12 32 45 71)26 80 53 33

  // using function as comp
  std::sort (myvector.begin()+4, myvector.end(), myfunction); // 12 32 45 71(26 33 53 80)

  // using object as comp
  std::sort (myvector.begin(), myvector.end(), myobject);     //(12 26 32 33 45 53 71 80)

  // print out content:
  std::cout &lt;&lt; "myvector contains:";
  for (std::vector&lt;int&gt;::iterator it=myvector.begin(); it!=myvector.end(); ++it)
    std::cout &lt;&lt; ' ' &lt;&lt; *it;
  std::cout &lt;&lt; '\n';

  return 0;
}</code></pre> 
<p><img alt="" class="has" height="634" src="https://images2.imgbox.com/d1/8d/mNtfygB6_o.png" width="750"></p> 
<p>为了展示sort的实际应用场景，这里再加一个案例。</p> 
<p>设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。</p> 
<p>通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。</p> 
<p>五名英雄信息如下：</p> 
<pre>		{"刘备",23,"男"},
		{"关羽",22,"男"},
		{"张飞",20,"男"},
		{"赵云",21,"男"},
		{"貂蝉",19,"女"},</pre> 
<p>首先定义Hero.h</p> 
<pre class="has"><code class="language-cpp">#pragma once
#ifndef HERO_TYPE_01_
#define HERO_TYPE_01_
#include &lt;string&gt;
#include &lt;iostream&gt;
struct Hero
{
	std::string name;
	int age;
	bool sex;
};

void sort_hero(Hero heros[], int len);

void print_hero_list(Hero heros[], int len);

#endif
</code></pre> 
<p>然后是Hero.cpp关于Hero.h的实现</p> 
<pre class="has"><code class="language-cpp"># include "hero.h"
# include &lt;algorithm&gt;
# include &lt;vector&gt;
bool myfunc(Hero HA, Hero HB)
{
	return HA.age &gt; HB.age;
}

void sort_hero(Hero heros[], int len)
{
	// 定义一个vector向量，将结构体的数据放入到vector,在algorithm的参数里面要求为Random-access iterators
	std::vector&lt;Hero&gt;vec_heros(heros, heros + len);
	// 通过内置算法进行排序
	std::sort(vec_heros.begin(), vec_heros.end(), myfunc);
	// 将排序的vector结果拷贝给heros数组
	for (size_t i = 0; i &lt; len; i++)
	{
		heros[i] = vec_heros[i];
	}
}

void print_hero_list(Hero heros[], int len)
{
	for (size_t i = 0; i &lt; len; i++)
	{
		std::cout &lt;&lt; "name=" &lt;&lt; heros[i].name &lt;&lt; " age=" &lt;&lt; heros[i].age &lt;&lt; " sex=" &lt;&lt; heros[i].sex &lt;&lt; std::endl;
	}
}</code></pre> 
<p>主函数</p> 
<pre class="has"><code class="language-cpp">#include &lt;iostream&gt;
#include "hero.h"
using namespace std;

int main()
{
	struct Hero heros[5] = {
		{ "刘备",23,"男" },
		{ "关羽",22,"男" },
		{ "张飞",20,"男" },
		{ "赵云",21,"男" },
		{ "貂蝉",19,"女" },
	};

	int len = sizeof(heros) / sizeof(Hero); //获取数组元素个数

	sort_hero(heros, len); //排序

	print_hero_list(heros, len); //打印

	system("pause");
	return 0;
}</code></pre> 
<p><img alt="" class="has" height="168" src="https://images2.imgbox.com/07/ec/Z9aWfGYv_o.png" width="666"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ea386d2ce0c6f5250dd73d647a2c5a0a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Caffe测试集分类结果相同，全部为最后一类</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c083ba40c271271cb3f2665168e3a748/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43; 空指针与野指针</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>