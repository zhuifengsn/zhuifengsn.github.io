<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>k8s部署spark集群 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="k8s部署spark集群" />
<meta property="og:description" content="1、构建打包镜像
打包镜像相关文件地址:链接：https://pan.baidu.com/s/1OoBuEVcCNjsYZKqBTCMWaw
提取码：ct16
进入目录，执行
docker build . -t wyx/spark:2.4.4
2、推送镜像到镜像仓库
进入harbor界面，项目-新建项目-新建wyxx项目
docker tag dc45b9403697 10.0.3.47:5000/wyx/spark:2.4.4
docker push 10.0.3.47:5000/wyx/spark:2.4.4
输出以下代表成功命令
基于kubernetes部署的两种方式
直接使用kubernetes作为集群管理器(Cluster Manager)，类似与mesos和yarn，使用方式可以看running-on-kubernetes。但是这个部署方式，一是还不成熟，不推荐在生产环境使用。第二是要求k8s版本大于1.6，但我这边版本1.5.1，线上在用，不太想升级，而spark只是想搭起来玩玩…
第二种方式是standalone的方式，即便是不用集群也能很方便的用sbin下的脚本来部署，不过使用k8s有几个好处，一个是提高机器使用率。这边的k8s集群大部分是在白天使用，晚上空闲，刚好能拿来跑数据。二是方便一键扩容，一键升级，能复用本身在k8s集群上做好的监控以及日志收集
以下内容主要依据github 上k8s example中spark的例子
https://github.com/kubernetes/examples/blob/master/staging/spark/README.md
1、namespace
为了方便管理，还是新建一个namespace，将所有的相关的都放在这个namespace下，方便资源管理。
apiVersion: v1
kind: Namespace
metadata:
name: “spark-cluster”
labels:
name: “spark-cluster”
kubectl create -f namespace-spark-cluster.yaml 新建一个名为spark-cluster的namespace。
2、构建spark-master-controller.yaml
kind: ReplicationController
apiVersion: v1
metadata:
name: spark-master-controller
spec:
replicas: 1
selector:
component: spark-master
template:
metadata:
labels:
component: spark-master
spec:
hostname: spark-master-hostname
subdomain: spark-master-headless
containers:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/e29941750a28ed198370b753bd5ff270/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-12T15:25:05+08:00" />
<meta property="article:modified_time" content="2022-08-12T15:25:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">k8s部署spark集群</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>1、构建打包镜像<br> <img src="https://images2.imgbox.com/33/e8/c3JifGHE_o.png" alt="在这里插入图片描述"><br> 打包镜像相关文件地址:链接：https://pan.baidu.com/s/1OoBuEVcCNjsYZKqBTCMWaw<br> 提取码：ct16<br> 进入目录，执行<br> docker build . -t wyx/spark:2.4.4<br> 2、推送镜像到镜像仓库<br> 进入harbor界面，项目-新建项目-新建wyxx项目<br> docker tag dc45b9403697 10.0.3.47:5000/wyx/spark:2.4.4<br> docker push 10.0.3.47:5000/wyx/spark:2.4.4<br> 输出以下代表成功命令</p> 
<p><img src="https://images2.imgbox.com/27/e1/GzdAF32T_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/7c/6f/tjawySYc_o.png" alt="在这里插入图片描述"></p> 
<p>基于kubernetes部署的两种方式<br> 直接使用kubernetes作为集群管理器(Cluster Manager)，类似与mesos和yarn，使用方式可以看running-on-kubernetes。但是这个部署方式，一是还不成熟，不推荐在生产环境使用。第二是要求k8s版本大于1.6，但我这边版本1.5.1，线上在用，不太想升级，而spark只是想搭起来玩玩…<br> 第二种方式是standalone的方式，即便是不用集群也能很方便的用sbin下的脚本来部署，不过使用k8s有几个好处，一个是提高机器使用率。这边的k8s集群大部分是在白天使用，晚上空闲，刚好能拿来跑数据。二是方便一键扩容，一键升级，能复用本身在k8s集群上做好的监控以及日志收集</p> 
<p>以下内容主要依据github 上k8s example中spark的例子<br> https://github.com/kubernetes/examples/blob/master/staging/spark/README.md<br> 1、namespace<br> 为了方便管理，还是新建一个namespace，将所有的相关的都放在这个namespace下，方便资源管理。<br> apiVersion: v1<br> kind: Namespace<br> metadata:<br> name: “spark-cluster”<br> labels:<br> name: “spark-cluster”<br> kubectl create -f namespace-spark-cluster.yaml 新建一个名为spark-cluster的namespace。<br> 2、构建spark-master-controller.yaml<br> kind: ReplicationController<br> apiVersion: v1<br> metadata:<br> name: spark-master-controller<br> spec:<br> replicas: 1<br> selector:<br> component: spark-master<br> template:<br> metadata:<br> labels:<br> component: spark-master<br> spec:<br> hostname: spark-master-hostname<br> subdomain: spark-master-headless<br> containers:</p> 
<ul><li>name: spark-master<br> image: registry.cn-hangzhou.aliyuncs.com/xujunkai/spark:2.4.4<br> imagePullPolicy: Always<br> command: [“/start-master”]<br> ports:</li><li>containerPort: 7077</li><li>containerPort: 8080<br> resources:<br> requests:<br> cpu: 100m</li></ul> 
<p>执行命令kubectl apply -f spark-master-controller.yaml --namespace=spark-cluster<br> 3、构建spark-master-service.yaml<br> kind: Service<br> apiVersion: v1<br> metadata:<br> name: spark-master<br> spec:<br> ports:</p> 
<ul><li>port: 7077<br> targetPort: 7077<br> name: spark</li><li>port: 8080<br> targetPort: 8080<br> name: http<br> selector:<br> component: spark-master<br> 执行命令：kubectl apply -f spark-master-service.yaml --namespace=spark-cluster<br> 一个service，把7077端口和8080端口暴露出来给集群，方便slaver直接用spk-master:8080这样的方式进行访问。注意，只是暴露给集群，外部访问的方式最后会说。<br> 4、构建spark-worker-controller.yaml<br> kind: ReplicationController<br> apiVersion: v1<br> metadata:<br> name: spark-worker-controller<br> spec:<br> replicas: 2<br> selector:<br> component: spark-worker<br> template:<br> metadata:<br> labels:<br> component: spark-worker<br> spec:<br> containers:</li><li>name: spark-worker<br> image: registry.cn-hangzhou.aliyuncs.com/xujunkai/spark:2.4.4<br> imagePullPolicy: Always<br> command: [“/start-worker”]<br> ports:</li><li>containerPort: 8081<br> resources:<br> requests:<br> cpu: 100m<br> 执行命令：kubectl create -f spark-worker-controller.yaml —namespace=spark-cluster<br> 启动worker脚本中需要传入master的地址，因为有dns且设置了service的缘故，可以通过spk-master.spark-cluster访问。把replicas设置为N即可启动N个worker。另外，我还在worker上加了资源的限制，限制最多使用2个cpu以及12g内存。</li></ul> 
<p>proxy<br> image为elsonrodriguez/spark-ui-proxy:1.0 这玩意在一般启动standalone集群的时候是没有的，但是在k8s集群里边，则必不可缺。<br> 设想一下，如果只是简单的暴露master的8080端口出来，我们只能看到master的管理页面，但是进一步从master访问worker的ui则变得不太现实（每个worker都有自己的ui地址，且ip分配很随机，这些ip只能在集群内部访问）。所以我们需要一个代理服务，从内部访问完我们需要的页面后，返回给我们，这样我们只需要暴露一个代理的地址即可。<br> 5、构建spark-ui-proxy-controller.yaml<br> kind: ReplicationController<br> apiVersion: v1<br> metadata:<br> name: spark-ui-proxy-controller<br> spec:<br> replicas: 1<br> selector:<br> component: spark-ui-proxy<br> template:<br> metadata:<br> labels:<br> component: spark-ui-proxy<br> spec:<br> containers:</p> 
<ul><li>name: spark-ui-proxy<br> image: elsonrodriguez/spark-ui-proxy:1.0<br> ports:</li><li>containerPort: 80<br> resources:<br> requests:<br> cpu: 100m<br> args:</li><li>spk-master:8080<br> livenessProbe:<br> httpGet:<br> path: /<br> port: 80<br> initialDelaySeconds: 120<br> timeoutSeconds: 5<br> 执行命令：kubectl create -f spark-ui-proxy-controller.yaml —namespace=spark-cluster<br> 6、构建spark-ui-proxy-service.yaml，暴露proxy的80端口<br> kind: Service<br> apiVersion: v1<br> metadata:<br> name: spark-ui-proxy<br> spec:<br> type: NodePort<br> ports:</li><li>port: 80<br> targetPort: 80<br> nodePort: 32180<br> selector:<br> component: spark-ui-proxy<br> 执行命令：kubectl create -f spark-ui-proxy-service.yaml —namespace=spark-cluster<br> 查看pod命令：kubectl get pods --all-namespaces 显示如下<br> <img src="https://images2.imgbox.com/62/b4/BN28WSSY_o.png" alt="在这里插入图片描述"></li></ul> 
<p>查看svc命令：kubectl get svc --all-namespaces 显示如下<br> <img src="https://images2.imgbox.com/03/c2/KBUA0dS4_o.png" alt="在这里插入图片描述"></p> 
<p>外部机器浏览器输入 http://ip:32180 显示如下<br> http://ip:32180/proxy:spark-master:8080<br> <img src="https://images2.imgbox.com/b8/28/SgbnyLYN_o.png" alt="在这里插入图片描述"></p> 
<p>参考文档：<br> https://www.cnblogs.com/xujunkai/p/14900417.html</p> 
<p>https://blog.csdn.net/lixinkuan328/article/details/104528182/</p> 
<p>https://github.com/kubernetes/examples/blob/master/staging/spark/README.md</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c23dc7c0a3887890116677108c0ab499/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c&#43;&#43;运算符优先级归纳</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/36ae8fc135cb9e2b6bb88c54ed4ef7f4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">1.单例模式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>