<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据库基础——9.聚合函数 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据库基础——9.聚合函数" />
<meta property="og:description" content="这篇文章来讲一下数据库中的聚合函数
目录
1. 聚合函数介绍
1.1 AVG和SUM函数
1.2 MIN和MAX函数 1.3 COUNT函数 2. GROUP BY
2.1 基本使用
2.2 使用多个列分组 2.3 GROUP BY中使用WITH ROLLUP 3. HAVING
3.1 基本使用
3.2 WHERE和HAVING的对比 4. SELECT的执行过程
4.1 查询的结构
4.2 SELECT执行顺序
4.3 SQL 的执行原理 我们上一章讲到了 SQL 单行函数。实际上 SQL 函数还有一类，叫做聚合（或聚集、分组）函数，它是对 一组数据进行汇总的函数，输入的是一组数据的集合，输出的是单个值。
1. 聚合函数介绍 什么是聚合函数？ 聚合函数作用于一组数据，并对一组数据返回一个值。
聚合函数类型： AVG() SUM() MAX() MIN() COUNT() 聚合函数语法：
注意：聚合函数不能嵌套调用。比如不能出现类似“AVG(SUM(字段名称))”形式的调用。 1.1 AVG和SUM函数 可以对数值型数据使用AVG（求均值）和 SUM（求和）函数。
例：SELECT AVG(salary), MAX(salary),MIN(salary), SUM(salary) FROM employees WHERE job_id LIKE &#39;%REP%&#39;;
1.2 MIN和MAX函数 可以对任意数据类型的数据使用 MIN（最小值）和 MAX（最大值）函数。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/a6f3b121eaf6aea31144cc8ae17dbfba/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-29T18:01:20+08:00" />
<meta property="article:modified_time" content="2023-05-29T18:01:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据库基础——9.聚合函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>这篇文章来讲一下数据库中的聚合函数</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%20%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#1.%20%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D" rel="nofollow">1. 聚合函数介绍</a></p> 
<p id="1.1%20AVG%E5%92%8CSUM%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#1.1%20AVG%E5%92%8CSUM%E5%87%BD%E6%95%B0" rel="nofollow">1.1 AVG和SUM函数</a></p> 
<p id="1.2%20MIN%E5%92%8CMAX%E5%87%BD%E6%95%B0%C2%A0-toc" style="margin-left:40px;"><a href="#1.2%20MIN%E5%92%8CMAX%E5%87%BD%E6%95%B0%C2%A0" rel="nofollow">1.2 MIN和MAX函数 </a></p> 
<p id="1.3%20COUNT%E5%87%BD%E6%95%B0%C2%A0-toc" style="margin-left:40px;"><a href="#1.3%20COUNT%E5%87%BD%E6%95%B0%C2%A0" rel="nofollow">1.3 COUNT函数 </a></p> 
<p id="2.%20GROUP%20BY-toc" style="margin-left:0px;"><a href="#2.%20GROUP%20BY" rel="nofollow">2. GROUP BY</a></p> 
<p id="2.1%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#2.1%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8" rel="nofollow">2.1 基本使用</a></p> 
<p id="2.2%20%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%88%97%E5%88%86%E7%BB%84%C2%A0-toc" style="margin-left:40px;"><a href="#2.2%20%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%88%97%E5%88%86%E7%BB%84%C2%A0" rel="nofollow">2.2 使用多个列分组 </a></p> 
<p id="2.3%20GROUP%20BY%E4%B8%AD%E4%BD%BF%E7%94%A8WITH%20ROLLUP%C2%A0-toc" style="margin-left:40px;"><a href="#2.3%20GROUP%20BY%E4%B8%AD%E4%BD%BF%E7%94%A8WITH%20ROLLUP%C2%A0" rel="nofollow">2.3 GROUP BY中使用WITH ROLLUP </a></p> 
<p id="3.%20HAVING-toc" style="margin-left:0px;"><a href="#3.%20HAVING" rel="nofollow">3. HAVING</a></p> 
<p id="3.1%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#3.1%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8" rel="nofollow">3.1 基本使用</a></p> 
<p id="3.2%20WHERE%E5%92%8CHAVING%E7%9A%84%E5%AF%B9%E6%AF%94%C2%A0-toc" style="margin-left:40px;"><a href="#3.2%20WHERE%E5%92%8CHAVING%E7%9A%84%E5%AF%B9%E6%AF%94%C2%A0" rel="nofollow">3.2 WHERE和HAVING的对比 </a></p> 
<p id="4.%20SELECT%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-toc" style="margin-left:0px;"><a href="#4.%20SELECT%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B" rel="nofollow">4. SELECT的执行过程</a></p> 
<p id="4.1%20%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#4.1%20%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%BB%93%E6%9E%84" rel="nofollow">4.1 查询的结构</a></p> 
<p id="4.2%20SELECT%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-toc" style="margin-left:40px;"><a href="#4.2%20SELECT%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F" rel="nofollow">4.2 SELECT执行顺序</a></p> 
<p id="4.3%20SQL%20%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%C2%A0-toc" style="margin-left:40px;"><a href="#4.3%20SQL%20%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%C2%A0" rel="nofollow">4.3 SQL 的执行原理 </a></p> 
<hr id="hr-toc"> 
<p></p> 
<p>我们上一章讲到了 SQL 单行函数。实际上 SQL 函数还有一类，叫做聚合（或聚集、分组）函数，它是对 一组数据进行汇总的函数，输入的是一组数据的集合，输出的是单个值。</p> 
<h2 id="1.%20%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D">1. 聚合函数介绍</h2> 
<p><span style="color:#fe2c24;"><strong>什么是聚合函数？ </strong></span>聚合函数作用于一组数据，并对一组数据返回一个值。</p> 
<p><img alt="" height="451" src="https://images2.imgbox.com/89/3d/kJGv8o0u_o.png" width="757"></p> 
<p><span style="color:#fe2c24;"><strong>聚合函数类型：</strong></span> AVG()   SUM()   MAX()   MIN()   COUNT() </p> 
<p>聚合函数语法：<img alt="" height="216" src="https://images2.imgbox.com/96/dc/aZEcv7Vx_o.png" width="781"></p> 
<p><span style="color:#fe2c24;"><strong>注意：</strong></span>聚合函数不能嵌套调用。比如不能出现类似“AVG(SUM(字段名称))”形式的调用。 </p> 
<h3 id="1.1%20AVG%E5%92%8CSUM%E5%87%BD%E6%95%B0">1.1 AVG和SUM函数</h3> 
<p>可以对数值型数据使用AVG（求均值）和 SUM（求和）函数。</p> 
<p><span style="color:#fe2c24;"><strong>例：</strong></span>SELECT AVG(salary), MAX(salary),MIN(salary), SUM(salary) FROM employees WHERE job_id LIKE '%REP%';</p> 
<p><img alt="" height="216" src="https://images2.imgbox.com/c1/d4/rzGDEnP2_o.png" width="949"></p> 
<h3 id="1.2%20MIN%E5%92%8CMAX%E5%87%BD%E6%95%B0%C2%A0">1.2 MIN和MAX函数 </h3> 
<p>可以对任意数据类型的数据使用 MIN（最小值）和 MAX（最大值）函数。</p> 
<p><span style="color:#fe2c24;"><strong>例：</strong></span>SELECT MIN(hire_date), MAX(hire_date) FROM employees;</p> 
<p><img alt="" height="165" src="https://images2.imgbox.com/3c/0f/o0q1zy00_o.png" width="1022"></p> 
<h3 id="1.3%20COUNT%E5%87%BD%E6%95%B0%C2%A0">1.3 COUNT函数 </h3> 
<p>COUNT(*)返回表中记录总数，适用于任意数据类型。</p> 
<p><span style="color:#fe2c24;"><strong>例：</strong></span>SELECT COUNT(*) FROM employees WHERE department_id = 50;</p> 
<p><img alt="" height="170" src="https://images2.imgbox.com/83/8d/ePhvc6ts_o.png" width="671"></p> 
<p>COUNT(expr) 返回expr不为空的记录总数</p> 
<p><span style="color:#fe2c24;"><strong>例：</strong></span>SELECT COUNT(commission_pct) FROM employees WHERE department_id = 50;</p> 
<p> <img alt="" height="189" src="https://images2.imgbox.com/a7/ee/CMWSMwlV_o.png" width="584"></p> 
<p><span style="color:#fe2c24;"><strong>问题：用count(*)，count(1)，count(列名)谁好呢?</strong></span></p> 
<p>其实，对于MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。 Innodb引擎的表用count(*),count(1)直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但好 于具体的count(列名)。 </p> 
<p><span style="color:#fe2c24;"><strong>问题：能不能使用count(列名)替换count(*)?</strong></span></p> 
<p>不要使用 count(列名)来替代 count(*) ， count(*) 是 SQL92 定义的标准统计行数的语法，跟数 据库无关，跟 NULL 和非 NULL 无关。</p> 
<p><strong>说明：</strong>count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</p> 
<h2 id="2.%20GROUP%20BY">2. GROUP BY</h2> 
<h3 id="2.1%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">2.1 基本使用</h3> 
<p><img alt="" height="485" src="https://images2.imgbox.com/d1/fb/IbVauKfX_o.png" width="793"></p> 
<p>可以使用GROUP BY子句将表中的数据分成若干组</p> 
<p><span style="color:#fe2c24;"><strong>例：</strong></span>SELECT column, group_function(column) FROM table [WHERE condition] [GROUP BY group_by_expression] [ORDER BY column];</p> 
<p><span style="color:#fe2c24;"><strong>明确：</strong></span>WHERE一定放在FROM后面</p> 
<p>在SELECT列表中所有未包含在组函数中的列都应该包含在 GROUP BY子句中</p> 
<p><span style="color:#fe2c24;"><strong>例：</strong></span>SELECT department_id, AVG(salary) FROM employees GROUP BY department_id</p> 
<p><img alt="" height="450" src="https://images2.imgbox.com/aa/99/stiXa5Yu_o.png" width="836"></p> 
<p> 包含在 GROUP BY 子句中的列不必包含在SELECT 列表中</p> 
<p><span style="color:#fe2c24;"><strong>例：</strong></span>SELECT AVG(salary) FROM employees GROUP BY department_id</p> 
<p><img alt="" height="453" src="https://images2.imgbox.com/0e/51/JnPFFJf4_o.png" width="794"></p> 
<h3 id="2.2%20%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%88%97%E5%88%86%E7%BB%84%C2%A0">2.2 使用多个列分组 </h3> 
<p><img alt="" height="462" src="https://images2.imgbox.com/ff/d9/7dgo3Qqr_o.png" width="797"></p> 
<p><span style="color:#fe2c24;"><strong>例：</strong></span>SELECT department_id dept_id, job_id, SUM(salary) FROM employees GROUP BY department_id, job_id </p> 
<p><img alt="" height="474" src="https://images2.imgbox.com/1f/34/H59GE7SB_o.png" width="866"></p> 
<h3 id="2.3%20GROUP%20BY%E4%B8%AD%E4%BD%BF%E7%94%A8WITH%20ROLLUP%C2%A0">2.3 GROUP BY中使用WITH ROLLUP </h3> 
<p>使用 WITH ROLLUP 关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所 有记录的总和，即统计记录数量。</p> 
<p><span style="color:#fe2c24;"><strong>例：</strong></span>SELECT department_id,AVG(salary) FROM employees WHERE department_id &gt; 80 GROUP BY department_id WITH ROLLUP;</p> 
<p><img alt="" height="256" src="https://images2.imgbox.com/5c/85/0DpQOV3e_o.png" width="638"></p> 
<p><strong>注意： </strong>当使用ROLLUP时，不能同时使用ORDER BY子句进行结果排序，即ROLLUP和ORDER BY是互相排斥的。 </p> 
<h2 id="3.%20HAVING">3. HAVING</h2> 
<h3 id="3.1%20%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">3.1 基本使用</h3> 
<p><img alt="" height="449" src="https://images2.imgbox.com/ef/63/FAWX9xoe_o.png" width="833"></p> 
<p><strong>过滤分组：</strong>HAVING子句</p> 
<ol><li>行已经被分组。</li><li>使用了聚合函数。</li><li>满足HAVING 子句中条件的分组将被显示。</li><li>HAVING 不能单独使用，必须要跟 GROUP BY 一起使用。 </li></ol> 
<p><img alt="" height="235" src="https://images2.imgbox.com/04/68/mFLWuDfC_o.png" width="791"></p> 
<p><span style="color:#fe2c24;"><strong>例： </strong></span>SELECT department_id, MAX(salary) FROM employees GROUP BY department_id HAVING MAX(salary)&gt;10000 ;</p> 
<p><img alt="" height="301" src="https://images2.imgbox.com/08/26/TYQKKcdk_o.png" width="689"></p> 
<p><strong>非法使用聚合函数 ：</strong> 不能在 WHERE 子句中使用聚合函数。</p> 
<p>如下： <img alt="" height="263" src="https://images2.imgbox.com/14/0c/687MMM2w_o.png" width="744"></p> 
<h3 id="3.2%20WHERE%E5%92%8CHAVING%E7%9A%84%E5%AF%B9%E6%AF%94%C2%A0">3.2 WHERE和HAVING的对比 </h3> 
<p><span style="color:#b95514;"><strong>区别1：WHERE 可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件； HAVING 必须要与 GROUP BY 配合使用，可以把分组计算的函数和分组字段作为筛选条件。</strong></span></p> 
<p>这决定了，在需要对数据进行分组统计的时候，HAVING 可以完成 WHERE 不能完成的任务。这是因为， 在查询语法结构中，WHERE 在 GROUP BY 之前，所以无法对分组结果进行筛选。HAVING 在 GROUP BY 之 后，可以使用分组字段和分组中的计算函数，对分组的结果集进行筛选，这个功能是 WHERE 无法完成 的。另外，WHERE排除的记录不再包括在分组中。</p> 
<p><span style="color:#b95514;"><strong>区别2：如果需要通过连接从关联表中获取需要的数据，WHERE 是先筛选后连接，而 HAVING 是先连接 后筛选。</strong></span></p> 
<p>这一点，就决定了在关联查询中，WHERE 比 HAVING 更高效。因为 WHERE 可以先筛选，用一 个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也比较高。HAVING 则需要 先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用 的资源就比较多，执行效率也较低。</p> 
<p><span style="color:#fe2c24;"><strong>小结：</strong></span></p> 
<p><img alt="" height="163" src="https://images2.imgbox.com/3d/c3/7Vu5y5Nm_o.png" width="792"></p> 
<p><strong>开发中的选择：</strong></p> 
<p>WHERE 和 HAVING 也不是互相排斥的，我们可以在一个查询里面同时使用 WHERE 和 HAVING。包含分组 统计函数的条件用 HAVING，普通条件用 WHERE。这样，我们就既利用了 WHERE 条件的高效快速，又发 挥了 HAVING 可以使用包含分组统计函数的查询条件的优点。当数据量特别大的时候，运行效率会有很 大的差别。 </p> 
<h2 id="4.%20SELECT%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B">4. SELECT的执行过程</h2> 
<h3 id="4.1%20%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%BB%93%E6%9E%84">4.1 查询的结构</h3> 
<blockquote> 
 <p>#方式1：</p> 
 <p>SELECT ... , .... , ...</p> 
 <p>FROM ... , ... , ....</p> 
 <p>WHERE    多表的连接条件</p> 
 <p>AND    不包含组函数的过滤条件</p> 
 <p>GROUP BY ... , ...</p> 
 <p>HAVING    包含组函数的过滤条件</p> 
 <p>ORDER BY ...</p> 
 <p>ASC/DESC LIMIT ... , ...</p> 
 <p></p> 
 <p></p> 
 <p>#方式2： </p> 
 <p>SELECT ... , .... , ...</p> 
 <p>FROM ...</p> 
 <p>JOIN ... ON    多表的连接条件</p> 
 <p>JOIN ... ON ... </p> 
 <p>WHERE    不包含组函数的过滤条件</p> 
 <p>AND/OR    不包含组函数的过滤条件</p> 
 <p>GROUP BY ... , ...</p> 
 <p>HAVING    包含组函数的过滤条件</p> 
 <p>ORDER BY ...</p> 
 <p>ASC/DESC LIMIT ... , ...</p> 
 <p></p> 
 <p>#其中：</p> 
 <p>#（1）from：从哪些表中筛选</p> 
 <p>#（2）on：关联多表查询时，去除笛卡尔积</p> 
 <p>#（3）where：从表中筛选的条件</p> 
 <p>#（4）group by：分组依据</p> 
 <p>#（5）having：在统计结果中再次筛选</p> 
 <p>#（6）order by：排序</p> 
 <p>#（7）limit：分页</p> 
</blockquote> 
<h3 id="4.2%20SELECT%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F">4.2 SELECT执行顺序</h3> 
<p>你需要记住 SELECT 查询时的两个顺序：</p> 
<p><span style="color:#fe2c24;"><strong>1. 关键字的顺序是不能颠倒的：</strong></span></p> 
<blockquote> 
 <p>SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT...</p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>2.SELECT 语句的执行顺序</strong></span>（在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同）：</p> 
<blockquote> 
 <p>FROM  --&gt;  WHERE  --&gt;  GROUP BY  --&gt;  HAVING  --&gt;  SELECT 的字段  --&gt;  DISTINCT</p> 
 <p>--&gt; ORDER BY  --&gt;  LIMIT</p> 
</blockquote> 
<p><img alt="" height="448" src="https://images2.imgbox.com/59/5f/hc2qV8zH_o.png" width="579"></p> 
<p>比如你写了一个 SQL 语句，那么它的关键字顺序和执行顺序是下面这样的：</p> 
<p><img alt="" height="185" src="https://images2.imgbox.com/a8/d5/u4FSs9mq_o.png" width="741"> </p> 
<p>在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个 虚拟表 ，然后将这个虚拟表传入下一个步 骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的。</p> 
<h3 id="4.3%20SQL%20%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%C2%A0">4.3 SQL 的执行原理 </h3> 
<p>SELECT 是先执行 FROM 这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：</p> 
<ul><li>首先先通过 CROSS JOIN 求笛卡尔积，相当于得到虚拟表 vt（virtual table）1-1；</li><li>通过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2；</li><li>添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟 表 vt1-2 的基础上增加外部行，得到虚拟表 vt1-3。</li></ul> 
<p>当然如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得 到是我们的原始数据。</p> 
<p>当我们拿到了查询数据表的原始数据，也就是最终的虚拟表 <span style="color:#b95514;"><strong>vt1</strong></span> ，就可以在此基础上再进行 <span style="color:#b95514;"><strong>WHERE 阶 段 </strong></span>。在这个阶段中，会根据 <span style="color:#b95514;"><strong>vt1 表</strong></span>的结果进行筛选过滤，得到虚拟表<span style="color:#b95514;"><strong> vt2</strong></span> 。 </p> 
<p>然后进入第三步和第四步，也就是<span style="color:#b95514;"><strong> GROUP 和 HAVING 阶段</strong></span> 。在这个阶段中，实际上是在<span style="color:#b95514;"><strong>虚拟表 vt2</strong></span> 的 基础上进行分组和分组过滤，得到中间的<span style="color:#b95514;"><strong>虚拟表 vt3 和 vt4</strong></span> 。</p> 
<p>当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到 <span style="color:#b95514;"><strong>SELECT 和 DISTINCT 阶段</strong></span> 。</p> 
<p>首先在 <span style="color:#b95514;"><strong>SELECT 阶段</strong></span>会提取想要的字段，然后在 <span style="color:#b95514;"><strong>DISTINCT 阶段</strong></span>过滤掉重复的行，分别得到中间的<span style="color:#b95514;"><strong>虚拟表 vt5-1 和 vt5-2 </strong></span>。</p> 
<p>当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是 <span style="color:#b95514;"><strong>ORDER BY 阶段 </strong></span>，得到<span style="color:#b95514;"><strong> 虚拟表 vt6</strong></span> 。</p> 
<p>最后在<span style="color:#b95514;"><strong> vt6</strong></span> 的基础上，取出指定行的记录，也就是 <span style="color:#b95514;"><strong>LIMIT 阶段 </strong></span>，得到最终的结果，对应的是<span style="color:#b95514;"><strong>虚拟表 vt7</strong></span> 。</p> 
<p>当然我们在写<span style="color:#b95514;"><strong> SELECT 语句</strong></span>的时候，不一定存在所有的关键字，相应的阶段就会省略。</p> 
<p>同时因为 SQL 是一门类似英语的结构化查询语言，所以我们在写 SELECT 语句的时候，还要注意相应的 关键字顺序，<span style="color:#fe2c24;"><strong>所谓底层运行的原理，就是我们刚才讲到的执行顺序。</strong></span></p> 
<p></p> 
<p><span style="color:#0d0016;">MySQL的聚合函数比较重要，需要掌握</span></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6e11831d57029eb001e2c1138beeac88/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">css制作的漂亮的3D产品展示卡片</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/178b185d7ca2ac01a74dc81152b16092/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">今天面了个字节跳动拿35K出来的测试，真是砂纸擦屁股，给我露了一手啊</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>