<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6daae7ecf1cc036e88175268c0a23a9/" rel="bookmark">
			进行跨域数据传输时，看看500强企业都在使用什么方案？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大型企业在全国或全球设立不同的分支机构已变得非常普遍，对于500强企业来说，除了总部外，还会在多地设立分公司、分公司下甚至会设立办事处，同时，会在一些特殊地区设立研发中心、数据中心及工厂等。这就导致企业的组织结构不管在横向还是纵向都进一步延伸。组织结构的扩大，是业务开展的必然结果，在设立多个组织单位后，各地区的组织并不是互相割裂独立的，相反，为了业务更便捷地开展、消息更及时地同步和传达，各地区组织间的数据交往仍较为频繁。
对于这样跨地理区域、跨组织域及跨网络域的文件交换，我们统称为跨域数据传输，那么，通常企业是如何实现跨域数据传输的呢？
1、一般企业通过互联网进行数据交换；对于军工、银行等特殊单位，一般会搭建专线来进行总分支文件交换
2、在传输工具上，主要包括邮件、网盘、FTP应用、IM通讯工具、自建数传系统等
企业在这个过程也会遇到阻碍和挑战，一般包括以下方面：
管理层面：
未建立统一的总分支跨区域文件交换平台，不利于管理
IT人员维护成本较高，当存在国内外多个分支机构时，分别架设系统，整体经济成本较高
有些公司同级之间不允许直接交换数据或特定数据，有些因为网络部署原因，同级之间交换数据需经由总部过渡，因此，同级之间数据交换需能灵活控制方向和策略
数据安全层面：
申请一般在OA系统，也可能线下申请，审批、传输过程是间断的，且经由不同系统，导致整个流程缓慢，有时间厌恶，还会存在数据安全隐患
内容安检通过人工或DLP，人工会导致安检漏洞、性价比低；DLP与传输系统未做集成，不连贯，效率低
传输日志是中断的、不完整的，不利于审计；FTP传输无法追溯原文件
涉及居民个人信息的敏感数据从总部发送至分支机构，被分支机构用户下载到终端使用，存在 “非必要不落地”的违规风险（特定行业要求分支仅有数据使用权，不可下载到本地）
数据传输层面：
专线需要同时供业务数据即时传输，因此需要有限速功能，避免某一项任务占据过多带宽而影响业务开展
大文件、海量文件传输困境：无法传输，需切割传输，传输易出错、中断、丢包等问题
当总部往下级下发同一文件，多地下级同时下载时，网络可能崩溃
那么，上述问题该如何解决呢？来看看500强企业是如何进行跨域数据传输的。
飞驰云联Ftrans CDS跨域文件交换集中管控系统，帮助企业构建统一、安全、高效的跨域文件交换通道，实现可控、可靠、便捷的企业总分支数据流转，在保障数据安全性的同时，有效提升业务效率，帮助企业降本增效。
Ftrans CDS跨域文件交换集中管控系统帮助企业实现统一、高效、智能的跨域文件交换管理；“系统-传输节点”的部署模式，有效降低企业建设门槛和成本，优化了企业在跨域数据交换管控上的人力、运维、时间投入，使整体呈现事半功倍的效果。
Ftrans CDS跨域文件交换集中管控系统具有多重跨域数据交换安全管控策略，实现对企业跨域数据交换的主客体、交换过程、交换内容的整体性管控，进而保障跨域数据交换是合规的、安全的、可控的，避免重要数据泄露，保护数据资产。
关于飞驰云联
飞驰云联是中国领先的数据安全传输解决方案提供商，长期专注于安全可控、性能卓越的数据传输技术和解决方案，公司产品和方案覆盖了跨网跨区域的数据安全交换、供应链数据安全传输、数据传输过程的防泄漏、FTP的增强和国产化替代、文件传输自动化和传输集成等各种数据传输场景。飞驰云联主要服务于集成电路半导体、先进制造、高科技、金融、政府机构等行业的中大型客户，现有客户超过500家，其中500强和上市企业150余家，覆盖终端用户超过40万，每年通过飞驰云联平台进行数据传输和保护的文件量达到4.4亿个。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/754ec5b32573f3ab658e35c9372eccc3/" rel="bookmark">
			软件设计师软考题目解析06 --每日五题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想说的话：要准备软考了。0.0，其实我是不想考的，但是吧，由于本人已经学完所有知识了，只是被学校的课程给锁在那里了，不然早找工作去了。寻思着反正也无聊，就考个证玩玩。
本人github地址：nanshaws (cover) (github.com)
各位想学习的，可以在上面联系我。 目录
题一
题二
题三
题四
题五
总结
题一 设系统中有R类资源m个，现有n个进程互斥使用。若每个进程对R资源的最大需求为w，那么当m、n、w取下表的值时，对于下表中的a~e五种情况，（）两种情况可能会发生死锁。对于这两种情况，若将（/）,则不会发生死锁。
A a和b
B b和c
C c和d
D c和e
答：选D，情况a：m=2，n=1，w=2,系统中有2个资源，1个进程使用，该进程最多要求两个资源，所以不会发生死锁。情况b：m=2，n=2，w=1，系统中有两个资源，2个进程使用，每个进程最多要求一个资源，所以不会发生死锁。情况c：m=2，n=2，w=2，系统中有两个资源，2个进程使用，每个进程最多要求两个资源，当每个进程都占一个的时候，就死锁了，互相等待。所以c可能会死锁，情况d，即使三个线程，一人占一个，那还有一个可以分配给其中三个，即可以解除这个锁。e，e就不用看了，明显死锁😎，学java的做错这道题的人，速速给我点赞
题二 以下关于中断方式与DMA方式的叙述中，正确的是（）
A 中断方式与DMA方式都可实现外设与CPU之间的并行工作
B 程序中断方式和DMA方式在数据传输过程中都不需要CPU的干预
C 采用DMA方式传输数据的速度比程序中断方式的速度慢
D 程序中断方式和DMA方式都不需要CPU保护现场
答：当然各位要是不明白DMA是什么的话，我可以讲解一下
DMA，即直接存储器访问（Direct Memory Access），是一种高效的数据传输技术。它允许某些硬件子系统在不需要CPU参与的情况下直接读写系统内存。
DMA的主要优势在于它能够减轻CPU的负担，提高整体系统的数据传输效率。以下是对DMA的一些详细说明：
工作原理：DMA控制器（DMAC）负责管理数据的直接传输。当外设需要与内存进行数据交换时，DMAC会接管总线控制权，直接在外设和内存之间传输数据，无需CPU介入。传输方式：DMA可以执行多种数据传输操作，包括从外设到内存、从内存到外设、以及内存到内存的传输。特征：DMA传输通常比通过CPU进行的数据传输要快得多，因为它减少了CPU的干预和上下文切换的时间开销。配置与使用：在使用DMA时，需要对DMAC进行适当的配置，包括设置传输的数据量、源地址和目标地址等参数。一旦配置完成，DMAC就可以自动完成数据传输任务。资源与中断：在某些微控制器或处理器中，如STM32系列，DMA通道与中断紧密相关，可以在数据传输完成后触发中断，以便CPU进行后续处理。 总的来说，DMA是一种优化计算机系统性能的重要技术，特别是在需要高速数据传输和处理的场景中，如图像处理、音频播放和网络通信等。通过减少CPU的直接参与，DMA不仅提高了数据传输速度，还释放了CPU资源，使其能够处理其他任务。下面我们看一下选题：
A. 中断方式与DMA方式都可实现外设与CPU之间的并行工作
这个说法是正确的。中断方式可以让CPU在处理外设请求的同时，继续执行其他任务，实现了外设与CPU的并行工作。 B. 程序中断方式和DMA方式在数据传输过程中都不需要CPU的干预
这个说法是不正确的。在中断方式中，CPU需要介入处理中断请求；而在DMA方式中，CPU会启动数据传输，但在数据传输过程中可以继续执行其他任务。 C. 采用DMA方式传输数据的速度比程序中断方式的速度慢
这个说法是不正确的。DMA方式通常比中断方式速度更快，因为DMA直接控制数据传输，减少了CPU的介入和上下文切换时间。 D. 程序中断方式和DMA方式都不需要CPU保护现场
这个说法是不正确的。在中断方式和DMA方式中，CPU都需要保护现场。在中断处理过程中，CPU会保存当前执行任务的状态，然后执行中断处理程序；在DMA方式中，CPU也会在启动DMA传输前保存当前状态。 题三 若用256k*8bit的存储器芯片，构成地址40000000H到400FFFFFH且按字节编址的内存区域，则需（）片芯片。
A 4
B 8
C 16
D 32
答：
若用256k*8bit的存储器芯片，构成地址40000000H到400FFFFFH且按字节编址的内存区域，则需4片芯片。
解析如下：
地址范围计算：首先需要计算所需内存区域的总字节数。给出的地址范围是从40000000H到400FFFFFH，所以需要计算这个范围内包含的字节数。由于地址是16进制的，我们可以通过减法运算得到范围内的字节数：400FFFFFH - 40000000H + 1 = 1000000H（16进制），转换为10进制就是16777216字节。单片存储器容量：每片存储器的容量是256k*8bit，即256 * 1024 * 8位。因为1字节等于8位，所以该存储器也可以表示为256 * 1024字节。所需芯片数量：将所需的内存区域总字节数除以单片存储器的字节数得到所需的芯片数量：16777216 / (256 * 1024) = 64（片）。但是，题目中给出的选项没有64，可能是题目有误或者理解有误。根据常规的理解，如果使用256K×8bit的存储器芯片构建内存，那么每片芯片可以提供256K字节的存储空间。因此，我们需要计算整个地址范围内有多少个256K字节。换算单位：在进行计算之前，需要注意单位的转换。地址是以字节为单位给出的，而存储器芯片的容量是以位（bit）为单位给出的。由于1字节等于8位，所以在计算时需要将芯片的容量转换为字节。正确计算：正确的计算方法是将地址范围内的总位数转换为字节，然后除以单片存储器的字节数。具体计算如下： (400FFFFFH−40000000H+1)×8textbit/(256×8×1024 bit)=4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/754ec5b32573f3ab658e35c9372eccc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf1e781cf97be29d5d797e5947efe66c/" rel="bookmark">
			WPF 【十月的寒流】学习笔记(2):MVVM中是怎么实现通知的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言相关链接代码仓库项目配置代码初始代码ViewPersonViewModel 尝试老办法通知解决方案ObservableCollectionBindingListICollectionView 总结 前言 我们这次详细了解一下列表通知的底层是怎么实现的
相关链接 十月的寒流
MVVM实战技巧之：可被观测的集合（ObservableCollection &amp; BindingList）
代码仓库 我为了方便展示源代码，我将代码提交到了代码仓库里面
B站【十月的寒流】对应课程的代码 Github仓库
项目配置 如何使用我这里就不展开说明了
WPF CommunityToolkit.Mvvm
WPF CommunityToolkit.Mvvm Messenger通讯
WPF-UI HandyControl 简单介绍
WPF-UI HandyControl 控件简单实战+IconPacks矢量图导入
Bogus，.NET生成批量模拟数据
代码 初始代码 View &lt;UserControl.DataContext&gt; &lt;viewModels:DemoViewModel /&gt; &lt;/UserControl.DataContext&gt; &lt;DockPanel&gt; &lt;StackPanel DockPanel.Dock="Bottom"&gt; &lt;Button Command="{Binding AddItemCommand}" Content="添加数据"&gt;&lt;/Button&gt; &lt;/StackPanel&gt; &lt;DataGrid ItemsSource="{Binding People}"&gt;&lt;/DataGrid&gt; &lt;/DockPanel&gt; Person public class Person { public int Id { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public string FullName { get; set; } public DateOnly BirthDay { get; set; } public static Person FakerOne =&gt; faker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf1e781cf97be29d5d797e5947efe66c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/667e1b17201ab6023d9f81a9984c199c/" rel="bookmark">
			rabbitmq知识梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.WorkQueues模型 Work queues，任务模型。简单来说就是让多个消费者绑定到一个队列，共同消费队列中的消息。
当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。
此时就可以使用work 模型，多个消费者共同处理消息处理，消息处理的速度就能大大提高了。
接下来，我们就来模拟这样的场景。
首先，我们在控制台创建一个新的队列，命名为work.queue：
1.消息发送 这次我们循环发送，模拟大量消息堆积现象。
在publisher服务中的SpringAmqpTest类中添加一个测试方法：
/** * workQueue * 向队列中不停发送消息，模拟消息堆积。 */ @Test public void testWorkQueue() throws InterruptedException { // 队列名称 String queueName = "work.queue"; // 消息 String message = "hello, message_"; for (int i = 0; i &lt; 50; i++) { // 发送消息，每20毫秒发送一次，相当于每秒发送50条消息 rabbitTemplate.convertAndSend(queueName, message + i); Thread.sleep(20); } } 2.消息接收 要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：
@RabbitListener(queues = "work.queue") public void listenWorkQueue1(String msg) throws InterruptedException { System.out.println("消费者1接收到消息：【" + msg + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/667e1b17201ab6023d9f81a9984c199c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4813eaecbc795f33a055a76a8d22bc57/" rel="bookmark">
			计算机网络 数据链路层课后题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.以太网帧有哪些不同的封装格式？他们有何区别和应用场景？ 以太网II封装（Ethernet II）：以太网II封装是最常用的以太网封装格式，也被称为DIX封装。它在数据链路层首部使用6个字节的目的MAC地址和6个字节的源MAC地址，接着是2个字节的类型字段，表示上层协议的类型（如IPv4、ARP等）。以太网II封装适用于大多数局域网和广域网的数据传输，支持多种上层协议。IEEE 802.3封装：IEEE 802.3封装是以太网的标准封装格式，也称为以太网标准帧。与以太网II封装相比，IEEE 802.3封装在数据链路层首部使用的是2个字节的目的MAC地址和2个字节的源MAC地址，之后是2个字节的长度字段（表示数据字段的长度），接着是最小46个字节的数据负载和4个字节的帧校验序列。IEEE 802.3封装适用于数据传输速达到10 Mbps的以太网。原始太网封装（Raw Ethernet）：原始以太网封装在数据链路层的首部只包含目的MAC地址和源MAC地址，没有类型字段（或称为长度字段）。这种封装格式通常用于在网络中直接发送或接收特定的协议数据，例如在网络安全和网络监控等应用中，可以使用原始以太网封装来传输特定协议的数据。 2.为什么以太网有一个最小帧长和最大帧长 ​ 以太网规定最小帧长为64字节，即512比特 数据字长最小46字节
​ 以太网的最小帧长确保了主机在帧发送完成之前就检测到该帧的发送过程是否遭遇了碰撞，凡是长度小于64字节的帧都是由于碰撞而异常终止的无效帧
​ 为了防止主机长时间占用总线，以太网的帧也不能太长
3.数据链路层使用PPP协议或CSMA/CD协议时，既然不能保证可靠传输，为什么要对所传输的帧进行差错检测 提前发现错误：差错检测机制可以在接收端提前检测到传输过程中引入的错误。尽管无法进行纠错，但能够及时发现错误并通知发送端，以触发相应的重传机制或其他错误处理措施。
错误通知和丢弃：接收端通过差错检测能够判断接收到的帧是否出现了错误，通过错误通知可以提示发送端重新发送或采取其他纠错措施。同时，检测到错误的帧还可以被丢弃，避免传递到上层协议，保持上层协议的数据完整性。
误诊断和排错：差错检测机制可以提供有关错误发生的信息，以帮助排查网络故障和错误的来源。通过对帧的诊断，可以确定故障影响的范围，进一步采取相应的纠正措施。
适应不可靠传输环境：尽管PPP协议或CS/CD协议不能提供可靠传输，但错检测机制仍然能够在不可靠的传输环境中起到一定的作用。通过不断进行差错检测，可以减少传输中的错误率，提高数据传输的可靠性和稳定性。
4.以太帧中的目的MAC地址和源MAC地址分别在局域网中的哪些环节起到重要作用？ ​ 数据链路层：以太帧的目的MAC地址和源MAC地址是数据链路层的重要组成部分。在数据链路层，通过目的MAC地址，接方可以识别出帧的目标设备，并将帧转发给正确的接收方。源MAC地址则用于标识帧的发送方。
​ 交换机：交换机是局网中重要的网络备，用于转发以太网帧。交换机根据目的MAC地址来决定将帧传输到哪个端口。通过学习的MAC地址和对应的端口关联，交换机可以实现帧的有针对性转发，提高局域网的传输效率。
​ 网络分段：在局域网中，根据源MAC地址和目的MAC地址进行网络分段是常见的网络管理技术。通过指定源MAC地址和目的MAC地址的组合，管理员可以将不同的设备划分到不同的虚拟局域网（VLAN）中，实现物理隔离和逻辑分割，增加网络安全性和管理灵活性。
5.广播和泛洪的区别是 ​
目的性：广播是将数据发送到网络中的所有主机或设备，无论是否需要接收该数据。而泛洪是将数据发送到网络中的所有直接相邻的主机或设备，即发送给所有已知邻居。路由选择：广播不需要选择特定的路径，数据会通过网络中的所有链接传播。而泛洪则需要依靠网络中已知的邻居列表来决定数据传输的路径，通常采用分组转发的方式。控制机制：广播使用广播地址将数据传输到所有主机，不需要进行额外的控制机制。而泛洪需要使用一些机制来避免数据陷入无限循环，例如设置一个时间限制或通过序号等方式避免数据重复传输。效率和安全性：广播在大型网络中可能会导致网络拥塞和资源浪费，因为所有主机都会接收到该广播数据。而泛洪只将数据发送给已知的邻居，因此可以减少网络资源的消耗。但同时，泛洪也可能存在安全性问题，可能导致网络中的恶意主机接收到不应该传递的数据。 6.如果交换表中不存在目标MAC地址的条目，交换机会采取怎样的行为？ ​ 交换机会采取泛洪，交换机会将该数据帧转发到除了收到这个数据帧的接口之外的所有接口上。
7.交换机如何处理广播和组播数据帧？它们是如何被转发到适当的目标端口的？ ​
广播数据帧： 当交换机收到广播数据帧时，它会将该数据帧复制并转发到所有与其连接的端口（除了接收到该广播数据的端口）。这样做可以确保广播数据帧能够到达网络中的所有主机。广播数据帧不需要交换机查询交换表即可进行广播，因为广播数据帧的目标MAC地址为全1，所以交换机会直接将广播数据帧转发到所有端口。 组播数据帧： 当交换机收到组播数据帧时，它需要查询交换表以确定目标组播MAC地址对应的端口。交换机会将组播数据帧复并转发到所有已知的属于目标组播组的端口上。交换机根据交换表中的信息将组播数据帧发送到组播组成员所在的端口上，以便目标组中的所有主机都能接收到该组播数据帧。为了确定目标组播组的端口，交换机会参考诸如Internet组播协议（如IGMP）等协议，这些协议用于管理组组成员和组播组的关系。 ​
8.交换机的多端口间同时传输是指什么？ ​ 交换机的多端口间同时传输是指交换机可以同时从多个端口接收数据帧，并且在相同的时间内，通过匹配数据帧的目标MAC地址和交换表的信息，将数据帧转发到适当的目标端口。
具体来说，当交换机收到一个数据帧时，它会根据数据帧中的目标MAC地址，查询交换表以确定该目标MAC地址对应的端口。然后，交换机会将帧仅转发到目标MAC地址对应的端口，而不是广播到所有端口。这种并发处理的能力使得交换机能够在同时接收和处理多个端口的数据帧。
多端口间的同时传输是交换机的核心功能之一，它提高了网络的效率和吞吐量。通过避免冲突和碰撞，交换机能够提供更高的数据转发速度和更好的网络性能，同时减少网络中的数据传输延迟。这样，在局域网中流动的数据能够以高速、精确和可靠的方式被交换机处理和转发到目标设备。
9.什么因素可以限制冲突域的大小 （两个节点同时发生数据会产生冲突的 网络范围就是冲突域）
物理距离 较长的物理距离信号传输的延迟比较大可能导致设备发送的帧不能及时到达整个网络
帧的传输速率 当帧在传输介质上的传输速率较高时，冲突域的大小相对较小。这是因为快速传输可以更快地将帧从发送设备传输到接收设备，减少了突的可能性。
网络拓扑 网络拓扑是指网络中设备之间理连接的结构。某些网络拓扑可以限制冲突域的大小。例如，在星型拓扑中，每个设备都直接连接到中央集线器或交换机，从而将冲突隔离在特定的设备之间。
冲突检测机制 网络中的冲突检测机制可以帮助限制冲突域的大小。当设备检测到冲突时，它们会发送冲突信号，以停止当前的传输。这帮助确保帧在较小的范围内发生冲突，减少了整个网络中冲突的影响范围
网络规模 当网络中的设备数量增加时，冲突的可能性也会增加因此，网络规模较小的情况下冲突域可能相对较。
10.交换表的容量有上限吗，如果有抵达上限后收到的帧应该怎么处理，因此产生的数据丢弃应该怎么解决 ​ 交换表的容量是有上限的。每个交换机的交换表有一定的最大容量，其中记录了MAC地址与对应端口的映射关系。当交换表的容量达到上限时，新的数据帧无法被添加到交换表中，这种情况称为交换表溢出。
当交换表发生溢出时，交换机会采取以下方式来处理收到的帧:
动态地址学习：交换机会尝试学习新的MAC地址，并更新交换表中的条目。如果收到的帧是来自先前未知的MAC地址的，交换机会将其添加到交换表中，然后根据需要转发。基于老化的机制：了清理交换表中未使用的MAC地址条目，交换机会使用老机制。该机制通过定期检查交换表中的条目，并删除一段时间内未被使用的条目，以释放空间供新的MAC地址进入交换表。 尽管交换机采取了这些处理方式，但如果交换表容量严重不足，仍然可能导致数据丢失。为了解决数据丢失的问题，可以考虑以下方法：
增加交换机的容量：升级交换机或选择支持更大交换表的设备，以便能够容纳更多的MAC地址。使用更高性能的交换机：高性能交换机通常配备更大的交换表，并具备更优异的处理能力，可以更好地处理大量的数据帧。划分虚拟局域网（VLAN）：通过划分不同的VLAN，可以将网络中的设备划分为多个逻辑上隔离的区域，以减少每个交换表中的条目数量。层次化网络设计：通过构建层次化的网络结构，可以将交换机分布在不同层级的网络中，从而减少每个交换机的工作负载，减缓交换表容量的压力。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca39872257f502ec6f8fff185f5537bb/" rel="bookmark">
			开启数字内容创作的新时代
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
技术解析
未来展望
技术解析 Sora是一款由OpenAI开发的先进AI视频模型，其技术架构基于深度学习和自然语言处理技术。该模型的核心算法原理包括使用深度神经网络进行视频内容的理解、生成和互动。
在技术架构方面，Sora采用了一种混合的神经网络结构，结合了卷积神经网络（CNN）和循环神经网络（RNN）。CNN用于视频帧的特征提取和分析，能够有效捕捉视频中的空间信息；而RNN则用于对视频序列的建模，从而理解视频的时间动态特征。这种结合使得Sora能够对视频内容进行更加全面和深入的理解。
在算法原理方面，Sora利用了深度学习中的生成对抗网络（GAN）和注意力机制（Attention Mechanism）。通过GAN，Sora可以生成逼真且富有创意的视频内容，从而实现视频内容的智能生成。而通过注意力机制，Sora可以对视频中的重要信息进行关注，从而实现更加精准的内容生成和互动。
在实现过程中，Sora还结合了自然语言处理技术，通过文本理解和生成模型，使得用户可以通过自然语言与Sora进行交互。这种结合使得Sora能够实现更加智能和自然的人机交互，为用户提供更加个性化和高效的使用体验。
总体而言，Sora作为首个AI视频模型，通过深度学习和自然语言处理技术的结合，实现了对视频内容的智能生成和互动，为视频创作和消费带来了全新的体验和可能性。
随着人工智能技术的快速发展，AI视频模型正逐渐改变着数字内容创作的方式。在这个领域，OpenAI的Sora无疑是引领者之一，其强大的智能生成和互动功能正在重新定义着创作者们的创作方式，预示着一个更加个性化、高效和创新的未来。
未来展望 首先，Sora将为创作者们带来更大的创作自由度。传统的数字内容创作往往受限于技术水平和时间成本，但是有了Sora这样强大的AI视频模型，创作者们将能够更轻松地实现他们的创意想法。通过Sora提供的智能生成功能，创作者们可以快速生成各种高质量的视频内容，而不再受制于传统的制作流程和资源限制。这将极大地激发创作者们的创作潜力，推动数字内容创作的多样化和创新。
其次，Sora将为用户带来更加个性化和沉浸式的观影体验。传统的视频内容往往是静态的，观众们只能被动地接受内容，缺乏互动性和个性化。然而，有了Sora这样的AI视频模型，观众们将能够参与到内容创作的过程中，与视频内容进行更加直接和互动的交流。Sora提供的智能生成和互动功能，使得视频内容能够根据观众的反馈和偏好实时调整，为他们提供更加个性化和沉浸式的观影体验。这将极大地提升用户的满意度和忠诚度，推动视频内容消费的进一步发展。
最后，Sora将为数字内容创作带来更加高效和可持续的发展。传统的内容创作往往需要大量的人力和物力投入，而且往往效率低下，不够灵活和可持续。然而，有了Sora这样的AI视频模型，创作者们将能够更加高效地进行内容创作，节约时间和成本，提高生产效率。而且，由于Sora能够实现智能生成和互动，创作者们还能够更加灵活地应对市场需求和用户反馈，保持内容的新鲜和吸引力。这将为数字内容创作带来更加可持续的发展，促进整个行业的繁荣和进步。
综上所述，Sora作为首个AI视频模型，将为数字内容创作带来革命性的变革。它将为创作者们带来更大的创作自由度，为用户带来更加个性化和沉浸式的观影体验，同时也将推动数字内容创作的高效和可持续发展。相信在Sora的带领下，数字内容创作将迎来一个全新的时代，呈现出更加多样化、创新化和可持续化的发展趋势
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70c48c2b41b950c3f5633b7eb5aa4287/" rel="bookmark">
			【Vue】组件通信组件通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📝个人主页：五敷有你 🔥系列专栏：JVM
⛺️稳中求进，晒太阳
组件通信 组件通信，就是指组件与组件之间的数据传递
组件的数据是独立的，无法直接访问其他组件的数据想用其他组件的数据--&gt;组件通信 组件关系： 父子关系 props和$emit prop定义：组件上定义的属性prop作用：向子组件传递数据特点： 可以传递任何数量的prop可以传递任何类型的propprops的校验 为组件的prop指定验证要求，不符合要求，控制台就会有错误显示语法：类型校验非空校验默认值自定义校验 //类型校验 props:{ 检验的属性名：类型 } //全 props:{ 校验的属性名:{ type：类型， require:true, default:"默认值", validator(value){ //自定义校验逻辑 return 是否通过校验 } } } 父传子 子传父 非父子关系 provide和injecteventbus通用解决方案：Vuex（适合复杂业务场景） 小黑记事本（组件化版） App.vue &lt;template&gt; &lt;div id="app"&gt; &lt;div class="main"&gt; &lt;TodoHeader @addItem="add" &gt;&lt;/TodoHeader&gt; &lt;TodoMain :list="list" @deleteItem="del"&gt;&lt;/TodoMain&gt; &lt;TodoFooter :totalNum="totalNum" @clearItem="clear"&gt;&lt;/TodoFooter&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import TodoHeader from './components/TodoHeader.vue'; import TodoMain from './components/TodoMain.vue'; import TodoFooter from './components/TodoFooter.vue'; export default { name: 'App', components: { TodoHeader, TodoMain, TodoFooter }, data(){ return { list:JSON.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70c48c2b41b950c3f5633b7eb5aa4287/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91518add9b46e78e53ff2bcc24666597/" rel="bookmark">
			使用EFCore连接SQLite
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 在使用EFCore连接SQLite之前我们先来了解一下SQLite
SQLite是一个轻量级、自包含、无服务器、零配置的事务性SQL数据库引擎，它支持SQL92标准的大多数查询语言并兼容ACID事务。具体如下：
轻量级：SQLite非常轻巧，它的库体积小，资源占用低，特别适合于嵌入式设备和移动应用，有时仅需几百KB的内存即可运行。自包含：作为一个自给自足的数据库，SQLite不需要单独的服务器进程或操作系统进行管理。它通过直接访问磁盘文件进行数据存储。无服务器：由于SQLite不需要运行服务器，因此简化了安装和管理过程，也降低了系统开销。零配置：SQLite无需任何配置文件即可运行，使得它在简单性和易用性方面具有很大优势。事务性：它支持事务（Transaction），即一系列操作要么完全成功，要么完全失败，这保证了数据的完整性。兼容性：SQLite支持大部分SQL92标准，这意味着许多基于标准的SQL查询和命令都可以在SQLite上无缝运行。跨平台：它可以在多种操作系统和平台上运行，包括Windows、Linux、Mac OS等。多语言接口：SQLite提供了多种编程语言的API，如C、C++、Python、Java等，方便不同语言开发者使用。开源：SQLite是开源软件，可以免费用于任何目的，包括商业用途。 安装Nuget包 新建一个.netCore的控制台项目
我们在项目的Nuget包管理器控制台中安装Microsoft.EntityFrameworkCore.Sqlite
NuGet\Install-Package Microsoft.EntityFrameworkCore.Sqlite -Version 8.0.2 创建数据库 打开我们的数据库可视化管理工具Navicat，新建连接，选择SQLite
连接名随便取一个，类型选SQLite3，数据库文件选择放在我们刚刚创建的控制台项目下
创建一个Users表，待会测试用
数据库上下文 在项目中创建一个Users表的实体类和上下文类MyContext，如下图，刚刚创建的数据库文件与program类处于同一级
Users类 public class users { public int Id { get; set; } public string Name { get; set; } } 上下文 MyContext 数据库连接字符串：Data Source=data.db 定义一个名为 Users 的公共虚拟属性，它的类型是 DbSet&lt;users&gt;。DbSet&lt;TEntity&gt; 是 EF Core 中的一个泛型类，表示数据库中的一个表。在这里，它表示 users 表。
virtual 关键字允许 EF Core 在内部使用延迟加载来加载相关数据。
public class MyContext : DbContext { protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { optionsBuilder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91518add9b46e78e53ff2bcc24666597/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fb2a336c50bcb600935e12479804f67/" rel="bookmark">
			Android java基础_异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.异常的概念 在Java中，异常（Exception）是指程序执行过程中可能出现的不正常情况或错误。它是一个事件，它会干扰程序的正常执行流程，并可能导致程序出现错误或崩溃。
异常在Java中是以对象的形式表示的，这些对象是从java.lang.Throwable类或其子类派生而来。Throwable是异常类层次结构的根类，它有两个主要的子类：java.lang.Exception和java.lang.Error。
Exception（异常）：java.lang.Exception是表示可检查异常的基类。可检查异常是指在编译时需要显式处理的异常。Exception类及其子类用于表示程序运行过程中可能出现的外部条件、错误或其他可恢复的情况。例如，文件未找到、网络连接中断、输入格式错误等。开发人员需要通过捕获或声明这些异常来确保在程序中进行适当的异常处理。
Error（错误）：java.lang.Error是表示严重问题或系统级错误的基类。错误是指那些程序通常无法处理或恢复的情况，例如内存溢出、堆栈溢出、虚拟机错误等。与异常不同，错误不需要在程序中显式处理，因为它们通常表示了无法解决的问题。
异常在Java中通过抛出（throw）和捕获（catch）的方式进行处理。当程序执行到可能引发异常的代码时，可以使用throw语句手动抛出异常对象。然后，可以使用try-catch语句块来捕获异常，并在catch块中提供相应的异常处理逻辑。在catch块中，可以根据异常的类型执行适当的操作，如日志记录、错误报告或异常处理。如果异常没有在当前方法中被捕获处理，它将继续向上级调用栈传播，直到找到合适的异常处理代码或导致程序终止。
二.未进行异常处理 未进行异常处理的程序：
/* java Div 6 2 * 6/2=3 */ public class Div { public static void main(String args[]) { int m = Integer.parseInt(args[0]); int n = Integer.parseInt(args[1]); System.out.println("Begin of div"); int r = div(m, n); System.out.println("End of div"); System.out.println(m+"/"+n+"="+r); } public static int div(int m, int n) { int r = m / n; return r; } } 没有进行异常处理，编译运行结果： 程序退出
root@ubuntu:/home/topeet/guyilian# javac Div.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fb2a336c50bcb600935e12479804f67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b8a240193322f67182f254224579339/" rel="bookmark">
			14：00面试，14：05就出来了，问的问题有点变态。。。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下午两点，我准时走进了面试的会议室，心中既有期待也有紧张。然而，仅仅五分钟后，我便走出了会议室，心中充满了困惑和挫败感。面试官的问题确实出乎我的预料，它们既深入又具体，让我有些措手不及。
“你能解释一下如何在模块请求从http迁移到https的过程中制定测试方案吗？”面试官的话音刚落，我便开始急速思考。我知道https与http的主要区别在于安全性，但在具体的迁移和测试过程中，我应该如何考虑和行动呢？
面试结束后，我反思了自己的表现，意识到自己在某些领域的知识储备还远远不够。这次面试不仅仅是一次简单的测试，更是一次自我认知的机会。它让我看到了自己的不足，也激发了我进一步学习和提升自己的动力。
感觉好简单的题，硬是没有答出来，早知道好好看看一大佬软件测试面试宝典了。
通过大数据总结发现，其实软件测试岗的面试都是差不多的。常问的有下面这几块知识点：
第一部分，测试理论（测试基础+需求分析+测试模型+测试计划+测试策略+测试案例等等）
第二部分，Linux（ Linux基础+Linux练习题）
第三部分，MySQL（基础知识+查询练习+万年学生表经典面试题汇总+数据库企业真题）
第四部分，Web测试
第五部分，API测试
第六部分，App测试
第七部分，管理工具
第八部分，Python基础（Python基础+编程题+集合+函数+Python特性等等）
第九部分，Selenium相关
第十部分，性能测试
第十一部分，LordRunner相关
第十二部分，计算机网络
第十三部分，组成原理
第十四部分，数据结构与算法
第十五部分，逻辑题
第十六部分，人力资源
软件测试基础
软件测试的步骤是什么?
如何录制测试脚本?
应该考虑进行如何测试的测试方法
怎样估计测试工作量?
测试设计的问题
当测试过程发生错误时，有哪几种解决办法?
测试执行的问题
测试评估的目标
如何提高测试?
C/S模式的优点和缺点
B/S模式的优点和缺点
…
Linux
grep和find的区别? grep 都有哪些用法?
查看IP地址?
创建和删除一个多级目录?
在当前用户家目录中查找haha.txt文件?
如何查询出tomcat的进程并杀掉这个进程，写出linux命令?
动态查看日志文件?
查看系統硬盘空间的命令?
查看当前机器listen 的所有端口?
…
Python
统计python源代码文件中代码行数，去除注释，空行，进行输出?
python调用cmd并返回结果?
冒泡排序
1,2,3,4 这4个数字，能组成多少个互不相同的且无重复的三位数，都是多少?
请用 python 打印出 10000 以内的对称数（对称数特点：数字左右对称，如：1,2,11,121,1221 等）
给定一个整数 N，和一个 0-9 的数 K，要求返回 0-N 中数字 K 出现的次数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b8a240193322f67182f254224579339/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50892673fdb71e4a7a985345017a2bef/" rel="bookmark">
			WPF 【十月的寒流】学习笔记(1):DataGrid过滤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 相关链接代码仓库前言环境DataGrid 数据筛选项目配置使用原理主要代码（详细代码可以看我的GitHub仓库）Models.PersonDataGirdViewDataGridViewModel 实现效果 DataGrid直接绑定CollectionViewxamlViewModel 总结 相关链接 十月的寒流
在 WPF 中制作 DataGrid 的数据筛选功能
WPF 中如何制作 DataGrid 的分页功能
代码仓库 我为了方便展示源代码，我将代码提交到了代码仓库里面
B站【十月的寒流】对应课程的代码 Github仓库
前言 为了深入的重新学习WPF的基础知识，打算从【B站：十月的寒流】这位大佬上面去学习WPF的相关的知识。我其实更推荐大家去看原视频的相关教程内容。
环境 visual studio 2022.net core 8.0windows11 DataGrid 数据筛选 项目配置 如何使用我这里就不展开说明了
WPF CommunityToolkit.Mvvm
WPF CommunityToolkit.Mvvm Messenger通讯
WPF-UI HandyControl 简单介绍
WPF-UI HandyControl 控件简单实战+IconPacks矢量图导入
Bogus，.NET生成批量模拟数据
使用原理 WPF DataGrid 数据过滤
ICollectionView让MVVM更简单
微软官方文档|ICollectionView 接口
这里不得不提到微软的WPF文档了，写了和没写差不多。
实现原理就是微软为了方便对数据进行分组、排序和筛选。给ItemSorce添加了ICollectionView 专门用于干这个。然后我们可以对ICollectionView添加规则，Ture就是需要，False就是不需要。
主要代码（详细代码可以看我的GitHub仓库） Models.Person public class Person { public int Id { get; set; } public string FullName { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public DateTime BirthDay { get; set; } } DataGirdView &lt;UserControl x:Class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50892673fdb71e4a7a985345017a2bef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1df200e6b9c95ea7a17b4fea1b907282/" rel="bookmark">
			c语言经典例题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里我会将和c语言有关的题目分享给大家 题目来源很多 大家也可以去自行参考 我只是将自己的一些理解写下来 参考菜鸟教程，力扣，牛客等 这里会持续更新的
我们刚刚的c语言刚刚结束 我们来通过简单到一般的难度来巩固一下 1 输出hello_word! #include &lt;stdio.h&gt; int main() { printf("hello_world!"); return 0; } 2 输出整数 #include &lt;stdio.h&gt; int main() { int a; printf("请输入一个整数\n"); scanf("%d",&amp;a); printf("您输入的整数是:%d\n",a); return 0; } 3输出单个字符 #include &lt;stdio.h&gt; int main() { char a; printf("请输入一个字符\n"); scanf("%c",&amp;a); //如果这里我们使用的格式匹配符是%d 将输出字符对应的ASCLL码 printf("您输入的字符是:%d\n",a); return 0; } 4
4输出浮点数 #include &lt;stdio.h&gt; int main() { float a; printf("请输入一个浮点数\n"); scanf("%f",&amp;a); printf("a=%.2f\n",a);//保存小数点后俩位 return 0; } 5输出双精度数 #include &lt;stdio.h&gt; int main() { double d; // 声明双精度变量 d = 12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1df200e6b9c95ea7a17b4fea1b907282/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f983eef755a91174155e43e1f9a795d2/" rel="bookmark">
			ConvNeXt V2：用MAE训练CNN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文名称：ConvNeXt V2: Co-designing and Scaling ConvNets with Masked Autoencoders
发表时间：CVPR2023
code链接：代码
作者及组织: Sanghyun Woo，Shoubhik Debnath来自KAIST和Meta AI。
前言 ConvNextV2是借助MAE的思想来训练ConvnextV1。关于ConvnextV1可参考：
A ConvNet for the 2020s
1、Fully Convolutional Masked Autoencoder 本文借助MAE的思想，设计了一套基于CNN的自监督学习网络结构。
如上图所示，首先随机mask住2D图像的patch区域，为了防止Conv在训练过程中“看到“被遮挡区域的信息，于是Encoder部分采用了Sparse Conv(简单来说就是仅卷有像素值的区域)；而Decoder则是一层Convnext Block；最终类似SIMMIM，仅用MSE Loss计算被遮挡部分的损失函数。
这里值得注意一个点：在Pretraining Stage用SparseCNN，在Finetuning Stage又将SparseCNN转变成常规卷积。
最终取得实验结果：发现还是比不上有监督训练。
2、Global Response Normalization（GRN） 在上节中，发现FCMAE效果还是差点儿，于是作者可视化特征图的每个channel：发现有好多失活的，这跟MAE训练的ViT效果相反：不同channel均有激活且多样性丰富。
为了增加channel的多样性，作者设计了GRU的归一化方式：
简单说下上述代码含义：算法的输入和输出的维度相同 R H × W × C \mathbb{R}^{H \times W \times C} RH×W×C 。首先对X的每个channel执行L2正则得到 g x ∈ R C gx \in \mathbb{R}^{ C} gx∈RC ；然后对gx的每个channel的值除以gx的均值得到权重 n x ∈ R C nx \in \mathbb{R}^{ C} nx∈RC , n x nx nx 保留了每个channel相对于其余channel的重要性。 最后返回 X ⋅ n x ∈ R H × W × C X \cdot nx \in \mathbb{R}^{ H \times W \times C} X⋅nx∈RH×W×C 。另外设计了两个可学习的缩放系数 γ \gamma γ 和 β \beta β 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f983eef755a91174155e43e1f9a795d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7822874758284b0e429b19bd41edb33e/" rel="bookmark">
			单片机51 定时器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本概念 1.1简介 单片机的定时器是一种内部功能模块，用于产生计时、计数、延时等功能。定时器通常由一个或多个计数器和相关的控制逻辑组成。单片机的定时器可以运行在不同的工作模式下，以适应不同的计时和计数需求。
C51中的定时器和计数器是同一个硬件电路支持的，通过寄存器配置不同，就可以将他当做定时器
或者计数器使用。
确切的说，定时器和计数器区别是致使他们背后的计数存储器加1的信号不同。当配置为定时器使
用时，每经过1个机器周期，计数存储器的值就加1。而当配置为计数器时，每来一个负跳变信号
(信号从P3.4 或者P3.5引脚输入)，就加1，以此达到计数的目的。
标准C51有2个定时器/计数器：T0和T1。他们的使用方法一致。C52相比C51多了一个T2。
1.2 如何定时 定时器的本质原理： 每经过一个机器周期，就加1 :寄存器
晶振： 晶振(晶体震荡器)，又称数字电路的“心脏”，是各种电子产品里面必不可少的频率元器件。数字电
路的所有工作都离不开时钟，晶振的好坏、晶振电路设计的好坏，会影响到整个系统的稳定性。
时钟周期： 时钟周期也称为振荡周期，定义为时钟频率的倒数。时钟周期是计算机中最基本的、最小的时间单
位。在一个时钟周期内，CPU仅完成一个最基本的动作。时钟周期是一个时间的量。更小的时钟周
期就意味着更高的工作频率。
机器周期： 机器周期也称为CPU周期。在计算机中，为了便于管理，常把一条指令的执行过程划分为若干个阶
段（如取指、译码、执行等），每一阶段完成一个基本操作。完成一个基本操作所需要的时间称为
机器周期。一般情况下，一个机器周期由若干个时钟周期组成。
1.3 时间计算方式 二、 程序 2.1 非中断模式 定时10ms led状态翻转一次：
#include &lt;stdio.h&gt; #include "reg52.h" sbit led = P3^6; sbit key1 = P2^1; //void Timer0Init(void)	//10毫秒@11.0592MHz //{ //	AUXR &amp;= 0x7F;	//定时器时钟12T模式 //	TMOD &amp;= 0xF0;	//设置定时器模式 //	TL0 = 0x00;	//设置定时初值 //	TH0 = 0xDC;	//设置定时初值 //	TF0 = 0;	//清除TF0标志 //	TR0 = 1;	//定时器0开始计时 //} int main() { int cnt =0; TMOD &amp;= 0xF0;	//设置定时器模式 TL0 = 0x00;	//设置定时初值 TH0 = 0xDC;	//设置定时初值 TF0 = 0;	//清除TF0标志 TR0 = 1;	//定时器0开始计时 while(1) { if(TF0 == 1) { TF0= 0; TL0 = 0x00;	//设置定时初值 TH0 = 0xDC;	//设置定时初值 cnt++; if(cnt&gt;100) { led = !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7822874758284b0e429b19bd41edb33e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d46d06554f4b6a4402ace305621785d/" rel="bookmark">
			【机器学习科学库】全md文档笔记：Matplotlib详细使用方法（已分享，附代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本系列文章md笔记（已分享）主要讨论人工智能相关知识。主要内容包括，了解机器学习定义以及应用场景，掌握机器学习基础环境的安装和使用，掌握利用常用的科学计算库对数据进行展示、分析，学会使用jupyter notebook平台完成代码编写运行，应用Matplotlib的基本功能实现图形显示，应用Matplotlib实现多图显示，应用Matplotlib实现不同画图种类，学习Numpy运算速度上的优势，知道Numpy的数组内存块风格，了解Numpy与Pandas的不同，学习Pandas的使用，应用crosstab和pivot_table实现交叉表与透视表，应用Pandas实现数据的读取和存储，并且了解完整机器学习项目的流程。 仓库里完整资料代码： 请移步这里获取文档和代码 感兴趣的小伙伴可以自取哦，欢迎大家点赞转发~ 共 7 章，33 子模块 Matplotlib 学习目标 应用Matplotlib的基本功能实现图形显示应用Matplotlib实现多图显示应用Matplotlib实现不同画图种类 3.2 基础绘图功能 — 以折线图为例 学习目标 目标
掌握给图形添加辅助功能(如：标注、x,y轴名称、标题等)
知道图形的保存
知道如何多次plot绘制图形
知道如何多个坐标系显示图形知道折线图的应用场景 1 完善原始折线图 — 给图形添加辅助功能 为了更好地理解所有基础绘图功能，我们通过天气温度变化的绘图来融合所有的基础API使用
需求：画出某城市11点到12点1小时内每分钟的温度变化折线图，温度范围在15度~18度
效果：
1.1 准备数据并画出初始折线图 ```python import matplotlib.pyplot as plt import random
画出温度变化图 0.准备x, y坐标的数据 x = range(60) y_shanghai = [random.uniform(15, 18) for i in x]
1.创建画布 plt.figure(figsize=(20, 8), dpi=80)
2.绘制折线图 plt.plot(x, y_shanghai)
3.显示图像 plt.show() ```
1.2 添加自定义x,y刻度 plt.xticks(x, **kwargs) x:要显示的刻度值
plt.yticks(y, **kwargs) y:要显示的刻度值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d46d06554f4b6a4402ace305621785d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cdcef31c20134dcf9d686b9ab432289/" rel="bookmark">
			OpenHarmony分布式购物车案例展示~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 分布式购物车demo 模拟的是我们购物时参加满减活动，进行拼单的场景；实现两人拼单时，其他一人添加商品到购物车，另外一人购物车列表能同步更新，且在购物车列表页面结算时，某一人结算对方也能实时知道结算金额和优惠金额。整个操作效果分为3个小动画，
拉起对方用户 添加商品到购物车列表 购物车列表勾选 demo效果（HH-SCDAYU200） 工程目录 完整的项目结构目录如下
├─entry\\src\\main │ │ config.json 应用配置文件 │ │ │ ├─ets │ │ └─MainAbility │ │ │ app.ets ets应用程序主入口 │ │ │ │ │ ├─model │ │ │ ArsData.ets // 初始化我的页面数据 │ │ │ CommonLog.ets // 日志类 │ │ │ GoodsData.ets // 初始化商品信息数据类 │ │ │ MenuData.ets // 初始化我的页面数据类 │ │ │ RemoteDeviceManager.ets // 分布式拉起设备管理类 │ │ │ ShoppingCartDistributedData.ets // 加入购物车分布式数据库 │ │ │ TotalSelectedDistributedData.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cdcef31c20134dcf9d686b9ab432289/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da098afc70573361b8d65ef732708c0a/" rel="bookmark">
			单片机精进之路-5矩阵键盘扫描
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如下图，先在p3口输出0xfe，再读取p3口的电平，如果没有按键按下，temp &amp; 0xf0还是0xf0，如果又第一个键按下，temp &amp; 0xf0还是0xee，其他按键由此类推可得。
//4*4键盘检测程序,按下键后相应的代码显示在数码管上 #include&lt;reg51.h&gt; sbit beep=P2^3; sbit dula = P2^6; sbit wela = P2^7; unsigned char i = 100; unsigned char j, k, temp, key; void delay(unsigned char i) { for(j = i; j &gt; 0; j--) for(k=125; k&gt;0; k--); } unsigned char code table[] = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e, 0x79, 0x71}; display(unsigned char num) { P0 = table[num]; dula = 1; dula = 0; P0 = 0xc0; wela = 1; wela = 0; } void main() { dula = 0; wela = 0; while(1) { //扫描第一行键盘是否按下 P3 = 0xfe;	//	1111 1110 temp = P3; temp = temp &amp; 0xf0;	//	1111 0000 if(temp !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da098afc70573361b8d65ef732708c0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/078f82184228d149bfef563b716edfa8/" rel="bookmark">
			Arduino单片机基础介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（本文为简单介绍，内容源于网络和AI）
Arduino单片机，自2005年诞生以来，已经成为全球爱好者和专业工程师们快速实现创意原型的重要工具。Arduino的普及不仅因其强大的功能和简易的操作，还在于其背后强大的社区支持和开源精神。
Arduino项目起源于意大利的伊维利亚设计研究院(IDII)，由Massimo Banzi和David Cuartielles等人于2005年发起。最初目的是为非电子专业的学生提供一种廉价、便捷、易于学习的硬件平台，以便他们能够实现各种互动项目。Arduino名称来源于意大利的一个酒吧，该酒吧的名字叫“Bar di Re Arduino”，是创始人们经常聚会的地方。
Arduino板通常基于Atmel AVR微控制器，如ATmega系列。这些微控制器的性能不同，具有不同数量的输入/输出端口、内存大小、处理速度等。例如，Arduino Uno，作为最受欢迎的Arduino板之一，配备了ATmega328P微控制器，拥有14个数字输入/输出引脚（其中6个可用作PWM输出）、6个模拟输入引脚、16 MHz的晶体振荡器、USB连接、电源插座等。
Arduino的优势在于其易用性、灵活性和可扩展性。它提供了一个简单的集成开发环境（IDE），用户可以通过C/C++语言进行编程，并且提供了大量的库（libraries）来简化硬件操作。此外，Arduino板采用开源硬件和软件，用户可以自由获取设计文件，进行定制和扩展。
Arduino的另一个重要优势是其庞大的用户社区。全球范围内有大量的爱好者、创客和专业人士分享他们的代码、教程和项目经验，这为初学者和进阶者提供了极大的学习资源。
Arduino的应用非常广泛，它不仅被广泛用于教育和爱好者项目，还被应用于专业的产品原型开发中。以下是一些典型应用案例：
教育领域：Arduino常被用于学校和研究机构的STEM教育中，帮助学生理解编程和电子基础知识。
艺术与设计：艺术家和设计师使用Arduino来创造互动装置和装饰品。
家居自动化：使用Arduino来控制家中的灯光、温度或安全系统。
机器人：Arduino作为许多DIY机器人项目的大脑，使得机器人编程和控制变得容易。
物联网：Arduino可以与各种传感器和网络模块相连，用于构建智能设备和系统，实现物联网应用。
随着技术的不断发展，Arduino也在不断推出性能更强、功能更丰富的新型号，如Arduino Due、Arduino MKR系列等，以满足用户日益增长的需求。
我这里分享一个包含150G学习资料的免费资料包,里面包含的学习内容、面试经验和项目实例都是比较新的和全面的
https://m.hqyjai.net/emb_study_blue_short.html?xt=lwf
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2fd5983c66316d3b9a4a4eec1634a1a/" rel="bookmark">
			网络原理——HTTPS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTPS是 在HTTP的基础上，引入了一个加密层（SSL)。
1. 为什么需要HTTPS 在我们使用浏览器下载一些软件时，相信大家都遇到过这种情况：明明这个链接显示的是下载A软件，点击下载时就变成了B软件，这种情况是运营商劫持。
当我们点击下载时其实就是给服务器发送了一个HTTP请求，这个请求通过网络传输是就会通过很多设备，其中就有运营商的设备，服务器接收到请求之后，服务器会返回一个响应，这个响应就带有软件的下载链接，当这个响应经过运营商的设备时，运营商就可以把其中的链接篡改，于是就导致了我们得到的下载链接和想要下载的软件不一致。这就叫运营商劫持。
不仅如此，我们的信息也可能会被泄露。
为了解决此类问题，加密就是一个很好的方法，于是诞生了HTTPS。
2. 什么是HTTPS？ HTTPS，全称为HyperText Transfer Protocol Secure，即超文本传输安全协议，是HTTP的安全版。通过使用SSL/TLS协议，HTTPS在传输层对数据进行加密，从而确保网络通信过程中的安全性和完整性。通常，HTTPS被用于安全地传输个人信息、金融交易数据、登录凭证等敏感信息，以防止被恶意攻击者窃取或篡改。
2.1 密钥 密钥在加密通信中扮演着至关重要的角色，它用于加密和解密数据，确保数据传输的安全性。在HTTPS等加密通信中，通常会涉及到两种类型的密钥：对称密钥和公钥/私钥（非对称密钥）。
对称密钥： 对称密钥是一种加密系统中使用的密钥，用于对数据进行加密和解密。在对称加密算法中，加密和解密使用相同的密钥，因此被称为对称密钥。对称加密算法的优点是加密解密速度快，缺点是密钥传输的安全性相对较低。在HTTPS握手过程中，通常会使用对称密钥来加密通信内容，以提高传输效率。
公钥/私钥（非对称密钥）： 公钥/私钥是一对密钥，其中一个用于加密数据，一个用于解密数据。公钥可以自由发布给他人，而私钥则必须保密。非对称加密算法的优点是密钥传输的安全性高，缺点是加密解密速度较慢。在HTTPS的握手过程中，服务器会将其公钥发送给客户端，客户端使用该公钥加密生成的对称密钥，然后发送给服务器，从而建立安全连接。
3. HTTPS工作过程 3.1 引入对称加密 对称加密时，客户端和服务器使用同一个密钥进行加密和解密，并且为了进一步提高安全，不同的客户端使用的密钥不相同，所以每个客户端连接到服务器时，都需要生成一个随机的密钥，并且把这个密钥告知给 服务器/客户端 ,但是由于密钥明文传输才能被对端理解，所以导致了黑客也能获取并理解密钥，一旦黑客拿到了密钥就意味着加密操作无意义了
3.2 引入非对称加密 使用非对称加密主要是用于对对称密钥进行加密。
服务器会把用于加密的公钥明文发送给客户端，客户端使用公钥对对称加密的密钥进行加密传输给服务器，由于黑客不持有私钥，所以无法的到对称密钥，后续客户端和服务器就可以使用对称加密来进行通信。
由于非对称加密的资源消耗要远大于对称加密，所以不太适合用于正式的数据交互加密。
3.3 中间人攻击 在我们3.2 中的加密方式还存在一个漏洞 ：
服务器可以创建出一对公钥和私钥，那么黑客同样可以，于是当服务器发送公钥给客户端时，黑客可以把公钥修改为自己生成的公钥，客户端接受到这个公钥，就会用这个公钥对生成的对称密钥加密，然后发送给服务器，黑客就可以知道对称密钥，为了不被服务器发现，黑客会对客户端发送的对称密钥用服务器生成的公钥重新加密，再发送给服务器，于是后续客户端和服务器使用对称密钥通信时，黑客也能获取到并解密出数据。
3.4 证书 中间人攻击能成功的最关键的一点就是客户端无法验证接受到的公钥是不是服务器的，为了防止中间人攻击，于是引入了证书。证书是一个结构化的数据，里面包含了很多属性，例如服务器的主域名，公钥，证书有效期等，以字符串的形式储存。证书是搭建服务器的公司要从第三方的公证机构申请。证书中有一个属性叫“签名”，这个“签名”本质上是一个经过加密的校验和，公证机构再发布证书时，会给这个证书计算出校验和，然后用非对称密钥的私钥进行加密，这个私钥不会公布出去，对应的公钥会内置在常见的系统中。服务器给客户端发送公钥时，会直接把证书发送过去，客户端拿到证书后会对证书中的校验和用该公证机构的公钥进行解密，再通过证书中提供的校验和算法对证书再次计算校验和然后和解密的到的校验和进行对比，即可判断出证书是否被修改。如果被修改过，浏览器就会提示 “你访问的网站有风险”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1790c03887f6c08fa1ed4ba2fbde96e5/" rel="bookmark">
			防御保护----内容安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		八.内容安全--------------------------。 IAE引擎： IAE引擎里面的技术：DFI和DPI技术--- 深度检测技术 DPI --- 深度包检测技术--- 主要针对完整的数据包（数据包分片，分段需要重组），之后对 数据包的内容进行识别。（应用层） 1，基于“特征字”的检测技术---最常用的识别手段，基于一些协议的字段来识别特 征。
2，基于应用网关的检测技术---有些应用控制和数据传输是分离的，比如一些视频流。 一开始需要TCP建立连接，协商参数，这一部分我们称为信令部分。之后，正式传输数 据后，可能就通过UDP协议来传输，流量缺失可以识别的特征。所以，该技术就是基于 前面信令部分的信息进行识别和控制。
3，基于行为模式的检测技术---比如我们需要拦截一些垃圾邮件，但是，从特征字中很 难区分垃圾邮件和正常邮件，所以，我们可以基于行为来进行判断。比如，垃圾邮件可 能存在高频，群发等特性，如果出现，我们可以将其认定为垃圾邮件，进行拦截，对IP 进行封锁。
DFI --- 深度流检测技术---一种基于流量行为的应用识别技术。这种方法比较适合判断P2P流 量。 结论：
1，DFI仅对流量进行分析，所以，只能对应用类型进行笼统的分类，无法识别出具体的应 用；DPI进行检测会更加精细和精准； 2，如果数据包进行加密传输，则采用DPI方式将不能识别具体的应用，除非有解密手段；但 是，加密并不会影响数据流本身的特征，所以，DFI的方式不受影响。
入侵防御（IPS） IDS --- 侧重于风险管理的设备 IPS --- 侧重于风险控制的设备 IPS的优势： 1，实时的阻断攻击； 2，深层防护---深入到应用层； 3，全方位的防护---IPS可以针对各种常见威胁做出及时的防御，提供全方位的防护； 4，内外兼防---只要是通过设备的流量均可以进行检测，可以防止发自于内部的攻击。 5，不断升级，精准防护
入侵检测的方法： 异常检测 误用检测 异常检测： 异常检测基于一个假定，即用户行为是可以预测的，遵循一致性模式的； 误用检测：误用检测其实就是创建了一个异常行为的特征库。我们将一些入侵行为记录下来，总结成 为特征，之后，检测流量和特征库进行对比，来发现威胁。 总结： 1，在进行IPS模块检测之前，首先需要重组IP分片报文和TCP数据流；---增加检测的精准性 2，在此之后需要进行应用协议的识别。这样做主要为了针对特定的应用进行对应精细的解 码，并深入报文提取特征。 3，最后，解析报文特征和签名（特征库里的特征）进行匹配。再根据命中与否做出对应预设 的处理方案。
签名--- 针对网络上的入侵行为特征的描述，将这些特征通过HASH后和我们报文进行 比对。 签名--- 预定义签名---设备上自带的特征库，这个需要我们激活对应的License（许可证） 后才能获取。---这个预定义签名库激活后，设备可以通过连接华为的安全中心进行升级。
自定义签名---自己定义威胁特征。 自定义签名和预定义签名可以执行的动作：
告警--- 对命中签名的报文进行放行，但是会记录再日志中
阻断--- 对命中签名的报文进行拦截，并记录日志 放行--- 对命中签名的报文放行，不记录日志
注意：这里在进行更改时，一定要注意提交，否则配置不生效。修改的配置需要在提交后重启 模块后生效。 ID --- 签名的标识 对象--- 服务端，客户端，服务端和客户端：服务端和客户端指的都是身份，一般将发起连接的一端称为客户端，接受连接提供服 务的称为服务端。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1790c03887f6c08fa1ed4ba2fbde96e5/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<span class="pagination__item pagination__item--current">1/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/2/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>