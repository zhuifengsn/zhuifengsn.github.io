<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法 - 归并排序（Merge_sort） - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="算法 - 归并排序（Merge_sort）" />
<meta property="og:description" content="目录
什么是归并排序(Merging_sort)？
归并排序的适用场景：
演示归并排序的过程(默认arr和brr两个数组都是有序的)：
代码实现：
如果我们事先并没有分配好两个已经排序好的数组，而是直接的一个无序序列呢？
代码实现：
什么是归并排序(Merging_sort)？ 在写归并排序的代码之前，我们先对归并排序的定义和排序原理进行梳理。
在严蔚敏的《数据结构（C语言版）》一书中对归并排序是这样定义的：
归并排序（Merging_Sort）是一类不同的排序方法。“归并”的含义是将两个或者两个以上的有序表组合成一个新的有序表。利用归并的思想容易实现排序，且这种实现方法已为读者熟悉，无论是顺序存储结构还是链表存储结构，都可以在O（m&#43;n）的时间量级上实现。归并排序也是一个与插入排序、交换排序、选择排序不同的一类排序方法。
归并排序是一个基于分治法思想的算法，拿两个已经有序的序列重新组合成一个有序的序列。
归并排序的适用场景： 归并排序适合链表排序但不适合数组排序，归并在外部排序，比如磁盘文件的情况下比快速排序好，因为快排比较依赖数据的随机存取，而归并是顺序存取，对磁盘这种外村比较友好，还有很重要的一点就是快速排序和对排序都是不稳定排序，归并排序是稳定排序。
演示归并排序的过程(默认arr和brr两个数组都是有序的)： 例如我在这里给出两个数组：
int arr[] = {1,3,5,7}; int brr[] = {2,4,6,8}; 我们定义两个指针i和j分别指向arr数组和brr数组，在定义一个临时值temp，通过遍历这两个数组，每一次的遍历我们都对i和j所指向的值进行比较，找到两个数中较小的值放入临时值temp中，并拷贝一份放入到新的数组中，直到排序完成：
当我们的i遍历至元素1，j遍历至元素2时，i是小于j的，于是我们将i所指向的元素赋值给temp并放入到新的数组中，令i指针向前迁移一位进行下一次i和j的比较：
此时继续i和j指向元素的比较，我们发现，元素2小于3，这时我们将元素2赋值给temp并放入新数组中，并令j指针的位置加1:
此时继续进行比较，我们发现3 &lt; 4，现在将元素3赋值给temp，放入至新数组中，所对应i指针的位置向后迁移一位：
过程以此类推：
比较4和5:
比较5和6:
比较6和7:
比较7和8:
最后我们直接将元素8放至新数组的末尾：
同样的，如果我们的第二个数组的后面又加上9和10，我们在第一个数组已经遍历完了的情况下，直接将9和10安插在新数组的后面。
代码实现： #include&lt;stdio.h&gt; #include&lt;assert.h&gt; #include&lt;iostream&gt; void showar(int *ar,int len) { assert(ar != nullptr); for(int i = 0;i &lt; len;i&#43;&#43;){ printf(&#34;%d &#34;,ar[i]); } printf(&#34;\n--------------------------\n&#34;); } void Merging_sort1(int *ar,int len1,int *br,int len2,int *temp) { assert(ar !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/f5ffc79f7bec3f936e300a34aa08b0fb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-01T16:24:18+08:00" />
<meta property="article:modified_time" content="2022-09-01T16:24:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法 - 归并排序（Merge_sort）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%BB%80%E4%B9%88%E6%98%AF%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F(Merging_sort)%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%28Merging_sort%29%EF%BC%9F" rel="nofollow">什么是归并排序(Merging_sort)？</a></p> 
<p id="%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A" rel="nofollow">归并排序的适用场景：</a></p> 
<p id="%E6%BC%94%E7%A4%BA%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BF%87%E7%A8%8B(%E9%BB%98%E8%AE%A4arr%E5%92%8Cbrr%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E9%83%BD%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84)%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E6%BC%94%E7%A4%BA%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BF%87%E7%A8%8B%28%E9%BB%98%E8%AE%A4arr%E5%92%8Cbrr%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E9%83%BD%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%29%EF%BC%9A" rel="nofollow">演示归并排序的过程(默认arr和brr两个数组都是有序的)：</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A" rel="nofollow">代码实现：</a></p> 
<p id="%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E4%BA%8B%E5%85%88%E5%B9%B6%E6%B2%A1%E6%9C%89%E5%88%86%E9%85%8D%E5%A5%BD%E4%B8%A4%E4%B8%AA%E5%B7%B2%E7%BB%8F%E6%8E%92%E5%BA%8F%E5%A5%BD%E7%9A%84%E6%95%B0%E7%BB%84%EF%BC%8C%E8%80%8C%E6%98%AF%E7%9B%B4%E6%8E%A5%E7%9A%84%E4%B8%80%E4%B8%AA%E6%97%A0%E5%BA%8F%E5%BA%8F%E5%88%97%E5%91%A2%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E4%BA%8B%E5%85%88%E5%B9%B6%E6%B2%A1%E6%9C%89%E5%88%86%E9%85%8D%E5%A5%BD%E4%B8%A4%E4%B8%AA%E5%B7%B2%E7%BB%8F%E6%8E%92%E5%BA%8F%E5%A5%BD%E7%9A%84%E6%95%B0%E7%BB%84%EF%BC%8C%E8%80%8C%E6%98%AF%E7%9B%B4%E6%8E%A5%E7%9A%84%E4%B8%80%E4%B8%AA%E6%97%A0%E5%BA%8F%E5%BA%8F%E5%88%97%E5%91%A2%EF%BC%9F" rel="nofollow">如果我们事先并没有分配好两个已经排序好的数组，而是直接的一个无序序列呢？</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A" rel="nofollow">代码实现：</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%BB%80%E4%B9%88%E6%98%AF%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F(Merging_sort)%EF%BC%9F">什么是归并排序(Merging_sort)？</h2> 
<p>在写归并排序的代码之前，我们先对归并排序的定义和排序原理进行梳理。</p> 
<p>在严蔚敏的《数据结构（C语言版）》一书中对归并排序是这样定义的：</p> 
<p><span style="color:#fe2c24;"><strong>归并排序（Merging_Sort）</strong></span>是一类不同的排序方法。“归并”的含义是将两个或者两个以上的有序表组合成一个新的有序表。利用归并的思想容易实现排序，且这种实现方法已为读者熟悉，无论是顺序存储结构还是链表存储结构，都可以在O（m+n）的时间量级上实现。归并排序也是一个与插入排序、交换排序、选择排序不同的一类排序方法。</p> 
<p>归并排序是一个基于分治法思想的算法，拿两个已经有序的序列重新组合成一个有序的序列。</p> 
<h2 id="%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A">归并排序的适用场景：</h2> 
<p>归并排序适合链表排序但不适合数组排序，归并在外部排序，比如磁盘文件的情况下比快速排序好，因为快排比较依赖数据的随机存取，而归并是顺序存取，对磁盘这种外村比较友好，还有很重要的一点就是快速排序和对排序都是不稳定排序，<span style="color:#fe2c24;">归并排序是稳定排序。</span></p> 
<h2 id="%E6%BC%94%E7%A4%BA%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BF%87%E7%A8%8B(%E9%BB%98%E8%AE%A4arr%E5%92%8Cbrr%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E9%83%BD%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84)%EF%BC%9A">演示归并排序的过程(默认arr和brr两个数组都是有序的)：</h2> 
<p>例如我在这里给出两个数组：</p> 
<pre><code>int arr[] = {1,3,5,7};
int brr[] = {2,4,6,8};</code></pre> 
<p>我们定义两个指针i和j分别指向arr数组和brr数组，在定义一个临时值temp，通过遍历这两个数组，每一次的遍历我们都对i和j所指向的值进行比较，找到两个数中较小的值放入临时值temp中，并拷贝一份放入到新的数组中，直到排序完成：</p> 
<p><img alt="" src="https://images2.imgbox.com/8c/bf/JW1ZghfQ_o.png"></p> 
<p>当我们的i遍历至元素1，j遍历至元素2时，i是小于j的，于是我们将i所指向的元素赋值给temp并放入到新的数组中，令i指针向前迁移一位进行下一次i和j的比较：</p> 
<p><img alt="" src="https://images2.imgbox.com/35/ce/TrD3lpfv_o.png"></p> 
<p>此时继续i和j指向元素的比较，我们发现，元素2小于3，这时我们将元素2赋值给temp并放入新数组中，并令j指针的位置加1:</p> 
<p><img alt="" src="https://images2.imgbox.com/74/66/6f1YlkvY_o.png"></p> 
<p></p> 
<p>此时继续进行比较，我们发现3 &lt; 4，现在将元素3赋值给temp，放入至新数组中，所对应i指针的位置向后迁移一位：</p> 
<p><img alt="" src="https://images2.imgbox.com/6a/eb/Nr4Wc0Kt_o.png"></p> 
<p></p> 
<p>过程以此类推：</p> 
<p> 比较4和5:<img alt="" src="https://images2.imgbox.com/0f/62/6jUeoLk8_o.png"></p> 
<p>比较5和6:</p> 
<p> <img alt="" src="https://images2.imgbox.com/58/26/ejziOXs1_o.png"></p> 
<p>比较6和7:</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c8/b4/Q6CxJfER_o.png"></p> 
<p>比较7和8:</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/78/0e/9NfalRnp_o.png"></p> 
<p>最后我们直接将元素8放至新数组的末尾：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d4/89/w4cyNnP0_o.png"></p> 
<p><span style="color:#fe2c24;"><strong>同样的，如果我们的第二个数组的后面又加上9和10，我们在第一个数组已经遍历完了的情况下，直接将9和10安插在新数组的后面。</strong></span></p> 
<h2 id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span style="color:#0d0016;">代码实现：</span></h2> 
<pre><code>#include&lt;stdio.h&gt;
#include&lt;assert.h&gt;
#include&lt;iostream&gt;
void showar(int *ar,int len)
{
	assert(ar != nullptr);
	for(int i = 0;i &lt; len;i++){
		printf("%d ",ar[i]);
	}
	printf("\n--------------------------\n");
}
void Merging_sort1(int *ar,int len1,int *br,int len2,int *temp)
{
	assert(ar != nullptr &amp;&amp; br != nullptr &amp;&amp; temp != nullptr);
	assert(len1 &gt;= 0 &amp;&amp; len2 &gt;= 0);
	int i = 0,j = 0,k = 0;
	while(i &lt; len1 &amp;&amp; j &lt; len2){
		if(ar[i] &lt; br[j]){
			temp[k] = ar[i];
			i++;
			k++;
		}
		else{
			temp[k] = br[j];
			j++;
			k++;
		}
	}
	while(i &lt; len1){
		temp[k] = ar[i];
		i++;
		k++;
	}
	while(j &lt; len2){
		temp[k] = br[j];
		j++;
		k++;
	}
}
int main()
{
    int ar[4] = {1,3,5,7};
	int br[4] = {2,4,6,8};
	int len1 = sizeof(ar) / sizeof(ar[0]);
	int len2 = sizeof(br) / sizeof(br[0]);
	int temp[8] = {0};
	Merging_sort1(ar,len1,br,len2,temp);
	showar(temp,8);
	return 0;
}</code></pre> 
<p>我们对排序的代码做一下简洁优化（三目运算符）：</p> 
<pre><code>void Merging_sort1(int *ar,int len1,int *br,int len2,int *temp)
{
	assert(ar != nullptr &amp;&amp; br != nullptr &amp;&amp; temp != nullptr);
	assert(len1 &gt;= 0 &amp;&amp; len2 &gt;= 0);
	int i = 0,j = 0,k = 0;
	while(i &lt; len1 &amp;&amp; j &lt; len2){
		temp[k++] = ar[i] &lt; br[j] ? ar[i++] : br[j++];
	}
	while(i &lt; len1){
		temp[k++] = ar[i++];
	}
	while(j &lt; len2){
		temp[k++] = br[j++];
	}
}</code></pre> 
<p>运行结果：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/32/79/t6JlcwH0_o.png"></p> 
<h2 id="%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E4%BA%8B%E5%85%88%E5%B9%B6%E6%B2%A1%E6%9C%89%E5%88%86%E9%85%8D%E5%A5%BD%E4%B8%A4%E4%B8%AA%E5%B7%B2%E7%BB%8F%E6%8E%92%E5%BA%8F%E5%A5%BD%E7%9A%84%E6%95%B0%E7%BB%84%EF%BC%8C%E8%80%8C%E6%98%AF%E7%9B%B4%E6%8E%A5%E7%9A%84%E4%B8%80%E4%B8%AA%E6%97%A0%E5%BA%8F%E5%BA%8F%E5%88%97%E5%91%A2%EF%BC%9F">如果我们事先并没有分配好两个已经排序好的数组，而是直接的一个无序序列呢？</h2> 
<p>例如在这里我给出一个无序数组：</p> 
<pre><code>int arr[9] = {5,8,2,3,1,4,7,6};</code></pre> 
<p>归并排序的思想就是分治法，我们将数组中的8个数全部分成单一的数，把他们均看作是一个小数组：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d3/f7/sF53HnS7_o.png"></p> 
<p>现在形成了8个长度为1的数组 ，然后我们两两进行归并，并把相对较小的元素放在前面：</p> 
<p><img alt="" src="https://images2.imgbox.com/9c/56/NTvZQviB_o.png"></p> 
<p></p> 
<p>现在形成了4个长度为2的数组，我们继续进行两两归并：</p> 
<p>这次我们对58和23进行归并，我们先放2再放3，然后依次放5和8，后面两个数组也是这样：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/fa/61/Ed8pRQ4l_o.png"></p> 
<p>现在形成了两个长度为4的数组，继续对这两个数组进行归并：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9c/fa/K8ul9Ala_o.png"></p> 
<h2>代码实现：</h2> 
<pre><code>#define MAXSIZE 11
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;
#include&lt;iostream&gt;
#include&lt;time.h&gt;
void initar(int *ar,int len)//初始化ar数组，用小于30的int类型数填充
{
	assert(ar != nullptr);
	for(int i = 0;i &lt; len;i++){
		ar[i] = rand() % 30;
	}
}
void showar(int *ar,int len)//打印数组函数
{
	assert(ar != nullptr);
	for(int i = 0;i &lt; len;i++){
		printf("%d ",ar[i]);
	}
	printf("\n--------------------------\n");
}
void merge(int *ar,int low,int middle,int high,int *temp)//归并排序
{
	int i = low;//通过I遍历左半边数组
	int j = middle + 1;//通过j遍历右半边数组
	int k = low;//通过k遍历整个数组
	while(i &lt;= middle &amp;&amp; j &lt;= high){//循环通过I和j分别遍历从中间划分开来的两个数组，并分开比较大小
		temp[k++] = ar[i] &lt; ar[j] ? ar[i++] : ar[j++];//如果前者小于后者就将前者直接添加至新数组的后面，依此类推
	}
	while(i &lt;= middle)//如果比较完了，但左半边数组还有剩余的元素，直接将这些元素添加至新数组的后方
	temp[k++] = ar[i++];
	while(j &lt;= high)//同理，比较完了右半边还有剩余的，也直接添加至新数组的后方
	temp[k++] = ar[j++];
	for(i = low;i &lt;= high;i++){//最后将新数组的所有元素赋值给ar数组
		ar[i] = temp[i];
	}
}
void merge_sort(int *ar,int low,int high,int *temp)
{
	if(low &gt;= high){//如果左边界大于右边界，直接返回
		return;
	}
	int middle = low + (high - low) / 2;//相比较（low + high）/ 2；的优化写法，可以防止越界
	merge_sort(ar,low,middle,temp);递归调用，左半部分循环归并
	merge_sort(ar,middle + 1,high,temp);//右半部分循环归并
	merge(ar,low,middle,high,temp);//递归操作
}
void mergesort(int *ar,int len)//最终归并函数
{
	int *temp = (int *)malloc(sizeof(int)*len);//向堆区申请len个int类型大小的空间赋给temp新数组
	assert(temp != nullptr);//断言新数组不为空
	merge_sort(ar,0,len - 1,temp);//递归归并操作
	free(temp);//释放temp的内存空间
    temp = NULL;//将temp置空
}
int main()
{
    srand((unsigned int)time(NULL));
	int ar[MAXSIZE];
	initar(ar,MAXSIZE);
	printf("原始数据为：\n");
	showar(ar,MAXSIZE);
    printf("\n经过归并排序后的数据为：\n");
	mergesort(ar,MAXSIZE);
	showar(ar,MAXSIZE);
	return 0;
}</code></pre> 
<p>运行结果： </p> 
<p> <img alt="" src="https://images2.imgbox.com/74/4c/gywJSPxP_o.png"></p> 
<p>如图，成功将系统随机生成的十一个数完成升序排序。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/db14bd8b3076b8d60803be7cea2a8e3b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python split 函数方法，字符串分割，分割中间，分割左右，分割次数。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4d106de81aec0a1dbf0b0ca82c4feab3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何解决批量上传太多文件导致浏览器挂掉的问题(已解决)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>