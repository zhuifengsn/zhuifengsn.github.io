<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringCloud运用与理解 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringCloud运用与理解" />
<meta property="og:description" content="文章目录 SpringCloud介绍优缺点SpringCloud和SpringBoot关系SpringCloud和Dubbo的区别SpringCloud作用SpringCluod的五大组件引入组件的步骤 SpringCloud核心组件的业务运用EurekaEureka ClientEureka Server客服端与服务端的链接Eureka的自我保护机制EurekaServer集群Eureka与zookeeper比较 RibbonFeignHystrix问题背景解决方案服务熔断概念实现 服务降级概念实现 熔断与服务降级的区别Dashboard监控 Zuul实现 SpringCloud介绍 Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具
SpringCloud官网：http://projects.spring.io/spring-cloud/
相关学习网站：
https://springcloud.cc/spring-cloud-netflix.html
中文API文档： https://springcloud.cc/spring-cloud-dalston.html
SpringCloud中国社区 http://springcloud.cn/
SpringCloud中文网 https://springcloud.cc
优缺点 优点：
1、服务拆分粒度更细，有利于资源重复利用，有利于提高开发效率
2、可以更精准的制定优化服务方案，提高系统的可维护性
3、微服务架构采用去中心化思想，服务之间采用Restful等轻量级通讯，比ESB更轻量
4、适于互联网时代，产品迭代周期更短
5、社区活跃度高
缺点：
1、微服务过多，治理成本高，不利于维护系统
2、分布式系统开发的成本高（容错，分布式事务等）对团队挑战大
总的来说优点大过于缺点，目前看来SpringCloud是一套非常完善的分布式框架，目前很多企业开始用微服务
SpringCloud和SpringBoot关系 SpringBoot专注于快速方便的开发单个个体微服务SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，为各个微服务之间提供：配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务SpringBoot可以离开SpringCloud独立使用，开发项目，但是SpringCloud离不开SpringBoot，属于依赖关系SpringBoot专注于快速，方便的开发单个个体微服务，SpringCloud关注全局的服务治理框架 SpringCloud和Dubbo的区别 SpringCloudDubbo服务注册中心SpringCloud Netfilx EureKaZookeeper服务调用方式REST APIRPC服务监控Spring Boot AdminDubbo-monitor断路器Spring Cloud Netflix Hystrix不完善服务网关Spring Cloud Netfilx Zuul无分布式配置Spring Cloud Config无服务跟踪Spring Cloud Sleuth无消息总线Spring Cloud Bus无数据流Spring Cloud Srream无批量任务Spring Cloud Task无 最大区别：SpringCloud抛弃了Dubbo的RPC通信，采用的是最基本的HTTP的REST方式
严格来说，这两种方式各有优劣，虽然从一定程度上来说，后者牺牲看服务调用的性能，但是也避免的上面提到的原生RPC带来的问题，而且REST相比RPC更灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更加合适
他们解决的问题域不一样：Dubbo的定位是一款RPC框架，Spring Cloud的目标是微服务架构下的一站式解决方案
SpringCloud作用 Distributed/versioned configuration (分布式/ 版本控制配置)Service registration and discovery （服务注册与发现）Routing（路由）Service-to-service calls　（服务到服务的调用）Load balancing （负载均衡配置）Distributed messaging（分布式消息管理）。。。 SpringCluod的五大组件 服务发现 ——Netflix Eurek客户端负载均衡——Netflix Ribbon断路器——Netflix Hystrix服务网关——Netflix Zuul分布式配置——Spring Cloud Config 引入组件的步骤 导入依赖编写配置文件开启这个功能 @EnableXXXXX配置类 SpringCloud核心组件的业务运用 在实际微服务开发中，是将项目拆分为一个一个的子服务，如在常见的电商项目中，存在搜索服务，库存服务，订单服务，评价服务，仓储服务，积分服务等服务，微服务使得开发容易和为维护，因为一个服务只关注一个特定的业务，使得业务清晰，代码量少等优点" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/3036837eaaa0521a8c31d227135de14b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-06T16:15:08+08:00" />
<meta property="article:modified_time" content="2023-07-06T16:15:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringCloud运用与理解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#SpringCloud_2" rel="nofollow">SpringCloud介绍</a></li><li><ul><li><a href="#_20" rel="nofollow">优缺点</a></li><li><a href="#SpringCloudSpringBoot_42" rel="nofollow">SpringCloud和SpringBoot关系</a></li><li><a href="#SpringCloudDubbo_49" rel="nofollow">SpringCloud和Dubbo的区别</a></li><li><a href="#SpringCloud_70" rel="nofollow">SpringCloud作用</a></li><li><a href="#SpringCluod_80" rel="nofollow">SpringCluod的五大组件</a></li><li><a href="#_88" rel="nofollow">引入组件的步骤</a></li></ul> 
  </li><li><a href="#SpringCloud_97" rel="nofollow">SpringCloud核心组件的业务运用</a></li><li><a href="#Eureka_123" rel="nofollow">Eureka</a></li><li><ul><li><a href="#Eureka_Client_130" rel="nofollow">Eureka Client</a></li><li><a href="#Eureka_Server_136" rel="nofollow">Eureka Server</a></li><li><a href="#_142" rel="nofollow">客服端与服务端的链接</a></li><li><a href="#Eureka_174" rel="nofollow">Eureka的自我保护机制</a></li><li><a href="#EurekaServer_404" rel="nofollow">EurekaServer集群</a></li><li><a href="#Eurekazookeeper_454" rel="nofollow">Eureka与zookeeper比较</a></li></ul> 
  </li><li><a href="#Ribbon_492" rel="nofollow">Ribbon</a></li><li><a href="#Feign_548" rel="nofollow">Feign</a></li><li><a href="#Hystrix_578" rel="nofollow">Hystrix</a></li><li><ul><li><a href="#_591" rel="nofollow">问题背景</a></li><li><a href="#_599" rel="nofollow">解决方案</a></li><li><a href="#_617" rel="nofollow">服务熔断</a></li><li><ul><li><a href="#_619" rel="nofollow">概念</a></li><li><a href="#_623" rel="nofollow">实现</a></li></ul> 
   </li><li><a href="#_682" rel="nofollow">服务降级</a></li><li><ul><li><a href="#_684" rel="nofollow">概念</a></li><li><a href="#_692" rel="nofollow">实现</a></li></ul> 
   </li><li><a href="#_755" rel="nofollow">熔断与服务降级的区别</a></li><li><a href="#Dashboard_778" rel="nofollow">Dashboard监控</a></li></ul> 
  </li><li><a href="#Zuul_854" rel="nofollow">Zuul</a></li><li><ul><li><a href="#_874" rel="nofollow">实现</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="SpringCloud_2"></a>SpringCloud介绍</h2> 
<blockquote> 
 <p>Spring Cloud是一系列框架的<strong>有序集合</strong>。它利用Spring Boot的开发便利性巧妙地<strong>简化了分布式系统基础设施的开发</strong>，如<strong>服务发现注册</strong>、<strong>配置中心</strong>、消息总线、<strong>负载均衡</strong>、<strong>断路器</strong>、<strong>数据监控</strong>等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具</p> 
</blockquote> 
<p>SpringCloud官网：http://projects.spring.io/spring-cloud/</p> 
<p>相关学习网站：</p> 
<ul><li> <p>https://springcloud.cc/spring-cloud-netflix.html</p> </li><li> <p>中文API文档： https://springcloud.cc/spring-cloud-dalston.html</p> </li><li> <p>SpringCloud中国社区 http://springcloud.cn/</p> </li><li> <p>SpringCloud中文网 https://springcloud.cc</p> </li></ul> 
<h3><a id="_20"></a>优缺点</h3> 
<p>优点：</p> 
<p>1、服务拆分粒度更细，有利于资源重复利用，有利于提高开发效率</p> 
<p>2、可以更精准的制定优化服务方案，提高系统的可维护性</p> 
<p>3、微服务架构采用去中心化思想，服务之间采用Restful等轻量级通讯，比ESB更轻量</p> 
<p>4、适于互联网时代，产品迭代周期更短</p> 
<p>5、社区活跃度高</p> 
<p>缺点：</p> 
<p>1、微服务过多，治理成本高，不利于维护系统</p> 
<p>2、分布式系统开发的成本高（容错，分布式事务等）对团队挑战大</p> 
<p>总的来说优点大过于缺点，目前看来SpringCloud是一套非常完善的分布式框架，目前很多企业开始用微服务</p> 
<h3><a id="SpringCloudSpringBoot_42"></a>SpringCloud和SpringBoot关系</h3> 
<ul><li>SpringBoot专注于快速方便的开发单个个体微服务</li><li>SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，为各个微服务之间提供：<strong>配置管理</strong>、<strong>服务发现</strong>、<strong>断路器</strong>、<strong>路由</strong>、<strong>微代理</strong>、<strong>事件总线</strong>、<strong>全局锁</strong>、<strong>决策竞选</strong>、<strong>分布式会话</strong>等等集成服务</li><li>SpringBoot可以离开SpringCloud独立使用，开发项目，但是SpringCloud离不开SpringBoot，属于依赖关系</li><li>SpringBoot专注于快速，方便的开发单个个体微服务，SpringCloud关注全局的服务治理框架</li></ul> 
<h3><a id="SpringCloudDubbo_49"></a>SpringCloud和Dubbo的区别</h3> 
<table><thead><tr><th align="center"></th><th align="center">SpringCloud</th><th align="center">Dubbo</th></tr></thead><tbody><tr><td align="center">服务注册中心</td><td align="center">SpringCloud Netfilx EureKa</td><td align="center">Zookeeper</td></tr><tr><td align="center">服务调用方式</td><td align="center">REST API</td><td align="center">RPC</td></tr><tr><td align="center">服务监控</td><td align="center">Spring Boot Admin</td><td align="center">Dubbo-monitor</td></tr><tr><td align="center">断路器</td><td align="center">Spring Cloud Netflix Hystrix</td><td align="center">不完善</td></tr><tr><td align="center">服务网关</td><td align="center">Spring Cloud Netfilx Zuul</td><td align="center">无</td></tr><tr><td align="center">分布式配置</td><td align="center">Spring Cloud Config</td><td align="center">无</td></tr><tr><td align="center">服务跟踪</td><td align="center">Spring Cloud Sleuth</td><td align="center">无</td></tr><tr><td align="center">消息总线</td><td align="center">Spring Cloud Bus</td><td align="center">无</td></tr><tr><td align="center">数据流</td><td align="center">Spring Cloud Srream</td><td align="center">无</td></tr><tr><td align="center">批量任务</td><td align="center">Spring Cloud Task</td><td align="center">无</td></tr></tbody></table> 
<p><strong>最大区别</strong>：SpringCloud抛弃了Dubbo的RPC通信，采用的是最基本的HTTP的REST方式</p> 
<p>严格来说，这两种方式各有优劣，虽然从一定程度上来说，后者牺牲看服务调用的性能，但是也避免的上面提到的原生RPC带来的问题，而且REST相比RPC更灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更加合适</p> 
<p>他们解决的问题域不一样：Dubbo的定位是一款RPC框架，Spring Cloud的目标是微服务架构下的一站式解决方案</p> 
<h3><a id="SpringCloud_70"></a>SpringCloud作用</h3> 
<ul><li>Distributed/versioned configuration (分布式/ 版本控制配置)</li><li>Service registration and discovery （服务注册与发现）</li><li>Routing（路由）</li><li>Service-to-service calls　（服务到服务的调用）</li><li>Load balancing （负载均衡配置）</li><li>Distributed messaging（分布式消息管理）</li><li>。。。</li></ul> 
<h3><a id="SpringCluod_80"></a>SpringCluod的五大组件</h3> 
<ol><li>服务发现 ——Netflix Eurek</li><li>客户端负载均衡——Netflix Ribbon</li><li>断路器——Netflix Hystrix</li><li>服务网关——Netflix Zuul</li><li>分布式配置——Spring Cloud Config</li></ol> 
<h3><a id="_88"></a>引入组件的步骤</h3> 
<ol><li>导入依赖</li><li>编写配置文件</li><li>开启这个功能 @EnableXXXXX</li><li>配置类</li></ol> 
<h2><a id="SpringCloud_97"></a>SpringCloud核心组件的业务运用</h2> 
<p>在实际微服务开发中，是将项目拆分为一个一个的子服务，如在常见的电商项目中，存在搜索服务，库存服务，订单服务，评价服务，仓储服务，积分服务等服务，微服务使得开发容易和为维护，因为一个服务只关注一个特定的业务，使得业务清晰，代码量少等优点</p> 
<p>提出问题1：订单服务想要调用库存服务、仓储服务，或者积分服务，怎么调用？订单服务根本儿就不知道库存服务在哪台机器上啊！请求不知道发送给谁</p> 
<p>解决问题：使用<strong>Eureka</strong>将服务都注册到注册中心，就知道每个服务的具体位置</p> 
<p>提出问题2：知道了位置，哪怎么调用服务呢？写一堆网络链接代码？</p> 
<p>解决问题：使用<strong>Feign</strong>，Feign的动态代理会根据你在接口上的@RequestMapping等注解，来动态构造出你要请求的服务的地址</p> 
<p>提出问题3：当我们的某个服务需要进行集群时（请求量大，单个服务承载不了，如高峰期的订单服务），那我们此时请求集群的哪个服务器呢？都长得一样呀(都是订单服务)</p> 
<p>解决问题：使用<strong>Ribbon</strong>进行负载均衡，默认时轮询方式，也就是每一个服务都挨个依次访问</p> 
<p>提出问题4：如上，基本组成了微服务链路（扇出链路），但是这条链路中某个服务挂了，如评价服务，这业务和其他相比根本不重要，却导致整个项目瘫痪，亏大了</p> 
<p>解决问题：使用<strong>Hystrix</strong>进行熔断，对挂掉的服务做出一个备选处理，时项目正常运行</p> 
<p>提出问题5：在我们用户中，我想去使用某个服务，怎么办？记住每一个服务名称和端口号？当服务有上百个呢？当服务又存在着集群呢？显然让我们记住每一个服务名称和端口号？</p> 
<p>解决问题： 使用<strong>Zuul</strong>网关路由，进行服务的统一管理，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务 （这是不必须的）</p> 
<h2><a id="Eureka_123"></a>Eureka</h2> 
<ul><li>Eureka实现服务注册与发现</li><li>Eureka采用C-S的架构设计，即存在客服端Eureka Client 和 服务端Eureka Server两个组件</li><li>每一微服务都有着属于自己的Eureka Client ，向服务端Eureka Server 注册中心注册自己的信息</li><li>客服端Eureka Client 链接到服务端Eureka Server并维持心跳（隔一段时间发送信息确保客服端的存活，默认周期30秒），这样系统的维护人员就可以通过Eureka Server监控系统的各个微服务是否正常运行，SpringCloud的一些模块如Zuul就可以通过EurekaServer来发现系统的其他微服务</li></ul> 
<h3><a id="Eureka_Client_130"></a>Eureka Client</h3> 
<p>ureka Client是一个java客户端，用于简化EurekaServer的交互，客户端同时也具备一个内置的，使用轮甸负载算法的负载均衡器。在应用启动后，将会向EurekaServer发送心跳（默认周期为30秒)。如果ureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个报务节点移除掉(默认周期为90秒)</p> 
<h3><a id="Eureka_Server_136"></a>Eureka Server</h3> 
<p>Eureka Server提供服务注册服务，各个节点启动后，会在EurekaServer中进行注册，这样Eureka Server中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。</p> 
<h3><a id="_142"></a>客服端与服务端的链接</h3> 
<p>Eureka Client</p> 
<pre><code class="prism language-yaml"><span class="token comment">#使用Eureka将信息注入到注册中心</span>
<span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>
      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>7001/eureka
  <span class="token key atrule">instance</span><span class="token punctuation">:</span>
    <span class="token key atrule">instance-id</span><span class="token punctuation">:</span> springcloud<span class="token punctuation">-</span>provider<span class="token punctuation">-</span>dept8001
</code></pre> 
<p>Eureka Server</p> 
<pre><code class="prism language-yaml"><span class="token comment">#Eureka Server配置</span>
<span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">instance</span><span class="token punctuation">:</span>
    <span class="token key atrule">hostname</span><span class="token punctuation">:</span> localhost  <span class="token comment">#Eureka服务端的实例名称</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">register-with-eureka</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
    <span class="token comment">#表示是否向eureka注册中心注册自己</span>
    <span class="token key atrule">fetch-registry</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
    <span class="token comment">#是否获取注册表信息，false意味着自己就是注册表</span>
    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>  <span class="token comment">#监控地址</span>
      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//$<span class="token punctuation">{<!-- --></span>eureka.instance.hostname<span class="token punctuation">}</span><span class="token punctuation">:</span>$<span class="token punctuation">{<!-- --></span>server.port<span class="token punctuation">}</span>/eureka/
</code></pre> 
<p>完成注册！</p> 
<h3><a id="Eureka_174"></a>Eureka的自我保护机制</h3> 
<p>简单来说就是：宁可同时保留所有的微服务（健康和不健康的微服务都会保留），也不会盲目注销任何健康的微服务</p> 
<p><strong>目的</strong>：使用自我保护机制，可以让Eureka集群更加健壮和稳定</p> 
<p><strong>具体介绍</strong>：</p> 
<p>​ Eureka服务端会检查最近15分钟内所有Eureka 实例正常心跳占比，如果低于85%就会触发自我保护机制。触发了保护机制，Eureka将暂时把这些失效的服务保护起来，不让其过期，但这些服务也并不是永远不会过期。Eureka在启动完成后，每隔60秒会检查一次服务健康状态，如果这些被保护起来失效的服务过一段时间后（默认90秒）还是没有恢复，就会把这些服务剔除。如果在此期间服务恢复了并且实例心跳占比高于85%时，就会自动关闭自我保护机制。</p> 
<p><strong>为什么会有自我保护机制</strong></p> 
<ul><li>防止由于网路通信故障等原因，造成Eureka服务端失去于Eureka客户端的连接，从而形成的不可用。</li><li>因为网络通信是可能恢复的，但是Eureka客户端只会在启动时才去服务端注册。如果因为网络的原因而剔除了客户端，将造成客户端无法再注册到服务端。</li></ul> 
<p><strong>如何选择是否开启自我保护机制</strong></p> 
<ul><li> <p>Eureka服务端默认情况下是会开启自我保护机制的。但我们在不同环境应该选择是否开启保护机制。</p> </li><li> <p>一般情况下，我们会选择在开发环境下关闭自我保护机制，而在生产环境下启动自我保护机制。</p> </li></ul> 
<p><strong>开发环境下</strong>：</p> 
<p>​ 我们<strong>启动的服务数量较少</strong>而且会<strong>经常修改重启</strong>。如果开启自我保护机制，很容易触发Eureka客户端心跳占比低于85%的情况。使得Eureka不会剔除我们的服务，从而在我们访问的时候，<strong>会访问到可能已经失效的服务</strong>，导致请求失败，影响我们的开发。</p> 
<p><strong>在生产环境下</strong>：</p> 
<p>​ 我们启动的<strong>服务多且不会反复启动修改</strong>。<strong>环境也相对稳定</strong>，影响服务正常运行的人为情况较少。适合开启自我保护机制，让Eureka进行管理。</p> 
<p><strong>关闭自我保护机制</strong></p> 
<p><strong>服务端</strong>：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">server</span><span class="token punctuation">:</span>
    <span class="token comment">#服务端是否开启自我保护机制 （默认true）</span>
    <span class="token key atrule">enable-self-preservation</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
    <span class="token comment">#扫描失效服务的间隔时间（单位毫秒，默认是60*1000）即60秒</span>
    <span class="token comment">#让服务端每隔2秒扫描一次，使服务能尽快的剔除。</span>
    <span class="token key atrule">eviction-interval-timer-in-ms</span><span class="token punctuation">:</span> <span class="token number">2000</span>
</code></pre> 
<p><strong>客户端</strong>：</p> 
<p>我们的客户端设置和Eureka服务端的集群相同。我们设置三个客户端服务，服务名（spring.name）分别为client1、client2和client3，并修改端口号（server.port）分别为10000、20000、30000。</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">10000</span>
<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> client1
<span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>
      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//cluster1<span class="token punctuation">:</span>70700/eureka<span class="token punctuation">,</span>http<span class="token punctuation">:</span>//cluster2<span class="token punctuation">:</span>8080/eureka<span class="token punctuation">,</span>http<span class="token punctuation">:</span>//cluster3<span class="token punctuation">:</span>9090/eureka
  <span class="token key atrule">instance</span><span class="token punctuation">:</span>
  <span class="token comment"># 客户端向注册中心发送心跳的时间间隔（默认30秒），设置为1秒一次。</span>
    <span class="token key atrule">lease-renewal-interval-in-seconds</span><span class="token punctuation">:</span> <span class="token number">1</span>
    <span class="token comment">#Eureka注册中心（服务端）在收到客户端心跳之后，等待下一次心跳的超时时间，如果在这个时间内没有收到下次心跳，则移除该客户端（默认90秒），设置为2秒。如果超过2秒，移除该客户端。</span>
    <span class="token key atrule">lease-expiration-duration-in-seconds</span><span class="token punctuation">:</span> <span class="token number">2</span>
    <span class="token key atrule">server</span><span class="token punctuation">:</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">20000</span>
<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> client2
<span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>
      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//cluster1<span class="token punctuation">:</span>7070/eureka<span class="token punctuation">,</span>http<span class="token punctuation">:</span>//cluster2<span class="token punctuation">:</span>8080/eureka<span class="token punctuation">,</span>http<span class="token punctuation">:</span>//cluster3<span class="token punctuation">:</span>9090/eureka
  <span class="token key atrule">instance</span><span class="token punctuation">:</span>

<span class="token comment">#客户端向注册中心发送心跳的时间间隔，（默认30秒）</span>

    <span class="token key atrule">lease-renewal-interval-in-seconds</span><span class="token punctuation">:</span> <span class="token number">1</span>
    <span class="token comment">#Eureka注册中心（服务端）在收到客户端心跳之后，等待下一次心跳的超时时间，如果在这个时间内没有收到下次心跳，则移除该客户端。（默认90秒）</span>
    <span class="token key atrule">lease-expiration-duration-in-seconds</span><span class="token punctuation">:</span> <span class="token number">2</span>

<span class="token key atrule">server</span><span class="token punctuation">:</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">30000</span>
<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> client3
<span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>
      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//cluster1<span class="token punctuation">:</span>7070/eureka<span class="token punctuation">,</span>http<span class="token punctuation">:</span>//cluster2<span class="token punctuation">:</span>8080/eureka<span class="token punctuation">,</span>http<span class="token punctuation">:</span>//cluster3<span class="token punctuation">:</span>9090/eureka
  <span class="token key atrule">instance</span><span class="token punctuation">:</span>

<span class="token comment">#客户端向注册中心发送心跳的时间间隔，（默认30秒）</span>

    <span class="token key atrule">lease-renewal-interval-in-seconds</span><span class="token punctuation">:</span> <span class="token number">1</span>
    <span class="token comment">#Eureka注册中心（服务端）在收到客户端心跳之后，等待下一次心跳的超时时间，如果在这个时间内没有收到下次心跳，则移除该客户端。（默认90秒）</span>
    <span class="token key atrule">lease-expiration-duration-in-seconds</span><span class="token punctuation">:</span> <span class="token number">2</span>
</code></pre> 
<p>我们将Eureka服务端集群启动并启动客户端的三个实例。当我们将客户端（client1）实例停掉（按照Eureka心跳占比低于85%规则，停掉一个就可以出发自我保护机制），我们过2-3秒后，查看Eureka服务端的控制台，查看是否将已经失效的服务剔除。</p> 
<p><strong>查看自我保护机制是否启动和触发</strong></p> 
<p>Eureka是否触发自我保护机制和是否开启自我保护都可以在Eureka控制台看到。</p> 
<p>我们先认识一下Eureka控制台的三个参数</p> 
<p>Lease expiration enabled 是否启用租约过期 . 当前实例心跳占比不满85%，Eureka自动保护机制启动启动后该值为false，当实例心跳占比满足了85%时，Eureka将会自动关闭自我保护机制，此时此值为true。</p> 
<p>Renews thresshold: 续约阀值，既每分钟接收客户端最少的续约数。如果低于这个值，Eureka将进入自我保护机制。</p> 
<pre><code class="prism language-java">续约： 客户端向服务端发送一次心跳，来证明客户端在线。 理解：相当于服务端和客户端签订了一份合同，到期了就要续约，保证合同能够继续进行。

在<span class="token class-name">Eureka</span>源码中关于<span class="token class-name">Renews</span> thresshold阀值的计算函数如下
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">updateRenewsPerMinThreshold</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>numberOfRenewsPerMinThreshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>expectedNumberOfClientsSendingRenews <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">60.0D</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>serverConfig<span class="token punctuation">.</span><span class="token function">getExpectedClientRenewalIntervalSeconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">this</span><span class="token punctuation">.</span>serverConfig<span class="token punctuation">.</span><span class="token function">getRenewalPercentThreshold</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
expectedNumberOfClientsSendingRenews<span class="token operator">:</span> 注册的实例数
getExpectedClientRenewalIntervalSeconds<span class="token operator">:</span>服务端期望的客户端续约间隔，既服务端每分钟期望接收的心跳间隔
<span class="token function">getRenewalPercentThreshold</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> 阀值系数 默认为<span class="token number">0.85</span>


<span class="token class-name">Renews</span> thresshold <span class="token operator">=</span> （注册的实例数<span class="token operator">*</span>（<span class="token number">60</span><span class="token operator">/</span>服务端期望的客户端心跳间隔））<span class="token operator">*</span> 阀值 

注册的实例数：就是包括服务端集群和客户端在内的所有已经注册的实例。在控制台的<span class="token class-name">Instances</span> currently registered <span class="token keyword">with</span> <span class="token class-name">Eureka</span>中显示。

客户端一分钟心跳数：<span class="token class-name">Eureka</span>客户端eureka<span class="token punctuation">.</span>instance<span class="token punctuation">.</span>ease<span class="token operator">-</span>renewal<span class="token operator">-</span>interval<span class="token operator">-</span>in<span class="token operator">-</span>seconds配置的值，默认为<span class="token number">30</span>秒，既每<span class="token number">30</span>秒向服务端发送一次心跳。

阀值：我们在<span class="token class-name">Eureka</span>集群服务端配置的eureka<span class="token punctuation">.</span>instance<span class="token punctuation">.</span>renewal<span class="token operator">-</span>percent<span class="token operator">-</span>threshold<span class="token punctuation">.</span> 不需要配置，默认值为<span class="token number">0.85</span><span class="token punctuation">.</span>  既<span class="token number">15</span>分钟内<span class="token class-name">Eureka</span>实例的心跳数低于<span class="token number">85</span><span class="token operator">%</span>时，启动自我保护机制。
<span class="token class-name">Renews</span><span class="token punctuation">(</span>last min<span class="token punctuation">)</span>： 最后一分钟续约数。 这个值就是所有实例在当前时刻前一分钟的所有心跳数。
</code></pre> 
<p>我们判断是否进入了自我保护机制，就可以从Renews thresshold和Renews(last min)的对比中看出。</p> 
<p>Renews thresshold &lt;= Renews(last min) ： 当前最后一分钟的续约数大于续约阀值，这是正常状态，Eureka服务端没有启动自我保护机制。</p> 
<p>Renews thresshold &gt; Renews(last min)： 当续约阀值大于当前最后一分钟的续约数。此时Eureka将进入自我保护机制。</p> 
<p>我将在下面创建一个3个服务端的集群和3个不同服务的客户端，来模拟我们的自我保护机制启动关闭情况。让我们能够从控制台上，确定当前Eureka现在所处的状态。</p> 
<p>正常情况<br> 我们可以在控制台上Instances currently registered with Eureka中有6个实例。其中CLUSTEREUREKA是我们的Eureka服务端集群3个。剩下CLIENT1-CLIENT3是客户端实例。</p> 
<p>在正常情况下，可以看到Lease expiration enabled 显示为true。</p> 
<p>Renews thresshold值为 （我们6个实例<em>每个实例每分钟2次心跳）</em> 0.85 ≈ 10.2 所以我们的Renews thresshold=10.</p> 
<p>Renews(last min)值，因为在正常情况下，所以每个实例都是每分钟2次心跳，没有网络连接的异常。</p> 
<p>6个实例* 每个实例每分钟2次心跳 = 12.</p> 
<p>Renews thresshold &lt; Renews(last min) 当前情况没有达到开启自我保护机制的阀值所以是正常情况。</p> 
<p>启动自我保护机制并触发<br> 为了开启自我保护机制，我现在停掉CLIENT1实例。因为一个实例每分钟给服务发送两次心跳请求，当停掉一个实例时，他减少2次心跳。此时Renews (last min) = 10. 这时Renews = Renews threshold 我们来看一下是否触发了自我保护机制。</p> 
<p>Eureka服务端默认60秒扫描一次服务，我们过1分钟内可以在控制台看到我已将CLIENT1实例停掉了，但这里依然存在，且Lease expiration enabled 变为了false。Renews thresshold = Renews(last min)并且报出了一下异常。</p> 
<pre><code class="prism language-yaml">EMERGENCY<span class="token tag">!</span> EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY'RE NOT. 
RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST
TO BE SAFE.
紧急<span class="token tag">!EUREKA</span>可能错误地声称实例已经启动，而实际上并没有。续订小于阈值，因此实例不会因为安全而过期。
</code></pre> 
<p>根据我们上面讲到的情况，发现此时已经进入了自我保护机制。</p> 
<p>由此可以推断出如果Renews thresshold =&gt; Renews(last min）时，我们将进入自我保护机制中。</p> 
<p>当我们将CLIENT1重新启动后，1-2分钟后，Renews thresshold &lt; Renews(last min）,我们也会自动退出自我保护机制。</p> 
<p>关闭自我保护机制<br> 我们可以在服务端application-xxx.yml中配置enable-self-preservation和eviction-interval-timer-in-ms属性</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">server</span><span class="token punctuation">:</span>
    <span class="token comment">#服务端是否开启自我保护机制 （默认true） 生产环境下，需要自我保护机制，续注释</span>
    <span class="token key atrule">enable-self-preservation</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
    <span class="token comment">#扫描失效服务的间隔时间（单位毫秒，默认是60*1000）即60秒  生产环境下，需要自我保护机制，需注释</span>
    <span class="token key atrule">eviction-interval-timer-in-ms</span><span class="token punctuation">:</span> <span class="token number">2000</span>
  <span class="token key atrule">instance</span><span class="token punctuation">:</span>
客户端向注册中心发送心跳的时间间隔，（默认30秒）
    <span class="token key atrule">lease-renewal-interval-in-seconds</span><span class="token punctuation">:</span> <span class="token number">1</span>
    <span class="token comment">#Eureka注册中心（服务端）在收到客户端心跳之后，等待下一次心跳的超时时间，如果在这个时间内没有收到下次心跳，则移除该客户端。（默认90秒）</span>
    <span class="token key atrule">lease-expiration-duration-in-seconds</span><span class="token punctuation">:</span> <span class="token number">2</span>
</code></pre> 
<p>在客户端application-xxx.yml中配置lease-renewal-interval-in-seconds和lease-expiration-duration-in-seconds属性</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">instance</span><span class="token punctuation">:</span>
    <span class="token comment"># 客户端向注册中心发送心跳的时间间隔，（默认30秒）</span>
    <span class="token key atrule">lease-renewal-interval-in-seconds</span><span class="token punctuation">:</span> <span class="token number">1</span>
    <span class="token comment">#Eureka注册中心（服务端）在收到客户端心跳之后，等待下一次心跳的超时时间，如果在这个时间内没有收到下次心跳，则移除该客户端。（默认90秒）</span>
    <span class="token key atrule">lease-expiration-duration-in-seconds</span><span class="token punctuation">:</span> <span class="token number">2</span>
</code></pre> 
<p>这时我们不需要再看Renews threshold和Renews（last min）的值了。因为我们关闭了自我保护机制，不需要在计算是否超过了阀值。</p> 
<p>我们可以在控制台上看到如下提示，这个提示就告诉我们现在已经关闭了自我保护机制。</p> 
<pre><code>THE SELF PRESERVATION MODE IS TURNED OFF. THIS MAY NOT PROTECT INSTANCE EXPIRY IN CASE OF NETWORK/OTHER PROBLEMS.
自我保存模式已关闭。这可能无法在网络/其他问题时保护实例过期。
</code></pre> 
<p>这时候，随意关闭一个客户端服务，过几秒后我们将很快发现注册中心已经将失效的服务剔除了。</p> 
<h3><a id="EurekaServer_404"></a>EurekaServer集群</h3> 
<p>当只存一个Eureka Server时，当这个崩了，会导致业务瘫痪</p> 
<p>现如今有三个Eureka Server，记为Server1，Server2，Server3，端口分别为7001，7002，7003，服务端的实例名称分别为eureka7001.com，eureka7002.com，eureka7003.com</p> 
<p>方法：</p> 
<ul><li>在Server1中关联Server2，Server3</li><li>在Server2中关联Server1，Server3</li><li>在Server3中关联Server1，Server2</li></ul> 
<p>形成循环</p> 
<p>Server1：</p> 
<pre><code class="prism language-yaml"><span class="token comment">#Eureka Server配置</span>
<span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">instance</span><span class="token punctuation">:</span>
    <span class="token key atrule">hostname</span><span class="token punctuation">:</span> eureka7001.com  <span class="token comment">#Eureka服务端的实例名称</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">register-with-eureka</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
    <span class="token comment">#表示是否向eureka注册中心注册自己</span>
    <span class="token key atrule">fetch-registry</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
    <span class="token comment">#是否获取注册表信息，false意味着自己就是注册表</span>
    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>  <span class="token comment">#监控地址，监控Server1，Server2</span>
      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//eureka7002.com<span class="token punctuation">:</span>7002/eureka/<span class="token punctuation">,</span>
                   http<span class="token punctuation">:</span>//eureka7003.com<span class="token punctuation">:</span>7003/eureka/
</code></pre> 
<p>Server2，Server#同理</p> 
<p>Eureka Client 要同时注册到三个注册中心</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>
      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//eureka7001.com<span class="token punctuation">:</span>7001/eureka/<span class="token punctuation">,</span>
      http<span class="token punctuation">:</span>//eureka7002.com<span class="token punctuation">:</span>7002/eureka/<span class="token punctuation">,</span>
      http<span class="token punctuation">:</span>//eureka7003.com<span class="token punctuation">:</span>7003/eureka/<span class="token punctuation">,</span>
  <span class="token key atrule">instance</span><span class="token punctuation">:</span>
    <span class="token key atrule">instance-id</span><span class="token punctuation">:</span> springcloud<span class="token punctuation">-</span>provider<span class="token punctuation">-</span>dept8001
</code></pre> 
<p>访问其中一个注册中心，都能在该页面的DS Replicas下看到其他两个注册中心，在每一个注册中心都有Eureka Client 注册进来的信息，也就是说，其中一台Server挂掉并不影响业务</p> 
<h3><a id="Eurekazookeeper_454"></a>Eureka与zookeeper比较</h3> 
<p>比较Eureka与zookeepe的注册中心服务，先了解什么时CAP原则</p> 
<p>CAP定理又称CAP原则，指的是在一个<a href="https://so.csdn.net/so/search?q=%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F&amp;spm=1001.2101.3001.7020">分布式系统</a>中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），最多只能同时三个特性中的两个，三者不可兼得。</p> 
<p>CAP的定义</p> 
<p>Consistency (一致性)：</p> 
<p>“all nodes see the same data at the same time”, 即更新操作成功并返回客户端后，所有节点在同一时间的数据完全一致，这就是分布式的一致性。一致性的问题在并发系统中不可避免，对于客户端来说，一致性指的是并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。</p> 
<p>Availability (可用性):</p> 
<p>可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。</p> 
<p>Partition Tolerance (分区容错性):</p> 
<p>即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。</p> 
<p>分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，对于用户而言并没有什么体验上的影响。</p> 
<p>二、取舍策略</p> 
<p>CAP三个特性只能满足其中两个，那么取舍的策略就共有三种：</p> 
<p>CA without P：如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的。</p> 
<p>CP without A：如果不要求A（可用），相当于每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。设计成CP的系统其实不少，最典型的就是分布式数据库，如Redis、HBase等。对于这些分布式数据库来说，数据的一致性是最基本的要求，因为如果连这个标准都达不到，那么直接采用关系型数据库就好，没必要再浪费资源来部署分布式数据库。</p> 
<p>AP wihtout C：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。典型的应用就如某米的抢购手机场景，可能前几秒你浏览商品的时候页面提示是有库存的，当你选择完商品准备下单的时候，系统提示你下单失败，商品已售完。这其实就是先在 A（可用性）方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，虽然多少会影响一些用户体验，但也不至于造成用户购物流程的严重阻塞。</p> 
<p>其中Eureka实现AP原则，Zookeeper实现CP原则，P是分布式一定需要实现的</p> 
<h2><a id="Ribbon_492"></a>Ribbon</h2> 
<p>Ri bbon是基于Netflix Ribbon实现的一套<strong>客服端负载均衡的工具</strong></p> 
<p>一般负载均衡的方法：轮询、加权、随机</p> 
<p>Ribbon的作用：</p> 
<ul><li>LB（load Balance）负载均衡，在微服务或者分布式集群中经常用的一种应用</li><li>负载均衡也就是将用户的请求平摊的分配到多个服务器上，从而达到系统的HA（高可用）</li><li>常见的负载均衡软件有Nfinx，Lvs等等</li></ul> 
<p>负载均衡有两种</p> 
<ul><li>服务端的负载均衡，如Nginx</li><li>客服端负载均衡，Ribbon</li></ul> 
<p>Ribbon的负载均衡策略</p> 
<ul><li>RoundRobingRule 轮询（默认）</li><li>RandomRule 随机</li><li>AvailabilityFilteringRule 先过滤掉跳闸，访问故障的服务，对剩下的进行轮询</li><li>RetryRule 会先按照轮询获取服务，如果服务获取失败，则会在指定的时间内进行重试</li></ul> 
<p>这些的实现接口 IRule</p> 
<p>自定义策略</p> 
<p>步骤一：在启动类配置相应的注解</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@RibbonClient</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"XXX"</span><span class="token punctuation">,</span>configuration<span class="token operator">=</span>自定义类<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token comment">//XXX代表微服务的spring.application.name</span>
</code></pre> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyRule</span>
<span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">IRule</span> <span class="token function">myRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyRuleDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

calss <span class="token class-name">MyRule</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractLoadBalanceRule</span><span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>注：自定义策略（自定义组件）不能在主程序的上下文的@ComponentScan中，否则将由所有的@RibbonClients共享，如果使用@ComponentScan（或@SpringBootApplication），则需要避免包含（例如将其放在一个单独的，不重叠的包中，即和主程序不在同一包或子中）</p> 
<h2><a id="Feign_548"></a>Feign</h2> 
<p>问题背景：当我们在分布式微服务开发中，每一个功能模块独立出来，但是怎么实现服务一想与服务二进行通信</p> 
<ul><li> <p>订单服务根本就不知道人家库存服务在哪台机器上啊！他就算想要发起一个请求，都不知道发送给谁，有心无力！</p> </li><li> <p>这时候，就轮到Spring Cloud Eureka出场了。Eureka是微服务架构中的注册中心，专门负责服务的注册与发现。</p> </li><li> <p>Netflix在设计Eureka时，遵循AP原则</p> </li><li> <p>Eureka是Nexflix的一个子模块，也是核心模块之一</p> </li><li> <p>Eureka是一个基于REST的服务，用于定位服务，以实现云端中间层服务发现和故障转移</p> </li></ul> 
<p><img src="https://images2.imgbox.com/72/db/luJe7vP9_o.jpg" alt="img"></p> 
<p>上面的代码没有底层的建立连接、构造请求、解析响应的代码，直接就是用注解定义一个 FeignClient接口，然后调用那个接口就可以了。Feign Client会在底层根据你的注解，跟你指定的服务建立连接、构造请求、发起靕求、获取响应、解析响应，等等。这一系列脏活累活，Feign全给你干了。</p> 
<p>那么问题来了，Feign是如何做到这么神奇的呢？很简单，<strong>Feign的一个关键机制就是使用了动态代理</strong>。咱们一起来看看下面的图，结合图来分析：</p> 
<ul><li>首先，如果你对某个接口定义了@FeignClient注解，Feign就会针对这个接口创建一个动态代理</li><li>接着你要是调用那个接口，本质就是会调用 Feign创建的动态代理，这是核心中的核心</li><li>Feign的动态代理会根据你在接口上的@RequestMapping等注解，来动态构造出你要请求的服务的地址</li><li>最后针对这个地址，发起请求、解析响应</li></ul> 
<p><img src="https://images2.imgbox.com/74/9f/fzxBQzmq_o.jpg" alt="img"></p> 
<h2><a id="Hystrix_578"></a>Hystrix</h2> 
<ul><li>Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时，异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障,以提高分布式系统的弹性。</li><li>“断路器"本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝)，向调用方返回一个服务预期的，可处理的备选响应（FallBack)，而不是长时间的等待或者抛出调用方法无法处理的异常，这样就可以保证了服务调用方的线程不会被长时间，不必要的占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩</li></ul> 
<p>作用：</p> 
<ol><li>服务降级</li><li>服务熔断</li><li>服务限流</li><li>接近实时的监控</li><li>。。。</li></ol> 
<h3><a id="_591"></a>问题背景</h3> 
<p>在分布式系统中面临这样的问题，多个微服务之间调用的时候，假设微服务A调用微服务B和C，微服务B和C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，引起所谓的“雪崩效应”，也就是<strong>服务雪崩</strong></p> 
<p>对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。</p> 
<h3><a id="_599"></a>解决方案</h3> 
<p>使用SpringCloud中的Hystrix组件，可进行如下操作</p> 
<ul><li><strong>熔断模式</strong></li></ul> 
<p>这种模式主要是参考电路熔断，如果一条线路电压过高，保险丝会熔断，防止火灾。放到我们的系统中，如果某个目标服务调用慢或者有大量超时，此时，熔断该服务的调用，对于后续调用请求，不在继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用。</p> 
<ul><li><strong>隔离模式</strong></li></ul> 
<p>这种模式就像对系统请求按类型划分成一个个单位，当某个单位挂掉了，不会影响到其他单位。可以对不同类型的请求使用线程池来资源隔离，每种类型的请求互不影响，如果一种类型的请求线程资源耗尽，则对后续的该类型请求直接返回，不再调用后续资源。这种模式使用场景非常多，例如将一个服务拆开，对于重要的服务使用单独服务器来部署，再或者公司最近推广的多中心。</p> 
<ul><li><strong>限流模式</strong></li></ul> 
<p>上述的熔断模式和隔离模式都属于出错后的容错处理机制，而限流模式则可以称为<strong>预防模式</strong>。限流模式主要是提前对各个类型的请求设置最高的QPS阈值，若高于设置的阈值则对该请求直接返回，不再调用后续资源。这种模式不能解决服务依赖的问题，只能解决系统整体资源分配问题，因为没有被限流的请求依然有可能造成雪崩效应。</p> 
<h3><a id="_617"></a>服务熔断</h3> 
<h4><a id="_619"></a>概念</h4> 
<p>​ 当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回"错误"的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败就会启动熔断机制。</p> 
<h4><a id="_623"></a>实现</h4> 
<p><strong>导入依赖</strong></p> 
<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-hystrix<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p><strong>修改配置文件</strong></p> 
<pre><code class="prism language-yaml"> <span class="token key atrule">instance</span><span class="token punctuation">:</span>
    <span class="token key atrule">instance-id</span><span class="token punctuation">:</span> my8001<span class="token punctuation">-</span>hystrix
    <span class="token key atrule">prefer-ip-address</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
</code></pre> 
<p><strong>在相应Controller类设置</strong></p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@RestController</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeptController</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">DeptService</span> service <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/dept/get/{id}"</span><span class="token punctuation">,</span>method<span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>GET<span class="token punctuation">)</span>
    <span class="token annotation punctuation">@HystrixCommand</span><span class="token punctuation">(</span>fallbackMethod <span class="token operator">=</span> <span class="token string">"processHystrix_Get"</span><span class="token punctuation">)</span> 
    <span class="token keyword">public</span> <span class="token class-name">Dept</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token class-name">Long</span> id<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Dept</span> dept <span class="token operator">=</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>service<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> dept<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"该ID："</span><span class="token operator">+</span>id<span class="token operator">+</span><span class="token string">"没有没有对应的信息"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> dept<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Dept</span> <span class="token function">processHystrix_Get</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token class-name">Long</span> id<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Dept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setDeptno</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">setDname</span><span class="token punctuation">(</span><span class="token string">"该ID："</span><span class="token operator">+</span>id<span class="token operator">+</span><span class="token string">"没有没有对应的信息,null--@HystrixCommand"</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">setDb_source</span><span class="token punctuation">(</span><span class="token string">"no this database in MySQL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//一旦调用GET方法失败并抛出了错误信息后，会自动调用@HystrixCommand标注好的fallbackMethod调用类中的指定方法。但是，此种方式会存在一个问题就是每一个方法都需要一个处理</span>
</code></pre> 
<p><strong>在启动类加注解</strong></p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@EnableCircuitBreaker</span>
</code></pre> 
<p>当异常发生后，直接熔断整个服务，而不是一直等待这个服务直到超时！</p> 
<h3><a id="_682"></a>服务降级</h3> 
<h4><a id="_684"></a>概念</h4> 
<p>整体资源不足，将某些服务先关掉，待渡过难关，再重新开启，服务降级是在客户端完成的。</p> 
<p>存在Server1，Server2，Server3，分别占资源33.3%，但是访问Server的访问数量有3万条，而访问Server2，Server3的访问量只有100条，50条，可以先”关闭"Server3服务，将所占用的资源交给Server1使用，直到Server1渡过高并发的难关，再开启已"关闭"的服务</p> 
<p>注：这里的关闭服务，并不是真正的关闭服务，而是拒绝访问该服务的请求，如果Server自己关闭，则意味着该服务挂掉了</p> 
<h4><a id="_692"></a>实现</h4> 
<p><strong>API模块（公共模块）</strong></p> 
<p>新建一个实现了FallbackFactory接口的类DeptClientServiceFallbackFactory，该接口是专门处理异常的，与上面的服务熔断处理异常的方式相比，此种方式实现了逻辑与异常处理业务的分离</p> 
<pre><code class="prism language-java"><span class="token comment">//降级预备走的类，使得整体服务消耗减小</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeptClientServiceFallbackFactory</span> <span class="token keyword">implements</span>
        <span class="token class-name">FallbackFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DeptClientService</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">DeptClientService</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> throwable<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DeptClientService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token class-name">Dept</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">long</span> id<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Dept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setDeptno</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>
                        <span class="token punctuation">.</span><span class="token function">setDname</span><span class="token punctuation">(</span><span class="token string">"该ID："</span> <span class="token operator">+</span> id <span class="token operator">+</span> <span class="token string">"没有没有对应的信息,Consumer客户端提供的降级信息,此刻服务Provider已经关闭"</span><span class="token punctuation">)</span>
                        <span class="token punctuation">.</span><span class="token function">setDb_source</span><span class="token punctuation">(</span><span class="token string">"no this database in MySQL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Dept</span><span class="token punctuation">&gt;</span></span> <span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Dept</span> dept<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在API模块中的业务接口的注解中添加属性：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"PROVIDER"</span><span class="token punctuation">,</span>fallbackFactory<span class="token operator">=</span><span class="token class-name">DeptClientServiceFallbackFactory</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">DeptClientService</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/dept/get/{id}"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>GET<span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">Dept</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token keyword">long</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/dept/list"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>GET<span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Dept</span><span class="token punctuation">&gt;</span></span> <span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/dept/add"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span>POST<span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Dept</span> dept<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>Feign模块</strong>（消费者模块）</p> 
<pre><code>feign: 
  hystrix: 
    enabled: true
</code></pre> 
<p>服务的降级是重整体考虑，当某个服务熔断之后，服务器将不再被调用，客户端可以利用本地的回调，返回缺省值</p> 
<h3><a id="_755"></a>熔断与服务降级的区别</h3> 
<ul><li>服务降级：不管在什么情况下，服务降级的流程都是先调用正常的方法，再调用fallback的方法。 也就是服务器繁忙，请稍后再试，不让客户端等待并立刻返回一个友好提示。</li><li>服务熔断：假设服务宕机或者在单位时间内调用服务失败的次数过多，即服务降级的次数太多，那么则服务熔断。 并且熔断以后会跳过正常的方法，会直接调用fallback方法，即所谓“服务熔断后不可用”。 类似于家里常见的保险丝，当达到最大服务访问后，会直接拒绝访问，拉闸限电，然后调用服务降级的fallback方法，返回友好提示。</li></ul> 
<p><strong>区别</strong></p> 
<ul><li>可以理解成熔断使服务降级的一种特殊情况，熔断主要应对雪崩效应的链路自我保护机制</li><li>服务降级的流程使先调用正常方法，在调用fallback的方法，而服务熔断是熔断后不再调用正常方法，直接调用fallback方法，即服务熔断后不可用</li><li>服务降级是因为请求异常或者错误导致，服务熔断则是因为服务降级的次数太多，那么则服务熔断</li><li>触发原因不一样，服务熔断由链路上某个服务引起的，服务降级是从整体的负载考虑</li><li>管理目标层次不一样，服务熔断是一个框架层次的处理，服务降级是业务层次的处理</li><li>实现方式不一样，服务熔断一般是自我熔断恢复，服务降级相当于人工控制</li><li>触发原因不同 服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；</li></ul> 
<p>服务熔断是应对系统服务雪崩的一种保险措施，给出的一种特殊降级措施。而服务降级则是更加宽泛的概念，主要是对系统整体资源的合理分配以应对压力。</p> 
<p>服务熔断是服务降级的一种特殊情况，他是防止服务雪崩而采取的措施。系统发生异常或者延迟或者流量太大，都会触发该服务的服务熔断措施，链路熔断，返回fallback方法。这是对局部的一种保险措施。</p> 
<h3><a id="Dashboard_778"></a>Dashboard监控</h3> 
<ol><li>首先在消费者的基础上新建一个项目，引入dashboard的依赖，服务提供者也同样需要（服务提供者在Feign项目基础上）</li></ol> 
<pre><code class="prism language-xml"># 消费者
<span class="token comment">&lt;!--        dashboard--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-hystrix-dashboard<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.4.7.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>

# 服务提供者
<span class="token comment">&lt;!--        加入actuator监控--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-actuator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>

</code></pre> 
<ol start="2"><li> <p>在dashboard的启动类上增加注解<code>@EnableHystrixDashboard</code>开启监控</p> </li><li> <p>启动项目，访问dashboard监控页面</p> <p><img src="https://images2.imgbox.com/76/52/TAmxiKJa_o.png" alt="img"></p> </li></ol> 
<p>根据监控页面的信息<code>ingle Hystrix App: http://hystrix-app:port/actuator/hystrix.stream</code>,我们访问一下需要监控的地址，出现了页面404的问题</p> 
<p>添加如下配置：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">management</span><span class="token punctuation">:</span>
  <span class="token key atrule">endpoints</span><span class="token punctuation">:</span>
    <span class="token key atrule">web</span><span class="token punctuation">:</span>
      <span class="token key atrule">exposure</span><span class="token punctuation">:</span>
        <span class="token key atrule">include</span><span class="token punctuation">:</span> hystrix.stream
</code></pre> 
<p>在服务提供者配置后就可以看到这个页面已经可以看到有ping的信息了,但是ping的数据是空的</p> 
<p><img src="https://images2.imgbox.com/53/f0/1XH1dtNa_o.png" alt="img"></p> 
<p>ping的数据为空，原因是因为没有开启熔断机制，把原来<a href="https://so.csdn.net/so/search?q=Feign&amp;spm=1001.2101.3001.7020">Feign</a>的熔断机制<code>@HystrixCommand</code>和启动类上的<code>@EnableCircuitBreaker</code>熔断支持都开起来，访问一下我们的接口就正常了</p> 
<p><img src="https://images2.imgbox.com/5d/91/oG86a7Ii_o.png" alt="img"></p> 
<ol start="4"><li>把需要监控的信息填写到dashboard的页面上就可以成功了</li></ol> 
<p><img src="https://images2.imgbox.com/fd/80/mlvvLhnl_o.png" alt="img"></p> 
<p>对应图形数字颜色等信息</p> 
<p><img src="https://images2.imgbox.com/dd/bf/Bs6e8pBB_o.png" alt="img"></p> 
<p>注：第二种写法，注册一个Bean，不添加配置</p> 
<ol><li> <p>首先在Hystrix项目上注册一个Bean(actuator/hystrix.stream就是我们需要监控的地址)</p> <pre><code>// 增加一个servlet 注册一个Bean
@Bean
public ServletRegistrationBean servletRegistrationBean(){
    ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new HystrixMetricsStreamServlet());
    // 添加信息
    servletRegistrationBean.addUrlMappings("/actuator/hystrix.stream");
    return servletRegistrationBean;
}

</code></pre> <p>一个是在配置文件上添加配置，一个是在新注册一个Bean，都可以实现</p> </li></ol> 
<h2><a id="Zuul_854"></a>Zuul</h2> 
<p>Zuul，也就是微服务网关。<strong>这个组件是负责网络路由的</strong></p> 
<p>假设你后台部署了几百个服务，现在有个前端兄弟，人家请求是直接从浏览器那儿发过来的。<strong>打个比方</strong>：人家要请求一下库存服务，你难道还让人家记着这服务的名字叫做inventory-service？部署在5台机器上？就算人家肯记住这一个，你后台可有几百个服务的名称和地址呢？难不成人家请求一个，就得记住一个？</p> 
<p>上面这种情况，压根儿是不现实的。所以一般微服务架构中都必然会设计一个网关在里面，像android、ios、pc前端、微信小程序、H5等等，不用去关心后端有几百个服务，就知道有一个网关，所有请求都往网关走，网关会根据请求中的一些特征，将请求转发给后端的各个服务。</p> 
<p>而且有一个网关之后，还有很多好处，比如可以做<strong>统一的降级、限流、认证授权、安全</strong>，等等。</p> 
<ul><li>zuul是spring cloud中的微服务网关。<br> 网关： 是一个网络整体系统中的前置门户入口。请求首先通过网关，进行路径的路由，定位到具体的服务节点上。</li><li>Zuul是一个微服务网关，首先是一个微服务。也是会在Eureka注册中心中进行服务的注册和发现。也是一个网关，请求应该通过Zuul来进行路由。</li><li>Zuul网关不是必要的。是推荐使用的。<br> 使用Zuul，一般在微服务数量较多（多于10个）的时候推荐使用，对服务的管理有严格要求的时候推荐使用，当微服务权限要求严格的时候推荐使用。</li></ul> 
<img src="https://images2.imgbox.com/97/03/mXFDw2RN_o.png" alt="img"> 
<h3><a id="_874"></a>实现</h3> 
<ol><li> <p>添加依赖</p> <pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-netflix-eureka-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
        
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-netflix-zuul<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>

</code></pre> </li><li> <p>在启动类添加注解@EnableZuulProxy</p> <pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span></span><span class="token class-name">SpringApplication</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span></span><span class="token class-name">SpringBootApplication</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>netflix<span class="token punctuation">.</span>zuul<span class="token punctuation">.</span></span><span class="token class-name">EnableZuulProxy</span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token annotation punctuation">@EnableZuulProxy</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Application</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Application</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p>修改配置文件</p> <pre><code class="prism language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8000</span>
<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> zuul
<span class="token key atrule">zuul</span><span class="token punctuation">:</span>
  <span class="token key atrule">routes</span><span class="token punctuation">:</span>
    <span class="token comment"># 标识你服务的名字，这里可以自己定义，一般方便和规范来讲还是跟自己服务的名字一样</span>
    <span class="token key atrule">EUREKA-CLIENT-PRODUCER</span><span class="token punctuation">:</span>
      <span class="token comment">#服务映射的路径，通过这路径就可以从外部访问你的服务了，目的是为了不爆露你机器的IP</span>
      <span class="token comment">#这里zuul是自动依赖hystrix，ribbon的，不是面向单机</span>
      <span class="token key atrule">path</span><span class="token punctuation">:</span> /EUREKA<span class="token punctuation">-</span>CLIENT<span class="token punctuation">-</span>PROVIDER/<span class="token important">**</span>
      <span class="token comment">#这里一定要是你Eureka注册中心的服务的名称，是因为这里配置serviceId因为跟eureka结合了，</span>
      <span class="token key atrule">serviceId</span><span class="token punctuation">:</span> EUREKA<span class="token punctuation">-</span>CLIENT<span class="token punctuation">-</span>PROVIDER
<span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>
      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//admin<span class="token punctuation">:</span>123456@127.0.0.1<span class="token punctuation">:</span>8761/eureka/

</code></pre> </li></ol> 
<p>说明</p> 
<p>a. 通过zuul访问服务的，URL地址默认格式为：http://zuulHostIp:port/服务名称/服务中的URL</p> 
<p>例如：http://127.0.0.1:8000/EUREKA-CLIENT-PROVIDER/get?name=123<br> b. 服务名称就是配置文件中的spring.application.name。<br> c. 服务的URL，就是对应的服务对外提供的URL路径</p> 
<p>参考链接：</p> 
<p>https://blog.csdn.net/qq_42046105/article/details/83793787?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/26cf5ac293464952cb0323d0afb12f4c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">QT5项目程序打包成可执行exe程序（绿色版）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eed8e9228ed5de2e12278c47b7c23633/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Mysql数据库比较工具类(2.0版本)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>