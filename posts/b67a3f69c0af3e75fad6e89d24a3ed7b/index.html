<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>类和对象的初始化（构造函数与析构函数） - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="类和对象的初始化（构造函数与析构函数）" />
<meta property="og:description" content="有对象一定要有空间，有空间不一定有对象。
class Empty { }; int main() { Empty e; cout &lt;&lt; sizeof(e) &lt;&lt; endl;//1字节 return 0; } 虽然此对象没任何属性和方法，但是要创建一个对象，就必须在地址空间标识此对象，就必须占有一个字节。
类的数据成员不能在类定义时初始化。
class student { int num = 20060102; char name[15] = &#34;张三&#34;; float score = 85; };//错误 如果一个类中所有的数据成员都是公用的public，则可以在定义对象时对数据成员进行初始化。
class studet { public: int num; char name[15]; float score; }stu1 = { 20010130101,&#34;张三&#34;，85}; 一、构造函数 数据成员多为私有的，要对它们进行初始化，必须用一个公有函数来进行。C&#43;&#43;提供了构造函数来处理类对象的初始化问题。同时这个函数应该在且仅在定义对象时自动执行一次。称为构造函数(constructor) 。
构造函数就是用来在创建对象时初始化对象，为对象数据成员赋初始值。
构造函数用途:1)创建对象，2）初始化对象中的属性，3）类型转换。
构造函数是类的一种特殊的成员函数(在特殊用途中构造函数的访问限定可以定义成私有或保护)
，不需要人为调用；而是在建立对象时自动被执行。
特征：
1.C&#43;&#43;规定构造函数的名字必须与类名相同。
2.构造函数无函数返回类型说明。注意是没有而不是void，即什么也不写，也不可写void。实际上构造函数有返回值，返回的就是构造函数所创建的对象。
3.在程序运行时，当新的对象被建立，该对象所属的类构造函数自动被调用，在该对象生存期中也只调用这一次（由系统调用）。
4.构造函数可以重载。严格地讲，类中可以定义多个构造函数，它们由不同的参数表区分，系统在自动调用时按一般函数重载的规则选一个执行。
5.构造函数可以在类中定义，也可以在类中声明，在类外定义。
6.如果类说明中没有给出构造函数，则C&#43;&#43;编译器自动给出一个缺省的构造函数.
类名（void）{ }
只要我们定义了一个构造函数，系统就不会自动生成缺省的构造函数。只要构造函数是无参或只要各参数均有缺省值的，C&#43;&#43;编译器都认为是缺省的构造函数，并且缺省的构造函数只能有一个。默认构造函数——除了this指针以外没有参数的构造函数，函数体是空的，只能为对象开辟数据成员存储空间，而不能给对象中的数据成员赋初值。
构造函数定义形式:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/b67a3f69c0af3e75fad6e89d24a3ed7b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-24T19:11:26+08:00" />
<meta property="article:modified_time" content="2022-05-24T19:11:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">类和对象的初始化（构造函数与析构函数）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:#fe2c24;"><strong>有对象一定要有空间，有空间不一定有对象。</strong></span></p> 
<pre><code class="language-cpp">class Empty
{

};
int main()
{
	Empty e;
	cout &lt;&lt; sizeof(e) &lt;&lt; endl;//1字节
	return 0;
}</code></pre> 
<p>虽然此对象没任何属性和方法，但是要创建一个对象，就必须在地址空间<strong>标识此对象</strong>，就必须占有一个字节。</p> 
<p id="main-toc">类的数据成员不能在类定义时初始化。</p> 
<pre><code class="language-cpp">class student
{
    int num = 20060102;
    char name[15] = "张三";
    float score = 85;
};//错误</code></pre> 
<p>如果一个类中所有的数据成员都是公用的<strong>public</strong>，则可以在定义对象时对数据成员进行初始化。</p> 
<pre><code class="language-cpp">class studet
{
    public:
    int num;
    char name[15];
    float score;
}stu1 = { 20010130101,"张三"，85};</code></pre> 
<h2 id="%E4%B8%80%E3%80%81%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">一、构造函数</h2> 
<p><strong><span style="color:#000000;">数据成员多为私有的，要对它们进行初始化，必须用一个公有函数来进行。C++提供了</span><span style="color:#ff0000;">构造函数</span><span style="color:#000000;">来处理类对象的初始化问题。</span><span style="color:#fe2c24;">同时这个函数应该在且仅在定义对象时自动执行一次</span><span style="color:#000000;">。称为构造函数(constructor) 。</span></strong></p> 
<p><span style="color:#000000;"><strong>构造函数就是用来在创建对象时初始化对象，为对象数据成员赋初始值。</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>构造函数用途:1)创建对象，2）初始化对象中的属性，3）类型转换。</strong></span></p> 
<p><span style="color:#000000;"><strong>构造函数</strong>是类的一种</span><span style="color:#fe2c24;">特殊的成员函数(在特殊用途中构造函数的访问限定可以定义成私有或保护)</span><br><span style="color:#000000;">，不需要人为调用；而是在建立对象时<strong>自动被执行。</strong></span></p> 
<p><span style="color:#000000;"><strong>特征：</strong><br> 1.C++规定<strong>构造函数的名字必须与类名相同。</strong></span></p> 
<p><span style="color:#000000;">2.<strong>构造函数无函数返回类型说明</strong>。注意是没有而不是void，即什么也不写，</span><span style="color:#fe2c24;">也不可写void</span><span style="color:#000000;">。实际上</span><span style="color:#fe2c24;"><strong>构造函数有返回值</strong></span><span style="color:#000000;">，</span><span style="color:#4da8ee;">返回的就是构造函数所创建的对象。</span></p> 
<p><span style="color:#0d0016;">3.在程序运行时，当新的对象被建立，该对象所属的类构造函数</span><span style="color:#fe2c24;">自动被调用，在该对象生存期中也只调用这一次（由系统调用）</span><span style="color:#0d0016;">。</span></p> 
<p><span style="color:#0d0016;">4.构造函数可以重载。严格地讲，类中可以定义多个构造函数，它们由不同的参数表区分，系统在自动调用时按一般函数重载的规则选一个执行。<br> 5.构造函数可以在类中定义，也可以在类中声明，在类外定义。<br> 6.如果类说明中</span><span style="color:#fe2c24;">没有给出构造函数</span><span style="color:#0d0016;">，则C++编译器</span><span style="color:#fe2c24;">自动给出一个</span><span style="color:#0d0016;">缺省的构造函数.</span><br><span style="color:#000000;">          </span><span style="color:#956fe7;">  类名（void）{     }</span></p> 
<p>只要我们定义了一个构造函数，系统就不会自动生成缺省的构造函数。只要构造函数是无参或只要各参数均有缺省值的，C++编译器都认为是缺省的构造函数，并且<strong>缺省的构造函数只能有一个</strong>。默认构造函数——除了this指针以外没有参数的构造函数，函数体是空的，只能为对象开辟数据成员存储空间，而不能给对象中的数据成员赋初值。<br><span style="color:#000000;">构造函数定义形式:</span></p> 
<p style="text-align:left;"><span style="color:#ff0000;"><strong>类名（形式参数列表）</strong></span></p> 
<p style="text-align:left;"> <span style="color:#ff0000;"><strong>   {  </strong></span><span style="color:#ff0000;"><strong>函数体</strong></span><span style="color:#ff0000;"><strong>  }</strong></span></p> 
<p style="text-align:left;"></p> 
<h3 id="1.%E4%B8%8D%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" style="text-align:left;">1.1不带参数的构造函数</h3> 
<p style="text-align:left;">构造函数可以没有形参。</p> 
<h4 style="text-align:left;">1&gt;在类内定义构造函数：</h4> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
class student
{
public:
	student()
	{
		num = 20060102;
		strcpy(name,"张三");
		score = 85;
	}
	void display()
	{
		cout &lt;&lt; "num:" &lt;&lt; num &lt;&lt; endl;
		cout &lt;&lt; "name:" &lt;&lt; name &lt;&lt; endl;
		cout &lt;&lt; "score:" &lt;&lt; score &lt;&lt; endl;
	}
private:
	int num;
	char name[15];
	float score;
};</code></pre> 
<h4 style="text-align:left;">2&gt;在类外定义构造函数：</h4> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
class student
{
public:
	student();//类外定义构造函数
	void display()
	{
		cout &lt;&lt; "num:" &lt;&lt; num &lt;&lt; endl;
		cout &lt;&lt; "name:" &lt;&lt; name &lt;&lt; endl;
		cout &lt;&lt; "score:" &lt;&lt; score &lt;&lt; endl;
	}
private:
	int num;
	char name[15];
	float score;
};
student::student()
{
	num = 20060102;
	strcpy_s(name, "张三");
	score = 85;
}</code></pre> 
<p style="text-align:left;">只要创建类的新对象，都要执行构造函数。定义<strong>对象</strong>时<strong>自动调用</strong>构造函数</p> 
<p style="text-align:left;">构造函数的主要用途就是：<strong>初始化类的数据成员。</strong></p> 
<p style="text-align:left;"><span style="color:#0000e5;">用构造函数对对象进行初始化形式：</span></p> 
<p style="text-align:left;"><span style="color:#000000;">无参数的构造函数，定义对象的</span><span style="color:#000000;">形式:</span></p> 
<p style="text-align:left;">    <span style="color:#ff0000;">类名</span>  <span style="color:#ff0000;">对象名1</span><span style="color:#ff0000;">，</span><span style="color:#ff0000;">对象名2</span><span style="color:#ff0000;">，</span><span style="color:#ff0000;">......</span> <span style="color:#ff0000;">;</span></p> 
<p style="text-align:left;"><span style="color:#000000;">有参数的构造函数，定义对象的形式：</span></p> 
<p style="text-align:left;"><span style="color:#ff0000;">       类名</span>  <span style="color:#ff0000;">对象名1</span><span style="color:#ff0000;">(</span><span style="color:#ff0000;">实参列表</span><span style="color:#ff0000;">)</span><span style="color:#ff0000;">，对象名2</span><span style="color:#ff0000;">(</span><span style="color:#ff0000;">实参列表</span><span style="color:#ff0000;">)</span><span style="color:#ff0000;">......</span> <span style="color:#ff0000;">;</span></p> 
<p style="margin-left:.01in;text-align:left;"><span style="color:#000000;">构造函数是一种成员函数，它具有一般成员函数的特点。</span></p> 
<p style="margin-left:.01in;text-align:left;"><span style="color:#000000;">构造函数的名称与其类名相同</span><span style="color:#000000;">。</span></p> 
<p style="margin-left:.01in;text-align:left;"><span style="color:#000000;">一个类中可定义一个或多个构造函数。</span></p> 
<p style="margin-left:.01in;text-align:left;"><span style="color:#0000e5;">构造函数说明：</span></p> 
<p style="margin-left:.01in;text-align:left;"><span style="color:#000000;">1)</span> <span style="color:#000000;">构造函数是在创建对象时自动执行的，而且只执行一次，并先于其他成员函数执行。构造函数不需要人为调用，也不能被人为调用。</span></p> 
<p style="margin-left:.01in;text-align:left;"><span style="color:#000000;">2)</span> <span style="color:#000000;">构造函数一般声明为公有的</span><span style="color:#000000;">(public)，因为创建对象通常是在类的外部进行的。</span></p> 
<p style="margin-left:.01in;text-align:left;"><span style="color:#000000;">3) 在构造函数的函数体中不仅可以对数据成员初始化</span>,<span style="color:#000000;">而且可以包含其他任意功能的语句，但是一般不提</span><span style="color:#000000;">倡在构造函数中加入与初始化无关的内容。</span></p> 
<p style="margin-left:.01in;text-align:left;"><span style="color:#000000;">用</span><span style="color:#ff0000;">不</span><span style="color:#ff0000;">带参数的构造函数</span><span style="color:#000000;">对数据成员初始化，每一个对象的数据成员都得到同一组初值。</span></p> 
<h3 id="2.%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" style="margin-left:.01in;text-align:left;">1.2带参数的构造函数</h3> 
<p>用带参数的构造函数对不同对象初始化</p> 
<h4>1&gt;在类内定义构造函数</h4> 
<pre><code class="language-cpp">class  student 
          {  public:
                 student(int  n, string m, float s)
                     {  num = n;
                         name = m;
                         score = s；
                      } 
                 void display( )                             
                    {  cout&lt;&lt;”num: ”&lt;&lt; num&lt;&lt;endl;       
                        cout&lt;&lt;”name: ”&lt;&lt; name&lt;&lt;endl;   
                        cout&lt;&lt;”score: ”&lt;&lt; score &lt;&lt;endl;
                     }
              private:
                  int  num; 
                  string  name;    // 或char *name;
                  float  score;
         } ;</code></pre> 
<h4>2&gt;在类外定义构造函数</h4> 
<pre><code class="language-cpp">class  student 
          {  public:
                 student(int  n, string m, float s)；
                 void display( )                             
                    {  cout&lt;&lt;”num: ”&lt;&lt; num&lt;&lt;endl；      
                        cout&lt;&lt;”name: ”&lt;&lt; name&lt;&lt;endl； 
                        cout&lt;&lt;”score: ”&lt;&lt; score &lt;&lt;endl；
                     }
              private:
                  int  num；
                  string  name；   // 或 char *name；
                  float  score；
           } ; 
       student::student(int  n, string m, float s )
          {  num = n；
              name = m；  
              score = s；
           } </code></pre> 
<h3 id="3.%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E7%94%A8%E5%8F%82%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A1%A8%E5%AF%B9%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96">1.3在构造函数中用参数初始化表对数据成员初始化</h3> 
<p><span style="color:#000000;">构造函数可以使用</span><span style="color:#ff0000;">参数</span><span style="color:#ff0000;">初始化表</span><span style="color:#000000;">对数据成员进行初始化，不在函数体内，而在函数首部实现。</span></p> 
<p><span style="color:#000000;">一般形式为：</span></p> 
<p><span style="color:#ff0000;">类名（形式参数列表）：构造函数初始化</span></p> 
<p><span style="color:#ff0000;">         {   函数体</span></p> 
<p><span style="color:#ff0000;">          }</span></p> 
<p><span style="color:#000000;"><strong>与其他的成员函数一样，构造函数可以定义在类的内部或外部，但</strong></span><span style="color:#ff0000;"><strong>带</strong></span><span style="color:#ff0000;"><strong>初始化表</strong></span><span style="color:#ff0000;"><strong>的构造函数</strong></span><span style="color:#ff0000;"><strong>只在</strong></span><span style="color:#ff0000;"><strong>类体中</strong></span><span style="color:#ff0000;"><strong>定义中</strong></span><span style="color:#000000;"><strong>。</strong></span></p> 
<pre><code class="language-cpp">class  student 
          {  public:
               student(int  n, string m, float s)：num(n),name(m),score(s){ }               
                void display( )                             
                   {  cout&lt;&lt;”num: ”&lt;&lt; num&lt;&lt;endl;       
                       cout&lt;&lt;”name: ”&lt;&lt; name&lt;&lt;endl;   
                       cout&lt;&lt;”score: ”&lt;&lt; score &lt;&lt;endl;
                    }
              private:
                  int  num; 
                  string  name;    // 或char *name;
                  float  score;
         } ；
</code></pre> 
<p style="margin-left:0in;text-align:left;"><span style="color:#ff0000;"><strong>注意：</strong></span><span style="color:#000000;"><strong>如果数据成员是数组，就不能在参数初始化表对其进行初始化，应在函数体中用语句对其赋值。</strong></span></p> 
<p style="margin-left:0in;text-align:left;"><span style="color:#000000;"><strong>初始化是在构建对象的时候赋值，赋值是在构建完成后才会赋值。</strong></span></p> 
<pre><code class="language-cpp">class  student 
          {  public:
              student(int  n, float s, char m[ ] )：num(n), score(s)//此处是初始化              
                 {  strcpy(name, m);//函数体中的叫赋值  } 
                 void display( )                             
                    {  cout&lt;&lt;”num: ”&lt;&lt; num&lt;&lt;endl;       
                        cout&lt;&lt;”name: ”&lt;&lt; name&lt;&lt;endl;   
                        cout&lt;&lt;”score: ”&lt;&lt; score &lt;&lt;endl;
                     }
              private:
                  int  num; 
                  char  name[15];    
                  float  score;
          } ；
</code></pre> 
<p><strong>初始化列表的顺序，并不是对象中成员初始化表的顺序，是<span style="color:#fe2c24;">按照类中属性声明的顺序</span>构建</strong></p> 
<pre><code class="language-cpp">class  Complex
{
private:
	int Real;
	int Image;
public:
	Complex(int x) :Real{Image},Image{x}{}
	
	 void Print()
	 {
		 cout &lt;&lt; Real &lt;&lt; " " &lt;&lt; Image &lt;&lt; endl;
	 }
};
int main()
{
	Complex c1(10);

	c1.Print();

	return 0;
}</code></pre> 
<p><img alt="" height="103" src="https://images2.imgbox.com/fc/d8/NUGGJlc4_o.png" width="250"></p> 
<p><img alt="" height="497" src="https://images2.imgbox.com/d7/83/AiZM9IVJ_o.png" width="825"></p> 
<p></p> 
<p></p> 
<h3 id="%E4%BA%8C%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">1.4构造函数重载</h3> 
<p><span style="color:#000000;">与一般的成员函数一样，在一个类中</span><span style="color:#000000;">也</span><span style="color:#000000;">可以定义多个构造函数，即</span><span style="color:#ff0000;">构造函数重载</span><span style="color:#000000;">，只要每个构造函数的形参列表是唯一的。一个类的构造函数数量是没有限制的。</span></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt; 
using namespace std;
class  student 
    {  public:
           student( );
           student(int  n, string m, float s)：num(n),name(m),score(s){ }                
       void display( ) ;                            
       private:
           int  num; 
           string  name;    
           float  score;
    } ； 
student::student( )
   {  num = 20060102；
      name = ”张三”；  
      score = 85；
   } 
void student::display( )                            
   {  cout&lt;&lt;”num: ”&lt;&lt; num&lt;&lt;endl;       
       cout&lt;&lt;”name: ”&lt;&lt; name&lt;&lt;endl;   
       cout&lt;&lt;”score: ”&lt;&lt; score &lt;&lt;endl;
   }
int main( )
   { student stu1;
      stu1.display( );
      student stu2( 20060103，“李四”， 88);
      stu2.display( );
      return 0;
   }
</code></pre> 
<div style="margin-left:.51in;text-align:left;"> 
 <strong><span style="color:#000000;">构造函数使用说明：</span></strong> 
</div> 
<p style="margin-left:.01in;text-align:left;"><span style="color:#000000;">  1）在建立对象时不必给出实参的构造函数，称为</span><span style="color:#ff0000;">默认</span><span style="color:#ff0000;">构造函数</span><span style="color:#000000;">。无参构造函数属于默认构造函数。一个类只能有一个默认构造函数。</span></p> 
<p style="margin-left:.01in;text-align:left;"><span style="color:#000000;">  2）如果未定义构造函数，系统会自动提供一个默认构造函数，但它的函数体是空的，不起初始化作用。</span></p> 
<p style="margin-left:.01in;text-align:left;"><span style="color:#000000;">  3）尽管在一个类中可以包含多个构造函数，但是对于</span><strong><span style="color:#000000;">一个对象来说, 建立对象时只执行其中一个，并非每</span></strong><strong><span style="color:#000000;">个构造函数都被执行。</span></strong> </p> 
<h3 id="%E4%B8%89%E3%80%81%E5%B8%A6%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" style="margin-left:.01in;text-align:left;">1.5带默认参数的构造函数</h3> 
<p style="margin-left:.01in;text-align:left;"><span style="color:#000000;">在实际应用中，有些构造函数的参数值通常是不变的，只是在一些特殊情况下才需改变其值——可定义</span><span style="color:#ff0000;">带</span><span style="color:#ff0000;">默认</span><span style="color:#ff0000;">参数的构造函数</span><span style="color:#000000;">。</span></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

class  student
{
public:
	student(int  n = 20060101, string m = "张三", float s = 85);
	void display();
private:
	int  num;
	string  name;
	float  score;
};
student::student(int  n, string m, float s)
{
	num = n;
	name = m;
	score = s;
}
void student::display()
{
	cout &lt;&lt; "num: " &lt;&lt; num &lt;&lt; endl;
	cout &lt;&lt; "name:" &lt;&lt; name &lt;&lt; endl;
	cout &lt;&lt; "score:" &lt;&lt; score &lt;&lt; endl;
}
int main()
{
	student stu1;
	stu1.display();
	student stu2(20060103,"李四");
	stu2.display();
	return 0;
}</code></pre> 
<div style="margin-left:.51in;text-align:left;"> 
 <strong><span style="color:#000000;">构造函数默认参数的说明:</span></strong> 
</div> 
<p style="margin-left:.01in;text-align:left;">   <span style="color:#000000;">1</span><span style="color:#000000;">）</span><span style="color:#000000;">必须在类的内部指定构造函数的默认参数，不能在类外部指定默认参数。</span></p> 
<pre><code class="language-cpp">class  student 
    {  public:
         student( int  n , string m , float s  );                
         void display( ) ;                            
         private:
            int  num; 
            string  name;    
            float  score;
     } ； 
student::student( int n=20060101, string m=”张三”, float s=85  )
     {  num = n；name = m；  score = s； }    //错误</code></pre> 
<p style="margin-left:.25in;text-align:justify;"><span style="color:#000000;">2</span><span style="color:#000000;">）</span><span style="color:#000000;">如果构造函数的全部参数都指定了默认值，则在定</span><span style="color:#000000;">义对象时可以给一个或几个实参，也可以不给出实参。这时，就与无参数的</span><span style="color:#ff0000;">构造函数有歧义</span><span style="color:#000000;">了。</span></p> 
<p style="margin-left:.25in;text-align:justify;"></p> 
<p style="margin-left:.25in;text-align:justify;"><span style="color:#000000;">3</span><span style="color:#000000;">）</span><span style="color:#000000;">在一个类中定义了带默认参数的构造函数后，不能再定义与之有冲突的重载构造函数。</span></p> 
<p style="margin-left:.25in;text-align:justify;"><span style="color:#ff0000;">一般地，不应同时使用构造函数的重载和带默认参数的构造函数</span><span style="color:#ff0000;">。</span></p> 
<h3 style="margin-left:.25in;text-align:justify;">1.6用构造函数实现初始化方法总结</h3> 
<p><strong>  1</strong><span style="color:#000000;"><strong>）在类中定义的构造函数的函数体中对数据进行赋初值。</strong></span></p> 
<p style="text-align:left;"><span style="color:#000000;"><strong>  2</strong></span><span style="color:#000000;"><strong>）用带参数的</strong></span><span style="color:#000000;"><strong>构造函数，可以使同类的不同对象中的数</strong></span><span style="color:#000000;"><strong>据具有不同的初值。</strong></span></p> 
<p style="text-align:left;"><span style="color:#000000;"><strong>  3</strong></span><span style="color:#000000;"><strong>）在</strong></span><span style="color:#000000;"><strong>构造函数中用参数初始化表对数据赋初值。</strong></span></p> 
<p style="text-align:left;"><span style="color:#000000;"><strong>  4</strong></span><span style="color:#000000;"><strong>）在定义</strong></span><span style="color:#000000;"><strong>构造函数时可以使用默认参数。</strong></span></p> 
<p style="text-align:left;"><span style="color:#000000;"><strong>  5</strong></span><span style="color:#000000;"><strong>）</strong></span><span style="color:#000000;"><strong>构造函数可以重载，即在一个类中定义多个同名的</strong></span><span style="color:#000000;"><strong>构造函数。</strong></span></p> 
<p style="text-align:left;"><span style="color:#ff0000;"><strong>        一般不应同时使用有默认参数的构造函数和构造函数的重载。</strong></span></p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

class CGoods
{
private:
	enum{LEN=20};//枚举类型大小不计入结构体大小中
private:
	char Name[LEN];//直接将LEN替换为20
	int Amount;
	float Price;
	float Total;
public:
	CGoods(const char*name,int amount=0,float price=0.0):Amount(amount),Price(price),Total(amount*price)
	{
		strcpy_s(Name, name);
	}
	CGoods(){}

	void GoodsInfo()const
	{
		cout &lt;&lt; " Name " &lt;&lt; Name &lt;&lt; " Amount: " &lt;&lt; Amount &lt;&lt; " Price " &lt;&lt; Price &lt;&lt; " Total_value: " &lt;&lt; Total &lt;&lt; endl;
	}
};
int main()
{
	CGoods ca;
	CGoods car("bya", 10, 12.00);
	CGoods book("c++", 10, 128.00);
	car.GoodsInfo();
	book.GoodsInfo();
	return 0;
}</code></pre> 
<h3 style="text-align:left;">1.7 对象的定义</h3> 
<p style="text-align:left;">下列定义的对象哪一个是错误的：</p> 
<pre><code class="language-cpp">class  Complex
{
public:
	 Complex(){}
	 Complex(int r,int i):Real(r),Image(i){}
	 void Print()
	 {
		 cout &lt;&lt; Real &lt;&lt; " " &lt;&lt; Image &lt;&lt; endl;
	 }
	

private:
	int Real;
	int Image;
};
int main()
{
	Complex c1;
	Complex c2();
	Complex c3(12, 23);
	Complex c4 = Complex(1, 2);//直接将创建的对象给c4，没有借助中间对象，相当于Complex c4(1,2);
    c4 = Complex(3,4);//此种情况是创建一个无名对象，将无名对象的值给c4，因为c4此时存在，如果直接将构建的值给c4，那么c4就被构建了两次，这是不允许的
	Complex c5{};
	Complex c6{ 1,2 };
	c1.Print();

	return 0;
}</code></pre> 
<p style="text-align:left;"><strong>定义的c2不是对象</strong></p> 
<p style="text-align:left;"><img alt="" height="114" src="https://images2.imgbox.com/78/6e/MiyZTn6G_o.png" width="451"></p> 
<p> c2系统认为是函数的声明，系统将 <strong>类型 名称 <span style="color:#fe2c24;">（）</span>；</strong>认为是函数的声明</p> 
<p>如何想用（）初始化对象，要么就要带默认值（eg：c3），不带默认值就不要写括号(c1)</p> 
<h3 style="text-align:left;">1.8构造函数的用途——类型转换</h3> 
<pre><code class="language-cpp">class Int
{
private:
	int value;
public:
	Int(int x=0):value(x){}
	void Print()const { cout &lt;&lt; value &lt;&lt; endl; }
};
int main()
{
	Int a(10);//自己设计的类型
	a.Print();//10
	int x = 100;//系统内置类型
	a = x;//将int类型的x赋值给Int类型的对象a
	//隐式转换，用x的值构建一个临时对象，将这个临时对象赋值给a，赋值完成后，临时对象销毁，此临时对象称为将亡值
	a = (Int)x;//显式转换
	a.Print();//100
	
	return 0;
}</code></pre> 
<p>把一个变量给对象时，看起来像是把变量给对象赋值，实则不然。</p> 
<p><strong>把一个变量给对象，<span style="color:#fe2c24;">先调动对象的构造函数</span>，<span style="color:#fe2c24;">构建一个临时量</span>，再把这个临时量赋值给对象</strong>。赋值完成后，临时量就会销毁，此临时量也称作将亡值。</p> 
<p><span style="color:#4da8ee;"><strong>关键字explicit</strong></span></p> 
<p><span style="color:#4da8ee;"><strong>不允许隐式转化</strong></span></p> 
<p><strong>构造函数要想可以</strong><span style="color:#fe2c24;"><strong>类型转换，必须只有一个参数或者参数有默认值。</strong></span></p> 
<pre><code class="language-cpp">class Int
{
private:
	int value;
public:
	Int(int x,int y):value(x+y){}
	void Print()const { cout &lt;&lt; value &lt;&lt; endl; }
};
int main()
{
	Int a(10,20);
	a.Print();
	int x = 1, y = 2;
	a = x, y;//error
	a = (Int)(x, y);//强转也不行
	
	return 0;
}</code></pre> 
<p style="text-align:left;">构造函数有了默认值就可以了，就剩一个没默认值的参数</p> 
<pre><code class="language-cpp">class Int
{
private:
	int value;
public:
	Int(int x,int y=0):value(x+y){}
	void Print()const { cout &lt;&lt; value &lt;&lt; endl; }
};
int main()
{
	Int a(10,20);
	a.Print();//30
	int x = 1, y = 2;
	a = x, y;
    //强转，只能是单参
	a = (Int)(x, y);//构造函数此时单参，只需要传一个参数，逗号表达式的值为最右边的值
	a.Print();//2
    //构建一个对象给a
    a = Int(x, y);
    a.Print();//3
    
	return 0;
}</code></pre> 
<h2 style="text-align:left;">二、析构函数</h2> 
<p>当对象脱离其作用域时（如对象所在的函数已调用完毕），系统会<strong>自动执行</strong><span style="color:#fe2c24;"><strong>析构函数</strong></span></p> 
<p>析构函数也是一种<strong>特殊的成员函数</strong>，执行的是与构造函数相反的操作——<strong>通常用作执行一些清理任务（如释放对象所占用得内存等）。</strong></p> 
<p><strong>析构函数定义形式:</strong></p> 
<p><strong><span style="color:#fe2c24;">～类名( )<br>     {<!-- --></span></strong></p> 
<p><strong><span style="color:#fe2c24;">        函数体</span></strong></p> 
<p><strong><span style="color:#fe2c24;">    }</span></strong></p> 
<h3><span style="color:#4da8ee;">2.1析构函数的特点:</span></h3> 
<p>1.<strong>析构函数与构造函数的名字相同</strong>,但在其前面加上“<span style="color:#fe2c24;"><strong>~</strong></span>”。</p> 
<p>2.析构函数<span style="color:#fe2c24;"><strong>没有任何参数,没有返回值</strong>，<strong>也没有返回类型不能重载</strong></span></p> 
<p>3.<span style="color:#fe2c24;"><strong>一个类中只能有一个析构函数</strong></span>。</p> 
<p>4.对象销毁时，系统自动调用析构函数。</p> 
<p>5.如果类说明中没有给出析构函数，则C++编译器自动给出一个缺省的析构函数。</p> 
<p>eg:    <strong>~类型名称（）{}</strong></p> 
<pre><code class="language-cpp">class student 
{
public:
	student(int n, string m, float s)
	{
		num = n;
		name = m;
		score = s;
	}
	~student()
	{}
	void display()
	{
		
		cout &lt;&lt; "num:" &lt;&lt; num &lt;&lt; endl;
		cout &lt;&lt; "name:" &lt;&lt; name &lt;&lt; endl;
		cout &lt;&lt; "score:" &lt;&lt; score &lt;&lt; endl;
	}
private:
	int num;
	string name;
	float score;
};
int main()
{
	student stu1(2020, "zhangsan", 80);
	stu1.display();
	student stu2(2021, "lisi", 90);
	stu2.display();
	return 0;
}</code></pre> 
<h3>2.2析构函数说明:</h3> 
<p>1.每个类必须有一个析构函数，<strong>如果未定义析构函数，则系统自定义一个析构函数;</strong><br> 2.对于大多数类而言，不需要显式地编写析构函数，尤其是具有构造函数的类不一定需要定义自己的析构函数。<strong>析构函数通常用于释放在构造函数或在对象生命期内获取的资源(如动态分配的内存)。</strong></p> 
<h3>2.3何时调用析构函数：</h3> 
<p>1)对象在程序运行超出其作用域时自动撤销,撤销时自动调用该对象的析构函数。如函数中的非静态局部对象。<br> 2）如果用new运算动态地建立了一个对象，当用delete运算释放该对象时,调用该对象的析构函数。</p> 
<h3>2.4调用构造函数和析构函数的顺序</h3> 
<p>在使用构造函数和析构函数时，需要特别注意对它们的调用时间和调用次序。<br> 构造函数和析构函数的调用很像一个<span style="color:#fe2c24;"><strong>栈的先进后出</strong></span>,调用析构函数的次序正好与调用构造函数的次序相反。<strong><span style="color:#fe2c24;">最先被调用的构造函数</span>,其对应的(同一对象中的）<span style="color:#fe2c24;">析构函数最后被调用</span>,而最后被调用的构造函数，其对应的析构函数最先被调用。</strong></p> 
<p><span style="color:#ff0000;"><strong>先构造的后析构，后构造的先析构。</strong></span><br><img alt="" height="340" src="https://images2.imgbox.com/89/83/sHC5cd6E_o.png" width="1200"></p> 
<p></p> 
<h2>三、对象的生存期</h2> 
<h3>3.1 局部对象</h3> 
<p>1&gt;对于局部定义的对象，每当程序控制流到达该对象定义处时，调用构造函数。当程序控制走出该局部域时，则调用析构函数。</p> 
<pre><code class="language-cpp">
class  Complex
{
private:
	int Real;
	int Image;
public:
	Complex(int r=0,int i=0) :Real(r), Image(i)
	{
		cout &lt;&lt; "Create Complex " &lt;&lt; endl;
	}
	~Complex() {
		cout &lt;&lt; "Destory Complex" &lt;&lt; endl;
	}
	void Ptint()const
	{
		cout &lt;&lt; "Real: " &lt;&lt; Real &lt;&lt; "Image: " &lt;&lt; Image &lt;&lt; endl;
	}


	void Print()
	{
		cout &lt;&lt; Real &lt;&lt; " " &lt;&lt; Image &lt;&lt; endl;
	}
};
void fun()
{
	Complex c1(1, 2);
	cout &lt;&lt; "input block" &lt;&lt; endl;
	{
		Complex c2(4, 5);
	}
	cout &lt;&lt; "out block" &lt;&lt; endl;
	return;
}</code></pre> 
<p><img alt="" height="308" src="https://images2.imgbox.com/d5/29/Jpu8J8yz_o.png" width="645"></p> 
<p></p> 
<p>2&gt;对于静态局部定义的对象，在程序控制首次到达该对象定义处时，调用构造函数。当整个程序结束时调用析构函数。</p> 
<p>单纯的局部对象，tmp对象一直在构建析构构建析构，总共10次</p> 
<pre><code class="language-cpp">class  Complex
{
private:
	int Real;
	int Image;
public:
	Complex(int r=0,int i=0) :Real(r), Image(i)
	{
		cout &lt;&lt; "Create Complex " &lt;&lt; endl;
	}
	~Complex() {
		cout &lt;&lt; "Destory Complex" &lt;&lt; endl;
	}
	void Ptint()const
	{
		cout &lt;&lt; "Real: " &lt;&lt; Real &lt;&lt; "Image: " &lt;&lt; Image &lt;&lt; endl;
	}


	void Print()
	{
		cout &lt;&lt; Real &lt;&lt; " " &lt;&lt; Image &lt;&lt; endl;
	}
};
void fun()
{
	Complex tmp(1, 2);
}

int main()
{
	for (int i = 0; i &lt; 10; ++i)
	{
		fun();
	}
	return 0;
}</code></pre> 
<p><img alt="" height="338" src="https://images2.imgbox.com/88/3d/TZoPZmN7_o.png" width="184"></p> 
<p>当fun中的对象为静态局部对象时</p> 
<pre><code class="language-cpp">void fun()
{
	static Complex tmp(1, 2);//静态对象，在数据区，有一个标记，运行时下次再遇到查看标记发小存在就不再构建
}

int main()
{
	for (int i = 0; i &lt; 10; ++i)
	{
		fun();
	}
	return 0;
}
</code></pre> 
<p> <img alt="" height="76" src="https://images2.imgbox.com/c7/fd/34s2IvwY_o.png" width="313"></p> 
<p> 在函数第一次调用时只构建一次，也析构一次。</p> 
<h3>3.2 全局对象</h3> 
<p>对全局定义的对象，当程序进入入口函数main之前对象就已经定义，这时要调用构造函数。整个程序结束时调用析构函数。</p> 
<p>例：下列对象a,b,c，哪一个先构建</p> 
<pre><code class="language-cpp">class Int
{
private:
	int value;
public:
	Int(int x = 0) :value(x) 
	{
		cout &lt;&lt; "Create Int： " &lt;&lt; value&lt;&lt;endl;
	}
	~Int()
	{
		cout &lt;&lt; "Destory Int： " &lt;&lt; value &lt;&lt; endl;
	}
};
Int a(1);
int main()
{
	Int b(2);

	return 0;
}
Int c(3);</code></pre> 
<p><img alt="" height="120" src="https://images2.imgbox.com/1a/13/KX0r7vpV_o.png" width="367"></p> 
<p> </p> 
<p>我们可以看到，a,c,b按照此顺序构建</p> 
<p> a和c是全局对象，b是主函数中的对象，<span style="color:#fe2c24;"><strong>在进入主函数之前，全局变量和全局对象就要构建出来，</strong></span>进入主函数之后，主函数中的对象才会被构建</p> 
<h3>3.3 动态创建的对象</h3> 
<p>动态创建的对象,使用new创建对象,delete释放对象.</p> 
<h3>malloc申请空间</h3> 
<h4>1&gt;下列程序可以运行成功吗？show可以被cp指针调用吗</h4> 
<pre><code class="language-cpp">class  Complex
{
private:
	int Real;
	int Image;
public:
	Complex(int r = 0, int i = 0) :Real(r), Image(i)
	{
		cout &lt;&lt; "Create Complex " &lt;&lt; endl;
	}
	~Complex() {
		cout &lt;&lt; "Destory Complex" &lt;&lt; endl;
	}
	void Print()const
	{
		cout &lt;&lt; "Real: " &lt;&lt; Real &lt;&lt; "Image: " &lt;&lt; Image &lt;&lt; endl;
	}


	void show()
	{
		cout &lt;&lt; "Complex::show " &lt;&lt; endl;
	}
};
int main()
{
	Complex* cp = nullptr;
	cp-&gt;show();
	

	return 0;
}</code></pre> 
<p>//show(cp),传的是个空指针，this指针为nullptr，但是<strong>show方法中<span style="color:#fe2c24;">没有用到this指针</span></strong>，<strong>所以可以调用show</strong></p> 
<pre><code class="language-cpp">class  Complex
{
private:
	int Real;
	int Image;
public:
	Complex(int r = 0, int i = 0) :Real(r), Image(i)
	{
		cout &lt;&lt; "Create Complex " &lt;&lt; endl;
	}
	~Complex() {
		cout &lt;&lt; "Destory Complex" &lt;&lt; endl;
	}
	//void Print( Complex *const this)const
	void Print()const
	{
		//cout &lt;&lt; "Real: " &lt;&lt; this-&gt;Real &lt;&lt; "Image: " &lt;&lt; this-&gt;Image &lt;&lt; endl;
		cout &lt;&lt; "Real: " &lt;&lt; Real &lt;&lt; "Image: " &lt;&lt; Image &lt;&lt; endl;
	}


	void show()
	{
		cout &lt;&lt; "Complex::show " &lt;&lt; endl;
	}
};
int main()
{
	Complex* cp = nullptr;
	cp-&gt;Print();
	//Print(cp),this指针为nullptr

	return 0;
}</code></pre> 
<p></p> 
<h4>2&gt;那么cp可以调用print方法吗？</h4> 
<p>cp-&gt;print();</p> 
<p><img alt="" height="317" src="https://images2.imgbox.com/ea/b6/M5fThxdt_o.png" width="592"></p> 
<p>我们可以看到并不能调用成功。</p> 
<p><strong>Print方法中含有this指针，此时cp为nullptr,this指针为空，0地址不允许操作，</strong></p> 
<h4>3&gt;使用malloc申请空间的对象调用print方法可以成功吗</h4> 
<pre><code class="language-cpp">int main()
{
	Complex* cp = (Complex*)malloc(sizeof(Complex));
	if (cp == nullptr)return 1;
	cp-&gt;Print();


	return 0;
}</code></pre> 
<p><img alt="" height="126" src="https://images2.imgbox.com/20/ca/US1cjeti_o.png" width="446"></p> 
<p>我们可以看到可以调用print方法，但是值为随机值。</p> 
<p> 有空间但是没对象，</p> 
<p>malloc给cp申请了4字节（X86）的空间，Print(cp);cp指向申请的空间，this指针也指向这个堆区空间，但是没有对象，所以值为随机值。</p> 
<p><strong>给cp构建一个对象：</strong></p> 
<pre><code>int main()
{
	Complex c1(1, 2);
	Complex* cp = (Complex*)malloc(sizeof(Complex));
	if (cp == nullptr)return 1;
	cp-&gt;Print();
	*cp = c1;
	cp-&gt;Print();

	return 0;
}</code></pre> 
<p> 此时cp的值就不为随机值了</p> 
<p><img alt="" height="159" src="https://images2.imgbox.com/8b/e6/0ILaJ5SK_o.png" width="617"></p> 
<p><strong>不允许拿对象给空间赋值，<span style="color:#fe2c24;">可以在空间中构建对象</span></strong><span style="color:#fe2c24;">，但不允许用对象给空间赋值</span>。</p> 
<p>如果拿对象给空间赋值，容易出问题，eg：virtual虚函数</p> 
<pre><code class="language-cpp">virtual void Print()const
	{

		cout &lt;&lt; "Real: " &lt;&lt; Real &lt;&lt; "Image: " &lt;&lt; Image &lt;&lt; endl;
	}</code></pre> 
<p><img alt="" height="204" src="https://images2.imgbox.com/c3/ba/p8TaGxR0_o.png" width="772"></p> 
<h3>new申请空间 </h3> 
<pre><code class="language-cpp">class  Complex
{
private:
	int Real;
	int Image;
public:
	Complex(int r = 0, int i = 0) :Real(r), Image(i)
	{
		cout &lt;&lt; "Create Complex " &lt;&lt; endl;
	}
	~Complex() {
		cout &lt;&lt; "Destory Complex" &lt;&lt; endl;
	}
	virtual void Print()const
	{
		cout &lt;&lt; "Real: " &lt;&lt; Real &lt;&lt; "Image: " &lt;&lt; Image &lt;&lt; endl;
	}


	void show()
	{
		cout &lt;&lt; "Complex::show " &lt;&lt; endl;
	}
};

int main()
{
	Complex* cp = new Complex(1, 2);//new 1.自动计算类型大小 2.调用malloc从堆区申请空间 3.调动构建函数构建对象 4.把对象地址给cp
	cp-&gt;Print();
	delete cp;//1.调用析构函数析构cp 2.将cp的堆空间还给系统，cp此时变成失效指针，main函数结束时，cp栈区空间才会释放
    cp = nullptr;
	return 0;
}</code></pre> 
<p></p> 
<p></p> 
<h2>四、new三种用法：</h2> 
<h3>4.1作为运算法(关键字)</h3> 
<p>p = new Pointer(10,20);//p是指针，Pointer 是类对象</p> 
<p>new<strong>调用malloc</strong>在heap申请空间，调用Pointer类型在空间构建对象，返回。</p> 
<h3>4.2定位（构建）new</h3> 
<p><span style="color:#fe2c24;"><strong>只要给定位new一个地址，就可以在此地址创建对象。</strong></span></p> 
<p>new(s) Pointer(12,23);//在<strong>s指向的空间调动构造函数，构建对象</strong></p> 
<p>delete p;//delete调动析构函数释放空间，再调用free销毁。</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
class Object
{
private:
	int val;
public:
	Object(int x)
	{
		val = x;
		cout &lt;&lt; "Create:" &lt;&lt; val &lt;&lt; endl;
	}

};

Object ObjA(1);
int main()
{
	Object Objb(2);
}
Object objc(3);</code></pre> 
<p><img alt="" height="161" src="https://images2.imgbox.com/0b/7a/ozEyCQKj_o.png" width="789"></p> 
<p>进入主函数之前就要为全局对象构建，再进入主函数编译从上到下，</p> 
<pre><code class="language-cpp">int main()
{
	int a = 10;
	int b(10);//相当于调动了一个带参数的构造函数，拿10构建b
	/*伪构造函数*/
	int c = int(10);//类型名+（），调动其构造函数，构建c对象
	int* p = new int(20);//new申请int空间，调动int的构造函数构造整型
}</code></pre> 
<p>一个对象只能被构建一次，但可借助new实现二次构建，借助定位new可以对任何对象重新构建。</p> 
<pre><code class="language-cpp">class  Complex
{
public:
	 Complex(){}
	 Complex(int r,int i):Real(r),Image(i){}
	 void Print()
	 {
		 cout &lt;&lt; Real &lt;&lt; " " &lt;&lt; Image &lt;&lt; endl;
	 }
	

private:
	int Real;
	int Image;
};
int main()
{
	Complex c1;
	Complex c2(12, 23);
    c1(23,34);//erro,对象只能构建一次
	new(&amp;c1)Complex(23, 34);

	c1.Print();
	c2.Print();
	return 0;
}</code></pre> 
<p></p> 
<h3>4.3作为一个函数</h3> 
<pre><code class="language-cpp"> 
int main()
{
	/* operator new，函数方法的使用，和malloc一样，需要sizeof计算空间大小，需要对返回值强转*/
	int* ip = new int(10);
	int* is = (int*)::operator new(sizeof(int));
	/*operator new 和 malloc 的不同*/
	//malloc申请空间空间不足会返回空指针
	//operator new 申请空间失败会抛出异常throw bad_alloc，所以使用new或operator new 判断是否申请成功不能用判空判断
 
	//可以使用nothrow，让new或者operator new申请空间失败不抛出异常，返回一个空指针
	int* ip = new(std::nothrow) int(10);
	int* is = (int*)::operator new(sizeof(int),std::nothrow);
 
	delete ip;//new 申请的空间用delete释放
	::operator delete(is);//operator new 申请的空间需要用::operator delete释放
 
	return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c5b56c2dbf486e314e0bab5fe60ff9e9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">测试用例设计</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9dcc6f174c92421f73b010170a146d90/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java中数组元素的删除</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>