<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>贝叶斯核机器回归拓展R包：bkmrhat - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="贝叶斯核机器回归拓展R包：bkmrhat" />
<meta property="og:description" content="1.摘要 bkmrhat包是用于扩展bkmr包的贝叶斯核机器回归（Bayesian Kernel Machine Regression, BKMR）分析工具，支持多链推断和诊断。该包利用future, rstan, 和coda包的功能，提供了在贝叶斯半参数广义线性模型下进行identity链接和 probit 链接的方法。
主要功能包括：多链合并、继续采样、诊断和预测等。包内包含多种函数，如kmbayes_parallel用于并行计算多个链，kmbayes_combine和kmbayes_combine_lowmem用于合并链，as.mcmc.bkmrfit将bkmrfit对象转换为MCMC对象以进行诊断，以及predict.bkmrfit用于生成预测。
2. 函数介绍 2.1 包介绍 提供了扩展bkmr包的贝叶斯核机器回归工具支持多链推断和诊断利用future, rstan, coda包 2.2 as.mcmc.bkmrfit 函数书写格式：as.mcmc()将bkmrfit对象转换为coda包的MCMC对象coda 包支持许多不同类型的单链 MCMC 诊断，包括 geweke.diag、traceplot 和 effectiveSize。还可以使用后总结，例如 HPDinterval 和summary.mcmc。用于进行单链MCMC诊断和后验概括 示例代码1 # 加载bkmrhat包 library(bkmrhat) # 例子 set.seed(111) #设置随机数种子 library(coda) #加载coda包 # 加载bkmr包 library(bkmr) # 生成模拟数据 dat &lt;- bkmr::SimData(n = 50, M = 4) # 提取数据 y &lt;- dat$y Z &lt;- dat$Z X &lt;- dat$X set.seed(111) # 运行模型 fitkm &lt;- kmbayes(y = y, Z = Z, X = X, iter = 500, verbose = FALSE, varsel = FALSE) # 应用as." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/e17a805592764b367d10d27fa4a0a12a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-26T13:01:10+08:00" />
<meta property="article:modified_time" content="2024-02-26T13:01:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">贝叶斯核机器回归拓展R包：bkmrhat</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="margin-left:0cm;"><strong><code>1.摘要</code></strong></h2> 
<blockquote> 
 <p style="margin-left:0cm;"><code>bkmrhat</code>包是用于扩展<code>bkmr</code>包的贝叶斯核机器回归（Bayesian Kernel Machine Regression, BKMR）分析工具，支持多链推断和诊断。该包利用<code>future</code>, <code>rstan</code>, 和<code>coda</code>包的功能，提供了在贝叶斯半参数广义线性模型下进行identity链接和 probit 链接的方法。</p> 
 <p style="margin-left:0cm;">主要功能包括：多链合并、继续采样、诊断和预测等。包内包含多种函数，如<code>kmbayes_parallel</code>用于并行计算多个链，<code>kmbayes_combine</code>和<code>kmbayes_combine_lowmem</code>用于合并链，<code>as.mcmc.bkmrfit</code>将<code>bkmrfit</code>对象转换为MCMC对象以进行诊断，以及<code>predict.bkmrfit</code>用于生成预测。</p> 
</blockquote> 
<p>  </p> 
<h2 style="margin-left:0cm;">2. 函数介绍</h2> 
<h3 style="text-align:left;"><strong>2.1 包介绍</strong></h3> 
<blockquote> 
 <ul><li style="text-align:left;">提供了扩展<code>bkmr</code>包的贝叶斯核机器回归工具</li><li style="text-align:left;">支持多链推断和诊断</li><li style="text-align:left;">利用<code>future</code>, <code>rstan</code>, <code>coda</code>包</li></ul> 
</blockquote> 
<h3 style="text-align:left;"><strong>2.2 as.mcmc.bkmrfit</strong></h3> 
<blockquote> 
 <ul><li style="text-align:left;">函数书写格式：as.mcmc()</li><li style="text-align:left;">将<code>bkmrfit</code>对象转换为<code>coda</code>包的MCMC对象</li><li style="text-align:left;">coda 包支持许多不同类型的单链 MCMC 诊断，包括 geweke.diag、traceplot 和 effectiveSize。还可以使用后总结，例如 HPDinterval 和summary.mcmc。</li><li style="text-align:left;">用于进行单链MCMC诊断和后验概括</li></ul> 
</blockquote> 
<h5>示例代码1 </h5> 
<pre><code class="language-R"># 加载bkmrhat包
library(bkmrhat)

# 例子
set.seed(111) #设置随机数种子
library(coda) #加载coda包
# 加载bkmr包
library(bkmr) 
# 生成模拟数据
dat &lt;- bkmr::SimData(n = 50, M = 4)
# 提取数据
y &lt;- dat$y
Z &lt;- dat$Z
X &lt;- dat$X

set.seed(111)
#   运行模型
fitkm &lt;- kmbayes(y = y, Z = Z, X = X, iter = 500, verbose = FALSE,
                 varsel = FALSE)
# 应用as.mcmc函数
mcmcobj &lt;- as.mcmc(fitkm, iterstart=251)    
# 从bkmr对象中提取MCMC链,模型参数的后验总结
summary(mcmcobj) 
# 与bkmr包中的默认值进行比较，该默认值省略了链的前1/2
summary(fitkm)</code></pre> 
<p> </p> 
<h3><strong>2.3 as.mcmc.list.bkmrfit.list</strong></h3> 
<blockquote> 
 <ul><li style="text-align:left;">函数书写格式：as.mcmc.list()</li><li style="text-align:left;">转换多链<code>bkmrfit</code>对象为<code>coda</code>的<code>mcmc.list</code>对象，以进行 coda MCMC 诊断</li><li style="text-align:left;">coda 包支持许多不同类型的 MCMC 诊断，包括 geweke.diag、traceplot 和 effectiveSize。还可以使用后总结，例如 HPDinterval 和summary.mcmc。对于某些 MCMC 诊断，例如 gelman.diag 和 gelman.plot，需要使用多个链</li><li style="text-align:left;"><strong>适用于多链MCMC诊断</strong></li></ul> 
</blockquote> 
<h5>示例代码2 </h5> 
<pre><code class="language-R"># 运行 2 个并行马尔可夫链（通常更好）
future::plan(strategy = future::multisession, workers=2)

# 使用kmbayes_parallel函数运行马尔可夫链
fitkm.list &lt;- kmbayes_parallel(nchains=2, y = y, Z = Z, X = X, iter = 1000, verbose = FALSE, varsel = FALSE)

# 将结果转换为mcmc对象
mcmcobj = as.mcmc.list(fitkm.list)

# 打印马尔可夫链的摘要统计信息
summary(mcmcobj)</code></pre> 
<h3><strong>2.4 ExtractPIPs_parallel</strong></h3> 
<blockquote> 
 <ul><li style="text-align:left;">函数书写格式：ExtractPIPs()</li><li style="text-align:left;">计算<strong>每个链</strong>的后验包含概率</li><li style="text-align:left;">“Posterior inclusion probabilities” 🔤后验包含概率🔤</li></ul> 
</blockquote> 
<h5>示例代码3 </h5> 
<pre><code class="language-R"># 设置并行计算策略为多会话（multisession），使用4个工作进程
future::plan(strategy = future::multisession, workers=2)

# 使用kmbayes_parallel函数运行并行马尔可夫链，生成马尔可夫链结果的列表fitkm.list
fitkm.list &lt;- kmbayes_parallel(nchains=2, y = y, Z = Z, X = X, iter = 500, verbose = FALSE, varsel = TRUE)

# 将所有马尔可夫链的结果合并
bigkm = kmbayes_combine(fitkm.list, excludeburnin=FALSE)

# 从合并的马尔可夫链结果中提取参数估计
ests = ExtractEsts(bigkm)  

# 从合并的马尔可夫链结果中提取变量选择的后验概率
ExtractPIPs(bigkm)</code></pre> 
<p style="text-align:left;"></p> 
<h3 style="background-color:transparent;"><strong>2.5 kmbayes_combine</strong></h3> 
<blockquote> 
 <ul><li>函数书写格式：<strong>kmbayes_combine()</strong></li><li style="text-align:left;">合并多个<code>bkmr</code>链</li><li style="text-align:left;">组合包含 BKMR 的多个链适合不同的起始值</li><li style="text-align:left;">可设置自定义燃烧期和是否排除燃烧期</li><li style="text-align:left;"> <p>MCMC实施中的若干术语：</p> <p style="background-color:transparent;"><a class="has-card" href="https://blog.csdn.net/weixin_52505631/article/details/136207793" title="贝叶斯统计——6. 贝叶斯统计计算方法-CSDN博客"><span class="link-card-box"><span class="link-title">贝叶斯统计——6. 贝叶斯统计计算方法-CSDN博客</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/fa/bf/DEK1vVUA_o.png" alt="icon-default.png?t=N7T8">https://blog.csdn.net/weixin_52505631/article/details/136207793</span></span></a></p> <p></p> </li></ul> 
</blockquote> 
<table cellspacing="0"><tbody><tr><td style="vertical-align:bottom;width:54pt;"><span style="color:#000000;">参数名</span></td><td style="vertical-align:bottom;width:54pt;"><span style="color:#000000;">参数类型</span></td><td style="vertical-align:bottom;width:54pt;"><span style="color:#000000;">中文解释</span></td></tr><tr><td style="vertical-align:bottom;"><span style="color:#000000;">fitkm.list</span></td><td style="vertical-align:bottom;"><span style="color:#000000;">output</span></td><td style="vertical-align:bottom;"><span style="color:#000000;">bkmrfit 对象的列表，每个对象代表一个 MCMC 链的后验</span></td></tr><tr><td style="vertical-align:bottom;"><span style="color:#000000;">burnin</span></td><td style="vertical-align:bottom;"><span style="color:#000000;">numeric</span></td><td style="vertical-align:bottom;"> <p><span style="color:#000000;">自定义的燃烧数（每条链的燃烧迭代数）。</span></p> <p><span style="color:#000000;">如果为 NULL，则默认为每条链的一半</span></p> </td></tr><tr><td style="vertical-align:bottom;"><span style="color:#000000;">excludeburnin</span></td><td style="vertical-align:bottom;"><span style="color:#000000;">logical</span></td><td style="vertical-align:bottom;"> <p><span style="color:#000000;">是否从最终链中排除燃烧迭代次数？注意，所有bkmr包函数会自动从计算</span></p> <p><span style="color:#000000;">中排除燃烧迭代次数</span></p> </td></tr><tr><td style="vertical-align:bottom;"><span style="color:#000000;">reorder</span></td><td style="vertical-align:bottom;"><span style="color:#000000;">logical</span></td><td style="vertical-align:bottom;"> <p><span style="color:#000000;">确保合并链的前半部分只包含每个单独链的前半部分 - 这允许使用bkmr包中</span></p> <p><span style="color:#000000;">的标准函数，这些函数会自动修剪迭代的前半部分。这可用于后验总结，</span></p> <p><span style="color:#000000;">但某些诊断可能效果不好（自相关性，有效样本量），因此应在单独链上</span></p> <p><span style="color:#000000;">进行诊断检测</span></p> </td></tr></tbody></table> 
<h5 style="text-align:left;">示例代码见示例代码3</h5> 
<h3 style="background-color:transparent;"><strong>2.6 kmbayes_combine_lowmem</strong></h3> 
<blockquote> 
 <ul><li style="text-align:left;">类似于<code>kmbayes_combine</code>，但降低内存需求</li><li style="text-align:left;">在较低的内存设置中组合多个 BKMR 链</li><li style="text-align:left;">通过部分写入磁盘避免内存不足。此函数将一些结果写入磁盘，而不是尝试在内存中完全处理，这在某些情况下将避免 kmbayes_combine 可能发生的“内存不足【"out of memory"】”错误</li></ul> 
</blockquote> 
<h5 style="background-color:transparent;text-align:left;">示例代码4</h5> 
<pre><code class="language-R"># 设置并行计算策略为多会话（multisession），使用2个工作进程
future::plan(strategy = future::multisession, workers=2)

# 使用kmbayes_parallel函数运行并行马尔可夫链，生成马尔可夫链结果的列表fitkm.list
fitkm.list &lt;- kmbayes_parallel(nchains=2, y = y, Z = Z, X = X, iter = 500, verbose = FALSE, varsel = TRUE)

# 将所有马尔可夫链的结果合并，使用kmbayes_combine_lowmem函数，保留全部样本
bigkm = kmbayes_combine_lowmem(fitkm.list, excludeburnin=FALSE)

# 从合并的马尔可夫链结果中提取参数估计
ests = ExtractEsts(bigkm)  # 默认保留样本后半部分

# 从合并的马尔可夫链结果中提取变量选择的后验概率
ExtractPIPs(bigkm)</code></pre> 
<h3 style="background-color:transparent;"><strong>2.7 kmbayes_continue</strong></h3> 
<blockquote> 
 <ul><li style="text-align:left;">继续现有<code>bkmr</code>拟合的采样</li><li style="text-align:left;">不完全从先验开始，而是从最后的参数值开始</li><li style="text-align:left;">使用场景：当您使用 kmbayes 函数进行 MCMC 采样，但您没有获取足够的样本且不想重新开始时，请使用此选项</li></ul> 
</blockquote> 
<h5>示例代码5</h5> 
<pre><code class="language-R"># 调用 bkmr::kmbayes 函数进行贝叶斯分析，生成初始模型 fitty1
fitty1 = bkmr::kmbayes(y = y, Z = Z, X = X, est.h = TRUE, iter = 100)

# 进行一些诊断分析，以判断100次迭代是否足够（默认设置的迭代次数）
# 添加100个额外的迭代（仅作为示例，仍然不足够）
fitty2 = kmbayes_continue(fitty1, iter = 100)

# 将 fitty2 转换为 mcmc 对象
cobj = as.mcmc(fitty2)

# 输出 mcmc 对象中的变量名称
varnames(cobj)</code></pre> 
<p style="text-align:left;"></p> 
<h3><strong>2.8 kmbayes_diagnose</strong></h3> 
<blockquote> 
 <ul><li><strong>kmbayes_diag</strong></li><li style="text-align:left;">使用<code>rstan</code>包进行MCMC诊断</li><li style="text-align:left;"><strong>报告R-hat等指标</strong>：使用 Rhat、ess_bulk 和 ess_tail 函数从 rstan 包中为 MCMC 提供诊断。请注意，仅针对 kmbayes_parallel 中的 bkmrfit.list 对象报告 r-hat</li></ul> 
</blockquote> 
<h5 style="text-align:left;">示例代码6</h5> 
<pre><code class="language-R"># 使用 kmbayes_parallel 函数进行贝叶斯分析，并创建 fitkm.list 列表对象
# nchains=2 表示使用2个链，y、Z、X 是输入的数据，iter=1000 表示迭代次数为1000，verbose=FALSE 表示关闭冗长的输出，varsel=TRUE 表示进行变量选择
fitkm.list &lt;- kmbayes_parallel(nchains = 2, y = y, Z = Z, X = X, iter = 1000, verbose = FALSE, varsel = TRUE)

# 运行 kmbayes_diag 函数对 fitkm.list 进行诊断分析
kmbayes_diag(fitkm.list)

# 运行 kmbayes_diag 函数对第一个链（fitkm.list[[1]]）进行诊断分析
kmbayes_diag(fitkm.list[[1]])

# 关闭所有连接
closeAllConnections()</code></pre> 
<h3><strong>2.9 kmbayes_parallel</strong></h3> 
<blockquote> 
 <ul><li style="text-align:left;">并行运行多个<code>bkmr</code>链</li><li style="text-align:left;"><strong>利用<code>future</code>包加速计算</strong>：从 kmbayes 函数拟合平行链。这些链利用<code>future</code>包中的并行处理，可以加速拟合并实现依赖于分散初始值的多个马尔可夫链的诊断。</li></ul> 
</blockquote> 
<h5 style="text-align:left;">示例代码见示例代码7</h5> 
<h3><strong>2.10 kmbayes_parallel_continue</strong></h3> 
<blockquote> 
 <ul><li style="text-align:left;">继续<code>kmbayes_parallel</code>拟合的采样</li><li style="text-align:left;">使用场景：当您使用 kmbayes_parallel 函数进行 MCMC 采样，但您没有获取足够的样本且不想重新开始时，请使用此选项。</li><li style="text-align:left;">返回多链<code>bkmrfit</code>对象</li></ul> 
</blockquote> 
<p style="text-align:left;"></p> 
<h5 style="text-align:left;">示例代码7</h5> 
<pre><code class="language-R"># 并行计算策略，同时指定2个工作进程
future::plan(strategy = future::multisession, workers = 2)

# 使用 kmbayes_parallel 函数进行贝叶斯分析，创建 fitty1p 对象
fitty1p = kmbayes_parallel(nchains = 2, y = y, Z = Z, X = X)

# 使用 kmbayes_parallel_continue 函数继续在 fitty1p 上进行贝叶斯分析，迭代次数设置为3000，创建 fitty2p 对象
fitty2p = kmbayes_parallel_continue(fitty1p, iter = 3000)

# 将 fitty2p 转换为 mcmc.list 格式，创建 cobj 对象
cobj = as.mcmc.list(fitty2p)

# 绘制 MCMC 对象 cobj 的图形
plot(cobj)</code></pre> 
<h3><strong>2.11 predict.bkmrfit</strong></h3> 
<blockquote> 
 <ul><li>函数书写格式：<strong>predict()</strong></li><li style="text-align:left;">生成基于后验均值或标准差的预测值</li><li style="text-align:left;">适合与SuperLearner等集成：提供基于后验均值的观察水平预测，或者生成观察预测的后验标准差。此函数对于与仅使用点估计的 SuperLearner 等集成机器学习包进行交互时非常有用。</li></ul> 
</blockquote> 
<h5 style="text-align:left;">示例代码8</h5> 
<pre><code class="language-R"># 加载bkmr库
library(bkmr)

# 设置种子以确保结果的可复现性
set.seed(111)

# 生成模拟数据
dat &lt;- bkmr::SimData(n = 50, M = 4)
y &lt;- dat$y # 响应变量
Z &lt;- dat$Z # 块变量
X &lt;- dat$X # 协变量

# 再次设置种子以确保结果的可复现性
set.seed(111)

# 拟合贝叶斯知识迁移回归模型
fitkm &lt;- kmbayes(y = y, Z = Z, X = X, iter = 200, verbose = FALSE, varsel = TRUE)

# 预测后验均值
postmean = predict(fitkm)

# 使用Z的一半值进行预测，得到预测结果的均值差异
postmean2 = predict(fitkm, Znew = Z/2)

# 计算后验均值的均值差异
mean(postmean - postmean2)</code></pre> 
<h3 style="background-color:transparent;"><strong>2.12 OverallRiskSummaries_parallel</strong></h3> 
<blockquote> 
 <ul><li style="text-align:left;">按链计算总体风险概览</li><li style="text-align:left;">参数设置参考bmkr包的<strong>OverallRiskSummaries()</strong></li><li style="text-align:left;"><strong>bkmr包</strong> 
   <ul><li style="text-align:left;"><a href="https://blog.csdn.net/weixin_52505631/article/details/136210163" title="​​​​贝叶斯核机回归估计混合物健康效应 【BKMR包】——理论篇-CSDN博客">​​​​贝叶斯核机回归估计混合物健康效应 【BKMR包】——理论篇-CSDN博客</a></li><li style="text-align:left;"><a href="https://blog.csdn.net/weixin_52505631/article/details/136218976" title="贝叶斯核机回归估计混合物健康效应 【BKMR包】——实操篇-CSDN博客">贝叶斯核机回归估计混合物健康效应 【BKMR包】——实操篇-CSDN博客</a></li></ul></li></ul> 
</blockquote> 
<h3><strong>2.13 PredictorResponseBivar_parallel</strong></h3> 
<blockquote> 
 <ul><li style="text-align:left;">按链计算二元预测变量响应</li><li style="text-align:left;">参数设置参考bmkr包的<strong>PredictorResponseBivar()</strong></li></ul> 
</blockquote> 
<h3><strong>2.14 PredictorResponseUnivar_parallel</strong></h3> 
<blockquote> 
 <ul><li style="text-align:left;">按链计算单变量预测响应摘要</li><li style="text-align:left;">参数设置参考bmkr包的<strong>PredictorResponseUnivar()</strong></li></ul> 
</blockquote> 
<h3><strong>2.15 SamplePred_parallel</strong></h3> 
<blockquote> 
 <ul><li style="text-align:left;">按链获取E(Y|h(Z),X,beta)的后验样本</li><li style="text-align:left;">参数设置参考bmkr包的<strong>SamplePred()</strong></li></ul> 
</blockquote> 
<h3><strong>2.16 SingVarRiskSummaries_parallel</strong></h3> 
<blockquote> 
 <ul><li style="text-align:left;">按链计算单一变量摘要</li><li style="text-align:left;">参数设置参考bmkr包的<strong>SingVarRiskSummaries()</strong></li></ul> 
</blockquote> 
<p style="text-align:left;"></p> 
<p style="text-align:left;"></p> 
<p style="text-align:left;"></p> 
<h2 style="text-align:left;">参考文献</h2> 
<p><a class="has-card" href="https://cran.r-project.org/web/packages/bkmrhat/bkmrhat.pdf" rel="nofollow" title="bkmrhat: Parallel Chain Tools for Bayesian Kernel Machine Regression (r-project.org)"><span class="link-card-box"><span class="link-title">bkmrhat: Parallel Chain Tools for Bayesian Kernel Machine Regression (r-project.org)</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/cf/b3/vbDHFv81_o.png" alt="icon-default.png?t=N7T8">https://cran.r-project.org/web/packages/bkmrhat/bkmrhat.pdf</span></span></a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c18d6ff9af1e9ecc5d249a20773db556/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">为QComboBox建立dropDown消息响应函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b8f4a2288c8bd76c1e9d46a60648fb28/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[超实用插件]在Visual Studio中查看EF Core查询计划</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>