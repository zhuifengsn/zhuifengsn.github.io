<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; 常用类型（auto、类型转换、decltype） - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43; 常用类型（auto、类型转换、decltype）" />
<meta property="og:description" content="1 类型转换 1.1 string转换成int、double、float等类型 基于c&#43;&#43;11标准，&lt;string&gt;中已经封装好了对应的转换方法
#include&lt;string&gt; using namespace std;//添加名称空间 string d=&#34;123&#34;; double num=stod(d);//string 转换double int num=stoi(d);//string 转换成int float num=stof(d);//string 转换成float long num=stol(d);//string 转换成long 2 auto C&#43;&#43; 引入auto 和decltype关键字实现类型推导。在C&#43;&#43;11标准的语法中，auto被定义为自动推断变量的类型。auto可以在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型。
2.1使用原则 auto声明的变量必须要初始化，否则编译器不能判断变量的类型。这类似于const关键字。auto不能被声明为返回值，auto不能作为形参，auto不能被修饰为模板参数。 2.2 应用举例 int x = 0; auto * a = &amp;x;// a -&gt; int * ,auto 被推导为int auto b = &amp;x;// b -&gt; int * ,auto 被推导为int* auto &amp; c = x;// c -&gt; int &amp; ,auto 被推导为int auto d = c;//d -&gt; int,auto 被推导为int 当表达式是一个引用类型时，auto会把引用类型抛弃，直接推导成原始类型int const auto e = x; // e -&gt; const int ,auto 被推导为int auto f = e; // f -&gt; int ,auto 被推导为int,当表达式带有const属性时，auto会把const属性抛弃 const auto&amp; g = x;//g -&gt; const int&amp; ,auto 被推导为int 当auto 和引用结合时，auto的推导结果将保留表达式const属性 auto&amp; h = g;// h -&gt; const int&amp; ,auto 被推导为const int （1）在不声明为引用或指针时，auto会忽略等号右边的引用类型和const 和volatile限定。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/859beae485c2cd3737a04f335dddd44d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-11T17:30:50+08:00" />
<meta property="article:modified_time" content="2023-05-11T17:30:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; 常用类型（auto、类型转换、decltype）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1 类型转换</h2> 
<h3>1.1 string转换成int、double、float等类型</h3> 
<p>基于c++11标准，&lt;string&gt;中已经封装好了对应的转换方法</p> 
<pre class="has"><code class="language-cpp">#include&lt;string&gt;
using namespace std;//添加名称空间

string d="123";
double num=stod(d);//string 转换double
int num=stoi(d);//string 转换成int
float num=stof(d);//string 转换成float
long num=stol(d);//string 转换成long</code></pre> 
<p></p> 
<p></p> 
<h2>2 auto </h2> 
<p>C++ 引入auto 和decltype关键字实现类型推导。在C++11标准的语法中，auto被定义为自动推断变量的类型。<strong>auto可以在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型。</strong></p> 
<h3>2.1使用原则</h3> 
<ul><li>auto声明的变量必须要初始化，否则编译器不能判断变量的类型。这类似于const关键字。</li><li>auto不能被声明为返回值，auto不能作为形参，auto不能被修饰为模板参数。</li></ul> 
<h3>2.2 应用举例 </h3> 
<pre><code class="language-cpp">int x = 0;
auto * a = &amp;x;// a -&gt; int * ,auto 被推导为int
auto b = &amp;x;// b -&gt; int * ,auto 被推导为int*
auto &amp; c = x;// c -&gt; int &amp; ,auto 被推导为int
auto d = c;//d -&gt; int,auto 被推导为int 当表达式是一个引用类型时，auto会把引用类型抛弃，直接推导成原始类型int
const auto e = x; // e -&gt; const int ,auto 被推导为int
auto f = e; // f -&gt; int ,auto 被推导为int,当表达式带有const属性时，auto会把const属性抛弃
const auto&amp; g = x;//g -&gt; const int&amp; ,auto 被推导为int 当auto 和引用结合时，auto的推导结果将保留表达式const属性
auto&amp; h = g;// h -&gt; const int&amp;  ,auto 被推导为const int</code></pre> 
<p>（1）在不声明为引用或指针时，auto会忽略等号右边的引用类型和const 和volatile限定。</p> 
<p>（2）在声明为引用或者指针时，auto会保留等号右边的引用和const 和volatile属性</p> 
<p>（3） auto关键字更适用于类型冗长复杂、变量使用范围专一时，使程序更清晰易读。</p> 
<pre><code class="language-cpp">std::vector&lt;int&gt; vect; 
 for(auto it = vect.begin(); it != vect.end(); ++it)
 {  //it的类型是std::vector&lt;int&gt;::iterator
    std::cin &gt;&gt; *it;
}</code></pre> 
<p>（4） 保存lambda表达式类型的变量声明</p> 
<pre><code class="language-cpp">auto ptr = [](double x){return x*x;};//类型为std::function&lt;double(double)&gt;函数对象</code></pre> 
<h3>2.3 使用限制</h3> 
<p> （1）auto 不能用于函数参数</p> 
<pre><code class="language-cpp">void func(auto a = 1){}</code></pre> 
<p>（2）auto 不能用于非静态成员变量</p> 
<pre><code class="language-cpp">class A
{
  auto a = 1;        // error，在类中auto不能用作非静态成员变量
  static auto b = 1;     // error，这里与auto无关，正常static int b = 1也不可以
  static const auto c = 1; // ok
};</code></pre> 
<p>（3）auto需马上初始化</p> 
<pre><code class="language-cpp">
 auto a;     //ERROR 无法推导auto类型，需要初始值设定</code></pre> 
<p>（4）auto在一行定义多个变量时，各个变量的推导不能产生二义性，否则编译失败</p> 
<pre><code class="language-cpp">​auto d = 0, f = 1.0; // error，0和1.0类型不同，对于编译器有二义性，没法推导​​</code></pre> 
<p> （5）auto不能定义数组，但可定义指针</p> 
<pre><code class="language-cpp">int arr[10] = {0};
auto aa = arr; //ok ,aa -&gt; int *;
auto rr[10] = arr;//error,auto无法定义数组</code></pre> 
<p>（6）auto无法推导出模板参数</p> 
<pre><code class="language-cpp">vector&lt;int&gt; d;
vector&lt;auto&gt; f = d; // error，auto无法推导出模板参数</code></pre> 
<h2>3 decltype</h2> 
<p> decltype是C++11新增的一个关键字，和auto的功能一样，用来在<strong>编译时期</strong>进行自动类型推导。decltype则用于推导表达式类型，这里只用于编译器分析表达式的类型，表达式实际不会进行运算。</p> 
<h3>3.1 语法格式</h3> 
<pre><code class="language-cpp">decltype(exp)</code></pre> 
<p> 在编译时期，推导出表达式exp的类型。</p> 
<h3>3.2 使用规则</h3> 
<ul><li>如果exp是一个不被括号()包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，decltype(exp)的类型和exp一致；</li><li>如果exp是函数调用，则decltype(exp)的类型就和函数返回值的类型一致；</li></ul> 
<pre><code class="language-cpp">int&amp; fun_int_l(void);//左值
int&amp;&amp; fun_int_rr(void);//右值
int fun_int(void);//纯右值
int x = 0;
decltype(fun_int_l()) a1 =x;//a1 -&gt; int&amp;
decltype(fun_int_rr()) b1 =0;//b1 -&gt; int&amp;&amp;
decltype(fun_int()) c1 =0;//a1 -&gt; int</code></pre> 
<ul><li>如果exp是一个左值，或被括号()包围，decltype(exp)的类型就是exp的左值引用，假设exp的类型为T，则decltype(exp)的类型为T&amp;；</li></ul> 
<pre><code class="language-cpp">int x = 0;
decltype(x) y = 1;           // y -&gt; int
decltype(x + y) z = 0;       // z -&gt; int
const int&amp; i = x;
decltype(i) j = y;           // j -&gt; const int &amp;
const decltype(z) * p = &amp;z;  // *p  -&gt; const int, p  -&gt; const int *
decltype(z) * pi = &amp;z;       // *pi -&gt; int      , pi -&gt; int *
decltype(pi)* pp = &amp;pi;      // *pp -&gt; int *    , pp -&gt; int * *
</code></pre> 
<p></p> 
<h3>3.3 decltype与auto 的不同点</h3> 
<p>auto 只能根据变量的初始化表达式推导出变量应该具有的类型。若要想通过某个表达式得到的类型，但又不希望新变量和这个表达式具有同样的值，此时auto不适用。</p> 
<p></p> 
<p>参考文献：</p> 
<p>【1】<a href="https://blog.csdn.net/weixin_43744293/article/details/117440727?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-117440727-blog-126308644.pc_relevant_3mothn_strategy_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-117440727-blog-126308644.pc_relevant_3mothn_strategy_recovery&amp;utm_relevant_index=2" title="C++ auto用法及应用详解_代码乌龟的博客-CSDN博客_c++ auto">C++ auto用法及应用详解_代码乌龟的博客-CSDN博客_c++ auto</a></p> 
<p>【2】<a href="https://blog.csdn.net/aimalove/article/details/117886634" title="C++11 auto_aimalove的博客-CSDN博客">C++11 auto_aimalove的博客-CSDN博客</a> </p> 
<p>【3】<a href="https://blog.51cto.com/u_15652881/5322645" rel="nofollow" title="C++ 面试八股文_51CTO博客_java面试八股文">C++ 面试八股文_51CTO博客_java面试八股文</a> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a6e0739e6bdc9cc6748ef2eeea3bb9f4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">WB_BF项目问题说明以及探究</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9b64cf02164c8ec10d0e6dee1c1bdccd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">RabbitMQ实现延迟消息居然如此简单，整个插件就完事了</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>