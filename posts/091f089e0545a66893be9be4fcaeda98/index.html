<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>玩转 JS 逆向：RPC 加持，爬虫效率飙升 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="玩转 JS 逆向：RPC 加持，爬虫效率飙升" />
<meta property="og:description" content="大家好，我是安果！
一些复杂的网站针对参数是层层加密，如果选择硬刚，去扣代码、补环境，耗时耗力的同时，不一定能获取完整的加密逻辑
在 JS 逆向中，我们可以通过 RPC 通信，直接调用浏览器的方法生成加密参数，这样可以省去扣代码的时间
本篇文章将介绍 Sekiro RPC 进行 JS 逆向的完整流程
目标网站：
aHR0cHM6Ly93d3cueGluZ3R1LmNuL3N1cC9jcmVhdG9yL2hvdA==
具体操作步骤如下：
1、Sekiro RPC
Sekiro 是一个多语言的、分布式网络拓扑无关的服务发布平台
它能基于长连接和代码注入 API 服务暴露的框架，可用于逆向（包含 JS 逆向和 App 逆向）
官网：
https://sekiro.iinti.cn/sekiro-doc/
2、分析网站
打开目标网站，发现接口 /h/api/gateway/handler_get 中的查询参数 sign 是加密的
在 Sources - Page 面板下，通过关键字 sign: 全局查询
发现加密参数生成的具体逻辑如下：
PS：通过方法 generatePayload 生成 sign，其中 c、l 为参数
文件位置：
https://*/obj/goofy/star/idou_fe/assets/vendor-a1b40867.js
然后，在方法 generatePayload 方法内添加条件断点
这样，通过多次 Debugger 分析，可以得出参数的生成规则（即：参数固定值、参数生成逻辑）
//条件监听 //条件：c.service_name===&#39;author.AdStarAuthorService&#39; 这样，在调试模式下，我们可以在浏览器控制台进行测试了
如下，直接调用方法可以拿到加密后的参数
3、加密文件重写 Overrides
在本地新建一个文件夹，Sources - Overrides 关联该本地目录
PS：开启 Overrides 并授予权限" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/091f089e0545a66893be9be4fcaeda98/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-14T12:04:20+08:00" />
<meta property="article:modified_time" content="2023-08-14T12:04:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">玩转 JS 逆向：RPC 加持，爬虫效率飙升</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/0d/ea/3rnDUlKe_o.jpg" alt="a006381d352fe38800c19f40042e96fe.jpeg"></p> 
 <p>大家好，我是安果！</p> 
 <p style="text-align:left;">一些复杂的网站针对参数是层层加密，如果选择硬刚，去扣代码、补环境，耗时耗力的同时，不一定能获取完整的加密逻辑</p> 
 <p>在 JS 逆向中，我们可以通过 RPC 通信，直接调用浏览器的方法生成加密参数，这样可以省去扣代码的时间<br></p> 
 <p>本篇文章将介绍 Sekiro RPC 进行 JS 逆向的完整流程</p> 
 <p>目标网站：</p> 
 <p>aHR0cHM6Ly93d3cueGluZ3R1LmNuL3N1cC9jcmVhdG9yL2hvdA==</p> 
 <p>具体操作步骤如下：</p> 
 <p>1、Sekiro RPC</p> 
 <p style="text-align:left;">Sekiro 是一个多语言的、分布式网络拓扑无关的服务发布平台</p> 
 <p style="text-align:left;">它能基于长连接和代码注入 API 服务暴露的框架，可用于逆向（包含 JS 逆向和 App 逆向）</p> 
 <p style="text-align:left;">官网：</p> 
 <p style="text-align:left;">https://sekiro.iinti.cn/sekiro-doc/</p> 
 <p>2、分析网站</p> 
 <p>打开目标网站，发现接口 /h/api/gateway/handler_get 中的查询参数 sign 是加密的</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/71/90/cnHdwL8U_o.png" alt="3543be2e550f60cd4ac8029b6cff530c.png"></p> 
 <p>在 Sources - Page 面板下，通过关键字 sign: 全局查询</p> 
 <p>发现加密参数生成的具体逻辑如下：</p> 
 <p style="text-align:left;">PS：通过方法 generatePayload 生成 sign，其中 c、l 为参数</p> 
 <p style="text-align:left;">文件位置：</p> 
 <p style="text-align:left;">https://*/obj/goofy/star/idou_fe/assets/vendor-a1b40867.js</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/6b/17/ivwfb1vk_o.png" alt="6f5925e0d869828f37049aa618d4dbe1.png"></p> 
 <p>然后，在方法 generatePayload 方法内添加条件断点</p> 
 <p style="text-align:left;">这样，通过多次 Debugger 分析，可以得出参数的生成规则（即：参数固定值、参数生成逻辑）</p> 
 <pre class="has"><code class="language-go">//条件监听
//条件：c.service_name==='author.AdStarAuthorService'</code></pre> 
 <p>这样，在调试模式下，我们可以在浏览器控制台进行测试了</p> 
 <p>如下，直接调用方法可以拿到加密后的参数</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/3f/0e/0CwhPuwY_o.png" alt="fdcb3d3b13932a2bcc97e17d2d39d9a8.png"></p> 
 <p>3、加密文件重写 Overrides</p> 
 <p style="text-align:left;">在本地新建一个文件夹，Sources - Overrides 关联该本地目录</p> 
 <p style="text-align:left;">PS：开启 Overrides 并授予权限</p> 
 <p style="text-align:left;">在 Sources - Page 面板下，选择 vendor-a1b40867.js 文件右键，选择 Save for overrides 将文件保存到 Overrides 中</p> 
 <p style="text-align:left;">4、Sekiro 定义</p> 
 <p style="text-align:left;">修改 Overrides 中 vendor-a1b40867.js 文件</p> 
 <p style="text-align:left;">定义 SekiroClient 方法对象并实例化，注册一个方法进行监听处理</p> 
 <p style="text-align:left;">SekiroClient 源码如下：</p> 
 <p style="text-align:left;">https://raw.githubusercontent.com/yint-tech/sekiro-samples/main/demo-web/sekiroWeb.js</p> 
 <p style="text-align:left;">通过关键字 generatePayload 找到对应方法，回车换行，输入如下逻辑</p> 
 <p style="text-align:left;">PS：修改源码后，需要重新开启、关闭 Overrides 开关一次（ Enable Local Overrides ）</p> 
 <pre class="has"><code class="language-go">...
function SekiroClient(e){if(this.wsURL=e,this.handlers={},this.socket={},!e)throw new Error("wsURL can not be empty!!");this.webSocketFactory=this.resolveWebSocketFactory(),this.connect()}SekiroClient.prototype.resolveWebSocketFactory=function(){if("object"==typeof window){var e=window.WebSocket?window.WebSocket:window.MozWebSocket;return function(o){function t(o){this.mSocket=new e(o)}return t.prototype.close=function(){this.mSocket.close()},t.prototype.onmessage=function(e){this.mSocket.onmessage=e},t.prototype.onopen=function(e){this.mSocket.onopen=e},t.prototype.onclose=function(e){this.mSocket.onclose=e},t.prototype.send=function(e){this.mSocket.send(e)},new t(o)}}if("object"==typeof weex)try{console.log("test webSocket for weex");var o=weex.requireModule("webSocket");return console.log("find webSocket for weex:"+o),function(e){try{o.close()}catch(e){}return o.WebSocket(e,""),o}}catch(e){console.log(e)}if("object"==typeof WebSocket)return function(o){return new e(o)};throw new Error("the js environment do not support websocket")},SekiroClient.prototype.connect=function(){console.log("sekiro: begin of connect to wsURL: "+this.wsURL);var e=this;try{this.socket=this.webSocketFactory(this.wsURL)}catch(o){return console.log("sekiro: create connection failed,reconnect after 2s:"+o),void setTimeout(function(){e.connect()},2e3)}this.socket.onmessage(function(o){e.handleSekiroRequest(o.data)}),this.socket.onopen(function(e){console.log("sekiro: open a sekiro client connection")}),this.socket.onclose(function(o){console.log("sekiro: disconnected ,reconnection after 2s"),setTimeout(function(){e.connect()},2e3)})},SekiroClient.prototype.handleSekiroRequest=function(e){console.log("receive sekiro request: "+e);var o=JSON.parse(e),t=o.__sekiro_seq__;if(o.action){var n=o.action;if(this.handlers[n]){var s=this.handlers[n],i=this;try{s(o,function(e){try{i.sendSuccess(t,e)}catch(e){i.sendFailed(t,"e:"+e)}},function(e){i.sendFailed(t,e)})}catch(e){console.log("error: "+e),i.sendFailed(t,":"+e)}}else this.sendFailed(t,"no action handler: "+n+" defined")}else this.sendFailed(t,"need request param {action}")},SekiroClient.prototype.sendSuccess=function(e,o){var t;if("string"==typeof o)try{t=JSON.parse(o)}catch(e){(t={}).data=o}else"object"==typeof o?t=o:(t={}).data=o;(Array.isArray(t)||"string"==typeof t)&amp;&amp;(t={data:t,code:0}),t.code?t.code=0:(t.status,t.status=0),t.__sekiro_seq__=e;var n=JSON.stringify(t);console.log("response :"+n),this.socket.send(n)},SekiroClient.prototype.sendFailed=function(e,o){"string"!=typeof o&amp;&amp;(o=JSON.stringify(o));var t={};t.message=o,t.status=-1,t.__sekiro_seq__=e;var n=JSON.stringify(t);console.log("sekiro: response :"+n),this.socket.send(n)},SekiroClient.prototype.registerAction=function(e,o){if("string"!=typeof e)throw new Error("an action must be string");if("function"!=typeof o)throw new Error("a handler must be function");return console.log("sekiro: register action: "+e),this.handlers[e]=o,this};

//实例化一个客户端连接对象
//group：业务类型
//clientId：设备id
var client = new SekiroClient("wss://sekiro.iinti.cn:5612/business/register?group=test_web&amp;clientId=" + Math.random());

//注册
 client.registerAction("xingtu", function (request, resolve, reject) {
     // var enc_data = request['data']
     // var res = enc_data;
     // resolve(v()(res));
     let c={
         "hot_list_id": "0",
         "tag": "61e541324fe6649d1b8a2ee3",
         "service_name": "author.AdStarAuthorService",
         "service_method": "GetHotListData"
     };

     let l={
         "strict": true,
         "serializing": true,
         "rule": {
             "include": [
                 "hot_list_id",
                 "tag",
                 "download",
                 "image_download",
                 "province",
                 "city",
                 "rlid"
             ]
         }
     };
resolve(generatePayload(c,l));
 });
...</code></pre> 
 <p>重新访问下面地址，查看控制台，发现 Sekiro 已经准备完毕</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/c0/be/5MHZGHvV_o.png" alt="c2cb95e5c6cc6df6202bed021c00688f.png"></p> 
 <p>5、Python 调用</p> 
 <p style="text-align:left;">通过 Websocket 调用，借助浏览器调用 generatePayload() 方法，获取加密后的值 sign</p> 
 <p style="text-align:left;">最后，组成完整的 URL 获取数据</p> 
 <pre class="has"><code class="language-go">import requests

# Websocket通讯，获取sign（Sekiro）
def get_signature():
    data = {"group": "test_web",
            "action": "xingtu"
            }
    resp = requests.get("http://sekiro.iinti.cn:5612/business/invoke", params=data).json()
    return resp['sign']

# 获取数据
def get_data(sign):
    url = f"https://*host/h/api/gateway/handler_get/?hot_list_id=0&amp;tag=*tag&amp;service_name=author.AdStarAuthorService&amp;service_method=GetHotListData&amp;sign_strict=1&amp;sign={sign}"

    payload = {}
    headers = {
        'authority': '*host',
        'agw-js-conv': 'str',
        'pragma': 'no-cache',
        'x-login-source': '1',
        'x-star-service-method': 'GetHotListData',
        'x-star-service-name': 'author.AdStarAuthorService',
        'Cookie': 'cookie',
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36'
    }
    response = requests.request("GET", url, headers=headers, data=payload)

    print(response.text)

if __name__ == '__main__':
    sign = get_signature()
    print("sign：",sign)

    get_data(sign)</code></pre> 
 <p>6、补充一下</p> 
 <p style="text-align:left;">除了 Overrides 覆盖文件外，还可以使用油猴脚本或浏览器插件进行脚本注入，完成 Sekiro 的初始化及事件注册</p> 
 <p style="text-align:left;">相比传统的 JS 逆向，利用 Sekiro 直接调用方法获取加密参数更加方便快捷然后；但是它有一个缺点，即：需要通过浏览器打开目标网站</p> 
 <p>如果你觉得文章还不错，请大家 点赞、分享、留言 下，因为这将是我持续输出更多优质文章的最强动力！</p> 
 <p style="text-align:center;"><strong>推荐阅读</strong></p> 
 <p><a href="" rel="nofollow">5 分钟，教你从零快速编写一个油猴脚本！</a><br></p> 
 <p><a href="" rel="nofollow">Python 绝招：解锁小红书信息流的无限潜力！</a><br></p> 
 <p><a href="" rel="nofollow">反爬篇 | 手把手教你处理 JS 逆向之字体反爬（下）</a><br></p> 
 <p><a href="" rel="nofollow">休闲时光：最近上映的电影与爬虫世界，带您彻底放松！</a><br></p> 
 <p>END</p> 
 <p style="text-align:center;">好文和朋友一起看~</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f565a7a697679c3caa6872bcfa617b76/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【51单片机篇】LCD1602显示</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b6ba62d0c9714dde9b690e26977e42d7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PCL点云——滤波算法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>