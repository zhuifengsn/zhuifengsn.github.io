<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ffmpeg多种码率控制方式的实现 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ffmpeg多种码率控制方式的实现" />
<meta property="og:description" content="码率控制参数：
bitrate
默认：无
说明：三种可选的码率控制方法之二。设置x264使用固定目标比特率模式。固定目标比特率意味着最终文件的大小是可知的，但是目标的质量是不可知的。 x264会试图让最终文件的整体码率与给定的码率相等。参数的量纲为kilobits/sec（8bit = 1byte）。
通常这个选项和–pass选项配合进行2趟编码。
这个选项和 –qp和–crf是互斥的，三者只能选一个。
参见：–qp, –crf, –ratetol, –pass, –stats
-b bitrate 设置比特率，缺省200kb/s
-maxrate bitrate设置最大视频码率容忍度
-minrate bitreate 设置最小视频码率容忍度
-bufsize size 设置码率控制缓冲区大小
-bufsize (FFmpeg)
Depends on the profile level of the video being encoded. Set only if you’re encoding for a hardware device.
ffmpeg -i input -c:v libx264 -crf 20 -maxrate 400k -bufsize 1835k
这将会有效的将crf值锁定在20，但是如果输出码率超过400kbps，在这种情况下编码器会将质量降低到低于crf 20。
x264的三种码率控制模式
三种模式为：
qp模式…bitrate模式…crf模式
下面挨个解释一下…需要注意的是三种码率控制方法不能共存，有其一不能有另外两个！
qp模式
即为固定量化值（Constant Quantizer）模式来编码视频…需要注意的是这里的量化参值为P帧的量化值…I 帧（IDR帧）和B帧的量化值又由ipratio和bpratio参数来确定…不过通常这两个参数无需手动设置。
简单点说qp模式就是：相对于压缩前的原视频来说…每一个 P 帧 …I 帧 … B帧都会固定的损失一部分质量…损失判定是固定的." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/5800cd9ac4021785aa34b17dc37bfc62/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-05T09:46:28+08:00" />
<meta property="article:modified_time" content="2021-03-05T09:46:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ffmpeg多种码率控制方式的实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>码率控制参数：<br> bitrate<br> 默认：无<br> 说明：三种可选的码率控制方法之二。设置x264使用固定目标比特率模式。固定目标比特率意味着最终文件的大小是可知的，但是目标的质量是不可知的。 x264会试图让最终文件的整体码率与给定的码率相等。参数的量纲为kilobits/sec（8bit = 1byte）。<br> 通常这个选项和–pass选项配合进行2趟编码。<br> 这个选项和 –qp和–crf是互斥的，三者只能选一个。<br> 参见：–qp, –crf, –ratetol, –pass, –stats<br> -b bitrate 设置比特率，缺省200kb/s<br> -maxrate bitrate设置最大视频码率容忍度<br> -minrate bitreate 设置最小视频码率容忍度<br> -bufsize size 设置码率控制缓冲区大小<br> -bufsize (FFmpeg)</p> 
<p>Depends on the profile level of the video being encoded. Set only if you’re encoding for a hardware device.</p> 
<p>ffmpeg -i input -c:v libx264 -crf 20 -maxrate 400k -bufsize 1835k</p> 
<p>这将会有效的将crf值锁定在20，但是如果输出码率超过400kbps，在这种情况下编码器会将质量降低到低于crf 20。</p> 
<p>x264的三种码率控制模式</p> 
<p>三种模式为：<br> qp模式…bitrate模式…crf模式<br> 下面挨个解释一下…需要注意的是三种码率控制方法不能共存，有其一不能有另外两个！<br> qp模式<br> 即为固定量化值（Constant Quantizer）模式来编码视频…需要注意的是这里的量化参值为P帧的量化值…I 帧（IDR帧）和B帧的量化值又由ipratio和bpratio参数来确定…不过通常这两个参数无需手动设置。<br> 简单点说qp模式就是：相对于压缩前的原视频来说…每一个 P 帧 …I 帧 … B帧都会固定的损失一部分质量…损失判定是固定的.但由于I P B帧的插入是不确定的…所以最终文件的大小是无法确定的。<br> 设置为qp0时将产生无损的画面输出（输出文件一般会比源文件大出数倍以上）…并且相同视觉质量时…qp模式压出的视频文件比crf模式大。<br> bitrate模式<br> 即为固定目标码率模式（固定目标比特率模式），x264会试图让最终文件的整体码率与给定的码率相等，这会使最终文件的大小是确定的，适用于精确控制体积，但由于这是一次编码，所以画质上不如同等体积的crf，故一般配合pass参数使用。<br> crf模式<br> 即固定Ratefactor模式…如果说QP是固定量化器，bitrate是固定文件最终大小，那么crf则是则是固定“肉眼质量”，crf可以提供跟QP一样的视觉的质量…但是文件更小。<br> crf是通过降低那些“不那么重要”的帧的质量做到这一切的~，“不那么重要”意思是过于耗费码率又难以用肉眼察觉的帧…省下来的码率会用在其它更有效的帧里。<br> 其实crf就是一个浮动qp模式，其按照特定的标准，根据人眼的需求，给予每帧不同的qp值 ，但玩好crf模式…和aq…psy…qcomp等参数都脱不开关系。<br> 需要注意的是crf模式无法预测最终文件体积。</p> 
<p>在VBR和ABR情况下，可以设置vbv-maxrate和vbv-bufsize（很多情况下设置为vbv-maxrate = vbv-bufsize = bitrate，注意vbv-bufsize的量纲是不同，即最大缓存1s的数据）。<br> 在RC_ABR码率控制方法下，如果vbv-maxrate == bitrate这时候其实进行的是CBR码率控制方法，encoder力争控制每一帧输出都稳定在bitrate上。<br> 如果设置vbv-maxrate则vbv-bufsize必须设置，否则会提示"VBV maxrate specified, but no bufsize, ignored"， vbv-maxrate会被改回为0。<br> 如果设置vbv-bufsize而vbv-maxrate没有设置，则会提示"VBV maxrate unspecified, assuming CBR"，vbv-maxrate会被设为bitrate，此时进行CBR编码。<br> 一般设置为 vbv-maxrate = vbv-bufsize = a*bitrate。<br> a=0，不启用VBV机制，编码性能最好，适用于硬盘文件编码；但它输出的码率波动性大，有可能某些帧的比特数过高，不适用于有实际带宽限制的流媒体传输。<br> 0&lt;a&lt;1，这样的设置没有什么意义，得不到任何的好处。<br> a=1，等于CBR，CBR是一种复杂和平滑场景都不大讨好的码率控制方法，一般不采用这一方法。<br> a&gt;1，对每帧数据有限制，但又可以暂时超过平均码率，适用于流媒体传输。<br> 对于某些特殊场景编码，例如电脑屏幕编码，它的特点是I帧纹理细节丰富，编码数据极大，P帧变化很小或者根本没变化，p帧数据很小。<br> 这种情况，如果不设置vbv参数（保持缺省值0），I帧数据压不下来，码流会周期性的高低变动；有可能造成网络拥塞，数据包丢失，解码端花屏。<br> 如果设置a=1，I帧得到限制，可以压下来，但编码质量下降太多，主观质量差。<br> 因此需要根据网络设置成a&gt;1，使得I帧可以暂时有限度的大于平均码率，而P帧编码时候还能把平均码率降下来。</p> 
<p>视频编码器常用的码率控制方式包括abr(平均码率)，crf（限制码率），cqp（固定质量），ffmpeg中AVCodecContext显示提供了码率大小的控制参数，但是并没有提供其他的控制方式。ffmpeg中码率控制方式分为以下几种情况：<br> 1.如果设置了AVCodecContext中bit_rate的大小，则采用abr的控制方式；<br> 2.如果没有设置AVCodecContext中的bit_rate，则默认按照crf方式编码，crf默认大小为23（此值类似于qp值，同样表示视频质量）；<br> 3.如果用户想自己设置，则需要借助av_opt_set函数设置AVCodecContext的priv_data参数。下面给出三种控制方式的实现代码：<br> …<br> int bpsValue; //码流控制方式的对应值<br> int bpsMode; //码流控制方式，0表示平均码率(abr)，1表示固定码率(crf)，2表示固定质量（cqp）<br> AVCodecContext* pCodecCtx;<br> …</p> 
<pre><code>//码率控制方式
string modeValue = int2String(bpsValue);
switch (bpsMode) {
case 0:
    pCodecCtx-&gt;bit_rate = bpsValue*1000;
    break;
case 1:
    av_opt_set(pCodecCtx-&gt;priv_data,"crf",modeValue.c_str(),AV_OPT_SEARCH_CHILDREN);
    break;


case 2:
    av_opt_set(pCodecCtx-&gt;priv_data,"qp",modeValue.c_str(),AV_OPT_SEARCH_CHILDREN);
    break;
default:
    pCodecCtx-&gt;bit_rate = bpsValue;
    break;
}
</code></pre> 
<p><img src="https://images2.imgbox.com/e8/98/o8P6jE3W_o.png" alt="在这里插入图片描述"></p> 
<p>mb_qmin的替代，最小的量化因子。取值范围1-51。建议在10-30之间。</p> 
<p>-qscale q 使用固定的视频量化标度(VBR)</p> 
<p>-qdiff q 量化标度间最大偏差 (VBR)</p> 
<p>-qblur blur 视频量化标度柔化(VBR)</p> 
<p>-qcomp compression 视频量化标度压缩(VBR)</p> 
<p>-rc_init_cplx complexity 一遍编码的初始复杂度</p> 
<p>-b_qfactor factor 在p和b帧间的qp因子</p> 
<p>-i_qfactor factor 在p和i帧间的qp因子</p> 
<p>-b_qoffset offset 在p和b帧间的qp偏差</p> 
<p>-i_qoffset offset 在p和i帧间的qp偏差题)</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/29455ebe0976df7c800ca8eaa8c51d6b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mysql数据库物理备份_MySQL数据库之xtrabackup物理备份(一)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/89c3534f466a13958805d2191d8675ba/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java 线程池的理解_Java线程池深入理解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>