<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】时间复杂度和空间复杂度 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【数据结构】时间复杂度和空间复杂度" />
<meta property="og:description" content="大家好，我是苏貝，本篇博客带大家了解时间复杂度和空间复杂度，如果你觉得我写的还不错的话，可以给我一个赞👍吗，感谢❤️
目录 一.算法效率1.衡量一个算法的好坏2.算法的复杂度 二.时间复杂度1.时间复杂度的概念2.大O的渐进表示法3.常见时间复杂度计算举例 三.空间复杂度 一.算法效率 1.衡量一个算法的好坏 如何衡量一个算法的好坏呢？比如对于以下斐波那契数列：
long long Fib(int N) { if(N &lt; 3) return 1; return Fib(N-1) &#43; Fib(N-2); } 斐波那契数列的递归实现方式非常简洁，但简洁一定好吗？那该如何衡量其好与坏呢？
2.算法的复杂度 算法在编写成可执行程序后，运行时需要耗费时间资源和空间(内存)资源 。因此衡量一个算法的好坏，一般
是从时间和空间两个维度来衡量的，即时间复杂度和空间复杂度。
时间复杂度主要衡量一个算法的运行快慢，而空间复杂度主要衡量一个算法运行所需要的额外空间。在计算机发展的早期，计算机的存储容量很小。所以对空间复杂度很是在乎。但是经过计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度。所以我们如今已经不需要再特别关注一个算法的空间复杂度。
二.时间复杂度 1.时间复杂度的概念 时间复杂度的定义：在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。一个算法执行所耗费的时间，从理论上说，是不能算出来的，只有你把你的程序放在机器上跑起来，才能知道。但是我们需要每个算法都上机测试吗？是可以都上机测试，但是这很麻烦，所以才有了时间复杂度这个分析方式。一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法的时间复杂度。
即：找到某条基本语句与问题规模N之间的数学表达式，就是算出了该算法的时间复杂度。实际中我们计算时间复杂度时，我们其实并不一定要计算精确的执行次数，而只需要大概执行次数，那么这里我们使用大O的渐进表示法。
2.大O的渐进表示法 大O符号（Big O notation）：是用于描述函数渐进行为的数学符号。
推导大O阶方法：
1、用常数1取代运行时间中的所有加法常数，即O(1)，它并不是代表1次，而是常数次
2、在修改后的运行次数函数中，只保留最高阶项，即只取确定性的那项，去掉了那些对结果影响不大的项。
3、如果最高阶项存在且不是1，则去除与这个项相乘的常数。得到的结果就是大O阶。
另外有些算法的时间复杂度存在最好、平均和最坏情况：
最坏情况：任意输入规模的最大运行次数(上界)
平均情况：任意输入规模的期望运行次数
最好情况：任意输入规模的最小运行次数(下界)
例如：在一个长度为N数组中搜索一个数据x
最好情况：1次找到，最坏情况：N次找到，平均情况：N/2次找到
在实际中一般情况关注的是算法的最坏运行情况，所以数组中搜索数据时间复杂度为O(N)
3.常见时间复杂度计算举例 示例1：
// 计算Func2的时间复杂度？ void Func2(int N) { int count = 0; for (int k = 0; k &lt; 2 * N; &#43;&#43;k) { &#43;&#43;count; } int M = 10; while (M--) { &#43;&#43;count; } printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/b61b0171f074c4d0283ef97e5a85da52/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-21T16:54:38+08:00" />
<meta property="article:modified_time" content="2024-01-21T16:54:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】时间复杂度和空间复杂度</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>大家好，我是苏貝，本篇博客带大家了解时间复杂度和空间复杂度，如果你觉得我写的还不错的话，可以给我一个赞👍吗，感谢❤️<br> <img src="https://images2.imgbox.com/93/81/T2JD0Lkl_o.jpg" alt="在这里插入图片描述"></p> 
</blockquote> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_6" rel="nofollow">一.算法效率</a></li><li><ul><li><a href="#1_7" rel="nofollow">1.衡量一个算法的好坏</a></li><li><a href="#2_21" rel="nofollow">2.算法的复杂度</a></li></ul> 
  </li><li><a href="#_29" rel="nofollow">二.时间复杂度</a></li><li><ul><li><a href="#1_30" rel="nofollow">1.时间复杂度的概念</a></li><li><a href="#2O_36" rel="nofollow">2.大O的渐进表示法</a></li><li><a href="#3_53" rel="nofollow">3.常见时间复杂度计算举例</a></li></ul> 
  </li><li><a href="#_264" rel="nofollow">三.空间复杂度</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_6"></a>一.算法效率</h2> 
<h3><a id="1_7"></a>1.衡量一个算法的好坏</h3> 
<p>如何衡量一个算法的好坏呢？比如对于以下斐波那契数列：</p> 
<pre><code class="prism language-c"><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">Fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 <span class="token keyword">if</span><span class="token punctuation">(</span>N <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span>
 <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
 
 <span class="token keyword">return</span> <span class="token function">Fib</span><span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">Fib</span><span class="token punctuation">(</span>N<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>斐波那契数列的递归实现方式非常简洁，但简洁一定好吗？那该如何衡量其好与坏呢？</p> 
<h3><a id="2_21"></a>2.算法的复杂度</h3> 
<p>算法在编写成可执行程序后，运行时需要耗费时间资源和空间(内存)资源 。因此<strong>衡量一个算法的好坏，一般<br> 是从时间和空间两个维度来衡量的</strong>，即时间复杂度和空间复杂度。<br> <strong>时间复杂度主要衡量一个算法的运行快慢，而空间复杂度主要衡量一个算法运行所需要的额外空间</strong>。在计算机发展的早期，计算机的存储容量很小。所以对空间复杂度很是在乎。但是经过计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度。所以我们如今已经不需要再特别关注一个算法的空间复杂度。</p> 
<hr> 
<h2><a id="_29"></a>二.时间复杂度</h2> 
<h3><a id="1_30"></a>1.时间复杂度的概念</h3> 
<p>时间复杂度的定义：在计算机科学中，<strong>算法的时间复杂度是一个函数</strong>，它定量描述了该算法的运行时间。一个算法执行所耗费的时间，从理论上说，是不能算出来的，只有你把你的程序放在机器上跑起来，才能知道。但是我们需要每个算法都上机测试吗？是可以都上机测试，但是这很麻烦，所以才有了时间复杂度这个分析方式。一个算法所花费的时间与其中语句的执行次数成正比例，<strong>算法中的基本操作的执行次数，为算法的时间复杂度。</strong><br> 即：找到某条基本语句与问题规模N之间的数学表达式，就是算出了该算法的时间复杂度。实际中我们计算时间复杂度时，我们其实并不一定要计算精确的执行次数，而只需要<strong>大概执行次数，那么这里我们使用大O的渐进表示法。</strong></p> 
<h3><a id="2O_36"></a>2.大O的渐进表示法</h3> 
<p><strong>大O符号（Big O notation）：是用于描述函数渐进行为的数学符号。</strong><br> 推导大O阶方法：</p> 
<blockquote> 
 <p>1、用常数1取代运行时间中的所有加法常数，即O(1)，它并不是代表1次，而是常数次<br> 2、在修改后的运行次数函数中，只保留最高阶项，即只取确定性的那项，去掉了那些对结果影响不大的项。<br> 3、如果最高阶项存在且不是1，则去除与这个项相乘的常数。得到的结果就是大O阶。</p> 
</blockquote> 
<p>另外有些算法的时间复杂度存在最好、平均和最坏情况：</p> 
<blockquote> 
 <p>最坏情况：任意输入规模的最大运行次数(上界)<br> 平均情况：任意输入规模的期望运行次数<br> 最好情况：任意输入规模的最小运行次数(下界)</p> 
</blockquote> 
<p>例如：在一个长度为N数组中搜索一个数据x<br> 最好情况：1次找到，最坏情况：N次找到，平均情况：N/2次找到<br> 在实际中一般情况关注的是算法的最坏运行情况，所以数组中搜索数据时间复杂度为O(N)</p> 
<h3><a id="3_53"></a>3.常见时间复杂度计算举例</h3> 
<p><mark><font face="微软雅黑" size="3" color="#666FF">示例1：</font></mark></p> 
<pre><code class="prism language-c"><span class="token comment">// 计算Func2的时间复杂度？</span>
<span class="token keyword">void</span> <span class="token function">Func2</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">*</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">++</span>count<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">int</span> M <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>M<span class="token operator">--</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">++</span>count<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>执行的次数为2*N+10，因为只保留最高次项，所以为2 *N，又因为要去除与这个项相乘的常数，所以为O(N)</p> 
<p><mark><font face="微软雅黑" size="3" color="#666FF">示例2：</font></mark></p> 
<pre><code class="prism language-c"><span class="token comment">// 计算Func3的时间复杂度？</span>
<span class="token keyword">void</span> <span class="token function">Func3</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">,</span> <span class="token keyword">int</span> M<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> M<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">++</span>count<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">++</span>count<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>F(N)=M+N，如果不确定M和N的关系，则O(M+N)；若M远大于N，则O(M)；若N远大于M，则O(N)；；若N与M差不多大，则O(N)或者O(M)</p> 
<p><mark><font face="微软雅黑" size="3" color="#666FF">示例3：</font></mark></p> 
<pre><code class="prism language-c"><span class="token comment">// 计算Func4的时间复杂度？</span>
<span class="token keyword">void</span> <span class="token function">Func4</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token operator">++</span>count<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>F(N)=100，用常数1取代运行时间中的所有加法常数，所以O(1)，（O(1)并不是代表1次，而是常数次）</p> 
<p><mark><font face="微软雅黑" size="3" color="#666FF">示例4：</font></mark></p> 
<pre><code class="prism language-c"><span class="token comment">// 计算BubbleSort的时间复杂度？</span>
<span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> end <span class="token operator">=</span> n<span class="token punctuation">;</span> end <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>end<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> exchange <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				exchange <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>exchange <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>外面的for循环第1次时，里面的循环n-1次；外面的for循环第2次时，里面的循环n-2次；外面的for循环第3次时，里面的循环n-3次；……外面的for循环第n次时，end=1，里面的循环0次；所以是一个等差数列，Sn=n*(n-1)/2，所以O(N^2)</p> 
<p><mark><font face="微软雅黑" size="3" color="#666FF">示例5：二分查找</font></mark></p> 
<pre><code class="prism language-c"><span class="token comment">// 计算BinarySearch的时间复杂度？</span>
<span class="token keyword">int</span> <span class="token function">BinarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> begin <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> end <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token comment">// [begin, end]：begin和end是左闭右闭区间，因此有=号</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>begin <span class="token operator">&lt;=</span> end<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> mid <span class="token operator">=</span> begin <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>end <span class="token operator">-</span> begin<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> x<span class="token punctuation">)</span>
			begin <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&gt;</span> x<span class="token punctuation">)</span>
			end <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">else</span>
			<span class="token keyword">return</span> mid<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这是二分查找，最好的情况是执行1次，但时间复杂度关注的是算法的最坏运行情况：一直使用二分法，直至范围内只有1个元素。比如我们要找的元素是第一个元素，要使用x次二分法，即x次循环<br> <img src="https://images2.imgbox.com/1e/bd/l1Smx8Tu_o.png" alt="在这里插入图片描述"><br> N/(2^x)=1，所以x=log2 N，即底数为2，对数为N的计算结果，由于log2 N不好表示又经常会被用到，所以规定logN代表log2 N，将底数为2的底数省略(底数不为2的不能省略)，有些地方也会写成lgN(不建议)。所以O(logN)</p> 
<p>二分查找相对于暴力查找(对数组遍历)是十分便利的，但前提是数组是有序的</p> 
<p><mark><font face="微软雅黑" size="3" color="#666FF">示例6：</font></mark></p> 
<pre><code class="prism language-c"><span class="token comment">// 计算PartSort1的时间复杂度？</span>
<span class="token keyword">int</span> <span class="token function">PartSort1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> keyi <span class="token operator">=</span> left<span class="token punctuation">;</span>
	<span class="token keyword">int</span> n<span class="token operator">=</span>right<span class="token operator">-</span>left<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//找小</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			right<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//找大</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			left<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>keyi<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> left<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/1a/28/pFSFHjIn_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b3/48/4YLeDR2I_o.png" alt="在这里插入图片描述"><br> 当left&lt;right时，进入第二个while循环，找a[right] &lt; a[keyi]的数，否则right- -，a[right]指向前一个元素。再进入第3个while循环，找a[left] &gt; a[keyi]的数，否则left++，a[left]指向后一个元素。再判断是否left&lt;righ，是则再次执行上述循环，否则退出循环。到退出第一个while循环时，left&gt;=right，此时总的循环次数为n，n为未进行任何操作时right-left的值，即这段数组的长度，所以O(N)</p> 
<p><mark><font face="微软雅黑" size="3" color="#666FF">示例7：</font></mark></p> 
<pre><code class="prism language-c"><span class="token comment">// 计算阶乘递归Fac的时间复杂度？</span>
<span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">Fac</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> N<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> N<span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token function">Fac</span><span class="token punctuation">(</span>N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> N<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>递归调用是多次调用累加，共调用了N+1次，所以O(N)<br> <img src="https://images2.imgbox.com/d6/d0/tWZauLFb_o.png" alt="在这里插入图片描述"></p> 
<p><mark><font face="微软雅黑" size="3" color="#666FF">示例8：斐波那契数列</font></mark></p> 
<pre><code class="prism language-c"><span class="token comment">// 计算斐波那契递归Fib的时间复杂度？</span>
<span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">Fib</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> N<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>N <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token function">Fib</span><span class="token punctuation">(</span>N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">Fib</span><span class="token punctuation">(</span>N <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/0e/75/Le7w1NLj_o.png" alt="在这里插入图片描述"></p> 
<p>递归调用是多次调用累加，调用次数是等比数列（最后一行其实调用次数&lt;2^(n-2)，但由于时间复杂度只是估算大致执行的次数，所以我们将它当成有 2^(n-2)），调用次数的总和(错位相减法)：<br> Sn=2^(n-2) +2^(n-3) +2^(n-4)+…+ 2^1 +2^0<br> 2*Sn=2^(n-1) +2^(n-2) +2^(n-3)+…+ 2^2 +2^1<br> 相减得：Sn=2^(n-1) -1，所以O(2^N)</p> 
<p><mark><font face="微软雅黑" size="3" color="#666FF">示例9：</font></mark><br> <img src="https://images2.imgbox.com/eb/4e/rODf91sE_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token comment">//计算rotate的时间复杂度</span>
<span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> numsSize<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	k <span class="token operator">%=</span> numsSize<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>numsSize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> numsSize <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>令n=numsSize，要循环k*n次<br> 最好的情况：当k%n== 0时，不用旋转，O(1)<br> 最坏的情况：当k%n== n-1时，n(n-1)–&gt;O(N^2)</p> 
<hr> 
<h2><a id="_264"></a>三.空间复杂度</h2> 
<p>空间复杂度也是一个数学表达式，是对一个算法在运行过程中<strong>临时额外占用存储空间大小的量度</strong> 。<br> 空间复杂度不是程序占用了多少bytes的空间，因为这个也没太大意义，所以空间复杂度算的是变量的个数。空间复杂度计算规则基本跟实践复杂度类似，也使用<strong>大O渐进表示法</strong>。<br> 注意：<strong>函数运行时所需要的栈空间(存储参数、局部变量、一些寄存器信息等)在编译期间已经确定好了，因此空间复杂度主要通过函数在运行时候显式申请的额外空间来确定。</strong></p> 
<p><mark><font face="微软雅黑" size="3" color="#666FF">示例1：</font></mark></p> 
<pre><code class="prism language-c"><span class="token comment">// 计算BubbleSort的空间复杂度？</span>
<span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">assert</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> end <span class="token operator">=</span> n<span class="token punctuation">;</span> end <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>end<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> exchange <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				exchange <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>exchange <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>空间复杂度是求临时额外占用存储空间大小的量度，额外的意思是不算函数形参，本题中数组a和变量n都是形参，所以它们不算在空间复杂度中，end、exchange和i不是形参，所以使用了3个额外空间，所以空间复杂度为 O(1)</p> 
<p><mark><font face="微软雅黑" size="3" color="#666FF">示例2：</font></mark></p> 
<pre><code class="prism language-c"><span class="token comment">// 计算阶乘递归Fac的空间复杂度？</span>
<span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">Fac</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> N<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>N <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token function">Fac</span><span class="token punctuation">(</span>N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> N<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>递归的空间复杂度计算，也是空间累加，但不同的是空间可以重复利用。在一次阶乘递归中没有额外变量，所以O(1)，要调用N+1次，所以O(N)</p> 
<p><mark><font face="微软雅黑" size="3" color="#666FF">示例3：</font></mark></p> 
<pre><code class="prism language-c"><span class="token comment">// 计算斐波那契递归Fib的空间复杂度？</span>
<span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">Fib</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> N<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>N <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token function">Fib</span><span class="token punctuation">(</span>N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">Fib</span><span class="token punctuation">(</span>N <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>递归的空间复杂度计算，也是空间累加，但不同的是空间可以重复利用。<br> 计算斐波那契数时程序运行是“一条道走到黑的”，即计算fib(n)就要计算fib(n-1)和fib(n-2)，它们不是同时计算的，而是fib(n-1)先计算，等得到结果后再计算fib(n-2)；要fib(n-1)又要先计算fib(n-2)和fib(n-3)的值，fib(n-2)先计算，等得到结果后再计算fib(n-3)……计算fib(3)时要计算fib(2)和fib(1)，fib(2)先计算，等得到结果后释放fib(2)的空间，再计算fib(1)，所以得到了fib(3)的值；释放fib(3)的空间后再求得fib(2)的值，释放fib(2)的空间，得到fib(4)，再求fib(3)的值得到fib(5)……<br> 所以最多占用的空间为n-1个，O(N)</p> 
<p><img src="https://images2.imgbox.com/45/71/kcSt28bZ_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p><font face="微软雅黑" size="4" color="#666FF">好了，那么本篇博客就到此结束了，如果你觉得本篇博客对你有些帮助，可以给个大大的赞👍吗，感谢看到这里，我们下篇博客见❤️</font></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2077aa21a718b909c2fcc7f7df38f7d3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">实现linux cp指令的代码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/30dedc493303785b44331137d122c908/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【leetcode】移除元素</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>