<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17e77337ef5bafcd866603bbd4a7b4ad/" rel="bookmark">
			推荐算法概述：基于内容的推荐算法、协同过滤推荐算法和基于知识的推荐算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“无意中发现了一个巨牛的人工智能教程，忍不住分享一下给大家。教程不仅是零基础，通俗易懂，而且非常风趣幽默，像看小说一样！觉得太牛了，所以分享给大家。点这里可以跳转到教程。”
所谓推荐算法就是利用用户的一些行为，通过一些数学算法，推测出用户可能喜欢的东西。推荐算法主要分为两种
1. 基于内容的推荐 基于内容的信息推荐方法的理论依据主要来自于信息检索和信息过滤，所谓的基于内容的推荐方法就是根据用户过去的浏览记录来向用户推荐用户没有接触过的推荐项。主要是从两个方法来描述基于内容的推荐方法：启发式的方法和基于模型的方法。启发式的方法就是用户凭借经验来定义相关的计算公式，然后再根据公式的计算结果和实际的结果进行验证，然后再不断修改公式以达到最终目的。而对于模型的方法就是根据以往的数据作为数据集，然后根据这个数据集来学习出一个模型。一般的推荐系统中运用到的启发式的方法就是使用tf-idf的方法来计算，跟还有tf-idf的方法计算出这个文档中出现权重比较高的关键字作为描述用户特征，并使用这些关键字作为描述用户特征的向量；然后再根据被推荐项中的权重高的关键字来作为推荐项的属性特征，然后再将这个两个向量最相近的（与用户特征的向量计算得分最高）的项推荐给用户。在计算用户特征向量和被推荐项的特征向量的相似性时，一般使用的是cosine方法，计算两个向量之间夹角的cosine值。
2.基于协同过滤的推荐 基于协同过滤的推荐算法理论上可以推荐世界上的任何一种东西。图片、音乐、样样可以。 协同过滤算法主要是通过对未评分项进行评分 预测来实现的。不同的协同过滤之间也有很大的不同。
基于用户的协同过滤算法: 基于一个这样的假设“跟你喜好相似的人喜欢的东西你也很有可能喜欢。”所以基于用户的协同过滤主要的任务就是找出用户的最近邻居，从而根据最近邻 居的喜好做出未知项的评分预测。这种算法主要分为3个步骤：
一，用户评分。可以分为显性评分和隐形评分两种。显性评分就是直接给项目评分（例如给百度里的用户评分），隐形评分就是通过评价或是购买的行为给项目评分 （例如在有啊购买了什么东西）。
二，寻找最近邻居。这一步就是寻找与你距离最近的用户，测算距离一般采用以下三种算法：　1.皮尔森相关系数。　2.余弦相似性。　3调整余弦相似性。　调整余弦 相似性似乎效果会好一些。
三，推荐。产生了最近邻居集合后，就根据这个集合对未知项进行评分预测。把评分最高的N个项推荐给用户。 这种算法存在性能上的瓶颈，当用户数越来越多的时候，寻找最近邻居的复杂度也会大幅度的增长。
因而这种算法无法满足及时推荐的要求。基于项的协同过滤解决了这个问题。 基于项的协同过滤算法 根基于用户的算法相似，只不过第二步改为计算项之间的相似度。由于项之间的相似度比较稳定可以在线下进行，所以解决了基于用户的协同过滤算法存在的性能瓶 颈。
3.基于关联规则推荐 基于关联规则的推荐（Association Rule-based Recommendation）是以关联规则为基础，把已购商品作为规则头，规则体为推荐对象。关联规则挖掘可以发现不同商品在销售过程中的相关性，在零售业中已经得到了成功的应用。管理规则就是在一个交易数据库中统计购买了商品集X的交易中有多大比例的交易同时购买了商品集Y，其直观的意义就是用户在购买某些商品的时候有多大倾向去购买另外一些商品。比如购买牛奶的同时很多人会同时购买面包。
算法的第一步关联规则的发现最为关键且最耗时，是算法的瓶颈，但可以离线进行。其次，商品名称的同义性问题也是关联规则的一个难点。
4.基于效用推荐 基于效用的推荐（Utility-based Recommendation）是建立在对用户使用项目的效用情况上计算的，其核心问题是怎么样为每一个用户去创建一个效用函数，因此，用户资料模型很大程度上是由系统所采用的效用函数决定的。基于效用推荐的好处是它能把非产品的属性，如提供商的可靠性（Vendor Reliability）和产品的可得性（Product Availability）等考虑到效用计算中。
5.基于知识的推荐 基于知识的推荐（Knowledge-based Recommendation）在某种程度是可以看成是一种推理（Inference）技术，它不是建立在用户需要和偏好基础上推荐的。基于知识的方法因它们所用的功能知识不同而有明显区别。效用知识（Functional Knowledge）是一种关于一个项目如何满足某一特定用户的知识，因此能解释需要和推荐的关系，所以用户资料可以是任何能支持推理的知识结构，它可以是用户已经规范化的查询，也可以是一个更详细的用户需要的表示。
6.组合推荐 由于各种推荐方法都有优缺点，所以在实际中，组合推荐（Hybrid Recommendation）经常被采用。研究和应用最多的是内容推荐和协同过滤推荐的组合。最简单的做法就是分别用基于内容的方法和协同过滤推荐方法去产生一个推荐预测结果，然后用某方法组合其结果。尽管从理论上有很多种推荐组合方法，但在某一具体问题中并不见得都有效，组合推荐一个最重要原则就是通过组合后要能避免或弥补各自推荐技术的弱点。
在组合方式上，有研究人员提出了七种组合思路：
1）加权（Weight）：加权多种推荐技术结果。
2）变换（Switch）：根据问题背景和实际情况或要求决定变换采用不同的推荐技术。
3）混合（Mixed）：同时采用多种推荐技术给出多种推荐结果为用户提供参考。
4）特征组合（Feature combination）：组合来自不同推荐数据源的特征被另一种推荐算法所采用。
5）层叠（Cascade）：先用一种推荐技术产生一种粗糙的推荐结果，第二种推荐技术在此推荐结果的基础上进一步作出更精确的推荐。
6）特征扩充（Feature augmentation）：一种技术产生附加的特征信息嵌入到另一种推荐技术的特征输入中。
7）元级别（Meta-level）：用一种推荐方法产生的模型作为另一种推荐方法的输入。
主要推荐方法的对比 各种推荐方法都有其各自的优点和缺点，见表1。
表1 主要推荐方法对比
推荐方法优点缺点基于内容推荐 推荐结果直观，容易解释； 不需要领域知识
新用户问题； 复杂属性不好处理；
要有足够数据构造分类器
协同过滤推荐新异兴趣发现、不需要领域知识； 随着时间推移性能提高；
推荐个性化、自动化程度高；
能处理复杂的非结构化对象
稀疏问题； 可扩展性问题；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17e77337ef5bafcd866603bbd4a7b4ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcf4a73718b639743db87a360d932ef5/" rel="bookmark">
			作为互金产品经理，至少要具备哪些基本素质？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：7姐
全文共 字，阅读需要 分钟
———— / BEGIN / ————
优秀的产品经理很多很多，有的擅长数据分析，有的擅长用户体验等等。但是在互联网金融领域，无论是沙龙分享上，还是优秀的APP打造者，优秀突出的产品经理却还没有那么多。
很多产品经理想转型，有的觉得这个行业有更大的发展，有的可能觉得金融行业往往看着是多金的，有的是自己的兴趣所在。
在知乎上总能看到很多提问：如果转行做互联网金融的产品经理或者是转行到互联网金融领域该怎么做等等。
自己从事PM已经是第七个年头，步入证券行业直接上手做金融APP也即将三年。那么作为互金产品经理，要具备哪些基本素质或者是要做什么准备呢？
一、心态： 做好长期学习的准备 很多人肯定会问，谁工作不得学习啊，但是可以想想之前在互联网行业，可能更多学习的是工作方法，学习竞品，学习产品设计的等等。
这些内容很多程度上是经验的积累，是逻辑性的行程，是美感的培养等等。
如果进入金融行业，金融行业覆盖的范围很广；例如保险、银行、基金、证券、P2P等等，这里面涉及的内容不是多练习画原型，多看竞品，多看介绍互联网金融的书就能学到的。即使有一位导师，给你讲里面的知识，如果没有什么金融基础的话，根本不懂导师在说什么。
尤其是证券行业，P2P或者保险可能还稍微好一些，尤其证券和基金的专业性非常高，其中证券中的专业性太强了。
例如证券行业，想进入这个行业，即使不是业务人员也需要具备证券从业资格，而且每年都要培训学习，新的业务或者老的业务有变动，都需要你去了解。
举个例子：融资融券业务需要你作为一个产品经理去设计，去满足客户的需求，如果业务都不懂的话，无从设计。
所以，心态上要做好长期学习，不断学习的准备。
如果觉得自己喜欢吃老本，没什么动力去看书，去研究的话，还是不要进入这个行业。
二、兴趣： 喜欢金融，喜欢投资理财 说实在话，步入金融行业会对自己的生活带来很多好处，尤其是对于那些本身喜欢投资理财的人来说，更是有很大优势。
作为一名产品经理，如果你本身就是股票爱好者或者是理财忠实者的话，那步入互金行业会有很大的优势。
很多产品经理在步入金融圈子之前，自己从来没接触过股票，没买过基金，甚至买过理财产品。
可以想象一下：如果你是一个高净值的客户，你所使用的理财软件，却是一个都不懂理财的人设计的，那这样的产品你觉得会符合你的使用习惯吗？
所以，如果有这样的理财经历，对投资理财炒股基金本身有浓厚兴趣的，进入这个行业往往比别人轻松一些——因为你已经是你自己的目标客户，至少是了解客户的。
三、行动： 培养学习习惯、了解目标客户、具备产品思维 如果说已经做好准备要学习进入这行，并且自身也充满兴趣，那么就开始行动吧。行动中要做的事情有很多，我简单总结为三个步骤：
1. 培养学习习惯 1）基础业务的学习：
举个例子，如果有客户想开一个基金户或者开一个证券账户，作为产品经理该怎么设计呢？
开户这个功能，也许你有很多创新的项目，但是证券开户是有证监会等国家部门的具体要求的，如果你不了解具体开户的流程，只有纯粹的想法和创新，是不行的。
同样，如果说让你设计一个基金持仓的功能，持仓中不是简单的功能堆砌，你要了解基金这个业务，基金申购赎回的具体规则，才可以设计这个功能。
所以，先去赶紧买书上网学习这些基础业务吧，这些才是真金白银，真正工作中所需要的。
2）亲身体验学习：
我们每个人即使没有买过基金，没有买过p2p类的产品，但是我们基本每个人都要用银行APP、支付宝等等。这些涉及到理财的优秀的APP很多功能值得我们去研究，去体验。
所以不要嫌麻烦，多跑跑腿，多体验一些产品，看看其中的缺陷，亲自操作一些流程，真正去体验一下客户的感受。
2. 了解目标客户 作为一个产品经理，往往工作岗位是在IT部门或者是在单独的互联网金融部门，这些岗位都属于后台岗位，那么后台岗位如何了解前台的客户们的需求呢？
1）多与一线同事保持沟通：
还是以证券行业举例，证券公司往往下设很多营业部，一线同事的经验宝贵，他们获取的反馈也是最新鲜，最突出的。
所以，和一线的同事建立长期有效的沟通机制，获取一线客户的需求和建议。
2）客服团队是最有利的支撑：
很多公司都有客服团队，客服人员的专业能力比一般的产品经理不知道要高多少倍，他们积累的问题和需求往往比一线同事更多。
千万不要忽略这个团体，他们是产品经理的老师也是最有利的帮手。
3）把同事、家人或自己作为客户：
很多人可能会问，还没有进入到这个行业或者自己理想的公司，我该怎么了解目标客户呢？
这个也很容易，可能你的父亲或者身边的同事就在炒股，可能你最近也开始向理财——这些也都是资源，虽然人群少，但是也可以挖掘出不能年龄层、社交层客户的需求。
3. 具备产品思维 这一点如果之前就是PM那么就很好掌握，这是产品经理必备的素质。产品思维可以通过学习、工作中的项目慢慢培养与提高的。说一些实在的，可行的方法。
1）多画思维导图或者流程图：
很多产品经理有一个误区，那就是一定要会画原型。
其实画原型是PM最基本最简单的一项工作，在这之前理清需求，思路清晰才是更重要的。
自己有好想法的时候，动动笔，这样能很快找出问题，完善自己的逻辑。
2）培养多向思维：
做产品经理基本素质就是能把很多人想不到事情考虑周全，能为一些客户特殊的行为或者错误的行为，提供缓冲，找到解决办法。
这个可以多做一些小练习，例如怎么设计一个登录页？不要纯粹地以正常人的思维去设计，多去考虑一些特殊情况，例如客户忘记密码怎么办？页面崩溃怎么办？输入错误怎么办等等。
这些思维无论在不在互金行业都要具备。
3）多去找程序员GG聊天：
开发童鞋的思维往往非常严谨，他们总能从你的设计中找出你看不到的问题，这真的是一个提高自己的很好的机会。
同时，多去和他们聊，多学点研发知识，对于你们工作有效会提升很多。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcf4a73718b639743db87a360d932ef5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ea86aef2f6024eb2fba855224f2ed6b/" rel="bookmark">
			Java 子类未重写的方法调用父类还是子类的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		父类-------------------------------------------------------
public class begetter {
public void a1(){ System.out.println("父类a1方法"); this.b1(); } public void b1(){ System.out.println("父类b1方法"); } }
子类------------------------------------------------------
public class seed extends begetter {
public void b1(){
System.out.println("子类b1方法");
}
}
测试类---------------------------------------------------
public class test {
public static void main(String[] args){
begetter s1=new seed();
s1.a1();
}
}
输出结果：
父类a1方法
子类b1方法
new的seed() 所以this指向seed()类
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaede4ef7e0e0caaecee2a730ff625d7/" rel="bookmark">
			字符集&amp;字符编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符编码 字符(Character)是各种文字和符号的总称，字符集(Character set)是多个字符的集合，
常见字符集名称：ASCII字符集、GB2312字符集、BIG5字符集、 GB18030字符集、Unicode字符集等。
1 ASCII 1.1 发展历史 美国人首先对其英文字符进行了编码，也就是最早的ASCII码，
用一个字节的低7位来表示英文的128个字符，高1位统一为0；
后来欧洲人发现尼玛你这128位哪够用，比如我高贵的法国人字母上面的还有注音符，这个怎么区分，
把高1位编进来吧，这样欧洲普遍使用一个全字节进行编码，最多可表示256位。
可显示字符：英文大小写字符、阿拉伯数字和西文符号。
1.2 编码方式:单字节存储 7位（bits）表示一个字符，共128字符，字符值从0到127，其中32到126是可打印字符。
7位编码的字符集只能支持128个字符，为了表示更多的欧洲常用字符对ASCII进行了扩展，ASCII扩展字符集使用8位（bits）表示一个字符，共256字符。
1.3 存储长度 存储长度:1个字节
注：ASCII码表
2 GB2312 2.1 发展历史 但是即使位数少，不同国家地区用不同的字符编码，虽然0–127表示的符号是一样的，但是128–255这一段的解释完全乱套了，即使2进制完全一样，表示的字符完全不一样，比如135在法语，希伯来语，俄语编码中完全是不同的符号；
更麻烦的是，尼玛这电脑高科技传到中国后，中国人发现我们有10万多个汉字，你们欧美这256字塞牙缝都不够。于是就发明了GB2312这些汉字编码，典型的用2个字节来表示绝大部分的常用汉字，最多可以表示65536个汉字字符，这样就不难理解有些汉字你在新华字典里查得到，但是电脑上如果不处理一下你是显示不出来的了吧。
GB2312又称为GB2312-80字符集，全称为《信息交换用汉字编码字符集·基本集》，由原中国国家标准总局发布，1981年5月1日实施。
GB2312收录简化汉字及一般符号、序号、数字、拉丁字母、日文假名、希腊字母、俄文字母、汉语拼音符号、汉语注音字母，共 7445 个图形字符。
2.2 编码方式:分区存储&amp;双字节存储 "高位字节"使用了0xA1-0xF7(把01-87区的区号加上0xA0)，"低位字节"使用了0xA1-0xFE(把01-94加上0xA0)。
2.4 存储长度 存储长度:2个字节
2.5 编码举例 以GB2312字符集的第一个汉字"啊"字为例，它的区号16，位号01，则区位码是1601，在大多数计算机程序中，高字节和低字节分别加0xA0得到程序的汉字处理编码0xB0A1。
计算公式是：0xB0=0xA0+16, 0xA1=0xA0+1。
3 BIG5 3.1 发展历史 1984年由台湾财团法人信息工业策进会和五家软件公司宏碁 (Acer)、神通 (MiTAC)、佳佳、零壹 (Zero One)、大众 (FIC)创立，故称大五码，Big5字符集共收录13,053个中文字，该字符集在中国台湾使用。
3.2 编码方式:双字节存储 Big5码使用了双字节储存方法，以两个字节来编码一个字。第一个字节称为“高位字节”，第二个字节称为“低位字节”。高位字节的编码范围0xA1-0xF9，低位字节的编码范围0x40-0x7E及0xA1-0xFE。
各编码范围对应的字符类型如下：0xA140-0xA3BF为标点符号、希腊字母及特殊符号，另外于0xA259-0xA261，存放了双音节度量衡单位用字：兙兛兞兝兡兣嗧瓩糎；0xA440-0xC67E为常用汉字，先按笔划再按部首排序；0xC940-0xF9D5为次常用汉字，亦是先按笔划再按部首排序。
3.3 存储长度 存储长度:2个字节
4 GB18030 GB18030的全称是GB18030-2000《信息交换用汉字编码字符集基本集的扩充》，是我国政府于2000年3月17日发布的新的汉字编码国家标准，2001年8月31日后在中国市场上发布的软件必须符合本标准。
4.1 编码方式:单字节、双字节和四字节存储 单字节部分使用0×00至0×7F码(对应于ASCII码的相应码)。双字节部分，首字节码从0×81至0×FE，尾字节码位分别是0×40至0×7E和0×80至0×FE。四字节部分采用GB/T 11383未采用的0×30到0×39作为对双字节编码扩充的后缀，这样扩充的四字节编码，其范围为0×81308130到0×FE39FE39。其中第一、三个字节编码码位均为0×81至0×FE，第二、四个字节编码码位均为0×30至0×39
4.2 存储长度 存储长度:1~4个字节
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aaede4ef7e0e0caaecee2a730ff625d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fa8a77ab940274657868e9181f08ade/" rel="bookmark">
			树莓派-内核开发-说明 下载代码 编译 替换内核
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：http://nicekwell.net/blog/20171108/shu-mei-pai-nei-he-kai-fa-shuo-ming-xia-zai-dai-ma-bian-yi-ti-huan-nei-he.html
树莓派运行linux系统，内核代码开源，我们可以自己修改内核代码、编写驱动。
本文介绍如何获取linux内核代码，并完成编译、内核替换。
一、概述 树莓派的github主页：https://github.com/raspberrypi，里面包含了linux源码、交叉编译工具链等内容。
对于我们要用到的有两个仓库：
https://github.com/raspberrypi/linux 内核源码
https://github.com/raspberrypi/tools 交叉编译工具链（仅在交叉编译时用到）
注： 1、树莓派里安装的系统镜像版本要和kernel代码对应。因为树莓派系统是在不断开发和升级的，如果你的树莓派使用的是某个时间的系统镜像，那么最好也使用当时的kernel代码。 2、关于内核编译方法，官网有很详细的介绍：https://www.raspberrypi.org/documentation/linux/kernel/building.md，这里算是翻译和补充。 3、以下编译过程在树莓派1和树莓派3B上测试ok。
二、ubuntu里交叉编译 1、获取交叉编译工具和源码 源码：git clone git@github.com:raspberrypi/linux
交叉编译工具：git clone git@github.com:raspberrypi/tools
2、配置编译环境变量 2.1 手动配置环境变量 编译工具下载后，在64位ubuntu上编译我们需要的编译工具bin文件在：tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin 目录下，将此目录添加到环境变量PATH中，添加方法：
PATH=$PATH:/home/nicek/githubProjects/raspberrypi/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin
如果是在32位系统中编译则要选择32位的交叉编译工具。
配置完成之后可以用编译工具命令查看到版本号： arm-linux-gnueabihf-gcc -v
之后，所有的make命令都要指明一些环境变量： ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7
ARCH=arm 指明当前要编译arm，虽然树莓派是64位的，这里仍然选择arm，而不是arm64。 CROSS_COMPILE 指明交叉工具链名称。 KERNEL 指明kernel类型，树莓派1设置为kernel，树莓派2、3设置为kernel7。 每次make都需要指明这些环境变量，如： ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make menuconfig ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make -j4 zImage
2.2 自动配置环境变量 上面这些环境变量每次命令都要写很麻烦，可以通过export一次设置： export PATH=$PATH:/home/nicek/githubProjects/raspberrypi/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 之后在本终端里执行的所有命令都带有这些环境变量信息。
此 export 命令可以写成一个脚本，然后在编译前在终端里source一下这个脚本即可设置好所有的环境变量。就像android编译前也要先source一下envsetup.sh一样。
1 2 3 4 #!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fa8a77ab940274657868e9181f08ade/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bcb5b157dbfb353393ed43ca3108f46/" rel="bookmark">
			图像处理技术上的空间域和空间频率域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		空间域与频率域为我们提供了不同的视角。在空间域中，函数自变量（x,y）被视为二维空间中的一个点，数字图像f(x,y)即为一个定义在二维空间中的矩形区域上的离散函数；换一个角度，如果将f(x,y)视为幅值变化的二维信号，则可以通过某些变换手段（如傅里叶变换、离散余弦变换、沃尔什变换和小波变换等）在频域下对图像进行处理了 因为在频率域就是一些特性比较突出，容易处理。比如在空间图像里不好找出噪声的模式，如果变换到频率域，则比较好找出噪声的模式，并能更容易的处理。
具体名词解释如下：
空间域　英文： spatial domain。 释义： 又称图像空间(image space)。由图像像元组成的空间。在图像空间中以长度(距离)为自变量直接对像元值进行处理称为空间域处理。
频率域。 英文： spatial frequency domain。 释义： 以频率(即波数)为自变量描述图像的特征,可以将一幅图像像元值在空间上的变化分解为具有不同振幅、空间频率和相位的简振函数的线性叠加,图像中各种频率成分的组成和分布称为空间频谱。这种对图像的频率特征进行分解、处理和分析称为频率域处理或波数域处理。
二者关系：
空间域与频率域可互相转换。在频率域中可以引用已经很成熟的频率域技术,处理的一般步骤为：①对图像施行二维离散傅立叶变换或小波变换,将图像由图像空间转换到频域空间。②在频率域中对图像的频谱作分析处理,以改变图像的频率特征。即设计不同的数字滤波器,对图像的频谱进行滤波。
空间域处理的应用可以参考：http://www.cnblogs.com/kangronghu/p/6266637.html
https://wenku.baidu.com/view/b97f42eb172ded630b1cb6bc.html?pn=50
频率域处理主要用于与图像空间频率有关的处理中。如图像恢复、图像重建、辐射变换、边缘增强、图像锐化、图像平滑、噪声压制、频谱分析、纹理分析等处理和分析中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0acc3963bfac0b64bde59ca07fcae6ab/" rel="bookmark">
			疫情控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.预处理倍增 所有的军队都要尽可能地往根节点走。 那么我们可以dfs一遍，将倍增要用的一些值都处理好 2.二分答案 所以就是二分啦，二分一个答案。 3.上提军队 使用倍增的方法将军队在二分出的答案限制内尽力往上，不过不可以到根节点。 4.处理剩余路程 记录还可以走多少 5.dfs找能走的子树 找需要走的子树 6.走子树，走到第一个叉 将我们已经记录好了的可以到根节点的军队按照剩余路程从大到小排序。 然后贪心，用最长的更新走最长的 这样我们就可以判断当前二分出的答案是否可行了。
#include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #define ll long long using namespace std; const int M=51000; struct st{ ll rest,id; }; st a[M],b[M]; ll vis[M],used[M],dep[M][34],flag[M],f[M][34],jd[M],na,nb,restbj[M],restmin[M]; ll n,m; ll tot,head[M],nex[M*4],cos[M*2],to[M*2]; void add(ll x,ll y,ll z){ nex[++tot]=head[x]; to[tot]=y; cos[tot]=z; head[x]=tot; } ll cmp(const st&amp;a,const st&amp;b){ return a.rest&gt;b.rest; } void dfs(ll x,ll las,ll h){ f[x][0]=las,dep[x][0]=h; for(int i=1;i&lt;=18;++i){ f[x][i]=f[f[x][i-1]][i-1]; dep[x][i]=dep[x][i-1]+dep[f[x][i-1]][i-1]; } for(int i=head[x];i;i=nex[i]) if(to[i]!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0acc3963bfac0b64bde59ca07fcae6ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/808f9f2edc342aafde935bb531f5bae2/" rel="bookmark">
			js判断本地是否安装app
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		var ua = navigator.userAgent.toLowerCase(); 1.判断是否是微信 function isWeixinBrowser() { return (/micromessenger/.test(ua)) ? true : false; } 2.判断是否是android var isAndroid = ua.indexOf('android') &gt; -1 || ua.indexOf('linux') &gt; -1; 3.具体过程 scheme是客户端定义的url-scheme $("a[href^='scheme://']").on('click',function(e){ e.preventDefault();//阻止默认行为 if(isWeixinBrowser()){ $('.layer').show();//遮罩层（使用外部浏览器打开，此处样式自行设定） }else{ if(isAndroid){ //android $('body').append("&lt;iframe src="" style='display:none' target='' &gt;&lt;/iframe&gt;");//target为空防止在当前页面刷新 setTimeout(function(){window.location = 'http://www.510wifi.com/weixin_download_client.html'},600); }else{ //ios window.location = 'scheme://openapp'; setTimeout(function(){window.location = 'itms-apps://itunes.apple.com/app/id123456789'},25); } } }) 附：判断手机端各种浏览器 if (ua.match(/WeiBo/i) == "weibo") { //在新浪微博客户端打开 } if (ua.match(/QQ/i) == "qq") { //在QQ空间打开 } if (browser.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/808f9f2edc342aafde935bb531f5bae2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db3f0178e3b4117ebe4501383b2934eb/" rel="bookmark">
			多项式相加减【数据结构实验报告】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验名称：实验一 多项式加减法
学号：***
姓名：gnosed
实验日期：2017.10.16
一、实验目的
通过实现多项式的加减法，对链表有更深入的了解
二、实验具体内容
1、实验题目1：
（1）题目
问题描述：
设计一个一元稀疏多项式简单的加减法计算器
实现要求：
一元稀疏多项式简单计算器的基本功能是：
（1）输入并建立多项式
（2）输出多项式
（3）多项式A和B相加，建立多项式C＝A＋B，并输出相加的结果多项式C
（4）选作：多项式A和B相减，建立多项式C＝A－B，并输出相加的结果多项式D
（5）添加多项式因式
（6）摧毁多项式
（2）分析
对于各种功能
（1） 输入并建立多项式：
为输入输出格式的统一，本人规定因式格式为ax^b(a,b为int 类型) 。
规定指数呈递增输入输出。
创建两个单链表，表示两个一元多项式，单链表的一个结点表示多项式的一个因式，结点有一元参数的系数域、指数域和连接多个因式的指针域。
为方便对多项式进行删除或修改，单链表应该带空头结点。
（2） 输出多项式：
输出各系数的符号时，要判断系数是正数则在其前输出加号，是负数则只需输出它本身（自带负号）。
（3） 多项式A和B相加或相减
申请两个节点指针分别指向A和B的首个因式，比较它们的指数，
相同则系数相加减，申请新的节点来储存系数和指数，两个指针同时右移；
若不相同，则将指数小的因式赋值给新申请的节点，插在新的单链表上，将指向指数较小因式的指针右移。
重复上述比较，当有指针为空时，
若有一个指针为空，则将另一个指针指向的剩余的多项式因式连接到新的多项式后面；
若两个指针同时为空，return。
由此看出，规定按指数从小到大的顺序储存多项式，决定了实现多项式相加减的这种算法的出现。
（4） 添加多项式因式：
因为多项式是按指数从小到大储存的，所以插入新因式时，需要找到插入的位置。充分考虑是单链表的前头中间还是末尾。
（5） 摧毁多项式：
申请一个节点类型的指针，通过其移动，释放掉单链表的全部节点，返回空的头结点。
（3）实验代码
源代码：
（1） Poly.h 头文件
#ifndefPOLY_H_INCLUDED #definePOLY_H_INCLUDED structPolynode{ int cof,exp; struct Polynode* next; }; typedef structPolynode* plist; plistCrea_poly(plist head); voidprint_poly(plist head); plistaddnode_poly(plist head); plistdestor_poly(plist head); plistadd_or_substr_poly(plist a,plist b,char ope); #endif //POLY_H_INCLUDED （2） Poly.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db3f0178e3b4117ebe4501383b2934eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfcfa3a3ca99fb81a3463f834879ca8f/" rel="bookmark">
			一张图看懂docker命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，上图，该图出自Docker —— 从入门到实践的附录部分，基本概括了docker的所有命令。
从图中可以看到，对用户来说，大部分命令都是针对仓库(repository)，镜像(image)，容器(container)操作使用的，其他还包括管理命令，比如网络(network)，卷(volume)，节点(node)等的管理。 通过shell查看docker的帮助文档
$ docker --help Usage: docker COMMAND A self-sufficient runtime for containers Options: --config string Location of client config files (default "/home/blinkdr/.docker") -D, --debug Enable debug mode --help Print usage -H, --host list Daemon socket(s) to connect to -l, --log-level string Set the logging level ("debug"|"info"|"warn"|"error"|"fatal") (default "info") --tls Use TLS; implied by --tlsverify --tlscacert string Trust certs signed only by this CA (default "/home/blinkdr/.docker/ca.pem") --tlscert string Path to TLS certificate file (default "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfcfa3a3ca99fb81a3463f834879ca8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8d959914c67c76f6049ac39ef9972e7/" rel="bookmark">
			测试夹具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般，硬件工程师在工作中会遇到测试夹具，而这部分的知识恰恰是学生所不了解的，同时很少书籍介绍这玩意，于是本文补充这方面的不足。
一、什么是测试夹具？
上图就是测试夹具的实物图。
拉动红色把手，压下被测板，被测板跟夹具底下的针接触，针的另一端引线接到黑色木箱里的测试板。
测试板经过一些测试流程之后，给出测试结果。
具体流程，如下图所示。
被测板，也就是最终出货的产品，也叫目标板。
测试板，只是验证被测板是否正常而制作的辅助工具。
二、什么情况下使用测试夹具？
显然，做一台测试夹具并不容易，而且夹具上针的位置固定，灵活性不高。
一般来说，批量的板子才会做测试夹具。
做好测试夹具，测试PCBA板时，效率大大提高，因为不需要手动接线、人工操作测试流程。
但是，针对高速、高频信号，则难以制作测试夹具，因为夹具上的针可能会影响到被测板的信号质量。
三、怎样制作测试夹具？
1、被测板留有测试点或接插件（直插）供夹具测试使用。使用上面实物图的夹具，测试点应该打在板子底部，否则需要订做更高端的夹具。
2、找淘宝的店家或联系夹具厂制作夹具，并给出一台样机，和需要测试的位置。
3、制作测试板，以便完成测试流程。
4、如果测试板不能完成或不便完成测试流程，可以写个上位机，让电脑辅助测试。
四、测试夹具的维护。
一般来说，测试夹具一套系统，包含了机械、电子、计算机三大部分。
维护起来并不容易，主要考虑损耗品，如：夹具上的针、测试板的元件寿命、测试人员的误操作、电脑是否中毒等。
五、如何制作测试板？
根据被测板的功能，量身订做测试板。测试流程应尽可能覆盖被测板所有功能。
以下举个简单的例子。
1、测试电源。测试板用ADC采样被测板的电源电压，并能接通和切断被测板电源。。
2、测试串口。测试板用串口监测被测板的数据。
3、测试LED灯、蜂鸣器、喇叭。测试人员观察得知。
4、让被测板工作起来，并观察其行为。测试板用串口发指令到被测板。
5、只要拉下夹具把手，能产生标志信号，让测试板自动开始测试流程。
六、其它。
如果需要电脑软件来完成测试工作，请参考本博客的《单片机量产软件》。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f64a672963e00ce97ce5abf02df9c99/" rel="bookmark">
			洛谷月赛八连测 SAC E#1 - 一道大水题 Knight
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一开始一直re。。。。 原来是tot，cnt忘付出值为零了。。。。 跳了一上午。。 这个题就是一个包搜 因为只有16个旗子。 但白骑士，与黑骑士和国王不用记，因为你吃不掉黑骑士，国王你只要吃掉就赢了 所以将所有状态用二进制记录下来，有1&lt;&lt;13(2^13) 种，预处理出他们能走于不能走的地方 然后bfs从一个状态到另一个状态。
#include&lt;cstdio&gt; #include&lt;cstdlib&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;cstring&gt; #define ll long long using namespace std; struct st{ int x,y,s,k; }; int n;int p[60][60],cnt,tot;st ch[19],c[19]; int xx[10]={1,1,-1,-1,2,-2,2,-2},yy[10]={2,-2,2,-2,1,1,-1,-1}; int xx2[6]={1,1,-1,-1},yy2[6]={1,-1,1,-1}; char b[55][55];int sx,sy,tx,ty,a[55][55]; bool vis[1&lt;&lt;14][60][60]; bool check(int k,int x,int y){ //if(k&amp;(1&lt;&lt;(p[x][y]-1))&amp;&amp;p[x][y]==tot-1) //printf("1"); if(a[x][y]&lt;=1) return 1; if(a[x][y]==2||a[x][y]==7)return 0; if(k&amp;(1&lt;&lt;(p[x][y]-1))) return 0; return 1; } void C(int k,int x,int y){ for(int i=x+1;i&lt;=n;i++){ vis[k][i][y]=1; if(!check(k,i,y)) break; } for(int i=x-1;i&gt;=1;i--){ vis[k][i][y]=1; if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f64a672963e00ce97ce5abf02df9c99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20c2d09e79adfaf2db88e38fa8cf8ce0/" rel="bookmark">
			【多线程编程】线程私有数据（TSD）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Thread Specific Data（TSD）
线程私有数据，有什么用呢？在多线程中，经常要用全局变量来实现多个函数间的数据共享。由于数据空间是共享的，因此全局变量也为所有进程共有。但有时应用程序设计中必要提供线程私有的全局变量，这个变量被各个线程私有，但却可以跨过多个函数访问。
书上是这样说的：
int pthread_key_create(pthread_key_t *key, void (*destructor)(void*)); 该函数有两个参数，第一个参数是 pthread_key_t 变量指针，第二个参数是一个析构函数指针，在线程释放该线程存储时被调用，该函数指针可以设成 NULL，这样系统将调用默认的析构函数。析构函数正常返回0，其他任何返回值都表示出现了错误。 另外还有：
int pthread_setspecific(pthread_key_t key, const void *value); 当线程中需要存储特殊值的时候，可以调用 pthread_setspcific() 。该函数有两个参数，第一个为前面声明的pthread_key_t变量，第二个为void*变量，这样你可以存储任何类型的值。 void *pthread_getspecific(pthread_key_t key); 如果需要取出所存储的值，调用pthread_getspecific()。该函数的参数为前面提到的pthread_key_t变量，该函数返回void *类型的值。 下面用例子来说明：
#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; pthread_key_t key; pthread_once_t once = PTHREAD_ONCE_INIT;	// pthread_once 保证 create_key 只被执行一次 void create_key() { printf("init pthread_key\n"); if (pthread_key_create(&amp;key, NULL)) { printf("pthread_key_create failed"); } } void display() { printf("I'm %u\n", *(int *)pthread_getspecific(key)); } void * worker(void *arg) { pthread_once(&amp;once, create_key); pthread_t pid = pthread_self(); pthread_setspecific(key, &amp;pid); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20c2d09e79adfaf2db88e38fa8cf8ce0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49d8db6877f66cfa25459c9715054cd7/" rel="bookmark">
			Java从在数组中删除指定元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package org.usc.action; import java.util.ArrayList; import java.util.Arrays; import java.util.List; public class Test { public static void main(String[] args) { String[] str={ "张三" , "李四" , "王五" , "宋六" , "赵七" , "朱八" , "何九" , "田十" }; List&lt;String&gt; list=Arrays.asList(str); //将数组转换为list集合 if (list.contains( "张三" )){ //加入集合中包含这个元素 /*remove这些method时出现java.lang.UnsupportedOperationException异常。 * 这是由于Arrays.asList() 返回java.util.Arrays$ArrayList， * 而不是ArrayList。Arrays$ArrayList和ArrayList都是继承AbstractList， * remove，add等method在AbstractList中是默认throw UnsupportedOperationException而且不作任何操作。 * ArrayList override这些method来对list进行操作， * 但是Arrays$ArrayList没有override remove()，add()等， * 所以throw UnsupportedOperationException。 */ //这个时候我们直接移除会报错,所以我们要转换为Arraylist //list.remove("张三"); List&lt;String&gt; arrayList= new ArrayList&lt;String&gt;(list); //转换为ArrayLsit调用相关的remove方法 arrayList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49d8db6877f66cfa25459c9715054cd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73d01337a161e2140bc9b32bbb392b7c/" rel="bookmark">
			拟合与回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经常听到“回归分析”、“线性回归”等等名词，那么，这么晦涩的词语，到底来源于何处呢？
1、“回归”名词的由来 引自汪荣伟先生主编的《经济应用数学》 高尔顿（Frramcia Galton,1882-1911）早年在剑桥大学学习医学，但医生的职业对他并无吸引力，后来他接受了一笔遗产，这使他可以放弃医生的生涯，并与 1850－1852年期间去非洲考察，他所取得的成就使其在1853年获得英国皇家地理学会的金质奖章。此后他研究过多种学科（气象学、心理学、社会学、 教育学和指纹学等），在1865年后他的主要兴趣转向遗传学，这也许是受他表兄达尔文的影响。 从19世纪80年代高尔顿就开始思考父代和子代相似，如身高、性格及其它种种特制的相似性问 题。于是他选择了父母平均身高X与其一子身高Y的关系作为研究对象。他观察了1074对父母及每对父母的一个儿子，将结果描成散点图，发现趋势近乎一条直 线。总的来说是父母平均身高X增加时，其子的身高Y也倾向于增加，这是意料中的结果。但有意思的是高尔顿发现这1074对父母平均身高的平均值为68 英寸（英国计量单位，1 英寸=2.54cm）时，1074个儿子的平均身高为69 英寸，比父母平均身高大1 英寸 ，于是他推想，当父母平均身高为64 英寸时，1074个儿子的平均身高应为64+1=65 英寸；若父母的身高为72 英寸时，他们儿子的平均身高应为72=1=73 英寸，但观察结果确与此不符。高尔顿发现前一种情况是儿子的平均身高为67 英寸，高于父母平均值达3 英寸，后者儿子的平均身高为71英寸，比父母的平均身高低1 英寸。 高尔顿对此研究后得出的解释是自然界有一种约束力，使人类身高在一定时期是相对稳定的。如果父 母身高（或矮了），其子女比他们更高（矮），则人类身材将向高、矮两个极端分化。自然界不这样做，它让身高有一种回归到中心的作用。例如，父母平均身高 72 英寸，这超过了平均值68英寸，表明这些父母属于高的一类，其儿子也倾向属于高的一类（其平均身高71 英寸 大于子代69 英寸），但不像父母离子代那么远（71-69&lt;72-68）。反之，父母平均身高64 英寸，属于矮的一类，其儿子也倾向属于矮的一类（其平均67 英寸，小于子代的平均数69 英寸），但不像父母离中心那么远（69 -67&lt; 68-64）。 因此，身高有回归于中心的趋势，由于这个性质，高尔顿就把“回归”这个词引进到问题的讨论中，这就是“回归”名称的由来，逐渐背后人沿用成习了。
2、“回归分析”到底是什么意思 回归分析研究的是多个变量之间的关系。它是一种预测性的建模技术，它研究的是因变量（目标）和自变量（预测器）之间的关系。这种技术通常用于预测分析，时间序列模型以及发现变量之间的因果关系。 回归分析的好处比较多，主要有以下几点： （1）它表明自变量和因变量之间的显著关系 （2）它表明多个自变量对一个因变量的影响强度。 （3）允许我们去比较那些衡量不同尺度的变量之间的相互影响，如价格变动与促销活动数量之间联系
3、回归与拟合的区别 拟合的概念更广泛，拟合包含回归，还包含插值和逼近。拟合是一种数据处理的方式,不特指哪种方法.简单的说就是你有一组数据,觉得这组数据和一个已知的函数（这个函数的参数未定）很相似,为了得到最能表示这组数据特征的这个函数,通过拟合这种方式（具体的数学方法很多）求得参数.而回归是一种特定的数学方法,它可以实现数据拟合,得到函数的参数.也有些拟合得到的参数并非是函数的参数,如神经网络,得到的是这个神经网络的参数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f426e1581ede47ba893d83c1a1ce245e/" rel="bookmark">
			GTest源码剖析（七）——断言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GTest源码剖析——断言 GTest源码剖析断言 ASSERT_TRUE宏 1 ASSERT_TRUE宏 和 EXPECT_TRUE宏 的区别11 GTEST_MESSAGE_宏 12 AssertHelper类 2 ASSERT_TRUE宏的实现 21 AssertionResult类 1 ASSERT_TRUE宏 ASSERT_TRUE宏和ASSERT_FALSE宏几乎认为无区别，仅仅是参数取反而已。
ASSERT_*宏定义如下：
#define ASSERT_TRUE(condition) GTEST_TEST_BOOLEAN_((condition), #condition, false, true, GTEST_FATAL_FAILURE_) #define ASSERT_FALSE(condition) GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, GTEST_FATAL_FAILURE_) 1.1 ASSERT_TRUE宏 和 EXPECT_TRUE宏 的区别 EXPECT_TRUE宏和ASSERT_FALSE宏 几乎认为无区别，仅仅是参数取反而已；
EXPECT_TRUE宏和ASSERT_FALSE宏 均使用GTEST_TEST_BOOLEAN_宏； 两者的区别仅仅是第五个参数不同 EXPECT_TRUE的参数是GTEST_NONFATAL_FAILURE_，而ASSERT_TRUE的参数是GTEST_FATAL_FAILURE_
EXPECT_*宏定义如下：
#define EXPECT_TRUE(condition) GTEST_TEST_BOOLEAN_((condition), #condition, false, true,GTEST_NONFATAL_FAILURE_) #define EXPECT_FALSE(condition) GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, GTEST_NONFATAL_FAILURE_) 3.对比一下 GTEST_FATAL_FAILURE_宏 和 GTEST_NONFATAL_FAILURE_宏 的区别可以发现，两者均使用GTEST_MESSAGE_宏， 区别在于使用了不同的TestPartResult的枚举值。
宏定义如下：
#define GTEST_FATAL_FAILURE_(message) return GTEST_MESSAGE_(message, ::testing::TestPartResult::kFatalFailure) #define GTEST_NONFATAL_FAILURE_(message) GTEST_MESSAGE_(message, ::testing::TestPartResult::kNonFatalFailure) TestPartResult类定义如下，仅仅是定义了三个枚举值而已。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f426e1581ede47ba893d83c1a1ce245e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab7e0f5be189b8e3987390bf98346ba5/" rel="bookmark">
			GTest源码剖析（三）——TEST_F宏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GTest源码剖析——TEST_F宏 GTest源码剖析TEST_F宏 TEST_F宏与TEST宏的区别 1 TEST_F宏定义2 TEST宏定义3 对比分析 31 拼接类对比32 调用MakeAndRegisterTestInfo传参对比 TEST_F宏作用 1 TestCase级扩展2 Test级扩展 参考 1 TEST_F宏与TEST宏的区别 TEST_F宏和TEST宏的实现非常接近，只是TEST_F宏的封装更加开放一些，所以对TEST宏的功能多了一些扩展。 详细见GTest源码剖析——TEST宏
1.1 TEST_F宏定义 #define TEST_F(test_fixture, test_name) GTEST_TEST_(test_fixture, test_name, test_fixture, ::testing::internal::GetTypeId&lt;test_fixture&gt;()) 1.2 TEST宏定义 //step1 #if !GTEST_DONT_DEFINE_TEST # define TEST(test_case_name, test_name) GTEST_TEST(test_case_name, test_name) #endif //step2 #define GTEST_TEST(test_case_name, test_name) GTEST_TEST_(test_case_name, test_name,::testing::Test, ::testing::internal::GetTestTypeId()) 1.3 对比分析 eg:
TEST(Call,makeCall); TEST_F(Call,makeCall); 1.3.1 拼接类对比 区别在于： TEST宏中的拼接类Call_makeCall_Test继承于Test类； TEST_F宏中的拼接类Call_makeCall_Test继承于Call类；
即相对于TEST宏，TEST_F可以覆盖Test类中的虚函数SetUp()和TearDown()。
TEST宏:
class Call_makeCall_Test : public ::testing::Test { public: Call_makeCall_Test(); private: virtual void TestBody(); static ::testing::TestInfo* const test_info_ ; Call_makeCall_Test(Call_makeCall_Test const &amp;); void operator=(Call_makeCall_Test const &amp;); }; TEST_F宏：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab7e0f5be189b8e3987390bf98346ba5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee05f4ba7e9a139c85415a145c12ef42/" rel="bookmark">
			理解：回归与拟合、归一化与标准化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回归和拟合：
一、回归：
研究一个随机变量Y对另一个(X)或一组(X1,X2,…,Xk)变量的相依关系的统计分析方法。
应用回归预测法时应首先确定变量之间是否存在相关关系。如果变量之间不存在相关关系,对这些变量应用回归预测法就会得出错误的结果。
二、拟合
所谓拟合是指已知某函数的若干离散函数值{f1,f2,…,fn},通过调整该函数中若干待定系数f(λ1,λ2,…,λn),使得该函数与已知点集的差别(最小二乘意义)最小.
三、帮助理解的一些观点：
1、拟合是一种数据处理的方式。简单的说就是你有一组数据，觉得这组数据和一个已知的函数（这个函数的参数未定）很相似，为了得到最能表示这组数据特征的这个函数，通过拟合这种方式（具体的数学方法很多）求得参数。
而回归是一种特定的数学方法，它可以实现数据拟合，得到函数的参数。
2、
Curve fitting is the process of constructing a curve, or mathematicalfunction, that has the best fit to a series of data points, possibly subject toconstraints. Curve fitting can involve either interpolation, where an exact fitto the data is required, or smoothing, in which a "smooth" functionis constructed that approximately fits the data. A related topic is regressionanalysis, which focuses more on questions of statistical inference such as howmuch uncertainty is present in a curve that is fit to data observed with randomerrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee05f4ba7e9a139c85415a145c12ef42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc1879ed9c571862cf9c9f306276c9ea/" rel="bookmark">
			发现并解决linux高I/O Wait问题 – 如何发现linux中引起高io等待的进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux用很多可用的工具可以用来发现排错，有些很容易使用，有些用法则比较高级
查看I/O wait问题不仅需要使用一些高级工具，也需要一些基本工具的高级用法。I/O wait之所以难以排查是因为默认有太多的工具告诉你系统I/O阻塞，但没那么多工具可以帮你缩小范围以便确定出是哪个或哪些进程引起的问题。
首先回答是不是I/O引起系统缓慢
确定是不是I/O引起系统缓慢，你可以使用很多工具但最简单的还是unix命令top
[root@coolnull ~]# top top - 14:31:20 up 35 min, 4 users, load average: 2.25, 1.74, 1.68 Tasks: 71 total, 1 running, 70 sleeping, 0 stopped, 0 zombie Cpu(s): 2.3%us, 1.7%sy, 0.0%ni, 0.0%id, 96.0%wa, 0.0%hi, 0.0%si, 0.0%st Mem: 245440k total, 241004k used, 4436k free, 496k buffers Swap: 409596k total, 5436k used, 404160k free, 182812k cached 从CPU(s) 这行你可以看出当前CPU I/O Wait的情况；越高的wa表示越多的cpu资源在等待I/O
wa -- iowait Amount of time the CPU has been waiting for I/O to complete.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc1879ed9c571862cf9c9f306276c9ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3c4a094e3464bb2e1553267753c68a4/" rel="bookmark">
			Android原生webView加载h5页面出现加载错乱不完全问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、错误的效果图：
二、正确的效果图：
三、解决方案：
webView.getSettings().setDomStorageEnabled(true);//打开DOM存储API 四、参考文章： 地址：点击打开链接 http://blog.csdn.net/u010753376/article/details/51394304 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/117/">«</a>
	<span class="pagination__item pagination__item--current">118/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/119/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>