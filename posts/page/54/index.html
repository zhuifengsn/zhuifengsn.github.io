<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fcdb9fa628b449c7beb673897bccfa8/" rel="bookmark">
			软考-软件设计师 UML建模
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 UML概念关系类图对象图用例图构件图部署图序列图通信图状态图活动图 UML概念 UML是统一建模语言，和程序设计语言并无关系。
UML三个要素：UML的基本构造块，支配这些构造块如何放置在一起的规则和运用与整个语言的一些公共机制。
UML的基本构造块包括：事务（对模型中最具代表性成分的抽象），关系（把事务结合到一起），图（聚集了相关的事物）。
UML中有四种事务：结构事物，行为事物，分组事物，注释事物。
结构事物：模型的静态部分，如类，接口，用例，构件等，如图所示：
行为事物：模型的动态部分，如交互，活动，状态机；如图所示：
分组事物：模型的组织部分，如包；如图10-4
注释事物：模型的解释部分，依附于一个元素或一组元素之上对其进行约束或解释的简单符号；如图10-5所示：
关系 依赖：一个事物的语义依赖另一个事物的语义的变化而变化。
关联：是一种结构关系，描述了一组链，链是对象之间的链接。分为组合和聚合，都是部分和整体的关系，其中组合事物之间关系更强。两个类之间的关联，实际上是两个类所扮演角色的关联，因此两个类之间可以有多个由不同角色标识的关联。
泛化：一般/特殊的关系，子类和父类之间的关系。
实现：一个类元指定了另一个类元保证了执行的契约。
类图 静态图，为系统的静态设计图，展现一组对象，接口，协作和它们之间的关系。UML类图如下：
考察：多重度，属性，操作，关系。
对象图 静态图，展现某一 时刻一组对象及它们之间的关系，为类图的某一快照。在没有类图的前提下，对象图就是静态设计视图，如下：
用例图 静态图，展现了一组用例，参与者以及它们之间的关系。
用例图中的参与者是人、硬件或其他系统可以扮演的角色；用例是参与者完成的一系列操作；
用例之间的关系：包含，扩展，泛化；
构件图 构件图（组件图）：静态图，为系统静态实现视图，展现了一组构件之间的组织和依赖。如下
部署图 静态图，为系统静态部署视图，部署图物理模块的节点分布。它与构件图相关，通常一个节点包含一个或多个构件。其依赖关系类似于包依赖，因此部署组件之间的依赖是单向的类似于包含关系。如下：
序列图 序列图：即顺序图，动态图，是场景的图形化表示，描述了以时间顺序组织的对象之间的交互活动。
有同步消息（进行阻塞调用，调用者中止执行，等待控制权返回，需要等待返回消息，用实心三角箭头表示），异步消息（发出消息后继续执行，不引起调用者阻塞，也不等待返回消息，由空心三角箭头表示），返回消息（由从右往左的虚线箭头表示）三种。如下：
通信图 通信图：动态图，即协作图，是顺序图的另一种表示方法，也是由对象和消息组成的图，只不过不强调时间顺序，只强调事件之间的通信，而且没有固定的画法规则，和顺序图统称为交互图。如下：
状态图 状态图：动态图，展现了一个状态机，描述单个对象在多个用例中的行为，包括简单状态和组合状态。
装换可以通过事件触发器触发，事件触发后相应的监护条件会进行检查。状态图中状态和转换是两个独立的概念，如下：图中方框代表状态，箭头上代表触发的事件，实心圆点为起点和终点。
活动图 活动图：动态图，是一种特殊的状态图，展现了在系统内从一个活动到另一个活动的流程。
活动的分岔和汇合线是一条水平粗线。
并发分岔，并发汇合，监护表达式，分支，流等名词及含义。
每个分岔的分支数代表了可同时运行的线程数。活动图中能够并行执行的是一个分岔粗线下的分支上的活动。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5e5e17418e95c0f8061e71ae9729fc1/" rel="bookmark">
			vue 利用 screenfull 实现全屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用 screenfull 实现全屏 有时候我们实现的全屏点击的时候icon图标可以正常切换, 但是如果按 esc 键退出的话就不能监听到退出全屏导致icon展示不正确
其实我们可以利用 screenFull 的监听事件, 来实现屏幕的全屏和退出全屏的监听,当然使用原生的api也是可以实现的, 不过代码会显得有点臃肿
活不多说开整
第一步先安装插件
可以安装5.1的版本 npm install --save screenfull@5.1.0 然后再项目中导入使用 import screenFull from 'screenfull'; 然后我们需要在created 中初始化注册这个事件 data() { return { screenState: false // 屏幕的状态 } }, created() { this.init(); // 初始化注册screenFull的change事件 }, methoed: { init() { if (screenFull.isEnabled) { // 判断是否支持全屏 screenFull.on('change', this.change); // 开启监听change事件 } }, // 更改当前屏幕的状态 change() { this.screenState = screenFull.isFullscreen; // 更新全屏状态 }, }, // 最后注销监听事件 beforeDestroy() { if (screenFull.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5e5e17418e95c0f8061e71ae9729fc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0e8d976f98c12e762a306f81ed8e3d0/" rel="bookmark">
			LeetCode 189. 轮转数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌟 前言
Wassup guys！我是Edison 😎
今天是 LeetCode 上的 leetcode 189. 轮转数组
Let’s get it！
文章目录 1. 题目分析2. 题目图解🍑 思路一：右旋 k 次，依次移动一个🍑 思路二：额外开数组🍑 思路三：三趟逆置 3. 算法设计4. 代码实现 1. 题目分析 给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。
示例 1：
示例 2：
2. 题目图解 🍑 思路一：右旋 k 次，依次移动一个 假设我们要把数组 [1，2，3，4，5，6，7]，向右旋转 3 次
第 1 步，定义一个变量 tmp 用于存放数组的最后一个元素 7；
第 2 步，把数组前 n-1 个值往后挪；
第 3 步，把 tmp 的值放入空出来的第一个位置中；
这就完成了一次右旋，那么我们在向右旋转 k 次，就得到了最后的结果。
此方法时间复杂度为 O ( N ∗ K ) O(N*K) O(N∗K)；空间复杂度为 O ( 1 ) O(1) O(1)；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0e8d976f98c12e762a306f81ed8e3d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fdf64b2a53cf22dd7201b2d8d6fc963/" rel="bookmark">
			告别csdn，迁移到自己的博客网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一年过去了，懵懵懂懂也学了一些web网安的知识，写了大概60多篇的文章吧，不过自己太懒了，就没放到csdn上。后面干脆自己搭了一个博客网站，用springboot+vue写的，当然这里面参考了很多大佬的代码。无论如何，自己也还只是踏入安全圈的小白一枚，希望自己再接再厉，继续摸鱼。
我的博客网站：https://zeroer.xyz
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1d5c238769cf7988b1d4fcb5ab4115f/" rel="bookmark">
			C语言字符串详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、字符串的概念
二、占用内存的情况
三、字符串的初始化
四、字符串与指针
五、字符串的结尾标志
六、字符串常用的库函数
1、获取字符串的长度（strlen）
举个例子
运行效果
自己实现一个 strlen 函数
运行效果
2、字符串复制或赋值（strcpy）
自己实现一个 strcpy 函数
运行效果
3、字符串复制或赋值（strncpy）
自己实现一个 strncpy 函数
运行效果
4、字符串拼接（strcat）
自己实现一个 strncpy 函数 运行效果
5、字符串拼接（strncat）
自己实现一个 strncat 函数 运行效果
6、字符串比较（strcmp、strncmp）
自己实现一个strcmp 函数
运行效果 自己实现一个strncmp函数
运行效果
7、字符查找（strchr、strrchr）
自己实现一个strchr函数
运行效果 自己实现一个strrchr函数
8、字符串查找（strstr）
自己实现一个 strstr 函数
运行效果
一、字符串的概念 我们可以把字符串储存在char类型的数组中，如果char类型的数组末尾包含一个表示字符串末尾的空字符\0，则该数组中的内容就构成了一个字符串
因为字符串需要用\0结尾，所以在定义字符串的时候，字符数组的长度要预留多一个字节用来存放\0，\0就是数字0
例如
char name[21]; // 定义一个最多存放20个英文字符或十个中文的字符串 字符串也可以存放中文和全角的标点符号，一个中文字符占两个字节（GBK编码）。char strname[21]用于存放中文的时候，最多只能存10个汉字。字符串采用双引号包含起来，如："hello，world"、"你好C语言" 二、占用内存的情况 一个字符占用一字节的内存，字符串定义时数组的大小就是字符串占用内存的大小
char str[21]; // 占用21字节的内存 char str[1024]; // 占用1024字节的内存 三、字符串的初始化 char name[21]; memset(name,0,sizeof(name));//采用memset函数初始化字符串 四、字符串与指针 数组名是数组元素的首地址，字符串是字符数组，所以在获取字符串的地址的时候，不需要用&amp;取地址
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1d5c238769cf7988b1d4fcb5ab4115f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56eea08a86e31fda3fd17bf9b744cfc1/" rel="bookmark">
			QQ群计数器统计器使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		⌛ 下载安装
下载地址：https://ruyi666.lanzouy.com/b03pcayvg
⌛ 注册登陆
注册账号，输入卡密，登陆QQ群计数器
⌛ 使用功能
💤 登陆账号
快捷登陆，网页登陆，两种登陆模式
💤 登陆Q群
点击在线QQ账号，右键导入群组
💤 申请统计
账号在线状态即可正常统计，可通过手动一键通过所有同意申请列表，也可以✅开启自动同意所有来自动通过所有
💤 分享链接
一键分享生成分享链接，复制网址可查看，或点击✅自动分享直接弹出分享网页
💤 分组管理
默认状态都属于默认分组
如果需要给所有在线群组进行分组，先新增一个分组，再选中需要拉入这个分组的账号，最后点拉入就可以了
如果不需要某个分组了可以点击某个分组的选项点击删除，点击删除以后重新回归默认分组
💤 合并账号
多个软件同时使用可输入设置一个主号，然后✅点击开启合并，这样多个账号的数据可通过主号分享直接查看
💤 数据导出
可通过分享链接导出整个数据，也可以通过申请列表通过搜索查看整个或者个别Q群的申请以及通过数据
💤 过滤重复
开启✅自动过滤重复之后，重复添加我们所有群的账号只会被统计一次
💤 删除账号及清零
可点击删除所有账号键及清零所有键来进行全部删除和清零，也可以通过选中✅账号再点击删除账号或者统计归零来进行单个删除和清零
🔈 🔈注意事项，解决办法
🕥 统计不到数据
查看账号列表的账号是否在线状态
查看日志是否正常在运转
如果是网络问题可找到软件的帮助中心，点击网络修复检测并进行修复
🕥 不小心删除了账号或者数据清零了
找到帮助中心的数据还原，再找到删除的选项✅，点击右键选中还原备份
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92076cf5f719a464f76ef717e38905c1/" rel="bookmark">
			WX计数器统计器使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		⌛ 下载安装
下载地址：https://ruyi666.lanzouy.com/b03pcayvg
⌛ 注册登陆
注册账号，输入卡密，登陆微信计数器
⌛ 使用功能
💤 登陆账号
直接点登陆微信扫码进行登陆我们需要计数的微信
💤 申请统计
账号在线状态即可正常统计，可通过手动一键通过所有同意申请列表，也可以✅开启自动同意所有来自动通过所有
💤 自动备注
可通过✅自动备注选项来设置自动备注通过的账号(添加日期性别以及自动备注自定义)
💤 分享链接
一键分享生成分享链接，复制网址可查看，或点击✅自动分享直接弹出分享网页
💤 分组管理
默认状态都属于默认分组
如果需要给所有在线账号进行分组，先新增一个分组，再选中需要拉入这个分组的账号，最后点拉入就可以了
如果不需要某个分组了可以点击某个分组的选项点击删除，点击删除以后重新回归默认分组
💤 合并账号
多个软件同时使用可输入设置一个主号，然后✅点击开启合并，这样多个账号的数据可通过主号分享直接查看
💤 数据导出
可通过分享链接导出整个数据，也可以通过申请列表通过搜索查看整个或者个别账号的申请以及通过数据
💤 过滤重复
开启✅自动过滤重复之后，重复添加我们所有WX的账号只会被统计一次
💤 删除账号及清零
可点击删除所有账号及清零所有，也可以通过右键选中✅账号单个进行删除或者清零
🔈 🔈注意事项，解决办法
🕥 统计不到数据
查看账号列表的账号是否在线状态
查看日志是否正常在运转
如果是网络问题可找到软件的帮助中心，点击网络修复检测并进行修复
🕥 不小心删除了账号或者数据清零了
找到帮助中心的数据还原，再找到删除的选项✅，点击右键选中还原备份
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/365926455111b87af93a1443b4098dc1/" rel="bookmark">
			SQL学习七、聚合函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不放在第六篇中，是因为这个函数使用频率太高，所以单独作为一节。
聚合函数的使用场景
确定表中行数（或者满足某个条件或包含某个特定值的行数）；获得表中某些行的和；找出表列（或所有行或某些特定的行）的最大值、最小值、平均值 也就是需要汇总表中的数据，而不是直接获取表中的数据。
1、常用的聚合函数 函 数说 明AVG()返回某列的平均值COUNT()返回某列的行数MAX()返回某列的最大值MIN()返回某列的最小值SUM()返回某列值之和GROUP_CONCAT()返回一个字符串 聚集函数用来汇总数据。SQL支持 5个聚集函数，可以用多种方法使用 它们，返回所需的结果。这些函数很高效，它们返回结果一般比你在自己的客户端应用程序中计算要快得多。
我们用下面这张表来演示上述函数
建表语句 CREATE TABLE "oderlist" ( "id" INTEGER NOT NULL, "goodsName" TEXT, "quantity" integer, "item_price" real, "orderNo" text, "userId" INTEGER, "userName" TEXT, "orderTime" TEXT, PRIMARY KEY ("id") ) AVG()函数 - 求均值 比如，我们需要返回表中所有产品的平均价格，我们可以使用这样的SQL SELECT AVG(item_price) avgPrice FROM "oderlist" //...or SELECT AVG(item_price) AS avgPrice FROM "oderlist" 比如，我们需要返回表中单价低于10块的所有产品的平均价格，我们可以使用这样的SQL SELECT AVG(item_price) AS avgPrice FROM "oderlist" WHERE item_price &lt;10 COUNT()函数 - 求行数 可利用 COUNT()来确定表中行的数目或符合特定条件的行的数目。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/365926455111b87af93a1443b4098dc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32f9ab755f8ae2cb468e34b1d7fcd9ab/" rel="bookmark">
			c&#43;&#43;之继承
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、继承的概念
2、使用场景
3、继承定义
3.1、如何继承：
3.2、继承方式
3.3、继承父类成员访问方式的变化
4、基类和派生类对象的赋值转换
5、继承中的作用域
6、派生类的构造函数原则：
7、多继承与菱形继承
1、继承的概念 继承：继承就是在原有的类的基础之上进行扩展、增加一些功能。
可以这样理解：在古代的时候，皇帝驾崩了之后，就会有一个集运气于一身的幸运之子登上皇位。这位幸运之子继承了老皇帝留下来的江山，可以在这个江山已有的基础之上实施一些新政策、新措施、最终走上富国强兵……
看到这里应该不难理解继承是什么了吧，每一位新生的皇帝都是继承了上一任老皇帝的江山，颁布新政策。而类的继承，就是继承了已有的类，并可以在其基础之上进行扩展。
2、使用场景 在实际的应用中，要实现一个图书管理系统，有学生、老师、各色各样的人……，难道要一一实现每个角色的类吗？那不得烦死了。这时就可以使用继承的方式。学生、老师……都具有姓名，身份证，年龄，住址等共同信息，那就可以定义一个具有共同特征的person类。然后去定义一个学生、老师等等的类就可以来继承这个person类，并且可以在其基础之上进行扩展，增加独有的信息。
//具有共同特征的人类 class Person { protected: string name; int age; string id; string address; }; //学生类继承了Person类 class student:public Person { protected: //可以在原有的基础之上增加独有的信息：宿舍号 int dormitory_id; }; int main() { Person p; student st; return 0; } 3、继承定义 3.1、如何继承： Person是要被继承的类，叫父类，也叫基类。student继承了Person类，是子类，也叫派生类。 3.2、继承方式 3.3、继承父类成员访问方式的变化 总结：
1、父类的private成员，不管以什么方式被继承都是private、且不可见的：父类的私有成员被继承到了子类，子类不能访问到父类的private成员，因为语法的限制所以不能去访问，但确实有被继承下来。
2、父类的成员在基类的访问方式变化其实很好记。两个访问方式进行比较取小的那个（public &gt; protected &gt; private ），比如父类的public成员以public继承到子类，相等就以public访问方式。如果是以protected继承，public &gt; protected，protected比public小所以继承到子类的访问权限就会变成protected。如果是以private继承，public &gt; private，private比public小所以继承到子类的访问权限就会变成private。
3、父类的protected、private成员：两个的权限都是一样的，在类外不能访问，但在类里面可以访问。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32f9ab755f8ae2cb468e34b1d7fcd9ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b44e9ee9c19d9671b4bbe358d46902e7/" rel="bookmark">
			简述&amp;&amp;和&amp;的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.&amp;&amp;是逻辑操作符，而&amp;是位操作符
2.&amp;和&amp;&amp;都可以用作逻辑与的操作符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则只要一方为false,则结果为false。
3.&amp;&amp;还具有短路的功能，即如果第一个表达式false，则不再计算第二个表达式
4.&amp;还可以用作位运算符，例如 0&amp;1=0， 1&amp;1=1。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e0acef1f1550a05d37d8e68526f76da/" rel="bookmark">
			c&#43;&#43;类和对象(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类有6个默认成员函数 如果一个类什么成员都没有，称为空类。空类中什么都没有吗，并不是的，任何一个类在我们不写的情况下会自动生成以下6个默认成员函数。
class Date
{
}；
1、构造函数 概念：构造函数是用来初始化的。
class Date { public: void InitDate(int year, int month, int day) { _year = year; _month = month; _day = day; } void PrintDate() { cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl; } private: int _year; int _month; int _day; }; int main() { Date d1; d1.InitDate(2022, 6, 15); d1.PrintDate(); return 0; } 在日常的操作中，大家都会或多或少的忘记去初始化了，然后去访问它就会出现随机值或者会出现崩溃。我们想一下，在c语言的时候实现一个Stack的数据结构，如果忘记去初始化的话，在一个随机的指针中去插入一个数据，这就是野指针了。
忘记初始化是正常的事，那有没有什么办法是可以来让它自动来初始化的呢？答案是有的。构造函数就是来解决这种问题的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e0acef1f1550a05d37d8e68526f76da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1335e5997cdaa8636cb3fd5106da408a/" rel="bookmark">
			Linux：chmod -R 777 *含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux：chmod -R 777 * 首先，chmod命令是linux上用于改变权限的命令，-R 是递归遍历子目录，因为你要操作的文件使用的*通配符。
777，第一个7代表文件所属者的权限，第二个7代表文件所属者所在组的权限，第三个7代表其它用 户的权限，7=4+2+1，在linux中权限是可以通过数字来描述的。具体表示如下：
4，执行时设置用户ID，用于授权给基于文件属主的进程，而不是给创建此进程的用户。
2，执行时设置用户组ID，用于授权给基于文件所在组的进程，而不是基于创建此进程的用户。
1，设置粘着位。
其次，chmod命令的详细使用如下，有不懂的可以慢慢查看一下。
chmod----改变一个或多个文件的存取模式(mode)
chmod [options] mode files 只能文件属主或特权用户才能使用该功能来改变文件存取模式。mode可以是数字形式或以who opcode permission形式表示。who是可选的，默认是a(所有用户)。只能选择一个opcode(操作码)。可指定多个mode，以逗号分开。
options： -c，–changes
只输出被改变文件的信息
-f，–silent，–quiet
当chmod不能改变文件模式时，不通知文件的用户
–help
输出帮助信息。
-R，–recursive
可递归遍历子目录，把修改应到目录下所有文件和子目录
–reference=filename
参照filename的权限来设置权限
-v，–verbose
无论修改是否成功，输出每个文件的信息
–version
输出版本信息。
who u
用户
g
组
o
其它
a
所有用户(默认)
opcode +
增加权限
-
删除权限
=
重新分配权限
permission r
读
w
写
x
执行
s
设置用户(或组)的ID号
t
设置粘着位(sticky bit)，防止文件或目录被非属主删除
u
用户的当前权限
g
组的当前权限
o
其他用户的当前权限
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1335e5997cdaa8636cb3fd5106da408a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bff9fae418cc14ffafeac9ebf5fdc42e/" rel="bookmark">
			Shiro安全框架【SpringBoot版】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Shiro安全框架一、 入门概述1.1、Shiro是什么1.2、为什么使用Shiro1.3、Shiro与Spring Security的区别1.4、基本功能1.4.1、主要功能1.4.2 、次要功能 1.5、架构原理 二、基本使用2.1、环境准备2.2、配置ini文件2.3、登录认证2.3.1、登录认证概念2.3.2、登录认证的流程2.3.3、登录认证示例 2.4、角色、授权2.4.1、授权2.4.1.1、授权方式2.4.1.2、授权流程 2.4.2、角色2.4.3、角色授权示例 2.5、密码加密2.5.1、使用Shiro进行加密 三、Shiro整合SpringBoot3.1、整合依赖3.2、yml配置文件3.3、创建目录结构3.4、创建数据库3.5、创建对应的类3.6、创建Shiro配置类3.6.1、自定义Shiro配置类3.6.2、自定义Shiro拦截范围 3.7、测试3.8、登录认证前端 四、多个Realm登录校验五、rememberMe功能5.1、基本流程5.2、代码实现5.2.1、设置记住我5.2.2、配置记住我管理器以及Cookie属性5.2.3、添加用户过滤器5.2.4、改造Controller登录接口5.2.5、改造登陆页面 六、用户登出6.1、代码实现 七、授权、角色认证7.1、角色认证7.1.1、后端接口服务注解:fire::fire::fire:7.1.2、授权验证-没有角色无法访问7.1.3、授权验证-有角色7.1.4、创建角色表 7.2、授权访问 八、自定义异常九、前端角色权限认证9.1、引入依赖 十、实现缓存10.1、缓存工具Ehcache10.2、Shiro整合Ehcache Shiro安全框架 一、 入门概述 1.1、Shiro是什么 Apache Shiro 是一款功能强大的且易于使用的Java的安全框架。Shiro可以完成：认证、加密、会话管理、与web集集成等。借助SHiro可以帮助我们快速轻松的保护任何应用程序。
shiro官网：Apache Shiro | Simple. Java. Security.
1.2、为什么使用Shiro 与Shiro的特性密不可分：
易于使用全面灵活强力支持Web兼容性强社区支持 1.3、Shiro与Spring Security的区别 SpringSecurity基于Spring开发，项目若使用Spring 可以与SpringSecurity作权限更加方便，而Shiro需要与Spring进行整合
Spring Security功能更加丰富
Spring Security社区资源更加丰富
看到这里，是不是有些人就认为Spring Security功能更发面都比Shiro好，为什么不学习SpringSecurity。有一句话：存在即合理。下面看看Shiro的特点
Shiro的配置和使用比较简单，SpringSecurity使用比较复杂
Shiro的依赖性低，不需要任何的容器与框架，可以独立运行
Shiro不仅仅可以使用在Web端，可以使用在任何的场景。
1.4、基本功能 了解Shiro的功能，我们可以去官网下载一张Shiro的功能结构图来进行补充学习：
1.4.1、主要功能 认证登录（Authentication）授权验证（Authorization）会话管理（Session Management）密码加密（Cryptography） 1.4.2 、次要功能 Web支持（web support）缓存（caching）多线程并发验证（Concurrency）测试（Testing）另外身份登录（Run as）记住我（Remember me） 1.5、架构原理 从外部来看Shiro，即从应用程序的角度来观察使用Shiro完成工作
应用程序—&gt;（登录）----&gt;subject（对象）进行身份校验----&gt;安全管理器（SecurityManager）----&gt;Reaim（用户登陆的用户信息）
从内部的架构来看Shiro
二、基本使用 2.1、环境准备 1、Shiro不依赖容器，可以直接利用Maven使用
2、添加依赖
&lt;!-- Shiro依赖 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bff9fae418cc14ffafeac9ebf5fdc42e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd8a4994cda0fd15bebfa2db8459f196/" rel="bookmark">
			spring框架源码一、什么是aop
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是aop aop（Aspect Oriented Programming）面向切面编程
要想了解aop有必要先了解一下oop，
oop（Object Oriented Programming）面向对象编程
关于oop不需介绍太多，只用提一下，
oop的三大特征：封装、多态、继承。
oop更多是维护一种纵向的垂直继承体系。
比如：
A、X的子类都可以通过继承而获得eat和drink的能力，这一相同的行为。
aop是oop的补充
它们的本质都是为了减少重复代码
需要为多个不具有继承关系的对象引入一个相同的行为时，
这种通用行为我们称之为横切逻辑，
横切逻辑的使用场景有限，一般有事务控制、安全校验和请求、相应日志打印等。
在不改变原有业务逻辑的前提下，实现横切逻辑，这，就是面向切面编程。
比如：
为B、Y引入相同的行为run();
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ccdfb00925df9946448b3bcba30c1c1/" rel="bookmark">
			MT4 managerAPI 接口（头文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是MT4官方managerAPI的头文件，具体是什么功能看方法名字还是比较好理解的，
可以直接保存为.h文件导入到自己工程中使用
//+------------------------------------------------------------------+ //| MetaTrader 4 Manager API | //| Copyright 2001-2015, MetaQuotes Software Corp. | //| http://www.metaquotes.net | //+------------------------------------------------------------------+ //| DO NOT EDIT THIS FILE!!! | //+------------------------------------------------------------------+ // NoStyler #pragma once //+------------------------------------------------------------------+ //| API Version | //+------------------------------------------------------------------+ #define ManAPIProgramVersion 400 #define ManAPIProgramBuild 920 #define ManAPIVersion MAKELONG(ManAPIProgramBuild,ManAPIProgramVersion) //+------------------------------------------------------------------+ //| MSVS6 Compatibility | //+------------------------------------------------------------------+ #if _MSC_VER &lt;= 1200 #define __time32_t time_t #define __ptr32 #endif //+------------------------------------------------------------------+ //| Server Configurations | //+------------------------------------------------------------------+ //| Configuration types | //+------------------------------------------------------------------+ enum { CONFIG_ALL=0, // all configurations CONFIG_COMMON, // common configuration CONFIG_ACCESS, // IP access list configuration CONFIG_SERVERS, // data servers CONFIG_TIME, // working time configuration CONFIG_HOLIDAYS, // holidays configuration CONFIG_SYMBOLS, // symbols configuration CONFIG_SYMB_GROUPS, // securities configuration CONFIG_GROUPS, // groups configuration CONFIG_MANAGERS, // manager's rights configuration CONFIG_DATAFEEDS, // data feeds configuration CONFIG_BACKUP, // backups configuration CONFIG_LIVEUPDATE, // LiveUpdate configuration CONFIG_SYNC, // synchronization configuration CONFIG_PLUGINS, // plugins configuration CONFIG_GATEWAY_ACCOUNTS, // gateway accounts CONFIG_GATEWAY_MARKUPS, // gateway markups CONFIG_GATEWAY_RULES, // gateway rules CONFIG_END=255 // last (unused) }; //+------------------------------------------------------------------+ //| Configuration structures | //+------------------------------------------------------------------+ //| Common configuration | //+------------------------------------------------------------------+ struct ConCommon { char owner[128]; // servers owner (include version &amp; build) char name[32]; // server name ULONG address; // IP address assigned to the server int port; // port DWORD timeout; // sockets timeout int typeofdemo; // demo-accounts type (DEMO_DISABLED, DEMO_PROLONG, DEMO_FIXED) int timeofdemo; // demo-account living time int daylightcorrection; // allow daylight correction char internal[64]; // reserved int timezone; // time zone 0-GMT;-1=GMT-1;1=GMT+1; char timesync[64]; // time synchronization server address //--- int minclient; // minimal authorized client version int minapi; // minimal authorized client version DWORD feeder_timeout; // data feed switch timeout int keepemails; // internal mail keep period int endhour,endminute; // end of day time-hour &amp; minute //--- int optimization_time; // optimization start time (minutes) int optimization_lasttime; // optimization last time int optimization_counter; // internal variable int optimization_unused[8];// reserved for future use //--- int antiflood; // enable antiflood control int floodcontrol; // max.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ccdfb00925df9946448b3bcba30c1c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce3c53b4098ab93d84beddc9dfc8e0a9/" rel="bookmark">
			pytorch详细安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pytorch详细安装 打开annaconda自带的annaconda prompt进入虚拟环境安装pytorch把pytorch在annaconda prompt安装到annaconda 里面的jupyter notebook中进入notebook查看删除虚拟环境在jupyter 上的 kernels 打开annaconda自带的annaconda prompt 创建虚拟环境，这里以python=3.9.7为例。不知道自己安装的是什么版本的小伙伴可以去cmd
输入python查看，创建一个名为pytorch的虚拟环境
conda create -n pytorch python=3.9.7 进入虚拟环境安装pytorch 进入pytorch虚拟环境
conda activate pytorch link:进入pytorch官网查看你要安装的版本号复制代码在虚拟环境中安装即可,这里以cuda 10.2为例，每个人的要安装的版本不一样，需要自己去查找
pip3 install torch==1.10.1+cu102 torchvision==0.11.2+cu102 torchaudio===0.10.1+cu102 -f https://download.pytorch.org/whl/cu102/torch_stable.html 我们查看一下是否安装成功,在cmd里面依次输入
python import torch torch.cuda.is_available() 如果输出true则表示成功
false处理如下，删除安装的虚拟环境，重新运行一遍上面的操作
conda activate base conda remove -n pytorch --all 把pytorch在annaconda prompt安装到annaconda 里面的jupyter notebook中 以管理员的形式打开annaconda prompt
conda install nb_conda or
#首先安装ipykernel conda install ipykernel #在虚拟环境下创建kernel文件 conda install -n 环境名称 ipykernel 接着再进入前面创建好的虚拟环境里面输入
python -m ipykernel install --user --name pytorch 进入notebook查看 在新建文件那里我们看到有pytorch，并且打开后导入torch库，我们发现成功了！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce3c53b4098ab93d84beddc9dfc8e0a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64e5da03338776ea91ffafa11498f931/" rel="bookmark">
			CAS机制实现原理分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习方法：场景-&gt;需求-&gt;解决方案-&gt;应用-&gt;了解原理 一、CAS是什么？ CAS机制：CompareAndSwap 或 CompareAndExchange 或 CompareAndSet。
CAS是一个能够进行比较和替换的方法，这个方法能够在多线程环境下保证对一个共享变量进行修改时的原子性不变。
场景：i++ 保证原子性 为了更好的理解CAS机制，我们先看一个例子：
public class S01_AtomicDemo { volatile int i=0; //加上 synchronized 关键字保证结果一定是 2000 正确的 public /*synchronized */ void incr(){ i++; } public static void main(String[] args) throws InterruptedException { S01_AtomicDemo s01_atomicDemo = new S01_AtomicDemo(); Thread[] threads = new Thread[2]; for (int j=0; j &lt;2 ; j++) { threads[j]=new Thread(()-&gt;{ for (int k = 0; k &lt; 1000; k++) { s01_atomicDemo.incr(); } }); threads[j].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64e5da03338776ea91ffafa11498f931/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08546dd690c7dae3085e0860b9fe5b2d/" rel="bookmark">
			依赖示意图如何称之为模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：写一篇小论文，论述下图如何称之为模型
一、从概念入手，什么是模型？ 模型：通过主观意识借助实体或者虚拟表现，构成客观阐述形态结构的一种表达目的的物件（物件并不等于物体，不局限于实体与虚拟、不限于平面与立体）。【来自百度百科】
模型(model)：模型是指对于某个实际问题或客观事物、规律进行抽象后的一种形式化表达方式。【来自MBA智库百科】
个人理解：模型是我们对于某个实际问题或客观事物、规律，通过主观意识借助实体或虚拟表现进行抽象后，构成客观阐述形态结构的一种形式化表达方式。
二、需求剖析，代码优化过程: 从米老师让何老师开门这个实际需求出发，我们从第一版的面向过程代码（直接写在Client类中），经过一次次的沟通和老师的指导，我们先后优化了很多版，主要是从面向对象的角度，从注重具体的实现步骤，到注重谁来干事，优化出来两种建模方式：米老师依赖于何老师和何老师依赖于米老师：
建模方式一：米老师依赖于何老师
建模方式二：何老师依赖于米老师
这两种都是存在直接的依赖关系，代码逻辑上的体现是“谁在谁肚子里”。
我们经过研究设计模式书P362页的猫和老鼠示例，猫叫老鼠跑，但是猫和老鼠并没有直接的依赖关系，是通过委托与事件实现的猫和老鼠没有直接的依赖关系。从而引发我们的思考，如何让米老师和何老师在代码编写和编译时不产生直接的依赖关系，但是在运行时是可以具体产生依赖关系呢？——引出我们的抽象模型，如下图所示：
三、抽象模型的理解与思考： 这个抽象的图示模型可以看出Mi类的“肚子里还是有所依赖的”，但是具体依赖的是谁并不知道，而是在运行时具体知道依赖的是谁。这样让我们的Mi和He在编写代码时以及编译时都没有产生直接的依赖关系（或者说强依赖关系），而是通过反射实现在运行时产生依赖关系，这个依赖关系是弱依赖，是可替换、可拓展的，更符合面向对象的开闭原则，同时也符合迪米特法则和单一职责，米老师只需要发消息，并不需要知道谁来开门。
有了这样的模型架构，一层一层的架子，看着很虚，但是符合工程化：
快速（多人同时开发，保证不冲突）、规模大、低代码，低成本、代码解耦合、高复用、高拓展、高维护。
产品上线以后：
扩充：随着使用的人数逐渐增加，用户需求的变化，可拓展
维护：一个功能的多样化，可以通过配置进行维护
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/800a66b71864de6ecc356b08331485df/" rel="bookmark">
			数据结构（严蔚敏）【一元多项式的运算】【C语言】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、一元多项式的运算：实现两个多项式加、减乘运算 设计内容： 用顺序存储结构实现一元多项式的加法、减法和乘法。具体要求为：用五个函数分别实现一元多项式的创建、输出、加法、减法和乘法；
设计思路： 将顺序表数组下标作为多项式的指数项，数组内的数据元素存放多项式的系数，通过访问数组内元素的同时获取下标并对二者进行不同的运算后，将运算结果依旧按原形式放入新的数组中，完成对两个多项式的加减乘运算。
测试数据： 多项式1： 10 + 5 x − 4 x 2 + 3 x 3 + 2 x 4 10 + 5x -4x^2 + 3x^3 + 2x^4 10+5x−4x2+3x3+2x4（即输入10 0 5 1 -4 2 3 3 2 4）（输入-1 -1结束）
多项式2： − 3 + 8 x + 4 x 2 − 5 x 4 + 7 x 5 − 2 x 6 -3 + 8x + 4x^2 - 5x^4 + 7x^5 -2x^6 −3+8x+4x2−5x4+7x5−2x6（即输入 -3 0 8 1 4 2 -5 4 7 5 -2 6）（输入 -1 -1结束）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/800a66b71864de6ecc356b08331485df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46705e1fe950f5518da07ebd90dc7c12/" rel="bookmark">
			Visual Studio2022 离线安装包下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先去官网下载引导程序：
https://docs.microsoft.com/en-us/visualstudio/install/create-an-offline-installation-of-visual-studio?view=vs-2022
将下载后的文件拷贝至指定磁盘目录下，如本人的目录：F:\vs2022_Enterprise
其它文件请忽略，其余文件是执行命令自动下载的，cmd命令管理员身份运行进入F:\vs2022_Enterprise 如下图：
输入命令回车执行（全家桶）：vs_Enterprise.exe --layout F:\vs2022_Enterprise --lang en-US zh-CN 或
vs_Enterprise.exe --layout --add Microsoft.VisualStudio.Workload.ManagedDesktop --add Microsoft.VisualStudio.Workload.NetCrossPlat --add Microsoft.VisualStudio.Workload.NetWeb --add Microsoft.VisualStudio.Workload.Node --add Microsoft.VisualStudio.Workload.Office --add Microsoft.VisualStudio.Workload.Python --add Microsoft.VisualStudio.Workload.Universal --add Microsoft.VisualStudio.Workload.VisualStudioExtension --add Microsoft.VisualStudio.Workload.Azure --add Microsoft.VisualStudio.Workload.Data --add Microsoft.VisualStudio.Workload.DataScience --includeRecommended --lang zh-CN
弹出界面：
​​​​​​​ 安装成功后，开始下载：
语言：
cs-CZ Czech
de-DE German
en-US English
es-ES Spanish
fr-FR French
it-IT Italian
ja-JP Japanese
ko-KR Korean
pl-PL Polish
pt-BR Portuguese - Brazil
ru-RU Russian
tr-TR Turkish
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46705e1fe950f5518da07ebd90dc7c12/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/53/">«</a>
	<span class="pagination__item pagination__item--current">54/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/55/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>