<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aff142e20e5b1e1304cacfe382cc7cf/" rel="bookmark">
			Excel多表格多工作簿合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Excel多表格、多工作簿合并 直接通过“数据”栏目内置的“新建查询"可以实现，参考：
https://blog.csdn.net/qq_42692386/article/details/116231710
一. 单工作簿多工作表合并
点击【数据】&gt;【获取数据】&gt;【来自文件】&gt;【从工作簿】，选择原始数据，导入点击【主页】&gt;【追加查询】&gt;【追加查询】，选择“三个或更多表”，依次添加工作表，得到合并后的数据点击【关闭并上载】&gt;【关闭并上载】，可在excel中查看汇总后的数据 二. 多工作簿单工作表合并
原始数据含有多个工作簿，但每个工作簿中只有一个工作表**（注意：这里的单工作表是指每个工作簿中的工作表只有一个，且工作表的名称需要一致！！如果每个工作簿中只有一个工作表，但是表名不一致，需要按照本文稍后提供的第三种方法
点击【数据】&gt;【获取数据】&gt;【来自文件】&gt;【从文件夹】，选择原始数据，导入点击【组合】&gt;【合并和编辑】，选择工作表，点击【确定】，在powerquery中可查看到已合并的数据查看合并后的数据，点击【关闭并上载】 三. 多工作簿多工作表合并
点击【数据】&gt;【获取数据】&gt;【来自文件】&gt;【从文件夹】，选择原始数据，导入，点击【转换数据】。保留content及name列，点击【主页】&gt;【删除列】【删除其他列】。这些删除的列一般我们都是用不到的，所以我们直接删除提高效率。点击【添加列】&gt;【自定义列】，输入新列名及公式：
Excel.Workbook([Content],true)
第一个参数是要解析的字段，返回一个table，第二个是可选参数逻辑值，参数使用true，就是指定数据使用第一行做为标题。点击【关闭并上载】&gt;【关闭并上载】，可在excel中查看到已合并的数据。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/064753f4ccb91d47b85944d37ea64da4/" rel="bookmark">
			springboot/ssm文献搜索系统Java文献信息在线下载系统小说下载系统web
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot/ssm文献搜索系统Java文献信息在线下载系统小说下载系统web
基于springboot(可改ssm)+vue项目
开发语言：Java
框架：springboot/可改ssm + vue
JDK版本：JDK1.8（或11）
服务器：tomcat
数据库：mysql 5.7（或8.0）
数据库工具：Navicat/sqlyog
开发软件：eclipse//idea
依赖管理包：Maven
如需了解更多代码细节或修改代码功能界面，本人都能提供技术支持。（声音嘎嘎好听喔！）
祝你早日找到合适的代码哦～
注：主页千套源码&amp;文档，文章最下方获取源码哦
package com.controller; import java.text.SimpleDateFormat; import java.util.ArrayList; import java.util.Arrays; import java.util.Calendar; import java.util.Map; import java.util.HashMap; import java.util.Iterator; import java.util.Date; import java.util.List; import javax.servlet.http.HttpServletRequest; import com.utils.ValidatorUtils; import org.apache.commons.lang3.StringUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.format.annotation.DateTimeFormat; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import com.baomidou.mybatisplus.mapper.EntityWrapper; import com.baomidou.mybatisplus.mapper.Wrapper; import com.annotation.IgnoreAuth; import com.entity.NewsEntity; import com.entity.view.NewsView; import com.service.NewsService; import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/064753f4ccb91d47b85944d37ea64da4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39c58f19d1275891725adb8b39af904a/" rel="bookmark">
			Python世界之开端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、基础语法
1.交互式编程
2.脚本式编程
3.标识符
4.同一行显示多条语句
5.保留字符
6.行和缩进
7.错误提醒
8.多行语句
9.引号
10.注释
11.空行
12.print 输出
13.代码组
二、变量类型
1.标准数据类型
2.数字
3.字符串
1.字符串运算符
2.转义字符
3.字符串格式化符号
4.格式化操作符辅助指令
4.列表
1.列表的用途
2.列表脚本操作符
3.列表函数与方法
5.元组
1.创建元组
2.元组方法
6.字典
1.访问字典里的值
2.修改字典 3.删除字典元素
4.字典键的特性
5.字典用法 6.字典函数与方法
7.数据类型转换
一、基础语法 1.交互式编程 交互式编程不需要创建脚本文件，是通过 Python 解释器的交互模式进来编写代码。
①Linux 上只需要在命令行中输入 Python 命令即可启动交互式编程。
提示窗口如下：
$ python
Python 2.7.6 (default, Sep 9 2014, 15:04:36)
[GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.39)] on darwin
Type "help", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39c58f19d1275891725adb8b39af904a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35a2c10dbf8d94a8ff52afc116b2ca49/" rel="bookmark">
			QSS与CSS的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QSS简介 https://zhuanlan.zhihu.com/p/627210370
QSS称为Qt Style Sheets，也就是Qt样式表，
是Qt提供的一种用来自定义控件外观的机制。QSS大量参考了CSS的内容，不过QSS的功能比CSS要弱很多，体现在选择器要少，可以使用的QSS属性也要少很多，并且并不是所有的属性都可以用在Qt的所有控件上。
QSS与CSS的区别 https://blog.csdn.net/m0_62073294/article/details/123901272
QSS与CSS有什么区别？对于很多人来讲都不知道。
1. 对于复杂的控件，
可能会在其中包含其他子控件，如一个QComboxBox中有一个drop-down的按钮。那么现在如果要设置QComboxBox的下拉按钮的话，就可以这样访问：
QComboBox::drop-down { image: url(dropdown.png) } 其标志是（::）
2. 子控件选择器
是用位置的引用来代表一个元素，这个元素可以是一个单一控件或是另一个包含子控件的复合控件。使用subcontrol-origin属性可以改变子控件的默认放置位置，如：
QComboBox {
margin-right: 20px;
}
QComboBox::drop-down {
subcontrol-origin: margin;
}
如上语句可以用来改变drop-down的margin。
3. 相对位置属性
可以用来改变子控件相对于最初位置的偏移量，如当一个QCombox的drop-down按钮被按下时，我们可以用一个内部的小偏移量来表示被按下的效果，如下：
QComboBox::down-arrow {
image: url(down_arrow.png);
}
QComboBox::down-arrow:pressed {
position: relative;
top: 1px; left: 1px;
原文链接：https://blog.csdn.net/m0_62073294/article/details/123901272
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/537e8b79d9142289749cebba7470d2c1/" rel="bookmark">
			Python爬虫-报错requests.exceptions.SSLError: HTTPSConnectionPool
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习python爬虫，在公司运行代码没有问题，但是下班回来把代码拉下来运行，却出现问题。
问题：
requests.exceptions.SSLError: HTTPSConnectionPool(host=‘campusgateway.51job.com’, port=443): Max retries exceeded with url: /jobone-api/school/getSchoolByCity?pageIndex=1&amp;pageSize=21&amp;city=%E5%8C%97%E4%BA%AC (Caused by SSLError(SSLError(1, ‘[SSL: UNSAFE_LEGACY_RENEGOTIATION_DISABLED] unsafe legacy renegotiation disabled (_ssl.c:1000)’)))
上网查了各种方法，
添加verify=False -&gt; 报错依旧安装pip install requests == 2.19.1和pip install certifi==2018.8.13，变成另一个报错，ModuleNotFoundError: No module named ‘urllib3.packages.six.moves’。 百思不得其解，突然想到一句话，“代码一模一样但是运行不成功的话，要看环境有没配好”，然后我对比了公司和我电脑的Python解释器，我个人电脑的是Python 3.12版本，公司电脑我下载的是Python 3.6。果然不一样，然后我换成了3.6的，就可以成功运行了！！！
附上代码：
import requests # 地址 url = "https://campusgateway.51job.com/jobone-api/school/getSchoolByCity" # 查询参数 params = { "pageIndex": "1", "pageSize": "21", "city": "北京" } # 请求头 headers = { "User-Agent": "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/537e8b79d9142289749cebba7470d2c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2f52a41c6af3ba16ae1b104ec32c1a7/" rel="bookmark">
			应用回归分析：泊松回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		泊松回归是一种广泛用于计数数据的回归分析方法。它适用于响应变量是非负整数的情况，特别是当这些计数呈现出明显的离散分布时。泊松回归通过泊松分布的概率分布函数来建模计数数据，使其成为处理计数数据的自然选择。本文将介绍泊松回归的基本概念、应用场景、优缺点以及如何实施。
基本概念 泊松回归基于泊松分布的假设，泊松分布是一种描述在固定时间或空间内发生某事件次数的概率分布。泊松回归模型的形式通常表示为：
应用场景 泊松回归适用于多种场景，尤其是那些涉及计数数据的场合，例如：
交通事故次数：预测某条道路或地区在一定时间内的交通事故次数。疾病发病率：分析特定人群中疾病的发生次数。网站访问量：预测网站在特定时间段内的点击次数或访问量。零售销售：模拟商店在一定期间内的顾客数量或销售次数。 优缺点 优点：
专门化：泊松回归专门针对计数数据设计，能够有效处理非负整数响应变量。灵活性：通过引入偏移量或使用泊松分布的变体（如负二项分布），可以处理过度离散的数据。 缺点：
过度离散：当数据显示出明显的过度离散（方差大于均值）时，泊松回归的假设可能不成立。计数底限：泊松回归不适合处理有大量零计数的数据集，可能需要零膨胀模型来解决。 实施步骤 数据准备：确保响应变量为非负整数，且解释变量已适当选择和处理。模型选择：根据数据的特性选择合适的泊松回归模型。如果数据显示过度离散，可以考虑使用负二项回归。模型训练：使用统计软件包（如R的glm函数或Python的statsmodels库）来训练泊松回归模型。模型评估：通过检验统计量（如伪R^2）和残差分析来评估模型的拟合度和预测能力。模型应用：使用模型进行预测和解释。 示例代码 import pandas as pd import statsmodels.api as sm # 示例数据，假设DataFrame名称为df # df = pd.DataFrame({ # 'X1': [...], # 解释变量1 # 'X2': [...], # 解释变量2 # 'Counts': [...] # 计数数据，即响应变量 # }) data = { 'X1': [1, 2, 3, 4, 5], 'X2': [2, 2, 3, 4, 5], 'Counts': [0, 1, 2, 3, 4] } df = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2f52a41c6af3ba16ae1b104ec32c1a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ea647d9817b688450589af90c8c5dae/" rel="bookmark">
			Jenkins使用遇到的一些问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：插件依赖报错
比如遇到一堆插件报错，不是提示版本对不上，就是启用不了
这样直接把Jenkins升级就行了，比如我这个是命令行启动的，直接把他替换就好了
如果是遇到插件依赖报错，比如A插件异常
则点击这个插件，去他的历史版本
找一个合适的版本下载
然后在这里去导入安装
假设你安装失败了，则有可能是他还需要其他依赖的插件，才能安装成功，比如安装C插件，但是C依赖A和B，而A和B也是有问题的，这样就需要按照上面的方法，先按照顺序去安装A，再安装B，然后安装C，会比较麻烦，而且要注意的是，安装完A插件后，可能要重启一下jenkins才能安装B插件成功
2：hudson.ExtensionFinder$Sezpoz#scout:Failed to scout org.jenkinsci.plugins.gitserver.ssh.SshCommandFactoryImpl
不知道什么报错，就去插件管理，把有问题的差距重新安装一次，重启就好了
3：ERROR: Couldn't find any revision to build. Verify the repository and branch configuration for this job.
直接把master改为main就好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7872b3293d251f1fb10054428a726ec/" rel="bookmark">
			树-王道-复试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树 1.度： 树中孩子节点个数，所有结点的度最大值为 树的度
2.有序树： 逻辑上看，树中结点的各子树从左至右是有次序的，不能互换。
**3.**树的根节点没有前驱，其他节点只有一个前驱
**4.**所有节点可有零个或者多个后继
常考性质 1. 节点数 = 总度数（总边数）+1
2.度为 m 的树、m 叉树的区别：
** 3. 度为m的数第 i 层 至多有m(i-1)个结点，m叉树第i层至多有m(i-1)个节点 **
**4.高度为 h 的 m 叉树至多:**有（m^h-1）/m-1个节点
5.高度为 h 的 m 叉树至少: h个节点
6.高度为 h、度为 m 的树至少: h+m-1个节点
7.最小高度为： logmn
最小高度的计算：
2.完全二叉树 就是右叶子节点为缺，左边都是连起来的
特点：
1.只有最后两层可能有叶子结点。
2最多只有一个度为 1 的结点。(屁股节点，也就是度为1的节点只有1个)
3若按层序从 1 开始编号，结点 i 的左孩子为 2i，右孩子为 2i+1；结点 i 的父节点为 ⌊ i / 2 ⌋ \lfloor i/2\rfloor⌊i/2⌋。
4 i ≤ ⌊ n / 2 ⌋ 为分支结点，i &gt; ⌊ n / 2 ⌋ 为叶子结点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7872b3293d251f1fb10054428a726ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6cd6fa2c1dbd53f1610c2cc9fee2b69/" rel="bookmark">
			2.23数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单向循环链表
创建单向循环链表，创建节点 ，头插，按位置插入，输出，尾删，按位置删除功能
//main.c #include "loop_list.h" int main() { loop_p H=create_head(); insert_head(H,12); insert_head(H,6); insert_head(H,90); insert_head(H,123); out_put_loop(H); insert_pos(H,100,3); out_put_loop(H); del_tail(H); out_put_loop(H); del_pos(H,2); out_put_loop(H); return 0; } //loop_list.c #include "loop_list.h" //创建单向循环链表 loop_p create_head() { loop_p L =(loop_p)malloc(sizeof(loop_list)); if(L==NULL) { printf("空间申请失败\n"); return NULL; } L-&gt;len=0; L-&gt;next=L; return L; } //创建结点 loop_p create_node(datatype data) { loop_p new=(loop_p)malloc(sizeof(loop_list)); if(new==NULL) { printf("空间申请失败\n"); return NULL; } new-&gt;data=data; return new; } //判空 int loop_empty(loop_p H) { if(H==NULL) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6cd6fa2c1dbd53f1610c2cc9fee2b69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38d814c00bce6d1cd2e8ae98557fccec/" rel="bookmark">
			K8S-001-Virtual box - Network Config
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A. 配置两个IP， 一个连接内网，一个链接外网:
1. 内网配置(Host only， 不同的 virutal box 的版本可以不一样，这些窗口可能在不同的地方，但是配置的内容是一样的):
静态IP
动态IP
2. 外网（创建一个 Network 来连外网）
B. 虚拟机的配置
[root@k8smaster ~]# cat /etc/sysconfig/network-scripts/ifcfg-enp0s3 TYPE=Ethernet
BOOTPROTO=dhcp
DEFROUTE=yes
IPV4_FAILURE_FATAL=yes
PROXY_METHOD=none
BROWSER_ONLY=no
NAME=enp0s3
UUID=d06bea2b-0113-44ff-a2c3-1bc1416d7978
DEVICE=enp0s3
ONBOOT=yes
ZONE=public
[root@k8smaster ~]# [root@k8smaster ~]# cat /etc/sysconfig/network-scripts/ifcfg-enp0s8 TYPE=Ethernet
ONBOOT=yes
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=static
DEFROUTE=yes
IPV4_FAILURE_FATAL=yes
NAME=enp0s8
UUID=083ec645-492d-45bb-aaca-06d80650147f
DEVICE=enp0s8
ONBOOT=yes
IPADDR=192.168.3.105
ZONE=public
[root@k8smaster ~]#
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea505abd17cb4b154ad918877ccdcc70/" rel="bookmark">
			【数据结构】排序（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、概念：
二、直接插入排序：
三、希尔排序：
四、直接选择排序：
五、堆排序：
六、冒泡排序：
一、概念： 排序的概念：
使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。
排序又分为内部排序和外部排序：
内部排序：数据元素全部放在内存中的排序。
外部排序：数据元素太多不能同时放在内存中，根据排序过程的要求不能在内外存之间移动数据的排序。
常见的排序算法：
二、直接插入排序： 基本思想：
把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列 。
例如在我们玩扑克牌斗地主时的码牌操作中就运用到了这个思想。
代码实现：
当插入第i(i&gt;=1)个元素时，前面的a[0],a[1],…,a[i-1]已经排好序，此时用a[i]的排序码与 a[i-1],a[i-2],…的排序码顺序进行比较，找到插入位置即将a[i]插入，原来位置上的元素顺序后移即可。
//时间复杂度: O(N^2)	逆序 //最好的情况: O(N)	顺序有序 void InsertSort(int* a, int n) { for (int i = 0; i &lt; n - 1; i++)// i小于n-1是为下面条件做铺垫，防止越界 { // 设置end为下标，将其与tmp下标位置的数进行比较，并不断更新end int end = i; int tmp = a[end + 1];// 在单趟排序中，tmp固定 // 设置数组最小数的条件 while (end &gt;= 0) { // 对tmp和end位置数进行比较 if (tmp &lt; a[end]) { // 将end位置数复制在end+1处，本质上是更新去排序后对应的位置 a[end + 1] = a[end]; end--;// 更新end } else { break; } } // 将tmp数放入对应的位置 a[end + 1] = tmp; } } 直接插入排序的特性总结：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea505abd17cb4b154ad918877ccdcc70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd93f13d1671794527ce16d8a4912cfb/" rel="bookmark">
			【VRTK】【Unity】【VR开发】使用注意事项-Simulator没反应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【背景】 建立一个基本的VRTK项目后，用Simulator Rig模拟运行，移动鼠标后发现Simulator Rig没有任何反应。
【分析】 Console中的报错信息类似于没有启用Legacy unity input package，Legacy的意思是经典的，所以应该是指没有在player settings中设置为old input method。
【解决方法】 进入菜单Edit-》Project Settings-》Player-》Other Settings-》Configuration-》Active Input Handling，安全起见，可以将该属性改选为Both。
【结果】 再次运行测试，发现可以正常用鼠标模拟Rig移动了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f71876f139e35357abb7c87b5a6bc771/" rel="bookmark">
			【刷题记录】链表的回文结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本系列博客为个人刷题思路分享，有需要借鉴即可。
1.题目链接：
LINK
2.详解思路：
思路：思路：先找到中间节点，然后逆置后半部分链表，一个指针指向链表的头节点，再一个指针指向逆置的头节点，一一进行比对。
本身这个题目时比较难的，所以先搞几个简单的相关题目铺垫一下
铺垫题目1：若需要见详解请单击：LINK
铺垫题目2：若需见详解，请单击：LINK
所以解决回文链表这道题要结合上面两道题目的代码：先找到中间节点再逆置，再比对。
/* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) {} };*/ //找到中间结点 struct ListNode* middleNode(struct ListNode* head) { //思路2：快慢指针法 struct ListNode* fast = head; struct ListNode* slow = head; while(fast &amp;&amp; fast-&gt;next)//快指针走到头 { slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; } return slow; } struct ListNode* reverseList(struct ListNode* head) { //逆置链表为空 if(head == nullptr) return head; //不为空 struct ListNode* n1 = nullptr; struct ListNode* n2 = head; struct ListNode* n3 = head-&gt;next; while(n2) { //逆置 n2-&gt;next = n1; n1 = n2; n2 = n3; if(n3)//n3不为空 { n3 = n3-&gt;next; } } return n1; } class PalindromeList { public: bool chkPalindrome(ListNode* A) { // write code here //找到中间节点 struct ListNode* pMidNode = middleNode(A); //逆置中间节点及其以后的节点 struct ListNode* pNewMidNode = reverseList(pMidNode); //对比 while(A&amp;&amp;pNewMidNode) { if(pNewMidNode-&gt;val!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f71876f139e35357abb7c87b5a6bc771/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/385fe5a52b280e6ec592897dd7754a89/" rel="bookmark">
			听课笔记02
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人机交互的小故事
图形化界面打开图形
麻烦 操作系统
没有界面os
发明操作界面的人是谁呢
做os的大公司
不快进
图形化界面的样子
这段内容简单了一点
说一下操作系统的历史
图形界面的发展
屋外有车融雪
为什么要用图形化界面
cmd就是操作系统
看不起不会使用电脑的普通人，这是不对的
黑马创建大学非常厉害
win r 输入cmd
不小心打开知乎，认真上课
课外的扩展，桌面是一个文件夹。desktop
取之于互联网，用之于网。
打开cmd的方式
下一个视频需要学习cmd的常用命令
黑马大学的广告
常见的cmd命令
干饭
出现bug如何分析解决呢 合理分配工作与生活的时间
盘符切换 E:
dir 查看当前路径 所有文件
cd 进入的意思 后面的单词
cd … 回退
多级目录 多级回退 cd /
cls 用来清零
exit 退出命令行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cffc9fe0a51bb9e18d3c699814331d1e/" rel="bookmark">
			mysql group by分组后查询无数据补0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql经常会用到Group By来进行分组查询，但也经常会遇到一个问题，就是不满足条件的数据就不会显示,如图总共有五个业务,业务状态为3的就不会显示:
因此，想要实现，即使没有数据，也想让count显示出0而不是空的效果；
解决方案：构建一个包含所有delegate_type的表(字典表即可ID,code,name)；然后和我们本来的sql进行左外连接，在最外层利用ifnull函数[ ]SQL如下 SELECT sdi.name,IFNULL( t.countNum, 0) AS num,sdi.code FROM sys_dict sdi LEFT JOIN ( SELECT delegate_type,COUNT(1) AS countNum FROM sys_order GROUP BY delegate_type ) AS t ON t.delegate_type = sdi.code 实现自己想要的结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0838e73f59e20b2cef17e59a012d38e1/" rel="bookmark">
			五.索引的数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		索引的数据结构 1.为什么使用索引2.索引及其优缺点2.1索引概述2.2优点2.3缺点 3.InnoDB中索引的推演3.1索引之前的查找1. 在一个页中的查找2. 在很多页中查找 3.2设计索引1. 一个简单的索引设计方案2.InnoDB中的索引方案①迭代1次：目录项记录的页②迭代2次：多个目录项记录的页③迭代3次：目录项记录页的目录页④B+Tree 3.3 常见索引概念1. 聚簇索引2.二级索引（辅助索引、非聚簇索引）3. 联合索引（非聚簇） 3.4 InnoDB的B+树索引的注意事项1. 根页面位置万年不动2.内节点中目录项记录的唯一性3. 一个页面最少存储2条记录 4.MyISAM中的索引方案4.1MyISAM索引原理4.2MyISAM和InnoDB对比 5.索引的代价6.MySQL数据结构选择的合理性6.1全表遍历6.2Hash结构6.3 二叉搜索树6.4 AVL树6.5B-Tree6.6B+Tree6.7R树6.8小结 1.为什么使用索引 索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教课书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描，即需要一条一条地查找记录，直到找到与条件符合的记录。
如上图所示，数据库没有索引的情况下，数据分布在硬盘不同的位置上面，读取数据时，摆臂需要前后摆动查找数据，这样操作非常消耗时间。如果数据顺序摆放，那么也需要从1到6行按顺序读取，这样就相当于进行了6次io操作，依旧非常耗时。如果我们不借助任何索引结构帮助我们快速定位数据的话，我们查找Col 2 = 89 这条记录，就要逐行去查找、去比较。从Col2=34开始，进行比较，发现不是，继续下一行。我们当前的表只有不到10行数据，但如果表很大的话，有上千万条数据，就意味着要做很多很多次磁盘I/O才能找到。现在要查找Col2=89这条记录。CPU必须先去磁盘查找这条记录，找到之后加载到内存，再对数据进行处理。这个过程最耗时间的就是磁盘I/O(涉及到磁盘的旋转时间（速度较快）、磁头的寻道时间（速度慢、费时）)
假如给数据使用 二叉树 这样的数据结构进行存储，如下图所示
对字段Col 2添加了索引，就相当于在硬盘上为Col 2维护了一个索引的数据结构，即这个二叉搜索树。二叉搜索树的每个结点存储的是（K,V)结构，key是Col 2,value是该key所在行的文件指针（地址）。比如：该二叉搜索树的根节点就是：(34,0×07)。现在对Col2添加了索引，这时再去查找Col 2=89这条记录的时候会先去查找该二叉搜索树（二叉树的遍历查找）。读34到内存，89&gt;34;继续右侧数据，读89到内存，89==89;找到数据返回。找到之后就根据当前结点的value快速定位到要查找的记录对应的地址。我们可以发现，只需要查找两次就可以定位到记录的地址，查询速度就提高了。
这就是我们为什么要建索引，目的就是为了减少磁盘I/O的次数，加快查询速率。
2.索引及其优缺点 2.1索引概述 MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。
索引的本质： 索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 高级查找算法 。
索引是在存储引擎中实现的，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的最大索引数和最大索引长度。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度。
2.2优点 类似大学图书馆建书目索引，提高数据检索的效率，降低 数据库的IO成本 ，这也是创建索引最主要的原因。通过创建唯一索引，可以保证数据库表中每一行 数据的唯一性 。在实现数据的参考完整性方面，可以 加速表和表之间的连接 。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。在使用分组和排序子句进行数据查询时，可以显著 减少查询中分组和排序的时间 ，降低了CPU的消耗。 2.3缺点 增加索引也有许多不利的方面，主要表现在如下几个方面：
创建索引和维护索引要 耗费时间 ，并且随着数据量的增加，所耗费的时间也会增加。索引需要占 磁盘空间 ，除了数据表占数据空间之外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。虽然索引大大提高了查询速度，同时却会 降低更新表的速度 。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。 因此，选择使用索引时，需要综合考虑索引的优点和缺点。
提示：
索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。
3.InnoDB中索引的推演 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0838e73f59e20b2cef17e59a012d38e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d6748737ba8f8e706342ff4dd3d57ab/" rel="bookmark">
			centos将sh文件设置为开机自动执行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、先创建一个sh文件 vim redis-6.0.3.sh 这个是redis执行的sh脚本内容
#!/bin/sh
# chkconfig: 2345 80 90
# Simple Redis init.d script conceived to work on Linux systems
# as it does use of the /proc filesystem.
REDISPORT=7000 # 对应redis.conf文件的端口
EXEC=/usr/redis/redis-6.0.3/src/redis-server # redis-server 文件的位置
CLIEXEC=/usr/redis/redis-6.0.3/src/redis-cli # redis-cli 文件的位置
PIDFILE=/var/run/redis_${REDISPORT}.pid # 进程文件的位置
CONF="/usr/redis/redis-6.0.3/redis.conf" # 配置文件的位置
case "$1" in
start)
if [ -f $PIDFILE ] # 如果redis进程文件存在
then
echo "$PIDFILE exists, process is already running or crashed"
else
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d6748737ba8f8e706342ff4dd3d57ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9b928297d05be97fc595f0857bccd80/" rel="bookmark">
			机器学习中的决策树算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 决策树是一种常见的机器学习算法，属于监督学习。它借鉴了我们日常生活中采取决定的方法。每一个决定都会导向一个新的局面，这种情境可以被模拟成树的结构，因此被称为决策树。
基本原理 决策树方法将一个复杂的决策过程简化为一系列二元决策，形成一棵“树”形结构。每一个决策点（非叶节点）是一个特征，树的每个叶节点表示一个结果。
构建过程 构建决策树的过程实际上就是选择何时以及在何处选择哪个特征然后分解问题的过程。对于选择何处划分的疑问，答案很简单，一般我们自上而下的递归构造决策树。对于何时划分以及选择哪个特征进行划分，有几种常见的算法，如信息增益、增益率、基尼指数等。
# 以下是决策树算法的一个简单示例 from sklearn.datasets import load_iris from sklearn.model_selection import cross_val_score from sklearn.tree import DecisionTreeClassifier clf = DecisionTreeClassifier(random_state=0) iris = load_iris() cross_val_score(clf, iris.data, iris.target, cv=10) 总结 决策树是一种易于理解和实现的机器学习算法，同时也是很多强大的机器学习模型（如随机森林、GBDT）的基础。学好决策树，我们在机器学习的道路上就已经走出了一大步。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b5deeaad3f7d1449d041e641b9b023f/" rel="bookmark">
			C语言第二十九弹---浮点数在内存中的存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨个人主页： 熬夜学编程的小林
💗系列专栏： 【C语言详解】 【数据结构详解】
目录
1、浮点数在内存中的存储
1.1、练习
1.2、浮点数怎么转化为二进制
1.3、浮点数的存储
1.3.1、浮点数存的过程
1.3.2、浮点数取的过程
1.3、题目解析
总结
1、浮点数在内存中的存储 常见的浮点数：3.14159、1E10(1^10)等，浮点数家族包括： float 、 double 、 long double 类型。 浮点数表示的范围： float.h 中定义 1.1、练习 #include &lt;stdio.h&gt; int main() { int n = 9; float *pFloat = (float *)&amp;n; printf("n的值为：%d\n",n); printf("*pFloat的值为：%f\n",*pFloat); *pFloat = 9.0; printf("num的值为：%d\n",n); printf("*pFloat的值为：%f\n",*pFloat); return 0; } 输出什么？ 按照我们整数存储的想法，打印的结果分别是9、9.000000、9、9.000000 但是为什么会出现上面的结果呢？下面就从浮点数的存储来详细讲解此代码。
1.2、浮点数怎么转化为二进制 首先我们来个简单的例子：
把十进制小数5.25化为二进制小数，我们应该怎么操作？
我们分为以下几步：
1. 以小数点为界进行拆分；
2. 整数部分转为二进制相信大家肯定没问题
3. 小数部分采用的是"乘2取整法"，当乘2之后小数部分得到0就停止计算
十进制小数5.25：
1、以小数点为界进行拆分，整数部分为5，小数部分为0.25
2、整数转化为二进制为101
3、小数部分采取“乘2取整法”，0.25*2=0.5，整数部分为0，小数部分为0.5，继续乘2,0.5*2=1.0，整数部分为1，小数部分为0，小数部分为0则停止计算。取的数字为整数部分数字，因此转化为二进制小数为0.01。
4. 合并结果：整数部分 + 小数部分，最终得到二进制结果为101.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b5deeaad3f7d1449d041e641b9b023f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2b35cb378c73e6e4a2c80b21b0e0f2d/" rel="bookmark">
			python中hasattr()、getattr()、setattr()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hasattr(object, name) 作用：用于检查对象是否具有指定名称的属性或方法。参数： object：要检查的对象。name：要检查的属性或方法的名称。返回值：如果对象具有指定名称的属性或方法，则返回True；否则返回False。 class MyClass: x = 10 def my_method(self): pass obj = MyClass() print(hasattr(obj, 'x')) # True，obj具有属性'x' print(hasattr(obj, 'my_method')) # True，obj具有方法'my_method' print(hasattr(obj, 'y')) # False，obj不具有属性'y' getattr(object, name[, default]) 作用：用于获取对象的属性或方法。参数： object：要获取属性或方法的对象。name：要获取的属性或方法的名称。default：可选参数，如果属性或方法不存在时返回的默认值，默认为None。返回值：如果对象具有指定名称的属性或方法，则返回该属性或方法；否则，如果提供了default参数，则返回默认值；否则，抛出AttributeError异常。 class MyClass: x = 10 def my_method(self): pass obj = MyClass() print(getattr(obj, 'x')) # 10，获取属性'x'的值 print(getattr(obj, 'my_method')) # &lt;bound method MyClass.my_method of &lt;__main__.MyClass object at 0x7fb0f8e21730&gt;&gt;，获取方法'my_method' print(getattr(obj, 'y')) # AttributeError: 'MyClass' object has no attribute 'y' print(getattr(obj, 'y', 'default_value')) # 'default_value'，属性'y'不存在，返回默认值 setattr(object, name, value) 作用：用于设置对象的属性。参数： object：要设置属性的对象。name：要设置的属性的名称。value：要设置的属性的值。返回值：无。 class MyClass: pass # 创建对象实例 obj = MyClass() # 定义要动态添加的方法 def greet(self): print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2b35cb378c73e6e4a2c80b21b0e0f2d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/5/">«</a>
	<span class="pagination__item pagination__item--current">6/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/7/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>