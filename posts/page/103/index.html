<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a14e112c7214beed08a714d3f97e90cb/" rel="bookmark">
			Win7 支持.net framework的最高版本是4.5.2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、截止目前2019-11-02 11:33 dotnet-framework各个版本。
目前win7系统支持的最高版本的dotnet-framework 4.5.2
附件中包含.net-framework 4…0-----------4.8各个版本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c2220b9df62996ff9ada74e12b3d2e2/" rel="bookmark">
			Java是动态语言还是静态语言，是强类型还是弱类型？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 前言 今天小熙突然想到一个问题，那就是Java到底是动态语言还是静态语言，是强类型还是弱类型呢？虽然知道但是还是不够深入，接下来就一起探讨下吧。
二. 图释 小熙碰巧看到一张图，完美的区分了以上的问题，如下图所示：
如图所示，Java是强类型语言，静态类型。下面解释下为什么。
三. 解释 静态类型语言：变量定义时有类型声明的语言。
（1）变量的类型在编译的时候确定
（2）变量的类型在运行时不能修改
这样编译器就可以确定运行时需要的内存总量。
例如：C、Scala、Java、F#语言是静态类型语言。
动态类型语言：变量定义时无类型声明的语言。
（1）变量的类型在运行的时候确定
（2）变量的类型在运行可以修改
例如：python、Javascript、Ruby语言是动态类型语言。
强类型定义语言
强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言。
弱类型定义语言
数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。强类型定义语言在速度上可能略逊色于弱类型定义语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。
综上所述：小熙认为Java是在编译时期确定的变量类型且在运行时期不能改变，在类型转换方面也是强制的，例如大范围整数类型转换为小范围整数类型时必须要强转，如 int 必须强制转换才能得到小范围类型 byte。所以Java是静态、强类型语言。
以上就是小熙总结的结论，欢迎大家讨论。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c0a714de3bab214d8409191edcbc427/" rel="bookmark">
			聊聊 Airtest 自动化工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“ AirPython ”，选择“置顶公众号” 第一时间获取 Python 技术干货！ 阅读文本大概需要 5 分钟。 很多读者看过之前的文章，发现我使用最多的是一款 Airtest 的自动化测试框架。 Airtest 是一款适合于游戏和 App 的 UI 自动化测试框架。 下面对 Airtest 在平时自动化和爬虫过程中的常见问题做一个汇总。 1、 优势 Airtest 上手难易度低，高效方便，结合 Python 脚本，可以完成一些自动化的操作，也可以快速开发出一款 App 端的爬虫。 2、 AirtestIDE 还是 Pycharm 如果只是简单的一些操作，可以使用官网提供的 AirtestIDE，通过简单的拖拽、按压、点击就能完成脚本录制和回放操作。 当然，想完成一些复杂的操作，就需要在 Python 虚拟环境下安装 pocoui 依赖库，然后借助 Pycharm 编写 Python 脚本来完成。 3、 Airtest 结合 Python 操作 只需要在 Python 虚拟环境下安装 pocoui 依赖库。 pip3 install pocoui 4、 有线连接和无线连接 利用 Airtest 驱动手机完成自动化操作，有两种方式： 有线连接、无线连接。 有线连接 ：手机通过数据线连接 PC，确保使用 adb devices 命令能找到设备。 然后，通过下面的 Python 代码即可以完成连接操作。 # 通过有线连接 PC 端和手机 self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c0a714de3bab214d8409191edcbc427/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2026502d5ffdeaf4ca87c65be2fe920f/" rel="bookmark">
			2019.10.18 - Linux与MacOS 修改系统时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查看时间 date
MacOS：
Linux：
修改时间 Linux ntp自动校时 关闭ntp自动校时：sudo timedatectl set-ntp no打开ntp自动校时：sudo timedatectl set-ntp yes date -s 修改系统时间 sudo date -s "2016/11/11 10:21:32" sudo date -s "2016-11-11 10:21:32" sudo date -s "20161111 10:21:32" 另外也可以使用 next 或 last 的方式來設定 sudo date -s "next Mon" # 下週一 sudo date -s "last Mon 17:30:21" # 上週一 17:30:21 timedatectl 修改时间：sudo timedatectl set-time "2016-11-12 18:10:40" MacOS 关闭自动设置时间
修改的时间，都是使用两位数为替代，分别是 月、日、小时、分钟和年份。
sudo date 1019121019
参考资料 Linux 手動更改系統時間：date、hwclock 與 timedatectl 指令用法教學如何使用mac终端修改系统时间 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38cd0261fed98107b9eb7ec6c170b47d/" rel="bookmark">
			CAS介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换。
CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。
更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。
例子：
在内存地址V当中，存储着值为10的变量。 2.此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11。
3.在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。
4.线程1开始提交更新，首先进行A和地址V的实际值比较（Compare），发现A不等于V的实际值，提交失败。
5.线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为自旋。
6.这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相等的。
7.线程1进行SWAP，把地址V的值替换为B，也就是12。
从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。
CAS的缺点：
1.CPU开销较大
在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。
2.不能保证代码块的原子性
CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。
原子操作类的底层正是使用了CAS机制。
原子操作类，指的是java.util.concurrent.atomic包下，一系列以Atomic开头的包装类。例如AtomicBoolean，AtomicInteger，AtomicLong。它们分别用于Boolean，Integer，Long类型的原子性操作。
使用Synchronized在某些情况下不是一个最优情况
关键在于性能问题。
Synchronized关键字会让没有得到锁资源的线程进入BLOCKED状态，而后在争夺到锁资源后恢复为RUNNABLE状态，这个过程中涉及到操作系统用户模式和内核模式的转换，代价比较高。
尽管Java1.6为Synchronized做了优化，增加了从偏向锁到轻量级锁再到重量级锁的过度，但是在最终转变为重量级锁之后，性能仍然较低。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12a405fd8cfd6706c4be90c4d3e5a1a1/" rel="bookmark">
			使用Redis实现中英文自动补全功能详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Redis自动补全功能介绍: ​ Redis可以帮我们实现很多种功能,今天这里着重介绍的是Redis的自动补全功能的实现.我们使用有序集合，并score都为0，这样就按元素值的字典序排序.然后我们可以根据排序号的字符,进行添加前缀和后缀的方式,找到我们想要的区间内容.下面介绍一个简单的Zset的排序内容和思路,以便后续的理解:
名称为redis_concat的Zset集合元素如下:
编号数值分值1a02ab03abcd04abef05hjk06dbfgll07efhuo08iop09lkj010ghu0 ​ 当所有的数值分值为0的时候,Zset会按照字典升序排列,这里我们如果需要查找上面的a,就应该能找出[ a, ab,abcd,abef]这四个元素,查找上面的ab,就应该能找出[ab,abcd,abef]这三个元素,其他同理.这个时候我们只要想办法在这个搜索条件查找元素的前面后最后都筛选出想要的数据即可:
Ascii码里小写字母a的前面是`,z的后面是{于是我们查找ab匹配的元素,插入 aa{ 和 ab{ 即可( 或者" ab` "和" ab{ " )找到aa{ 和 ab{ 的下标,通过Zrange()得出相关区间的内容如果是中文,建议全部将支付转为16进制字符来进行存储,取出时候再转码 2.相关Demo分享 ​ 基于此本人建立了一个前后端分离的利用Redis自动补全联系人姓名的项目,前端采用的是Vue,后端采用Java的Spring框架,这个示例功能单一,有好的建议和想法都可以给我留言评论,多加以改进,另外项目GitHub地址在文末,喜欢请关注.下面是项目的简单演示:
项目结构如下: ├─src │ └─main │ ├─java │ │ └─com │ │ └─home │ │ ├─config │ │ ├─constants │ │ ├─controller │ │ ├─mapper │ │ ├─page │ │ ├─pojo │ │ └─service │ │ └─impl │ ├─resources │ │ ├─mapper │ │ └─properties │ └─webapp │ └─WEB-INF │ └─views │ └─vue └─target ├─classes │ ├─com │ │ └─home │ │ ├─config │ │ ├─constants │ │ ├─controller │ │ ├─mapper │ │ ├─page │ │ ├─pojo │ │ └─service │ │ └─impl │ ├─mapper │ └─properties ├─generated-sources │ └─annotations ├─qfang-agent-online-mass-client │ ├─META-INF │ └─WEB-INF │ ├─classes │ │ ├─com │ │ │ └─home │ │ │ ├─controller │ │ │ ├─mapper │ │ │ ├─pojo │ │ │ └─service │ │ │ └─impl │ │ └─mapper │ └─lib └─redis-web-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12a405fd8cfd6706c4be90c4d3e5a1a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f853d5cf0906bf9c6608cc2c93805069/" rel="bookmark">
			airtest基础使用(安装&#43;连接&#43;脚本导入)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		airtest基础(安装+连接+脚本导入) 原创：George555 公众号： 测试江湖路 如果这些内容对你有帮助，也可以打开微信扫一扫，加关注:
注：本篇只针对代码层面的使用，关于AirtestIDE的使用请去官网查看。
一、环境要求：
操作系统
Windows
MacOS X
Linux
Python2.7 &amp; Python3+
二、安装
1.安装方法1：pip install -U airtest
2.安装方法2：从git下载：
git clone https://github.com/AirtestProject/Airtest.git
pip install -e airtest
备注：因为Airtest还在快速开发中，这里使用 -e 来安装源码。以后你就可以直接使用 git pull 更新代码目录来升级Airtest了。
三、连接设备
---Android设备连接----
connect_device("android:///") #连接本地android设备connect_device("android://adbhost:adbport/1234566?cap_method=javacap&amp; touch_method=adb") #连接远端android设备示例： #A.连接本地夜神模拟器：
connect_device('Android://127.0.0.1:5037/127.0.0.1:62001')
注意：夜神模拟器端口是62001，127.0.0.1:5037是对应的本机的adbhost和adbport
#B.连接本机usb连接的真机： (连接华为真机)
connect_device("android:///Y2J5T17815005122")
----windows应用连接----
connect_device("Windows:///") #连接windows桌面
connect_device("Windows:///?title_re=百度.*") #连接windows应用
示例：
根据title正则匹配窗口：connect_device("Windows:///?title_re=百度一下.*")
根据窗口句柄匹配窗口：connect_device('Windows:///3410242')
----IOS设备连接----
connect_device("ios:///") #连接本机ios设备，即在mac上
connect_device("ios:///http://192.168.2.127:8100") #连接远端ios设备(比如在windows上调用脚本，操作mac上连接的ios设备)
注意：http://192.168.2.127:8100是在mac的xcode上运行WebdriverAgent(iOS-Tagent)成功后的服务端地址和端口
四、常用模拟输入
touch
swipe
text
keyevent
snapshot
wait
五、常用断言
assert_exists
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f853d5cf0906bf9c6608cc2c93805069/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4dd4c94bdc90069ef3e563369694ebb/" rel="bookmark">
			保存远程共享文件夹的文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CMDNetFileHelper
/// &lt;summary&gt; /// 连接远程共享文件夹 /// &lt;/summary&gt; public class CMDNetFileHelper { /// &lt;summary&gt; /// 连接远程共享文件夹 /// &lt;/summary&gt; /// &lt;param name="path"&gt;远程共享文件夹的路径&lt;/param&gt; /// &lt;param name="userName"&gt;用户名&lt;/param&gt; /// &lt;param name="passWord"&gt;密码&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool connectState(string path, string userName, string passWord) { bool Flag = false; Process proc = new Process(); try { proc.StartInfo.FileName = "cmd.exe"; proc.StartInfo.UseShellExecute = false; proc.StartInfo.RedirectStandardInput = true; proc.StartInfo.RedirectStandardOutput = true; proc.StartInfo.RedirectStandardError = true; proc.StartInfo.CreateNoWindow = true; proc.Start(); string dosLine = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4dd4c94bdc90069ef3e563369694ebb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf7dc4e1eea26595bd70b7a212376a25/" rel="bookmark">
			springcloud学习笔记2：eureka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在之前，没有学习springcloud之前，学习了dubbo，dubbo是一个远程调用(RPC)框架，当时使用的是zookeeper注册中心，但是在springcloud2.x之前，springcloud是没有zookeeper的，那么是如何实现远程调用的呢？
1.eureka（springcloud1.x版本的注册中心） springcloud在2019年也就是springcloud2之后才添加的zookeeper，在这之前，都是使用的springcloud自带的eureka注册中心实现的远程调用。
eureka是springcloud的核心，许多的服务都需要依赖eureka实现。
eureka与zookeeper的比较：
在之前使用的是zookeeper，现在学习eureka了解到，eureka也是一个注册中心，那么两个注册中心有什么区别呢？（如果都一样的话，为什么要开发它）
首先回顾zookeeper：
zookeeper保证的是数据的一致性（CP特性），zookeeper是一主多从机制，也就是三台zookeeper只有一台是leader，其他的两台是follower，消费者请求进来后，无论是进入leader还是follower，都会被移交给leader进行处理。
zookeeper的缺陷：因为保证了数据的一致性，那么如果leader宕机的话，就会读取到脏数据，之前zookeeper中有详细的介绍
Eureka：
eureka保证的是服务的可用性（AP特性），eureka集群中每个节点都是平等的，因此在服务注册时，就需要在每个节点都注册一份，三台节点中的数据都是一样的。这样就不会出现zookeeper中leader宕机读取脏数据的情况。解决了zookeeper的缺陷。
eureka的自我保护机制：
如果长时间不激活eureka的时候就会出现自我保护机制。
eureka在启动后，生产者每隔一段时间就会向eureka中发送心跳，eureka接收生产者的心跳，当网络延迟/服务器宕机等情况发生后，生产者不在向eureka发送心跳，eureka从接收不到心跳开始，默认90后，就会踢出这个生产者（Provider），但是如果出现大面积的生产者宕机——生产者的机房停电了，所有的服务器都无法发送心跳，这时eureka就不会踢出任何一个服务（会将所有的服务都保留下来，这就是AP性）
Eureka为什么不会踢出大量的服务？
如果把eureka中的所有服务都踢出，当consumer进来后，发现没有可用的服务了，就会报错500，整个项目于就瘫痪了。
当大面积服务没有心跳，但是eureka不踢出的话，consumer进来后，仍然可以获取到服务，可以获取到数据，这个数据可能不是最新的数据（假如说因为网络延迟，导致eureka没有接收到心跳，这样eureka不会讲服务全部踢出，也就是说consumer仍然可以找到provider，provider仍然可以工作，只是因为网络延迟的原因，可能现在获取的数据，其实已经被删除了，只不过删除的操作发生网络拥堵还没有到生产者中，这就会造成数据的不一致）
AP性：保证服务的可用性，不保证数据的一致性
CP性：保证数据的一致性，不保证服务的可用性
如何关闭eureka的自我保护机制 可以关，但是不能这么做
如果现在有一个服务就是不需要eureka的自我保护机制，那么可以想办法让eureka的自我保护失效。
方法：provider告诉eureka我每隔5秒给你发送一次心跳，如果你八秒后仍没有接受到我的心跳，那么你就将我踢出。
# 规定自己向eureka发送心跳的时间 # 单位是秒 eureka.instance.lease-renewal-interval-in-seconds=5 # 当eureka最后一次检测到心跳的时间间隔(单位是秒) # eg:15:05:20是最后一次检测到心跳--&gt;检测8秒之后还是无法检测心跳的时候直接剔除 eureka.instance.lease-expiration-duration-in-seconds=8 eureka中设置，默认等待provider10秒，10秒后还没有接受到心跳，就将provider踢出
# eureka自己检测服务的心跳时间(90秒) # 单位是毫秒，先把eureka检测心跳的时间缩短为10秒 # 也就是说每个10秒就会检测一次服务的心跳 eureka.server.eviction-interval-timer-in-ms=10000 具体使用：https://github.com/Zs-xiazhi/springcloud-parent
转载于:https://www.cnblogs.com/Zs-book1/p/11603833.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6f0cb5a1295f805ea7c3a5e15d540ac/" rel="bookmark">
			[LGOJ5558]心上秋（倍增）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题意 给一颗边带权的树，边权为1~5，多次询问树上某条路径组成的边权序列的LIS
思路 假设已知边权序列，设\(f_{i,j}\)表示处理了前\(i\)个数，当前\(LIS\)中的最后一个数为\(j\)时的\(LIS\)长度，显然有\(f_{i,j}=max(f_{i-1,k}+1),(k\leq j)\)，由于边权为1~5，这个算法一次是\(O(n)\)的
通过上述对\(f\)的处理的思路就可以得到倍增法
设\(fa_{rt,i}\)表示从\(rt\)向上跳\(2^i\)步到的节点
设\(g_{rt,i,j,k}\)，表示从\(rt\)向上跳\(2^i\)步得到的边权序列，当前\(LIS\)中的最小数为\(j\)，最大数为\(k\)时的\(LIS\)长度
有转移方程
\(g_{rt,i,j,k}=max(g_{rt,i-1,j,p}+g_{fa_{rt,i-1},i-1,p,k})\) 利用这个数组优化上面求\(f\)的过程即可
注意：虽然从\(y\)向\(lca\)走求的是最长不上升子序列（与\(LIS\)相反），但是可以发现\(g\)数组在\(j\geq k\)就可以表示最长不上升子序列（虽然这样与定义不符，但确实可以用）
Code #include&lt;bits/stdc++.h&gt; #define N 30005 #define Max(x,y) ((x)&gt;(y)?(x):(y)) #define Min(x,y) ((x)&lt;(y)?(x):(y)) using namespace std; const int temp = 16; int n,m,dep[N]; int dp[2][temp][6],g[N][temp][6][6],f[N][temp]; int l[N],r[N],cl,cr;//倍增时向上经过的断点 bool rev; struct Edge { int next,to,dis; }edge[N&lt;&lt;1];int head[N],cnt=1; void add_edge(int from,int to,int dis) { edge[++cnt].next=head[from]; edge[cnt].to=to; edge[cnt].dis=dis; head[from]=cnt; } template &lt;class T&gt; void read(T &amp;x) { char c;int sign=1; while((c=getchar())&gt;'9'||c&lt;'0') if(c=='-') sign=-1; x=c-48; while((c=getchar())&gt;='0'&amp;&amp;c&lt;='9') x=x*10+c-48; x*=sign; } void dfs(int rt,int fa) { dep[rt]=dep[fa]+1; for(int i=head[rt];i;i=edge[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6f0cb5a1295f805ea7c3a5e15d540ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3635a7b5c87f7459c87dae953a996032/" rel="bookmark">
			Android Studio获取开发版SHA1值和发布版SHA1值的史上最详细方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
今天我想把百度地图的定位集成到项目中来，想写个小小的案例，实现一下，但在集成百度地图时首先要申请秘钥，申请秘钥要用到SHA1值，所以今天就来总结一下怎样去获取这个值吧，希望对大家有帮助。
正常情况下：
一、获取开发版SHA1：
在此我直接用Android Studio提供的命令控制台了，毕竟做Android开发几乎都是用Android Studio了。
1、打开android studio 找到Terminal并打开，或者在最下面找到Terminal 如下图:
2、 输入命令 C: 进入c盘；
3、接着 输入命令 cd Users\Administrator 其中Administrator是自己的用户名 Administrator文件下有个.adnroid文件， 输入命令 cd .android，最后就找到了.android，如图：
4、输入命令 keytool -list -v -keystore debug.keystore 其中debug.keystore是studio默认的keystore，按回车，然后输入秘钥：android（系统默认） 回车（秘钥库口令是看不到的）如下图：
这样就成功获取到开发版的SHA1值了，是不是很简单呀，那是当然！
二、获取发布版的SHA1：
获取发布版的SHA1，跟获取开发版的SHA1的1、2、3步骤一样，不一样的地方就是第4步稍微不同而已。
1、同上；
2、同上；
3、同上；
4、输入命令 keytool -list -v -keystore 文件目录\自己的签名文件 比如我的：keytool -list -v -keystore E:\签名文件\android.keystore ，接着按回车，然后输入秘钥：（我只知道我的，哈哈） 回车（秘钥库口令是看不到的）如下图：
这样就成功获取到发布版的SHA1值了，是不是很简单呀，那是当然！
上面是正常情况下执行的，我在获取SHA1时就被坑了，接下来就是说一下不正常的情况了：
1、首先是出现：
'keytool' 不是内部或外部命令，也不是可运行的程序或批处理文件。如图：
于是我参考了一篇文章：http://blog.csdn.net/csdnhejingzhou/article/details/50643246 ，确实可以是解决了这个问题；
2、前面的问题解决了，然后我就按照他的步骤直接运行deybug.keystore，即C:\Program Files\Java\jdk1.8.0_31\bin&gt;cd keytool.exe
但又出现了一个问题：提示目录名称无效。如图：
最后我直接 把 C:\Users\Administrator\.Android 目录下的 debug.keystore 拷贝到 C:\Program Files\Java\jdk\bin 目录下了，就是和debug.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3635a7b5c87f7459c87dae953a996032/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e72de1e829b095807fb73f91a0be3b4/" rel="bookmark">
			【解决】Error: ENOSPC: no space left on device, watch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发现问题： 启动 node 项目ReactNative时候出现报错Error: ENOSPC: no space left on device, watch
[root@iz2zeihk6kfcls5kwmqzj1z JFReactNativeProject]# npm start &gt; wk_rn@0.0.1 start /app/jenkins_workspace/workspace/JFReactNativeProject &gt; react-native start ┌──────────────────────────────────────────────────────────────────────────────┐ │ │ │ Running Metro Bundler on port 8081. │ │ │ │ Keep Metro running while developing on any JS projects. Feel free to │ │ close this tab and run your own Metro instance if you prefer. │ │ │ │ https://github.com/facebook/react-native │ │ │ └──────────────────────────────────────────────────────────────────────────────┘ Looking for JS files in /app/jenkins_workspace/workspace/JFReactNativeProject Loading dependency graph.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e72de1e829b095807fb73f91a0be3b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d063089b1b2b7a15c10e40cbf6542ee/" rel="bookmark">
			mac 终端访问文件没有权限解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 终端下先 cd到该文件的目录下；
$ cd /Users/***/Documents 2. 执行命令 chmod a+x 文件名；
$ chmod a+x ****** 3. terminal自动运行写入功能，将选中的文件写成terminal 下的Unix可执行文件；
4. 最后，退出terminal，“control+click” 打开该文件即可。
2020年11月补充：
输入以下内容，然后直接拖拽文件进入terminal中，enter后“control+click” 打开即可。
chmod a+x 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/588c5123920398ecadb9a0edc22ed1f4/" rel="bookmark">
			数字图像处理（频域、空域处理基础）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 将图像从空间域通过傅里叶变换等变换转换到频域，目的在于更好处理且计算速度快。
1.频域处理基础
通过狄里赫莱条件（有限个间断点、有限个极值点、绝对可积）定义傅里叶变换。 通过了解FT的性质对图像进行处理。
上机实现：
m=imread('D:\Imagematlab\1.jpg'); t=rgb2gray(m); figure; imshow(t); R=fftshift(fft2(t));%fft figure; imshow(log(abs(R)),[]); figure; r2=dct2(t); imshow(log(abs(r2)),[]);%dct 2.空域点处理
伪彩色处理 or 假彩色处理：
伪彩色处理--灰度图像变为彩色图像，对比度增强、图像恢复。
假彩色处理--映射成奇异彩色引人注目；利用人眼对彩色的敏感度提高鉴别能力；遥感图像处理获得更多信息。
I=imread('cat.jpg'); I=rgb2gray(I); % I=im2double(I); % a=2;b=-55; % R=a.*I+b/255;%线性运算 % figure(1); % imshow(R); % R=2.5*log(I+1);%非线性运算 % figure(2); % imshow(R); % R=1.0*I.^4.5;%幂运算 % figure(3); % imshow(R); % imhist(I); % R=histeq(I); % figure; % imshow(R); % title('均衡化'); % J=imnoise(I,'salt &amp; pepper',0.02); % subplot(2,3,1);imshow(I);title('原图像'); % subplot(2,3,2);imshow(J);title('添加椒盐噪声'); % R1=filter2(fspecial('average',3),J);%3*3模板均值滤波 % R2=filter2(fspecial('average',5),J); % R3=filter2(fspecial('average',7),J); % R4=filter2(fspecial('average',9),J); % subplot(2,3,3);imshow(uint8(R1)),title('3*3模板均值滤波'); % subplot(2,3,4);imshow(uint8(R2)),title('5*5模板均值滤波'); % subplot(2,3,5);imshow(uint8(R3)),title('7*7模板均值滤波'); % subplot(2,3,6);imshow(uint8(R4)),title('9*9模板均值滤波'); % % figure(2); % subplot(2,3,1);imshow(I);title('原图像'); % subplot(2,3,2);imshow(J);title('添加椒盐噪声'); % R1=medfilt2(J); % R2=medfilt2(J,[5 5]); % R3=medfilt2(J,[7 7]); % R4=medfilt2(J,[9 9]); % subplot(2,3,3);imshow(R1),title('3*3');%中值模板 % subplot(2,3,4);imshow(R2),title('5*5'); % subplot(2,3,5);imshow(R3),title('7*7'); % subplot(2,3,6);imshow(R4),title('9*9'); % figure; % subplot(1,3,1);imshow(I); % H=fspecial('Sobel'); % H=H';%Sobel垂直模板 % R=filter2(H,I); % subplot(1,3,2);imshow(R,[]); % H=H';%Sobel水平模板 % R=filter2(H,I); % subplot(1,3,3);imshow(R,[]); % % figure(2); % subplot(2,3,1);imshow(I); % [R,t]=edge(I,'log'); % subplot(2,3,2);imshow(R);title('LOG算子检测边缘'); % R=edge(I,'Sobel'); % subplot(2,3,3);imshow(R);title('Sobel算子检测边缘'); % R=edge(I,'Prewitt'); % subplot(2,3,4);imshow(R);title('Prewitt'); % R=edge(I,'Roberts'); % subplot(2,3,5);imshow(R);title('Roberts'); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/663d834155e217767a2bd44917e79fb8/" rel="bookmark">
			C#面向对象程序设计学习笔记（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		继承
在程序设计中实现继承，表示这个类拥有他继承的类的所有共有成员或者受保护成员，在面向对象的编程中被继承的类称为父类或基类，实现继承的类成为子类或派生类。继承的基本思想是基于某个基类的扩展，制定一个新的派生类，派生类可以继承基类原有的属性和方法，也可以增加原来基类所不具备的属性和方法，或者重写基类中的某些方法。C#中使用“：”来标识两个类的继承关系。子类不能访问基类的私有成员。子类的访问不能高于父类的可访问性，例如下面子类继承父类
子类重写
子类重写父类的方法，如果想要调用父类的方法，就要使用base关键字
base.Property; //调用父类的属性 base.method(); //调用父类的方法 如果要在子类中使用base关键字调用父类的属性或者方法，父类的属性和方法必须定义为public或者protected类型
class Computer //父类：电脑 { public string sayHello() { return "欢迎使用"; } } class Pad : Computer //继承computer类 子类：平板电脑 { public new string sayHello() //子类重写父类方法 { return base.sayHello() + "平板电脑"; //调用父类方法，在结果后添加字符串 } } 在子类中定义构造函数时，即可使用base关键字来调用基类的构造函数
多态
它使得子类的实例可以直接赋予基类的对象，然后直接就可以通过这个对象调用派生类的方法，在C#中，类的多态性是通过在派生类中重写基类的虚方法来实现。
在C#中，方法在默认情况下不是虚拟的，但（除了构造函数以外）可以显示地声明为virtual，在方法前面加上关键字virtual，则称该方法为虚拟方法，定义虚方法后，可以在子类重写虚方法，重写虚方法使用override关键字。
类中的成员字段和静态方法不能声明为virtual，因为virtual只对类中的实例方法和属性有意义。
可以创建类名的数组，例如Vehicle[ ] vehicles={vehicle,train,car}
抽象类和抽象方法
如果一个类不与具体的事物相联系，仅仅是作为其派生类的一个基类，这样的类就可以声明为抽象类，C#中声明抽象类时需要使用abstract关键字，抽象类不能直接实例化，其中可以包含抽象成员，但非抽象类中不可以，抽象类中不能被密封，抽象方法必须声明在抽象类中，声明抽象方法时，不能使用virtual、static、private修饰符。例子如下：
当从一个派生类中生成一个非抽象类时，需要在非抽象类中重写抽象方法，以提供具体的实现，在重写抽象方法时需要使用override关键字.。
public abstract class Market //创建抽象类 { public string Name { get; set; } //商场名称属性 public string Goods { get; set; } //商品名称属性 public abstract void Shop(); //抽象方法 } public class WallMarket : Market //继承抽象类 { public override void Shop() //重写抽象方法 { Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/663d834155e217767a2bd44917e79fb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c942dec3143ffee8c2699927f9d895bb/" rel="bookmark">
			Spss乱码问题的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spss乱码问题的解决方法 方法1：网友kuangsir6提供 选择字体为：DFKai-SB 格式（我并没有找到这个格式）方法是 SPSS（PASW）—Edit—Options—Viewer—Title（以及Page Title和Text Output下面的）—Font—点击右边的下拉菜单选择“DFKai-SB”即可。另外两个地方的字体设置方法相同。这两个地方是Options—ChartsOptions—Muliple Imputations
方法2：网友flora_law提供 Spss的表格中显示的中文为乱码，输入的中文也是乱码，刚开始以为是版本的问题，换了两三个版仍然如此，今天才发现了问题的真正所在，原来是表格的字体设置有问题，以下为解决办法:
1、打开任意一个SPSS文件2、
在表格中任意位置右击，在弹出的菜单中选取“网格字体”,在字体对话框中设置，字体为中文字体，如宋体Simsun，确认即可，这样就可以在spss中显示中文和输入中文了。
方法2：网友kissgoodbye23提供 Spss的表格中显示的中文为乱码，输入的中文也是乱码，刚开始以为是版本的问题，换了两三个版仍然如此，今天才发现了问题的真正所在，原来是表格的字体设置有问题。
以下为解决办法：
1、打开任意一个Spss文件
2、在表格中任意位置右击，在弹出的菜单中选取“网格字体”,在字体对话框中设置，字体为中文字体，如宋体Simsun，确认即可，这样就可以在spss中显示中文和输入中文了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ecf7eb410bad2a742c62bfb3ccaff6d/" rel="bookmark">
			mysql的四种隔离级别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文转载链接：https://zhuanlan.zhihu.com/p/76743929?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=803980807206236160
下面的试验博主都进行了一一验证。
什么是事务
事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。
事务的结束有两种，当事务中的所以步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消撤消之前到事务开始时的所以操作。
事务的 ACID
事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。
原子性。事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做。
一致性。事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。
如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。
隔离性。一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。
持续性。也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。
Mysql的四种隔离级别
SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。
低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。
Read Uncommitted（读取未提交内容）
在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。
Read Committed（读取提交内容）
这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。
这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。
Repeatable Read（可重读）
这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。
简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。
Serializable（可串行化）
这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。
这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如：
脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。
不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。
幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就有几列数据是未查询出来的，如果此时插入和另外一个事务插入的数据，就会报错。
在MySQL中，实现了这四种隔离级别，分别有可能产生问题如下所示：
测试Mysql的隔离级别
下面，将利用MySQL的客户端程序，我们分别来测试一下这几种隔离级别。
测试数据库为demo，表为test；表结构：
两个命令行客户端分别为A，B；不断改变A的隔离级别，在B端修改数据。
将A的隔离级别设置为read uncommitted(未提交读)
A：启动事务，此时数据为初始状态
B：启动事务，更新数据，但不提交
A：再次读取数据，发现数据已经被修改了，这就是所谓的“脏读”
B：回滚事务
A：再次读数据，发现数据变回初始状态
经过上面的实验可以得出结论，事务B更新了一条记录，但是没有提交，此时事务A可以查询出未提交记录。造成脏读现象。未提交读是最低的隔离级别。
将客户端A的事务隔离级别设置为read committed(已提交读)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ecf7eb410bad2a742c62bfb3ccaff6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/149b99f6c04a932e877b450e68f2824a/" rel="bookmark">
			mysql约束
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		* 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。 * 分类： 1. 主键约束：primary key 2. 非空约束：not null 3. 唯一约束：unique 4. 外键约束：foreign key * 非空约束：not null，值不能为null 1. 创建表时添加约束 CREATE TABLE stu( id INT, NAME VARCHAR(20) NOT NULL -- name为非空 ); 2. 创建表完后，添加非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL; 3. 删除name的非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20); * 唯一约束：unique，值不能重复 1. 创建表时，添加唯一约束 CREATE TABLE stu( id INT, phone_number VARCHAR(20) UNIQUE -- 添加了唯一约束 ); * 注意mysql中，唯一约束限定的列的值可以有多个null 2. 删除唯一约束 ALTER TABLE stu DROP INDEX phone_number; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/149b99f6c04a932e877b450e68f2824a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be5db3f65f5ad37723a46efcf252c2ed/" rel="bookmark">
			springboot整合swagger-bootstrap-ui,过滤器放开并解决自定义错误信息返回冲突
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.引入swagger依赖包 &lt;!-- swagger --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt; &lt;version&gt;1.9.3&lt;/version&gt; &lt;/dependency&gt; 在启动类上添加@EnableSwagger2注解
2.Swagger配置类 import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; @Configuration @EnableSwagger2 public class SwaggerConfiguration { // @Bean // public Docket createRestApi() { // return new Docket(DocumentationType.SWAGGER_2) // .apiInfo(apiInfo()) // .groupName("资源管理") // .select() // .apis(RequestHandlerSelectors.basePackage("com.example.demo.controller")) // .paths(PathSelectors.any()) // .build(); // } // // @Bean // public Docket createMonitorRestApi() { // return new Docket(DocumentationType.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be5db3f65f5ad37723a46efcf252c2ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2ef51f0ce352b46a6260025ba52eeef/" rel="bookmark">
			Django开发，日常错误。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、migrate失败关于fake和fake-initial参数 以及其他的一些migrate可选用参数 二、在使用cx_Oracle模块中文乱码三、在使用django多线程时引发的问题四、get_or_create()一条记录被创建了两次五、Request body exceeded settings.DATA_UPLOAD_MAX_MEMORY_SIZE. 一、migrate失败 错误如下：
django.db.utils.ProgrammingError: relation "user" already exists 解决方式：
python3 manage.py migrate mfxx (migrations文件) --fake-initial 关于fake和fake-initial参数 以及其他的一些migrate可选用参数 –fake migrate命令的–fake参数在官方文档中的解释是，记录或消除migrate记录，但不去真的运行SQL以改变数据结构。换句话说，一般的migrate的流程是 1.读取migrations文件，解析成SQL；2.执行SQL改变数据库结构或内容；3.将本次migrate的信息录入django_migrations。但是如果加上–fake参数，那么第2步会被直接跳过而变更直接被记录到django_migrations中。 这个参数的使用场景常常是这样的： 当一个migration文件执行出错，而我们明确知道这个错该如何修正，我们完全可以手动去对数据库结构做一些修改。然后再带–fake参数地运行本次变更对应的migration文件。“假装”我们正确地做了一次migrate。 –fake-initial –fake-initial的原理是类似的，只不过其针对的只是执行0001_initial这个文件。所以说fake-initial的使用场景更加狭窄，即上面所说的对于数据库中有结构，但是0001_initial.py重新生成并且需要写入django_migrations记录时，用到这个参数。 sqlmigrate 另外migrate还有一个比较有用的参数是sqlmigrate。其用法是sqlmigrate app 000x_xxx。它的意思是将某个特定的migrations文件翻译成SQL打印到屏幕上。我们手动去执行这些SQL效果和自动去migrate的效果是一样的。因此在自动migrate时出错的时候，可以利用sqlmigrate打印出SQL，具体查看哪些SQL有问题。如果可以排除，那么可以手动修改出错的SQL并执行，再带有–fake参数执行下这个migrate即可。 二、在使用cx_Oracle模块中文乱码 在使用cx_Oracle模块读取oracle数据中的中文数据的时候，返回值是？？？？， 解决方案：
import os os.environ['NLS_LANG'] = 'SIMPLIFIED CHINESE_CHINA.UTF8' 三、在使用django多线程时引发的问题 在使用多线程的时候，需要考虑数据库存储时间问题。
多线程意味着django可以同时处理多个请求
下面有一个情景：
有一个用来存储数据的接口，逻辑是先利用主键判断这条数据是否已经存在，如果存在则返回“此数据已经存在”，否则存下来。
某时候。同时收到两个完全一样的请求，要存贮的数据也完全一样。两个请求同时判断了数据是否已经存在，很显然，不存在，然后两个请求一起存储数据，这是其中一个请求会引发IntegrityError的错误。
这虽然影响不大，但还需注意。
如果有需求的话，可以将这个主键存在redis中，有效期可以设置1小时，redis的速度是非常快的。
四、get_or_create()一条记录被创建了两次 理论上不会被创建两次，但在多线程下确实有可能的。
五、Request body exceeded settings.DATA_UPLOAD_MAX_MEMORY_SIZE. 完整的报错日志：
ERROR 2019-09-24 09:27:23,160 scheme:https path:/asset/api/interface/ method:POST data:&lt;QueryDict: {}&gt; Traceback (most recent call last): File "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2ef51f0ce352b46a6260025ba52eeef/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/102/">«</a>
	<span class="pagination__item pagination__item--current">103/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/104/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>