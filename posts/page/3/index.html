<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8f4a2288c8bd76c1e9d46a60648fb28/" rel="bookmark">
			[超实用插件]在Visual Studio中查看EF Core查询计划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 EF Core是我们.NET开发中比较常用的一款ORM框架，今天我们分享一款可以直接在Visual Studio中查看EF Core查询计划调试器可视化工具（帮助开发者分析和优化数据库查询性能）：EFCore.Visualizer。
值得推荐的.NET ORM框架 对于还不知道怎么选择.NET ORM框架的同学可以看下面这两篇文章，希望对你会有所帮助😁。
16个值得推荐的.NET ORM框架.NET ORM框架使用情况统计 EFCore.Visualizer工具介绍 C#开源的一款EF Core查询计划调试器可视化工具。
支持数据库 目前只支持以下两个数据库：
SQL ServerPostgreSQL 注意环境和版本（重要） EFCore.Visualizer工具需要Visual Studio 17.9.0版或更新版本，支持EF Core 7或更新版本。
Visual Studio版本太低会安装失败：
工具源代码 Visual Studio中安装工具 方式一、VS插件市场搜索下载 在VS中搜索EFCore.Visualizer，点击下载！
方式二、插件市场下载 插件市场下载地址：EFCore.Visualizer - Visual Studio Marketplace 查询计划可视化效果 单击Query Plan Visualizer，将为您的查询显示查询计划。
注意注意（很多同学不显示Query Plan Visualizer按钮的原因）：该插件只支持检查IQueryable变量，不支持List变量，只有IQueryable变量才会展示Query Plan Visualizer 按钮，无法在Visual Studio中检查中间值！！！
SQL Server： PostgreSQL： Visual Studio更多实用技巧 GitHub - YSGStudyHards/DotNetGuide: 🐱‍🚀【C#/.NET/.NET Core学习、工作、面试指南】记录、收集和总结C#/.NET/.NET Core基础知识、学习路线、开发实战、学习视频、文章、书籍、项目框架、社区组织、开发必备工具、常见面试题、面试须知、简历模板、以及自己在学习和工作中的一些微薄见解。希望能和大家一起学习，共同进步👊【让现在的自己不再迷茫✨，如果本知识库能为您提供帮助，别忘了给予支持哦(关注、点赞、分享)💖】。 项目源码地址 更多项目实用功能和特性欢迎前往项目开源地址查看👀，别忘了给项目一个Star支持💖。
GitHub - Giorgi/EFCore.Visualizer: Entity Framework Core queries debugger visualizer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8f4a2288c8bd76c1e9d46a60648fb28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e17a805592764b367d10d27fa4a0a12a/" rel="bookmark">
			贝叶斯核机器回归拓展R包：bkmrhat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.摘要 bkmrhat包是用于扩展bkmr包的贝叶斯核机器回归（Bayesian Kernel Machine Regression, BKMR）分析工具，支持多链推断和诊断。该包利用future, rstan, 和coda包的功能，提供了在贝叶斯半参数广义线性模型下进行identity链接和 probit 链接的方法。
主要功能包括：多链合并、继续采样、诊断和预测等。包内包含多种函数，如kmbayes_parallel用于并行计算多个链，kmbayes_combine和kmbayes_combine_lowmem用于合并链，as.mcmc.bkmrfit将bkmrfit对象转换为MCMC对象以进行诊断，以及predict.bkmrfit用于生成预测。
2. 函数介绍 2.1 包介绍 提供了扩展bkmr包的贝叶斯核机器回归工具支持多链推断和诊断利用future, rstan, coda包 2.2 as.mcmc.bkmrfit 函数书写格式：as.mcmc()将bkmrfit对象转换为coda包的MCMC对象coda 包支持许多不同类型的单链 MCMC 诊断，包括 geweke.diag、traceplot 和 effectiveSize。还可以使用后总结，例如 HPDinterval 和summary.mcmc。用于进行单链MCMC诊断和后验概括 示例代码1 # 加载bkmrhat包 library(bkmrhat) # 例子 set.seed(111) #设置随机数种子 library(coda) #加载coda包 # 加载bkmr包 library(bkmr) # 生成模拟数据 dat &lt;- bkmr::SimData(n = 50, M = 4) # 提取数据 y &lt;- dat$y Z &lt;- dat$Z X &lt;- dat$X set.seed(111) # 运行模型 fitkm &lt;- kmbayes(y = y, Z = Z, X = X, iter = 500, verbose = FALSE, varsel = FALSE) # 应用as.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e17a805592764b367d10d27fa4a0a12a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c18d6ff9af1e9ecc5d249a20773db556/" rel="bookmark">
			为QComboBox建立dropDown消息响应函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 需求
原来有个软件是用mfc做的，其中的comboBox有个功能：在dropndown（点击下拉列表）时通过tcp发送请求并获取消息，然后设置items，最后才popup下拉列表。
后来转到qt，想用QComboBox实现同样的响应dropdown消息的功能，但发现其根本没有dropdown的信号。
解决方法
#pragma once #include &lt;QComboBox&gt; #include &lt;QDebug&gt; class MyComboBox : public QComboBox { Q_OBJECT public: MyComboBox(QWidget* parent = nullptr) : QComboBox(parent) { }; std::function&lt;void()&gt;* dropDown; protected: void showPopup() override { // 模拟下拉列表框展开事件 qDebug() &lt;&lt; "Drop-down event triggered!"; if (dropDown != nullptr) (*dropDown)(); QComboBox::showPopup(); } void hidePopup() override { // 模拟下拉列表框关闭事件 QComboBox::hidePopup(); } }; 以上头文件“MyComboBox.h”定义了类MyComboBox，使用时只需将QComboBox控件提升为MyComboBox控件，并为其回调函数dropDown绑定具体的实现即可。
ui.comboBoxColName-&gt;dropDown = new std::function&lt;void()&gt;([&amp;]() { comboBoxDropDown(); }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5a9de86453092a83309bc7294084f19/" rel="bookmark">
			STM32程序(移植)中头文件的路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例:#include "./BSP/LCD/lcd.h"为什么有的头文件加了路径?
先看AI的回答:
在C和C++编程中，当我们在源文件中包含（或称为“引入”或“导入”）一个头文件时，编译器需要知道这个头文件的位置。通常，编译器会在几个预定义的目录（如系统目录、项目的include目录等）中查找这些头文件。但有时，这些头文件可能不在这些标准目录中，或者可能有多个同名文件，并且你想确保包含的是正确的一个。
在这种情况下，你可以通过提供头文件的完整路径来明确地告诉编译器去哪里找这个文件。这就是为什么你有时会在#include指令中看到路径的原因。
例如，#include "./BSP/LCD/lcd.h" 告诉编译器在当前目录（由.表示）下的BSP/LCD/子目录中查找lcd.h文件。
这种写法有几个要点：
相对路径：这里使用的是相对路径，其中./表示当前目录。你也可以使用其他相对路径，如../表示上一级目录。避免命名冲突：通过指定完整的路径，你可以确保即使系统目录或其他地方有同名的头文件，你的代码也会引用正确的一个。组织性：在某些项目中，头文件和其他源文件可能根据功能或模块被组织在不同的目录中。通过指定路径，可以清晰地表明头文件属于哪个部分或模块。移植性：使用绝对路径或特定于平台的相对路径可能会降低代码的移植性。因此，当可能时，最好使用相对于项目根目录或源代码文件的相对路径。 总之，通过在#include指令中包含路径，你可以更精确地控制编译器查找头文件的方式，并确保引入的是正确的文件。
下面是验证:
文件实际路径:
上面的四个文件每一个都包含各自的.c和.h文件
而我们在keil中添加头文件的路径是这样的:
在main.c中引用:
经编译正确,对应关系:
唯一区别的是#include "./LCD/lcd.h" .上图改成下图同样效果:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a551b19a774f95d085ab9cb254f6fcb/" rel="bookmark">
			真正的智能是计算与谋算（算计）的交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 计算代表了智能系统的技术能力，而"谋算"则代表了人类的智慧和决策能力。通过人类和计算系统之间的相互作用和合作，可以实现更高水平的智能和决策效率。这种交互可以促进人工智能系统更好地理解人类需求和价值观，并帮助人类更好地利用计算技术来解决复杂的问题。这种互补性的关系可能会成为未来智能发展的重要方向。
一个例子可以是智能推荐系统。这种系统使用计算技术来分析用户的行为和偏好，并根据这些信息提供个性化的推荐。但是，真正的智能不仅仅是依靠算法和数据分析。它还需要考虑到人类的主观感受、情感和价值观。在该例子中，计算与谋算的交互体现在以下几个方面：
数据分析：推荐系统通过计算技术来分析大量的用户数据，包括点击记录、购买记录、评分等。这些数据被用于建立用户模型和预测用户的兴趣和需求。
人类反馈：用户的反馈是非常重要的。用户可以对推荐结果进行评分、喜欢或不喜欢，甚至提供文字评论。这些反馈被用于优化推荐算法，并改进系统的准确性。
人工干预：除了纯粹的计算技术，智能推荐系统还经常融合人工干预。人类专家可以设定一些规则、限制条件，或者进行主观判断来调整和优化推荐策略。
个性化需求：真正的智能推荐系统不仅仅是根据用户的行为推荐相似的内容，还要考虑到用户的个性化需求和偏好。这需要更深入的理解用户的背景、兴趣爱好等信息，以便提供更加精准、有针对性的推荐。
通过计算与谋算的交互，智能推荐系统可以更好地理解和满足用户的需求，提供个性化的推荐体验。这个例子展示了计算和人类智慧的结合如何创造出真正智能的应用。
智能中事实与价值的问题是核心问题。事实一般是一一映射，而价值则是一多映射。
在逻辑和科学领域中，事实通常是指可以被证实或验证的陈述或观点。事实具有客观性，可以通过观察、实验或其他可靠的方法进行确认。因此，可以将事实视为一种"一一映射"，即对于特定的情况或现象，存在唯一的事实描述。
然而，价值是主观的、个体化的，与人类的信仰、文化、经验和情感等因素相关。不同的人可能会对同一件事情或情境产生不同的评价和看法。这种主观性使得价值具有多样性和多维度的特征，可以被视为一种"一多映射"，即对于相同的情况，不同的人可以有不同的价值观和评价。
例如，对于一个行为，一个人可能认为它是道德的，另一个人可能认为它是不道德的。这反映了价值观的多样性。同样，对于一个艺术品，一个人可能喜欢它，而另一个人可能不喜欢它。这也展示了价值观的多维度性。
因此，事实和价值之间存在一种区别。事实更加客观、可验证，而价值是主观、个体化的。理解这种区别有助于我们认识到不同人的观点和评价可能存在差异，并鼓励尊重和对话。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f48df6a97b0c2a10254aa742b243d1a/" rel="bookmark">
			使用Spring Boot整合MinIO实现断点续传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在现代Web应用程序中，文件上传是一个常见的需求。然而，当用户需要上传大型文件时，长时间的等待和不稳定的网络连接可能会成为问题。为了解决这些问题，我们可以利用MinIO对象存储服务与Spring Boot框架相结合，实现断点续传功能，从而提高文件上传速度和用户体验。
什么是MinIO？ MinIO是一个高性能的开源对象存储服务，与Amazon S3兼容。它可以在私有云或公共云环境中运行，并且具有水平扩展性和高可用性。
断点续传的优势 断点续传允许用户在上传大文件时中断上传过程，然后在之后的时间内从中断的地方继续上传，而不需要重新上传整个文件。这大大提高了用户体验，尤其是在上传大文件或网络连接不稳定的情况下。
添加依赖项 首先，在pom.xml文件中添加MinIO的依赖项：
&lt;dependency&gt; &lt;groupId&gt;io.minio&lt;/groupId&gt; &lt;artifactId&gt;minio&lt;/artifactId&gt; &lt;version&gt;7.1.6&lt;/version&gt; &lt;!-- 或者最新版本 --&gt; &lt;/dependency&gt; 配置MinIO客户端 在application.properties文件中配置MinIO客户端连接信息：
minio.endpoint=http://minio-server:9000 minio.accessKey=minio-access-key minio.secretKey=minio-secret-key 编写断点续传逻辑 创建一个Spring Boot的文件上传服务，并实现断点续传的逻辑。通过使用MinIO的putObject方法来实现：
import io.minio.MinioClient; import io.minio.PutObjectArgs; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import org.springframework.web.multipart.MultipartFile; import java.io.IOException; import java.io.InputStream; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; @Service public class FileUploadService { @Autowired private MinioClient minioClient; public void uploadFile(String bucketName, String fileName, MultipartFile file, long offset) throws IOException, NoSuchAlgorithmException, InvalidKeyException { try (InputStream inputStream = file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f48df6a97b0c2a10254aa742b243d1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7d88ce6d38d29fe1ff2c7ba8d411b2e/" rel="bookmark">
			解释一下什么是无服务器计算，以及它在云环境中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无服务器计算（Serverless Computing）是一种云计算服务模式，它允许开发者在无需关心服务器管理和运维的情况下，构建和运行应用程序。在无服务器计算中，服务商提供了完整的服务器基础设施，包括操作系统、运行时环境、应用程序、数据库等，开发者只需关注自己的核心业务逻辑，而无需管理这些基础设施。
无服务器计算适用于各种类型的应用程序，特别是那些需要快速迭代、按需伸缩、灵活部署的应用。它可以让开发者专注于解决实际问题，加快开发速度，降低运维成本。
在云环境中，无服务器计算可以大大简化应用程序的部署和管理。开发者只需关注自己的代码，而无需关心底层基础设施的配置和维护。无服务器计算服务商通常提供了自动化的部署、监控和扩缩容功能，使得应用程序能够根据实际负载进行自动调整，实现了高度的灵活性和可扩展性。
此外，无服务器计算还可以帮助开发者实现快速集成和敏捷开发。由于开发者无需关心底层基础设施，可以更快地集成新的功能和特性，实现快速迭代和交付。
总之，无服务器计算在云环境中可以大大简化应用程序的开发、部署和管理，提高效率和灵活性，降低成本和风险，是未来云计算发展的重要趋势之一。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/588573d423576a683862c32898eabbaa/" rel="bookmark">
			介绍一下云计算中的多租户技术，以及它在云环境中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多租户技术是一种在单一系统内同时为多个租户提供服务的技术，它可以让不同的租户在共享相同的资源（如硬件、数据库等）的情况下，仍可以保持各自的数据和应用程序的独立性。
在云计算中，多租户技术被广泛应用。通过多租户技术，多个客户可以在同一云平台上部署自己的应用程序，同时保证各自的数据和系统的隔离性。多租户技术不仅可以提高资源的利用率，降低成本，还可以提供灵活的服务，满足不同客户的需求。
多租户技术的主要应用包括：
数据隔离：多租户技术可以将不同租户的数据存储在独立的数据库中，保证数据的安全性和隐私性。服务隔离：多租户技术可以将不同的服务运行在独立的虚拟机或容器中，保证服务的稳定性和安全性。负载均衡：多租户技术可以根据不同的租户需求进行负载均衡，动态分配计算资源，提高资源的利用率。定制化服务：多租户技术可以根据不同的客户需求进行定制化服务，提供不同的服务和支持，满足客户的个性化需求。 总之，多租户技术在云计算中具有重要的作用，它可以提高资源的利用率，降低成本，提供灵活的服务，满足不同客户的需求。同时，多租户技术还可以保证数据和服务的安全性和隐私性，是云计算发展中不可或缺的技术之一。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83d25466017604d87608bf797cd7a84d/" rel="bookmark">
			idea 创建打包 android App
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、使用 idea 创建 android 工程 2、 配置构建 sdk 3、配置 gradle a、进入 gradle 官网，选择 install （默认是最新版本）
b、选择包管理安装，手动安装选择下面一个即可
c、安装 sdk 并通过 sdk 安装 gradle
安装 sdk：curl -s "https://get.sdkman.io" | bash
根据安装提示，执行 source 命令使 sdkman 生效
source "/Users/xxxx/.sdkman/bin/sdkman-init.sh"
然后执行 gradle 安装命令
安装成功
4、下载软件 Genymotion，并在IDEA安装一个Genymotion插件与之关联起来 a、下载安装 adb
模拟器下载地址：Genymotion Desktop download - Genymotion Android Emulator
配置自己下载安装的 android sdk 路径
b、安装插件
配置模拟器路径
5、配置完成执行命令打包构建 gradle assembleDebug 打包出现异常如下
Starting a Gradle Daemon (subsequent builds will be faster) FAILURE: Build failed with an exception.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83d25466017604d87608bf797cd7a84d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f1760064a7e4486b11739cbbc011bb8/" rel="bookmark">
			每天一个数据分析题（一百七十二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		聚类算法的主要应用场景是用户分群，在聚类算法中通过距离来衡量差异，以下哪个不是距离表示方式？（）。
A. 曼哈顿距离
B. 欧氏距离
C. 明可夫斯基距离
D. Pearson相关系数
题目来源于CDA模拟题库
点击此处获取答案
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/352d0073042ee2375f1bf679f783b405/" rel="bookmark">
			高并发下如何保证数据的一致性和可靠性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在高并发环境中，确保数据的一致性和可靠性是非常重要的。以下是一些常见的方法和策略：
事务管理：使用数据库事务来确保关键操作的原子性、一致性、隔离性和持久性。通过合理的事务设计和管理，对于涉及到多个数据操作的场景，可以保证数据的一致性。数据库锁机制：使用数据库提供的锁机制来保证对共享资源的独占访问。通过合理使用行锁、表锁、悲观锁或乐观锁等方式，控制并发访问数据库的行为，保证数据的一致性和正确性。幂等性设计：设计接口或操作具有幂等性，即对同一请求的多次执行只会产生一次结果影响。通过设计幂等性操作，可以避免因为同一请求的重复执行而导致的数据重复或不一致问题。高可用架构：构建高可用的系统架构，采用主备、集群、分布式等方式实现故障容错和数据备份。通过合理的架构设计和备份策略，当某个节点或服务发生故障时，可以快速切换到备用节点或服务，保证服务的可用性和数据的可靠性。队列和消息中间件：使用消息队列和消息中间件来解耦和异步处理高并发请求。将请求发送到队列中进行异步处理，保证数据操作的顺序和一致性。消息中间件还可以提供事务消息、可靠消息传递等特性，以确保数据的可靠传输和处理。分布式一致性算法：采用一致性哈希、分布式锁、Paxos、Raft等分布式一致性算法来处理分布式环境下的数据一致性问题。这些算法可以实现在分布式系统中的协调和一致性保证。异常处理和监控：及时捕获和处理异常，对于异常操作进行回滚或补偿操作，保证数据的一致性。同时，建立合适的监控系统，对系统和数据进行实时监测和报警，及时发现和处理潜在的问题。数据备份和恢复：定期进行数据备份，并建立完备的数据恢复机制。可以采用灾备方案、冷备、热备、增量备份等方式进行数据备份，确保在数据丢失或损坏情况下可以进行快速的恢复。 综上所述，维护数据的一致性和可靠性需要结合合适的技术手段和策略，在系统架构、数据管理和异常处理等方面进行综合考虑和实施。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f250a291d24d1fe0ce389c6321839f23/" rel="bookmark">
			每天一个数据分析题（一百七十一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		聚类算法的主要应用场景是用户分群，在聚类算法中通过距离来衡量差异，现有点A观测坐标（2，3），点B观测坐标（5，-1），则A与B曼哈顿距离是（）。
A. 4
B. 5
C. 6
D. 7
题目来源于CDA模拟题库
点击此处获取答案
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c4e8a4b50c1f595ae0277aef26a7a1a/" rel="bookmark">
			以ARM Cortex-A55/A53为例分析 L1/L2/L3 cache所支持的写策略（write-back/wirte-through,写通和写回）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在文章 ARM 中缓存维护策略：Allocate policy（读分配/写分配），Write policy（写通/写回）以及replacement policy基础知识中，笔者介绍了ARM cache的Write policy（写通/写回）。今天我们以ARM Cortex-A55和A53为例，具体分析各级cache（L1/L2/L3 ）对Write policy（写通/写回）的支持情况。
Cortex-A55/A53 一，Cortex-A53 处理器二，Cortex-A55 处理器 一，Cortex-A53 处理器 Cortex-A53 处理器支持 L1 cache（instruction cache 和 data cache）以及L2 cache （unified cache）。
Cortex-A53处理器将缓存同步逻辑简化成了如下的内存类型：
当内存类型为nner Write-Back 和Outer Write-Back 时，数据可以被缓存到 L1 Data cache 以及L2 cache中。当内存类型为Inner Write-Through时，Cortex-A53会将Inner Write-Through降级为Non-cacheable。当内存类型为Outer Write-Through 或者 Outer Non-cacheable时，也会被Cortex-A53降级为Non-cacheable，就是内存的inner属性为Write-Back。
上述规则如何理解呢？ 就是说Cortex-A53处理器的L1 data cache以及L2 cache都不支持Write-Through策略，当处理器访问内存类型为Write-Through的数据时，这些数据并不会经过L1 data cache和L2。
至于L1 instruction cache，对于指令数据，处理器只是读取，并不会写，所以cache 的写策略对指令缓存不起作用。
笔者在文章 关于cache maintenance 操作的四个寄存器（CTR，CLIDR，CSSELR，CCSIDR）解析中介绍过 CCSIDR寄存器，在访问CCSIDR之前，必须先在CSSELR寄存器中写入正确的值， 与CSSELR相对应，会根据CSSELR中的内容，显示指定cache的cache line大小、way的数量以及set的数量。
不仅如此，CCSIDR还提供了四个状态位：WT、WB、RA以及WA：
通过这四个状态位，我们可以知道当前cache所支持的读分配策略以及写策略。
从WT始终为0也可以知道：Cortex-A53的所有级别的cacahe都不支持 Write-Through策略。
二，Cortex-A55 处理器 Cortex-A53 处理器支持 L1 cache（instruction cache 和 data cache），L2 cache （unified cache）以及L3 cache。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c4e8a4b50c1f595ae0277aef26a7a1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fe427b74d8013d3cf3d77efb3faa2d4/" rel="bookmark">
			每天一个数据分析题（一百七十）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		聚类算法的主要应用场景是用户分群，在聚类算法中通过距离来衡量差异，现有点A观测坐标（2，3），点B观测坐标（5，-1），则A与B的欧氏距离是（）。
A. 4
B. 5
C. 6
D. 7
题目来源于CDA模拟题库
点击此处获取答案
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49762506c928e9fe97f650592b36d3ec/" rel="bookmark">
			CentOS 7 系统安装初始化之yum，linux系统使用起步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载如下python-[]及yum-[ ]，四个安装包，并用如下命令安装
http://mirrors.163.com/centos/7/os/x86_64/Packages/
rpm -ivh --force --nodeps python-iniparse*
rpm -ivh --force --nodeps yum-metadata-parse*
rpm -ivh --force --nodeps yum-3.4.3-168.el7.*
rpm -ivh --force --nodeps yum-plugin-fastestmirror-*
rpm -ivh --force --nodeps yum-cron-3.4.3*
二、配置阿里巴巴YUM源
1、备份本机yum配置文件：CentOS-Base.repo
cp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
2、下载阿里巴巴YUM源
wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
或者
curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo3
3、升级、清除、生成yum缓存（本地缓存必须的yum仓库源里的包资源，本机使用）
yum upgrade # 升级yum
yum clean all # 清除系统所有的yum缓存
yum makecache # 生成yum缓存
三、配置阿里巴巴epel-7.repo的YUM源
alibaba epel:
wget -O /etc/yum.repos.d/epel-7.repo http://mirrors.aliyun.com/repo/epel-7.repo
yum upgrade # update the yum
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49762506c928e9fe97f650592b36d3ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5a8ffd7d9cbeb29e736f5956ed79d96/" rel="bookmark">
			STM32F4XX - CAN设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		can协议部分
- 逻辑信号和电平信号
先贴上CAN信号在物理信号线上的查分信号表示形式
显性电平： 电压差范围为1.5-2.5v。 对应的逻辑电平是0
隐性电平： 其他 对应的逻辑电平是1
为什么显性电平对应的逻辑电平值为0，而隐性电平对应的逻辑电平是1？
因为在总线上，需要令显性位具有“覆盖”隐性位的能力。
在线与逻辑关系下，0才具有这种能力（1·1·1·……·1·1·0 = 0）。
所以才会将0定义为dominant，而将1定义为recessive。例如总线上10个节点发隐性位而1个节点发显性位的时候，总线上呈现出的是显性位。
电气连接图如下：（显性电平时逻辑电平为0，隐性电平时逻辑电平为1.具备线与的能力）
- 报文协议
CAN的协议报文由上面的逻辑电平组成；（如1111101111011101111101111）
灰色为显性，白色为隐性，浅蓝色表示可以是显性也可以是隐性。
起始帧（SOF） ： 起始的一个显性位
仲裁段（Identify SRR IDE RTR）：
canid填充位RTR 区分数据帧和远程帧 显性为数据帧，隐性为远程帧SRR 区分仲裁遥控帧的标准格式与扩展格式的优先级，比较标准格式的RTR位与扩展格式的SRR位，标准格式的RTR位恒为显性，扩展格式的SRR位恒为隐性。故前11位ID号相同时，标准数据帧优先级高于扩展数据帧。IDE 区分仲裁数据帧的标准格式与扩展格式的优先级，看IDE位，扩展格式的IDE位恒为隐性，标准格式的IDE位在控制段，恒为显性。故前11位ID号相同时，标准遥控帧优先级高于扩展遥控帧。
控制段（r1 r0 DLC）：r1和r0保留，DLC控制数据段的长度。
数据段（Data）: 数据段可包含0-8个字节的数据，从MSB（最高位）开始输出。遥控帧没有此段。
CRC段：由15个位的CRC序列和1个位的CRC界定符（用于分隔位）构成。CRC界定符恒为隐性。
ACK段： 由ACK槽（ACK Slot）和ACK界定符2个位构成。 发送端两个呈现隐性电平。 - 位时序设置
举一个具体的寄存器说明：
需要设置的值有四个：SJW TS2 TS1 BRP
计算方式参考：
SJW必须小于PBS1和PBS2的最小值。
这个寄存器中这些值使用的单位为tq。
brp ：波特率分频器
tq=(brp)*tpclk1
baud rate=Fpclk1/((tbs1+tbs2+1)*brp)
=42M/((7+6+1)*3)
=1Mbps
上面对CAN协议相关进行说明，后面针对具体STM32F4XX的例子进行分析说明。 u8 CAN1_Mode_Init(u8 tsjw,u8 tbs2,u8 tbs1,u16 brp,u8 mode) { GPIO_InitTypeDef GPIO_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; u16 i=0; if(tsjw==0||tbs2==0||tbs1==0||brp==0)return 1; tsjw-=1; //Subtract 1 before setting //先减去1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5a8ffd7d9cbeb29e736f5956ed79d96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bba4aa977edcb1c069c0d6b058afe1db/" rel="bookmark">
			前端开发环境模拟HTTPS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、创建HTTPS证书openssl报错？ 二、创建HTTPS服务器三、脚手架配置HTTPS@umi配置@vite配置 一、创建HTTPS证书 进入要建立 HTTPS 服务的目录
openssl genrsa -out key.pem 1024 openssl req -new -key key.pem -out csr.pem openssl x509 -req -in csr.pem -signkey key.pem -out cert.pem openssl报错？ Windows11 安装openssl
winget search openssl winget install OpenSSL 配置环境变量
# 变量名 OPENSSL_HOME # 变量值 C:\Program Files\OpenSSL-Win64\bin # PATH %OPENSSL_HOME% 二、创建HTTPS服务器 http-server -S ./ 三、脚手架配置HTTPS @umi配置 import {defineConfig} from "umi"; export default defineConfig({ https: { cert: './key/cert.pem', key: './key/key.pem', http2: true }, define: { IS_DEV: true } }) @vite配置 import * as fs from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bba4aa977edcb1c069c0d6b058afe1db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac61d99b00c00352ca07972c4916c466/" rel="bookmark">
			某电力铁塔安全监测预警系统案例分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目概述
电力铁塔是承载电力供应的重要设施，它的安全性需要得到可靠的保障。但是铁塔一般安装在户外，分布广泛，且有很多安装在偏远地区，容易受到自然、人力的影响和破环。因此需要使用辅助的方法实时监控铁塔的安全状态，对于可能出现的问题实现提前预警，起到保护铁塔的作用。
基于铁塔监测场景定制的轻量化GNSS接收机，同步可接入气象仪和北斗短报文终端，支持一机多天线，以满足塔顶、塔基、塔身不同部位对监测频次和精度的需求，以应对气象灾害、地质灾害等引发的塔基变形、杆塔倾斜等隐患。
近年来，因自然灾害和人为破坏等因素导致输电线路杆塔斜倒塌引起的电力事故呈上升趋势。针对铁塔监控的特点推出GNSS安全监测，用来监测铁塔倾斜状态，保障电能的稳定安全。由前端传感器将杆塔实际情况等数据收集后通过无线网络实时的传送到中心监控分析。监控中心可以对地基滑动、沉降变形以及天气原因导致铁塔倾斜、折断甚至整体倒塌的情况进行在线监测和预警，如出现异常会及时通知负责人现场处理，保障电力铁塔安全运行。
核心设备
GNSS接收机
GNSS接收是一款基于地质边坡监测场景需求深度研制的集成多测项（三维位移、倾角、加速度）的低成本、低功耗、高集成、边缘解算的普适型GNSS监测专用接收机，功耗低于1.5瓦，可根据变形趋势自动调整监测模式，以满足变形体不同变形阶段对监测频次和精度的需求，可应用于地灾监测、矿山监测、水库高边坡监测、公路边坡监测、危楼监测等领域。
倾角计
倾角计适用于长期安装在混凝土大坝、面板坝、土石坝等水工建筑物，及工民用建筑、道路、桥梁、隧道、路基、土建基坑等测量其倾斜变化量，方便实现测量数据的自动化采集。倾角计为全不锈钢结构，坚固耐用，附有调节和固定支架方便安装。倾角计采用的是耐冲击型伺服传感器，可靠性好，稳定速度快，安装附件少，组装方便，输出信号为RS485数字量，直接显示工程值(位移或角度)。
创科云铁塔健康安全监测管理平台
云平台采用B/S架构，可对数据进行智能化管理，包含数据存储与分析、自动形成报表、结构物状态分析与报警、现场设备管理等多项功能，并针对结构物及结构物群构建安全模型，进行智能诊断和结构健康分析，为用户提供稳定、精准、专业的结构物健康监测服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7442d4f843d730276fadbc666347de0e/" rel="bookmark">
			经销商文件分发 怎样兼顾安全和效率？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经销商文件分发是指将文件、资料、产品信息等从制造商或经销商传递给经销商的过程。这一过程对于确保经销商能够获取最新的产品信息、销售策略、市场活动资料等至关重要。
想要管理众多经销商合作伙伴之间的文件传输并提高效率，可以采取以下措施：
1、建立标准化流程：制定清晰的文件接收、验证、存储、分发和更新流程，确保所有相关人员都了解并遵循这些流程。
2、实施版本控制：对所有文件实施严格的版本控制，确保所有相关方使用的是最新的、正确的版本。
3、权限管理：根据员工的角色和职责分配文件访问权限，确保敏感信息的保密性。
4、审批流程：对于关键文件，建立审批流程，确保文件内容符合企业标准和法规要求。
5、自动化工具：利用自动化工具，如邮件群发、文件分发软件等，简化文件分发过程，提高效率。
6、安全传输：使用加密技术和安全协议（如SSL/TLS、SFTP）保护文件在传输过程中的安全。
7、反馈和沟通：建立有效的沟通机制，以便在文件出现问题或需要更新时，能够及时通知经销商。
8、审计和记录：记录文件分发的详细情况，包括分发时间、接收者、文件内容等，以便于审计和追溯。
9、培训经销商：对经销商进行培训，确保他们了解企业的文件管理要求和标准。
当然，以上这些方式都比较零散，很难统一进行管控，所以可以考虑选择专业的文件分发管理平台，如飞驰云联的《Ftrans B2B企业间文件安全交换系统》，它提供了一体化的协同解决方案，与企业现有IT系统无缝对接，支持数据发布、数据共享，并具备安全管控、权限管控等功能。
1、数据安全外发
通过文件交换系统，向指定的经销商商、研发合作单位发布设计数据，确保数据内容准确，分发高效，全程可监控、可追溯。
2、外部数据收缴
通过数据收缴的形式，允许外部伙伴向企业提交最新数据，使企业实时掌握外部动态，并与PLM系统中的数据保持同步。
3、传输审批审核
可自定义人工审批流程，支持多级、多人审批，会签、或签、转签；同时支持与OA、BPM审批系统集成，并自动邮件通知，保证文件外发安全合规、审批灵活便捷。
4、多工作空间协作
为各部门设定不同的协作空间，各空间独立。根据不同要求设定多样化的协作模式，满足企业对协作范围、安全控制等多样性需求。
5、安全性保障
可对外发文件进行加密封装，通过口令、机器码等方式对接收方进行安全认证，并限制接收方的只读、打印、水印等权限，有效防止二次泄密。
6、日志审计追溯
可追溯可追溯完整保留所有数据交换记录，可导出报表，以备统计分析。所有协作交换原始数据均自动归档，满足企业合规审计要求。
7、自动化流程
高效高效简化企业原有手工操作步骤，将涉及多部门、多人员的流程自动化实现，大大提高流转效率。
8、高性能传输保障
具备高性能文件传输协议，内置断点续传、文件校验、错误重传等机制，支持TB级超大文件、百万级海量文件的可靠传输，极大提高异地数据交换传输时效性，加快企业间协同节奏。
通过《Ftrans B2B企业间文件安全交换系统》，企业可以有效地管理经销商文件分发，确保供应链的顺畅运作，提高生产效率和产品质量。同时，该系统的高自动化和集成能力可以帮助企业简化手工操作步骤，提高流转效率，加快企业间协同节奏。
关于飞驰云联
飞驰云联是中国领先的数据安全传输解决方案提供商，长期专注于安全可控、性能卓越的数据传输技术和解决方案，公司产品和方案覆盖了跨网跨区域的数据安全交换、供应链数据安全传输、数据传输过程的防泄漏、FTP的增强和国产化替代、文件传输自动化和传输集成等各种数据传输场景。飞驰云联主要服务于集成电路半导体、先进制造、高科技、金融、政府机构等行业的中大型客户，现有客户超过500家，其中500强和上市企业150余家，覆盖终端用户超过40万，每年通过飞驰云联平台进行数据传输和保护的文件量达到4.4亿个。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/390fe0ce4adda5d5928757be23fed9e0/" rel="bookmark">
			Linux--串口屏显示控制实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 实验简介 实验目标：在Linux下通过串口屏显示并控制功能模块的状态和参数
操作系统：Ubuntu 20.04.6 LTS
串口屏：迪文串口屏 DMG48270C043_03W
二、实现代码-- C语言 代码功能就是在Linux下使用串口和TCP，重点在于如何处理好串口和网口接收的数据。 通过本实验可以基本掌握如何在Linux下使用串口和TCP。网上很多教程都会介绍Liunx下如何实现串口和TCP这两种通信方式，很少有结合实际应用进行介绍的文章，本文就将结合一个实际应用例子进行分析记录，也是对自己学习这些东西的一个简单总结记录。
2.1 通信协议 这里的通信协议不是说解释串口或是TCP这样的通信协议，本文指的是在传输数据过程自己定义的数据帧格式，不同的数据需要设置功能模块的不同功能通信协议的有助于我们管理不同的控制信号。发送数据时按以下格式设置好数据后再通过到其他模块。
主控模块&lt;-----&gt;功能模块 网口通信TCP
字段指令头指令码数据长度数据长度(字节)114N值0xAA不同指令N具体数据 主控模块&lt;-----&gt;串口屏 串口通信
2.2 串口通信 Linux的串口表现为设备文件。实验使用的串口屏是USB扩展的，实验前需要安装CH341驱动串口设备文件命名为dev/ttyCH341USB*，不同的硬件平台对串口设备文件的命名有所区别。
2.2.1 初始化串口 在Linux下，不管是设备、文档、可执行程序，对于内核来说都是读写文件，会涉及到open、read、write的操作，对于文件操作就有了“阻塞”和“非阻塞”的概念。不同模式对文件的处理方式会有不同，使用的场景也不一样。
“阻塞”的定义
对于 read，当串口的接收缓冲区没有数据的时候，read函数会阻塞在那里，不返回，程序也无法下一步执行，一直到串口的接收缓冲区中有数据可读时，read读到了想要长度的字节数后才会返回，返回值为读到的字节数。
对于write，当串口发送缓冲区满时，或者剩下的空间小鱼将要写入的字节数时，则write阻塞，一直到串口的发送缓冲区中剩下的空间大于等于将要写入的字节数，再执行写操作，返回写入的字节数。
“非阻塞”的定义
对于read，当串口的接收缓冲区中没有数据时，read操作立即返回，返回值为0.
对于write，当串口发送缓冲区满，或者剩下的空间小鱼将要写入的字节数时，write仍然会被执行，写入当前串口发送缓冲区剩下的空间字节数，然后返回写入的字节数。
serial init
serial = serial_new(); if (serial_open(serial,"/dev/ttyCH341USB1",115200) &lt;0) //打开并设置设备文件 { serial_free(serial); printf("serial open failed!\n"); } else { printf("serial opened! \n"); } serial_open 函数
网上很多都是直接用的open函数，实验使用的函数同样基于open函数通过该函数设置好串口，默认使用的阻塞模式。
int serial_open(serial_t *serial, const char *path, uint32_t baudrate) { return serial_open_advanced(serial, path, baudrate, 8, PARITY_NONE, 1, false, false);//参数设置 } int serial_open_advanced(serial_t *serial, const char *path, uint32_t baudrate, unsigned int databits, serial_parity_t parity, unsigned int stopbits, bool xonxoff, bool rtscts) { struct termios termios_settings; /* Validate args */ if (databits !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/390fe0ce4adda5d5928757be23fed9e0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/2/">«</a>
	<span class="pagination__item pagination__item--current">3/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/4/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>