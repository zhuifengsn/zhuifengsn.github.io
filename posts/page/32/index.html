<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0671cbd172fc7bab3f4f5f74d913676a/" rel="bookmark">
			刘铁猛C#教程笔记——操作符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#语言中的操作符 表中位于同一行的操作符优先级相同，从上到下优先级依次减弱；
操作符的用法举例 成员访问运算符——“.”：用于访问类中的成员或者访问位于某个名空间中的类，如： using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace course { class Program { static void Main(string[] args) { Example e; e = new Example(); double result = e.GetCone(3D, 4D); //访问类中的函数成员 Console.WriteLine(result); //引用命名空间中的某个类 System.Windows.Forms.Form f = new System.Windows.Forms.Form(); //创建窗体类对象 f.ShowDialog(); //用于显示窗体 } } class Example { public double GetCircleArea(double r) { return Math.PI * r * r; } public double GetCylinder(double r,double h) { return GetCircleArea(r) * h; } public double GetCone(double r,double h) { return GetCylinder(r, h) / 3; } } } System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0671cbd172fc7bab3f4f5f74d913676a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/383a58687c3e2350a3862d6c2307020d/" rel="bookmark">
			使用echarts绘画时域频域图的JS代码学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		function postChart(index){ // 基于准备好的dom，初始化echarts实例 console.log(index) var myChart = echarts.init(document.getElementById('main'),null,{ width:1500, height:300 }); var data1 = document.getElementById("dataline1").value; console.log("aaaaa") // console.log(data1) // console.log(Object.prototype.toString.call(data1)) // var data2 = data1.substring(1,data1.length-1); // console.log(data2.length) var data2 = data1.split(",") // String 数组 console.log(data2.length) var data4 = new Array() // for(var i=0;i&lt;data3.length;i++){ // data4.push(parseInt(data3[i])) // } for(var i = (index-1)*2048;i&lt;index*2048;i++){ data4.push(parseInt(data2[i])) } // console.log(data4) var data5 = new Array() for (var i =0;i&lt;2048;i++){ data5.push(i) } // // 指定图表的配置项和数据 var yname = '幅值' var a = '2' var b = 'm/'+'s'+a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/383a58687c3e2350a3862d6c2307020d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/559c46f95875978c69b0fb908b9cc771/" rel="bookmark">
			解决Linux network启动失败问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看NetworkManager状态是否开启，开启则关闭
systemctl status NetworkManager #查看状态 systemctl stop NetworkManager #关闭 systemctl enable NetworkManager #关闭自启动 NetworkManager 与 network 有可能发生冲突，关掉重新启动即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b3ba0a0703bfc8057c3f09f1d38a172/" rel="bookmark">
			数据结构与算法课程设计 线性表实现多项式的相加运算（Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、课程设计目的和要求
目的：深入理解数据结构的基本理论，掌握数据存储结构的设计方法，掌握基于数据结构的各种操作的实现方法，训练对基础知识和基本方法的综合运用能力，增强对算法的理解能力，提高软件设计能力。在实践中培养独立分析问题和解决问题的作风和能力。
要求：熟练运用Java语言、基本数据结构和算法的基础知识，独立编制一个具有中等难度的、解决实际应用问题的应用程序。通过题意分析、选择数据结构、算法设计、编制程序、调试程序、软件测试、结果分析、撰写课程设计报告等环节完成软件设计的全过程，不断地完善程序以提高程序的性能。
二、题意说明及分析
一元多项式的相加运算，采用多项式排序单链表。
多项式排序单链表类PolySinglyList&lt;T&gt;增加以下成员方法。
public class PolySinglyList&lt;T extends Comparable&lt;? super T&gt; &amp; Addible&lt;? super T&gt;&gt;
extends SortedSinglyList&lt;T&gt;
{
// C(x)=A(x)＋B(x)，返回this（A）和list相加（B）的多项式（C），不改变this和list。
// 算法不调用深拷贝和addAll(list)，将A和B相加的元素复制插入结点到C多项式排序单链表
PolySinglyList&lt;T&gt; union(PolySinglyList&lt;T&gt; list)
}
Polynomial多项式类使用PolyDoublyList&lt;T&gt;对象作为成员变量，实现以下方法。
public boolean equals(Object obj) //比较两个多项式是否相等，覆盖
三、算法设计与分析
用两个按指数升序的单链表遍历节点，依次比较。首先我的思路是要先创建空的一元多项式排序单链表，然后利用项数组进行赋值。在这个一元多项式的相加中，用p、q来遍历两条单链表，项按指数升序进行排序，然后当两项相加时，规则是，如果项的指数相同，则系数相加减，若系数和为零，则删除这一项，多余的项插入到链表中。
四、源程序
1.创建接口
package Finalwork;
public interface Addible&lt;T&gt;
{
public void add(T t);
public boolean removable();
}
2.创建节点Node
package Finalwork;
public class Node&lt;T&gt; {
public T data;
public Node&lt;T&gt; next;
public Node(T data,Node&lt;T&gt; next){
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b3ba0a0703bfc8057c3f09f1d38a172/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf607c58f6febf58ab4cfcf7be4610d9/" rel="bookmark">
			【坑】这样用C指针可不行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有人问了我一个C语言中使用指针时遇到的问题。下面是一个简化后的代码示例。
#include &lt;stdio.h&gt; int fix_var = 90; void update_ptr(int *a) { int* temp = a; a = &amp;fix_var; printf("adress of temp: %d \n", temp); printf("adress of a(in function): %d \n", a); } int main() { int *a = NULL; update_ptr(a); printf("adress of a: %d \n", a); return 0; } 编译运行的结果为：
adress of temp: 0 adress of a(in function): 4206608 adress of a: 0 他的疑问是，为什么我修改了函数内的指针a，结果在函数外面指针a却并没有变化。
这个其实是没有理解清楚变量的作用域。因为指针实际上也是一个变量。但我们常常把指针传入函数内部以便可以在函数内修改函数外面的某个变量值。从而被混淆地认为函数内也能改变传入的指针值。
给函数传入指针以修改函数外部变量的具体用法如下代码所示：
#include &lt;stdio.h&gt; // 交换两个整数的值 void swap(int *a, int *b) { int temp = *a; *a = *b; *b = temp; } int main() { int num1 = 10; int num2 = 20; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf607c58f6febf58ab4cfcf7be4610d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/794a5b5577bbc7b71f20dec0cf0be160/" rel="bookmark">
			机试算法学习题（第二章 枚举和模拟问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSDN设置字体样式及颜色（附颜色表） 地址
2.1枚举 abc问题 OJ地址
描述
设a、b、c均是0到9之间的数字，abc、bcc是两个三位数，且有：abc+bcc=532。求满足条件的所有a、b、c的值。
输入描述：
题目没有任何输入。
输出描述：
请输出所有满足题目条件的a、b、c的值。 a、b、c之间用空格隔开。 每个输出占一行。
思路：利用for循环遍历整个三位数
#include&lt;cstdio&gt; using namespace std; int main() { int a, b, c; for (a = 0; a &lt;=9; a++){ for (b = 0; b &lt;=9; b++) { for (c = 0; c &lt;=9; c++) { if (100 * a + 10 * b + c + 100 * b + 10 * c + c == 532) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/794a5b5577bbc7b71f20dec0cf0be160/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/598f5552af58bc8e8d57da93ed735ac8/" rel="bookmark">
			Database System Concepts(Seventh Edition) learning note
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Introduction Part one relation languages Introduction to the relational modelIntroduction to SQLIntermediate SQLAdvanced SQL 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e2dd2545bf695a69bcd36fb19f63e7d/" rel="bookmark">
			SpringCloud概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 什么是微服务？ ​ 微服务是一种面向服务的架构(SOA)风格，其中，应用程序被构建为多个不同的小型服务的集合而不是单个应用程序。与单个程序不同的是，微服务让你可以同时运行多个独立的应用程序，而这些独立的应用程序可以使用不同的编码或编程语言来创建。庞大而又复杂的应用程序可以由多个可自行执行的简单而又独立的程序所组成。这些较小的程序组合在一起，可以提供庞大的单程序所具备的所有功能。
什么是分布式服务？ ​ 分布式结构就是将一个完整的系统，按照业务功能，拆分成一个个独立的子系统，在分布式结构中，每个子系统就被称为“服务”。这些子系统能够独立运行在web容器中，它们之间通过RPC方式通信。
分布式服务与微服务的区别 1）微服务的各个服务都是独立的组件存在。
2）独立的组件形式，方便模块改造优化，或集群部署部署用于应对高并发。
3）系统之间的耦合度降低，非常容易扩展。
4）复用性强。
介绍 ​ Spring Cloud是一个基于Spring Boot实现的云应用开发工具，也是微服务系统架构的一站式解决方案。它为基于JVM的云应用开发中的服务发现注册 、配置中心 、消息总线 、负载均衡 、断路器 、数据监控 等操作提供了一种简单的开发方式。通俗地讲，Spring Cloud 就是用于构建微服务开发和治理的框架集合。
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-HMAx7fmZ-1684303939304)(/Users/zhaoyanhong/Library/Application Support/typora-user-images/image-20220906153940245.png)]
​ 微服务的特征：
​ 1）微服务单元按照数据结构特性或者领域来划分
​ 2）微服务通过HTTP来通讯，数据格式为json或者xml。
​ 3）微服务的数据库相对独立
​ 4）微服务的自动化部署。可使用jenkins、Docker、Kubernetes
​ 5）服务集中管理。Eureka、Zookeeper、Consul、Nacos、Etcd（服务注册发现组件）
​ 6）分布式架构（集群部署）。
​ 7）熔断机制/防止雪崩。Hystrix
​ 8）链路跟踪。Sleuth 、Skywalking
​ 9）完整的安全机制。用户验证、权限验证、资源保护等
​ 10）完整的实时日志。
Zookeeper/Eureka/nacos：服务注册与发现 ​ **服务注册中心本质上是为了解耦服务提供者和服务消费者。**对于任何一个微服务，原则上都应存在或者支持多个提供者，这是由微服务的分布式属性决定的。更进一步，为了支持弹性扩缩容特性，一个微服务的提供者的数量和分布往往是动态变化的，也是无法预先确定的。因此，原本在单体应用阶段常用的静态LB机制就不再适用了，需要引入额外的组件来管理微服务提供者的注册与发现，而这个组件就是服务注册中心。
服务注册需要具备的能力：
服务提供者把自己的协议地址注册到注册中心服务消费者需要从注册中心上去查询服务提供者的地址（根据服务名称）注册中心需要感知到服务提供者的上下线的变化服务消费者需要动态感知到注册中心服务地址的变化 Zookeeper ​ Zookeeper 是分布式应用程序协调服务, 用于维护配置信息、命名、提供分布式同步和提供组服务。客户端注册是服务自身要负责注册与注销的工作。**当服务启动后向注册中心注册自身，当服务下线时注销自己，期间还需要和注册中心保持心跳。**心跳不一定要客户端来做，也可以由注册中心负责（这个过程叫探活）。这种方式的缺点是注册工作与服务耦合在一起，不同语言都要实现一套注册逻辑。
​ Zookeeper数据模型的结构类似文件系统。
Zookeeper提供了什么服务 1）文件系统 ​ 每个子目录项如 NameService 都被称作为znode，和文件系统一样，我们能够自由的增加、删除znode，在一个znode下增加、删除子znode，唯一的不同在于znode是可以存储数据的。
有四种类型的znode：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e2dd2545bf695a69bcd36fb19f63e7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc84bd620c90242f608d620a2fb793b1/" rel="bookmark">
			HCIP第一次作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.需求：
2.步骤：
（1）子网划分：
（2）先把二层vlan做好（先弄交换机，再弄路由器）
LSW1的代码:
LSW2的代码:
（3）给每个设备配置ip地址：
R1的代码： R2的代码：
R3的代码以及DHCP动态分配地址：
​编辑
R4的代码：
​编辑 R5的代码：
ISP的代码：
（4）静态路由（不许使用其他动态）以及缺省
R1的静态路由：
R2的静态路由：
R3的静态路由：
R4的静态路由：
R5的静态路由：
（5）做ACL列表
在R5做好ACL列表，做好之后ping一下100.1.1.2
1.需求： 1.全网可达
2.拓扑中所需地址全部基于192.168.0.0/24划分所得
3.静态路由（不许使用其他动态）
4.R2环回需要汇总
2.步骤： （1）子网划分： 192.168.0.0 /24
3个网段——子网划分
192.168.0.00 000000 26
192.168.0.0/26——骨干链路
192.168.0.00 0000 00 /30(一共16个）
192.168.0.0 30
192.168.0.4 30
192.168.0.8 30
192.168.0.12 30
192.168.0.16 30
192.168.0.20 30
192.168.0.24 30
......
192.168.0.60 30
192.168.0.64/26——R2的环回
192.168.0.01 00 0000 28
192.168.0.64/28
192.168.0.80/28
192.168.0.96/28
192.168.0.112/28——预留
192.168.0.128/26——R4下网络
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc84bd620c90242f608d620a2fb793b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d18e86650e558522123cf0a63a50c08e/" rel="bookmark">
			C语言——链表（带头节点与不带头节点）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅简介：与大家一起加油，希望文章能够帮助各位！！！！ 💬保持学习、保持热爱、认真分享、一起进步！！！ 文章目录 前言
一、动态数组的弊端
二、单链表
1.链表的优势
2.什么是链表 3.如何定义一个链表
3.1底层代码逻辑 3.2链表元素的插入、删除操作 4.如何让我们在读入数据时降低时间开销 总结
前言 上篇文章写了顺序表（数组），虽然我们现在可以创造出来动态增加的数组，但是动态数组还是有一系列的问题：
一、动态数组的弊端 缺点一：我们的数组需要连续的整片的空间，而我们计算机中没有这么大的空间。
如下图：图中我们可以清晰的看到当第三次申请空间的时候，计算机明明有这么多空间但是却申请失败，因为数组需要连续不间断的空间来存放数据。
第二个缺点就是当我们扩容的时候，我们需要遍历之前的数据进行拷贝，浪费时间。当数据规模不大的时候，可以忽略。但是当数据达到一定程度后就会出现拷贝整个数组可能需要较长的时间，对性能会产生一定的影响。
二、单链表 1.链表的优势 动态性：链表是一种动态数据结构，可以在运行时灵活地插入、删除和修改元素，而不需要预先指定容量。这意味着链表可以根据需要动态地增长或缩小，提供更好的灵活性。
内存管理：链表的节点可以在内存中非连续地分布，每个节点可以存储任意数量的数据。这种内存分配方式可以更有效地利用内存空间，并且可以避免由于连续内存分配导致的碎片化问题。
从下面这张图也可以看出，链表和数组刚好互补。
2.什么是链表 链表是一种常见的线性数据结构，它由一系列的节点组成，每个节点包含两部分：数据和指向下一个节点的指针。每个节点可以在内存中不连续地分布，通过指针将它们串联在一起。下面呢，进入正题！！！ 3.如何定义一个链表 首先呢，我们先看这张图！这是带头节点，带头节点的链表是在链表头部添加了一个额外的节点，该节点不存储任何数据，只是作为链表的起始位置。带头节点的链表中，头节点的下一个节点才是实际存储数据的第一个节点。
不带头节点的主要区别就是在于第一个的问题，不带头结点首先定义一个同类型的指针，指向第一个存放元素的地址值，直接从存储数据的第一个节点开始。这里呢，因为不带头节点的代码更麻烦一点，所以我们主要以不带头节点的链表进行讲解！
3.1底层代码逻辑 首先，定义一个结构体（链表）
typedef struct _abc { struct _abc* next;//指向下一个 int value; } link; 现在，我们拥有了一个个的节点，该怎样去把他们去串在一起呢？
看完下面的代码，如果你学过数据结构的话不难看出这段代码的时间复杂度O(),怎样去降低这个时间的耗费呢？自己可以先停下来思考一下，后面会提到呦！！！
link* head = NULL; //定义头指针 int num; while (true){ printf("请输入链表中的值："); link* l = (link*)malloc(sizeof(link)); scanf("%d", &amp;num); if (num == -1) //如果num==-1结束循环 break; l-&gt;value = num; l-&gt;next = NULL; link* k = head; if (k) {//如果k=NULL进入 while (k-&gt;next) { k = k-&gt;next; } k-&gt;next = l; //循环结束，链表走到了最后一个位置，我们需要把新增加的元素加上去 } else { head = l;//如果head==NULL的话（第一次读入数据），则让head指向l的地址 } } 遍历链表！！！ 千万要记得malloc得到的空间一定要还回去，每次循环就是把指向地址的指针后移，读出数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d18e86650e558522123cf0a63a50c08e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a17ac570b1a44e7b83adb3d631dc2703/" rel="bookmark">
			OpenWrt安装使用教程（x86/64架构）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是OpenWrt? 官网简介：OpenWrt项目是一个针对嵌入式设备的Linux操作系统。OpenWrt不是一个单一且不可更改的固件，而是提供了具有软件包管理功能的完全可写的文件系统。这使您可以从供应商提供的应用范围和配置中解脱出来，并且让您通过使用适配任何应用的软件包来定制设备。对于开发人员来说，OpenWrt是一个无需围绕它构建完整固件就能开发应用程序的框架; 对于普通用户来说，这意味着拥有了完全定制的能力，能以意想不到的方式使用该设备。
OpenWrt被应用在哪些方面？ OpenWrt通常用于网络连接方面，其软件包系统是十分全面的，可以做很多的事情。
OpenWrt的安装 下载OpenWrt固件：
方法1 官方固件（不推荐，因为官方的固件内容太少了）：访问OpenWrt官方网站（https://openwrt.org/start）并导航到“firmware-selector（https://firmware-selector.openwrt.org/）”页面。
在“Model”部分中，输入"Generic x86/64"。根据你的硬件配置选择正确的版本。
点击下载链接，将固件保存到你的计算机上。
方法2 第三方编译固件（推荐，可玩性高）：访问https://supes.top/，选择Generic x86/64,自定义编译固件，自行选择相关信息。
下载写盘工具：
在https://m0n0.ch/wall/physdiskwrite.php上下载physdiskwrite 0.5.3
准备安装环境：
将一个U盘插入计算机，并确保其中没有重要的数据。
格式化U盘。
制作安装介质：
使用一个可用的工具（如微PE）。
打开微PE，并选择USB驱动器写入。
将下载的OpenWrt固件解压复制到USB驱动器。
开始安装：
将启动盘插入软路由，引导启动微PE。
打开存放固件和IMG写盘工具的目录。
注意：安装系统前请勿格式化分区！请务必保存好你的重要数据！
在此目录运行CMD，输入以下代码：
physdiskwrite.exe的路径 -u OpenWrt的镜像的路径 输入磁盘所在位置的数字，不要选择U盘。（例如“1”）回车。
输入“y”。回车。
等待安装完成，之后拔掉U盘关机。
至此安装操作就结束了。
OpenWrt的初始设置 开机，引导至OpenWrt所在磁盘。
看到”Please press enter to activite this console“时回车。
输入”passwd“设置密码。
输入代码：
vi etc/config/network 将wan口后改为eth0,lan口后改为eth1.(注，一般软路由网口从左到右为eth0到eth1，以此类推。)
将访问地址改为你想要的地址。
将软路由与电脑用网线相连。
在电脑上访问刚才设置的地址，用户名默认root，密码为你设置的。
在网络-接口-wan中设置DHCP客户端，因为是软路由。
在网络-接口-lan中设置，你有几个网口就设置几个。
在网络-无线中设置无线信息，信道设置占用低的（可在系统-信道分析中查看），2.4G和5G根据使用情况设置。然后设置无线用户名和密码、加密方式等。
至此，本教程结束。尽情享用吧！
注：原创文章，请认准作者为yinfan,yinfan nd studio。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf200043159c6c9de35b4348d93eb783/" rel="bookmark">
			SpringBoot添加过滤器Filter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 拦截器和过滤器 先说一下，过滤器和拦截器的区别和联系。
1.1 相同点 首先过滤器和拦截器都能实现请求的筛选（过滤或者拦截），然后根据自己的业务需求，添加自己的逻辑，保证请求往后走的时候数据能满足自己的需求。同时呢，他们又都能终止请求流（过滤器只要不在过滤链中往后传request就形；拦截器返回false）。
1.2 不同点 1.2.1 实现原理不同 过滤器和拦截器 底层实现方式大不相同，过滤器 是基于函数回调的，拦截器 则是基于Java的反射机制（动态代理）实现的
1.2.2 使用范围不同 过滤器 实现的是 javax.servlet.Filter 接口，而这个接口是在Servlet规范中定义的，也就是说过滤器Filter 的使用要依赖于Servlet的，生存与Tomcat等服务器容器中，导致它只能在web程序中使用
拦截器(Interceptor) 它是一个Spring组件，并由Spring容器管理，并不依赖Tomcat等容器，是可以单独使用的。不仅能应用在web程序中，也可以用于Application、Swing等程序中。
1.2.3 触发时机不同 由于过滤器和拦截器基于不同的容器，所以他们的触发时机和请求中经过容器的顺序有关，Filter作用于Servlet，Interceptor作用于Springmvc。
1.2.4 处理范围不同 过滤器处理逻辑都在doFilter方法中，拦截器区分pre、post和after，划分粒度更细了，使用起来更灵活
1.2.5 拦截器可以注入业务 拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。
2. Springboot添加拦截器 项目当中使用过滤器还是拦截器，根据需求来定，一般用哪种都可以，我是要处理requestbody 中的数据（处理特殊字符，加密等）。由于数据还要往下继续传，所以选用filter。
过滤器添加有2种方法：
2.1 通过@WebFilter注解添加 1.写过滤器类，并实现Filter接口2.添加@WebFilter注解，属性filterName设置过滤器名称，urlPatterns匹配要过滤的url import java.io.IOException; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.annotation.WebFilter; @WebFilter(filterName = "testFilter", urlPatterns = "/*") public class TestFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf200043159c6c9de35b4348d93eb783/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/653e2105744f93827ba067004c882f24/" rel="bookmark">
			掌握这18个Pandas知识点，快速入门数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一份完整的Pandas初学者指南。
微信搜索关注《Python学研大本营》，加入读者群，分享更多精彩
简介 根据最新的估计，每天有3.2877亿兆字节的数据产生，预计在2025年将会有大约181兆字节的数据产生。因此，现在是我们利用如此大量的数据来拥有敏锐的洞察力并预测现在和未来结果的时候了。
在你的Python开发者或数据科学的旅程中，可能已经多次遇到了pandas这个术语，但仍然需要弄清楚它的作用。以及数据和pandas的关系。因此，首先简单介绍一下pandas。
Pandas是一个建立在NumPy和Matplotlib基础上的Python库，主要设计用于处理数据。它用于分析、清理、探索和操作数据。
它是由Wes McKinney在2008年开发的，用于数据分析目的。
为什么我们需要Pandas？ 一般来说，我们通过智能手机、物联网设备、调查和其他各种来源收到的数据充满了相关和不相关的信息，其中包含了重复的、缺失的和不可操作的数值，使得我们很难直接得出结论。正因如此，Pandas让我们能够从数据中产生有意义和有价值的见解。
从以表格形式排列我们的数据、进行统计分析到生成图表，一切都可以通过pandas实现，使数据分析师和科学家可以在一个库下轻松完成所有任务。
简而言之，pandas就像一个过滤器，我们可以使用它来提纯我们的原始数据，以产生有价值的见解。
如何使用Pandas？ 在学习使用pandas的工具之前，必须了解数据在pandas中是如何存储和排列的。Pandas包含两种类型的数据结构：
Series
Dataframe
Series：它是一个一维数组，能够容纳任何数据类型的数据。
names = ['Alex', 'Bob', 'John'] df = pd.Series(names, index=[1, 2, 3]) print(df) Dataframe：Dataframe是一种由行和列组成的二维数据结构，就像一个表格。它是pandas中最流行的数据结构。
df = pd.read_csv("E:\emp_report.csv") print(df) 我们导入了一个CSV（Comma Separated Values），这是一个使用逗号分隔数值的分隔文本文件。在pandas中，可以使用read_csv()命令导入一个CSV文件，然后传递文件位置。
1. head() head方法默认返回dataframe的前五行。
print(df.head()) 如上可以看到主数据框中有六行，但是使用head命令，它输出了数据框的前五行。
甚至可以用head(n)指定想要的行数；如果我们传递head(12)，它将输出数据框的前12行。
2. tail() tail方法与head类似，但它不是输出最上面的行，而是默认返回数据框的最后五行。
print(df.tail()) 我们甚至可以使用tail(n)指定我们想要的底层行数；如果我们传递tail(10)，它将输出数据框的最后10行。
3. info() info()方法给出了数据框的完整描述，比如列的数量，每一列的数据类型，数据框的内存使用情况等。
print(df.info()) 4. describe() describe()方法给出了数据框的完整统计分析，如每一列的最大值、最小值、百分位数、总非空值和标准差。
print(df.describe()) 5. shape Pandas中的shape属性为我们提供了关于数据框形状的信息，即数据框中的行和列的数量。
print(df.shape) 在上图中六指的是行的数量，五指的是列的数量。
6. values 在一个二维数组中返回数据框的所有值。
print(df.values) 7. columns columns属性返回数据框中每一列的标签或名称。
print(df.columns) 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/653e2105744f93827ba067004c882f24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a814b83740b9da29fbffe4c89b35178a/" rel="bookmark">
			Springboot整合Shiro安全框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、创建springboot工程 2、引入依赖 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.aaa&lt;/groupId&gt; &lt;artifactId&gt;springboot-shiro&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot-shiro&lt;/name&gt; &lt;description&gt;springboot-shiro&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;spring-boot.version&gt;2.3.12.RELEASE&lt;/spring-boot.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--shiro和redis整合的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.crazycake&lt;/groupId&gt; &lt;artifactId&gt;shiro-redis&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--shrio和thymeleaf集成的扩展依赖，为了能在页面上使用xsln:shrio的标签 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--shiro和springboot整合的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a814b83740b9da29fbffe4c89b35178a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/447fdb4f5f2bfc59d0bf51b328f4f105/" rel="bookmark">
			this version of the Java Runtime only recognizes class file versions up to 55.0 新as 打开Java项目异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选择运行JDK版本
选择11版本JDK即可解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a202ae9cf8da3ee2b17cc5e58f1306e9/" rel="bookmark">
			Sql Server数据库sql语句去除所有空格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		空格包含一般空格和特殊空格。
1、一般空格
前后的空格，使用LTRIM()和RTRIM()即可，例如：LTRIM(RTRIM(name))
中间的空格，使用REPLACE()函数替换，例如：REPLACE(name,' ','')
2、特殊空格
通过ASCII()函数，找出空格的ASCII值，然后用REPLACE()函数+CHAR()函数来替换。
①通过查询的方式，将特殊空格之外的值替换成空字符串，这样就剩下特殊空格，通过ASCII()函数查到特殊空格的ASCII值。
例：select ASCII(REPLACE(name,' ','')） from 表名
②将该值替换成空字符串，例如通过ASCII()函数，找到空格的ASCII值为10，则使用REPLACE(name,char(10),'')来替换。
注意：ASCII值根据实际情况查询获得。
例：update 表名 set name=REPLACE(name,CHAR(10),'')
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f2bd73722209f0da9ea3f1af4f2040d/" rel="bookmark">
			如何使用ChatGPT的API(七)一个客户服务助手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本篇文章中，我们将综合前面文章中所有知识，创建一个端到端的客户服务助理示例。我们将经历以下步骤：
首先，我们将通过Moderation API检查输入是否违规。
其次，如果没有，我们将提取产品列表。
第三，如果找到产品信息，我们将尝试查找它们。
第四，我们用模型回答用户的问题。
第五，我们将通过Moderation API对答案进行审核。如果回答没有违规，我们可以把它返回给用户。
第六，对模型的回答进行质量评估
示例代码：
def process_user_message(user_input, all_messages, debug=True): delimiter = "```" # Step 1: Check input to see if it flags the Moderation API or is a prompt injection response = openai.Moderation.create(input=user_input) moderation_output = response["results"][0] if moderation_output["flagged"]: print("Step 1: Input flagged by Moderation API.") return "Sorry, we cannot process this request." if debug: print("Step 1: Input passed moderation check.") category_and_product_response = utils.find_category_and_product_only(user_input, utils.get_products_and_category()) #print(print(category_and_product_response) # Step 2: Extract the list of products category_and_product_list = utils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f2bd73722209f0da9ea3f1af4f2040d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26d81c38917cbaa88eb13ca748a2c192/" rel="bookmark">
			如何使用ChatGPT的API(六)输出检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章介绍如何检测模型的输出。
之前我们介绍过如何通过Moderation接口检测用户的输入，以避免让模型接受到违规的或者不合适的输入。现在我们同样也可以使用Moderation接口来检测模型输出的内容。
检测输出内容是否有害 final_response_to_customer = f""" The SmartX ProPhone has a 6.1-inch display, 128GB storage, \ 12MP dual camera, and 5G. The FotoSnap DSLR Camera \ has a 24.2MP sensor, 1080p video, 3-inch LCD, and \ interchangeable lenses. We have a variety of TVs, including \ the CineView 4K TV with a 55-inch display, 4K resolution, \ HDR, and smart TV features. We also have the SoundMax \ Home Theater system with 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26d81c38917cbaa88eb13ca748a2c192/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28b0bfa41bf3d26b2d03f6a8bbff5c66/" rel="bookmark">
			Ubuntu18.04 安装 OpenCV4.3 及环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu18.04 安装 OpenCV4.3 及环境配置_opencv4.3.0安装包_john_bh的博客-CSDN博客
[ 0%] Building CXX object 3rdparty/protobuf/CMakeFiles/libprotobuf.dir/src/google/protobuf/generated_message_util.cc.o [ 0%] Building NVCC (Device) object modules/core/CMakeFiles/cuda_compile_1.dir/src/cuda/cuda_compile_1_generated_gpu_mat.cu.o nvcc fatal : Unsupported gpu architecture 'compute_86' CMake Error at cuda_compile_1_generated_gpu_mat.cu.o.RELEASE.cmake:222 (message): Error generating /home/user/data1t/3rdparty/opencv-4.3.0/build/modules/core/CMakeFiles/cuda_compile_1.dir/src/cuda/./cuda_compile_1_generated_gpu_mat.cu.o make[2]: *** [modules/core/CMakeFiles/opencv_core.dir/build.make:77: modules/core/CMakeFiles/cuda_compile_1.dir/src/cuda/cuda_compile_1_generated_gpu_mat.cu.o] Error 1 make[1]: *** [CMakeFiles/Makefile2:3854: modules/core/CMakeFiles/opencv_core.dir/all] Error 2 make[1]: *** Waiting for unfinished jobs.... cmake命令行：
cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=../../opencv4.3_cuda10.2_nv3060_install/ -D WITH_CUDA=ON -D WITH_CUBLAS=ON -D CUDA_ARCH_BIN='8.6' -D OPENCV_EXTRA_MODULES_PATH=../opencv_contrib-4.3.0/modules -D OPENCV_GENERATE_PKGCONFIG=YES .. 最后，广告一下个人微信公众号“AI技术评论”，不会经常打扰你，但是会不定期分享一些新技术和行业资讯等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04d573217939a282f28a8bc79dd1271d/" rel="bookmark">
			已知 $1\leq x \leq 2$，求 $\sqrt{x^2-2x&#43;17}&#43;\sqrt{-x^2-4x&#43;29}$ 的最小值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 已知 1 ≤ x ≤ 2 1\leq x \leq 2 1≤x≤2，求 x 2 − 2 x + 17 + − x 2 − 4 x + 29 \sqrt{x^2-2x+17}+\sqrt{-x^2-4x+29} x2−2x+17 ​+−x2−4x+29 ​ 的最小值
解析 我们注意到两个根式中的自变量都是 x x x，所以我们可以考虑将它们的平方和进行最小化。
设 y = x 2 − 2 x + 17 + − x 2 − 4 x + 29 y = \sqrt{x^2-2x+17}+\sqrt{-x^2-4x+29} y=x2−2x+17 ​+−x2−4x+29 ​
y 2 = ( x 2 − 2 x + 17 ) + 2 ( x 2 − 2 x + 17 ) ( − x 2 − 4 x + 29 ) + ( − x 2 − 4 x + 29 ) y^2 = (x^2-2x+17) + 2\sqrt{(x^2-2x+17)(-x^2-4x+29)} + (-x^2-4x+29) y2=(x2−2x+17)+2(x2−2x+17)(−x2−4x+29) ​+(−x2−4x+29)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04d573217939a282f28a8bc79dd1271d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/31/">«</a>
	<span class="pagination__item pagination__item--current">32/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/33/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>