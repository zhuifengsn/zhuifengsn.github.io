<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82716df592a29cad9abc2c0e62142931/" rel="bookmark">
			Ubuntu开机桌面黑屏只有鼠标问题解决办法（搜狗输入法导致）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu开机桌面黑屏只有鼠标问题解决办法（搜狗输入法导致） 问题描述 笔者在安装完搜狗输入法重启电脑后，电脑开机黑屏，只有鼠标的光标可以移动。笔者一开始以为是系统问题，网上查阅资料才发现有大量的网友都因为搜狗输入法而导致电脑黑屏，如果读者近期安装了搜狗输入法，可以尝试采取以下解决方案来解决黑屏问题：卸载搜狗输入法。
解决办法 步骤1：首先使用快捷键 ： Ctrl + Alt + F3 (F3 ~ F6均可)来打开终端，Ctrl + Alt + F2快捷键则是打开桌面。如果可以打开其他终端，也说明了当前系统没有问题，只是桌面程序启动存在问题。
步骤2：打开终端后，输入用户名和密码进行登陆。
步骤3：依次输入以下指令将搜狗输入法和fcitx完全卸载：
sudo apt-get purge sogoupinyin sudo apt-get purge fcitx sudo apt-get autoremove 步骤4：重启电脑
reboot 至此，由于搜狗输入法导致的电脑黑屏问题即可解决。
如果上述操作仍无法解决问题，可以尝试重装桌面程序试试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad0002e5fcc073afd75a5c1a3dc8a8b3/" rel="bookmark">
			设计模式（一）--单例模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单例模式，保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例结构图如下：
单例模式应用的场景，包括单线程和多线程两种模式。多线程模式下要考虑资源争用的问题，保证在多线程下创建唯一实例。
1. 单线程模式 单线程模式比较简单，直接上代码（C#）
class Singleton { private static Singleton instance; //私有化构造函数 private Singleton() { } //公共的实例创建方法，利用lock锁定syncRoot 的方法控制单例创建 public static Singleton GetInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 2. 多线程模式 2.1 懒汉式单例模式 通过lock锁实现，相比饿汉式，懒汉式在第一次引用时才会进行实例化，具体代码如下（C#）：
class Singleton { private static Singleton instance; //运行时创建实例对象 private static readonly object syncRoot = new object(); //私有化构造函数 private Singleton() { } //公共的实例创建方法，利用lock锁定syncRoot 的方法控制单例创建 public static Singleton GetInstance() { if (instance == null) { lock (syncRoot) { if (instance == null) { instance = new Singleton(); } } } return instance; } } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad0002e5fcc073afd75a5c1a3dc8a8b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c21dd5629befe6bb6a4a46072a6bab3/" rel="bookmark">
			UML-认识六种箭头，轻松读懂UML图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进行系统设计时，UML是一种常见的面向对象结构设计方式，里面的各种箭头表示经常会把人弄糊涂，如果不能正确理解，实现阶段就会出大问题，失之毫厘，谬以千里，下面带着大家认识下6种常用箭头。
1. 泛化 概念：泛化是一种一般与特殊、一般与具体之间关系的描述，具体描述建立在一般描述的基础之上，并对其进行了扩展，一般用来表示继承的关系。
表示方法：用实线空心三角箭头表示，如下图。
2. 实现 概念：实现是一种类与接口的关系，表示类是接口所有特征和行为的实现，在程序中一般通过类实现接口来描述
表示方法：空心三角形箭头的虚线，实现类指向接口，如下：
3. 依赖 概念：是一种使用的关系，即一个类的实现需要另一个类的协助。如方法参数需要传入另一个类的对象，就表示依赖这个类。
表示方法：虚线箭头，类A指向类B，即A依赖B，如下图：
4.关联 概念：表示类与类之间的联接,它使一个类知道另一个类的属性和方法，这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的。程序中一个类的全局变量引用了另一个类，就表示关联了这个类，关联关系分为单项关联和双向关联。在Java中，单向关联表现为：类A当中使用了类B，其中B作为类A的成员变量。双向关联表现为：类A当中使用了类B作为成员变量；同时类B中也使用了类A作为成员变量。
表示方法：实线箭头，类A指向类B，即A关联B，如下图，消费者种关联了若干产品：
5.聚合 概念：聚合关联关系的一种特例，是强的关联关系。聚合是“整体-个体”之间的关系，即has-a的关系，整体与个体可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。程序中聚合和关联关系是一致的，只能从语义级别来区分。
表示方法：尾部为空心菱形的实线箭头（也可以没箭头），车轮和大灯都属于汽车，如下图：
6.组合 概念：组合也是关联关系的一种特例。组合是一种“整体-部分”的关系，即contains-a的关系，比聚合更强。部分与整体的生命周期一致，整体的生命周期结束也就意味着部分的生命周期结束，组合关系不能共享。程序中组合和关联关系是一致的，只能从语义级别来区分。
表示方法：尾部为实心菱形的实现箭头（也可以没箭头）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88210183ad9205d4b2dfc37094cfe4d7/" rel="bookmark">
			myfile.cpp:15:6 warning: ‘val‘ may be used uninitialized in this function [-Wmaybe-uninitialized]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本身这个问题很简单，提示也说的很清楚，val没有初始化。
但是，奇怪的地方在于去查看myfile.cpp:15并没有 val 这个变量，myfile.cpp:15 指向了一个函数myfunc()的开头，这个函数里面压根并没有定义val这个变量。甚至，整个myfile.cpp里面也没有定义这个变量。
解决方法：
经过查找资料发现，myfile.cpp在编译的时候是加了 -O3优化选项的，经过测试发现除去把-O3删掉，问题就会消失，O3优化具体做了什么可以自行google。但问题是我就是需要-O3，那怎么办？通过一行行的注释myfile.cpp:myfunc() 进一步定位问题发现，问题出在了某行的一个函数调用上，该函数是一个inline的函数，该inline函数其中的一个形参变量命名是 “val”。考虑到inline函数在执行时就是拷贝到调用处，再考虑到使用了O3, 所以估计是O3在做优化的时候，弄出了一个uninitialized的‘val’吧。所以解决方法就很简单了，把那个inline的函数改成非inline的就可以了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bf2bffd5fdac41bba1569c7bf56f930/" rel="bookmark">
			SQL UNIQUE 约束
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL UNIQUE 约束 UNIQUE 约束唯一标识数据库表中的每条记录。
UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。
PRIMARY KEY 约束拥有自动定义的 UNIQUE 约束。
请注意，每个表可以有多个UNIQUE 约束，但是每个表只能有一个PRIMARY KEY 约束。
CREATE TABLE 时的SQL UNIQUE 约束 下面的SQL 在"Persons111"表创建时在"P_id"列上创建 UNIQUE 约束：
CREATE TABLE Persons111 ( p_id int NOT NULL UNIQUE, lastname varchar(255) NOT NULL, fristname varchar(255), address varchar(255), city varchar(255), ) 如需命名UNIQUE 约束，并定义多个列的UNIQUE 约束，请使用下面的SQL 语法：
CREATE TABLE Persons11111 ( p_id int NOT NULL, lastname varchar(255) NOT NULL, fristname varchar(255), address varchar(255), city varchar(255), CONSTRAINT uc_Personid UNIQUE (p_id,lastname) ) ALTER TABLE 时的SQL UNIQUE 约束 当表已被创建时，需在"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bf2bffd5fdac41bba1569c7bf56f930/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d35b864dfe21c5c0a0c6a9394001313/" rel="bookmark">
			比较两个文本差异，直接显示两个文本的相同点与不同点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要：我们经常需要与文本打交道，那么有时候我们编辑了一个新的文本内容，但是我们想知道我们究竟改了哪些内容。这里给大家介绍一种能够比较两个文本内容的差异点的方法，让我们一眼就看出来相同点与不同点。
当我们修改了一个文本内容，但是我们最后想看一下我们究竟修改了哪些内容、新增了哪些内容和删除了哪些内容。因此我们需要有一个小工具，能够查看两个文本之间的差异点。方便我们直接看到新增了哪些内容、删除了哪些内容和修改了哪些内容。
这里给大家介绍一种非常简单的方法去查看两个文本之前的差异点、相同点与不同点。
首先打开「我的ABC软件工具箱」，进入「文本差异」对比的功能中：
打开这个功能后，我们可以看到左边与右边分别有两个文本框。我们只需要在左边填写一个文本，在右边再填写一个文本即可实时地看到两个文本的相同点和不同点差异。
当我们的两个文本都是相同的时候，界面显示是这样的：
当我们的两个文本中间有新增的地方的时候，界面显示是这样的：
当我们有两个文本中间有删除的时候，界面显示是这样的：
当我们两个文本中间有修改的时候，界面显示是这样的：
怎么样？是不是很直观地显示了两个文本的差异点，很方便就可以看到两个文本的相同点和不同点，这样我们可以一眼就看出两个文本是否完全一样了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab16ff107394650d11541310173ad99d/" rel="bookmark">
			SpringBoot测试类@Autowired无法获取Bean和Component
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 一、问题描述二、解决方法 一、问题描述 将 @Component 注解的类 JwtUtils 在测试类中注入报空指针错误：
@Autowired private JwtUtils jwtUtils; 二、解决方法 测试类需要加上注解 @SpringBootTest，代码如下：
@SpringBootTest class JwtUtilsTest { @Autowired private JwtUtils jwtUtils; @Test public void test() { // 生成token User user = new User(); user.setId(1L); user.setUsername("admin"); user.setPassword("123456"); String token = jwtUtils.generateToken(user); System.out.println("token:" + token); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37a8d01387bff1ec4e1299d1f94953e4/" rel="bookmark">
			队列(Queue)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、队列的概念 队列是一个先进先出的数据结构。
联想一下链表，在单链表中，只能对表尾进行插入，对表头进行结点的删除，这样强限制性的链表，就是所说的队列。也就是说，队列是限定在表的一端进行插入，表的另一端进行删除的数据结构。
如图去买票排队，每一列队伍都有一个队尾和队首，先来的先买票，后来的后买，买好的就从队首出去，新来买票的就需要从队尾继续排队。
通常，称进数据的一端为队尾，出数据的一端为队首，数据元素进队列的过程称为入队，出队列的过程称为出队。
队列是一个线性的数据结构，并且这个数据结构只允许在一端进行插入，另一端进行删除，禁止直接访问除这两端以外的一切数据，且队列是一个先进先出的数据结构。
如上图，队列就像一个两端相通的水管，只允许一端插入，另一端取出，取出的球就不在水管里面了，而先放入管中的球就会先从管中拿出。
队列存储结构的实现有以下两种方式：
①顺序队列：在顺序表的基础上实现的队列结构。
②链队列：在链表的基础上实现的队列结构。
两者的区别仅是顺序表和链表的区别，即在实际的物理空间中，数据集中存储的队列是顺序队列，分散存储的队列是链队列。
二、队列的结点设计与初始化 队列只有链式的设计方法，其本身分为多种队列，如顺序队列和循环队列，还有衍生的优先队列等等，以顺序队列的设计为例。
首先是队列的结点设计，可以设计出两个结构体，一个结构体 Node 表示结点，其中包含有 data 域和 next 指针，如图：
其中 data 表示数据，其可以是简单的类型，也可以是复杂的结构体。next 指针表示，下一个的指针，其指向下一个结点，通过 next 指针将各个结点链接。
然后再添加一个结构体，其包括了两个分别永远指向队列的队尾和队首的指针，看到这里是不是觉得和栈很像？
主要的操作只对这两个指针进行操作，如图所示：
其结构体设计的代码可以表示为：
//结点定义 typedef struct node{ int data; struct node *next; } node; //队列定义，队首指针和队尾指针 typedef struct queue{ node *front; //头指针 node *rear; //尾指针 } queue; 对于初始化需要初始化两个类型，一个是初始化结点，一个是初始化队列。代码中的描述，初始化队列有些不同，当初始化队列的时候，需要将头尾两个结点指向的内容统统置为空，表示是一个空队列，两个创建的函数代码可以表示为：
//初始化结点 node *init_node{ node *n=(node*)malloc(sizeof(node)); if(n==){ //建立失败，退出 exit(0); } return n; } //初始化队列 queue *init_queue { queue *q=(queue*)malloc(sizeof(queue)); if(q==) { //建立失败，退出 exit(0); } //头尾结点均赋值 q-&gt;front=; q-&gt;rear=; return q; } 三、判断队列是否为空 这是一个既简单也很要紧的操作，判断队列是否为空直接就是判断队列头指针是否是空值即可。其代码可以表示为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37a8d01387bff1ec4e1299d1f94953e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/359d9da354f2a244a2213b4a5395b79b/" rel="bookmark">
			Android studio jni开启debug的正确姿势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、修改APP Run/Debug Configrations Debug type
Debug type修改为Dual(Java+Native)
如图：
2、Open Model Setting-&gt;Build Variants-&gt;Jni Debuggable 改为true
如图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46cbb148601e280f94fc0e834c95eb42/" rel="bookmark">
			Linux：Centos8 环境搭建指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录： 导入yum 换源JDK1.8（Oracle）MySQL 8.x卸载安装与万能重置密码远程连接 导入 最近总爱整些 花里胡哨 的东西，导致我的 Linux 系统有很多莫名其妙的东西，所以经常回去重新安装，说到这儿，那么问题就来了，对于不爱用 快照 的我来说，每次都要配置环境，一点儿不对，就又会有什么奇奇怪怪的错，所以现在将我在使用过程中，对于 Linux 环境配置的一些记录。
环境：
Centos 8VMware Workstation Pro 16.xXshell 7Xftp 7 yum 换源 使用命令进入：
cd /etc/yum.repos.d 为了以后有需要，会恢复原有的文件，所以将 Centos8 自带的文件先保存起来：
新建一个文件夹用来保存：
mkdir yum.repos.old 将所有文件都移动到该文件夹下：
mv *.repo yum.repos.old/ 接着，使用 wget 下载新的源：
wget http://mirrors.aliyun.com/repo/Centos-8.repo(已停止使用) wget http://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo (最新) 若需要自行选择版本，可打开http://mirrors.aliyun.com/repo进行选择
接着清除以前的 yum 缓存：
yum clean all 最后创建新的缓存：
# 创建缓存 yum makecache # 更新 yum update JDK1.8（Oracle） 首先要去 Oracle 的官网上去下载 Linux 版的 JDK:
下载页面：https://www.oracle.com/cn/java/technologies/javase/javase-jdk8-downloads.html
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46cbb148601e280f94fc0e834c95eb42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa4dcea5aacf06dedb76139c667483ed/" rel="bookmark">
			C语言结构体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.为何需要结构体，什么是结构体 ？
结构体的概念：
2.结构体的声明
结构体变量定义和初始化
结构体成员的访问
.操作符
-&gt;操作符
结构体传参
1.为何需要结构体，什么是结构体 ？ 对于日期，分数，数字，名字这些简单的对象我们可以用整形，浮点型，字符进行描述。而对于一个人（例如：学生）这种复杂对象时，我们难以仅仅用整形，浮点型进行描述，往往我们需要多个数据类型整合起来描述。
例如：学生，我们用姓名，年龄，性别，成绩描述
姓名——&gt;字符数组
年龄——&gt;整形
性别——&gt;字符数组
成绩——&gt;浮点数
这时候，我们就要引出
结构体的概念： 结构是一些值的集合，这些值成为成员变量。结构的每个成员可以是不同类型的变量。
2.结构体的声明 在main函数前面进行声明
注：变量列表里也可以不创建变量
依然以学生为例，
struct stu { char name[20];//名字 int age;//年龄 char sex[10];//性别 float score;//成绩 };//不创建变量 struct stu { char name[20];//名字 int age;//年龄 char sex[10];//性别 float score;//成绩 }s1,s2;//创建变量 注：s1,s2是通过struct stu类型创建的变量，s1,s2是全局变量
注：结尾有分号
struct stu { char name[20];//名字 int age;//年龄 char sex[10];//性别 float score;//成绩 }s1,s2; //s1,s2为全局变量 int main() { struct stu s3; //注意:struct stu是结构体类型，此处struct不能省略 struct stu s4; //此处s3,s4为局部变量 return 0; } 注：s3，s4是局部变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa4dcea5aacf06dedb76139c667483ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02d64f9170e892f030fea5581ae25a41/" rel="bookmark">
			C语言———打印100—200之间的素数并统计素数个数的三种写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		素数：除了1和它本身以外再无其他因子
1、试除法：判断i是否时素数，则用2—&gt;i-1个数去整除i，若可以整除，则说明i不是素数
int main() { int i = 0; //用i记录100-200之间的数 int count = 0; //用count统计100-200之间的素数个数 for (i = 100; i &lt;= 200; i++) { int j = 0; //用j记录比i小的2—&gt;i-1个数字 for (j = 2; j &lt;i; j++) //j&lt;i则为i-1个数字 { if (i % j == 0) //如果i整数j,则说明i含有因子 { break;//跳出for循环 } } //执行if有两种情况：1、break跳出。 //2、for循环不满足规则就j&lt;i了，跳出，此时i为素数。 if (j == i) // j==i时说明将2—&gt;i-1个数字均试完了，均不整除，则i为素数 { count++; printf("%d ", i); } } printf("\ncount=%d\n",count); return 0; } 2、试除法的改进（增加算法的效率）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02d64f9170e892f030fea5581ae25a41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cef414c8ad875949a3afb720816f4b19/" rel="bookmark">
			python：cgi.escape错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python出现cgi.escape错误 在
import cgi 下面加上
import html 修改
cgi.escape() 为
html.escape() 完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bee09277c50ca1117346b7cd227a6e52/" rel="bookmark">
			SQL聚合函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、知识点
聚合函数对组执行计算并返回每个组唯一的值。GROUP BY子句通常与聚合函数一起用于统计数据。GROUP BY子句将行排列成组，聚合函数返回每个组的统计量。
常用的聚合函数有：COUNT()，SUM()，AVG()，MIN()，MAX()。
COUNT()，其作用主要是返回每个组的行数,也会返回有NULL值的列，可用于数字和字符列。
SUM()，主要用于返回表达式中所有的总和，忽略NULL值，仅用于数字列。
AVG()，返回表达式所有的平均值，仅用于数字列并且自动忽略NULL值。
MIN()，返回表达式中的最小值，忽略NULL值，可用于数字、字符和日期时间列。
MAX()，返回表达式中的最大值，忽略NULL值，可用于数字、字符和日期时间列。
二、案例分享
1.用count()返回课程数量。并查询课程进行对比。
Select*from course Select count(cno) from course 2.查询学号为s001同学的总成绩。并查询s001同学的成绩方便对比。
查询总成绩需要使用sum()。
Select*from sc where sno=‘s001’ Select sum(score) from sc where sno=‘s001’ 3.查询学号为s001的同学的平均成绩。
查询平均成绩，我们需要使用avg()。
Select avg(score) from sc Where sno=‘s001’ 4.查询学号为‘s001’最高成绩和最低成绩
查询最大用max()，最小用min()
Select min(score),max(score) From sc Where sno=‘s001’ 三、难点分享
使用聚合函数的难点在于精确、准确的使用方法，使用方法前还需要考虑该方法支持的数据类型。比如sum()，此方法仅用于数字列。查询最重要的还是查询的条件，需要什么查什么。此时就要使用where子句，像上面一样，使用where过滤数据，满足查询条件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0e259f10ff970b5fbaed11aa015e114/" rel="bookmark">
			4.JavaScript基础——原型、原型链（有待补充）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 原型 我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype， 这个属性对应着一个对象，这个对象就是所谓的原型对象如果函数作为普通函数调用，prototype没有任何作用当以构造函数调用时：
- 它所创建的对象中都会有一个隐含的属性( proto )指向该构造函数的原型对象
- 我们可以通过 proto 来访问该属性 举例1原型对象就相当于 一个公共区域， 所有同一类的实例都可以访问这个原型对象
我们可以将对象中共有的内容， 统一设置到原型对象中
语法： 构造函数.prototype.属性/方法 = 值 举例2 自身对象和原型对象 举例2 当我们访问对象中的一个属性值或方法时，它会现在（自身对象）中寻找，如果有则 使用； 如果没有，则去（原型对象）中寻找，如果找到则使用以后我们创建构造函数时，可以将这些共有的属性和方法，统一添加到原型对象中。这样不用分别为每一个对象添加，也不会影响全局作用域，就可以使每个对象都具有这些属性和方法。 代码举例 &lt;script&gt; // 举例1 function Person(){ } var per = new Person(); console.log(per.__proto__); // 举例2 function Person(){ } // 向Person 原型对象中添加一个属性name Person.prototype.name = "张三" // 向Person 原型对象中添加一个方法 Person.prototype.sayHello = function (){ alert('hello'); } var per = new Person(); per.name = "ls"; // 自身对象 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0e259f10ff970b5fbaed11aa015e114/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1c4edb40614db4b42235d0ebeb4f9e6/" rel="bookmark">
			【Linux 内核】编译 Linux 内核 ① ( 下载指定版本的 Linux 内核源码 | Linux 内核版本号含义 | 主版本号 | 次版本号 | 小版本号 | 稳定版本 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、下载 Linux 内核1、下载最新版本 Linux 内核2、下载指定版本 Linux 内核 二、Linux 内核版本号含义 一、下载 Linux 内核 1、下载最新版本 Linux 内核 进入 Linux 内核官网 https://www.kernel.org/ 下载 Linux 内核 , 点击右侧 黄色的 " Latest Release " 按钮 , 下载最新的 Linux 内核发布版本 ;
最新版的 Linux 内核有 122MB ;
2、下载指定版本 Linux 内核 目标 : 下载 5.6.14 5.6.14 5.6.14 版本的 Linux 内核 ;
主版本号 : 5 5 5此版本号 : 6 6 6小版本号 ( 修改次数 ) : 14 14 14 在 Linux 内核 官网 https://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1c4edb40614db4b42235d0ebeb4f9e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8764e1842a3654e4398abf7853fb3d3/" rel="bookmark">
			细说Redis-p1（2022.03.13）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis在我们工作中可以说用的非常多。大多用来会话存放、消息队列（支付）、活动排行榜或计数等。但我们其实很多时候是只管去用，却也没有对它进行更深层次的探索。这段时间正好也重温了一下Redis，写下来的话感觉能够让自己更深入的去理解Redis。
目录 1.Redis是什么2.为什么Redis这么快2.1 基于内存实现2.2 采用单线程2.3 多路IO复用 2.Redis的持久化方式2.1 RDB（快照）2.2 AOF（append-only file）2.3 混合持久化 3.Redis主从架构4.Redis哨兵高可用5.高可用集群模式5.1 集群的好处5.2 Redis集群原理分析5.2.1 槽位定位算法5.2.2 Redis集群选举原理分析 5.3 网络抖动5.4 集群是否完整才能对外提供服务5.5 Redis集群为什么至少需要三个master节点，并且推荐节点数为奇数？5.6 哨兵leader选举流程 1.Redis是什么 Redis是什么，这应该是一个老生常谈的问题了。几乎用过的人都知道，或者说面试的时候也会问到。Redis就是一个NoSQL数据库。
其实想知道Redis是什么，我们可以通过官方文档来看看
Redis官网解释了Redis是什么，简单来说，它就是一款内存高速缓存数据库。画重点，基于内存，支持多种类型数据结构。
2.为什么Redis这么快 我想这个问题，大家在面试的时候应该都遇到过。
2.1 基于内存实现 数据库的工作模式按存储方式可分为：硬盘数据库和内存数据库。Redis 将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度极快。
2.2 采用单线程 Redis进行命令的读写都是基于单线程，避免了不必的上下文切换。
为什么Redis要使用单线程（注意，我没有说Redis完全是单线程的）？
在此之前，我想问一个问题。就是在I/O操作都时候，例如磁盘I/O，网络I/O等！为什么一般是在I/O操作都时候，要用多线程呢？
因为I/O操作一般可以分为两个阶段:即等待I/O准备就绪和真正操作I/O资源。
以磁盘操作为例，磁盘的结构如下：
“在磁盘上数据是分磁道、分簇存储的，而数据往往并不是连续排列在同一磁道上，所以磁头在读取数据时往往需要在磁道之间反复移动，因此这里就有一个寻道耗时！另外，盘面旋转将请求数据所在扇区移至读写头下方也是需要时间，这里还存在一个旋转耗时！”
那么，在这一时间段（即"I/O等待"）内，线程是在“阻塞”着等待磁盘，此时操作系统可以将那个空闲的CPU核心用于服务其他线程。因此在I/O操作的情况下，使用多线程，效率会更高！
回到刚刚的问题，我想现在大家应该知道答案了吧！
Redis读写数据基于内存，是不涉及到IO操作的。如果不涉及到的话，那么单线程执行肯定要比多线程更快。
官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。
2.3 多路IO复用 用一个线程接收客户的连接请求。
多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。
**这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。**采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量
2.Redis的持久化方式 2.1 RDB（快照） 将内存数据快照保存到名字为dump.rdb的二进制文件中（保存的是二进制压缩文件）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8764e1842a3654e4398abf7853fb3d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1c6cb4005636bd5618b8e1fde039697/" rel="bookmark">
			Large-Scale Order Dispatch in On-Demand Ride-Hailing Platforms: A Learning and Planning Approach论文精读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《Large-Scale Order Dispatch in On-Demand Ride-Hailing Platforms: A Learning and Planning Approach》论文精读笔记 论文来源：滴滴，KDD CUP2018主要涉及方法：马尔科夫决策过程（MDP）、KM算法。本篇也是出行领域非常经典的一篇派单算法，有必要精读！参考解读 https://mp.weixin.qq.com/s/rRRYDoeUfiDmDwj_3hKz5A (赞！)http://www.arvinzyy.cn/2018/11/03/Dispatching-in-Didichuxing-2/ （赞！）https://www.leiphone.com/category/ai/7ZbAz8REosn3L8kT.html 摘要 背景：网约车、滴滴打车平台传统方法及不足：传统方法只关注于当下的乘客满意度(比如给当前乘客分配最近的司机，可以满足当下乘客，但是把这个司机分配到别的稍远的订单，可能会缓解别的区域的供需问题，带来更大收益)改进思路：设计一种更有效的方式来从全局和更长期的角度来优化资源利用以及用户体验改进方法：把派单过程建模为一个大规模的序列决策问题，每一个派单都有由一个集中式算法以协调的方式确定。方法简述：采用了learning and planning的方式来求解问题： 基于历史数据，利用时空价值来量化供需关系（对应了司机在该时空状态下的期望收益）planning步骤是在线进行的，每个司乘匹配分都考虑了当下回报和未来收益，然后使用组合优化算法来解决调度问题。 1、引言 近年来，打车软件得到了快速发展。在无线通信、GPS等加持下，网约车在空驶问题、乘客等待时间方面都得到了较大改进（相较于传统出租车系统）。同时这些打车软件还提供了关于乘客需求和出租车出行模式的丰富信息，这有利于各种研究领域，包括需求预测、路线规划、供应链管理和交通灯控制。本论文关注于网约车的派单问题（或者叫订单分配、司乘匹配都可）。以前往往会采用给乘客最近的司机等方法，这些方法易于实施和管理，但并非做的是全局优化。由于网约车司机和乘客需求之间的时空错配（打个比方，把一个离你很近的司机分配给你，当下时空获得了最大收益，但是如果把他分配给别的稍微远一点的乘客，可能在之后的时空下获得更大收益，从而给平台带来更大的利润），从长远来看，这可能会导致次优结果。作者们的目标是从长远的角度来进行订单分配，同时考虑当下乘客的满意度，并且考虑未来的预期收益。这依赖于从时空层面上对乘客和网约车模式的建模。为了达到上述目标，滴滴将其建模成了一个序列决策问题。并且将用于决策的司乘匹配分拆分为即时奖励和未来收益两部分。并以时空状态价值函数来量化未来收益（也就是后面主要介绍的MDP方法得到的状态价值函数）。并利用组合优化的方法来根据司乘匹配分进行派单，主要框图如论文图一所示。本论文提出的主要贡献如下： 提出了一种订单调度算法，可以优化大规模应用的长期平台效率。该算法在一个统一的决策框架中同时考虑了乘客的即时满意度和预期的未来收益。通过将订单调度建模为具有集中控制的顺序决策问题，属于强化学习的范畴。该算法在学习和规划框架中实现，是强化学习在大规模实时系统中的首批应用之一。考虑了计算效率、实验设计等问题，并且已经上线取得了收益。 2、派单背景和系统概述 从司机抢单模式到平台分发模式，平台效率显著提高，订单完成率提高了10%以上。派单就是要做好司乘之间的最优匹配，自然对打车服务非常重要。略 3、LEARNING（离线学习部分） 概述：该步骤就是利用离线数据，通过马尔可夫过程为每个时空过程学习出一个未来价值，存在查找表中，然后在线上调用。
3.1 问题定义、建模 背景：马尔可夫决策过程（MDP）通常用于建模连续决策问题。在MDP中，智能体需要在环境中根据自身所处的状态通过某个策略做出动作，相应的动作会有奖励。该智能体的目标就是最大化整个过程中收到的奖励。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/846952aa9ffd5b0ddad38bcae79c7b9d/" rel="bookmark">
			计组-运算方法及运算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运算方法及运算器 文章目录 运算方法及运算器定点数运算加减1）补码2）移码3）溢出4）加法器 乘法1）原码一位乘法2）原码两位乘法3）补码一位乘法4）补码两位乘法5）阵列乘法器 除法1）原码除法2）补码除法3）一些问答4）阵列除法器 ALU(算术逻辑运算单元)单元电路1）寄存器2）移位寄存器 ALU IC芯片运算器的结构标志寄存器（状态运算器） 浮点运算数据浮点表示加减乘除实现 定点数运算 加减 1）补码 使得CPU的设计只需要加法器就能完成加法与减法运算。
加法： [ X + Y ] 补 = [ X ] 补 + [ Y ] 补 [X+Y]_补=[X]_补+[Y]_补 [X+Y]补​=[X]补​+[Y]补​
减法： [ X − Y ] 补 = [ X ] 补 + [ [ Y ] 补 ] 求 补 [X-Y]_补=[X]_补+[[Y]_{补}]_{求补} [X−Y]补​=[X]补​+[[Y]补​]求补​
(注意：先补再求补，顺序不可调换)
求补：对于正数求补（全部取反+1）得到其负数。X - Y = X + ( - Y)
将减法转换为加法实现。
2）移码 对两方移码求和/差后将结果取反。
注意== [ X ] 移 + [ Y ] 移 ≠ [ X + Y ] 移 [X]_{移}+[Y]_{移}\ne[X+Y]_{移} [X]移​+[Y]移​​=[X+Y]移​==
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/846952aa9ffd5b0ddad38bcae79c7b9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dab949d540ad542be172ee54452fcae/" rel="bookmark">
			手机安装ubuntu
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先 需要获得root，可以先安装recovery，也可以用鲁大师，但是我搜了好几个root的软件都没有获取成功，所以我找到了免 Root的安装方法。安装的前提是手机剩余空间在3G以上。第1步下载安装Termux汉化版，我是在知乎上搜到的网址
https://www.lanzous.com/b776387/
之后安装ubuntu操作系统，网上搜到了操作指令，1、pkg install wget openssl-tool proot -y &amp;&amp; hash -r &amp;&amp; wget
2https://raw.githubusercontent.com/niezhe/Android_linux/master/install_system.sh &amp;&amp; bash
3、install_system.sh
输入第二条之后回车自动安装系统，可以使用VPN，成功率会高一些，安装过程中会有提示，输入Y后回车， 安装过程中不要退出，会提示打开手机存储权限，安装完成后，使用sh install_ System.sh 进入脚本。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/66/">«</a>
	<span class="pagination__item pagination__item--current">67/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/68/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>