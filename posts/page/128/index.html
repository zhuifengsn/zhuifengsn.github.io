<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcec8e914f2ec304fe1aeedd1f1e9ed0/" rel="bookmark">
			网站计数器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 主页计数器是用来记录页面曾经被访问次数的组件。它是一个比较简单的功能，但是实现起来却有许多实际问题要考虑。例如访问次数的记录如何存放？如果服务器关机，数据记录是否会丢失？等等问题都是需要我们考虑的。 目前的计数器主要是使用ASP技术制作，方法非常简单。但是很少有使用ASP.NET技术制作的计数器，原因主要是ASP.NET技术还未正式发布，同时支持.NET的服务器还很少导致的。本文讲述了如何利用ASP.NET技术，制作主页计数器。 设计构思 计数器的核心工作就是想办法将访问的次数记录下来，并且能够方便的读出数据记录。在此应用中，拟建立四个文件，一个是webform1.aspx，主要是用于显示访问次数记录，一个counter.txt文件用于存储访问次数记录，还有global.asax和global.asax.cs，这两个文件是核心文件，主要是负责响应事件和读写文件。因此，程序必须具有打开文件，读文件，累加数值，写文件等功能。同时，还需注意：在进行数值累加时，不能象ASP中的那样写成 application(“counter”)=application(“counter”)+1 因为数值类型不能和对象做数学运算。 经过以上的思考，我们基本就可以编写代码了，但是在完成编写之前，还应了解以下的相关知识。 相关知识 1. Global.asax文件 Global.asax文件也称为ASP.NET应用程序文件，它一般被放在根目录下。此文件中的代码不产生用户界面，也不相应单个页面的请求。它主要是负责处理Application_Start，Application_End，Session_Start和Session_End事件的。 2. Application对象及其事件 Application 对象来自HttpApplictionStat 类。它可以在多个请求、连接之间共享公用信息，也可以在各个请求连接之间充当信息传递的管道。此对象的生命周期起于IIS开始运行并且有人开始连接时，终止于IIS关闭或者若干时间内无人连接（默认为20分钟）。当Application 对象的生命周期开始时，Application_Start 事件会被启动，当Application对象的生命周期结束时Application_End 事件会被启动。 3. Session对象及其事件 Session对象有着与Application类似的事件：Session_Start和Session_End事件。当有一个新用户访问应用程序时，就会立刻触发Session_Start事件。当某个用户停止了访问或者程序执行了Session.Abandon方法，就会触发Session_End事件。 4. Application和Session对象比较 Session对象与Application对象有些相似，但其作用域有更大的限制。Application对象是针对所有用户都生效，而Session对象则相反，每个用户都有自己的Session对象，它的生命周期起始于服务器产生对用户请求页面的相应，终止于用户断开与服务器的连接。Application对象不会象Session对象那样当一个新用户请求就触发事件，Application对象的事件只触发一次，就是在第一个用户的第一个请求时。一个Application_End事件肯定发生在Session_End事件之后，Application_End事件只有在服务器停止工作或Application_End事件卸载时才触发。 程序部分 首先建立一个文本文件counter.txt，打开文件输入一个大于0的整数作为访问记录的初始值。 下面我们就可以正式的编写计数器的程序了。 listing 1是webform1.aspx，主要是用于显示从文件中读出的访问次数的记录。由于在整个应用程序生命周期中，Application 对象都是有效的，所以在不同的页面中都可以对它进行存取，就像使用全局变量一样方便。 在代码中，使用&lt;%=Application["counter"]%&gt;来表示访问次数记录。 程序代码如下: listing1 -----webform1.aspx----- &lt;%@ Page language="c#" Src="WebForm1.aspx.cs" Inherits="counter1.WebForm1" %&gt; &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" &gt; &lt;HTML&gt; &lt;HEAD&gt; &lt;meta name="GENERATOR" Content="Microsoft Visual Studio 7.0"&gt; &lt;meta name="CODE_LANGUAGE" Content="C#"&gt; &lt;/HEAD&gt; &lt;body&gt; &lt;form id="Form1" method="post" runat="server"&gt; &lt;FONT face="宋体"&gt;您是第&lt;%=Application["counter"]%&gt;位访问者！&lt;/FONT&gt; &lt;/form&gt; &lt;/body&gt; &lt;/HTML&gt; Listing 2和listing3是global.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcec8e914f2ec304fe1aeedd1f1e9ed0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9bacf357a114e1264acf1e0a44b8c81/" rel="bookmark">
			SQL UNIQUE 约束介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UNIQUE 约束唯一标识数据库表中的每条记录。
UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。
PRIMARY KEY 拥有自动定义的 UNIQUE 约束。
请注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。
独特的SQL制约创建表
下列SQL创建了一个唯一约束的“ P_Id ”一栏时， “人”是创建表：
CREATE TABLE Persons(P_Id int NOT NULL,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255),UNIQUE (P_Id)) SQL Server / Oracle / MS Access:
CREATE TABLE Persons(P_Id int NOT NULL UNIQUE,LastName varchar(255) NOT NULL,FirstName varchar(255),Address varchar(255),City varchar(255)) 为了让命名一个独特的制约因素，并确定了唯一约束上多列，请使用下面的SQL语法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9bacf357a114e1264acf1e0a44b8c81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b3665f3ce9c77ca5ae9819fd39b6bad/" rel="bookmark">
			高级Bash脚本编程指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 第一部分. 热身 为什么使用shell编程 带着一个Sha-Bang出发(Sha-Bang指的是#!) 调用一个脚本 初步的练习 第二部分. 基本 特殊字符 变量和参数的介绍 变量替换 变量赋值 Bash变量是不分类型的 特殊的变量类型 引用(翻译的可能有问题,特指引号) 引用变量 转义(\) 退出和退出状态 Tests Test结构 文件测试操作 其他比较操作 嵌套的if/then条件test 检查你的test知识 操作符和相关的主题 操作符 数字常量 第三部分. 超越基本 变量重游 内部变量 操作字符串 参数替换 指定类型的变量:declare或者typeset 变量的间接引用 RANDOM: 产生随机整数 双圆括号结构 循环和分支 循环 嵌套循环 循环控制 测试与分支(case和select结构) 内部命令与内建 作业控制命令 外部过滤器,程序和命令 基本命令 复杂命令 时间/日期 命令 文本处理命令 文件与归档命令 通讯命令 终端控制命令 数学计算命令 混杂命令 系统与管理命令 分析一个系统脚本 命令替换 算术扩展 I/O 重定向 使用exec 代码块的重定向 应用 Here Documents Here Strings 休息时间 第四部份.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b3665f3ce9c77ca5ae9819fd39b6bad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31a7b78eeec2920b40d4946040f86f14/" rel="bookmark">
			TCP三次握手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 TCP的三次握手是怎么进行的：发送端发送一个SYN=1，ACK=0标志的数据包给接收端，请求进行连接，这是第一次握手；接收端收到请求并且允许连接的话，就会发送一个SYN=1，ACK=1标志的数据包给发送端，告诉它，可以通讯了，并且让发送端发送一个确认数据包，这是第二次握手；最后，发送端发送一个SYN=0，ACK=1的数据包给接收端，告诉它连接已被确认，这就是第三次握手。之后，一个TCP连接建立，开始通讯。 *SYN：同步标志 同步序列编号(Synchronize Sequence Numbers)栏有效。该标志仅在三次握手建立TCP连接时有效。它提示TCP连接的服务端检查序列编号，该序列编号为TCP连接初始端(一般是客户端)的初始序列编号。在这里，可以把 TCP序列编号看作是一个范围从0到4，294，967，295的32位计数器。通过TCP连接交换的数据中每一个字节都经过序列编号。在TCP报头中的序列编号栏包括了TCP分段中第一个字节的序列编号。 *ACK：确认标志 确认编号(Acknowledgement Number)栏有效。大多数情况下该标志位是置位的。TCP报头内的确认编号栏内包含的确认编号(w+1，Figure-1)为下一个预期的序列编号，同时提示远端系统已经成功接收所有数据。 *RST：复位标志 复位标志有效。用于复位相应的TCP连接。 *URG：紧急标志 紧急(The urgent pointer) 标志有效。紧急标志置位 *PSH：推标志 该标志置位时，接收端不将该数据进行队列处理，而是尽可能快将数据转由应用处理。在处理 telnet 或 rlogin 等交互模式的连接时，该标志总是置位的。 *FIN：结束标志 带有该标志置位的数据包用来结束一个TCP回话，但对应端口仍处于开放状态，准备接收后续数据。 .TCP的几个状态对于我们分析所起的作用。在TCP层，有个FLAGS字段，这个字段有以下几个标识：SYN, FIN, ACK, PSH, RST, URG.其中，对于我们日常的分析有用的就是前面的五个字段。它们的含义是：SYN表示建立连接，FIN表示关闭连接，ACK表示响应，PSH表示有 DATA数据传输，RST表示连接重置。其中，ACK是可能与SYN，FIN等同时使用的，比如SYN和ACK可能同时为1，它表示的就是建立连接之后的响应，如果只是单个的一个SYN，它表示的只是建立连接。TCP的几次握手就是通过这样的ACK表现出来的。但SYN与FIN是不会同时为1的，因为前者表示的是建立连接，而后者表示的是断开连接。RST一般是在FIN之后才会出现为1的情况，表示的是连接重置。一般地，当出现FIN包或RST包时，我们便认为客户端与服务器端断开了连接；而当出现SYN和SYN＋ACK包时，我们认为客户端与服务器建立了一个连接。PSH为1的情况，一般只出现在 DATA内容不为0的包中，也就是说PSH为1表示的是有真正的TCP数据包内容被传递。TCP的连接建立和连接关闭，都是通过请求－响应的模式完成的。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e596440e33a43cf6cd72c5d6ffca211/" rel="bookmark">
			Linux启动过程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文以RedHat9.0和i386平台为例，剖析了从用户打开电源直到屏幕出现命令行提示符的整个Linux启动过程。并且介绍了启动中涉及到的各种文件。 阅读Linux源代码，无疑是深入学习Linux的最好方法。在本文对Linux启动过程的介绍中，我们也尝试从源代码的视角来更深入的剖析Linux 的启动过程，所以其中也简单涉及到部分相关的Linux源代码，Linux启动这部分的源码主要使用的是C语言，也涉及到了少量的汇编。而启动过程中也执行了大量的shell(主要是bash shell)所写脚本。为了方便读者阅读，笔者将整个Linux启动过程分成以下几个部分逐一介绍，大家可以参考下图： 当用户打开PC 的电源，BIOS开机自检，按BIOS中设置的启动设备(通常是硬盘)启动，接着启动设备上安装的引导程序lilo或grub开始引导Linux， Linux首先进行内核的引导，接下来执行init程序，init程序调用了rc.sysinit和rc等程序，rc.sysinit和rc当完成系统初始化和运行服务的任务后，返回init；init启动了mingetty后，打开了终端供用户登录系统，用户登录成功后进入了Shell，这样就完成了从开机到登录的整个启动过程。 下面就将逐一介绍其中几个关键的部分： 第一部分：内核的引导(核内引导) Red Hat9.0可以使用lilo或grub等引导程序开始引导Linux系统，当引导程序成功完成引导任务后，Linux从它们手中接管了CPU的控制权，然后CPU就开始执行Linux的核心映象代码，开始了Linux启动过程。这里使用了几个汇编程序来引导Linux，这一步泛及到Linux源代码树中的“arch/i386/boot”下的这几个文件：bootsect.S、setup.S、video.S等。 其中 bootsect.S是生成引导扇区的汇编源码，它完成加载动作后直接跳转到setup.S的程序入口。setup.S的主要功能就是将系统参数（包括内存、磁盘等，由BIOS返回）拷贝到特别内存中，以便以后这些参数被保护模式下的代码来读取。此外，setup.S还将video.S中的代码包含进来，检测和设置显示器和显示模式。最后，setup.S将系统转换到保护模式，并跳转到 0x100000。 那么0x100000这个内存地址中存放的是什么代码？而这些代码又是从何而来的呢？ 0x100000这个内存地址存放的是解压后的内核，因为Red Hat提供的内核包含了众多驱动和功能而显得比较大，所以在内核编译中使用了“makebzImage”方式，从而生成压缩过的内核，在RedHat中内核常常被命名为vmlinuz，在Linux的最初引导过程中，是通过"arch/i386/boot/compressed/"中的head.S利用 misc.c中定义的decompress_kernel()函数，将内核vmlinuz解压到0x100000的。 当CPU跳到 0x100000时，将执行"arch/i386/kernel/head.S"中的startup_32，它也是vmlinux的入口，然后就跳转到 start_kernel()中去了。start_kernel()是"init/main.c"中的定义的函数，start_kernel()中调用了一系列初始化函数，以完成kernel本身的设置。start_kernel()函数中，做了大量的工作来建立基本的Linux核心环境。如果顺利执行完 start_kernel()，则基本的Linux核心环境已经建立起来了。 在start_kernel()的最后，通过调用init ()函数，系统创建第一个核心线程，启动了init过程。而核心线程init()主要是来进行一些外设初始化的工作的，包括调用 do_basic_setup()完成外设及其驱动程序的加载和初始化。并完成文件系统初始化和root文件系统的安装。 当 do_basic_setup()函数返回init()，init()又打开了/dev/console设备，重定向三个标准的输入输出文件stdin、 stdout和stderr到控制台，最后，搜索文件系统中的init程序（或者由init=命令行参数指定的程序），并使用 execve()系统调用加载执行init程序。到此init()函数结束，内核的引导部分也到此结束了。 第二部分：运行init init的进程号是1，从这一点就能看出，init进程是系统所有进程的起点，Linux在完成核内引导以后，就开始运行init程序，。init程序需要读取配置文件/etc/inittab。inittab是一个不可执行的文本文件，它有若干行指令所组成。在Redhat系统中，inittab的内容如下所示(以“###"开始的中注释为笔者增加的)： # # inittab This file describes how the INIT process should set up # the system in a certain run-level. # # Author: Miquel van Smoorenburg, &lt;miquels@drinkel.nl.mugnet.org&gt; # Modified for RHS Linux by Marc Ewing and Donnie Barnes # # Default runlevel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e596440e33a43cf6cd72c5d6ffca211/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0e88c86b104517ca712f60121449af7/" rel="bookmark">
			Linux驱动入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux驱动入门 作者：齐波 更新时间：2005-04-14 内核版本: 2.4.22 阅读此文的目的: 学会编写Linux设备驱动。 阅读此文的方法: 阅读以下2个文件: hello.c,asdf.c。 此文假设读者: 已经能用C语言编写Linux应用程序, 理解"字符设备文件, 块设备文件, 主设备号, 次设备号", 会写简单的Shell脚本和Makefile。 1. "hello.c" -------------------------------- /* * 这是我们的第一个源文件， * 它是一个可以加载的内核模块， * 加载时显示"Hello,World!"， * 卸载时显示"Bye!"。 * 需要说明一点，写内核或内核模块不能用写应用程序时的系统调用或函数库， * 因为我们写的就是为应用程序提供系统调用的代码。 * 内核有专用的函数库，如&lt;linux/kernel.h&gt;, &lt;linux/fs.h&gt;, &lt;linux/sche.h&gt;等, * 现在还没必要了解得很详细， * 这里用到的printk的功能类似于printf。 * "/usr/src/linux"是你实际的内核源码目录的一个符号链接， * 如果没有现在就创建一个,因为下面和以后都会用到。 * 编译它用"gcc -c -I/usr/src/linux/include hello.c"， * 如果正常会生成文件hello.o, * 加载它用"insmod hello.o", * 只有在文本终端下才能看到输出。 * 卸载它用"rmmod hello" */ /* * 小技巧: 在用户目录的.bashrc里加上一行: * alias mkmod='gcc -c -I/usr/src/linux/include' * 然后重新登陆Shell, * 以后就可以用"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0e88c86b104517ca712f60121449af7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1f0d307d490051ed75d3934ed8548c7/" rel="bookmark">
			h323 document
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		28 May, 1996 SOURCE : SG15 Plenary May 28, 1966 TITLE :Draft Recommendation H.323: VISUAL TELEPHONE SYSTEMS AND EQUIPMENT FOR LOCAL AREA NETWORKS WHICH PROVIDE A NON-GUARANTEED QUALITY OF SERVICE
This document reflects changes to COM15-245 (H.323) approved by the May 28 Plenary of SG15. It is the final master for the decided H.323. It has no change marks. The file name is p323ncm3.doc. This document results from the application of the changes in the file h323wtd8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1f0d307d490051ed75d3934ed8548c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f2ea94ceec67da77bc4f28cfdd9ae58/" rel="bookmark">
			Linux个人防火墙设计与实现-数据包捕获
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要 防火墙是网络安全研究的一个重要内容，数据包捕获是包过滤型防火墙的前提，本文对基于Linux主机的个人防火墙的数据包捕获模块进行了研究,重点论述数据包捕获模块的结构、组成以及功能。首先对信息安全及防火墙的重要性进行论述，并给出防火墙的详细分类；然后分析了基于Linux主机的个人防火墙总体设计及软硬件平台原理，接着论述Linux下的数据包捕获模块结构与原理，并详述其具体实现步骤。 关键词 防火墙 Linux 数据包捕获模块 包过滤 一、防火墙概述 网络防火墙技术是一种用来加强网络之间访问控制，防止外部网络用户以非法手段通过外部网络进入内部网络，访问内部网络资源，保护内部网络操作环境的特殊网络互联设备。它对两个或多个网络之间传输的数据包按照一定的安全策略来实施检查，以决定网络之间的通信是否被允许，并监视网络运行状态。 根据防火墙所采用的技术不同，可以将它分为四种基本类型：包过滤型、网络地址转换—NAT、代理型和监测型。包过滤型产品是防火墙的初级产品，其技术依据是网络中的分包传输技术。包过滤技术的优点是简单实用，实现成本较低，在应用环境比较简单的情况下，能够以较小的代价在一定程度上保证系统的安全。网络地址转换是一种用于把IP地址转换成临时的、外部的、注册的IP地址标准。它允许具有私有IP地址的内部网络访问因特网。 代理型防火墙也可以被称为代理服务器，它的安全性要高于包过滤型产品，并已经开始向应用层发展。代理型防火墙的优点是安全性较高，可以针对应用层进行侦测和扫描，对付基于应用层的侵入和病毒都十分有效。其缺点是对系统的整体性能有较大的影响，而且代理服务器必须针对客户机可能产生的所有应用类型逐一进行设置，大大增加了系统管理的复杂性。 监测型防火墙是新一代的产品，能够对各层的数据进行主动的、实时的监测，在对这些数据加以分析的基础上，监测型防火墙能够有效地判断出各层中的非法侵入。同时,这种检测型防火墙产品一般还带有分布式探测器，这些探测器安置在各种应用服务器和其他网络的节点之中，不仅能够检测来自网络外部的攻击，同时对来自内部的恶意破坏也有极强的防范作用。监测型防火墙在安全性上已超越了包过滤型和代理服务器型防火墙，但其实现成本较高。基于对系统成本与安全技术成本的综合考虑，用户可以选择性地使用某些监测型技术。 二、基于Linux个人防火墙总体设计 本文研究的是防火墙系统的软硬件环境以及该防火墙的开发步骤和所要实现的功能，最后重点对该防火墙系统所需要的硬件和软件平台原理进行说明。尽管所有Linux系统都自带防火墙内核程序，但需要用户进行配置才能起到保护网络安全的目的。 1、防火墙系统总体设计 Linux系统下实现软件防火墙的设计与应用，实质上就是基于主机的网络安全解决方案。因此，我们完全可以选择合适的软硬件平台和相应的防火墙设计原理，自己开发出一套能够满足要求的防火墙系统。 归纳起来这里要实现的防火墙需要满足两大要求：第一，必须能够对主机提供安全保护，即对主机与局域网以外的主机进行数据传输时实施安全保护；第二，必须能够提供良好的人机接口界面，具有容易操作、容易管理的优点。 考虑到现有硬件设备的限制，在保证满足实验要求的环境下尽可能地简化了实验环境。因为该防火墙系统是基于主机设计的，故只需要一个联网的主机即可进行实验。该系统是在Linux环境下用C语言实现包过滤型软件防火墙的设计与应用，采用Kylix开发工具进行界面设计和数据库连接。 基于Linux的个人防火墙系统主要具有以下功能： （1）全程动态包过滤 本防火墙要在Linux下实现全程动态包过滤功能，通过分析数据包的地址、协议、端口对任何网络连接当前状态进行访问控制，从而提高系统的性能和安全性。 （2）提供日志审计 本防火墙配备了日志记录系统和查询工具，用于记录系统管理、系统访问及针对安全策略的网络访问情况。 （3）防火墙数据库的备份 本防火墙制作防火墙过滤数据库，并且管理员可以能动地对该数据库进行设置。 三、基于Linux的数据包捕获模块结构与原理分析 本节就监控层数据包捕获模块的结构特性进行探讨，并详细论述其原理，且对实现数据包捕获功能的程序的一些重要函数进行说明。 1、数据包捕获模块结构 数据包捕获模块用于监视和验证网络流量情况，它可以截取或者阅读网络上OSI协议模型中各个协议层次上的数据包。 本文所设计的数据包捕获程序可以捕获通过原始套接口(Socket)的原始数据包(Raw Packet)，当一个数据包到达网络接口时，数据包捕获程序就直接从缓存区读取捕获的数据包，以供数据分析和处理时调用。数据捕获模块的结构如图1所示： 数据捕获 网卡设置 获取数据包 得到数据包头信息 图1 数据捕获程序结构图
2、数据包捕获模块原理分析
（1）网卡设置原理
在一个实际的系统中，数据的收发是由网卡来完成的，网卡接收到传输来的数据，网卡内的程序接收数据帧的目的MAC地址，根据计算机上的网卡驱动程序设置的接收模式判断该不该接收，认为不该接收就丢掉不管。而对于网卡来说一般有四种接收模式：广播模式组播模式、直接方式、混杂模式。数据包捕获程序首先使网络接口(网卡)处于混杂状态，从而可截获网络上的内容，并且通过相应的软件处理，可以实时分析这些数据的内容，为数据包过滤作准备。
（2）基本函数说明
本文中在Linux主机上用C语言编写数据包捕获程序，所编写的程序中用到很多Linux中的预定义函数，在此节将对这些基本函数的功能和使用特点进行说明。
1）ioctl函数定义
ioctl()函数非常庞杂，它可以控制各种文件的属性。它用于控制特殊文件的底层设备参数，这些特殊文件通常是指终端、套接字和接口。ioctl函数原型为：
int ioctl(int handle,int cmd[,int *argdx,int argcx])；
2）socket函数定义
常用的Socket类型有两种：流式Socket(SOCK_STREAM)和数据包式Socket (SOCK_DGRAM)。流式是一种面向连接的Socket，针对面向连接的TCP服务应用；数据报式Socket是一种无连接的Socket，针对无连接的UDP服务应用。Socket函数原型为：
int socket(int domain, int type,int protocol)；
3）recvfrom()函数定义
用recvfrom()函数来实现接收数据包，recvfrom()是具备“阻塞式I/O”特性的函数，能够在没有数据包到达的情况下暂时挂起等待，直至接收到数据包后，再激活转入下一步处理。recvfrom()函数的原型为：
int recvfrom(SOCKET s,char FAR *buf,int len,int flags,struct sockaddr FAR *from,int *fromlen)；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f2ea94ceec67da77bc4f28cfdd9ae58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c70076398b00518c52f3365636bc8bc8/" rel="bookmark">
			错误unknown character &#39;0xa1&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个错误是一些懒人(像我)常有的。我在教程里直接Copy了下面的代码，结果就总是出错。
#include "windows.h" int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow) { MessageBox (NULL, TEXT ("你好，欢迎来到VC之路"), TEXT ("欢迎"), 0) ; return 0 ; } 字符之间的空格在不同的编辑器中，编码是不同的。这里因为VC没法识别该字符而报错。
解决方法：去掉多余的空格并且以后尽量自己写代码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4bd9c5b8bed80c466dffe70d47ff3b0/" rel="bookmark">
			Google编程大赛入围赛750分真题(第五组) 之解法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在CSDN首页看到 Google编程大赛入围赛750分真题 第五组之后，一时手痒，动手用C++做了一个解决方案，写出来接受大家的批评，呵呵。 先贴上代码， ============================================================================= #pragma warning (disable : 4786) #include &lt;list&gt; #include &lt;vector&gt; #include &lt;iostream&gt; namespace S3{ const unsigned int MAX_COUNT = 1000000000; const unsigned int MAX_UINT = 0xFFFFFFFF; struct cell { char ch; int count[2]; }; class CGrid { typedef cell* LPCELL; public: CGrid() : m_RowCount(0), m_ColCount(0), m_ppCells(NULL) { } ~CGrid() { Clear(); } bool Initialize(const std::vector&lt;std::string&gt;&amp; grid) { Clear(); m_RowCount = grid.size(); if (m_RowCount &lt;= 0) { return false; } m_ColCount = grid[0].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4bd9c5b8bed80c466dffe70d47ff3b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc738a10ade7732c2903deffb1111889/" rel="bookmark">
			一段经典的c 分析9
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c952cc547f06553b36a5aa1f39f928fc/" rel="bookmark">
			STL List Container
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		The Standard Template Library's list container is implemented as a doubly linked list. You might wonder why there are both list and vector containers in the STL -- the reason is that the underlying representations are different, and each representation has its own costs and benefits. The vector has relatively costly insertions into the middle of the vector, but fast random access, whereas the list allows cheap insertions, but slow access (because the list has to be traversed to reach any item).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c952cc547f06553b36a5aa1f39f928fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b5c4f85f53a150a7c79f946f98e51ea/" rel="bookmark">
			google 编程挑战赛（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Problem Statement When editing a single line of text, there are four keys that can be used to move the cursor: end, home, left-arrow and right-arrow. As you would expect, left-arrow and right-arrow move the cursor one character left or one character right, unless the cursor is at the beginning of the line or the end of the line, respectively, in which case the keystrokes do nothing (the cursor does not wrap to the previous or next line).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b5c4f85f53a150a7c79f946f98e51ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4033ddaa5a527e46b80be79b3f2d63c8/" rel="bookmark">
			google 编程挑战赛（1）answer3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//这一次的修改参照了几位高手的代码，真没想到，从这样一个编程题目中可以学到这么多的东西，真的很直
#include &lt;stdio.h&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;
#define DOWN 0
#define RIGHT 1
#define UP 2
#define LEFT 3
inline int INT(char *x,int len)
//全局函数将字符串转换为int
//在这里定义为inline是经过了再三的考虑啊
//终于明白了c++中inline的用意，哈哈，
//原来c++真的不亚于c阿，看来要学一c++了
{
int out=0;
for(int i=0;i&lt;len;i++)
{
out = out*10+x[i]-48;
}
return out;
}
class DrawLines
{
int x,y;
int dx,dy;
int direct;
vector&lt;string&gt; result;
void OnLeft();
void OnForward();
public:
DrawLines()
{
int i,j;
result.resize(20); x=0;
y=0;
dx=0;
dy=1;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4033ddaa5a527e46b80be79b3f2d63c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba0977148afe7576b2b83c123f14e4c1/" rel="bookmark">
			用Perl制作页面计数器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网友大都喜欢在自己的主页上做一个计数器来显示自己主页被访问的次数。以前我们只能申请由第三方提供的计数器或用由系统管理员提供的计数器，受到很大限制。现在许多免费空间都提供了CGI权限，因此我们也可以用CGI方式实现一个自己的计数器。 计数器可以用数据库方式实现，也可以用文本文件方式实现。由于文本文件方式不涉及系统的数据库管理系统，相对简单，容易实现，因此，在这里介绍文本方式的计数器。 计数器的原理比较简单，页面每次被访问的时候，对记录访问次数的数字加1，然后将这个数显示出来。原理虽然简单，在具体实现上还是需要一定的技巧。 由于一个CGI程序在服务器上并非一直驻留在内存中，为了对访问次数进行计数，则需要把这个数字存入一个文件中，每当主页被访问时，打开该文件将访问数字加1后再存入文件中。 网站是多用户环境，在访问文件时必须对文件上锁以禁止其他用户对文件的访问，这样才能保证数据的可靠性。然而不同网站使用的操作系统不同，其对文件上锁的机制也不同。本文采用了一种各种平台都适用的方法，每当有页面被访问时，CGI程序创建一个临时文件，此时若有其它进程也要对文件进行存取则须等待，进程对文件更新后删除该临时文件，等待的进程才能对文件进行存取。 下面是用Perl实现的一个计数器源代码，并加注了注释： #!/usr/local/bin/perl ＃存贮表示主页访问量数字的文件 $data = '/usr/local/etc/httpd/htdocs/counter.data'; ＃用作文件锁的临时文件 $lockfile = '/usr/local/etc/httpd/htdocs/counter.LOCK'; # 主模块 &amp;increment; print "Content-Type: text/html/n/n"; print $accesses; sub increment { # 检查临时文件是否存在 while (-e $lockfile) { sleep 2; # 存在则等待2秒 } # 创建临时文件 open(LOCK," &gt;$lockfile") || die "Can't create lockfile./n"; # 读文件并更新数据 open(DATA,$data) || die "Can't open data file./n"; $accesses = &lt; DATA &gt;; $accesses++; print DATA "$accesses/n"; close(DATA); # 删除临时文件，对数据文件开锁 close(LOCK); unlink($lockfile); } 你可以在页面上需要显示计数器的地方加上下面的HTML代码，页面被访问的时候，来访者就可以知道自己是第几位来访者了。 &lt; html &gt; &lt; head &gt; &lt; title &gt;Home Page&lt; /title &gt; &lt; /head &gt; &lt; body &gt; &lt; h1 &gt;Home Page&lt; /h1 &gt; &lt; p &gt;欢迎您！第 &lt; !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba0977148afe7576b2b83c123f14e4c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4a3898dfb8be92de36f6dbda16f0585/" rel="bookmark">
			OPENH323中呼叫建立过程的跟踪与分析（八）----非快速隧道方式之被叫端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CPhone 0x004AD480 3 videoio.cxx(466) PVidDev SetColourFormatConverter success for native YUV420P
CPhone 0x004AD480 4 h323caps.cxx(1772) H323 FindCapability: "G.723.1A(6.3k)-Cisco{hw}"
CPhone 0x004AD480 3 h323caps.cxx(1687) H323 Added capability: G.723.1A(6.3k)-Cisco{hw} &lt;1&gt;
CPhone 0x004AD480 4 h323caps.cxx(1772) H323 FindCapability: "G.723.1A(5.3k){hw}"
CPhone 0x004AD480 3 h323caps.cxx(1687) H323 Added capability: G.723.1A(5.3k){hw} &lt;2&gt;
CPhone 0x004AD480 4 h323caps.cxx(1772) H323 FindCapability: "G.723.1A(6.3k){hw}"
CPhone 0x004AD480 3 h323caps.cxx(1687) H323 Added capability: G.723.1A(6.3k){hw} &lt;3&gt;
CPhone 0x004AD480 4 h323caps.cxx(1772) H323 FindCapability: "G.723.1(5.3k){hw}"
CPhone 0x004AD480 3 h323caps.cxx(1687) H323 Added capability: G.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4a3898dfb8be92de36f6dbda16f0585/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6217bfea51eff34b15df93dcf7c16b88/" rel="bookmark">
			Ghost V8.0 使用详解 【操作说明】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ghost V8.0 使用详解 【操作说明】 一、分区备份 使用Ghost进行系统备份，有整个硬盘（Disk）和分区硬盘（Partition）两种方式。在菜单中点击 Local（本地）项，在右面弹出的菜单中有3个子项，其中 Disk表示备份整个硬盘（即克隆）、Partition 表示备份硬盘的单个分区、Check 表示检查硬盘或备份的文件，查看是否可能因分区、硬盘被破坏等造成备份或还原失败。分区备份作为个人用户来保存系统数据，特别是在恢复和复制系统分区时具有实用价值。 选 Local→Partition→To Image 菜单，弹出硬盘选择窗口，开始分区备份操作。点击该窗口中白色的硬盘信息条，选择硬盘，进入窗口，选择要操作的分区（若没有鼠标，可用键盘进行操作：TAB键进行切换，回车键进行确认，方向键进行选择）。 在弹出的窗口中选择备份储存的目录路径并输入备份文件名称，注意备份文件的名称带有 GHO 的后缀名。 接下来，程序会询问是否压缩备份数据，并给出3个选择：No 表示不压缩，Fast表示压缩比例小而执行备份速度较快，High 就是压缩比例高但执行备份速度相当慢。最后选择 Yes 按钮即开始进行分区硬盘的备份。Ghost 备份的速度相当快，不用久等就可以完成，备份的文件以 GHO 后缀名储存在设定的目录中。 二、硬盘克隆与备份 硬盘的克隆就是对整个硬盘的备份和还原。选择菜单Local→Disk→To Disk，在弹出的窗口中选择源硬盘（第一个硬盘），然后选择要复制到的目标硬盘（第二个硬盘）。注意，可以设置目标硬盘各个分区的大小，Ghost 可以自动对目标硬盘按设定的分区数值进行分区和格式化。选择 Yes 开始执行。 Ghost 能将目标硬盘复制得与源硬盘几乎完全一样，并实现分区、格式化、复制系统和文件一步完成。只是要注意目标硬盘不能太小，必须能将源硬盘的数据内容装下。 Ghost 还提供了一项硬盘备份功能，就是将整个硬盘的数据备份成一个文件保存在硬盘上（菜单 Local→Disk→To Image），然后就可以随时还原到其他硬盘或源硬盘上，这对安装多个系统很方便。使用方法与分区备份相似。 三、备份还原 如果硬盘中备份的分区数据受到损坏，用一般数据修复方法不能修复，以及系统被破坏后不能启动，都可以用备份的数据进行完全的复原而无须重新安装程序或系统。当然，也可以将备份还原到另一个硬盘上。 要恢复备份的分区，就在界面中选择菜单Local→Partition→From Image，在弹出窗口中选择还原的备份文件，再选择还原的硬盘和分区，点击 Yes 按钮即可。 四、局域网操作 LPT 是通过并口传送备份文件,下面有两个选项：slave 和 master, 分别用以连接主机和客户机。 网络基本输入输出系统 NetBios 和 LPT 相似, 也有 slave 和 master 两个选项, 作用与 LPT 相同。 先和平时一样将要 ghost 的分区做成一个 *.gho 文件，再在一台 win98 上安装Symantec Ghost 企业版，重启。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6217bfea51eff34b15df93dcf7c16b88/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/127/">«</a>
	<span class="pagination__item pagination__item--current">128/128</span>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>