<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a4ab08134cd984f76ea64dadaef4301/" rel="bookmark">
			单片机51 输入和输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、IO口基本概念介绍 单片机的IO口（Input/Output口）是连接单片机与外部电路或设备的接口。单片机的IO口可以分为输入口和输出口两种，用于控制和监测外部设备的状态。
1. 输入口：单片机的输入口用于接收外部电路或设备的信号。输入口可以连接传感器、开关、按键等外部设备，用于获取外部环境的信息。输入口一般被配置为高阻态，以避免影响外部电路。
2. 输出口：单片机的输出口用于向外部电路或设备发送信号。输出口可以连接LED灯、继电器、电机等外部设备，用于控制它们的状态。输出口可以输出高电平（通常为Vcc）或低电平（通常为地）来控制外部设备。
单片机的IO口可以通过编程来配置和控制，通常包括以下步骤：
1. 配置IO口为输入口或输出口。
2. 读取输入口状态或向输出口写入数据。
3. 根据需要控制IO口的电平状态，实现特定功能。
在设计单片机应用时，合理使用IO口可以实现与外部设备的通信和控制，实现各种功能，如数据采集、控制执行、通信传输等。设计时需考虑IO口的数量、电压、电流等参数，以确保与外部电路的匹配和稳定性。
二、IO输出 点亮led 2.1 电路原理图 电路原理图
led在板子上的io口
2.2 程序 点亮一个led灯
#include "reg52.h" sbit led1 = P3^6; int main() { led1 = 0; } 三、IO输入 key按键 3.1 #include "reg52.h" sbit led1 = P3^6; sbit key1 = P2^1; sbit key2 = P2^0; void Delay50ms()	//@11.0592MHz { unsigned char i, j; i = 90; j = 163; do { while (--j); } while (--i); } int main() { while(1) { if(key1 == 0) { Delay50ms(); if(key1 == 0) { led1 =0; } } if(key2 == 0) { Delay50ms(); if(key2 == 0) { led1 =1; } } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cb7917aa5936e5668a26fa7d3a7c2f1/" rel="bookmark">
			【算法分析与设计】1的个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📝个人主页：五敷有你 🔥系列专栏：算法分析与设计
⛺️稳中求进，晒太阳
题目 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。
示例 示例 1：
输入：n = 00000000000000000000000000001011 输出：3 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。 示例 2：
输入：n = 00000000000000000000000010000000 输出：1 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。 示例 3：
输入：n = 11111111111111111111111111111101 输出：31 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1' 思路 们可以直接循环检查给定整数 nnn 的二进制位的每一位是否为 111。
具体代码中，当检查第i位时，我们可以让 n 与 1左移i位 进行与运算，当且仅当 n 的第 i 位为 1 时，运算结果不为 0。然后++
实现代码 public class Solution { public int hammingWeight(int n) { int ret = 0; for (int i = 0; i &lt; 32; i++) { if ((n &amp; (1 &lt;&lt; i)) !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cb7917aa5936e5668a26fa7d3a7c2f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/978a9862ea66a5e62673f285e4687d54/" rel="bookmark">
			linux逻辑卷/dev/mapper/centos-root扩容增加空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 centos7中/dev/mapper/centos-root扩容 问题文件系统根目录，/dev/mapper/centos-root空间满了，导致k8s不停重启 1.查看磁盘情况 df -h #查看最大占用目录 du -h -x --max-depth=1 2.查看磁盘信息 fdisk -l 3.查看磁盘分区层级 lsblk 可见剩余空闲60G空间未被分配
4.新建分区 在/dev/sda磁盘上使用剩余空间新建分区
fdisk /dev/sda 新建分区：输入“n”，回车；（n：新建分区）
主分区：不用输入，回车；（p：主分区）
设置分区号：不用输入，回车；（t：设置分区号）
设置扇区：下面几个选项不用输入，直接回车；
保存修改：输入“w”，回车；（w：保存修改）
5.刷新分区信息 #方式一：重启机器 reboot #方式二：直接命令刷新(未尝试) partprobe partprobe是一个Linux下的命令，它可以在不重启系统的情况下，通知操作系统重新加载分区表。有时候在分区之后，内核仍然使用的是旧的分区表和分区信息。
6.查看新分区是否出现 lsblk 7.通过LVM工具创建物理卷 #创建物理卷 pvcreate /dev/sda3 #查看物理卷属性 pvdisplay 将物理硬盘分区初始化为物理卷，以便LVM使用
8.添加物理卷到逻辑卷组centos vgextend centos /dev/sda3 扩展逻辑卷组的存储空间，使其能够容纳更多的物理卷。
9.查看逻辑卷组属性 vgdisplay 10.逻辑卷扩容 lvextend -l +100%FREE /dev/mapper/centos-root 将逻辑卷 /dev/mapper/centos-root 扩展到卷组中所有可用空闲空间的大小
11.对root文件系统执行扩容 xfs_growfs /dev/mapper/centos-root 同步到文件系统 之前只是对逻辑卷扩容，还要同步到文件系统，实现对根目录的扩容
将逻辑卷上的文件系统扩展到卷组中新增的物理卷的空间范围内，以便更有效地利用存储空间
12.查看扩容结果 df -h 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b03abe763b823a25dbc14a4f35a831c1/" rel="bookmark">
			【嵌入式——QT】字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【嵌入式——QT】字符串 QString构造函数QString类从字符串转换为整数的函数其他常用功能 QByteArray构造函数其他常用功能 QString 与 QByteArray的区别 QString 构造函数 QString(const QByteArray &amp;ba) QString(const char *str) QString(QString &amp;&amp;other) QString(const QString &amp;other) QString(QLatin1String str) QString(int size, QChar ch) QString(QChar ch) QString(const QChar *unicode, int size = -1) QString() QString类从字符串转换为整数的函数 int toInt(bool *ok=nullptr, int base=10) const; uint toUInt(bool *ok=nullptr, int base=10) const; long toLong(bool *ok=nullptr, int base=10) const; qlonglong toLongLong(bool *ok=nullptr, int base=10) const; qulonglong toULongLong(bool *ok=nullptr, int base=10) const; short toShort(bool *ok=nullptr, int base=10) const; ushort toUShort(bool *ok=nullptr, int base=10) const; float toFloat(bool *ok=nullptr) const; double toDouble(bool *ok=nullptr) const; 默认是从十进制表示的字符串转换为整数，若指定整数基参数，还可以直接将二进制、十六进制字符串转换为整数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b03abe763b823a25dbc14a4f35a831c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a83df9b2ed1f69f4e142fadf9ff5cb0/" rel="bookmark">
			adb-monkey命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
adb shell monkey -p/-v 包名 次数
1、指定一个包 2、指定多个包 3、不指定包 Event percentages（事件百分比）
常见参数
--throttle 延迟时间 单位毫秒
--pct-touch 设定触屏事件生成的百分比
--pct-motion 设定滑动事件生成的百分比
--pct-trackball 设定轨迹球事件生成的百分比
--pct-nav 设定基本导航事件生成的百分比
--pct-majornav 设定主要导航事件生成的百分比
--pct-key 设定按键事件生成的百分比
--pct-syskeys 设定系统按键事件生成的百分比
--pct-appswitch 设定应用切换事件生成的百分比
--pct-flip 设定翻转事件生成的百分比
--hprof 在应用程序运行时生成内存使用情况的分析报告
--ignore-crashes 在Monkey测试期间忽略应用程序崩溃
--ignore-timeouts 忽略超时事件
--ignore-security-exceptions 忽略安全异常
adb shell monkey -p/-v 包名 次数 -p 参数：表示指定测试的程序（空格后面跟安装包名）
-v 参数：表示查看monkey执行过程的日志（-v 越多越详细，最多三个）
数字100：表示测试事件数为100
1、指定一个包 adb shell monkey -p com.bignox.app.store.hd -v 1000
2、指定多个包 adb shell monkey -p com.bignox.app.store.hd -p com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a83df9b2ed1f69f4e142fadf9ff5cb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d263edbf51e640c6110630a51d24b107/" rel="bookmark">
			常用ADB命令整理已经ADB键盘输入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在测试Android app过程中 需要经常更换安装包的操作 熟练使用ADB命令可以提升测试效率
* 查看设备
adb devices
ps这个命令是查看当前连接的设备, 连接到计算机的android设备或者模拟器将会列出显示
若有多台安卓设备，可以通过在adb后面加上 -s &lt;设备id&gt; 对指定设备进行装包、卸载等操作
*启动adb
adb start-server
*关闭adb
adb kill-server
* 安装软件
adb install &lt;apk文件路径&gt;
* 卸载软件 adb uninstall &lt;应用进程名&gt;
*卸载app但保留数据和缓存文件
adb uninstall -k&lt;package&gt;
*重新启动设别
adb reboot
*重启到bootloader，即刷机模式
adb reboot bootloader
*重启到recovery，即恢复模式
adb reboot recovery
*从电脑上发送文件到设备
adb push &lt;本地路径&gt; &lt;远程路径&gt;
ps: 用push命令可以把本机电脑上的文件或者文件夹复制到设备(手机)
*从设备上下载文件到电脑
adb pull &lt;远程路径&gt; &lt;本地路径&gt;
ps: 用pull命令可以把设备(手机)上的文件或者文件夹复制到本机电脑
*取得设备root权限
adb remount
*登录设备shell
adb shell
adb shell&lt;command命令&gt;
ps: adb shell 后面加的是linux系统操作指令，也即直接运行设备命令, 相当于执行远程命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d263edbf51e640c6110630a51d24b107/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f941e4c46de3f8638e3286338eb5777/" rel="bookmark">
			【TEE论文】硬件辅助安全全面调查：从边缘到云（综述）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：A comprehensive survey of hardware-assisted security: From the edge to the cloud
1. 引言 从在中央存储库（例如云主机）中处理收集的传感器数据的传统部署，到更高级的解决方案，例如新兴的边缘计算领域，其中分布式处理发生在终端设备中。在这两种情况下，数据都超出了用户的控制范围，在处理时尤其容易受到完整性或机密性攻击。基于软件的安全性带来的性能开销是不可忽视的，硬件支持可以减少性能开销。
硬件安全方面，解决方案是专门为唯一的硬件层设计的，这与硬件辅助安全不同，硬件辅助安全侧重于保护机器架构的更高层（例如，虚拟机管理程序、操作系统）。
主要供应商（即 AMD、ARM、Intel）发布了多种硬件辅助解决方案的架构实现，用于各种用途，例如加速安全相关处理、安全随机数生成、内存边界保护、隔离执行、视频保护或可信计算等技术。
本文提出了许多支持主机内保护的技术，这些技术适用于大多数 CPU 内部。所考虑的架构可在典型物联网部署的两端利用：终端设备和云主机。
是针对物联网终端设备或云托管服务器等环境中处理的数据进行最关键攻击的最佳方法，例如总线嗅探、超级劫持、冷启动、代码注入、iago、侧信道、代码重用、缓冲区溢出。
2.相关工作 SoK: A study of using hardware-assisted isolated execution environments for security：比较了硬件辅助隔离执行环境的六种技术。他们从安全角度介绍了主要功能，并讨论了它们的漏洞。Survey of hardware-based security support for IOT/CPS systems：物联网背景下的硬件辅助安全性进行了调查。在这项工作中，注意力主要集中在可信计算上，更准确地说，是能够确保硬件信任根（HRoT）的技术。A comparison of software and hardware techniques for x86 virtualization：比较了 Intel 和 AMD CPU 在支持虚拟化方面的架构扩展。从性能和安全角度来看，他们将现有软件 VMM 与使用新兴硬件支持设计的 VMM 进行了比较。Hardware-based Control Flow Integrity (CFI)：概述了硬件辅助用于控制流完整性（CFI）保护，其中硬件监视器用于检查软件的行为（即调用）。 与之前的工作不同，本文的目标是涵盖更广泛的硬件辅助安全解决方案，这些解决方案专注于物联网边缘设备和云节点。
3. 硬件辅助安全的承诺：概念、场景和分类 概念 硬件辅助安全包括使用硬件组件或扩展来支持更高计算机层（如固件或软件）的安全性的技术，因此包括 BIOS、操作系统、虚拟机管理程序或任何其他用户级应用程序。 硬件辅助安全不得与硬件安全相混淆，硬件安全旨在保护物理设备，而不是安装在计算机系统硬件上的软件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f941e4c46de3f8638e3286338eb5777/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28bcc8372b847b1fd38b556918ecb5ce/" rel="bookmark">
			TCP Keepalive 和 HTTP Keep-Alive
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP 的Keep-Alive 在 HTTP 1.0 中默认是关闭的，如果浏览器要开启 Keep-Alive，它必须在请求的包头中添加：
Connection: Keep-Alive 然后当服务器收到请求，作出回应的时候，它也添加一个头在响应中：
Connection: Keep-Alive 这样做，连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接。这一直继续到客户端或服务器端提出断开连接。
从 HTTP 1.1 开始， 就默认是开启了 Keep-Alive，如果要关闭 Keep-Alive，需要在 HTTP 请求的包头里添加：
Connection:close 所以为了避免资源浪费的情况，web 服务软件一般都会提供 keepalive_timeout 参数，用来指定 HTTP 长连接的超时时间。
比如设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会启动一个定时器，如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，定时器的时间一到，就会触发回调函数来释放该连接。
TCP 的 Keepalive TCP 的 Keepalive 这东西其实就是 TCP 的保活机制
如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。
如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 TCP 保活时间会被重置，等待下一个 TCP 保活时间的到来。如果对端主机宕机（注意不是进程崩溃，进程崩溃后操作系统在回收进程资源的时候，会发送 FIN 报文，而主机宕机则是无法感知的，所以需要 TCP 保活机制来探测对方是不是发生了主机宕机），或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，TCP 会报告该 TCP 连接已经死亡。 所以，TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活，这个工作是在内核完成的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28bcc8372b847b1fd38b556918ecb5ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10a34f7d3d6d46ea1c30966d4b745254/" rel="bookmark">
			【前端素材】推荐优质后台管理系统XELORO平台模板（附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、需求分析 后台管理系统网站是指用于管理和控制网站、应用程序或系统后台运行的管理工具。它通常是网站或应用程序的管理者、管理员或内容编辑人员使用的界面，具有一系列功能来管理用户、内容、数据和系统设置。其功能和设计思路可以根据具体需求和系统复杂性有所不同，但一般包括以下几个方面的功能和设计考虑：
功能分析： 用户管理：包括用户权限管理、用户信息管理、角色管理等，确保不同用户有不同的访问权限和操作权限。
内容管理：管理网站或应用程序的内容，包括文章、图片、视频等的发布、编辑、删除等操作。
数据管理：对系统中的数据进行管理，包括数据的导入导出、备份恢复、数据分析等功能。
系统设置：管理系统的基本设置，包括站点标题、LOGO、页面风格、邮件设置等。
日志管理：记录用户操作日志、系统日志，便于追踪问题和监控系统运行情况。
安全管理：包括用户身份验证、防火墙设置、数据加密等，确保系统安全性。
统计分析：对系统数据进行统计分析，生成报表、图表，帮助管理员了解系统运行状况。
设计思路： 用户友好性：界面简洁直观，易于操作，减少用户的学习成本。
模块化设计：将系统功能模块化，每个模块负责一类功能，方便扩展和维护。
Responsiveness：后台管理系统应当是响应式设计，能够适配不同设备屏幕大小，包括电脑、平板和手机等。
权限控制：根据用户角色设定不同的权限，确保用户只能访问其权限范围内的功能。
数据安全：对用户数据进行加密存储、访问控制等措施，保护用户隐私和系统安全。
日志功能：记录关键操作日志，保留操作痕迹，便于审计和追踪问题。
系统性能：考虑系统的性能优化，包括减少不必要的数据读写、合理利用缓存等，提高系统响应速度。
汇总： 以上只是后台管理系统的一些基本功能和设计思路，具体的系统需求和规模会影响功能设计和实现的复杂程度。设计一个高效、易用的后台管理系统需要充分考虑用户需求和系统架构，确保系统稳定运行并满足管理员的管理需求。
后台管理系统网站是指用于管理和控制网站、应用程序或系统后台运行的管理工具。它通常是网站或应用程序的管理者、管理员或内容编辑人员使用的界面，具有一系列功能来管理用户、内容、数据和系统设置。
二、界面展示 1、系统首页
2、应用页
【数据表】
【登录页】
3、数据分析
三、资源获取 前端素材推荐优质后台管理系统XELORO平台模板（附源码）资源-CSDN文库
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c69657e0f6e36973fb7e1e9a0f55b922/" rel="bookmark">
			Unity中.Net与Mono的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是.NET .NET是一个开发框架，它遵循并采用CIL(Common Intermediate Language)和CLR(Common Language Runtime)两种约定，
CIL标准为一种编译标准：将不同编程语言（C#, JS, VB等）使用各自的编译器，按照统一的标准编译成语义一致的CIL中间码， 这样虽然代码使用的语言不同，但编译出的产物是一样的。
CLR标准为一种执行标准：不同的操作系统可以根据CLR这一执行标准开发出自己平台的中间码执行器，这样CIL这个标准中间产物就可以在不同的平台执行了。其中Mono框架就扮演了这样一个重要的角色，实现了各个平台的CLR执行器。
.Net拥有跨语言，跨平台性:
跨语言：就是只要是面向.Net平台的编程语言，用其中一种语言编写的类型就可以无缝的在另外一种语言编写的应用程序中互操作。
跨平台：一次编译，不需要任何代码修改，应用程序就可以运行在任意在.Net实现的平台上跑，即代码不依赖于操作系统，也不依赖硬件环境。一个.Net程序运行的核心在于.Net
CLR(公共语言运行时，或者称为.Net 虚拟机，类似java虚拟机的概念)，为了让.Net程序在其他平台（目前只能在.Net 平台,windows系统）上跑,微软官方还推出了在其他平台(MacOs,Linux)跑的
.Net的实现，就推出了.Net Core。
然而，Unity引擎需求也是需要跨平台，支持多语言（C#，Js，Boo）。就参考微软开发.Net Core的概念，于是，推出了Mono.
画个图简单对比一下：
到这里，基本说明了.Net 与Mono和Unity的联系关系，其实没啥关系。做游戏都知道，肯定需要跨平台，不能只支持一种平台，不然每个对应的平台做出一种对应的编译器，那真的会累死。所以对于跨平台的需求，对于游戏开发而言，很重要。Unity的架构需求设计当然也需要这个特性。参考.Net依托CLR来实现设计思路，于是Mono就出来了。
什么是Mono Mono是一个框架，它是.NET这个开源框架的子集，它建立在.NET框架基础上，在使用.NET基础能力的基础上，自己做了多各个操作系统的CLR实现来实现跨平台。同时也重写了一些.NET框架中的基本功能。
mcs编译器: C#编译器，C#编译为IL中间指令。
Unity跨平台的原理: 就是Mono运行时编译器支持将IL代码转为对应平台原生码，IL可以在任何支持CLI(Common Language Insfrastructure,通用语言环境结构)中运行，IL的运行是依托Mono运行时。
IOS不支持jit编译原因：机器码被禁止映射到内存，即封存了内存的可执行权限，变相的封锁了jit编译方式，详情参考：https://www.cnblogs.com/murongxiaopifu/p/4278947.html
JIT编译: 将IL代码转为对应平台原生码并且将原生码映射到虚拟内存中执行。JIT编译的时候IL是在依托Mono运行时，转为对应的原生码后在依托本地运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fa781a7053b1bd317ff3b4a338f12a1/" rel="bookmark">
			10 个最佳 Linux 开源笔记软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记应用程序允许您随时随地记录笔记，无论您是在课堂上、学习中、在某处阅读、在工作中还是在会议中。您可以在 Linux 系统上安装和使用许多笔记应用程序。
在本文[1]中，我们将回顾可在 Linux 系统上使用的 11 个最佳开源笔记应用程序。
Joplin Joplin 是一款功能齐全、高度可定制且安全的开源笔记和待办事项应用程序，适用于 Linux、Windows 和 macOS（笔记本电脑或台式电脑）以及 Android 和 iOS（手机）或药片。它还可以作为终端或基于文本的应用程序使用。
Joplin 支持多种语言，允许您记笔记并从任何设备安全地访问它们。它的功能是将笔记组织到笔记本中，支持多媒体笔记和附件（图像、视频、PDF 以及音频），并支持高级文本搜索查询、标签和外部编辑器。
它还支持待办事项的警报（通知）、端到端加密（E2EE）以确保安全，允许使用 Firefox 和 Chrome 网络浏览器中提供的网络剪辑扩展将网页和屏幕截图保存为笔记，并支持与云或文件存储服务，例如 Joplin Cloud、Dropbox 和 OneDrive 等服务。此外，它还支持通过自定义主题、插件、多个文本编辑器（富文本或 Markdown）等进行定制。
Simplenote Simplenote，这是一种在 Linux 系统、Windows、Mac、iOS 和 Android 以及 Web 浏览器上保存所有笔记的简单方法。它是免费的、开源的、支持标签和可共享的待办事项列表，并提供降价支持。它可以跨设备同步您的所有笔记，并允许您在线发布笔记。
Boost Note Boost Note 不仅仅是一个笔记应用程序，还是一个开源文档驱动的项目管理工具，专为开发人员和运营 (DevOps) 团队设计。它根据开发人员的需求提供可定制的工作区，并具有类似 IDE 的用户界面。
Boost Note 支持随时随地的实时协作（Web、桌面和移动应用程序）、强大的 Markdown 编辑器和多个视图。您还可以将其与 Github、Gitlab、Trello、Jira、Slack、Zoom 和许多其他应用程序（多达 4000 多个）等工具集成。
它还具有评论和提及、支持图表、仪表板、用于文档自定义的丰富属性以及丰富的可搜索性。此外，它还提供双向文档链接并支持嵌入第三方内容。并提供公共 API 来以编程方式管理文档。
Standard Notes Standard Notes 面向数字专家和专业人士，是一款免费、开源、安全的端到端加密笔记应用程序。它简单、易于使用、轻量级，有多种主题可供使用。它是跨平台的，可以在 Linux 系统、Windows、Mac、iOS、Android 和 Web 浏览器上运行。Standard Notes 使您能够捕获具有注释类型的操作（Markdown 测试、纯文本、任务、待办事项、代码、电子表格等）。它还具有智能视图、嵌套文件夹、身份验证器、密码保护、密码、面部 ID 和指纹锁定。它还支持数据导入和导出，并标配同步到所有设备和端到端加密。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fa781a7053b1bd317ff3b4a338f12a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec003c55486c5f5441498c2cf4b87f75/" rel="bookmark">
			.Net 8.0 新的变化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.NET 8 是微软于2021年8月24日宣布的下一代编程语言和框架，它是 .NET 宇宙的一部分，与 C# (Common Language Infrastructure) 紧密集成。.NET 8 引入了许多新功能，如原生编译、值类型 (Value Types)、结构化并发 (structured concurrency) 和快速数组 (RapidArray)。.NET 8 还支持本机 (native) AOT (Ahead-Of-Time) 编译，以提高性能和启动速度。
.NET 8 是 Microsoft 发布的最新一代 .NET 框架，它引入了许多新功能和改进，旨在提高性能、可扩展性和开发效率。
以下是一些 .NET 8 的主要亮点：
1、性能提升：.NET 8 引入了名为“性能计数器”的新功能，可帮助开发人员了解应用程序的性能瓶颈，并采取相应的优化措施。此外，.NET 8 还对许多现有的组件和库进行了优化，以提高应用程序的整体性能。
2、新的异步编程模型：.NET 8 引入了名为“协程”的新的异步编程模型，它可以更自然地处理异步操作和长时间运行的任务。协程可以在同一个线程上执行多个异步操作，从而避免了线程切换和上下文切换的开销。
3、云原生支持：.NET 8 提供了更好的云原生支持，可以更轻松地将应用程序部署到 Kubernetes 等容器化平台中。.NET 8 还支持使用 Docker 等容器化工具打包和分发应用程序。
4、新的开发工具：.NET 8 引入了新的开发工具，如 R#”、Visual Studio Code“ 和 Visual Studio IDE 等，这些工具可以帮助开发人员更高效地编写、调试和测试代码。
5、跨平台支持：.NET 8 可以在多个平台上运行，包括 Windows、macOS 和 Linux 等操作系统。此外，.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec003c55486c5f5441498c2cf4b87f75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5229dede94693e8b5f55b8f439634c9/" rel="bookmark">
			C语言K&amp;R圣经笔记 8.3 open,creat,close,unlink 8.4随机访问-lseek
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		8.3 open, creat, close, unlink 除了标准输入、标准输出和标准错误之外，如果你要读写文件，就必须显式地打开它们。有两个系统调用做这件事，open 和 creat（末尾就是没有 e 的）。
open 非常像第七章讨论的 fopen，区别在于 open 不返回文件指针，而是返回文件描述符，后者仅仅是个 int 。如果发生任何错误，则 open 返回 -1。
#include &lt;fcntl.h&gt; int fd; int open(char *name, int flags, int perms); fd = open(name, flags, perms); 与 fopen 一样，name 参数是包含文件名的字符串。第二个 int 参数 flags 是用来指定如何打开文件的；主要的值有
O_RDONLY 只读
O_WRONLY 只写
O_RDWR 读写
在 System V UNIX 系统上，这些常量定义在 &lt;fcntl.h&gt; 中，而在伯克利（BSD）版本的系统上，它们定义在 &lt;sys/file.h&gt; 中。
若为了读取而打开已存在的文件，要写成
fd = open(name, O_RDONLY, 0); 接下来在介绍 open 的使用时，我们总是把参数 perms 的值设为 0。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5229dede94693e8b5f55b8f439634c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b299ad8972aad2e221607ad676da390d/" rel="bookmark">
			HarmonyOS-ArkTS卡片运行机制和相关模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ArkTS卡片运行机制 实现原理 图1 ArkTS卡片实现原理
卡片使用方：显示卡片内容的宿主应用，控制卡片在宿主中展示的位置，当前仅系统应用可以作为卡片使用方。卡片提供方：提供卡片显示内容的应用，控制卡片的显示内容、控件布局以及控件点击事件。卡片管理服务：用于管理系统中所添加卡片的常驻代理服务，提供formProvider接口能力，同时提供卡片对象的管理与使用以及卡片周期性刷新等能力。卡片渲染服务：用于管理卡片渲染实例，渲染实例与卡片使用方上的卡片组件一一绑定。卡片渲染服务运行卡片页面代码widgets.abc进行渲染，并将渲染后的数据发送至卡片使用方对应的卡片组件。 图2 ArkTS卡片渲染服务运行原理
与JS卡片相比，ArkTS卡片支持在卡片中运行逻辑代码，为确保ArkTS卡片发生问题后不影响卡片使用方应用的使用，ArkTS卡片新增了卡片渲染服务用于运行卡片页面代码widgets.abc，卡片渲染服务由卡片管理服务管理。卡片使用方的每个卡片组件都对应了卡片渲染服务里的一个渲染实例，同一应用提供方的渲染实例运行在同一个虚拟机运行环境中，不同应用提供方的渲染实例运行在不同的虚拟机运行环境中，通过虚拟机运行环境隔离不同应用提供方卡片之间的资源与状态。开发过程中需要注意的是globalThis对象的使用，相同应用提供方的卡片globalThis对象是同一个，不同应用提供方的卡片globalThis对象是不同的。
ArkTS卡片的优势 卡片作为应用的一个快捷入口，ArkTS卡片相较于JS卡片具备如下几点优势：
统一开发范式，提升开发体验和开发效率。
OpenHarmony在2022年发布了声明式范式的UI开发框架，而卡片还延续了css/hml/json三段式类Web范式的开发方式，提高了开发者的学习成本，提供ArkTS卡片能力后，统一了卡片和页面的开发范式，页面的布局可以直接复用到卡片布局中，提升开发体验和开发效率。
图3 卡片工程结构对比
增强了卡片的能力，使卡片更加万能。
新增了动效的能力：ArkTS卡片开放了属性动画和显式动画的能力，使卡片的交互更加友好。新增了自定义绘制的能力：ArkTS卡片开放了Canvas画布组件，卡片可以使用自定义绘制的能力构建更多样的显示和交互效果。允许卡片中运行逻辑代码：开放逻辑代码运行后很多业务逻辑可以在卡片内部自闭环，拓宽了卡片的业务适用场景。 ArkTS卡片的约束 ArkTS卡片相较于JS卡片具备了更加丰富的能力，但也增加了使用卡片进行恶意行为的风险。由于ArkTS卡片显示在使用方应用中，使用方应用一般为桌面应用，为确保桌面的使用体验以及功耗相关考虑，对ArkTS卡片的能力做了以下约束：
不支持加载so。不支持使用native语言开发。仅支持声明式范式的部分组件、事件、动效、数据管理、状态管理和API能力。卡片的事件处理和使用方的事件处理是独立的，建议在使用方支持左右滑动的场景下卡片内容不要使用左右滑动功能的组件，以防手势冲突影响交互体验。 除此之外，当前ArkTS卡片还存在如下约束：
暂不支持导入模块。暂不支持极速预览。暂不支持断点调试能力。暂不支持Hot Reload热重载。 ArkTS卡片相关模块 图1 ArkTS卡片相关模块
FormExtensionAbility：卡片扩展模块，提供卡片创建、销毁、刷新等生命周期回调。
FormExtensionContext：FormExtensionAbility的上下文环境，提供FormExtensionAbility具有的接口和能力。
formProvider：提供卡片提供方相关的接口能力，可通过该模块提供接口实现更新卡片、设置卡片更新时间、获取卡片信息、请求发布卡片等。
formInfo：提供了卡片信息和状态等相关类型和枚举。
formBindingData：提供卡片数据绑定的能力，包括FormBindingData对象的创建、相关信息的描述。
页面布局（Card.ets）
：提供声明式范式的UI接口能力。
ArkTS卡片特有能力：postCardAction用于卡片内部和提供方应用间的交互，仅在卡片中可以调用。ArkTS卡片能力列表：列举了能在ArkTS卡片中使用的API、组件、事件、属性和生命周期调度。 卡片配置
：包含FormExtensionAbility的配置和卡片的配置
在module.json5配置文件中的extensionAbilities标签下，配置FormExtensionAbility相关信息。
ion-file-0000001427744540-V2)中的extensionAbilities标签下，配置FormExtensionAbility相关信息。在resources/base/profile/目录下的form_config.json配置文件中，配置卡片（WidgetCard.ets）相关信息。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f86b8f4e1102c853083e97a53c43940/" rel="bookmark">
			Excel面试题及答案（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.辅助列添加，快速填充方式填充隔行的编号；定位条件定位到空值后，右击---插入整行
2.利用通配符计算A3：A9含有车间的单元格个数（保留计算公式）。
3.利用身份证号提取 “性别”、“年月日”、“年龄”
性别：利用mid（）方法，添加了一列辅助列，根据提取身份证后面第2位，用MOD（）判断奇数偶数来判断男女性别，奇数为男，偶数为女。 =MID(B2,17,1)，=IF(MOD(G2,2)=0,"女","男")
年龄：利用DATEDIF()函数：这是一个计算两个日期之间差异的函数。身份证里提取的年份与当今的年份之差就是年龄。 4.根据给出的节假日及月份和天，得出2023年各个节假日的具体日期和星期
星期几：使用weekday（）函数具体时间：使用date()函数 5.使用INDEX及MATCH组合函数查找标黄部分相关信息
6.用HLOOKUP公式从产品价格表中查找出标黄部分值
7.使用iserror()函数设置单元格格式。
8.用SUMPRODUCT函数在黄色单元格内计算销售人员为"a"且产品编号为"A001"的销售金额合计 计算过程 SUMPRODUCT 函数会取两个数组（在本例中是转换后的逻辑数组和 D 列的范围）的对应元素的乘积，然后将这些乘积相加。由于逻辑数组中的元素是 0、1 或 2，这实际上是在计算满足特定条件的 D 列单元格的和。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a410639bfd3c4ae2c1733552201a0161/" rel="bookmark">
			linux之用户和用户组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、简介1.1 用户1.2 用户组1.3 UID和GID1.4 用户账户分类 二、用户2.1 添加新的用户账号：useradd2.2 删除账号：userdel2.3 修改账号：usermod(mod=modify)2.4 用户口令的管理:passwd2.5 切换用户：su 三、用户组3.1 增加一个用户组:groupadd3.2 groupdel 删除组3.3 groupmod 修改组3.4 newgrp切换 四、用户账号系统文件4.1 /ete/passwd4.2 /etc/shadow4.3 /etc/group 一、简介 1.1 用户 如果要使用系统资源，就必须向系统管理员申请一个账号，然后通过这个账号进入系统，这个账号即用户，用户又有不同的权限，经理有增删改查的权限，组长没有新增表权限，普通用户只能看
1.2 用户组 linux系统中的用户组(group)就是具有相同特性的用户(user)集合
1.3 UID和GID 即用户ID和组ID
1.4 用户账户分类 查看用户类别
cat /etc/passwd
超级用户root(0)
默认是root用户，其UID和GID均为0.在每台unix/inux操作系统中都是唯一且真实存在的，通过它可以登录系统，可以操作系统中任何文件和命命，拥有最高的管理权限。在生产环境，一般禁止root账号远程登录SSH连接服务器，以加强系统安全
程序用户(1~499)
与真实用户区分开来，这类用户的最大特点是安装系统后默认就会存在的，且默认情况不能登录系统，它们是系统正常运行必不可少的，他们的存在主要是方便系统管理，满足相应的系统进程都文件属主的要求。例如系统默认的bin、adm、nodoby、ma用户等。由于服务器角色的不同，有部分用不到的系统服务被禁止开机执行。因此，在做系统安全优化时，被禁止开机后动了的服务对应的虚拟用户也是可以处理掉的(删除或注释)
普通用户(500~65535)
这类用户一般是由具备系统管理员root的权限的运维人员添加的
二、用户 2.1 添加新的用户账号：useradd 注：只要创建目录必定有home家这个文件夹
1.添加新的用户账号：
useradd 选项 用户名
参数说明：选项：
-c commert 指定一段注释性描述(加注释)。
-d 目录 指定指定创建用户主目录（切换主目录），如果此目录指定，则自动在根目录下创建同名的文件夹。
-g 用户组 指定用户所属的用户组。
-G 用户组，用户组 指定用户所属的附加组。
-s Shell 文件 指定用户的登录Shell（shell脚本的执行命令）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a410639bfd3c4ae2c1733552201a0161/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cef4f7a1f1eb7e986a7581e41fbebfca/" rel="bookmark">
			springboot项目打包jar和war有什么区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot项目可以打包成可执行的JAR（Java Archive）文件或WAR（Web Archive）文件，两者之间有一些区别：
JAR（可执行的Java Archive）： JAR文件是一种常见的Java归档文件格式，它包含了项目的所有代码、依赖项和资源文件。Spring Boot的JAR包是可执行的，可以通过 java -jar 命令直接运行。这种方式下，Spring Boot应用内嵌了一个Servlet容器（通常是Tomcat），因此不需要额外的Servlet容器来运行应用。打包成JAR文件适合于独立运行的Spring Boot应用，尤其是微服务架构中的独立服务。 WAR（Web Archive）： WAR 文件是一种常见的Java Web应用归档文件格式，用于部署到Servlet容器中（例如Tomcat、Jetty）。WAR 文件中包含了Web应用的所有资源，包括JSP页面、HTML文件、静态资源等。WAR 文件通常也包含 WEB-INF 目录，其中包含了web.xml等配置文件。
WAR 文件需要部署到外部的Servlet容器中运行，Spring Boot应用会在容器中运行，而不是作为独立的Java应用。打包成WAR文件适合于传统的Java Web应用或者需要与其他Web应用共享一个Servlet容器的场景。 选择JAR或WAR取决于你的部署需求和架构设计。如果你的应用是一个独立的微服务，你可能会选择JAR；如果你需要将应用部署到传统的Servlet容器中，你可能会选择WAR。Spring Boot提供了方便的插件和配置，使得JAR和WAR的打包过程都变得简单。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d80c5c6b866eecb9e45d7f26e2515ee2/" rel="bookmark">
			JVM-虚拟机栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概念 Java虚拟机栈是Java虚拟机内存结构中的一部分，是每个线程运行的内存空间。每个虚拟机栈由多个栈帧组成，每次调用一个方法会创建一个新的栈帧。
二、栈内存溢出 由于栈帧过多，导致栈帧所用的内存之和超出了给栈分配的内存，造成了StackOverflow错误。用-Xss参数可以设置栈的大小，例如-Xss256k表示设置栈的大小是256k字节
三、线程运行诊断 案例1:CPU占用过高 用top命令找到哪个进程占用CPU过高；ps H -eo pid, tid, %CPU | grep 进程id，定位到该进程中哪个线程占用CPU过高；jstack 进程id，会打印进程当前线程的堆栈信息，可以根据占用CPU高的线程id进一步定位到源代码的某文件-某行存在问题。 案例2:长时间没有返回结果（出现死锁） 也可以用jstack 进程id命令，定位到具体哪两个（多个）线程出现死锁。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6c2a834374ebed13dacea8450ff8bc7/" rel="bookmark">
			HarmonyOS—使用预览器查看应用/服务效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DevEco Studio为开发者提供了UI界面预览功能，可以查看应用/服务的UI界面效果，方便开发者随时调整界面UI布局。预览器支持布局代码的实时预览，只需要将开发的源代码进行保存，就可以通过预览器实时查看应用/服务运行效果，方便开发者随时调整代码。
说明
由于操作系统和真机设备的差异，在预览界面中可能出现字体、颜色等与真机设备运行的效果存在差异，预览效果仅作为应用/服务开发过程中的参考，实际最终效果请以真机设备运行效果为准。
为了更好的使用体验，建议先将DevEco Studio升级至最新版本，然后检测并更新SDK至最新版本。
查看ArkTS和JS应用/服务预览效果 预览器支持JS和ArkTS应用/服务“实时预览”和“动态预览”。
说明
预览Phone、Tablet、TV和Wearable设备的JS/ArkTS工程，预览器功能依赖于电脑显卡的OpenGL版本，OpenGL版本要求为3.2及以上。
richtext、web、video、XComponent组件不支持预览。
不支持调用C++库的预览。
har在被应用和元服务使用时真机效果有区别，真机上实际效果应用不显示menubar，元服务显示menubar，但预览器都以不显示menubar为准。若开发har模块时，请注意被元服务使用时预览器效果与真机效果的不同。
实时预览：在开发界面UI代码过程中，如果添加或删除了UI组件，您只需Ctrl+S进行保存，然后预览器就会立即刷新预览结果。如果修改了组件的属性，则预览器会实时（亚秒级）刷新预览结果，达到极速预览的效果（当前版本极速预览仅支持ArkTS组件。API 8工程的极速预览仅在非数据绑定场景生效，如涉及数据绑定，仍需要在文件保存后才可以预览；API 9工程的极速预览支持部分数据绑定场景，如@State变量）。实时预览默认开启，如果不需要实时预览，请单击预览器右上角按钮，关闭实时预览功能。
说明
开发者修改resources/base/profile目录下的配置文件（如main_page.json），不支持触发实时预览，开发者需要手动刷新。
动态预览：在预览器界面，可以在预览器中操作应用/服务的界面交互动作，如单击、跳转、滑动等，与应用/服务运行在真机设备上的界面交互体验一致。
在使用预览器前，请根据如下项检查环境信息：
确保File &gt; Settings &gt; SDK &gt;
HarmonyOS/OpenHarmony中，已下载Previewer资源。如果已下载Previewer，但存在新版本的情况，建议升级到最新版本，详情请参考下载HarmonyOS
SDK。建议将File &gt; Settings &gt; SDK &gt; HarmonyOS/OpenHarmony中的SDK更新至最新版本。 以ArkTS为例，使用预览器的方法如下：
1.创建或打开一个ArkTS应用/服务工程。本示例以打开一个本地ArkTS Demo工程为例。
2.在工程目录下，打开任意一个.ets文件（JS工程请打开.hml/.css/.js页面）。
3.可以通过如下任意一种方式打开预览器开关，显示效果如下图所示：
通过菜单栏，单击View&gt;Tool Windows&gt;Previewer打开预览器。在编辑窗口右上角的侧边工具栏，单击Previewer，打开预览器。 查看ArkUI预览效果 ArkUI预览支持页面预览与组件预览，下图中左侧图标为页面预览，右侧图标为组件预览。
页面预览 ArkTS应用/服务支持页面预览，要求compileSdkVersion为7或以上。页面预览通过在工程的ets文件头部添加注解@Entry实现。
@Entry的使用参考如下示例：
@Entry @Component struct Index { @State message: string = 'Hello World' build() { Row() { Column() { Text(this.message) .fontSize(50) .fontWeight(FontWeight.Bold) } .width('100%') } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6c2a834374ebed13dacea8450ff8bc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59f7a22134e53be3c8990517b63b1f58/" rel="bookmark">
			计算机网络：传输层知识点汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、传输层概述二、UDP协议三、TCP协议特点和TCP报文段格式四、TCP连接管理五、TCP可靠传输六、TCP流量控制七、TCP拥塞控制 一、传输层概述 我们通信的时候，虽然都说是主机之间的通信，但实际是主机之间的进程和进程通信。比如我和你发微信，实际是我手机中运行的微信程序和你手机微信这样的进程进行通信。
我们在传输层主要学习两种协议：TCP协议和UDP协议
在计算机网络中有个非常重要的问题，就是我们在进行数据通信，资源共享的过程中，如何保证我们的数据是准确的？如何在一种可能会丢失或者损坏的数据媒体上，如何可靠的来传输我们的数据，这个就是TCP协议发挥作用的地方。
而UDP协议就是相当不可靠的协议，在传输对数据准确性不高的，对传输延迟比较苛刻的场景，我们通常会使用UDP协议。
传输层是在主机才有的层次，也就是在端系统两个主机之间才有一层叫做传输层。
传输层位与五层网络体系结构的第四层，上面是应用层，下面是网络层。我们之前讲过，下层是要为上层提供服务的，所以传输层是为应用层提供服务，同时它也可以使用网络层的服务。
传输层功能：
1.传输层提供进程和进程之间的逻辑通信。
注意这里说的是进程和进程之间的，在网络层是为主机之间通信提供服务。但我们在实际通信的时候，比如说我们的微信聊天时，如果这个数据只知道了这个主机还没有通信结束，只有把这个数据送交到某一个具体进程，或者说这个进程的具体一个窗口，也就是进程中一个具体线程时，我们才能实现这个通信的过程。所以到网络层，这个通信是没有完成的，还需要到传输层实现进程和进程之间的通信。
2.复用和分用
复用是指发送方不同的进程，比如微信和QQ，它们都可以使用同一个传输层的协议来传送数据。而分用是指接收方在传输层剥离报文的首部后，能把这些数据发给正确的进程。
举个例子，现在我QQ发了一个消息给我朋友1，微信发了一个消息给我朋友2。这两个消息就作为我们传输层的一个传送单元，我们称之为报文段，这些报文段就可以交付给网络层。这一些报文段就可以在链路上进行传输，这实际就是把两个进程的一个数据进行了复用（使用了同一个传输层的协议进行传输）。
同样，如果我们收到了朋友1和朋友2的消息，到了我们主机这里，还要把传送过来的报文段发给对应的进程。
3.传输层对收到的报文进行差错检测
我们在学网络层的时候，学过一个首部校验和。这个校验只是校验头部，没有校验数据部分，那因此就需要传输层来实现对于数据的一个检错，因为网络层的数据部分就是传输层的报文段，因此传输层如果对报文进行了差错检测，那么网络层就不需要再对报文差错检测了，也就只需要检测IP数据报的头部，而不需要检查数据部分。
可见，传输层和网络层一起，就可以实现一个可靠传输的功能。
4.传输层两种协议
当然，这个传输层并不是一定会实现可靠传输的，因为传输层有两种协议一个是TCP，一个是UDP
二、UDP协议 我们说UDP是面向报文的，也就是说UDP对于应用层叫下来的报文既不合并也不拆分，对于报文长度大小不做任何改变，也就是整个应用层的报文都会放到传输层的UDP数据报中。
因此，应用程序一定要选择一个大小合适的报文了。
如果报文太长，UDP把完整的报文装进来并且交给网络层时，网络层就需要分片了。因为接下来要交给链路层，它有一个MTU的要求，所以到网络层这边就需要分片，这样就给网络层的效率造成了影响。
如果报文过小，传输到网络层时，IP数据报的数据部分又比首部少很多。这样也会降低网络层的效率。
另外，我们第三点说UDP面向报文，适合一次性传输少量数据的网络层应用。因为如何太大的话最后还要分片，而由于UDP协议是不可靠的，容易数据丢失，所以我们一次性也不要传输太多，这样损伤可能比较大。
第四点，UDP没有拥塞控制，适合很多实时应用。我们可以试想一下，UDP没有拥塞控制，所以即使再怎么拥塞，UDP也不会让发送方的速率放缓一些，它不会去控制这个问题。
大家可能觉得网络都出现拥塞了为啥不去解决呢？因为有些实时性的应用不允许数据有太大的延迟，但是丢一点是可以的。比如我们开视频会议时，老师在上面讲课，由于听的人比较多，就可能会导致网络出现一定的拥塞问题，比如画面可能卡一些，但是老师可以一直讲。
当然了，如果拥塞太严重，我们也有补救措施，比如向前纠错，或者重传报文。
UDP有8个字节的首部字段，及剩下的数据字段，数据字段是可以为0的。
所以UDP数据报最少可以是8字节。
源端口号是可有可无的，如果我发送的数据报希望接收到对方的回复就给一个源端口号，如果不需要就可以不给源端口号。
目的端口号是一定要有的，不然你怎么知道发给谁呢？
UDP长度是指整个用户数据报的长度，也就是首部+数据字段，比如数据字段7字节，那么UDP长度=8+7=15字节
UDP检验和是在检验整个UDP数据报是不是有出错，也就是包括首部字段和数据字段。
如果发生差错，就会把这个UDP用户数据报给丢弃掉。还有一种出错的情况就是我们在分用的时候，也就是网络层交付给传输层的数据报，这些数据报根据端口号各自去找自己对应的应用进程时，某个UDP数据报找不到自己的目的端口号对应的进程，它就会把该报文丢弃掉，然后给发送方回一个ICMP端口不可达的差错报告报文。
UDP校验过程中，我们在首部前又加了一个伪首部。伪首部其实和IP数据报的首部类似，因为伪首部中包括源IP地址以及目的IP地址。
这里的17是IP数据报首部的协议字段，这个协议字段其实就是在说明数据部分用的是什么字段。
这个伪首部其实它伪的就是这个IP首部，至于伪首部什么时候会出现——只有计算校验和的时候出现，它既不向上递交，也不向下传送。
下面我们来学一下如何用伪首部进行校验
上图是伪首部及UDP用户数据报结合的一个整体，我们要把它看成很多16位的字串连接起来，也就是很多4字节的组成部分。也就是1横条就是4字节。
但是数据部分有时候不一定是4字节，我们就会把这个空用0补全。
三、TCP协议特点和TCP报文段格式 1.TCP是面向连接（虚连接）的传输层协议：
指的是应用程序在使用这个TCP协议之前，必须要先建立好一个TCP连接，在传送数据完毕之后，再释放已经建立的连接。也就是说两个应用类似打电话一样，只有两个人电话打通了才能进行数据传输。
为什么又说是虚连接呢？因为我们建立的连接不是实际一个物理连接。实际的连接过程是把这个数据报加上各个层次的首部之后放到链路上传输，然后再到接收端进一步解封装，这才是一个完整的物理连接。
但是TCP协议的使用就好像两个进程之间建立了一点对另一点的连接，就好像是进程和进程之间的直接连接在一起了，所以我们说是一种虚连接。
2.每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的：
由于每一个TCP连接只能是点对点，一对一的，所以TCP连接没法用于广播或者多播的通信方式。
3.TCP提供可靠交付的服务，无差错、不丢失、不重复、按序到达：
总结就是可靠有序，不丢不重
4.TCP提供全双工通信：
全双工是指发送方和接收方两个角色是不固定的，双方都可以同时发送数据、接收数据。
由于全双工通信的特点，TCP协议连接的两端都会设置发送缓存及接收缓存。
发送缓存：可以想象成一个准备发送数据的队列，其中数据包括准备发送的数据、已发送但未收到确认的数据。
接收缓存：同理就是一个准备接收数据的队列，其中数据包括按序到达但未被接受应用程序读取的数据、不按序到达的数据。只有把数据按顺序排好了，接收方才能逐一的来从接收缓存中取出数据，交付给对应的进程。
5.TCP面向字节流：
流是指流入到进程或者从进程中流出的字节序列，面向字节流是指虽然我们的应用程序与TCP交互是一次发送一个数据块，数据块的大小可以是不一样的。但是TCP会把这个应用程序交付的数据看成一连串的无结构字节流。
举例如下：
现在发送方要发送一个文件，他把这个文件按照字节排序然后编号。在发送的时候就会把这些字节放到TCP缓存中，这是传输层要做的事情。
如下图，这里是把1-10字节放到缓存中等待发送。
如果开始发送，我们可以先取123字节组成一个TCP的报文段，然后在报文段上加上TCP的头部。形成一个完整的报文段后再放到链路上进行传输。
ps：具体一次取多少个字节组成一个报文段是不确定的
可以看出，TCP是面向字节（也可以说是面向字节流的）。
TCP报文段主要是两个部分，一个部分是首部，另一个部分就是数据部分。
在首部，除了有20字节的固定首部，还有选项（长度可变）和填充字段。
填充字段是TCP希望字节的首部是四字节的整数倍，也就是4n字节，所以为了使得添加选项之后还是4n字节，就需要一些填充位。填充我们一般都是填充全0字段。
一行是32位，即4字节，我们上图固定首部有5行，也就是20字节。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59f7a22134e53be3c8990517b63b1f58/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/6/">«</a>
	<span class="pagination__item pagination__item--current">7/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/8/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>