<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fbe8f8510d7e03dd868345c7f074041/" rel="bookmark">
			.NET Core使用NPOI导出复杂，美观的Excel详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 这段时间一直专注于数据报表的开发，当然涉及到相关报表的开发数据导出肯定是一个不可避免的问题啦。客户要求要导出优雅，美观的Excel文档格式的来展示数据，当时的第一想法就是使用NPOI开源库来做数据导出Excel文档（当时想想真香，网上随便搜一搜教程一大堆），但是当自己真正的实践起来才知道原来想要给不同的单元格设置相关的字体样式、边框样式以及单元格样式一个简单的样式需要写这么多行代码来实现。作为一个喜欢编写简洁代码的我而言肯定是受不了的，于是乎提起袖子说干就干，我自己根据网上的一些资料自己封装了一个通用的NPOI导出Excel帮助类，主要包括行列创建，行内单元格常用样式封装（如：字体样式，字体颜色，字体大小，单元格背景颜色，单元格边框，单元格内容对齐方式等常用属性），希望在以后的开发中能够使用到，并且也希望能够帮助到更多有需要的同学。
一、引入NPOI NuGet： NPOI GitHub源码地址： https://github.com/tonyqus/npoi
版本说明： NPOI 2.4.1 （注意不同版本可能使用的姿势有点小差别）
程序包管理器控制台输入一下命令安装： Install-Package NPOI -Version 2.4.1 通过NuGet管理解决方案安装： 选择=&gt;工具=&gt;NuGet包管理器=&gt;程序包管理器控制台： 搜索：NPOI进行安装： 二、导出Excel文档内容展示格式如下如所示： 三、CellStyle单元格常用样式概述： HSSFCellStyle cellStyle = (HSSFCellStyle)workbook.CreateCellStyle(); //创建列头单元格实例样式 cellStyle.Alignment = hAlignment; //水平布局方式（HorizontalAlignment hAlignment） cellStyle.VerticalAlignment = vAlignment; //垂直布局方式（VerticalAlignment vAlignment） cellStyle.WrapText =false;//是否自动换行 //TODO:十分注意，要设置单元格背景色必须是FillForegroundColor和FillPattern两个属性同时设置，否则是不会显示背景颜色 //如下设置黄色背景色 cellStyle.FillForegroundColor = cellBackgroundColor;//单元格背景颜色（short cellBackgroundColor = HSSFColor.Yellow.Index） cellStyle.FillPattern = fillPattern;//填充图案样式(FineDots 细点，SolidForeground立体前景，isAddFillPattern=true时存在（FillPattern fillPattern = FillPattern.SolidForeground） //设置单元格边框样式 //常用的边框样式 None(没有),Thin(细边框，瘦的),Medium(中等),Dashed(虚线),Dotted(星罗棋布的),Thick(厚的),Double(双倍),Hair(头发)[上右下左顺序设置] cellStyle.BorderBottom = BorderStyle.Thin; cellStyle.BorderRight = BorderStyle.Thin; cellStyle.BorderTop = BorderStyle.Thin; cellStyle.BorderLeft = BorderStyle.Thin; //设置单元格边框颜色[上右下左顺序设置] cellStyle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fbe8f8510d7e03dd868345c7f074041/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08abd5f8e36259464fad1a6d7f6680a9/" rel="bookmark">
			Docker安装MS SQL Server并使用Navicat远程连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MS SQL Server简介 Microsoft SQL Server（简称SQL Server）是由微软公司开发的关系数据库管理系统，它是一个功能强大、性能卓越的企业级数据库平台，用于存储和处理大型数据集、支持高效查询和分析等操作。SQL Server 支持广泛的应用程序开发接口（API），包括 T-SQL、ADO.NET、ODBC、OLE DB 等，并支持多种操作系统，包括 Windows、Linux 和 Docker 等。SQL Server 包含许多高级功能和组件，如数据仓库、分析服务、报告服务、全文搜索等，可为企业提供全面的数据管理和分析解决方案。
基于Ubuntu的Microsoft SQL Server官方镜像 mssql-server Docker hub：https://hub.docker.com/_/microsoft-mssql-server
拉取Microsoft SQL Server 2022容器镜像 sudo docker pull mcr.microsoft.com/mssql/server:2022-latest 验证mssql镜像是否成功拉取到本地 使用以下命令来查看mssql镜像是否成功拉取到本地：
docker images 创建并运行一个mssql容器 使用以下命令启动容器（Docker 镜像启动后，将会自动启动 SQL Server），其中 Y.sa123456 为 SQL Server sa 用户的密码：
这个命令的含义是在 Docker 中以后台模式 (-d) 运行 Microsoft SQL Server 2022 的最新版本 (mcr.microsoft.com/mssql/server:2022-latest) 镜像，并将容器命名为 mssql2022 (--name mssql2022)。同时，通过 -p 1433:1433 参数将容器的 1433 端口映射到主机的 1433 端口上，使得可以通过主机的 1433 端口访问 SQL Server。在容器启动过程中，需要设置两个环境变量：ACCEPT_EULA=Y 表示接受使用条款。MSSQL_SA_PASSWORD=Y.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08abd5f8e36259464fad1a6d7f6680a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b60a256da140adbf31ece1f0eefa4433/" rel="bookmark">
			解析数据挖掘：发掘数据中的宝藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据挖掘作为一种从大规模数据中发现模式、规律和知识的技术和方法，已经在各个领域展现了强大的应用价值。本文将从数据挖掘的定义、流程、常用算法以及应用场景等方面进行科普介绍，帮助读者深入了解数据挖掘的概念及其在实际应用中的重要作用。
1. 数据挖掘的定义 数据挖掘（Data Mining）是指从大规模数据中自动发现模式、规律和知识的过程。它利用统计学、机器学习、人工智能等技术和方法，对数据进行分析和挖掘，从中挖掘出有价值的信息和知识，为决策和预测提供支持。
2. 数据挖掘的流程 数据挖掘的一般流程包括以下几个步骤：
数据收集：收集并整理需要挖掘的数据，包括结构化数据和非结构化数据。数据预处理：对数据进行清洗、去重、缺失值处理等预处理操作，以保证数据质量。特征选择：从数据中选择与挖掘目标相关的特征，排除无用的特征，减少数据维度。模型建立：选择合适的挖掘算法，建立预测模型或者分类模型。模型评估：对建立的模型进行评估和验证，检验模型的准确性和泛化能力。结果应用：将挖掘得到的知识和规律应用于实际业务中，进行决策支持或者预测分析。 3. 常用的数据挖掘算法 数据挖掘领域涵盖了多种算法和技术，常用的数据挖掘算法包括：
决策树算法：根据特征属性构建决策树模型，用于分类和预测任务。聚类分析算法：将数据集中的对象划分为若干个组，使得组内的对象相似度高，组间的相似度低。关联规则挖掘算法：用于发现数据集中的频繁项集和关联规则，发现项与项之间的关联关系。神经网络算法：模仿人脑神经元的结构和工作原理，用于处理复杂的非线性关系。 4. 数据挖掘的应用场景 数据挖掘技术已经在各个领域得到了广泛的应用，包括但不限于：
电商领域：利用用户行为数据进行个性化推荐和精准营销。医疗领域：利用医疗数据进行疾病预测、诊断辅助和药物研发。金融领域：利用交易数据进行风险评估、信用评分和欺诈检测。制造业领域：利用生产数据进行质量控制、故障预测和供应链优化。 5. 结论与展望 数据挖掘作为一种发现数据中潜在价值的重要手段，已经在各个领域发挥着重要作用。未来，随着数据规模的不断增大和技术的不断进步，相信数据挖掘技术将会在更多领域得到应用，为人类社会的发展带来更多的创新和进步。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b37bb024f3477953478d610dffc0a3c6/" rel="bookmark">
			免编程经验，搭建宠物店小程序轻松实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在如今的互联网时代，小程序商城已成为各行业推广和销售的热门方式。对于花店来说，搭建一个自己的小程序商城不仅可以提升品牌形象，还可以方便顾客在线选购花卉产品。下面就来教大家如何轻松搭建一个花店小程序商城，并通过引流获得更多的客户！
首先，我们需要登录乔拓云网后台，进入商城管理页面。在商城管理页面中选择小程序商城，并点击进入前往设计。乔拓云网提供了一站式的小程序商城解决方案，无需编程，只需要简单操作就可以完成搭建。
接下来，在模版中心页面中选择适合的模板，并进行编辑制作。模版中心提供了多种风格的模板，既有简约大气的设计，也有精美细致的风格，可以根据花店的特点选择合适的模板。在编辑制作过程中，可以进行文字内容编辑、图片替换、功能模块添加和编辑、页面添加和设置、导航控件设置等。可以根据实际需求进行个性化的设计，使小程序商城更符合花店的品牌形象。
完成小程序商城的制作后，需要进行预览确认无误，并提交审核等待上线。在预览过程中，可以检查各项功能是否正常，页面是否美观，用户体验是否良好。如果有问题可以进行相应的修改和调整，确保小程序商城的质量。
一旦小程序商城通过审核上线后，就可以开始进行引流获客的工作了。首先，可以通过各种渠道宣传推广自己的小程序商城，比如在社交媒体上发布相关内容，与顾客互动交流；还可以通过优惠活动吸引顾客的关注，比如推出特价花束、赠送小礼品等；此外，可以通过与其他商家合作，进行互相推广，扩大影响力。通过这些方式，可以吸引更多的顾客进入小程序商城，提升销售量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f72c1076cd4be0871ac004728a17966/" rel="bookmark">
			机器学习的简单概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单论述机器学习 一、何为机器学习? 机器学习是一种人工智能（AI）的分支，其主要目标是使计算机系统具有从数据中学习并改进性能的能力，而无需明确地进行编程。换句话说，机器学习算法允许计算机系统根据数据中的模式和趋势来自动学习，并且可以根据新数据进行预测或做出决策。
机器学习的主要步骤包括：
数据收集：收集相关的数据，这些数据可以是结构化的（如表格数据）或非结构化的（如文本、图像、音频等）。
数据预处理：对数据进行清洗、转换和归一化等处理，以便更好地适应机器学习模型。
特征工程：选择和提取最相关的特征，以帮助模型更好地理解数据。
模型选择：选择适当的机器学习算法或模型来训练数据，例如决策树、神经网络、支持向量机等。
模型训练：使用训练数据来调整模型参数，使其能够捕捉数据中的模式和规律。
模型评估：使用测试数据来评估模型的性能，并根据评估结果调整模型。
模型部署：将训练好的模型应用于实际场景中，以进行预测或做出决策。
二、机器学习的发展历史？ 机器学习的发展历史可以追溯到20世纪50年代，随着计算机科学和人工智能领域的发展，机器学习逐渐成为一个重要的研究领域。
以下是机器学习的主要发展阶段和里程碑：
起源阶段（1950年代 - 1960年代）：
1950年代中期，Alan Turing提出了著名的“图灵测试”，这可以被视为机器学习的早期启示之一。
1956年夏季达特茅斯会议上，John McCarthy、Marvin Minsky、Nathaniel Rochester和Claude Shannon等人首次提出了“人工智能”（Artificial Intelligence）这一概念，为机器学习的发展奠定了基础。
1959年，Arthur Samuel提出了“机器学习”（Machine Learning）这一术语，并且他的工作主要集中在将机器学习应用于棋类游戏中的自动学习程序。
知识导向阶段（1960年代 - 1980年代）：
60年代至70年代，机器学习主要集中在符号主义学习（Symbolic Learning）和专家系统（Expert Systems）等领域，研究者试图通过手工编写规则和知识来教导计算机执行任务。
1970年代末，出现了基于统计学习的方法，如决策树学习、神经网络等，这些方法为后来的机器学习提供了新的思路。
连接主义和统计学习阶段（1980年代 - 2000年代）：
80年代至90年代，机器学习逐渐从专家系统转向基于连接主义（Connectionism）和统计学习（Statistical Learning）的方法。这一时期出现了多层神经网络、支持向量机、隐马尔可夫模型等经典算法。
1997年，IBM的Deep Blue击败国际象棋世界冠军加里·卡斯帕罗夫，展示了机器学习在复杂游戏中的潜力。
大数据时代（2000年代至今）：
随着互联网的普及和数据的大规模产生，机器学习进入了大数据时代。传统的机器学习算法被应用于海量数据的处理和分析，同时也涌现出了更加复杂的深度学习模型。
2012年，由Geoffrey Hinton领导的团队使用深度学习算法在ImageNet图像识别竞赛中取得了突破性的进展，标志着深度学习技术的崛起。
近年来，深度学习在计算机视觉、自然语言处理等领域取得了一系列重大突破，推动了机器学习技术的发展和应用。
三、机器学习的未来趋势？ 机器学习在未来的发展中可能会涉及以下趋势：
1.深度学习的进一步发展： 深度学习是当前机器学习领域的主要驱动力之一，未来将继续发展。这可能包括更复杂的神经网络架构、更有效的训练技术和更强大的计算平台。
2.自动化机器学习： 自动化机器学习旨在简化机器学习模型的开发和部署过程，使更多的人能够使用机器学习技术，而无需深入了解其内部工作原理。这将涉及自动特征工程、超参数调整和模型选择等方面的自动化。
3.联邦学习和隐私保护： 随着对数据隐私和安全性的关注增加，联邦学习将成为一个重要的研究方向。联邦学习允许在不共享原始数据的情况下训练机器学习模型，从而保护用户的隐私。
4.增强学习的应用拓展： 增强学习是一种通过试错来学习最优决策的方法，在自动驾驶、机器人控制等领域已经取得了成功。未来，增强学习可能会在更多领域得到应用，如资源管理、金融交易等。
5.解释性机器学习： 随着机器学习模型的应用越来越广泛，对模型的解释性和可解释性的需求也越来越强。未来的趋势可能包括开发更加可解释的机器学习模型，并提供对模型决策的解释和可视化。
6.多模态学习： 多模态学习涉及处理多种类型的数据，如图像、文本、音频等，并将它们结合起来进行综合分析。未来，多模态学习可能会在许多领域得到应用，如智能助理、医疗诊断等。
四、机器学习的使用？ 学习和使用机器学习需要掌握一系列的基础知识和技能，并通过实践来提高。以下是一些学习和使用机器学习的步骤：
1.学习基础知识： 掌握数学基础： 线性代数、概率论、统计学等是理解机器学习算法和原理的基础。
学习编程技能： 掌握编程语言（如Python、R）和相关的库（如NumPy、Pandas、Scikit-learn等）以实现机器学习算法。
2.学习机器学习理论： 学习经典机器学习算法： 线性回归、逻辑回归、决策树、支持向量机、神经网络等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f72c1076cd4be0871ac004728a17966/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8975db3cd495d099e0e7b8ba2708384/" rel="bookmark">
			软件设计师软考题目解析03 --每日五题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想说的话：要准备软考了。0.0，其实我是不想考的，但是吧，由于本人已经学完所有知识了，只是被学校的课程给锁在那里了，不然早找工作去了。寻思着反正也无聊，就考个证玩玩。
本人github地址：nanshaws (cover) (github.com)
各位想学习的，可以在上面联系我。
目录
题一
题二
题三
题四
题五
总结
题一 以下不属于软件项目风险的是（）。
A 团队成员可以进行良好沟通
B 团队成员离职
C 团队成员缺乏某方面培训
D 招不到符合项目技术要求的团队成员
答：A ，不属于，肯定是选A呀😍
题二 双端队列是指在队列的两个端口都可以加入和删除元素，如下图所示。现在要求元素进队列和出队列必须在同一端口，即从A端进队的元素必须从A端出、从B端进队的元素必须从B端出，则对于4个元素的序列a、b、c、d，若要求前两个元素（a、b）从A端口依序全部进入队列，后两个元素（c、d）从B端口按次序全部进入队列，则不可能得到的出队序列是（）
A d、a、b、c
B d、c、b、a
C b、a、d、c
D b、d、c、a
答：A，这个简单，知道队列是先进后出，然后看A，a比b还要先出明显不符。😊
题三 在如下所示的数据流图中，共存在（）个错误。
A 4
B 6
C 8
D 9
答：B，结构化分析将数据和处理作为分析对象，数据的分析结果表示了现实世界中实体的属性及其之间的相互关系，而处理的结果则展现了系统及其之间的相互关系，而处理的结果则展示了系统对数据的加工和转换。数据流DF2、DF6和DF7的输入、输出均不是加工，这与“数据流只能和加工或加工流向加工、数据流流向加工或加工流向数据流”相违背。加工P1只有输出，没有输入；加工P3同理，数据流DF4经过加工P4之后没有发生任何改变（因为后面都是到P3的），数据流不应与P4有关。
这样吧，我去借个图，给你们认识一下
该图来自数据流图（DFD） - 知乎 (zhihu.com)
题四 位图与矢量图相比，位图（）
A 占用空间较大，处理侧重于获取和复制，显示速度快
B 占用空间较小，处理侧重于绘制和创建，显示速度较慢
C 占用空间较大，处理侧重于获取和复制，显示速度较慢
D 占用空间较小，处理侧重于绘制和创建，显示速度快
答：A，矢量图形是用一系列计算机指令来描述和记录一幅图的内容，即通过指令描述构成一幅图的所有直线，曲线等。位图图像在计算机内存中由一组二进制位组成，这些位定义图像中每个像素点的颜色和亮度。占用空间大，适合于表现比较细腻，层次较多，色彩较丰富，快速地在屏幕上显示出来，侧重于获取和复制。这个要记住哦😊
题五 计算机感染特洛伊木马后的典型现象是（）
A 程序异常退出
B 有未知程序试图建立网络连接
C 邮箱被垃圾邮箱填满
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8975db3cd495d099e0e7b8ba2708384/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8267756c8abe8138e8f70bab7e2b33e/" rel="bookmark">
			【深度学习】Logistic回归算法和向量化编程。全md文档笔记（代码文档已分享）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本系列文章md笔记（已分享）主要讨论深度学习相关知识。可以让大家熟练掌握机器学习基础,如分类、回归（含代码），熟练掌握numpy,pandas,sklearn等框架使用。在算法上，掌握神经网络的数学原理，手动实现简单的神经网络结构，在应用上熟练掌握TensorFlow框架使用，掌握神经网络图像相关案例。具体包括：TensorFlow的数据流图结构，神经网络与tf.keras，卷积神经网络(CNN)，商品物体检测项目介绍，YOLO与SSD，商品检测数据集训练和模型导出与部署。 全套笔记和代码自取移步gitee仓库： gitee仓库获取完整文档和代码 感兴趣的小伙伴可以自取哦，欢迎大家点赞转发~ 共 9 章，60 子模块 TensorFlow介绍 python 说明TensorFlow的数据流图结构 应用TensorFlow操作图 说明会话在TensorFlow程序中的作用 应用TensorFlow实现张量的创建、形状类型修改操作 应用Variable实现变量op的创建 应用Tensorboard实现图结构以及张量值的显示 应用tf.train.saver实现TensorFlow的模型保存以及加载 应用tf.app.flags实现命令行参数添加和使用 应用TensorFlow实现线性回归
1.2 神经网络基础 学习目标 目标
知道逻辑回归的算法计算输出、损失函数
知道导数的计算图知道逻辑回归的梯度下降算法 知道多样本的向量计算
应用
应用完成向量化运算
应用完成一个单神经元神经网络的结构 1.2.1 Logistic回归 1.2.1.1 Logistic回归 逻辑回归是一个主要用于二分分类类的算法。那么逻辑回归是给定一个 x x x, 输出一个该样本属于1对应类别的预测概率 y ^ = P ( y = 1 ∣ x ) \hat{y}=P(y=1|x) ​y​^​​=P(y=1∣x)。
Logistic 回归中使用的参数如下：
e − z e^{-z} e​−z​​的函数如下
例如：
1.2.1.2 逻辑回归损失函数 损失函数（loss function）用于衡量预测结果与真实值之间的误差。最简单的损失函数定义方式为平方差损失：
L ( y ^ , y ) = 1 2 ( y ^ − y ) 2 L(\hat{y},y) = \frac{1}{2}(\hat{y}-y)^2 L(​y​^​​,y)=​2​​1​​(​y​^​​−y)​2​​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8267756c8abe8138e8f70bab7e2b33e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/916ff658ad7dc1fcd4d96e17fed8d719/" rel="bookmark">
			C# 实现网页内容保存为图片并生成压缩包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
应用场景
实现代码
扩展功能(生成压缩包)
小结 应用场景 我们在一个求职简历打印的项目功能里，需要根据一定的查询条件，得到结果并批量导出指定格式的文件。导出的格式可能有多种，比如WORD格式、EXCEL格式、PDF格式等，实现方式是通过设置对应的模板进行输出，实际情况是，简历的内容是灵活设置的，没有固定的格式，模板数量是不固定的。
通过动态页面技术，可以实现简历配置后的网页内容输出，但制作对应的各种模板会遇到开发效率和服务跟进的问题。为了保障原样输出，折中而简单的方案就是将动态输出的页面转化为图片格式。
实现代码 创建一个 UrlToImage 类，创建实例的时候传递指定的 URL, 并调用 SaveToImageFile（string outputFilename）方法，该方法传递要输出的文件名参数即可即可。
调用示例代码如下：
string url = "https://" + Request.Url.Host + "/printResume.aspx"; UrlToImage uti = new UrlToImage(url); bool irv = uti.SaveToImageFile(Request.PhysicalApplicationPath + "\\test.jpg"); if(bool==false){ Response.Write("save failed."); Response.End(); } 类及实现代码如下：
public class UrlToImage { private Bitmap m_Bitmap; private string m_Url; private string m_FileName = string.Empty; int initheight = 0; public UrlToImage(string url) { // Without file m_Url = url; } public UrlToImage(string url, string fileName) { // With file m_Url = url; m_FileName = fileName; } public Bitmap Generate() { // Thread var m_thread = new Thread(_Generate); m_thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/916ff658ad7dc1fcd4d96e17fed8d719/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f115869cb3ea1ed2ffc46c370f81874b/" rel="bookmark">
			2024.2.23 模拟实现 RabbitMQ —— 实现消费消息逻辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引言
函数式接口
消费者订阅消息 实现思路
关于消息确认
引言 函数式接口 Lambda 表达式的本质是匿名函数Java 函数无法脱离类而存在，所以 Java 通过引入函数式接口以支持 Lambda 表达式 特性：
函数式接口为一个 interface 类该类中有且仅有一个方法该类需加上 @FunctionalInterface 注解 注意：
上述三点其实就是 Lambda 的本质，即底层实现 消费者订阅消息 实现思路 1、让 broker server 把有哪些消费者管理好
消费者调用 basicConsume 方法就是订阅某个指定队列的消息 注意：
消费者是以队列为纬度订阅的一个队列可以有多个消费者 约定 消费者之间按照 轮询 的方式进行消费 代码编写：
定义一个 ConsumerEnv 类，用来描述一个消费者该类中也会包含一些消费者消费过程中用到的数据 import lombok.Data; /* * 表示一个消费者(完整的执行环境) * */ @Data public class ConsumerEnv { private String consumerTag; private String queueName; private boolean autoAck; // 通过这个回调来处理收到的消息 private Consumer consumer; public ConsumerEnv(String consumerTag, String queueName, boolean autoAck, Consumer consumer) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f115869cb3ea1ed2ffc46c370f81874b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/244c6d5726675b414354777d4635c461/" rel="bookmark">
			蛇形矩阵1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 把数1，2，3，…，N*N按照“蛇形1”放入N*N的矩形中，输出结果。
下面是N=10的蛇形1的图示
输入格式 第一行1个正整数：N，范围在[1,100]。
输出格式 N行，每行N个整数。
输入/输出例子1 输入：
5
输出：
1 2 3 4 5 10 9 8 7 6 11 12 13 14 15 20 19 18 17 16 21 22 23 24 25
CODE：
#include&lt;bits/stdc++.h&gt; using namespace std; int t[109][109],s[109][109],l=1,n; int main() { cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { t[i][j]=l; l++; } } for(int i=1;i&lt;=n;i++) { l=n+1; for(int j=1;j&lt;=n;j++) { if(i%2==1)s[i][j]=t[i][j]; if(i%2==0) { l--; s[i][j]=t[i][l]; } } } for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++)cout&lt;&lt;s[i][j]&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/244c6d5726675b414354777d4635c461/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/038e7957c1cb4b40240a86112adbcc83/" rel="bookmark">
			Apache celeborn 安装及使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载安装包 https://celeborn.apache.org/download/ 测0.4.0时出现https://github.com/apache/incubator-celeborn/issues/835
2.解压 tar -xzvf apache-celeborn-0.3.2-incubating-bin.tgz
3.修改配置文件 cp celeborn-env.sh.template celeborn-env.sh cp log4j2.xml.template log4j2.xml cp celeborn-defaults.conf.template cp celeborn-defaults.conf 3.1修改celeborn-env.sh CELEBORN_MASTER_MEMORY=2g CELEBORN_WORKER_MEMORY=2g CELEBORN_WORKER_OFFHEAP_MEMORY=4g 3.2 修改celeborn-defaults.conf # used by client and worker to connect to master celeborn.master.endpoints 10.67.78.xx:9097 # used by master to bootstrap celeborn.master.host 10.67.78.xx celeborn.master.port 9097 celeborn.metrics.enabled true celeborn.worker.flusher.buffer.size 256k # If Celeborn workers have local disks and HDFS. Following configs should be added. # If Celeborn workers have local disks, use following config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/038e7957c1cb4b40240a86112adbcc83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93c4c98499d43c8f01199aa503787ef2/" rel="bookmark">
			Python世界之运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、算术运算符 以下假设变量： a=10，b=20：
运算符
描述
实例
+
加 - 两个对象相加
a + b 输出结果 30
-
减 - 得到负数或是一个数减去另一个数
a - b 输出结果 -10
*
乘 - 两个数相乘或是返回一个被重复若干次的字符串
a * b 输出结果 200
/
除 - x除以y
b / a 输出结果 2
%
取模 - 返回除法的余数
b % a 输出结果 0
**
幂 - 返回x的y次幂
a**b 为10的20次方， 输出 100000000000000000000
//
取整除 - 返回商的整数部分（向下取整）
9//2输出结果为4
-9//2输出结果为-5
注：数除整数，只能得出整数。如果要得到小数部分，把其中一个数改成浮点数即可。
二、比较运算符 以下假设变量a为10，变量b为20：
运算符
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93c4c98499d43c8f01199aa503787ef2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f592d79df54233491caae37b582795bf/" rel="bookmark">
			【数据结构-字符串 五】【字符串转换】字符串转为整数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		废话不多说，喊一句号子鼓励自己：程序员永不失业，程序员走向架构！本篇Blog的主题是【字符串转换】，使用【字符串】这个基本的数据结构来实现，这个高频题的站点是：CodeTop，筛选条件为：目标公司+最近一年+出现频率排序，由高到低的去牛客TOP101去找，只有两个地方都出现过才做这道题（CodeTop本身汇聚了LeetCode的来源），确保刷的题都是高频要面试考的题。
明确目标题后，附上题目链接，后期可以依据解题思路反复快速练习，题目按照题干的基本数据结构分类，且每个分类的第一篇必定是对基础数据结构的介绍。
字符串转为整数【MID】 字符串和栈结合的一道题
题干 题目如下
一些用例的示例：
解题思路 原题解地址，在这里依据题意罗列几个要点：
根据示例 1，需要去掉前导空格；根据示例 2，需要判断第 1 个字符为 + 和 - 的情况，因此，可以设计一个变量 sign，初始化的时候为 1，如果遇到 - ，将 sign 修正为 -1；判断是否是数字，可以使用字符的 ASCII 码数值进行比较，即 0 &lt;= c &lt;= '9'；根据示例 3 ，在遇到第 1 个不是数字的字符的情况下，转换停止，退出循环；根据示例 5，如果转换以后的数字超过了 int 类型的范围，需要截取。这里不能将结果 res 变量设计为 long 类型，注意：由于输入的字符串转换以后也有可能超过 long 类型，因此需要在循环内部就判断是否越界，只要越界就退出循环，这样也可以减少不必要的计算；由于涉及下标访问，因此全程需要考虑数组下标是否越界的情况。 代码实现 给出代码实现基本档案
基本数据结构：字符串
辅助数据结构：无
算法：迭代
技巧：无
import java.util.*; public class Solution { /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * * @param n int整型 the n * @return int整型 */ public int myAtoi(String s) { // 1 初始化下标，并删除下标前的空格 int index = 0; while (index &lt; s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f592d79df54233491caae37b582795bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bca2d9af8a0e7edd07ddc1de329e39b8/" rel="bookmark">
			解读信息系统治理：构建数字化时代的智慧组织
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		信息系统治理作为管理信息系统的一种方法论，旨在确保信息系统的有效运作和最大化业务效益。本文将从信息系统治理的定义、原则、目标以及实践方法等方面进行科普解读，帮助读者更好地理解信息系统治理的重要性及其在数字化时代的应用意义。
1. 什么是信息系统治理？ 信息系统治理（Information Systems Governance）是指对组织内的信息系统进行有效管理和监督的一种方法论。它包括了制定决策、确保资源投入、监督运行和评估绩效等方面，旨在确保信息系统能够对组织的战略目标产生最大化的支持和价值。
2. 信息系统治理的原则 信息系统治理的核心原则包括：
透明度与责任：确保信息系统决策的透明度，明确相关责任人和职责。战略导向：将信息系统治理与组织的战略目标紧密结合，确保信息系统的发展方向与组织战略一致。风险管理：识别和管理信息系统相关的风险，确保信息系统的安全性和可靠性。资源管理：合理配置资源，确保信息系统的投资和运行具有高效性和经济性。绩效评估：建立绩效评估体系，及时监测和评估信息系统的运行状况和业务价值。 3. 信息系统治理的目标 信息系统治理的主要目标包括：
提高业务价值：确保信息系统能够对组织的业务目标产生最大化的支持和价值。降低风险：有效管理和降低信息系统相关的各种风险，保障信息系统的安全性和可靠性。优化资源配置：合理配置信息系统相关的资源，确保资源的最大化利用和效益。提升绩效水平：通过评估和监控，不断提升信息系统的绩效水平，实现持续改进和创新。 4. 信息系统治理的实践方法 信息系统治理的实践方法主要包括：
设立治理结构：建立信息系统治理委员会或者专门的治理机构，明确决策和监督机构。制定治理框架：制定信息系统治理的政策、流程和指南，确保信息系统治理的顺畅运作。风险管理与合规性：建立风险管理和合规性管理体系，及时识别和管理信息系统相关的风险。绩效评估与监控：建立绩效评估和监控机制，定期评估信息系统的运行状况和业务价值。 5. 信息系统治理在数字化时代的意义 在数字化时代，信息系统治理显得尤为重要。随着信息技术的不断发展和应用，信息系统对组织的业务和战略目标的支持作用日益突出。而信息系统治理可以帮助组织更好地管理和利用信息系统，提高业务效率和竞争力，促进组织的可持续发展。
信息系统治理是组织管理信息系统的关键方法论，通过制定政策、监督运行和评估绩效等方式，确保信息系统能够有效运作并为组织的战略目标产生最大化的支持和价值。在数字化时代，信息系统治理的重要性更加凸显，有助于构建数字化时代的智慧组织。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d02222ab52a8c33a26c364d737e0c1bd/" rel="bookmark">
			从0开始python学习-54.python中flask创建MD5和base64加密校验的接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MD5加密接口 import hashlib from flask import Flask, request, jsonify # 初始化一个flask的对象 app = Flask(__name__) # MD5加密校验数据请求 # 定义用户数据 user_data = [ {"username": "admin1", "password": "E10ADC3949BA59ABBE56E057F20F883E"}, # 123456 {"username": "admin2", "password": "C33367701511B4F6020EC61DED352059"} # 654321 ] # 请求接口-form @app.route("/post_md5",methods=['post']) def post_MD5(): username = request.form.get('username') password = request.form.get('password') if not username or not password: return jsonify({'error': '用户名和密码是必填项'}) # 计算密码的MD5哈希值--注意user_data中的password是大写，所以这里需要转成大写 hash_pwd = hashlib.md5(password.encode()).hexdigest().upper() # 遍历用户数据，匹配用户名和密码进行校验 for user in user_data: if user['username'] == username and user['password'] == hash_pwd: return jsonify({'message': '登录成功'}) return jsonify({'error': '用户名或密码不正确'}) if __name__ == '__main__': app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d02222ab52a8c33a26c364d737e0c1bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b61fba87400e2dd16855cc8abaac65d8/" rel="bookmark">
			从0开始python学习-53.python中flask创建简单接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 创建一个简单的请求,没有写方法时默认为get
2. 创建一个get请求
3. 创建一个post请求，默认可以使用params和表单传参
4. 带有参数的post请求
1. 创建一个简单的请求,没有写方法时默认为get from flask import Flask, request # 初始化一个flask的对象 app = Flask(__name__) @app.route("/") def a(): return "简单接口" # 注意一定要有返回 if __name__ == '__main__': app.run() 2. 创建一个get请求 from flask import Flask, request # 初始化一个flask的对象 app = Flask(__name__) @app.route("/get",methods=['get']) def get(): name = request.values.get('name') age = request.values.get('age') if name is None or name == '': return '姓名必填' elif age is None or age == '': return '年龄必填' else: return {'name为:':name,'age为:':age} if __name__ == '__main__': app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b61fba87400e2dd16855cc8abaac65d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ce38518139b10166c8047826ea4148a/" rel="bookmark">
			Python | OS模块操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍 Python的os模块提供了许多与操作系统交互的函数，可以用于文件和目录的操作、进程管理、环境变量的访问等。以下是os模块的一些常用功能：
文件和目录操作：os模块提供了许多函数来进行文件和目录的操作，如创建文件夹(os.mkdir)、删除文件夹(os.rmdir)、重命名文件或文件夹(os.rename)、获取文件或目录信息(os.stat)等。
环境变量：os模块提供了访问和修改环境变量的函数，如获取指定环境变量的值(os.getenv)、设置环境变量的值(os.putenv)等。
进程管理：os模块提供了一些函数来进行进程管理，如启动一个新的进程(os.system)、获取当前进程的ID(os.getpid)、等待子进程结束(os.wait)等。
路径操作：os模块提供了一些函数来进行路径操作，如获取当前工作目录(os.getcwd)、拼接路径(os.path.join)、判断路径是否存在(os.path.exists)等。
杂项操作：os模块还提供了一些其他杂项操作，如执行系统命令(os.popen)、修改文件权限(os.chmod)、获取文件列表(os.listdir)等。
总的来说，os模块提供了许多与操作系统交互的函数，可以帮助我们在Python程序中进行文件和目录操作、进程管理等操作。详细的文档可以在Python官方文档中找到。
二、目录操作 2.1 获取目录 2.1.1 获取当前工作目录绝对路径 os.getcwd() &gt;&gt;&gt; E:\Work\WorkScript 2.1.2 获取当前工作目录绝对路径（Unicode编码） os.getcwdb() &gt;&gt;&gt; b'E:\\Work\\WorkScript' 2.1.3 获取当前目录 os.curdir &gt;&gt;&gt; . 2.1.4 获取当前目录上级目录 os.pardir &gt;&gt;&gt; .. 2.2 判断目录是否存在 os.path.lexists(指定路径) &gt;&gt;&gt; True or False 2.3 获取目录下内容 默认当前目录：
os.listdir() &gt;&gt;&gt; ['.idea', '.venv', 'test.py'] 指定目录：
os.listdir(指定目录) &gt;&gt;&gt; ['.idea', '.venv', 'test.py'] 目录不存在时报错，获取前先判断。
import os if os.path.lexists(指定目录): print(os.listdir(指定目录)) else: print("目录不存在") 2.4 创建目录 目录不存在时报错，创建前先判断。
os.mkdir(指定目录) import os if os.path.lexists(指定目录): print("指定目录已存在") else: os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ce38518139b10166c8047826ea4148a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5439b654a7ca671fee1d3a84566e742f/" rel="bookmark">
			YApi-pro docker安装在centos7上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前安装失败了，只好在docker中装了。
准备环境
1.docker安装
centos7 docker 安装-CSDN博客
2.mongodb数据库docker安装
创建mongo容器目录
mkdir /data/mongo -p
docker pull mongo:4.2.21
创建一个yapi网络插件
docker network create yapi docker run -d \
--name mongodb \
--restart always \
--net=yapi \
-p 2717:27017 \
-v /data/mongo:/data/db \
-e MONGO_INITDB_DATABASE=yapi \
-e MONGO_INITDB_ROOT_USERNAME=yapipro \
-e MONGO_INITDB_ROOT_PASSWORD=yapi2023 \
mongo:4.2.21
容器创建并启动成功
进入mongodb容器
docker exec -it 容器id /bin/bash
mongo
进入了客户端
use admin;
db.auth("yapipro", "yapi2023");
use yapi;
db.createUser({ user: 'yapi', pwd: 'yapi123456', roles: [ { role: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5439b654a7ca671fee1d3a84566e742f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57e9dbf0e793d6ddeffb0358d2172edc/" rel="bookmark">
			centos7 docker 安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.卸载之前docker环境
sudo yum remove docker \
docker-client \
docker-client-latest \
docker-common \
docker-latest \
docker-latest-logrotate \
docker-logrotate \
docker-engine
安装依赖环境
sudo yum install -y yum-utils
配置镜像地址为 阿里的镜像
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
安装docker CE
sudo yum install -y docker-ce docker-ce-cli containerd.io
docker启动
sudo systemctl start docker
验证docker是否启动
docker ps
出现此画面docker启动成功
设置docker 开机自启动
sudo systemctl enable docker
ok
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e034a2bc4e56750795b166cc5d87108/" rel="bookmark">
			小世界网络：直径、分形、同配性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.小世界网络特点 —— 网络直径接近于网络中节点数量的自然对数
2.小世界分形网络 —— 移除弱链接的小世界网络
3.同配性分析 —— Pearson相关系数、邻居相关度
在宏观层面上，关注平均度、度分布和聚类等全局结构特征的影响。更高的平均度被认为会导致更快的扩散（Mukherjee，2014），而度分布为评估不对称影响和扩散时间提供了见解（Dover et al.，2012）。
当假设为同质性时，聚类可以通过同质个体间更有效的通信来加速扩散，或者通过导致网络结构中的冗余结构来限制向大多数网络的扩散（Rogers，2003，p.326）（Bohlmannetal.，2010）。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/4/">«</a>
	<span class="pagination__item pagination__item--current">5/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/6/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>