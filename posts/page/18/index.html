<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e25cb637ce84068faac84a867490e081/" rel="bookmark">
			Linux系统软件工程师/嵌入式Linux应用开发工程师 知识体系构建 500篇（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		包括以下子专栏： - shell基础与实战
- C++编程法则
- C++ STL实战
- 面向对象分析与设计40讲
- Ubuntu/Linux系统管理
- C++并发编程实战
- Linux程序调试与调优
- Linux网络编程实战
- cmake从入门到实战
- git面向工作使用教程
- C++模板元编程
2024年完成1000篇之后的计划是，将每一个子专栏录制成视频教程，敬请期待...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0e53aceb01c00923fe7662c340128a3/" rel="bookmark">
			【leetcode】轮转数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是苏貝，本篇博客带大家刷题，如果你觉得我写的还不错的话，可以给我一个赞👍吗，感谢❤️
目录 1.三步旋转法2.利用额外的数组 点击查看题目
1.三步旋转法 根据大数据运算可得到以下规律，采用下面的三步旋转即可得到旋转后的数组
void reverse(int* nums,int left,int right) { while(left&lt;right) { int tmp=nums[left]; nums[left]=nums[right]; nums[right]=tmp; left++; right--; } } void rotate(int* nums, int numsSize, int k) { k %= numsSize; reverse(nums,0,numsSize-k-1); reverse(nums,numsSize-k,numsSize-1); reverse(nums,0,numsSize-1); } 2.利用额外的数组 我们可以知道，数组元素经过轮转后下标为原下标i+k再整体%numsize
void rotate(int* nums, int numsSize, int k) { k %= numsSize; int* newArr=(int*)malloc(sizeof(int)*numsSize); for(int i=0;i&lt;numsSize;i++) { newArr[(i+k)%numsSize]=nums[i]; } for(int i=0;i&lt;numsSize;i++) { nums[i]=newArr[i]; } } 好了，那么本篇博客就到此结束了，如果你觉得本篇博客对你有些帮助，可以给个大大的赞👍吗，感谢看到这里，我们下篇博客见❤️
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae5458a45e30b09775b2c3098518cf16/" rel="bookmark">
			【Spring Boot 源码学习】ApplicationListener 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《Spring Boot 源码学习系列》
ApplicationListener 详解 引言往期内容主要内容1. 初识 ApplicationListener2. 加载 ApplicationListener3. 响应应用程序事件 总结 引言 书接前文《初识 SpringApplication》，我们从 Spring Boot 的启动类 SpringApplication 上入手，了解了 SpringApplication 实例化过程。其中，《BootstrapRegistryInitializer 详解》 和 《ApplicationContextInitializer 详解》博文中，Huazie 已经带大家详细分析了 BootstrapRegistryInitializer 和 ApplicationContextInitializer 的加载和初始化过程，如下还有 2.5 还未详细分析：
那本篇博文就主要围绕 2.5 的内容展开，详细分析一下 ApplicationListener 的加载和处理应用程序事件的逻辑。
往期内容 在开始本篇的内容介绍之前，我们先来看看往期的系列文章【有需要的朋友，欢迎关注系列专栏】：
Spring Boot 源码学习 Spring Boot 项目介绍 Spring Boot 核心运行原理介绍 【Spring Boot 源码学习】@EnableAutoConfiguration 注解 【Spring Boot 源码学习】@SpringBootApplication 注解 【Spring Boot 源码学习】走近 AutoConfigurationImportSelector 【Spring Boot 源码学习】自动装配流程源码解析（上） 【Spring Boot 源码学习】自动装配流程源码解析（下） 【Spring Boot 源码学习】深入 FilteringSpringBootCondition 【Spring Boot 源码学习】OnClassCondition 详解 【Spring Boot 源码学习】OnBeanCondition 详解 【Spring Boot 源码学习】OnWebApplicationCondition 详解 【Spring Boot 源码学习】@Conditional 条件注解 【Spring Boot 源码学习】HttpEncodingAutoConfiguration 详解 【Spring Boot 源码学习】RedisAutoConfiguration 详解 【Spring Boot 源码学习】JedisConnectionConfiguration 详解 【Spring Boot 源码学习】初识 SpringApplication 【Spring Boot 源码学习】Banner 信息打印流程 【Spring Boot 源码学习】自定义 Banner 信息打印 【Spring Boot 源码学习】BootstrapRegistryInitializer 详解 【Spring Boot 源码学习】ApplicationContextInitializer 详解 主要内容 注意： 以下涉及 Spring Boot 源码 均来自版本 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae5458a45e30b09775b2c3098518cf16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e367c8a55cf0d0cc31d8eabb08004a3/" rel="bookmark">
			什么是低代码？一款很火的物联网低代码开发平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以速度为后盾的创新是当今各种规模组织的基础。在这个持续数字化变革的时代，每个组织都必须随时准备创新。低编码就是这样的创新。Gartner 预测，到 2024 年，65% 的应用程序开发项目将依赖于低代码开发。
什么是低代码？ 低代码(Low Code)是一种可视化的软件开发方法，通过最少的手动编码可以更快地交付应用程序。低代码平台的图形用户界面和拖放功能可自动执行开发过程的各个方面，从而消除对传统计算机编程方法的依赖。
什么是低代码平台？ 低代码开发平台(Low-Code Development Platform，LCDP)就是使用低代码的方式进行开发，能快速设置和部署的平台。这些平台通常提供可视化的开发工具和预构建的模块，允许开发者通过图形界面和预构建的模块来构建应用程序，而不需要编写大量的代码。
低代码开发平台旨在简化应用开发过程，降低开发难度，缩短开发周期，提高开发效率，并使非专业程序员(如业务分析师、产品经理等)也能够参与到应用开发中。其中完全不用写代码，通过可视化工具就能进行应用程序开发的，称为无代码开发平台(No-Code Development Platform，NCDP)。无代码开发平台属于低代码开发平台。
低代码平台主要特点？ 可视化开发：低代码开发平台提供可视化的开发界面，用户可以通过拖拉拽组件和系统配置的参数等方式来构建应用程序的功能和页面;
组件库丰富：组件库内有常见的表格、表单、图表、富文本、图片等等组件，用户根据需要选择合适的组件构建对于的应用即可;
自定义扩展：低代码平台支持自定义扩展组件，用户可根据需求编写组件，扩展功能;
什么是低代码物联网平台？ 低代码物联网平台是一种开发平台，它使开发人员能够使用图形界面和可视化模型来设计和构建物联网应用程序，而不需要编写大量的代码。这些平台通常提供一系列预先构建的模块和工具，使开发人员可以快速构建应用程序，同时提供必要的安全性和可靠性。
低代码开发平台在物联网领域应用广泛，包括智能制造、智慧物流、智慧交通、智慧城市、智慧医疗、智慧教育、智慧园区、智慧矿山等等。
物联网低代码开发平台 Sovit2D 低代码平台介绍 Sovit2D 是长沙数维图信息科技有限公司自主研发的新一代拖拽式前端可视化产品，可灵活、快捷地设计各类交互式前端常规屏和大屏可视化效果，强大的Web绘图工具，具有广泛的设计功能，提供丰富的行业标准元器件图元库及多行业模板和组件，在浏览器端即可完成便捷的人机交互，简单的拖拽即可完成可视化页面的编排设计，可快速构建现代化的SCADA、HMI、仪表板、IIOT系统等，广泛应用于工业、水利、电力、能源、油气、环境、园区、交通等领域。Sovit2D具有跨平台、简单、高效、与外部系统易对接等特点，最大程度减少企业研发和运维的成本，即便是没有编程基础也可零代码轻松开发实现Web组态、SCADA等。
Sovit2D 低代码平台特点 私有化部署
消除客户对数据存储安全性的顾虑——在决定Sovit2D技术选型之初，考虑到客户对数据的安全与隐私有顾虑，同时客户需要积累自己的用户行为数据资产，对数据深度应用与功能二次开发，因此我们将私有化部署作为Sovit2D数据的产品核心设计理念。
可视化编辑
支持灵活的自由式布局、组件化的设计使设计更加方便、丰富的组件库涵盖各行业模型组件，用户也可以自定义组件，以及对组件进行属性、数据、动画，事件等设置。用户只需通过简单的拖拉拽及配置几分钟上手就可以快速地制作出一张敏捷数据动态可视化模型页面。
数据源绑定
提供多种数据源与外部系统通过界面配置进行无缝对接，致力于开发人员或用户0代码即可开发数据可视化展示平台。
交互式动效
通过设置实现Web场景中图形的动画效果如旋转、变色、闪烁、心跳、报警、高度变化、水管流动、沿轨道移动等各种动画，让你的页面展现更加的生动。同时这些动画可以通过与后台数据绑定，由数据触发动画的执行，比如可以根据数据的大小控制旋转的速度，根据状态数据的切换控制闪烁效果或者报警效果等，以此实现模拟实际运行效果的目的。
Sovit2D 低代码平台示例 Sovit2D前端接口采用标准HTML5开发，支持2D/3D图形配置、Mqtt协议访问。配置界面可单独发布，可与企业自有平台无缝集成，并可轻松与用户自有系统集成为综合应用平台。
智慧电厂调峰控制系统
智慧化工沥青生产监测系统
智慧充电桩实时监控系统
循环水泵房控制系统
综上所述，在工业应用领域，低代码技术的应用价值非常重要。通过低代码技术，我们可以打破传统的开发和运维模式，实现工业互联网应用的快速、高效和质量保障。
如果您有项目正在沟通或者正在开发，作为全新一代物联网、工业互联网Web前端可视化低代码开发平台，Sovit2D绝对是个不错的选择，目前行业中流行的部分可视化工具，有的专注于可视化报表，有的专注大屏，有的专注于3D……而数维图依据多年开发经验，自主研发了SovitChart、Sovit2D、Sovit3D可视化工具，集报表/大屏、2D组态、三维可视化等于一身，使用更便捷，维护更简单。
相信看到这，大家都有跃跃欲试的冲动。
我们期待着数维图的可视化产品能够与你的业务场景深度结合，助力客户业务高速发展。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7959f3f597c9dc08f477849fae213c40/" rel="bookmark">
			JAVA 2个集合差集交集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 创建第一个集合 List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); list1.add(1); list1.add(2); list1.add(3); // 创建第二个集合 List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;(); list2.add(2); list2.add(4); list2.add(5); // 将第一个集合转换为 HashSet Set&lt;Integer&gt; set1 = new HashSet&lt;&gt;(list1); // 将第二个集合转换为 HashSet Set&lt;Integer&gt; set2 = new HashSet&lt;&gt;(list2); // 计算差集并输出结果 set1.removeAll(set2); System.out.println("1相对于2差集为：" + set1); 结果：
1相对于2差集为：[1, 3]
而2相对于1差集为：
// 创建第一个集合 List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); list1.add(1); list1.add(2); list1.add(3); // 创建第二个集合 List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;(); list2.add(2); list2.add(4); list2.add(5); // 将第一个集合转换为 HashSet Set&lt;Integer&gt; set1 = new HashSet&lt;&gt;(list1); // 将第二个集合转换为 HashSet Set&lt;Integer&gt; set2 = new HashSet&lt;&gt;(list2); // 计算差集并输出结果 // set1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7959f3f597c9dc08f477849fae213c40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29204ba8b389a4467f9691ea345a4b5d/" rel="bookmark">
			关于互联网金融贷款业务的整体梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：在互金公司做抵押贷款两年多时间，从贷前用户进件，审批流程，到贷后用户还款入账，结清资产，与第三方资方对接全流程参与需求评审，设计，开发，测试，上线。现在要离开公司，想以自己工作的经历，总结一下金融行业贷款业务的整体流程。提供一些设计思路，以及一些设计原则，提高自己的代码设计，业务理解能力。 整体概述 贷款，是指根据国家政策以一定的利率将资金贷放给资金需要者，并约定期限归还的一种经济行为。从这句话中不难看出，互联网贷款，就是用户通过系统，然后系统把钱借给用户，根据国家规定的利率，采取不同的收取策略，对借出资金进行回收。现在贷款种类根据是否只需要用户信用情况信息进行担保，分为信用贷款，和抵押贷款。抵押贷款是根据用户提供的抵押物，评估价值，根据价值给用户提供一个可以提款的额度，用户只可以借款额度以内的金额，并且使用。本文主要以抵押消费贷的视角进行阐述。如果公司想要在公开渠道发行这款产品，必须是要在银保监进行备案，并且获得互联网消费金融牌照才行。
详细描述 关于互联网金融贷款业务，可以大体分为两个部分，一个是贷前，一个贷后。从名字就能知道，一个是贷款动作完成之前的业务，一个是贷款动作完成之后的业务。贷款之前，主要是客户与系统交互，从用户引流，用户信息资料获取，用户征信信息获取，借款合同签署，用户额度授信，用户银行卡绑卡，用户用款申请，到最终审批放款，至此贷前业务完成，在这个阶段，基本上是系统数据的初始化阶段，包括用户基础信息，授信信息，用户借款信息，用户应还款信息，初始化到数据库中，后续的贷后业务，基本上都是围绕着这些基础信息进行操作以及处理。贷款放款之后，就到了资产回收，入账销账，贷后管理，内部系统数据同步等阶段，说直白一点就是系统处理用户还款信息，保证借款按照合同所约定的情况进行还款，尽量保证公司的资产不受损失。
贷前 由此可以看到，整个贷前业务呈现线性结构，所以通常以流程引擎为基础开发框架，配合业务系统，来完成每个业务节点需要完成的业务需求，和审批需求，提高开发效率。在不同的节点需要调用不同的第三方或内部系统，并且如果是不同的金融产品，在业务节点上相同，但是具体实现是不同的，所以此处采用模版方法以及工厂模式的开发模式可以极大的提高代码的复用率以及可读性。
贷后 整个贷后业务在业务上比较复杂，主要是针对用户的还款计划进行处理还款，保证公司资产不受损失，此时要考虑用户还款逾期，用户部分还款，用户生成账单，但是隔一段时间还款造成数据异常等情况。用户提前结清过程中，要计算用户提前结清的违约金等。然后用户还款核销入账后，需要修改的表包括还款计划，还款历史，用户借款合同，数据上报等表，是一个超长的事务，不可避免的可能会产生事务问题，如果是跨越多个微服务，还可能会产生分布式事务的问题，所以在设计过程中，要计算好，在哪个事务不会影响其他事务的处理，或者哪些数据是一定需要保证成功的，要保证每个流程互不关联，不需要等待哪个业务完成后，才能完成后续的业务，提高系统的可用性。
增强设计 从上面的流程可以看出来，围绕了一个金融产品，并且全程没有其他公司或者集团进行参与的流程，全部是公司内部自我的业务。但是在金融行业，公司与公司合作，公司对公司投资的行为普遍存在，并且抵押贷算是比较优质的金融产品，所以在真正的场景中，经常会有几种产品模式。第一种，直接对接贷前，用户信息注册，也会在第三方资金方系统注册，其他贷前业务流程也会在第三方资金方中进行，最后放款由两方合资，或者一方独资，最后，将贷后业务进行组合，由我方管理，就提供能力，在收到款的同时，进按合同规定的资金分润比例同时打到第三方资金方的银行卡上，或者记录每一笔收益，等月底进行统一的资金分润，通过线下方式转入对方对公账户。第二种，只对接贷后，这样的资产方归属全部是我方，用户借款信息就是我们的真实资产，这个时候我们就可以对这些资产进行直接的转让，这种行为被称为债转，改变了资产的所有方，但是贷后的管理可以发生变化，也可以不发生变化，不发生变化就是和直接对接贷前一样进行收益分润。如果将贷后管理同时转让给第三方，第三方对资产进行还款处理，就必须考虑还款信息的同步策略。如果资产发生逾期，并且逾期期数过大，这种就被称为不良资产，如果不良资产过大，资金的损失概率变大，是所有第三方公司不愿意看到的，这种时候就会要求我方将这些资产买回来，变为自己的资产，这个业务就被称为回购，此时的资产归属方就又变为我方或者其他方。
其实在后续还有很多业务，包括几期的时候如果资金不足，可能不用全部回购，选择按期代偿可以减少不良资产的回购率。第三方拿到这些资产，可以进行打包成金融产品，基金信托服务，进行售卖等等 ，这些业务我接触不太深入，就不在这赘述。
总结 互金系统的业务属性很稳定，不太可能有大批量全新的业务需求出现对行业造成冲击，所以保证系统的稳定性以及高吞吐率是重中之重。由此，在进行互金系统架构过程中，设计模式，中间件的高可用性，微服务熔断降级，分布式事务等是优先考虑的问题，业务基本上都是业界可循。如果抽空可以整理下思路，对互金系统进行微服务划分，关键点设计进行总结。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e3998a331f822ef6be23834c39c0afa/" rel="bookmark">
			栈-后进先出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、基本概念 栈只允许访问一个数据项：即最后插入的一个元素。只有移除最后一个元素之后，才能访问倒数第二插入的元素。
2、代码实现 public class Stack { public static void main(String[] args) { Stack stack = new Stack(10); //入栈 for (int i = 0; i &lt; 10; i++) { stack.push(i); } //出栈 while (!stack.isEmpty()) { System.out.println(stack.pop()); } } private long data[]; private int top; private int capacity; public Stack(int capacity) { this.capacity = capacity; data = new long[capacity]; top = -1; } //入栈 public void push(long value) { if (top == capacity - 1) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e3998a331f822ef6be23834c39c0afa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30dedc493303785b44331137d122c908/" rel="bookmark">
			【leetcode】移除元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是苏貝，本篇博客带大家刷题，如果你觉得我写的还不错的话，可以给我一个赞👍吗，感谢❤️
目录 一.暴力求解法二.使用额外数组三.原地修改数组 点击查看题目
一.暴力求解法 若我们不考虑时间复杂度，第一想到的方法应该都是暴力求解法吧：遍历数组，如果数组元素=val，用后面的元素将之覆盖。比较简单也不符合题意，就不写代码了
二.使用额外数组 第二种方法不符合题意，但由于能启发第三种方法，所以简单介绍一下
先创建一个元素个数大于或等于nums数组的数组tmp，src和dst分别是数组nums和tmp的下标，初始化都=0，当nums[src]不等于val时，将之拷贝到tmp数组中，拷贝的位置为tmp[dst]，再src++，dst++；当nums[src]等于val时，直接src++。
时间复杂度为O(N)，空间复杂度为O(N)
三.原地修改数组 创建变量src和dst，它们都是数组nums的下标，初始化都为0，当nums[src]不等于val时，让nums[dst]=nums[src]，再src++，dst++，相当于src位置的元素保留；当nums[src]等于val时，直接src++，相当于src位置的元素被移除
int removeElement(int* nums, int numsSize, int val) { int src=0; int dst=0; for(int i=0;i&lt;numsSize;i++) { if(nums[src]!=val) { nums[dst++]=nums[src++]; } else { src++; } } return dst; } 好了，那么本篇博客就到此结束了，如果你觉得本篇博客对你有些帮助，可以给个大大的赞👍吗，感谢看到这里，我们下篇博客见❤️
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b61b0171f074c4d0283ef97e5a85da52/" rel="bookmark">
			【数据结构】时间复杂度和空间复杂度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是苏貝，本篇博客带大家了解时间复杂度和空间复杂度，如果你觉得我写的还不错的话，可以给我一个赞👍吗，感谢❤️
目录 一.算法效率1.衡量一个算法的好坏2.算法的复杂度 二.时间复杂度1.时间复杂度的概念2.大O的渐进表示法3.常见时间复杂度计算举例 三.空间复杂度 一.算法效率 1.衡量一个算法的好坏 如何衡量一个算法的好坏呢？比如对于以下斐波那契数列：
long long Fib(int N) { if(N &lt; 3) return 1; return Fib(N-1) + Fib(N-2); } 斐波那契数列的递归实现方式非常简洁，但简洁一定好吗？那该如何衡量其好与坏呢？
2.算法的复杂度 算法在编写成可执行程序后，运行时需要耗费时间资源和空间(内存)资源 。因此衡量一个算法的好坏，一般
是从时间和空间两个维度来衡量的，即时间复杂度和空间复杂度。
时间复杂度主要衡量一个算法的运行快慢，而空间复杂度主要衡量一个算法运行所需要的额外空间。在计算机发展的早期，计算机的存储容量很小。所以对空间复杂度很是在乎。但是经过计算机行业的迅速发展，计算机的存储容量已经达到了很高的程度。所以我们如今已经不需要再特别关注一个算法的空间复杂度。
二.时间复杂度 1.时间复杂度的概念 时间复杂度的定义：在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。一个算法执行所耗费的时间，从理论上说，是不能算出来的，只有你把你的程序放在机器上跑起来，才能知道。但是我们需要每个算法都上机测试吗？是可以都上机测试，但是这很麻烦，所以才有了时间复杂度这个分析方式。一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法的时间复杂度。
即：找到某条基本语句与问题规模N之间的数学表达式，就是算出了该算法的时间复杂度。实际中我们计算时间复杂度时，我们其实并不一定要计算精确的执行次数，而只需要大概执行次数，那么这里我们使用大O的渐进表示法。
2.大O的渐进表示法 大O符号（Big O notation）：是用于描述函数渐进行为的数学符号。
推导大O阶方法：
1、用常数1取代运行时间中的所有加法常数，即O(1)，它并不是代表1次，而是常数次
2、在修改后的运行次数函数中，只保留最高阶项，即只取确定性的那项，去掉了那些对结果影响不大的项。
3、如果最高阶项存在且不是1，则去除与这个项相乘的常数。得到的结果就是大O阶。
另外有些算法的时间复杂度存在最好、平均和最坏情况：
最坏情况：任意输入规模的最大运行次数(上界)
平均情况：任意输入规模的期望运行次数
最好情况：任意输入规模的最小运行次数(下界)
例如：在一个长度为N数组中搜索一个数据x
最好情况：1次找到，最坏情况：N次找到，平均情况：N/2次找到
在实际中一般情况关注的是算法的最坏运行情况，所以数组中搜索数据时间复杂度为O(N)
3.常见时间复杂度计算举例 示例1：
// 计算Func2的时间复杂度？ void Func2(int N) { int count = 0; for (int k = 0; k &lt; 2 * N; ++k) { ++count; } int M = 10; while (M--) { ++count; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b61b0171f074c4d0283ef97e5a85da52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2077aa21a718b909c2fcc7f7df38f7d3/" rel="bookmark">
			实现linux cp指令的代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现思路：
1、打开demo1.c文件
2、把demo1.c文件中的内容写到buf上
3、创建/打开demo2.c文件
4、把写入的buf中的文件内容读取到demo2.c中
5、关闭两个文件
引入main函数标准原型：
main(int argc, char **argv, char **enpv);或者main(int argc, char *argv[], char *enpv[]);
int argc：整型，其中包括的是命令行参数的个数（如下图展示）
char **argv：二维的char型指针，存放命令行参数字符串
char **enpv：二维的char型指针，存放环境变量
#include&lt;stdio.h&gt; int main(int argc,char *argv[]) { printf("参数总个数是:%d\n",argc); printf("第一个参数是:%s\n",argv[0]); printf("第二个参数是:%s\n",argv[1]); printf("第三个参数是:%s\n",argv[2]); return 0; } 程序运行的结果：./a.out demo1 demo2 参数总个数是:3 第一个参数是:./a.out 第二个参数是:demo1 第三个参数是:demo2 实现cp指令代码
#include&lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include&lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include&lt;string.h&gt; int main(int argc,char *argv[])//argc表示参数的个数，argv表示字符串数组是二级指针 { int fd; int fd2; int size; int n_read; int n_write; char*readbuf=NULL; if(argc!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2077aa21a718b909c2fcc7f7df38f7d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0163692b90da0fee67fbde1c4f26252/" rel="bookmark">
			删除顺序表表中值为X的数据元素，要求时间复杂度为O(n)，空间复杂度为O(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要求时间复杂度为O(n)那么要求你所实现的算法只包含一层for循环，也就是说一需要在一轮扫描中完成删除所有的值为X的数据元素的操作，空间复杂度为O(1)要求你不能借助另一个数组来实现此算法
算法思路：用一个变量来记录当前已经扫描到的值为X的数据元素的个数，然后将当前的数据元素向前移动k个位置
代码实现步骤 1、定义顺序表 //定义顺序表 typedef struct { int data[MAX]; int length; }sqList; 2、实现InitList操作 //对顺序表进行初始化 void InitList(sqList&amp; L) { L.length = 0; } 3、实现 listInsert操作
//向顺序表中的指定位置插入指定值 bool listInsert(sqList&amp; L, int i, int e) { if (i&lt;1 || i&gt;L.length + 1) return false; for (int j = L.length; j &gt;= i; j--) { L.data[j] = L.data[j - 1]; } L.data[i - 1] = e; L.length++; } 4、算法实现
//删除顺序表中值为X的数据元素，要求算法性能要好，时间复杂度为O(n),空间复杂度为O(1) void deleteX(sqList&amp; L, int x) { int x_num = 0; //记录当前已经扫描到的顺序表中值等于x的数据元素个数 for (int i = 0; i &lt; L.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0163692b90da0fee67fbde1c4f26252/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a780a39552a99234dfd157a50d072df9/" rel="bookmark">
			linux内核配置——树莓派3B&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树莓派内核文件的获取 如果想要树莓派的内核文件，可以到
Raspberry Pi · GitHub
中选择linux（在连接树莓派的终端中利用指令uname -r来知道自己的树莓派版本）
选择对应的版本，在code里选择download.zip下载压缩包，放到windows中自己之前弄过的共享文件夹中，方便在Ubuntu中文件的传递
我们把下载好的压缩包放在一个创建好的文件夹中（SYSTEM），解压，目的是为了后续配置文件做好准备
驱动代码的编写 驱动代码的编译需要一个提前编译好的内核
编译内核就需要配置
配置的最终目标会生成.config文件，该文件指导Makefile去把有用的东西组织成内核
第一种方式：
厂家配linux内核源码，比如买树莓派，树莓派的linux内核源码商家会一并给你
查找各种内核源码的指令是：find -name *_defconfig
配置对应的内核源码：
cp 厂家.config .config
第二种方式：
make menuconfig 一项项配置，通常是基于厂家的config来配置
第三种方式：
完全自己来
我们把这个为什么配置以及方式有哪几种说清楚后，开始我们的配置工作
如何配置树莓派的linux内核 参考博文 树莓派-内核开发-说明 下载代码 编译 替换内核_树莓派-内核开发-说明 下载代码 编译 替换内核 nicekwell-CSDN博客
1、配置交叉编译（之前有记笔记，或者点击上述链接进入后进行配置） 2、配置config Linux源码中有很多工程：
树莓派1的工程是bcmrpi_defconfig
树莓派2,3的工程是bcm2709_defconfig
我们选择使用源码里自带的config（内核配置）
ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=
指定ARM架构 指定编译器 树莓派 kernel7 make bcm2709_defconfig
主要核心指令
注：上面这个指令不是分段进行
完整指令如下：
ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make bcm2709_defconfig
（当然我的建议是先把下面提到的树莓派linux内核编译提到的必要的库安装完成之后在执行这个指令）
这个指令在/home/wbw/SYSTEM/linux-rpi-4.14.y这个目录下进行
注：在你自己解压好的内核源码目录下也就是（linux-rpi-4.14.y）我之所以是4.14是因为我的树莓派版本是4.14，前面有提到。
此命令功能是获取bcm2709_defconfig的配置到.config里
树莓派linux内核编译 安装必要的库： sudo apt-get install bc
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a780a39552a99234dfd157a50d072df9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5882ba836457dbff58183445257e74bd/" rel="bookmark">
			关于树莓派3B&#43;内核配置遇到的一个问题——nl80211
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		咱先看我配置好之后用mobaxterm串口打开后遇到问题的情况吧
我也是在发现无法用SSH登录树莓派的时候，被告知无法连接，于是重新用串口连接，使用指令ifconfig发现我的wlan0不见了，一开始我以为是无线射频被锁起来了
然后用sudo ifconfig -a指令发现依旧没有，是将截图发给朋友看了之后，给了我上面这个提示，告诉我我的内核驱动没拷贝进去
于是我回到vmware去将拷贝配置相关文件步骤重新拷贝一遍，然后直接将读卡器给拔出了
回到mobaxterm串口继续登录，发现问题依旧没解决，于是上网查找了很多资料，最后定格在了两个可能
第一个可能：挂载过多
我回到vmware，等待TF卡接到linux交叉编译的主机上之后，先用dmesg查看设备时候存在
然后用lsblk指令查看识别到的TF卡设备节点，正常情况下TF卡设备会自动挂载到/media/{当前用户目录}/下的boot和rootfs目录下，这个时候就没必要在自己重新创建目录进行挂载了
linux@ubuntu:~/linux$ lsblk
NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
sda 8:0 0 20G 0 disk └─sda1 8:1 0 20G 0 part /
sdb 8:16 1 14.6G 0 disk ├─sdb1 8:17 1 256M 0 part /media/wbw/boot
└─sdb2 8:18 1 3.3G 0 part /media/wbw/rootfs
第二个可能，在完成一切操作之后，没有做卸载操作
也就是指令
umount /home/wbw/data1
umount /home/wbw/data2
当然，如果是自动挂载，那就执行
umount /media/wbw/boot
umount /media/wbw/boot
基于以上两种可能性，重新拷贝一遍应该就能解决问题了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6861613a96213bf795659c65c3678801/" rel="bookmark">
			linux 完全卸载docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Linux系统中，要完全无残留地卸载Docker及其所有相关组件，请遵循以下详细步骤：
1、停止 Docker 服务： sudo systemctl stop docker 2、停止并禁用 Docker 相关的守护进程（如果适用）： sudo systemctl disable docker sudo systemctl stop containerd sudo systemctl disable containerd # 对于使用containerd作为runtime的情况 3、删除所有正在运行的容器、网络和镜像： sudo docker container stop $(docker container ls -aq) sudo docker container rm $(docker container ls -aq) sudo docker image prune -a --force sudo docker network prune --force 4、卸载 Docker 软件包： 对于通过yum或dnf安装的RHEL/CentOS系统：
sudo yum remove docker-ce docker-ce-cli containerd.io docker-compose-plugin \ docker-distribution docker-rhel-push-plugin sudo yum autoremove 对于使用apt安装的Ubuntu/Debian系统：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6861613a96213bf795659c65c3678801/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd8eec9bfb226c094db8b8c89b79422d/" rel="bookmark">
			Python笔记（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人学习笔记（整理不易，有帮助点个赞）
笔记目录：学习笔记目录_pytest和unittest、airtest_weixin_42717928的博客-CSDN博客
目录
一：简单了解一下Python
二：安装
三：Python解析器
四：命令行模式和Python交互模式
五：执行.py文件(在命令行模式执行)
六：编辑器
七：输出
八：输入
一：简单了解一下Python 编写的代码少（代码库完善），速度慢（因为Python是解释型语言，代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时），代码不能加密（发布Python程序就是发布源代码）。
Python是跨平台的，它可以运行在Windows、Mac和各种Linux/Unix系统上。
二：安装 安装Python，会得到Python解释器（就是负责运行Python程序的），一个命令行交互环境，还有一个简单的集成开发环境。
官网：Welcome to Python.org
x86是32位，x86-64是64位
embeddable zip file：嵌入式版本，可集成到其它应用中 web-based installer：要联网安装 executable installer：可执行文件(*.exe)方式安装 安装完成
安装成功后，打开命令提示符窗口，敲入python后，会出现两种情况：
显示python的版本信息，说明安装成功
如果安装时候没有勾选那个，那就要手动配置环境变量：
可以参考百度安全验证
你看到提示符&gt;&gt;&gt;就表示已经在Python交互式环境中了，可以输入任何Python代码，回车后会立刻得到执行结果。
输入exit()并回车，就可以退出Python交互式环境（直接关掉命令行窗口也可以）
三：Python解析器 安装Python，会得到一个官方版本的解释器：CPython
Python文件是以后缀.py为扩展名的文本文件
要运行代码，就需要Python解释器去执行.py文件
四：命令行模式和Python交互模式 命令行模式：
Python交互模式，它的提示符是&gt;&gt;&gt;
在Python交互模式下输入exit()并回车，就退出了Python交互模式，并回到命令行模式
五：执行.py文件(在命令行模式执行) 在桌面新建一个文件，内容如下，重命名为hw.py(注意后缀是py)
原因是路径问题
注意：
Python交互模式的代码是输入一行，执行一行
命令行模式下直接运行.py文件是一次性执行该文件内的所有代码
六：编辑器 （1）有推荐说使用Visual Studio Code，因为跨平台（Windows、Mac和Linux）
（2）我直接使用Pycharm（类似idea，需要破解，我使用的是jetbrains-agent.jar+注册码的方式，版本是2019.2）：https://blog.csdn.net/weixin_42717928/article/details/102757053
使用Pycharm：create new project（注意：前提是安装了Python）
pycharm成功配置加载了Python的环境变量
（3）绝对不能用Word和Windows自带的记事本。Word保存的不是纯文本文件，而记事本会自作聪明地在文件开始的地方加上几个特殊字符（UTF-8 BOM），结果会导致程序运行出现莫名其妙的错误
（4）如果是使用Sublime Text或者Notepad++，要注意文件所在的路径
假设我在桌面新建了一个hw.py文件，可以查看桌面有没有这个文件
七：输出 //输出a b //遇到逗号，输出空格 print('a', 'b') 备注：java里面这样报错，通过+的方式进行连接 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd8eec9bfb226c094db8b8c89b79422d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22ac6e97381e6704a23ec3f985b526df/" rel="bookmark">
			Go语言的映射reflect使用大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、映射的基本用法
1.获取类型信息
2.获取值
3.读取和设置值
4.使用Kind来区分类型
5.操作结构体
6.创建新实例
7.调用方法
8.调用方法
二、使用实例
总结
前言 Go语言作为一个高性能的静态语言，我们在写函数的时候，由于go语言的特性，我们需要定义变量类型，大多情况下，变量类型是固定结构体，这就会导致我们想做一个适配性较高的函数的时候，则需要将变量以及返回值用interface{}接口实现
一、映射的基本用法 1.获取类型信息 使用`reflect.TypeOf()`可以获取任何值的类型信息
var x float64 = 3.4 fmt.Println("type:", reflect.TypeOf(x)) 2.获取值 使用`reflect.ValueOf()`可以获取reflect.Value类型表示的实际值：
var x float64 = 3.4 v := reflect.ValueOf(x) fmt.Println("value:", v) fmt.Println("type:", v.Type()) fmt.Println("kind:", v.Kind()) 3.读取和设置值 通过reflect可以对变量的值进行读取和设置：
var x float64 = 3.4 p := reflect.ValueOf(&amp;x) // 注意这里必须要传递x的地址 v := p.Elem() v.SetFloat(7.1) 4.使用Kind来区分类型 `reflect.Kind`可以用来区分基本类型：
v := reflect.ValueOf(x) if v.Kind() == reflect.Float64 { // x是float64类型 } 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22ac6e97381e6704a23ec3f985b526df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d25f364db2ee6d4ea0d368e214986bd/" rel="bookmark">
			linux文件编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件编程内容比较多，如文件系统原理及访问机制文件在内核中的管理机制，什么是文件信息节点iNode、文件共享、文件权限、各种用户对其权限等等。以下主要记录如何用代码操作文件，实现文件的创建、打开、编辑等自动化执行。
在介绍相关的操作之前，我们要记住几个概念，这样方便我们后续的理解
linux一切皆文件：硬件设备、管道、数据库、socket等
文件描述符：在linux下一切皆文件，文件描述符是内核为了高效的管理已经被打开的文件所创建的索引，它是一个非负整数，用于指代被打开的文件，所有执行I/O操作的系统调用都是通过文件描述符完成的。 在linux中，进程是通过文件描述符(file descriptors 简称fd)来访问文件的，文件描述符实际上是一个整数。在程序刚启动的时候，默认有三个文件描述符，分别是：0(代表标准输入)，1(代表标准输出)，2(代表标准错误)。再打开一个新的文件的话，它的文件描述符就是3。 POSIX标准规定，每次打开的文件时(含socket)必须使用当前进程中最小可用的文件描述符号码。
文件描述符的创建： 进程获取文件描述符最常见的方法就是通过系统函数open或create获取，或者是从父进程继承。进程相关知识这里就不展开叙述，前两者往下看。
在windows下，我们一般编写一个文档都是，创建word文档——&gt;打开文档——&gt;编辑文档——&gt;保存文档——&gt;关闭文档。
同理，linux下任何操作都离不开这几个步骤
操作系统提供了相关上述步骤的API，如下：
1、打开/创建文件
头文件：
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include&lt;fcntl.h&gt;
函数：
打开：
int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t made);
第一个参数是要打开的文件名（含路径，缺省为当前路径）
第二个参数Flags是对文件操作的权限
1、O_RDONLY：只读打开
2、O_WRONLY：只写打开
3、O_RDWR：可读可写打开
当我们附带了权限后，打开的文件只能按照这种权限来操作
以上三种常数中应当只指定一个，下列常数可选择：
O_CREAT：若文件不存在则创建它。使用此选项时，需要同时说明第三个参数mode（也就是第二个函数的写法），用其说明该新文件的存取许可权限。
O_EXCL：如果同时指定了O_CREAT，而文件已经存在则出错返回值是-1。 O_APPEND：每次写时都加到文件的尾端。如果不加这个常量每次写的时候就会将源文件内容覆盖掉一定的字节数（写入多少字节数就在源文件覆盖多少字节）如果用或操作加上这个常量，会在原文件另起一行，将东西写入。
O_TRUNC：属性去打开文件时，如果这个文件中本来是有内容的，而且为只读或只写成功打开，则将其长度截短为0。 就是将源文件中的所有内容都干掉，就没有内容了。
创建：
int create(const char *filename, mode_t mode)
第一个参数：要创建的文件名
第二个参数：创建模式（可读可写可执行）如下：
S_IRUSR 4 可读
S_IWUSR 2 可写
S_IXUSR 1 可执行
S_IRWXV 7 可读可写可执行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d25f364db2ee6d4ea0d368e214986bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1b5bd3bfa123c33d6d90911b03a9eed/" rel="bookmark">
			【linux一】关于新创建的虚拟机安装vmware tools的一些心得
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里我们创建一个新的虚拟机（ubuntu18-04）
之前用的VMware是10.0.7，建议升级
我这里用的是（VMware16.2.3版本）
关于VMware tools的安装心得：
1、如果你仅仅只是安装了VMware，并没有linux.iso这个镜像文件，建议到官网下载一个和自己安装的VMware版本一样的，网址如下：
CDS Repository - /var/www/public/stage/session-89/cds/vmw-desktop/ws
以我的16.2.3版本为例子
CDS Repository - /var/www/public/stage/session-89/cds/vmw-desktop/ws/16.2.3/19376536/windows/packages/
你进入第一个连接之后，除了第一个16.2.3选择你自己vmware版本的以外，其他照着我的选进入到如下界面选择红框的那个压缩包
2、下载好之后放到你想放在的windows磁盘里面，解压
3、回到虚拟机页面，在最上面选择虚拟机——&gt;设置
将软盘的连接由「使用软盘映像文件 -&gt; autoinst.flp」改成「使用物理驱动器 -&gt; 自动检测」
将CD/DVD的连接，改成「使用ISO映像文件 -&gt; VMware workstation安装目录下的linux.iso（就是你下载的那个解压出来的东西）」 点击确认
4、点击虚拟机，点击安装VMware tools选项 （如果到这里，看见VMware tools选项变成了重装VMware tools且没有变灰，表示已经安装好了，就不需要继续往下看了） （如果点击之后，选项一直停留在正在安装VMware tools，且桌面显示CD/DVD光盘的东西，页面下显示如何安装的操作那么就继续往下操作）
5、右键电机桌面出现的那个光盘，点击open，我们进入里面之后会看到一个压缩包（如下图），压缩包就是我们之前进网页下载的东西，将它复制到主目录（/home/）上来进行解压 复制就直接右键，然后点击copy，在同样界面左侧点击到home那，进入home，在空白处右键选择paste 回到终端，利用解压指令：unrar XXX.tar.gz对该压缩包解压
6、如果到这里你发现你的电脑无解压方式，可以进行两种操作进行下载 （1）sudo apt install unrar （2）wget https://www.rarlab.com/rar/rarlinux-x64-6.0.2.tar.gz tar -zxvf rarlinux-x64-6.0.2.tar.gz cd rar sudo make make install
7、如果你是使用第二种方式下载，那么你需要通过如下方式解压
tar -xzvf VMXXX.tar.gz
8、解压完成之后进入文件夹 Eg：cd vmware-tools-distrib
9、运行vmware-install.pl sudo ./vmware-install.pl 中途遇到y点y，遇到路径点回车 （如果到这里你的虚拟机选项中的安装vmware-tools变成重装vmware-tools且没有变灰，就可以结束了） （如果没有，继续往下，换一种方法）
注：检验安装是否可用还有一种方法，建议sudo reboot后，从windows复制一个指令或文字，到linux来粘贴，如果可以，则成功，如果不可以往下看 10、sudo apt-get autoremove open-vm-tools删除之前全部安装好的vmware-tools的东西 然后sudo apt-get install open-vm-tools-desktop，输入这个安装指令，应该就可以解决了（用上面注的方法测试），如果还遇到没安装上的问题，那我也没办法了，我是小菜鸡一枚~，以上是我安装的心得，希望对你有帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a7990db130c3c94109cc93b20453925/" rel="bookmark">
			【ACL 2023】A Novel Table-to-Graph Generation Approach for Document-Level Joint Entity and RE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【ACL 2023】A Novel Table-to-Graph Generation Approach for Document-Level Joint Entity and Relation Extraction 论文：https://aclanthology.org/2023.acl-long.607/
代码：https://github.com/ridiculouz/TaG / https://github.com/tonytan48/Re-DocRED
Abstract 文档级关系提取（DocRE）旨在提取文档中实体之间的关系，这对知识图构建等应用程序至关重要。现有的方法通常假设实体及其提及是预先识别的，这与现实世界中的应用程序不符。为了克服这一限制，我们提出了TAG，这是一种新的 table-to-graph 生成模型，用于在文档级别联合提取实体和关系。为了增强任务依赖性的学习，TAG在提及之间引入一个潜在图，不同类型的边指示不同的任务信息，并通过关系图卷积网络进一步传播。为了缓解错误传播问题，我们采用分层聚集聚类算法在解码阶段反向传播任务信息。在基准数据集DocRED上的实验表明，TAG在很大程度上超过了以前的方法，并取得了最先进的结果。
Introduction 早期的研究主要集中在句子层面的Relation Extraction（RE），即在一个句子中预测实体之间的关系。然而，在维基百科文章或科学论文等现实世界场景中，大量的关系事实是在多个句子中表达的，这就需要句子间推理技巧。因此，最近的努力一直在向更现实的文档级RE（DocRE）迈进。
尽管进展迅速，但大多数以前的DocRE方法都只专注于关系提取任务，该任务假设实体及其相应的提及是预先给定的。如图1所示，要在文档级别提取实体和关系，自然的想法是使用pipline方法。传统上，它首先将整个任务划分为提及提取（ME）、共指消解（COREF）和关系提取（RE）的子任务，然后使用单独的模型逐步执行每个任务。然而，流水线框架忽略了子任务之间的底层依赖关系，这可能导致性能不理想。在联合考虑子任务方面已经取得了一些进展，然而，之前的尝试仍然分别对COREF和RE的任务进行建模，在编码和解码阶段都可能产生偏差。一方面，这些方法仍然存在缺乏信息共享的问题。它们要么完全依赖于共享语言模型（例如BERT），或者只考虑从RE到COREF的单向信息流，而忽略其他跨任务依赖性。另一方面，现有的方法大多采用流水线式解码，首先识别提及跨度并形成实体簇，然后对每个实体对进行关系分类。这样的例程不仅耗时，而且还面临着错误传播问题。实体提取的结果可能会影响关系提取的性能，并导致级联错误。Xu和Choi试图在COREF得分手中使用正则化术语来缓解这个问题，但这个问题仍然没有完全解决。
在这项工作中，我们提出了TAG，一种新的 table-to-graph 生成模型，以解决上述挑战。我们首先将COREF和RE的任务与经典的表填充框架统一起来。然后，我们设计了一个下面的表格填充器来对原始文本进行编码，并对这两项任务进行粗略的预测。将提及作为节点，我们动态地构建两个相应的共指图和关系图，其中边由表填充器的置信度得分加权。此外，为了缓解长期依赖问题，并对句法信息进行显式建模，我们构建了一个过度提及的句法图。给定这三个子图，TAG将它们视为三种不同类型的边，并使用关系图卷积网络（RGCN）对隐式任务依赖性进行精细建模。与以前仅直接从语言模型共享跨度表示的多任务系统不同，我们的粗到细框架通过语义和句法链接传播信息，利用丰富的节点表示。
直观地说，同一实体集群中的提及应该与其他实体建立类似的关系链接。为了避免错误传播问题，我们利用这一假设，并将层次聚集聚类（HAC）算法应用于聚类提及。HAC的核心是计算每个聚类对之间的共指距离。为了反向传播关系信息，我们计算节点的关系向量，并使用不同集群之间的平均汉明距离（Hamming distance）作为额外的惩罚。
我们在DocRED数据集上评估TAG，这是一个广泛采用的DocRE基准。实验表明：（1）与以前的方法相比，粗粒度的表填充基线建立了具有竞争力的结果。（2） 细粒度的信息传播模块和增强的HAC解码算法可以有效地促进跨任务交互，更好地缓解错误传播问题。（3） 我们提出的TAG实现了新的最先进技术，并在很大程度上优于先前的方法。我们还报告了关于Re-DocRED的联合实体和关系提取的第一个结果，这是DocRED的修订版，用于未来的研究。
我们的贡献可以总结如下：
我们将COREF和RE在文档级联合实体和关系提取中的任务与表填充框架相统一，并提出了一种新的 table-to-graph 生成方法TAG，以促进信息共享。在解码阶段，我们采用HAC算法来增强RE预测的COREF，从而减轻错误传播的问题。我们证明TAG超越了以前的方法，并在标准DocRE基准上获得了最先进的新结果。 Problem Formulation 给定由 L L L个token组成的文档 D D D，我们的目标是以端到端的方式联合抽取所有实体和关系。由于一个实体可能在文档中多次出现，并有不同的提及，因此联合提取过程可以自然地分为三个子任务：
提及提取（ME），它提取所有可能的跨度 M = { m i } i = 1 M \mathcal{M}=\{m_i\}^M_{i=1} M={mi​}i=1M​表示原始文档中的实体，其中跨度定义为单词的连续序列；共指解析（COREF），将本地提及分组为实体簇 E = { e i } i = 1 E \mathcal{E}=\{e_i\}^E_{i=1} E={ei​}i=1E​，其中 e i = { m j i } j = 1 N e i e_i=\{m^i_j\}^{N_{e_i}}_{j=1} ei​={mji​}j=1Nei​​​;关系提取（RE），它从实体对 ( e h , e t ) h , t = 1 , … , E ; h ≠ t (e_h,e_t)_{h,t=1,\dots,E;h \ne t} (eh​,et​)h,t=1,…,E;h=t​之间的预定义关系集 R ∪ ⊥ \mathcal{R} \cup {\bot} R∪⊥， ⊥ \bot ⊥表示没有关系。 与以往的工作不同，我们使用表格填充框架来制定COREF和RE的任务，每个提及对 ( m i , m j ) (m_i,m_j) (mi​,mj​)之间的多类分类。我们维护一个表 T ∣ M ∣ × ∣ M ∣ T^{|M|\times|M|} T∣M∣×∣M∣来表示提及对，并对这两个任务使用共享表示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a7990db130c3c94109cc93b20453925/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f623cb9b333e602597aff2342eb737a/" rel="bookmark">
			【MYSQL】事务隔离级别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		脏读、幻读、不可重复读 脏读
一个事务正在对一条记录做修改，在这个事务完成并提交前，另一个事务也来读取同一条记录，读取了这些未提交的“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象的叫作’脏读’（Dirty Reads）。
例子：事务A修改了一条数据1状态为CLOSED，还没有提交，事务B来读数据1，获取到了数据1的状态为CLOSED
不可重复读
一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫作“ 不可重复读”（Non-Repeatable Reads）。
例子：事务A读取一条数据1状态为OPEN，事务B来修改数据1状态为CLOSED，事务A再次读取数据1状态变为CLOSED
幻读
一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”（Phantom Reads）。
例子：事务A根据时间20231212条件筛选查询数据有3条，事务B插入了时间为20231212的一条数据，事务A再次查询发现数据变为了4条，仿佛出现幻读
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/17/">«</a>
	<span class="pagination__item pagination__item--current">18/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/19/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>