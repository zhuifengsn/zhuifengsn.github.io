<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3f581a0e594740de513f00001af854c/" rel="bookmark">
			【selenium】多个class定位方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【背景】
要定位自己想要定位的元素，有时候元素没有合适的ID或其他属性，就想用class试一试，但是class往往不止一个，而是多个class堆叠在一起。
【解决办法】
此时用driver.findelementsbyclass是无法得到想要结果的，需要用如下形式。
eles = driver.find_elements_by_css_selector(".row.mc-my-4.mc-text--bare-link-parent") 问题解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e8cb5017519283e28232b70abf57708/" rel="bookmark">
			mysql workbench 快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql workbench 常用快捷键 新建tab(new tab) ctrl+t执行当前语句(execute current statement) ctrl+enter执行全部或选中的语句(execute all or selection) ctrl+shift+enter查看执行计划(explain current statement) ctrl+alt+x注释 - -加空格，如 – select * from t; 以上快捷键，都可以通过query查看 公众号 欢迎关注个人公众号
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb48773e5888dc35bdb9f0c9cbbfc325/" rel="bookmark">
			cpp——引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引用概念
引用原则：对引用的变量不能权限放大，只能权限缩小。
使用场景
注意事项
引用和指针的区别
引用跟指针的汇编代码对比：是一样的
引用和指针的不同点：
引用概念 引用不是定义一个新变量，而是给已存在的变量取了一个别名，编译器不会为引用的变量开辟内存空间，它和它引用的变量共用同一块内存空间。
小王因经常健身每天吃八个鸡蛋，被小伙伴们调侃的取了个外号叫“八蛋”，又刚好姓王，“王八蛋”，小伙伴们每天都会问“八蛋”你今天吃八个鸡蛋了没。我们想一下，“八蛋”是不是小王，小王是不是“八蛋”。没错，引用相当于是给变量取外号，不会为这个外号另开辟内存空间来存储，而是共用一块空间。要是因给小王取了个外号就多变出一个叫“八蛋”的人那岂不荒唐了！！
俗话说的好，口说无凭。我说共用一块内存空间就共用一块内存空间吗？让我们来看看是不是真的如我所说。定义了一个变量a，给这个变量取了个别名，分别打出其地址来看看是不是同一块空间。
#include&lt;iostream&gt; using namespace std; int main() { int a = 10; int &amp;b = a;	//给a取了个别名叫b //打出两个地址 cout &lt;&lt; "a的地址：" &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; "b的地址：" &lt;&lt; &amp;b &lt;&lt; endl; return 0; } 事实胜于雄辩，果然不是我在吹牛。他们确实是共用一块内存空间。
竟然是共用一块内存空间那不乏让我们联想到c语言中交换两个数的函数，需要进行传址，指针接收。如果用引用来取别名会不会更简单，更让人读懂。
//c语言的写法：指针 void swap(int*num1, int* num2) { int tmp = *num1; *num1 = *num2; *num2 = tmp; } //c++的写法:引用 void swap(int &amp;num1, int &amp;num2) { int tmp = num1; num1 = num2; num2 = tmp; } 看到这里可能会惊叹到原来引用可以这么用的啊！但引用并不是可以肆意用的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb48773e5888dc35bdb9f0c9cbbfc325/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a35ab7201f5f03c869dac1412adf3ae6/" rel="bookmark">
			软件设计师提纲&#43;复习资料整理（上午题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 软件设计师考试大纲上午题（选择题）一、计算机组成原理考点：CPU结构组成考点：原码、反码、补码定点整数范围考点：浮点数表示考点：RISC和CISC计算机的区别考点：奇校验与偶校验考点：寻址方式考点：RAM、ROM、FLASH（闪存）考点：CPI与MIPS考点：流水线吞吐率计算考点：指令周期、机器周期、时钟周期 二、操作系统考点：中断方式考点：DMA考点：位示图考点：进程资源图考点：分页（物理地址计算）考点：信号量考点：多级索引结构 三、计算机网络考点：TCP/IP五层模型中各个协议内容（高频）考点：HTTP一次请求的过程考点：A类、B类、C类网络考点：几种常见命令及功能 四、网络信息安全考点：几种常见攻击方式考点：对称加密与非对称加密考点：计算机病毒的特性 五、法律方面考点：保护期限考点：知识产权人确定考点：侵权判定 六、软件工程考点：软件设计各个阶段考点：项目的活动图考点：进程前驱图考点：软件模型考点：模块的耦合类型考点：模块的内聚类型考点：白盒测试（路径覆盖与语句覆盖）考点：面向对象分析考点：类的设计原则考点：设计模式考点：ISO/IEC 9126软件质量模型考点：类的划分考点：UML类图考点：MTTF、MTTR、MTBF考点：V模型考点：嵌入式操作系统的特点考点：软件维护的特点考点：分布式数据库特点 七、程序语言基础考点：词法、语法、语义分析考点：调用函数，采用传值方式和传引用方式区别考点：编译与解释考点：有限自动机考点：并行系统与串行系统可靠度计算考点：算数表达式 八、数据结构考点：树考点：图的存储（邻接矩阵、邻接表）考点：广度优先与深度优先遍历考点：排序算法（复杂度）考点：算法设计策略 九、数据库考点：确定候选码考点：部分依赖、完全依赖、传递依赖考点：关系代数表达式考点：1NF、2NF、3NF考点：共享锁与排他锁考点：外连接考点：数据流图考点：外模式、模式和内模式 软件设计师考试大纲 考试科目
计算机与软件工程知识，考试时间为150分钟，笔试，选择题；软件设计，考试时间为150分钟，笔试，问答题。 考试范围
软件工程知识
计算机科学基础知识
1.1数制及其转换
◇ 二进制、八进制、十进制和十六进制等常用数制及其相互转换
1.2 计算机内数据的表示
◇ 数的表示（补码表示，整数和实数的表示，精度和溢出）
◇ 非数值表示（字符和汉字表示，声音表示、图像表示）
1.3算术运算和逻辑运算
◇ 计算机中的二进制数运算方法
◇ 逻辑代数的基本运算
1.4其他数学基础知识
◇ 常用数值计算
◇ 排列组合，概率论应用，应用统计（数据的统计分析）
◇编码基础
◇ 命题逻辑、谓词逻辑、形式逻辑的基础知识
◇ 运筹基本方法
计算机系统知识
2.1计算机硬件基础知识
2.1.1计算机系统的组成、体系结构分类及特性
◇ CPU、存储器的组成、性能和基本工作原理
◇ 常用I/O设备、通信设备的性能以及基本工作原理
◇ I/O接口的功能、类型和特性
◇ CISC/RISC，流水线操作，多处理机，并行处理
2.1.2存储系统
◇ 虚拟存储器基本工作原理，多级存储体系
◇ RAID类型和特性
2.1.3可靠性与系统性能评测基础知识
◇ 诊断与容错
◇ 系统可靠性分析评价
◇ 计算机系统性能评测方法
2.2计算机软件知识
2.2.1数据结构与算法知识
◇ 数组
◇ 链表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a35ab7201f5f03c869dac1412adf3ae6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a4e0925d5ff7089bd030c157e5fade4/" rel="bookmark">
			有哪些高含金量的编程竞赛？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.USACO（美国计算机奥林匹克竞赛） USACO（UnitedStatesofAmericaComputingOlympiad,美国计算机奥林匹克竞赛)是一项针对全世界所有的高中信息学竞赛选手的一项竞赛。开设目的是为每年夏季举办的国际信息学奥林匹克竞赛（IOI）选拔美国队队员。这项赛事不仅可以培养学生的算法和编程思维，好的竞赛成绩还能给孩子大学申请加分。由于有些编程题跟谷歌，脸书等顶级科技公司面试题类似，好的USACO竞赛成绩对孩子以后申请实习也大有裨益。
官网网址：http://www.usaco.org/http://www.usaco.org/
2.ACSL（美国计算机科学联赛） 美国计算机科学联赛 （American Computer Science League）起源于美国硅谷，拥有40多年的历史，是美国历史悠久的中小学生计算机编程赛事之一。该比赛同时获得了美国国家中学校长联盟NASSP 与美国计算机科学教师协会的官方认证和推荐，同时获得了如谷歌、Adobe、No Starch Press、O'Reilly Media、Pearson、Pragmatic Bookshelf、and Wolfram 等著名高科技和教育企业的支持。随着各国日益重视编程教育，每年来自美国、加拿大、欧洲、非洲和亚洲的众多中小学生都踊跃参加到该竞赛中。
官网网址：American Computer Science Leaguehttps://www.acsl.org/
国内网址：American Computer Science League (ACSL) - ASDAN STEM CHALLENGES-Enrich Your Learning for Futurehttp://www.asdanchina.com.cn/en/acsl-en/
3.CCC（加拿大计算机竞赛） CCC计算机竞赛(全称 Canadian Computing Competition)由加拿大滑铁卢大学与清华大学联合举办面向高中生的CS计算机竞赛，是加拿大历史悠久，影响深远的计算机竞赛。自1996年首界竞赛至今已经有26年历史，累积超过近10万名加拿大境内外高中生参赛。不仅如此，CCC证书也是作为留学背景提升、申请北美知名院校，极具含金量的计算机证书。滑铁卢大学每年2月开始举行CCC竞赛，作为其数学学院各专业以及软件工程专业入学录取的重要指标及参考，更成为学生申请该学院奖学金的重要考核标准。同时该竞赛成绩也可作为申请加拿大和美国名校的重要参考。
官方网址：CCC Contest Systemhttps://cccgrader.com/
4.OUCC（牛津大学编程思维挑战赛） 牛津大学编程思维挑战赛（The Oxford University Computing Challenge-OUCC）是由牛津大学为了激发青少年编程学习兴趣，培训青少年编程思维能力，以及选拔优秀人才，在 2017 年创办的新型编程思维挑战赛。开赛当年就有近万名英国选手参与。OUCC 根据难度分为初级、中级、高级和精英级四个等级，分别对应小学，初中和高中。牛津大学编程思维挑战赛（OUCC）与英国信息学奥赛（BIO）并列，成为英国编程挑战协会（UKCT）四个组成单位之一。在英国，OUCC 优秀同学将被推荐参加英国信息学奥赛（BIO）。
官方网址：Welcome - OUCChttps://oucc.uk/
国内网址：http://www.asdanchina.com.cn/en/oucc-en/http://www.asdanchina.com.cn/en/oucc-en/
5.Google Code Jam（谷歌全球编程挑战赛） Google Code Jam谷歌全球编程挑战赛是 Google 举行的一项国际编程竞赛，目标是为 Google 选拔顶尖的工程人才。该项赛事始于 2003 年，竞赛内容包括在限定时间内解决一系列特定的算法问题，编程语言和环境的选择不受限制。每年竞赛中所有参赛者在经过4轮线上比赛后，将会诞生25位选手参加在不同Google Offices地点举办的The World Finals全球总决赛，竞争现金大奖及奖杯。Google Code Jam凭借全球平台和独特的互动式 PK 赛制，已迅速成为全球信息学爱好者最热衷参与的世界级编程大赛之一。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a4e0925d5ff7089bd030c157e5fade4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba01d5f07a5d8d807793224164645f73/" rel="bookmark">
			Android 打开另一个APP，H5打开APP方法，打开淘宝、京东、天猫、拼多多。需求、商品详情或优惠券页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在待打开的APP注册可被外APP调用的activity
&lt;activity android:name=".TwoActivity"&gt; &lt;intent-filter &gt; &lt;action android:name="android.intent.action.VIEW" /&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;data android:scheme="test" android:host="com.example.mvvmtest" android:path="/home" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 注：host是包名
2、任意APP打开已注册的开放的activity
Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse("test://com.example.mvvmtest/home")); intent.putExtra("name","aacc44"); startActivity(intent); H5打开APP &lt;intent-filter&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;action android:name="android.intent.action.VIEW"/&gt; &lt;category android:name="android.intent.category.BROWSABLE"/&gt; &lt;data android:scheme="dogness" android:host="rice" android:path="/device" /&gt; &lt;/intent-filter&gt; dongness://rice/device dongness://rice/device?sn=365622952860844032
Uri uri = getIntent().getData(); if (uri !=null){ xiexunss = uri.getQueryParameter("dognesscode"); LgqLogPlus.d("浏览器返回==== "+xiexunss); SharedPreUtil.putString("liulanqidp",xiexunss); } APP跳转到淘宝商品详情和优惠券页面demo /** * 跳转至商品详情 * * @param activity Activity * @param url 商品详情 */ fun gotoGoodsDetail(activity: Activity, url: String?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba01d5f07a5d8d807793224164645f73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8087019122e17c44f55640adc00cba31/" rel="bookmark">
			批量将 PDF 转为 ePub 格式文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要：PDF 格式文档转为 ePub 格式的需求是我们经常会碰到的，网上的各种工具效果也是良莠不齐，经常会出现格式错乱、字体丢失等各种问题。今天给大家介绍的是一种非常简单的方式完成将多个 PDF 文档批量转为 ePub 格式的方法，这种方法处理效率非常高，并且效果也很理想！对格式比较复杂的 PDF 格式的文档也能很好的支持。
在工作中经常会碰到需要将 PDF 转为 ePub 格式的需求，以前每次碰到需要转换的时候都是在网上找各种工具、各种教程。虽然也找到了很多的处理方法，但是有时候也是难以达到效果的，比如 PDF 格式简单的时候还好，一旦格式变得复杂，就会出现格式错乱、乱码等等各种问题，让人很抓狂。今天就给大家介绍一种比较简单高效、处理效果非常好的将 PDF 文档转为 ePub 格式的的方法，并且支持批量处理，一次将多个 PDF 文档批量转为 ePub 格式文档！
效果预览 我们先来看下 PDF 转为 ePub 格式之后的效果如何！
在上图中。左边的就是原始的PDF文档。右边就是转化过之后的 ePub 文档啦。是不是效果挺不错的！
工具准备 若需要批量将 PDF 文档转为 ePub 格式文档，我们需要借助一个工具-「我的ABC软件工具箱」。打开「我的ABC软件工具箱」后在左侧选择「格式转换」，右侧进入「PDF 转换为其它格式」的功能。
进入到功能后，我们就能看到「添加文件」的按钮。我们在这里一次性将所有需要转为 ePub 格式的 PDF 文档选择进来即可，有一千个选择一千个，有一万个可以选择一万个，软件都能一次性的完成 PDF 转 ePub 的操作！ 选项设置 添加好需要转换为 ePub 格式的 PDF 文档后，我们点击下一步，就能进入到格式选择的页面。
上面我们能看到，PDF 转换支持的格式非常多，这其中就包含我们需要的 epub 格式。我们需要哪种格式做对应勾选就可以，如上图所示的【epub】选项。勾选好之后点击下一步，可以选择存储的路径了。
处理完成 选择好存储路径之后，再点击下一步。软件就开始批量将 PDF 文档转为 ePub 了。处理速度是非常快的，一会儿就能完成多个 PDF 文档的转换，你也可以得到你需要的 ePub 格式的文档了，你学会了吗？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69f378ef2c63c989f35dcb2756e131b4/" rel="bookmark">
			SQL知识梳理（三）基础语法-查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础语法-查 一、查询数据SELECT1.单列查询2.多列查询3.查所有列4.去重查询：多用于查看种类-DISTINCT关键词5.限制返回行数-LIMIT关键词6.排序（1）单列排序（2）多列排序（3) 升序-ASC关键词（4) 降序-DESC关键词 二、过滤数据WHERE1.单条件过滤2.多条件过滤3.范围值过滤4.筛选部分数据 三、模糊查找-通配符1. %通配符可以代表一个或多个字符2. _通配符只能代表一个字符 查询数据是SQL语言中最常用，也最重要的部分。 一、查询数据SELECT 语法：select column_name from table_name
使用 select 选取列数据，返回的结果是无序的。
1.单列查询 SELECT column FORM table； 2.多列查询 SELECT column1, column2 FORM table； 3.查所有列 SELECT * FROM table； 4.去重查询：多用于查看种类-DISTINCT关键词 SELECT DISTINCT column1, column2 FORM table； 5.限制返回行数-LIMIT关键词 返回两行
SELECT * FROM student limit 2； 6.排序 （1）单列排序 SELECT column FORM table ORDER BY column1； （2）多列排序 SELECT column FORM table ORDER BY column1, column2； 有先后顺序，先排 列1，再将列1中数值相同、并列在一起的数值按 列2 排序；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69f378ef2c63c989f35dcb2756e131b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dcc6f174c92421f73b010170a146d90/" rel="bookmark">
			Java中数组元素的删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是一个LeetCode的简单题，在二刷做过的题时突然感觉这个题真的是非常的不错，虽然是个简单题，没有什么技巧，但是写代码的过程中有很多要注意的点，感觉还是很考验基本功，而且还加深了对数组的理解。
Java中的数组是存放一系列相同元素的集合，对应着堆空间中的连续的存储空间，所以在删除数组中某个元素的时候为保证数组的连续性，需要将后面的元素逐一向前覆盖，这就是这个题的解题思路。代码如下：
public static void main(String[] args) { int[] nums = {2, 3, 3, 2}; int target = 3; //首先遍历数组找target int len = nums.length; int i = 0; while (i &lt; len) { if (nums[i] == target) {//这时就需要删除该元素了，需要将后面的元素逐步向前覆盖 for (int j = i; j &lt; len - 1; j++) { nums[j] = nums[j + 1]; } i--;//需要将指针后移一位，因为此时i的位置上是原来i+1处的元 //素，不后移会跳过该元素的处理 len--;//因为删除了一个元素所以需要len-- } i++; } System.out.println(Arrays.toString(nums));//输出{2, 2, 2, 2} } 代码中两个for循环其实还可以用双指针来代替，这样时间复杂度更低，代码如下，思想比较简单，其实就是对数组进行重排，然后移除掉我们要删除的，把留下来的元素从数组头开始放，所以用一个i指针来记录了我们下一个要放的元素的位置，这种思想在很多地方都有应用，比如排序算法。
public int removeElement(int[] nums, int val) { int len = nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dcc6f174c92421f73b010170a146d90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b67a3f69c0af3e75fad6e89d24a3ed7b/" rel="bookmark">
			类和对象的初始化（构造函数与析构函数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有对象一定要有空间，有空间不一定有对象。
class Empty { }; int main() { Empty e; cout &lt;&lt; sizeof(e) &lt;&lt; endl;//1字节 return 0; } 虽然此对象没任何属性和方法，但是要创建一个对象，就必须在地址空间标识此对象，就必须占有一个字节。
类的数据成员不能在类定义时初始化。
class student { int num = 20060102; char name[15] = "张三"; float score = 85; };//错误 如果一个类中所有的数据成员都是公用的public，则可以在定义对象时对数据成员进行初始化。
class studet { public: int num; char name[15]; float score; }stu1 = { 20010130101,"张三"，85}; 一、构造函数 数据成员多为私有的，要对它们进行初始化，必须用一个公有函数来进行。C++提供了构造函数来处理类对象的初始化问题。同时这个函数应该在且仅在定义对象时自动执行一次。称为构造函数(constructor) 。
构造函数就是用来在创建对象时初始化对象，为对象数据成员赋初始值。
构造函数用途:1)创建对象，2）初始化对象中的属性，3）类型转换。
构造函数是类的一种特殊的成员函数(在特殊用途中构造函数的访问限定可以定义成私有或保护)
，不需要人为调用；而是在建立对象时自动被执行。
特征：
1.C++规定构造函数的名字必须与类名相同。
2.构造函数无函数返回类型说明。注意是没有而不是void，即什么也不写，也不可写void。实际上构造函数有返回值，返回的就是构造函数所创建的对象。
3.在程序运行时，当新的对象被建立，该对象所属的类构造函数自动被调用，在该对象生存期中也只调用这一次（由系统调用）。
4.构造函数可以重载。严格地讲，类中可以定义多个构造函数，它们由不同的参数表区分，系统在自动调用时按一般函数重载的规则选一个执行。
5.构造函数可以在类中定义，也可以在类中声明，在类外定义。
6.如果类说明中没有给出构造函数，则C++编译器自动给出一个缺省的构造函数.
类名（void）{ }
只要我们定义了一个构造函数，系统就不会自动生成缺省的构造函数。只要构造函数是无参或只要各参数均有缺省值的，C++编译器都认为是缺省的构造函数，并且缺省的构造函数只能有一个。默认构造函数——除了this指针以外没有参数的构造函数，函数体是空的，只能为对象开辟数据成员存储空间，而不能给对象中的数据成员赋初值。
构造函数定义形式:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b67a3f69c0af3e75fad6e89d24a3ed7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5b56c2dbf486e314e0bab5fe60ff9e9/" rel="bookmark">
			测试用例设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍
测试用例就是一个文档，描述输入、动作、或者时间和一个期望的结果，其目的是确定应用程序的某个特性是否正常的工作。
二、基本格式 用例的基本要素包括测试用例编号、测试标题、重要级别、测试输入、操作步骤、预期结果等。
用例编号：编号有一定的规则，如系统测试用例的编号这样定义规则： PROJECT1-ST-001 ，命名规则是项目名称+测试阶段类型（系统测试阶段）+编号。定义测试用例编号，便于查找测试用例，便于测试用例的跟踪。
测试标题：对用例描述，测试用例标题应该清楚表达测试用例的用途。比如 “ 测试用户登录时输入错误密码时，软件的响应情况 ” 。
重要级别：定义测试用例的优先级别，可以笼统的分为 四个不同的等级。
前置条件：
输入限制：提供测试执行中的各种输入条件。根据需求中的输入条件，确定输入。测试用例的输入对软件需求当中的输入有很大的依赖性，如果软件需求中没有很好的定义需求的输入，那么测试用例设计中会遇到很大的障碍。
操作步骤：提供测试执行过程的步骤。对于复杂的用例，测试用例的输入需要分为几个步骤完成，这部分内容在操作步骤中详细列出。
预期结果：提供测试执行的预期结果，预期结果应该根据需求说明书中的输出得出。如果在实际中，得到的实际测试结果与预期结果不符，那么测试不通过；反之则测试通过。
三、示例
测试编号测试项用例名称前置条件操作步骤预期结果优先级project1-login-01登录用户成功登录系统存在用户账号abc/1231、输入账号abc
2、输入密码123
3、输验证码000
4、点击登录成功登录，跳转到首页高project1-login-02登录密码错误，登录失败，系统存在用户账号abc/1231、输入账号abc
2、输入密码567
3、输验证码000
4、点击登录不跳转，提示密码错误，请重新登陆高 四、测试用例设计方法
常见的有：等价类划分法、边界值分析法、错误推测法、流程分析法、判定表法、正交实验法。
等价类法：就是将测试的范围划分成几个互不相交的子集，他们的并集是全集，从每个子集选出几个有代表性的值作为测试用例。如：密码长度6-10位，则划分1-5位 、6-10位、10位以上三类。 边界值法：软件大量的错误是发生在输入或输出范围的边界上，而不是发生在输入输出范围的内部。因此针对各种边界情况设计测试用例，可以查出更多的错误。选出的测试用例，应选取正好等于、刚刚大于、刚刚小于边界的值，例如：成年人年龄假定 X 为整数, 18≤X≤100,那么 X 在测试中应该取的边界值为：17，18,19，99，100，101。
错误推测法：在测试时，根据经验或直觉推测程序中可能存在的各种错误，从而有针对性地编写检查这些错误的测试用例的方法。这方法没有固定的形式，依靠的是经验和直觉，有针对性地设计。只能作为一种补充。
流程分析法：又称为场景法，是根据不同的业务场景来编写测试用例，需要把所以可能产生分支的地方考虑到。流程分析主要包括三个流程：基本流、备选流、异常流。
基本流：也就是正向流程，通过业务流程输入都为正确的，能够最终达到目标的流程。如：经典的ATM机取款流程，插入银行卡—输入正确的密码—输入正确的金额-取钱-取卡。
备选流：通过实现业务流程时，因错误操作或异常输入，导致流程存在反复，但最终能够达到预期的操作流程，如：ATM机取款，插入银行卡—输入错误的密码—重新输入正确的密码—输入正确的金额-取钱-取卡。
异常流：实现业务流程时，因操作错误或异常输入，导致没有完成业务流程，如ATM机取款，插入银行卡—输入错误的密码3次—吞卡。
正交实验法：就是在各因素互相独立的情况下，设计出一种特殊的表格，找出能以少数替代全面的测试用例。
状态迁移法：根据测试对象和测试数据之间的关系。测试对象的输出行为不仅仅和当前的输入数据有关，而且和测试对象当前的状态有关。状态迁移图是设计状态转换测试用例的基础，基于状态迁移图进行的测试就是状态迁移测试。例如：订单状态：未支付、超时取消、已取消、已支付、已收货、已完成等。步骤：画出状态迁移图、通过状态迁移图画出状态转换树、从状态转换树推导出测试路径、根据测试路径编写合法测试用例
五、缺陷报告
报告内容：标题、描述（简洁、准确、完整、反映缺陷本质）、重现步骤、严重程度（致命、严重、一般、较小）、优先级（紧急、高、中和低）、截图、编号、缺陷状态、指派人、测试环境、版本、所属模块等。
编写测试报告要做到以下几点：
1、对错误的描述要做到简洁、准确、完整，揭示错误实质 2、每个软件问题报告只书写一个缺陷或错误
3、明确指明错误类型和严重程度
4、每一个步骤尽量只记录一个完整操作
5、复现的操作步骤要完整，准确，简短
6、可以附加必要的错误特征图像
7、可以附加必要的测试用例
严重等级划分：
致命：系统任何⼀个主要功能完全丧失，⽤户数据受到破坏，系统崩溃、悬挂、死机等。
严重：系统的主要功能部分丧失，数据不能保存，系统的次要功能完全丧失，系统所提供的功能或服务受到明显的影响。
⼀般：系统的次要功能没有完全实现，但不影响⽤户的正常使⽤。例如：提⽰信息不太准确或⽤户界⾯差、操作时间长等⼀些问题。
较⼩：是操作者不⽅便或遇到⿇烦，但它不影响功能的操作和执⾏，如个别不影响产品理解的错别字、⽂字排列不整齐等⼀些⼩问题。
。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1a3c4f7e112a4e63a2c4f0700f0ca66/" rel="bookmark">
			Linux 重启后启动网卡提示Failed to start LSB: Bring up/down networking
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 VMware 安装的centos7 系统，断电重启后ens33 地址为空；
使用systemctl start network 时提示 Failed to start LSB: Bring up/down networking
解决：
1、查看NetworkManager状态systemctl status NetworkManager
2、NetworkManager和network是两个不同的服务,它们是互相冲突的。最根本的解决办法就是把NetworkManager服务停掉
停止：systemctl stop NetworkManager
systemctl disable NetworkManager
3、启动network
systemctl start network
查看没有报错，看看ip地址这会正常了。
若是还不行重启服务器就ok了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdfa3860333c42a05426c84060d1b487/" rel="bookmark">
			devtools热更新报错 javax.management.InstanceAlreadyExistsException: org.springframework.boot:type=Admin
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： spring-boot-version: 2.4.2
spring-cloud-version: 2020.0.1
spring-cloud-alibaba-version: 2021.1
问题描述 在配置过devtools热更新之后，更新报错为
org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'requestMappingHandlerAdapter' defined in class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]: Initialization of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'springApplicationAdminRegistrar' defined in class path resource [org/springframework/boot/autoconfigure/admin/SpringApplicationAdminJmxAutoConfiguration.class]: Invocation of init method failed; nested exception is javax.management.InstanceAlreadyExistsException: org.springframework.boot:type=Admin,name=SpringApplication at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:617) ~[spring-beans-5.3.3.jar:5.3.3] ... 主要错误为nested exception is javax.management.InstanceAlreadyExistsException: org.springframework.boot:type=Admin,name=SpringApplication
直接粘贴错误，经过各种google搜索，并没有找到相关解决方案
原因分析： 再次分析更新过程，发现spring的banner输出了2次
29秒一次
36秒又一次
再次google搜索devtools restarts twice
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdfa3860333c42a05426c84060d1b487/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/324dbcd1f43b4baf749082208043c841/" rel="bookmark">
			DEseq2 差异分析基本原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DEseq简介 寻找组间显著表达变化的基因，以解释基因表达水平的变化对生物功能的变化最直接的办法就行进行转录组测序和定量。那如何从不同组定量的转录组寻找到那些显著差异的基因呢？DESeq 就是来解决这个问题的，它主要使用负二项分布的模型来进行差异分析。DESeq2是DEseq的升级版，但是DEseq2只适用于有生物学重复的试验，而DEseq既可以做有生物学重复也可以做无重复（或部分重复的）试验。
2. DEseq2的差异分析原理 2.1 统计模型：负二项分布 所谓的差异分析实际上是指通过假设检验来判断两组数据是否存在显著差异，有参数检验（总体分布已知）和非参数检验（总体分布未知）两种方式，显然，对于分布已知的数据，运用参数检验的结果会更准确些。因此在进行表达差异分析的时候，我们会假定表达数据符合某一个特定的分布，然后在使用参数检验的方式进行假设检验。
那么，表达数据（read counts）应该是一个什么样的分布呢？首先read counts本质是数目值，是一个离散的非零整数，其分布应该是离散型分布，其次，对于测序数据往往是n很大，p很小的分布，因此学术界常用泊松分布和负二项分布来描述。事实上，早期确实有人使用泊松分布来进行差异分析，不过后续发现基因的read counts的均值和方差并不是相等的（如下图示），这并不符合泊松分布均值和方差是相等的规律，因此发展至今，负二项分布成为差异分析的主要分布模型。
2.2 数据标准化 理论上知道了数据的已知分布（负二项分布），就可以直接进行差异分析了。但对于测序分析得到的read counts需要事先标准化处理，才能用于差异分析。标准化处理主要为了解决两个问题。
1） 文库大小造成的两组数据之间存在差异。
2） 文库组成造成的两组数据基因的比例存在差异
具体的标准化过程如下：
1）计算所有样本的同一基因的对数均值，然后去除对数均值为Inf的值（read count为0的）。取对数的目的是减弱异常值的影响，使得数据分布更加平滑; 剔除reads数为0的基因是为了留下稳定表达的基因。
2） 使用对数矩阵分别减去对应基因的对数均值，得到一个新的矩阵。
3） 对于上个步骤得到的新的矩阵，计算每个样本的中位数（均值比较容易受异常值的影响，但中位数对异常值则不敏感） ,然后使用该中位数取真数，得到的结果作为该样本的标准化因子。
4） 原始reads数矩阵分别除以标准化因子得到最终标准化的矩阵
得到的标准化的表达矩阵就可以使用负二项分布的统计模型进行假设检验了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eec1de5151c99a02e36e868e8448ae5/" rel="bookmark">
			数据库SQL调优的几种方式(转)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目中,SQL的调优对项目的性能来讲至关重要,所有掌握常见的SQL调优方式是必不可少的,下面介绍几种常见的SQL的调优方式,供借鉴.
一.创建索引 要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引(1)在经常需要进行检索的字段上创建索引，比如要按照表字段username进行检索，那么就应该在姓名字段上创建索引，如果经常要按照员工部门和员工岗位级别进行检索，那么就应该在员工部门和员工岗位级别这两个字段上创建索引。
(2)创建索引给检索带来的性能提升往往是巨大的，因此在发现检索速度过慢的时候应该首先想到的就是创建索引。
(3)一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。索引并不是越多越好，索引固然可以提高相应的 select 效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。 二.避免在索引上使用计算 在where字句中，如果索引列是计算或者函数的一部分，DBMS的优化器将不会使用索引而使用全表查询,函数属于计算的一种,同时在in和exists中通常情况下使用EXISTS，因为in不走索引。
效率低：select * from user where salary*22&gt;11000(salary是索引列) 效率高：select * from user where salary&gt;11000/22(salary是索引列) 三.使用预编译查询 程序中通常是根据用户的输入来动态执行SQL，这时应该尽量使用参数化SQL,这样不仅可以避免SQL注入漏洞攻击，最重要数据库会对这些参数化SQL进行预编译，这样第一次执行的时候DBMS会为这个SQL语句进行查询优化并且执行预编译，这样以后再执行这个SQL的时候就直接使用预编译的结果，这样可以大大提高执行的速度。
四.调整Where字句中的连接顺序 DBMS一般采用自下而上的顺序解析where字句，根据这个原理表连接最好写在其他where条件之前，那些可以过滤掉最大数量记录。
五.尽量将多条SQL语句压缩到一句SQL中 每次执行SQL的时候都要建立网络连接、进行权限校验、进行SQL语句的查询优化、发送执行结果，这个过程是非常耗时的，因此应该尽量避免过多的执行SQL语句，能够压缩到一句SQL执行的语句就不要用多条来执行。
六.用where字句替换HAVING字句 避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前刷选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数 的过滤，除此之外，应该将条件写在where字句中。
七.使用表的别名 当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减 少哪些友列名歧义引起的语法错误。
八.用union all替换union 当SQL语句需要union两个查询结果集合时，即使检索结果中不会有重复的记录，如果使用union这两个结果集 同样会尝试进行合并，然后在输出最终结果前进行排序，因此如果可以判断检索结果中不会有重复的记录时候，应该用union all，这样效率就会因此得到提高。
九.考虑使用“临时表”暂存中间结果 简化SQL语句的重要方法就是采用临时表暂存中间结果，但是，临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在tempdb中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。
但是也得避免频繁创建和删除临时表，以减少系统表资源的消耗。
十.只在必要的情况下才使用事务begin translation SQL Server中一句SQL语句默认就是一个事务，在该语句执行完成后也是默认commit的。其实，这就是begin tran的一个最小化的形式，好比在每句语句开头隐含了一个begin tran，结束时隐含了一个commit。
有些情况下，我们需要显式声明begin tran，比如做“插、删、改”操作需要同时修改几个表，要求要么几个表都修改成功，要么都不成功。begin tran 可以起到这样的作用，它可以把若干SQL语句套在一起执行，最后再一起commit。 好处是保证了数据的一致性，但任何事情都不是完美无缺的。Begin tran付出的代价是在提交之前，所有SQL语句锁住的资源都不能释放，直到commit掉。
可见，如果Begin tran套住的SQL语句太多，那数据库的性能就糟糕了。在该大事务提交之前，必然会阻塞别的语句，造成block很多。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6eec1de5151c99a02e36e868e8448ae5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/291c9071173bfddec38be6d0c9628e9f/" rel="bookmark">
			Java 数组元素的删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java数组的长度固定，因此无法直接删除数组中的元素。
通过创建新的数组，将保留的原数组中的元素赋值到新数组来实现原数组元素的删除。同理，可以实现数组添加元素。
package package1; import java.util.Arrays; public class ArrayTest1 { public static void main(String[] args) { int[] array1 = new int[] {4, 5, 6, 7}; int num = 2; int[] newArray = new int[array1.length-1]; for(int i=0;i&lt;newArray.length; i++) { // 判断元素是否越界 if (num &lt; 0 || num &gt;= array1.length) { throw new RuntimeException("元素越界... "); } // if(i&lt;num) { newArray[i] = array1[i]; } else { newArray[i] = array1[i+1]; } } // 打印输出数组内容 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/291c9071173bfddec38be6d0c9628e9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dd3a38bf127cbd3164057b4ebfa253f/" rel="bookmark">
			Mybatis&#43;Collection一对多表查询踩坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mybatis+Collection一对多表查询踩坑 需求思考解决方案实现方法MyBatis关联查询一对一association查询一对多collection查询坑1坑2 需求 自己写的springboot项目中有这样一个需求：
将简历模板映射到数据库中。
思考 简历模板包含多个属性，每个属性又有多个条目，比如个人上学经历，有小学，初中，高中，大学等多个条目，如果把这些全部都存到一个表里就不那么好。
解决方案 将简历表作为主表，将简历中包含的属性作为从表，这样就形成了主从表的结构。
实现方法 现在需要的是后端从数据库中将简历模板信息拿到，就涉及到了主从表查询，这里介绍MyBatis的关联查询
MyBatis关联查询 一对一association查询 很简单，就是一对多的简易版，不多赘述。主要讲collection查询。
一对多collection查询 一：建主从表的实体类
其中lev1Entity是主表其他都是从表
二：需要将从表作为一个属性单独的加到主表实体类中
三：接下来就要用到collection查询了
首先需要将collection作为返回写到resultmap中
注意resultmap的type和id等属性。
四：然后就写select查询即可
五：查询到的结果如下：
前面的主表内容相同，后面是一个从表的两个条目，查询结果是分开的，但是MyBatis根据一定规则将他们自动映射到数据集List中，合并为一条数据，这也就有了下面的坑：
坑1 坑1：注意这里select的返回类型需要是resultmap对应上面返回结果的resultmap类型，不能是resulttype，否则查询到的多条结果将不会合并到list’中，这里是一个注意点。
坑2 坑2：坑2是因为一个collection只能多一个sql查询，而我需要一个主表对应多个从表，就需要多个collection查询，select语句前面贴图已经有了，但是我遇到的问题是他们始终合并不了，类似于笛卡尔积，会多出许多重复的条目
原因：
原因是MyBatis中进行结果映射时是用数据库的列名进行查询的，这时如果多个表存在相同的字段名时，他们就会重复，不会合并，这是MyBatis这里的规则。
解决方案一：select查询时用别名查询
解决方案二：修改数据库中没有相同的字段名即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87646260d2b888abea82e60ec6a1c15a/" rel="bookmark">
			关于Vue数组，对象数据变化无法更新到视图问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题原因：Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。
数组详解
数组数据变动，使用某些方法操作数组，变动数据时，有些方法无法被vue监测
push()，pop()，splice()，sort()，reverse()可被vue检测到
filter(), concat(), slice()。这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组
解决方法
一、使用官方推荐
this. s e t ( a r r ∣ o b j , i n d e x ∣ k e y , v a l u e ) t h i s . set( arr | obj , index | key, value ) this. set(arr∣obj,index∣key,value)this.delete(arr | obj , index | key)
二、vue多层循环，动态数据改变后渲染很慢或者不渲染
尝试在方法第一行加上
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87646260d2b888abea82e60ec6a1c15a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5346ae7639326c99ccb0a96973dc445/" rel="bookmark">
			java json字符串转map 字段顺序错乱问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.73&lt;/version&gt; &lt;/dependency&gt; 默认可以使用JSON.parseObject将字符串转成Map，但是如果json中有多个key-value，则转换后的顺序可能颠倒。如下
public static void main(String[] args) { String content = "{\"text1\":\"123\",\"text2\":\"456\",\"text3\":\"789\"}"; Map paraMap = JSON.parseObject(content); System.out.println(paraMap.toString()); } 运行结果：
{"text3":"789","text1":"123","text2":"456"} 使用JSON.parseObject(content, LinkedHashMap.class, Feature.OrderedField)可以解决这个问题
public static void main(String[] args) { String content = "{\"text1\":\"123\",\"text2\":\"456\",\"text3\":\"789\"}"; Map paraMap = JSON.parseObject(content, LinkedHashMap.class, Feature.OrderedField); System.out.println(paraMap.toString()); } 运行结果：
{text1=123, text2=456, text3=789} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa20adc31d376ee5ff40d0095dcfd6ea/" rel="bookmark">
			Linux vim中如何不带行号复制大段代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1&gt;只可以在vim复制
2&gt;可以复制到外界的
1&gt;只可以在vim复制 末行模式下 使用命令 v 进入可视模式
此时使用 “上下左右键”，选中想要复制的部分，在vim中可以看到选中的文本变颜色，就像在windows系统下的shift键加上鼠标左键的效果一样
命令 y 复制,p粘贴
2&gt;可以复制到外界的 按照常规复制，结果如下
1 #include&lt;stdio.h&gt; 2 #include&lt;stdlib.h&gt; 3 #include&lt;unistd.h&gt; 4 5 int main(int argc,char* argv[],char *envp[]) 6 { 7 printf("main pid =%d\n",getpid()); 8 execle("/usr/bin/ps","ps","-f",(char*)0,envp);//需要传入环境变量 9 // execlp("ps","ps","-f",(char*)0); 10 //execl("/usr/bin/ps","ps","-f",(char*)0); 11 printf("execl err\n"); 12 13 exit(0); 14 } 15 ~ 带有行号，后面再次复制不方便，那么如何不带行号复制呢？
按住Ctrl键，选择想要的区域，右键复制就好啦
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;unistd.h&gt; int main(int argc,char* argv[],char *envp[]) { printf("main pid =%d\n",getpid()); execle("/usr/bin/ps","ps","-f",(char*)0,envp);//需要传入环境变量 // execlp("ps","ps","-f",(char*)0); //execl("/usr/bin/ps","ps","-f",(char*)0); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa20adc31d376ee5ff40d0095dcfd6ea/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/62/">«</a>
	<span class="pagination__item pagination__item--current">63/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/64/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>