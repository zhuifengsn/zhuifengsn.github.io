<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceaf69cea70d6598859bf74862afdcd5/" rel="bookmark">
			DCM4CHE处理解压缩的DICOM文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在处理dicom转jpg的时候，发现dcm文件分为压缩与非压缩两种类型，而对于dcm4che中给到的dcm转jpg都是对非压缩dcm的处理，而对于压缩的dcm文件需要先解压，再做图像转换。
1.查看dcm4che/dcm4che-tool工具类https://github.com/dcm4che/dcm4che/tree/master/dcm4che-tool，需要用到dcm4che-tool-dcm2dcm和dcm4che-tool-dcm2jpg；
2. pom需要用到的dcm依赖包
&lt;dependency&gt; &lt;groupId&gt;org.dcm4che&lt;/groupId&gt; &lt;artifactId&gt;dcm4che-imageio&lt;/artifactId&gt; &lt;version&gt;5.22.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.dcm4che&lt;/groupId&gt; &lt;artifactId&gt;dcm4che-imageio-opencv&lt;/artifactId&gt; &lt;version&gt;5.22.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.weasis.opencv&lt;/groupId&gt; &lt;artifactId&gt;weasis-opencv-core&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.dcm4che&lt;/groupId&gt; &lt;artifactId&gt;dcm4che-image&lt;/artifactId&gt; &lt;version&gt;5.22.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.dcm4che&lt;/groupId&gt; &lt;artifactId&gt;dcm4che-core&lt;/artifactId&gt; &lt;version&gt;5.22.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.dcm4che.tool&lt;/groupId&gt; &lt;artifactId&gt;dcm4che-tool-common&lt;/artifactId&gt; &lt;version&gt;5.22.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;/dependency&gt; 3. 测试类
import java.io.IOException; public class TestClass { public static void main(String[] args) throws IOException { String srcPath = "D:\\1.dcm"; String desPath = "D:\\2.dcm"; String desImgPath = "D:\\3.jpg"; // 解压压缩的dcm（非压缩的dcm也可以执行这一步） Dcm2DcmUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ceaf69cea70d6598859bf74862afdcd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a03b1eb504c534ef3ba10b6db10901bb/" rel="bookmark">
			PTA 打印沙漏（java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1027 打印沙漏 (20分) 本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印
***** *** * *** ***** 沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。
给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。
输入格式: 输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。
输出格式: 首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。
输入样例: 19 * 输出样例:` ***** *** * *** ***** 2 样例解答： 此题注意：每行只要输入前一部分空格即可
import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); String s = sc.next(); int sum=n-1,i; for(i=3;sum&gt;=0;i+=2) { sum-=i*2; } sum+=(i-2)*2; i-=4; for(int j=i;j&gt;=1;j-=2) { int k; for(k=0;k&lt;(i-j)/2;k++) { System.out.print(" "); } for(k=0;k&lt;j;k++) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a03b1eb504c534ef3ba10b6db10901bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d5107205ad5945066db49fdcaa84699/" rel="bookmark">
			运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运算主要分为：加，减，乘，除，乘方 +， - ，× ，÷ ，^ 下面来详细讲解一下每个运算的定义和方法
加（+）：定义：一个数和另一个数的和。 运算方法： #include&lt;bits/stdc++.h&gt; using namespace std; int main(){ int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;a+b; return 0; } 但有时候数字会很大，我们怎么办呢？ 第一种方法：卡常，有时候能直接蒙混过关（建议别用）
第二种方法：高精度
具体做法：输入的是字符串，因为long long 放不下
然后将每一位数存入数组的一个格子里
a,b数组是初始的两个数，c数组是最终的结果
注意：有可能有进位 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=100; int a[105],b[105],c[105]; int len_a,len_b,len_c; string s; int main(){ cin&gt;&gt;s; len_a=s.length(); for(int i=0;i&lt;len_a;i++) a[len_a-i]=s[i]-48; cin&gt;&gt;s; len_b=s.length(); for(int i=0;i&lt;len_b;i++) b[len_b-i]=s[i]-48; int i,x=0; for(i=1;i&lt;=len_a||i&lt;=len_b;i++) { c[i]=a[i]+b[i]+x; x=c[i]/10; c[i]%=10; } c[i]=x; len_c=i; while(c[len_c]==0&amp;&amp;len_c&gt;1) len_c--; for(int i=len_c;i&gt;=1;i--) cout&lt;&lt;c[i]; return 0; } ----
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d5107205ad5945066db49fdcaa84699/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc0ac8b54648e286f5d6b116713f4140/" rel="bookmark">
			java基础---表达式的分类和表达式的优先级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.表达式的分类 (1)按照复杂程度来分: 简单表达式: 只有一个运算符的表达式 a + b , a * 6 , 4 - 3,
复杂表达式: 两个或者两个以上的运算符组成的表达式 a &gt; b &amp;&amp; a &lt; b,如果复杂表达式就必须要知道运算符的优先级
(2)按照运算符两边的操作数来分: 单目:+5
双目:3+a
三目:x ? y: z
(3)按照名称来分: a + b 算数表达式
2.运算符的优先级 (1)有括号先计算括号里面的
(2)单目运算符 &gt; 双目运算符 &gt; 三目运算符
(3)算数运算符(* / % &gt; + -) &gt; 关系运算符(&gt; &lt;… &gt; == !=) &gt; 逻辑运算符(&amp;&amp; &gt; ||) &gt; 条件运算符(三目运算符) &gt; 赋值运算符&gt;位运算符
(4)如果运算符的优先级相同,从左至右即可
(5)在单目里面:+ -大于++ –
3.运算符的优先级一览表: 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd3d2f5482d40e24cbb517a210a673a1/" rel="bookmark">
			两个有序链表序列的合并 (20分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 已知两个非降序链表序列S1与S2，设计函数构造出S1与S2合并后的新的非降序链表S3。
输入格式:
输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用−1表示序列的结尾（−1不属于这个序列）。数字用空格间隔。
输出格式:
在一行中输出合并后新的非降序链表，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出NULL。
输入样例:
1 3 5 -1 2 4 6 8 10 -1 输出样例:
1 2 3 4 5 6 8 10 #include&lt;bits/stdc++.h&gt; using namespace std; int a[9000000]; bool cmp(int a,int b) { if(a&lt;b)return 1; else return 0; } int main(void) { int s,i=0; while((scanf("%d",&amp;s))!=EOF) { if(s!=-1) a[i++]=s; } int len=i; sort(a,a+len,cmp); for(int i=0; i&lt;len; i++) { printf("%d",a[i]); if(i!=len-1) { printf(" "); } } if(len==0)printf("NULL"); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b19c217d684cf1cdb4a222f8ae87433/" rel="bookmark">
			Java中的回调函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回调函数 1.定义 在计算机程序设计中，回调函数，或简称回调（Callback 即call then back 被主函数调用运算后会返回主函数），是指通过函数参数传递到其它代码的，某一块可执行代码的引用。这一设计允许了底层代码调用在高层定义的子程序。
在java的回调函数，以类A调用类B方法为例
在类A中方法a调用了类B中的b方法，b方法在执行完成之后，会执行类A中的callback()方法，这个callback方法就是回调函数，表明类B的b方法执行完成。
2.同步回调 同步回调的话会等待回调函数执行完成之后才执行其他的业务。
以儿子要坐火车出远门，跟妈妈告别，到了学校之后打电话告诉自己到学校这件事为例：
接口：
public interface Callable { /** * 回调函数 */ public void call(); } 妈妈：
/** * @author xiaobai */ //定义类Mother实现了Callable接口，实现了call()回调函数的具体内容 public class Mother implements Callable { Son son; public Mother(Son son) { this.son=son; } //表示妈妈和儿子的分别函数，儿子在这期间搭乘火车离开 public void parting() { System.out.println("开始执行同步回调函数"); son.rideTrain(this); System.out.println("同步回调函数执行完成"); } @Override public void call() { System.out.println("儿子到学校了"); } } 儿子：
public class Son { public void rideTrain(Callable callable) { try { //模拟坐火车 Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b19c217d684cf1cdb4a222f8ae87433/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6fdc7b462e5f5ef47ba0e8ac73575f5/" rel="bookmark">
			bfs解决洛谷P1443 马的遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		马的遍历 题目链接
题目描述 有一个n*m的棋盘(1&lt;n,m&lt;=400)，在某个点上有一个马,要求你计算出马到达棋盘上任意一个点最少要走几步。
输入格式
一行四个数据，棋盘的大小和马的坐标
输出格式
一个n*m的矩阵，代表马到达某个点最少要走几步（左对齐，宽5格，不能到达则输出-1）
样例输入
3 3 1 1
样例输出
0 3 2
3 -1 1
2 1 4
解题思路 首先要知道的是马走"日"字，如图，可以从中心圆的位置到达五角星的位置。
那我们就可以遍历八个方向，所到达的点是否是满足条件的（是否在图内，是否已经走过），每走一步，步数加一，就可以直接把当前的步数给到二维数组a（存储结果的数组）。
代码如下 #include&lt;bits/stdc++.h&gt; using namespace std; int a[405][405]; bool vis[405][405]; int dir[8][2] = {{2,1},{2,-1},{-2,1},{-2,-1},{1,2},{1,-2},{-1,2},{-1,-2}}; int n,m; int x,y; struct node { int x,y; int step; }; void bfs() { queue&lt;node&gt;q; node start; start.x = x; start.y = y; start.step = 0; vis[x][y] = true; a[x][y] = 0; q.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6fdc7b462e5f5ef47ba0e8ac73575f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/599bbc9d942a9141badaa6771961ea67/" rel="bookmark">
			福禄克寻线仪使用方法图解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在网络时代，网络布线已经进入了千户万户的企业中家庭中，面对凌乱混杂的布线环境，只有用到寻线仪这种工程师专门设计的省时省力的好工具才能高效解决，寻线仪的种类千千万万，但是寻线仪的使用方法却都是一样的，下面明辰智航的小编给大家分享寻线仪使用方法图解。
做网络这块都知道灵活运用寻线仪，可以解决网络工程师的不少时间。就拿寻线仪最经典的品牌福禄克的使用方法来说吧。
第一步：安装电池
电池一定要安装好，两个接口对应的接口
第二步：本期测试（寻线讲解）
如图：
首页把故障线插入音频发生器接口
然后音频发生器轮盘转到如图所示的图标
然后拿出指针（轮盘转到图上对应的图标）
然后拿着指针去网线的另一端
如果线端在附近会指针会发出声音并且表面会显示数字，距离越远就会显示1-2-3-4-5-6-7-8
距离越近就会显示8的数字（如图所示）
那么这就是我们的故障线就找到了。
然后把找到的那根故障线插到指针后面的网线接口，指针轮盘转到（cablemap按钮）线序会依次显示，哪个数字下的指示灯没有亮就是问题所在。
好了，本期明辰智航的小编测得是寻线仪寻线功能，当然寻线仪还有很多功能。想要快速了解或者学习寻线仪使用方法图解的功能资料可以去我们明辰智航的网站学习哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93fcc44d5986327b1bf8b18b0e31a488/" rel="bookmark">
			python中HTML文档转义与反转义方法介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在网页抓取的过程中，往往会遇到一些转义字符，特别是文章内容里面。这种情况很让人反感，那么，应该如何处理这些转移字符，也就是反转义回去呢？
unescape()方法
python3中使用html包里面的unescape()方法可以解决！
源文档
反转义回去后
当然，与unescape()方法相对应的方法是escape()方法
escape()方法
源文档
转义之后
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28f0f5fdf0bf3207a6c815701b80471e/" rel="bookmark">
			解决Spring Boot 配置SSL之后项目启动443端口占用问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 之前我把我的博客从http协议更改成了https协议,不知道的小伙伴可以点击蓝字传送:Spring Boot 项目如何配置 Https ,然后又配置了将http访问自动转向https,没看过的小伙伴可以点击蓝字传送:Spring boot HTTP访问自动转向HTTPS .项目我是在本地存了一份,运行本地项目的时候突然报443端口占用,我看了一下我的配置.如下: #443端口号 server.port=443 #ssl证书文件位置 server.ssl.key-store=classpath:3958096_yangchong.vip.pfx #证书密码 server.ssl.key-store-password=kqER77i2 server.ssl.keyStoreType=PKCS12 配置没啥问题,遂想到是不是443端口被占用了.然后我使用命令查看了一下所有端口: 打开命令提示符,输入以下指令:
netstat -ano //或者输入下面的指令 netstat -ano |findstr "端口号" 赫然发现443被一个pid为37628的进程占用着. 查看该pid对应的程序: tasklist |findstr "进程id号" 于是我尝试杀掉该进程: taskkill /f /t /im "进程id或者进程名称" 结果: 解决方案: 打开VM虚拟机,点击菜单中的“编辑-首选项”,把共享虚拟机给关闭; 关闭之后查看443端口占用情况: 项目成功启动大功告成~~ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57e164431d9a10066cfa50c786b6120a/" rel="bookmark">
			“特质波动率之谜”（Idiosyncratic Volatility），用Python计算特质波动率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hello，大家好，今天给大家介绍的是有关于“特质波动率”度量的相关内容。曾在写本科毕业论文时有所涉及，当时看了好多资料，发现它还有很多研究空间，并且由Ang所提出的“特质波动率之谜”的现象至今也未有合理的解释。所以今天就给大家用python对“特质波动率”进行计算。
特质波动率 “特质波动率之谜”的介绍特质波动率的度量方法Python代码相关文章获取代码 “特质波动率之谜”的介绍 风险与收益一直是金融学中形影不离的两个概念。经典的CAPM模型，只考虑了系统性风险，认为股票预期收益率只与市场风险溢价有关。直到1972年，Jensen，Black和Scholes对传统金融学理论提出了不同的看法，认为非系统性风险与股票收益率是存在一定的相关关系，并首次提出了特质波动率的概念。Merton曾从供需的角度来解释这两者之间的关系，认为投资者会对系统风险和非系统风险都要求进行一定的风险补偿，而这一解释也被大家广泛地接受与认可。
一般来讲，我们都认为风险与收益应该是正相关，即风险越高，收益率越高。但在2006年，Ang等人却得出了不一样的结论，他们借助Fama-French三因子模型却发现特质波动率与预期收益率之间的关系变为负相关关系。目前尚未有公认的理论可以解释这种异象，因此引起了剧烈的争论，而这一异象也被称为“特质波动率之谜”。
特质波动率的度量方法 在特质波动率的度量方面，我利用Fama-French三因子模型进行计算
（有关三因子模型的介绍与代码在之前的文章有所讲解，读者们可见文末链接）
首先，通过三因子模型，得到每日的残差，即ε
然后，计算残差的波动率，即当月残差标准差乘以当月总交易天数。
这样就得到我们所要的特质波动率了。
Python代码 Python实现的过程中，我们只需要使用pandas、statsmodels.formula.api两个包即可完成：
import pandas as pd import statsmodels.formula.api as smf 首先，读取数据，我从锐思数据库中，下载了创业板中2015-2019年所有股票每日收益率、无风险收益率以及创业板每日的三因子：
Factors = pd.read_excel("F:\\公众号\\图文素材\\特质波动率\\Data.xlsx", sheetname = 0, header = 0) Return = pd.read_excel("F:\\公众号\\图文素材\\特质波动率\\Data.xlsx", sheetname = 1, header = 0) NoRisk = pd.read_excel("F:\\公众号\\图文素材\\特质波动率\\Data.xlsx", sheetname = 2, header = 0) 为了后续筛选日期方便，我们需要将“日期”的数据类型更改为日期型：
Factors['Date'] = pd.to_datetime(Factors['Date']) Return['Date'] = pd.to_datetime(Return['Date']) NoRisk['Date'] = pd.to_datetime(NoRisk['Date']) 通过pd.merge()将数据进行合并：
Data = pd.merge(pd.merge(Factors, Return, on = 'Date'), NoRisk, on = 'Date') 参数说明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57e164431d9a10066cfa50c786b6120a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2aa13c11e3478eea8827e476a7ce100/" rel="bookmark">
			2020.6.16
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嗯
又是一节信息课
这节课我们学习编稿，改稿
还是比较轻松的
只是比较繁琐
修改了好几次才过
然后就下课了
拜拜
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/888653c6dc7c347c5ccdc1da98cdf1fa/" rel="bookmark">
			TreeSize Free
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TreeSize Free是一款硬盘空间管理工具，用树形描述出来，能够显示文件大小和实际占用空间数及浪费的空间等信息
官网下载：https://www.jam-software.com/treesize_free
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3812e58fad9c3081457ffb60cdbc98e1/" rel="bookmark">
			个人主页的计数器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，你需要知道这个网站：https://www.hit-counts.com
进去之后在右边输入你的信息
左边是计数器的样式，右边你自己输入你的信息，然后点一下右下角的 generate code就会出现这样：
然后在中间的文本框里找到这样的句子：http://www.hit-counts.com/counter.php?t=MTQ0OTE0OA
复制，然后用连接插入就行了。
好了，讲完了，大家别忘给个赞再走啊！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f05170ae99acf9f9b74a6faef9b118f4/" rel="bookmark">
			如何快速查找网线-寻线仪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在网上看到好多小伙伴提问，想知道如何快速查找网线或是如何找对应端口的网线？情况大多是网线上没有标识，而网线分布比较复杂，想从房间的端口找到机房对应的网线端口。这种情况下，就必须用到一款机房必备工具寻线仪。
寻线仪又叫查线器，是日常网络机房管理维护的必备工具。它由信号发声器和寻线器组成，其工作原理：信号发声器发出的声音信号通过RJ45/RJ11通用接口接入目标线缆的端口上，至使目标线缆回路周围产生一环绕的声音信号场，用高灵敏度感应式寻线器很快在回路沿途和未端识别它发出的信号场，从而找到这条目的线缆。福禄克代表（18600295382）
需要的工具找到了，那选择一款适合的寻线仪也十分重要。对于寻线仪来说，最核心的功能就是能否快速准确的查找到对应线缆。在这里，小编为小伙伴们推荐一款好用的寻线仪——福禄克寻线仪MT-8200-60-KIT，它查线的快速和准确，秒杀其他品牌的寻线仪。小编之前也用过好多品牌的寻线仪，比如精明鼠、杉木林，一但遇到复杂的网络环境，就很难快速找到对应网线，最后往往需要手动插拔确认。而福禄克的这款查线仪就没有这种困惑，再复杂的环境都能快速准确找到网线，节省了大量找线的时间。
有了好用的寻线仪，再也不用担心如何查找网线的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94fa0a1a633442176150ecb88d25fd2e/" rel="bookmark">
			布隆过滤器究竟是什么，这一篇给讲的明明白白的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：jack_xu
juejin.im/post/5e9c110151882573793e8940
不知道从什么时候开始，本来默默无闻的布隆过滤器一下子名声大燥，在面试中面试官问到怎么避免缓存穿透，你的第一反应可能就是布隆过滤器，缓存穿透=布隆过滤器成了标配，但具体什么是布隆过滤器，怎么使用布隆过滤器不是很清楚，那今天我们就来把它说清楚，讲明白。
缓存穿透 大家看下这幅图，用户可能进行了一次条件错误的查询，这时候redis是不存在的，按照常规流程就是去数据库找了，可是这是一次错误的条件查询，数据库当然也不会存在，也不会往redis里面写值，返回给用户一个空，这样的操作一次两次还好，可是次数多了还了得，我放redis本来就是为了挡一挡，减轻数据库的压力，现在redis变成了形同虚设，每次还是去数据库查找了，这个就叫做缓存穿透，相当于redis不存在了，被击穿了，对于这种情况很好解决，我们可以在redis缓存一个空字符串或者特殊字符串，比如&amp;&amp;，下次我们去redis中查询的时候，当取到的值是空或者&amp;&amp;，我们就知道这个值在数据库中是没有的，就不会在去数据库中查询，ps：这里缓存不存在key的时候一定要设置过期时间，不然当数据库已经新增了这一条记录的时候，这样会导致缓存和数据库不一致的情况
上面这个是重复查询同一个不存在的值的情况，如果应用每次查询的不存在的值是不一样的呢？即使你每次都缓存特殊字符串也没用，因为它的值不一样，比如我们的数据库用户id是111，112，113，114依次递增，但是别人要攻击你，故意拿-100，-936，-545这种乱七八糟的key来查询，这时候redis和数据库这种值都是不存在的，人家每次拿的key也不一样，你就算缓存了也没用，这时候数据库的压力是相当大，比上面这种情况可怕的多，怎么办呢，这时候我们今天的主角布隆过滤器就登场了。
从一道面试题说起 问：如何在海量元素中（例如 10 亿无序、不定长、不重复）快速判断一个元素是否存在？好，我们最简单的想法就是把这么多数据放到数据结构里去，比如List、Map、Tree，一搜不就出来了吗，比如map.get(),我们假设一个元素1个字节的字段，10亿的数据大概需要 900G 的内存空间，这个对于普通的服务器来说是承受不了的，当然面试官也不希望听到你这个答案，因为太笨了吧，我们肯定是要用一种好的方法，巧妙的方法来解决，这里引入一种节省空间的数据结构，位图，他是一个有序的数组，只有两个值，0 和 1。0代表不存在，1代表存在。
有了这个屌炸天的东西，现在我们还需要一个映射关系，你总得知道某个元素在哪个位置上吧，然后在去看这个位置上是0还是1，怎么解决这个问题呢，那就要用到哈希函数，用哈希函数有两个好处，第一是哈希函数无论输入值的长度是多少，得到的输出值长度是固定的，第二是他的分布是均匀的，如果全挤的一块去那还怎么区分，比如MD5、SHA-1这些就是常见的哈希算法。
我们通过哈希函数计算以后就可以到相应的位置去找是否存在了，我们看红色的线，24和147经过哈希函数得到的哈希值是一样的，我们把这种情况叫做哈希冲突或者哈希碰撞。哈希碰撞是不可避免的，我们能做的就是降低哈希碰撞的概率，第一种是可以扩大维数组的长度或者说位图容量，因为我们的函数是分布均匀的，所以位图容量越大，在同一个位置发生哈希碰撞的概率就越小。但是越大的位图容量，意味着越多的内存消耗，所以我们想想能不能通过其他的方式来解决，第二种方式就是经过多几个哈希函数的计算，你想啊，24和147现在经过一次计算就碰撞了，那我经过5次，10次，100次计算还能碰撞的话那真的是缘分了，你们可以在一起了，但也不是越多次哈希函数计算越好，因为这样很快就会填满位图，而且计算也是需要消耗时间，所以我们需要在时间和空间上寻求一个平衡。
布隆过滤器 当然，这个事情早就有人研究过了，在 1970 年的时候，有一个叫做布隆的前辈对于判断海量元素中元素是否存在的问题进行了研究，也就是到底需要多大的位图容量和多少个哈希函数，它发表了一篇论文，提出的这个容器就叫做布隆过滤器。
大家来看下这个图，我们看集合里面3个元素，现在我们要存了，比如说a，经过f1(a)，f2(a)，f3(a)经过三个哈希函数的计算，在相应的位置上存入1，元素b，c也是通过这三个函数计算放入相应的位置。当取的时候，元素a通过f1(a)函数计算，发现这个位置上是1，没问题，第二个位置也是1，第三个位置上也是 1，这时候我们说这个a在布隆过滤器中是存在的，没毛病，同理我们看下面的这个d，通过三次计算发现得到的结果也都是1，那么我们能说d在布隆过滤器中是存在的吗，显然是不行的，我们仔细看d得到的三个1其实是f1(a)，f1(b)，f2(c)存进去的，并不是d自己存进去的，这个还是哈希碰撞导致的，我们把这种本来不存在布隆过滤器中的元素误判为存在的情况叫做假阳性（False Positive Probability，FPP）。
我们再来看另一个元素，e 元素。我们要判断它在容器里面是否存在，一样地要用这三个函数去计算。第一个位置是 1，第二个位置是 1，第三个位置是 0。那么e元素能不能判断是否在布隆过滤器中？答案是肯定的，e一定不存在。你想啊，如果e存在的话，他存进去的时候这三个位置都置为1，现在查出来有一个位置是0，证明他没存进去啊。。通过上面这张图加说明，我们得出两个重要的结论
从容器的角度来说：
如果布隆过滤器判断元素在集合中存在，不一定存在
如果布隆过滤器判断不存在，一定不存在
从元素的角度来说：
如果元素实际存在，布隆过滤器一定判断存在
如果元素实际不存在，布隆过滤器可能判断存在
小伙们请牢记
Guava实现布隆过滤器 java为什么写的人多，基数大，因为是开源的，拥抱开源，框架多，轮子多，而且一个功能的轮子还不止一个，光序列化就有fastjson，jackson，gson，随你挑任你选，那布隆过滤器的轮子就是google提供的guava，我们用代码来看一下使用方法
首先引入我们的架包
&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;21.0&lt;/version&gt; &lt;/dependency&gt; 这里先往布隆过滤器里面存放100万个元素，然后分别测试100个存在的元素和9900个不存在的元素他们的正确率和误判率
//插入多少数据 private static final int insertions = 1000000; //期望的误判率 private static double fpp = 0.02; public static void main(String[] args) { //初始化一个存储string数据的布隆过滤器,默认误判率是0.03 BloomFilter&lt;String&gt; bf = BloomFilter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94fa0a1a633442176150ecb88d25fd2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/954abcfa0e09a3cd7b797fba01435eb1/" rel="bookmark">
			给大家分享一个免费的去全网短视频水印的微信小程序，支持100多个平台！支持修改md5，视频直接去重上热门！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给大家分享一个免费的去全网短视频水印的微信小程序，支持100多个平台！支持修改md5，视频直接去重上热门！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfef94990f30e7f89fc42a252dd7011c/" rel="bookmark">
			数值计算—方程求根（C语言&#43;二分法、牛顿法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		求解方程：x3-0.2x2-0.2x-1.2=0的根
编写二分法、牛顿法程序，分析运行结果。
思想： 二分法 给定区间，并设f(a)与f(b)符号相反，取Ɛ1为根的允许误差，Ɛ2为｜f(x)｜的允许误差。
1）c=（a+b）/ 2；
2）如果（c-a）&lt; Ɛ1或｜f( c )｜&lt; Ɛ2，则输出 c，结束；否则执行3）；
3）如果 f( a )·f( b ) &gt; 0，则令 a=c，否则令 b=c，重复以上步骤。
牛顿迭代法 给定初值x0，取Ɛ1为根的允许误差，Ɛ2为｜f(x)｜的允许误差，N为迭代次数的允许值。
1）如果 f’(x0)=0 或迭代次数大于N，则算法失败，结束，否则执行2）；
2）计算 x1 = x0 - (f(x0) / f’(x0));
3）若｜x1 - x0｜&lt; Ɛ1或｜f(x1)｜&lt; Ɛ2,则输出x1，程序结束，否则执行4）；
4）令 x0 = x1，转向1）。
代码： //二分法 #include &lt;stdio.h&gt; #include &lt;math.h&gt; float Bisection(float a, float b, float (*f)(float)) { float c,fa=(*f)(a),fb=(*f)(b),fc=(*f)(c); int n=1; printf("二分次数 \t c \t f(c)\n"); while(1){ if(fa * fb &gt; 0){ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfef94990f30e7f89fc42a252dd7011c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2a26c129378a56fd8e9ab11bb789614/" rel="bookmark">
			电磁场仿真实验【matlab】带电粒子在磁场中的受力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验： 电磁波的反射干涉 实验：静电场的边值问题 实验：带电粒子在磁场中的受力 实验：电磁波的极化 (1)电场强度和磁场强度都不为零； (2)电场强度为零，磁场强度不为零； (3)电场强度不为零，磁场强度为零。 磁聚焦现象 磁镜现象 Matlab主函数部分： %不同情况，需要更改调用的函数 [t,w]=ode23(@ifun1,[0:0.1:20],[0,0.01,0,6,0,0.01],[ ]); plot3(w(:,1),w(:,3),w(:,5));%绘制轨迹 grid on title('b\neq0,e\neq0')%标题每次改一下 电场强度和磁场强度都不为零； function dwdt=ifun(t,w)%b e不等于0 q=1.6e-2; e=1; b=1; m=0.02;%设置条件 dwdt=[w(2); q.*b./m.*w(4); w(4); (q.*e./m)-(q.*b./m).*w(2); w(6); 0;];%建立微分方程 end 电场强度为零，磁场强度不为零； function dwdt=ifun1(t,w)%b e不等于0 q=1.6e-2; e=0; b=1; m=0.02;%设置条件 dwdt=[w(2); q.*b./m.*w(4); w(4); (q.*e./m)-(q.*b./m).*w(2); w(6); 0;];%建立微分方程 end 电场强度不为零，磁场强度为零。 function dwdt=ifun2(t,w)%b e不等于0 q=1.6e-2; e=1; b=0; m=0.02;%设置条件 dwdt=[w(2); q.*b./m.*w(4); w(4); (q.*e./m)-(q.*b./m).*w(2); w(6); 0;];%建立微分方程 end 磁聚焦现象 t=0:0.01:2*pi; a1=0.5.*(t-pi); for m=[-16:2:10]*pi/180 axis([0 7 -1 1 -0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2a26c129378a56fd8e9ab11bb789614/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19f1c01cf9f5710ba01b8202f5a6252d/" rel="bookmark">
			搬运小视频为什么要修改MD5值？什么是MD5？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MD5的全称是Message-Digest Algorithm 5，它一种被广泛使用的密码散列函数，可以产生出2113一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。
MD5值等同于文件的ID，它的值5261是唯一的。 如果文件已被修改（例如嵌入式病毒，特洛伊木马等），其MD5值将4102发生变化。 因此，一些常规下载URL提供文件MD并且通常提供MD5值。 如果用户在下载后发现他们的MD5值与网站公告不一致1653，可能是文件被修改过或者下载出错。
修改MD5值肯定是可以增加视频的原创度的，这一点类似于我们做网站发布文章，把文章内容稍微打乱一点，也是可以增加原创度的，效果当然比不上原创，但了胜于无，做了总比没做要强。
对于大量搬运的视频，我们要改MD5就有点麻烦了，我这里给大家提供一款破解版的批量修改工具，大家可以去下载试一下。不用安装的，但是千万不要升级，软件打开后十秒左右会提示升级，关掉就行，千万千万不要升级，升级就要看广告才可以用了哦！
以上就是搬运小视频为什么要修改MD5值？什么是MD5？的全部内容，有喜欢的点下关注，定时更新一些常用小工具。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/96/">«</a>
	<span class="pagination__item pagination__item--current">97/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/98/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>