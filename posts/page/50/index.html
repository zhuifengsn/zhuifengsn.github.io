<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b93f0a6d593c60504fdf5e654363583/" rel="bookmark">
			java每日一练(4)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java每日一练(4)
文章目录 单选部分不定项选择题多选题编程题 单选部分 1.下列与队列结构有关联的是（）
A 函数的递归调用
B 数组元素的引用
C 多重循环的执行
D 先到先服务的作业调度
队列的特点 ： 先进先出 , 所以 答案非常明显 D
2.类所实现接口的修饰符不能为（）
A void
B public
C abstract
D final
答案 ： 这里我们的类被 final 修饰 是不能够继承的 , 而我们的接口本来就是用来被实现，然后重写里面的方法的，此时如果修饰了就不能进行重写了 ，所以
这里不能使用 final 修饰我们的接口
3.下列叙述正确的是（ ）。
A 算法就是程序
B 设计算法时只需要考虑数据结构的设计
C 设计算法时只需要考虑结果的可靠性
D 以上三种说法都不对
答案　：　D　很明显　A B C 都是错误的　．
４.下面关于abstract关键字描述错误的是（）
A abstract关键字可以修饰类或方法
B final类中的方法都不能是abstract，因为final类不能有子类
C abstract类不能实例化
D abstract类的子类必须实现其超类的所有abstract方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b93f0a6d593c60504fdf5e654363583/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08bb39a0d46e576d2be31282cb44da9e/" rel="bookmark">
			基于51单片机的教室智能照明控制系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		硬件方案 本系统以51单片机作为控制模块的核心部件，采用热释红外人体传感器检测人体的存在，采用光敏三极管构成的电路检测环境光的强度；根据教室合理开灯的条件，通过对人体存在信号和环境光信号的识别与判断，完成对教室灯光的智能控制，避免了教室用电的大量浪费。系统还具有报警功能；同时还采用了软/硬件的“看门狗”等抗干扰措施。
整体电路主要由51单片机STC89C52、时钟芯片DS1302、液晶屏LCD1602、比较器芯片LM339、光敏电阻、红外对管、按键、LED等构成；原理图如图：
PCB及仿真图：
设计功能 使用4个LED灯模拟教室的照明灯，在符合条件开启时，人数小于10人亮一个灯，10-20人亮二个灯，20-30人亮三个灯，大于30人则全亮四个灯。教室使用两个红外对管来检测是否有人进入并进行人数统计，人数可以统计到二位数99人，并实时将人数显示到液晶屏LCD上，液晶屏同时显示实时日期/时间/星期。利用光敏电阻检测教室的光线强弱；系统分自动/手动模式，可以通过按键切换模式，并有LED指示当前所在模式，在自动模式下，可以设定定时时间段，在定时时间段内，当教室有人（人数大于0）的情况下，如果光线暗弱则自动打开照明灯，照明灯点亮个数根据人数而定，不在定时时间段或者教室无人的情况下，关闭所有照明灯，另外在手动模式下，可以通过手动开关控制照明灯的亮灭，人数统计部分仍然生效。 软件设计 主程序源码
void main() { AUTO_LED=0; //默认自动模式 temperature=readtemperature(); init(); //液晶初始化 T0_init(); //定时器初始化 delay1(8000); while(1) { if(Adjust==0) //非调节模式下显示时间人数和温度 { temperature=readtemperature(); //读取温度 temperature_dispaly(3,temperature); //显示温度 Time_Display(); //显示时间 Open(); //动作判断,根据光线和声响开关 Count_Value(); //计算人数 } Keyscan(); //扫描键盘 } } void temperature_dispaly(char add,char dat) //温度显示函数：第一个：参数的地址，第二个：参数的内容 { uchar shi,ge; shi=dat/10; //把温度的十位提取出来 ge=dat%10; //把温度的个位提取出来 write_com(0x80+0x40+add); //要写的地址 write_date(0x30+shi); //十位的内容 1602字符库 write_date(0x30+ge); //个位的内容 1602字符库 } /*****************************************定时器初始化和主函数***********************************************************/ void T0_init(void) { TMOD=0x11; //设置定时器0为工作方式1 TH0=(65536-50000)/256; //50MS定时 TL0=(65536-50000)%256; EA=1; //开定时器T0的中断 总中断 ET0=1; //允许T0中断 // TR0=1; //开启定时器 } void Timer0() interrupt 1 //定时器T0中断函数 { TH0=(65536-50000)/256; //赋初值=50ms TL0=(65536-50000)%256; //TH0=3C,TL0=B0 Count++; //每中断一次，Count加一，计数20次，表示1s的时间到 if(Count&gt;=20) //1s到 { Count=0; Miao++; if(Miao&gt;=3) //3秒内无触发另一个，全部清零 { Miao=0; OUT1_flag=0; //清零 IN1_flag=0; TR0=0; //关闭定时器 } } } 资料链接：https://pan.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08bb39a0d46e576d2be31282cb44da9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c41ff5104223798ae51b8531f6768ee8/" rel="bookmark">
			Python实现PU口袋活动更新提醒
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PU口袋活动监控，为了让学生变得更加优秀变成分奴，学校要求学生在PU口袋参加活动从而获得第二课堂学分。便诞生了这个脚本…也是理论和实践相结合了吧。
直接复制，修改关键部分就可以使用了。
import requests import os import re import time from lxml import etree import smtplib import random from email.mime.text import MIMEText from email.mime.multipart import MIMEMultipart title = re.compile(".*?&lt;title&gt;(?P&lt;name&gt;.*?)&lt;/title&gt;") user_agent_list = ["Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36", "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36", "Mozilla/5.0 (Windows NT 10.0; WOW64) Gecko/20100101 Firefox/61.0", "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c41ff5104223798ae51b8531f6768ee8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68efcbb292cc9cc8a0cb803dd86ab00e/" rel="bookmark">
			pydroid3 v5.0更新。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在pydroid之前，安卓上写python代码各种麻烦，自从用了pydroid，各种烦恼迎刃而解。不过官方版的pydroid库文件装不了。基本的lxml，pandas都装不上。在快速安装点安装，提示需要安装一个插件，点下载吧因为和谐的原因又下载不了。经搜索又找到最新版的。
pydroid 3 v5.00 arm与arm64两个版本.
分别对应2个插件文件。
5.00arm版主程序和插件文件
链接:https://pan.baidu.com/s/1y6Cx8aIAPZN7cUhsBT72-Q 提取码:13x7 5.00arm64版主程序和插件文件
链接:https://pan.baidu.com/s/12JaV87nywFwRXtM3igOnbw 提取码:l04i apk 自行 安装，obb文件 自行 复制到 内置存储/android/obb/ru.iiec.pydroid3.quickinstallrepo/路径下。
ru.iiec.pydroid3.quickinstallrepo这个文件夹需要自己建。然后再复制obb文件吧。
重新打开程序，你会发现装不了的库可以安装了。快试试吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fa9fb5bb288c9f981338da5220e740d/" rel="bookmark">
			c语言入门(十三)--c&#43;&#43;引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、C++引用 对于c++，在创建源文件是应该如main.cpp以.cpp后缀结尾。
引用的作用：使用引用后，在子函数内的操作和函数外的操作手法一致，编程效率高，对于初学者友好。
引用使用场景：要在子函数中修改主函数的变量中变量的值时使用，不用修改不使用。
1.c++引用的便捷性 在子函数中修改普通变量的值 #include &lt;stdio.h&gt; void modify_num(int &amp;b){ // 形参中写&amp;，称为引用 b=b+1; } int main() { int a=0; modify_num(a); printf("after modify_num a=%d\n",a); // after modify_num a=1 return 0; } 等价于纯C代码：
#include &lt;stdio.h&gt; void modify_num(int *b){ // 形参中写&amp;，称为引用 *b=*b+1; } int main() { int a=0; modify_num(&amp;a); printf("after modify_num a=%d\n",a); // after modify_num a=1 return 0; } 在子函数中修改主函数一级指针变量的值(⭐️⭐️⭐️) #include &lt;stdio.h&gt; void modify_pointer(int *&amp;p, int *q){ p=q; } int main(){ int *p=NULL; int i=10; int *q=&amp;i; modify_pointer(p,q); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fa9fb5bb288c9f981338da5220e740d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37dea38ac44f60e78ed1603b35354c6b/" rel="bookmark">
			线性表之顺序表（C语言版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线性表之顺序表（C++版）http://t.csdn.cn/pEmnl
seqlist.h文件包含结构体的定义，函数的声明
#pragma once #include&lt;stdio.h&gt; #include&lt;malloc.h&gt; #include&lt;assert.h&gt; #define Initsel 8 #define INC_SIZE 8 typedef int ElemType;//代表当前元素的类型，方便修改 typedef struct SeqList { ElemType* base;//指向一个表,内容 int capacity;//容量 int size;//大小 }SeqList; void InitSeqList(SeqList* list);//初始化 void push_back(SeqList *list,ElemType val);//尾插 void Show(SeqList* list);//显示 void push_front(SeqList* list, ElemType val);//头插 void pop_back(SeqList *list);//尾删 void pop_front(SeqList* list);//头删 void inser_pos(SeqList* list, int val,int pos);//按位置插入 int find(SeqList* list, int val);//按值查找 int length(SeqList* list);//长度 void delete_pos(SeqList* list, int pos);//按位置删除 int delete_val(SeqList* list, int val);//按值删除 void sort(SeqList* list);//排序 void reverse(SeqList* list);//逆序 void swap(int&amp; a, int&amp; b);//交换函数 void clear(SeqList* list);//清空 void destroy(SeqList* list);//销毁 bool Inc(SeqList* list);//增加空间 list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37dea38ac44f60e78ed1603b35354c6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaf2aa753a6c4a436386d4b60d7234a0/" rel="bookmark">
			Linux进程总结详解（上——初识）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux进程 文章目录 Linux进程前言——先从硬件和软件谈起一、冯诺依曼体系结构二、操作系统概念 一、进程介绍概念进程控制块查看进程通过系统创建进程 二、进程状态1.内核代码如下： 总结 前言——先从硬件和软件谈起 一、冯诺依曼体系结构 定义：数学家冯·诺依曼提出了计算机制造的三个基本原则，即采用二进制逻辑、程序存储执行以及计算机由五个部分组成（运算器、控制器、存储器、输入设备、输出设备），这套理论被称为冯·诺依曼体系结构,如图： 输入设备：键盘、鼠标、网卡、显卡等等
输出设备：显示器，打印机等等
中央处理器(CPU)：运算器和控制器等
需要知道的是——冯.诺依曼体系结构是现代计算机的基础
现在大多计算机仍是冯.诺依曼计算机的组织结构,只是作了一些改进而已,并没有从根本上突破冯体系结构的束缚。
二、操作系统 计算机是各种硬件构成的，那么这些硬件就需要软件去操控。
概念 任何计算机系统都包含一个基本的程序集合，称为操作系统(OS)。笼统的理解，操作系统包括：
内核（进程管理，内存管理，文件管理，驱动管理）
其他程序（例如函数库，shell程序等等）
设计OS的目的
1.与硬件交互，管理所有的软硬件资源
2.为用户程序（应用程序）提供一个良好的执行环境
计算机软件和硬件之间的结构图如下：
一、进程介绍 概念 课本概念：程序的一个执行实例，正在执行的程序等
内核观点：担当分配系统资源（CPU时间，内存）的实体
（包含着程序代码 + 相关数据结构）
首先，程序就是我们所写的代码也就是一堆文字符号，而真正想要运行，得要和计算机软件硬件联系起来。按照课本上的定义，被加载到内存中的程序就叫做进程。而这些进程都是由操作系统来管理的。比如去分配资源比如时间片等等去进行各种调度策略这里我们不做赘述想要了解的同学可以去查查资料。
进程控制块 我们知道进程是由操作系统管理的，它管理的方式就是先描述再组织。我们知道linux操作系统是由C语言编写的，那么描述进程的结构就用的是结构体。描述进程的结构体也叫做PCB。
进程信息被放在一个叫做进程控制块的数据结构中，可以理解为进程属性的集合。课本上称之为PCB（process control block），在Linux操作系统下则是一个结构体task_struct。具体可参考task_struct结构体结构在linux系统下，描述进程的结构体是task_struct，是内核的一种数据结构，会被加载到RAM（内存中）并且保存着进程的信息。task_struct内容： 标示符: 描述本进程的唯一标示符，用来区别其他进程。
状态: 任务状态，退出代码，退出信号等。
优先级: 相对于其他进程的优先级。
程序计数器: 程序中即将被执行的下一条指令的地址。
内存指针: 包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针
上下文数据: 进程执行时处理器的寄存器中的数据[休学例子，要加图CPU，寄存器]。
I／O状态信息: 包括显示的I/O请求,分配给进程的I／O设备和被进程使用的文件列表。
记账信息: 可能包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。
其他信息
小结：一个程序想要运行的时候就会以进程的形式存在，当进程生成的时候，OS会给进程自动创建一个对应的PCB来管理进程。曾经我们运行各种程序的本质就是在操作系统上建立进程！！！
上边说完了描述进程，接下来说说怎么组织进程。
进程的组织方式一共有三种：
链接方式索引方式连接表方式
具体参考进程的组织方式，只需了解一下，本篇文章不做重点阐述。 如下图所示，在内存中多个进程都有自己的进程号id，一个进程是包含他的代码段和数据段以及相关的数据结构的。linux下task_struct中数据会保存对应进程数据和代码地址，而每一个进程之间也可以相互通信。
当CPU调度的时候，只需要提供给CPU ，PCB相关数据就会找到对应的进程去调度。
并且所有运行在系统里的进程都以task_struct链表的形式储存在内核里。
查看进程 Linux 内核提供了一种通过 /proc 文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。而系统中当前运行的每一个进程都有对应的一个目录在/proc下，以进程的 PID号为目录名，它们是读取进程信息的接口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eaf2aa753a6c4a436386d4b60d7234a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/425db6f024e9045980f7caf92df07f26/" rel="bookmark">
			基于51单片机的DS18B20温度显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本讲内容：
了解温度传感器DS18B20的使用，并通过一个例程展示温度传感器DS18B20测温过程。
DS18B20简介：
DS18B20 是单线数字温度传感器，即“一线器件”，其具有独特的优点：
（1）采用单总线的接口方式 与微处理器连接时 仅需要一条口线即可实现微处理器与 DS18B20 的双向通讯。 单总线具有经济性好，抗干扰能力强，适合于恶劣环境的现场温度测量，使用方便等优点，使用户可轻松地组建传感器网络。
（2）测量温度范围宽，测量精度高 。DS18B20 的测量范围为 -55 ℃ ~+ 125 ℃ ； 在 -10~+ 85°C 范围内，精度为 ± 0.5°C 。
（3）多点组网功能 多个 DS18B20 并联在惟一的单线上，实现多点测温。
DS18B20的存储器由一个高速暂存RAM和一个非易失性、电可擦除（E2）RAM组成。
0温度的低八位数据5保留（全1）1温度的高八位数据6保留2高温阀值7保留3低位阀值8前八位CRC效验值5配置寄存器 配置寄存器：
出场设置默认R0、R1为11。也就是12位分辨率，也就是1位代表0.0625摄氏度。
DS18B20经转换所得的温度值以二字节补码形式存放在高速暂存存储器的第0和第1个字节。所以当我们只想简单的读取温度值的时候，只用读取暂存器中的第0和第1个字节就可以了。
简单的读取温度值的步骤如下：
1：跳过ROM操作
2：发送温度转换命令
3：跳过ROM操作
4：发送读取温度命令
5：读取温度值
DS18B20接口电路图：
DS18B20的初始化 ： 主机首先发出一个480－960微秒的低电平脉冲，然后释放总线变为高电平，并在随后的480微秒时间内对总线进行检测，如果有低电平出现说明总线上有器件已做出应答。若无低电平出现一直都是高电平说明总线上无器件应答。
做为从器件的DS18B20在一上电后就一直在检测总线上是否有480－960微秒的低电平出现，如果有，在总线转为高电平后等待15－60微秒后将总线电平拉低60－240微秒做出响应存在脉冲，告诉主机本器件已做好准备。若没有检测到就一直在检测等待。
sbit DS = P2^2; void dsreset(void) {
uint i;
DS=0;
i=103;
while(i&gt;0)i--;
DS=1;
i=4;
while(i&gt;0)i--;
}
主机发出各种操作命令都是向DS18B20写0和写1组成的命令字节，接收数据时也是从DS18B20读取0或1的过程。因此首先要搞清主机是如何进行写0、写1、读0和读1的。
写周期最少为60微秒，最长不超过120微秒。
写周期一开始做为主机先把总线拉低1微秒表示写周期开始。随后若主机想写0，则将总线置为低电平，若主机想写1，则将总线置为高电平，持续时间最少60微秒直至写周期结束，然后释放总线为高电平至少1微秒给总线恢复 。而DS18B20则在检测到总线被拉底后等待15微秒然后从15us到45us开始对总线采样，在采样期内总线为高电平则为1，若采样期内总线为低电平则为0。
void tmpwritebyte(uchar dat) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/425db6f024e9045980f7caf92df07f26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78f454c9dd64b5c70a40e6e5de5949ba/" rel="bookmark">
			java每日一练(2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java每日一练(2) 单选部分 1.A 派生出子类 B ， B 派生出子类 C ，并且在 java 源代码有如下声明：
A a0=new A();A a1=new B();A a2=new C(); 问以下哪个说法是正确的（）
A 只有第一行能通过编译 B 第1、2行能通过编译，但第3行编译出错
C 第1、2、3行能通过编译，但第2、3行运行时出错 D 第1行，第2行和第3行的声明都是正确的
复习文章 ： 继承 Inheritance_
答案 ： D
C 的父类 是 B ， B的父类是 A ，所以 A 的父类一定是C的父类 , 根据父类引用引用子类对象 推出 3行代码是可以执行的
2.下面代码将输出什么内容：（）
这里就考到了我们的 toLowerCaSe 方法最后会创建一个新的对象， == 比较的是否为同一个对象， 所以这里就会返回一个 false
复习文章 ： String类 — 上篇_
3.阅读如下代码。 请问，对语句行 test.hello(). 描述正确的有（）
A 能编译通过，并正确运行
B 因为使用了未初始化的变量，所以不能编译通过
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78f454c9dd64b5c70a40e6e5de5949ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9ac53ebb01ac8039210981693fa2e2a/" rel="bookmark">
			【小专题】正交试验法设计测试用例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正交试验法设计测试用例 正交试验法设计工具：
1、正交设计助手
2、AllPairs
3、python（本质是使用AllPairs）
先看一个案例：
假设一个web系统，需要做兼容性测试，该系统兼容不同操作系统、数据库和web服务器软件，并且客户端有许多的浏览器： &gt;浏览器：Firefox、IE、Google Chrome &gt;数据库：MySQL、Oracle、DB2 &gt;应用服务器：nginx、Apche、Tomcat &gt;操作系统：Windows Server、Unix、Linux 分析
4因素3水平实验：全面实验需要81条用例，而正交实验只需要9条用例
全面实验：
3 4 = 81 3^{4}=81 34=81
正交实验：
L 9 ( 3 4 ) L_{9}(3^{4}) L9​(34)
工具一&gt;正交设计助手 工具二—&gt;Allpairs 1、根据需求在Excel中确定因素及每个因素的取值（水平）
2、新建txt文档，将取值表数据直接复制粘贴到txt中，并保存
3、将步骤2的文件放到Allpairs安装的文件路径下
4、打开cmd命令行工具，进入Allpairs解压后所在的路径，
输入allpairs.exe test.txt&gt;test2.txt，然后回车
6、打开Allpairs文件路径，就可以看到新生成的正交表文件test2.txt了
就是不知道为什么Allpairs生成的用例多了一条，可能是我下载的版本问题
如果因素和水平符合标准的正交表，建议使用正交设计助手，如果水平没有那么规范，建议使用Allpairs
工具三—&gt;python 1、导allpairspy包实现AllPairs功能
from allpairspy import AllPairs parameters = [ ["Firefox", "IE","Google Chrome"], ["MySQL", "Oracle", "DB2"], ["nginx", "Apche", "Tomcat"], ["Windows Server", "Unix", "Linux"] ] print("测试用例:") for i, pairs in enumerate(AllPairs(parameters)): print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9ac53ebb01ac8039210981693fa2e2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ba46b93676735338f5d1d0e98b49316/" rel="bookmark">
			单片机矩阵键盘扫描
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本讲任务：
了解矩阵键盘检测原理及如何获得键盘扫描值。
逐行扫描：
我们可以通过高四位轮流输出低电平来对矩阵键盘进行逐行扫描，当低四位接收到的数据不全为1的时候，说明有按键按下，然后通过接收到的数据是哪一位为0来判断是哪一个按键被按下。
例程：
/*************************矩阵键盘扫描************************** *单片机型号：STC89C52RC
*开发环境：KEIL
*功能：当按下一个按键后，在数码管进行数值的显示 ******************************************************************/
#include&lt;reg51.h&gt;
sbit BEEP=P2^3;
sbit LE1=P2^6;
sbit LE2=P2^7;
void delay(int In,int Out);
unsigned char buffer,key_num;
unsigned char code table[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71};
void delay(int In,int Out) //定义延时函数 {
int i,j;
for(i=0;i&lt;In;i++)
{for(j=0;j&lt;Out;j++){;}}
}
void display(unsigned char num) //数码管显示
{
P0=table[num]; LE1=1;LE1=0;
P0=0x00; LE2=1;LE2=0;
}
void main()
{
LE1=0;LE2=0;
while(1)
{
/**************************************************************/
P3=0xfe; //扫描S3,S4,S5,S6; buffer=P3; buffer=buffer&amp;0xf0; if(buffer!=0xf0)
{
delay(5,10);
if(buffer!=0xf0)
{
buffer=P3; switch(buffer)
{
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ba46b93676735338f5d1d0e98b49316/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ae1958924c9f93af36f9fd928768848/" rel="bookmark">
			Sql索引（primary key、unique、index）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、索引概述 主索引：primary key
唯一索引：unique
普通索引：index
创建索引： 1.建立数据表的同时建立索引 命令格式：
CREATE TABLE table_name ([col_name data_type]
[PRIMARY|UNIQUE][|INDEX|KEY] [index_name] (index_col_name [length])
[ASC | DESC]) table_name数据表的名称 primary主索引 unique唯一索引 index_name索引名
index_col_name索引列的名称
2.在已有数据表上建立索引
alter table 表名 add [UNIQUE | PRIMARY KEY | INDEX] [索引名] (列名 [排序方式]);
ALTER TABLE tbl_name ADD PRIMARY KEY (column_list): 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。ALTER TABLE tbl_name ADD UNIQUE index_name (column_list): 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。ALTER TABLE tbl_name ADD INDEX index_name (column_list): 添加普通索引，索引值可出现多次。 查看索引： show index from 表名 ；
删除索引： drop index 索引名 on 表名 ；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ae1958924c9f93af36f9fd928768848/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3743fb9c94bb51129d2e2828a597392d/" rel="bookmark">
			离线安装Docker镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		部分线上服务器无法连接公网，或者服务器下载镜像比较慢，遇到这种情况要怎么解决？
我们可以在联网的本机或服务器上，将已经下载好的镜像导出，然后导入到没有网络的服务器上，通过Docker加载。
例如，这里有一个镜像grafana/loki:2.2.1
使用docker save导出镜像
docker save 727c39682956 &gt; loki.tar 将导出的镜像loki.tar移动到服务器，使用docker load加载服务器
docker load &lt; loki.tar 使用docker images可以查看已经加载的镜像，但是镜像名称和tag都为&lt;none&gt;。
使用docker tag 修改镜像名称
docker tag 727c39682956 grafana/loki:2.2.1 使用docker images查看加载好的镜像即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/080e91ee7e009b5e82b86c0677ef9281/" rel="bookmark">
			vnc安装和开机自启设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装VNC 键入以下命令以在 Ubuntu 服务器上安装 TigerVNC ：
sudo apt install tigervnc-standalone-server tigervnc-common 现在安装了 VNC 服务器，下一步是运行 vncserver 命令，该命令将创建初始配置并设置密码。运行以下命令时不要使用 sudo ：
vncserver 在继续下一步之前，首先使用带有 -kill 选项和服务器编号作为参数的 vncserver 命令停止 VNC 实例。在我们的例子中，服务器在端口 5901 (:1)中运行，因此我们将使用以下命令停止它：
1.启动vnc服务：
vncserver -localhost no 2.查看vnc运行状态：
vncserver -list 3.关闭vncC显示器
vncserver -kill :1 4.查找 vnc
ps -ef | grep vnc ubuntu.desktop 5.查找端口
netstat -ano | grep 5901 二、设置开机自启 1、编写启动脚本 nano /usr/lib/python3/start_vncserver.sh 复制下面到脚本
#!/bin/bash echo "start vncserver...oooooooooooooo" nohup /usr/bin/vncserver -SecurityTypes=None -rfbport=5901 -localhost no --I-KNOW-THIS-IS-INSECURE &amp; #!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/080e91ee7e009b5e82b86c0677ef9281/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6923ac12de13f9096a13205fefaab30/" rel="bookmark">
			novnc安装和开机自启设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装和使用novnc 1. 下载noNVC
git clone https://github.com/novnc/noVNC.git 2.创建安装连接
VNC的默认会话不是安全的，需要创建一个安全的VNC连接。创建完毕的证书 self.pem 需要放置到 noVNC/utils 目录下，当启动 noVNC 时，websockify将自动装载证书。
cd noVNC openssl req -new -x509 -days 365 -nodes -out self.pem -keyout self.pem 一路回车下去
3.运行 noVNC,连接本机是5901的vnc服务
./utils/launch.sh --vnc localhost:5901 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-PjpP6A5s-1669098082802)(img/1667372027736.png)]
http://uduntu-master:6080/vnc.html?host=uduntu-master&amp;port=6080
4.打开链接,输入密码连接
http://192.168.122.218:6080/vnc.html
二、设置开机自启 1、编写启动脚本 nano /opt/software/noVNC/utils/start_novnc.sh 复制下面到脚本
#!/bin/bash nohup /opt/software/noVNC/utils/novnc_proxy --vnc localhost:5901 --listen 6080 &amp; 2、附加权限 chmod u+x /opt/software/noVNC/utils/start_novnc.sh 3、编写.service脚本 sudo nano /etc/systemd/system/novnc.service 4.1.复制下面到脚本
[Unit] Description= noVNC Service(noVNC) After=tigervnc.target [Service] # backend running Type=forking ExecStart=/opt/software/noVNC/utils/start_novnc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6923ac12de13f9096a13205fefaab30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71eab090c7f57cc13dfe94e4fb031d82/" rel="bookmark">
			简单网络管理协议SNMP（史上最全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单网络管理协议（SNMP）是TCP/IP协议簇的一个应用层协议。在1988年被制定，并被Internet体系结构委员会（IAB）采纳作为一个短期的网络管理解决方案；由于SNMP的简单性，在Internet时代得到了蓬勃的发展，1992年发布了SNMPv2版本，以增强SNMPv1的安全性和功能。现在，已经有了SNMPv3版本。 SNMP版本 SNMPv1
SNMPv1 是 SNMP 协议的最初版本，提供最小限度的网络管理功能。SNMPv1 的 SMI 和 MIB 都比较简单，且存在较多安全缺陷。SNMPv1 采用团体名认证。团体名的作用类似于密码，用来限制NMS对Agent 的访问。如果 SNMP 报文携带的团体名没有得到 NMS/Agent 的认可，该报文将被丢弃。SNMPV1 是一种简单的请求/响应协议。网络管理系统发出一个请求，管理器则返回一个响应。这一行为的实现是通过使用四种协议操作中的其中任一种完成的。这四种操作分别是 GET、GETNEXT、SET 和 TRAP。NMS 通过 GET 操作，从 SNMP 代理处得到一个或 更多的对象(实例)值。如果代理处不能提供请求列表中所有的对象(实例)值，它也就不提供任何值。 NMS 使用 GETNEXT 操作请求代理从请求列表或对象列表中取出下一 个对象实例值。NMS 通过 SET 操作向 SNMP 代理发送命令，要求对对象值重新配置。SNMP 代理通过 TRAP 操作不定时的通知 NMS 所发生的特定事件 SNMP 是一种应用程序协议。
SNMPv2
SNMPv2c 也采用团体名认证。在兼容 SNMPv1 的同时又扩充了 SNMPv1 的功能:它提 供了更多的操作类型(GetBulk--批量获取操作等)；支持更多的数据类型(Counter32等)，提供了更丰富的错误代码，能够更细致地区分错误。
SNMPV1 中的 GET、GETNEXT 及 SET 操作同样适用于 SNMPV2，只是 SNMPV2 添加和增强了有关协议操作。例如 SNMPV2 中的 TRAP 操作，不但具备 SNMPV1 中 TRAP 的相同功能，而且它采用了一种不同的消息格式，它用于替换 SNMPV1 中的 TRAP。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71eab090c7f57cc13dfe94e4fb031d82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce6a9a730d2d6874678d756d88a61e87/" rel="bookmark">
			spring框架源码十七、Bean对象创建子流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Bean对象创建子流程 Bean对象创建子流程new ClassPathXmlApplicationContextClassPathXmlApplicationContext#ClassPathXmlApplicationContext(java.lang.String)ClassPathXmlApplicationContext#ClassPathXmlApplicationContext(java.lang.String[], boolean, org.springframework.context.ApplicationContext)AbstractApplicationContext#refreshAbstractApplicationContext#finishBeanFactoryInitializationDefaultListableBeanFactory#preInstantiateSingletonsAbstractBeanFactory#getBean(java.lang.String)AbstractBeanFactory#doGetBean标记bean开始被创建，this.alreadyCreated.add(beanName)1、DefaultSingletonBeanRegistry#getSingleton(java.lang.String, org.springframework.beans.factory.ObjectFactory&lt;?&gt;)标记bean正在被创建，this.singletonsCurrentlyInCreation.add(beanName) 2、AbstractAutowireCapableBeanFactory#createBean(java.lang.String, org.springframework.beans.factory.support.RootBeanDefinition, java.lang.Object[]) AbstractAutowireCapableBeanFactory#doCreateBean Bean对象创建子流程 Bean对象创建的入口，
AbstractApplicationContext#finishBeanFactoryInitialization
new ClassPathXmlApplicationContext ClassPathXmlApplicationContext#ClassPathXmlApplicationContext(java.lang.String) ClassPathXmlApplicationContext#ClassPathXmlApplicationContext(java.lang.String[], boolean, org.springframework.context.ApplicationContext) AbstractApplicationContext#refresh AbstractApplicationContext#finishBeanFactoryInitialization Bean对象创建子流程的入口，
DefaultListableBeanFactory#preInstantiateSingletons 实例化所有立即加载的单例bean，
@Override public void preInstantiateSingletons() throws BeansException { if (logger.isTraceEnabled()) { logger.trace("Pre-instantiating singletons in " + this); } // 存放所有的beanName，即beanID // Iterate over a copy to allow for init methods which in turn register new bean definitions. // While this may not be part of the regular factory bootstrap, it does otherwise work fine.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce6a9a730d2d6874678d756d88a61e87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5a825a9ae93cd5fba25dff6d645374b/" rel="bookmark">
			希望计算机专业同学都知道这些老师
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言教程——翁凯老师、赫斌 翁恺老师是土生土长的浙大码农，从本科到博士都毕业于浙大计算机系，后来留校教书，一教就是20多年。
翁恺老师的c语言课程非常好，讲解特别有趣，很适合初学者学习。
郝斌老师的思路是以初学者的思路来思考的，非常适合小白，你不理解的问题，基本上他都会详细说一下。
C++——侯捷老师 看了候老师的课有种醍醐灌顶的感觉，强烈建议自学c++ 者仔细看候捷老师的课，会受益匪浅。
数据结构课程——陈越、王卓老师 青岛大学王卓老师的数据结构与算法基础，课程评价很高，通俗易懂，适合零基础入门。
陈越老师，被同学们尊称为“姥姥”，为各种同学答疑解惑，事无巨细，非常有热情和接地气，是个亲切的长辈一样的存在。
陈姥姥的课简单易懂，评价也非常高，认真学了肯定有很大的收获~
操作系统——李治军老师、向勇、陈渝 李治军老师的操作系统课程非常棒，讲解很清晰、详细，配图也相当丰富，对初学者很友好。
我看过不同老师讲的操作系统课程，觉得比较好的入门级课程是清华大学开设的网课《操作系统》，该课程由清华大学老师向勇和陈渝授课，虽然大彬上不了清华大学，但是至少可以在网上选择听清华大学的课嘛。
计算机网络——郑烇、杨坚老师 中科大郑烇、杨坚老师的计算机网络，老师讲课很幽默，思路很清晰，最重要的是，可以跟中科大学生一起完成专业知识的学习~
数据库——战德臣老师 哈尔滨工业大学战德臣老师的数据库系统原理，是国家精品课程，值得大家去学习。
机器学习——吴恩达、李沐 吴恩达老师，斯坦福计算机系的副教授，师从机器学习的大师级人物 Michael I. Jordan。吴老是，徒弟遍布美国名校，他们这一大学派的主要研究和贡献集中在统计机器学习（Statistical Machine Learning）和图模型(Probabilistic Graphical model)等。
更重要的是，他在学术圈内圈外知名度很高！除了师承之外，还有一个重要原因是他在斯坦福公开课里面主讲机器学习，讲的的确是非常好，在工程界非常受欢迎。
bilibili 2021新人奖UP主、亚马逊资深首席科学家，李沐老师的机器学习课程，可以说是机器学习入门课程的天花板，非常适合新手入门，没有很复杂的推导过程和数学知识，偏向于运用的角度。
python系列课程——嵩天 嵩天老师是国内大学Python教育的先行者， 是Python语言进入计算机等级考试的关键人物，为推广Python语言进入大学教育序列，作了很大贡献。嵩天老师的python系列视频深入浅出，值得零基础入学。
Java基础课程——韩顺平 韩顺平老师的Java课程主要面向初学者，讲课幽默风趣，通俗易懂，善于用已知的概念解释编程问题，对初学者非常友好，是自学Java很不错的选择！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88dc036fc2f4153e90fee733f22d7466/" rel="bookmark">
			数据结构——多项式的加减乘法以及合并同类项的算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试数据（这里只测试了一组数据，小伙伴们可以自行测试其他数据喔）
2 2 3 3 4 4 0 0
1 2 2 2 0 0
1 2 1 1 0 0 1 2 1 3 0 0
-1 2 -5 3 -4 2 0 0 2 3 -4 2 -3 6 0 0
2 2 4 4 3 3 6 6 5 5 0 0 8 7 4 5 6 1 1 3 3 5 0 0
1 2 3 4 5 6 7 8 0 0 2 2 4 4 6 6 8 8 0 0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88dc036fc2f4153e90fee733f22d7466/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e84ec487776e6774c3ecfd0daaeba4c8/" rel="bookmark">
			Linux开发工具VI/VIM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux开发工具VI/VIM 文章目录 Linux开发工具VI/VIM一、Linux 软件包管理器 yum语法安装和卸载sl（小火车跑动）软件包 二、编辑器VI/VIM1.基本介绍2.基础使用接下来介绍vim使用正常模式命令集末行模式命令集 三、VIM优化总结 一、Linux 软件包管理器 yum yum(Yellow dog Updater, Modified)是Linux下非常常用的一种包管理器. 主要应用在Fedora, RedHat, Centos等发行版上.yum 是一个软件包管理器，但是是基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖关系，并且一次性安装所有依赖的软件包。 语法 yum [选项] [参数] 选项参数-y对于命令之后的所有问题都yes 安装和卸载sl（小火车跑动）软件包 安装
命令： sudo yum install sl 这里说明一下，要么在root用户下安装，要么给当前用户增加权限（sudo命令）。
Sudo 的全称为：super user do。 顾名思义：干超级用户才能干的事！所以Sudo最常用的功能就是提升一个命名的执行权限。
当提示 Is this ok?的时候输入y并回车即可。
安装完毕之后就可以在命令行输入sl命令可以看见小火车跑过的画面。
2. 卸载
sudo yum remove sl 二、编辑器VI/VIM 1.基本介绍 vi/vim的区别简单点来说，它们都是多模式编辑器，不同的是vim是vi的升级版本，它不仅兼容vi的所有指令，而且还有一些新的特性在里面。例如语法加亮，可视化操作不仅可以在终端运行，也可以运行于x window、 mac os、windows。接下俩按照vim来进行讲解。
查看版本命令： vim --version 那么我这里版本是7开头的没有更新，如果有需要更新到8.0以及以上大家可以参考这篇文章
2.基础使用 vim下需要了解三种模式（分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode））
正常/普通/命令模式(Normal mode) 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e84ec487776e6774c3ecfd0daaeba4c8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/49/">«</a>
	<span class="pagination__item pagination__item--current">50/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/51/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>