<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f01c8efba5614c95d2781f2539205dc/" rel="bookmark">
			201512-2消除类游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 消除类游戏是深受大众欢迎的一种游戏，游戏在一个包含有n行m列的游戏棋盘上进行，棋盘的每一行每一列的方格上放着一个有颜色的棋子，当一行或一列上有连续三个或更多的相同颜色的棋子时，这些棋子都被消除。当有多处可以被消除时，这些地方的棋子将同时被消除。 现在给你一个n行m列的棋盘，棋盘中的每一个方格上有一个棋子，请给出经过一次消除后的棋盘。 请注意：一个棋子可能在某一行和某一列同时被消除。 输入格式 输入的第一行包含两个整数n, m，用空格分隔，分别表示棋盘的行数和列数。 接下来n行，每行m个整数，用空格分隔，分别表示每一个方格中的棋子的颜色。颜色使用1至9编号。 输出格式 输出n行，每行m个整数，相邻的整数之间使用一个空格分隔，表示经过一次消除后的棋盘。如果一个方格中的棋子被消除，则对应的方格输出0，否则输出棋子的颜色编号。 样例输入 4 5 2 2 3 1 2 3 4 5 1 4 2 3 2 1 3 2 2 2 4 4 样例输出 2 2 3 0 2 3 4 5 0 4 2 3 2 0 3 0 0 0 4 4 样例说明 棋盘中第4列的1和第4行的2可以被消除，其他的方格中的棋子均保留。 样例输入 4 5 2 2 3 1 2 3 1 1 1 1 2 3 2 1 3 2 2 3 3 3 样例输出 2 2 3 0 2 3 0 0 0 0 2 3 2 0 3 2 2 0 0 0 样例说明 棋盘中所有的1以及最后一行的3可以被同时消除，其他的方格中的棋子均保留。 评测用例规模与约定 所有的评测用例满足：1 ≤ n, m ≤ 30。 关键：复制棋盘
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f01c8efba5614c95d2781f2539205dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/330a191f6604a03b6e44380da650b2ba/" rel="bookmark">
			为什么springcloud值得我们学习？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springcloud好不好？好！ 它的微服务理念适合所有公司的业务吗？不一定！ 但是不使用它需要学习它吗？需要！ 虽然去年就听了朋友说了springcloud全家桶如何如何方便？但是一看到全家桶中Eureka,Hystrix,Zuul,Bus我还是比较头疼的，这么多子模块从哪里看起呢？但当我开始学习了解的时候我便停不下来了！！！
首先springcloud得益于spingboot的优雅简洁，可还记得我们被无数xml支配的恐惧？可还记得springmvc，mybatis错综复杂的配置，有了spingboot，这些东西一去不复返了！！！spingboot好处不再赘诉，毕竟主角还是
什么叫做开箱即用？什么叫做大道至简？即使是当年的黄金搭档dubbo+zookeeper下载配置起来也是颇费心神的！而springcloud完成这些只需要一个jar的依赖就可以了！ springcloud大多数子模块都是直击痛点，像zuul解决的跨域，fegin解决的负载均衡，hystrix的熔断机制，在业务复杂的时候通过zipkin去清晰的查看服务的依赖和调用……
当然，当我们的业务模块很少的时候，我们不需要去使用微服务，微服务意味着更多的rpc调用和更大的维护难度。只有当我们的业务模块多到一定程度的时候，每个模块都需要一个小团队去开发，这样微服务才能更好的解决问题，复杂所有的业务都耦合在一个项目里，不说一个服务的bug直接引起整个项目的崩溃，就一个代码的冲突合并都能让开发人员抓狂！ 而微服务在大型项目中就体现了它的优势：
开发简单，开发效率高，一个服务可能就是专一的干一件事它易于被开发人员理解，使得小团队更加专注自己的模块 而最关键的一个点，我们为什么要学习springcloud来作为我们的微服务框架呢？
首先如果你只熟悉Java语言，那么你学起来就会非常轻松，它并不需要mybatis、springmvc甚至struts那么多的配置文件，你只需要花时间去思考原理，写一些代码就能很快入门，我发誓它比前面的框架入门要简单，说实话我一直觉得k8s是一个很好的东西，但是k8s的学习曲线就很困难！！！springcloud的学习会让你对高并发、分布式、服务的降级、熔断及雪崩相关概念理解的更加清晰springcloud是一套完整的微服务框架，正是因为它是全家桶，看起来繁杂，实际上使用风格很相似，而且拿dubbo来举例，dubbo不具有服务网关、分布式配置、服务跟踪等等功能，而springcloud都具备 我觉得springcloud带来了很多新的东西，让我更有兴趣一步一步的去探索它，希望越来越好！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14d55c8dd6c144db2285901c44d8fb75/" rel="bookmark">
			图像形态学转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用的形态学操作包括：腐蚀、膨胀、开运算、闭运算。其中，开运算是先腐蚀在膨胀，用来消除背景中的噪点；闭运算是先膨胀再腐蚀，用来消除目标中的噪点。在图像处理中我们经常需要这些操作，比如二值处理后，我们的目标区域往往不仅包含噪点，本身也可能相互之间没有连通，这时候适当的形态学处理可以修复目标或者消除噪点，那么腐蚀还是膨胀，两个都用先后顺序如何？都需要进行对比分析。
相关函数为:
{腐蚀，膨胀}：cv2.erode(),cv2.dilate(),传递的参数为:img,kernel,iterations分别代表源图像，卷积核，以及相应处理的次数
形态学往往是针对二值图处理，往往视白色为目标，黑色为背景。
腐蚀，会使得白色区域缩小，处理过程：将卷积核依次沿着图像移动，判断卷积核对应的原图，若该范围内所有像素值为1，则中心元素保持原来的像素值，否则变为0。在处理中，往往用在1)去掉背景（黑色）中的噪点（小白点），2)可以使原本连通在一起的白色区域相互隔开，视效果选择最佳的迭代次数。
腐蚀效果：分别选择不同的kernel，相同迭代次数以及不同迭代次数和相同kernel。
通常kernel选择为(3*3)或者(5*5)，iterations选择1-2次，膨胀类似处理，其计算过程不同在于将图像卷积核对应区域中只要有一个为1，则中心元素像素值为1，会使得白色区域扩张。
开、闭运算：cv2.morphologyEx()，开运算参数为img,cv2.MORPH_OPEN,kernel,相应的闭运算在第二个参数为cv2.MORPH_CLOSE;而形态学梯度则是将该参数改为cv2.MORPH_GRADIENT,其处理过程为膨胀图像-腐蚀图像，能够极好的显示目标区域的轮廓。
附上部分代码：
import numpy as np import cv2 from matplotlib import pyplot as plt #导入matlab绘图模块 import pylab#导入该模块为了调整matlab绘图大小 pylab.rcParams['figure.figsize']=(16,10) img=cv2.imread('building.jpg')#读取需要处理的图像 img2gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)#将其转换为灰度图，为进一步二值化 ret,imgOtsu=cv2.threshold(img2gray,0,255,cv2.THRESH_BINARY+cv2.THRESH_OTSU)#采用OTSU自适应阈值，关于OTSU算法网络资源较多 #腐蚀次数 iteration_time=[2,5] #kernel大小 kernels=[] for i in range(1,10,4): kernels.append(np.ones((i,i),np.uint8)) #相同次数，不同的kernel值 for i,kernel in enumerate(kernels): #腐蚀 # erosion=cv2.erode(imgOtsu,kernel,iterations=2)#腐蚀，kernel大则会损失掉更多前景 # print(kernel) #膨胀 dilationpic=cv2.dilate(imgOtsu,kernel,iterations=2) #subplot()中参数依次为（列，行，当前图像的索引值),索引值从1开始 plt.subplot(2,3,i+2),plt.imshow(dilationpic,'gray'),plt.title('kernel is %d *%d'%(4*i+1,4*i+1)) #相同kernel,不同迭代次数 image_index=5 kernel_3=np.ones((3,3),np.uint8)#选择3*3的卷积核，5*5会损失目标 for times in iteration_time: # erosion=cv2.erode(imgOtsu,kernel_3,iterations=times) dilationpic=cv2.dilate(imgOtsu,kernel_3,iterations=times) plt.subplot(2,3,image_index),plt.imshow(dilationpic,'gray'),plt.title('iteration time is %d'%(times)) image_index+=1 #进行画图，将我们需要的图像逐个通过matlab模块来绘制，往往画多个图会比较好，画单个cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14d55c8dd6c144db2285901c44d8fb75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7981fa3ba8445418fc835df25e710921/" rel="bookmark">
			harvasst of apples（组合数）（乘法逆元）（莫队算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Problem B. Harvest of Apples Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 262144/262144 K (Java/Others)
Total Submission(s): 1529 Accepted Submission(s): 171
Problem Description
There are n apples on a tree, numbered from 1 to n.
Count the number of ways to pick at most m apples.
Input
The first line of the input contains an integer T (1≤T≤105) denoting the number of test cases.
Each test case consists of one line with two integers n,m (1≤m≤n≤105).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7981fa3ba8445418fc835df25e710921/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e92f3fba3cd5d0e1bfde3856d8664ce/" rel="bookmark">
			两个有序链表序列的合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		已知两个非降序链表序列S1与S2，设计函数构造出S1与S2合并后的新的非降序链表S3。
输入格式: 输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用−1表示序列的结尾（−1不属于这个序列）。数字用空格间隔。
输出格式: 在一行中输出合并后新的非降序链表，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出NULL。
输入样例: 1 3 5 -1 2 4 6 8 10 -1 输出样例: 1 2 3 4 5 6 8 10 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef struct node* node; struct node{ int data; struct node* next; }; node initlist() { node head=(node)malloc(sizeof(struct node)); head-&gt;next=NULL; return head; } void creat(node *L){ node s,r=L; int num,flag=1; while(flag) { scanf("%d",&amp;num); if(num&gt;=0) { s=(node)malloc(sizeof(struct node)); s-&gt;data=num; r-&gt;next=s; r=r-&gt;next; } else{ flag=0; r-&gt;next=0; } } } void print(node L) { node t=L-&gt;next; int flag=1;int num=0; while(t!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e92f3fba3cd5d0e1bfde3856d8664ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21d344ba7ed54c84a8508ab92f2bd7f4/" rel="bookmark">
			C&#43;&#43;细节  输出运算符的重载为什么不写成类的成员函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打印类中的一些变量，此时就需要使用函数或者重载，为了提高代码可读性，一般使用操作符重载来书写，而cout并不在c++的默认类成员函数中，需要我们自己书写。第一种写在类中如下面的代码（我们以日期类举例，较《c++primer》中的书店类更加容易讲解做笔记）
对输出运算符的重载
void operator&lt;&lt;(ostream&amp; out) { out &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl; } 会出现一个问题，只能写成
d&lt;&lt;cout //打印d中的年月日
因为函数的第一个参数是this指针，第二个参数才是我们传进去的 out，但是这与std中的cout使用习惯完全不符，我们的所打印变量是应该在cout的右边，如 cout&lt;&lt;d&lt;&lt;endl.
这样的重载和普通的函数没有两样，也就失去了重载函数的目的所在。
那么这样，我们便不可以把输出运算符的重载写成成员函数，写成成员函数去实现功能，能实现功能 但失去重载本身的意义。
那么我们将输出运算符的重载
那么我们在类外写重载函数，此时输出运算符的重载函数是一个全局的。
void operator&lt;&lt;(ostream&amp; out,const Date&amp; d) { out &lt;&lt; d._year &lt;&lt; "-" &lt;&lt; d._month &lt;&lt; "-" &lt;&lt; d._day &lt;&lt; endl; } 然后在对应的类中使用友元
class Date { friend void operator&lt;&lt;(ostream&amp; out, const Date&amp; d); public: Date(int year = 1998, int month = 1, int day = 1) /*	:_year(year) , _month(month)//初始化列表， , _day(day) */ { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21d344ba7ed54c84a8508ab92f2bd7f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db4ebf4804bd29cdec40b238763454ab/" rel="bookmark">
			python3 TypeError: &#39;map&#39; object is not subscriptable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下面语句报错python3 TypeError: 'map' object is not subscriptable
map(apply_filters_to_token, sentences) 2、修改，add “list” to map
return list(map(apply_filters_to_token, sentences)) 3、实例分析 # # 手写读取数据 # f = file(path) # x = [] # y = [] # for i, d in enumerate(f): # if i == 0: #跳过第0行的标题 # continue # d = d.strip() #去掉换行，回车等 # if not d: #如果d是空的，没有数据 # continue # d = list(map(float, d.split(','))) #d有数据，用，分隔后转为float # x.append(d[1:-1]) #取第一到倒数第一个之前的数 # y.append(d[-1]) #取倒数第一个数 # print(x) # print(y) # x = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db4ebf4804bd29cdec40b238763454ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c765a4f23bf30c5dcc1d057e329c4c14/" rel="bookmark">
			openjudge/ 1.4编程基础之逻辑表达式与条件分支 1-5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01:判断数正负 #include&lt;iostream&gt; using namespace std; int main(){ int n; scanf("%d",&amp;n); if(n&gt;0) cout&lt;&lt;"positive"&lt;&lt;endl; else if(n==0) cout&lt;&lt;"zero"&lt;&lt;endl; else cout&lt;&lt;"negative"&lt;&lt;endl; } 02:输出绝对值 #include&lt;iostream&gt; #include&lt;cmath&gt; using namespace std; int main(){ double n; cin&gt;&gt;n; if(n&gt;=0) printf("%.2lf\n",n); else printf("%.2lf\n",abs(n)); return 0; } 03:奇偶数判断 #include&lt;iostream&gt; using namespace std; int main(){ int n; cin&gt;&gt;n; if(n%2==1) cout&lt;&lt;"odd"; else cout&lt;&lt;"even"; return 0; } 04:奇偶ASCII值判断 #include &lt;iostream&gt; using namespace std; int main(){ char ch; ch = getchar(); if (ch%2 == 0) cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c765a4f23bf30c5dcc1d057e329c4c14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07f817e95944a2f293e0ac35817d30ba/" rel="bookmark">
			数据库SQL调优的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目中,SQL的调优对项目的性能来讲至关重要,所有掌握常见的SQL调优方式是必不可少的,下面介绍几种常见的SQL的调优方式,供借鉴.
一.创建索引 1.要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引 2.(1)在经常需要进行检索的字段上创建索引，比如要按照表字段username进行检索，那么就应该在姓名字段上创建索引，如果经常要按照员工部门和员工岗位级别进行检索，那么就应该在员工部门和员工岗位级别这两个字段上创建索引。 (2)创建索引给检索带来的性能提升往往是巨大的，因此在发现检索速度过慢的时候应该首先想到的就是创建索引。 (3)一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。
二.避免在索引上使用计算 在where字句中，如果索引列是计算或者函数的一部分，DBMS的优化器将不会使用索引而使用全表查询,函数 属于计算的一种,同时在in和exists中通常情况下使用EXISTS，因为in不走索引 效率低：
select * from user where salary*22&gt;11000(salary是索引列) 效率高：
select * from user where salary&gt;11000/22(salary是索引列) 三.使用预编译查询 程序中通常是根据用户的输入来动态执行SQL，这时应该尽量使用参数化SQL,这样不仅可以避免SQL注入漏洞 攻击，最重要数据库会对这些参数化SQL进行预编译，这样第一次执行的时候DBMS会为这个SQL语句进行查询优化 并且执行预编译，这样以后再执行这个SQL的时候就直接使用预编译的结果，这样可以大大提高执行的速度。
四.调整Where字句中的连接顺序 DBMS一般采用自下而上的顺序解析where字句，根据这个原理表连接最好写在其他where条件之前，那些可以 过滤掉最大数量记录。
五.尽量将多条SQL语句压缩到一句SQL中 每次执行SQL的时候都要建立网络连接、进行权限校验、进行SQL语句的查询优化、发送执行结果，这个过程 是非常耗时的，因此应该尽量避免过多的执行SQL语句，能够压缩到一句SQL执行的语句就不要用多条来执行。
六.用where字句替换HAVING字句 避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前 刷选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数 的过滤，除此之外，应该将条件写在where字句中。
七.使用表的别名 当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减 少哪些友列名歧义引起的语法错误。
八.用union all替换union 当SQL语句需要union两个查询结果集合时，即使检索结果中不会有重复的记录，如果使用union这两个结果集 同样会尝试进行合并，然后在输出最终结果前进行排序，因此如果可以判断检索结果中不会有重复的记录时候，应 该用union all，这样效率就会因此得到提高。
九.考虑使用“临时表”暂存中间结果 简化SQL语句的重要方法就是采用临时表暂存中间结果，但是，临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在tempdb中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。 但是也得避免频繁创建和删除临时表，以减少系统表资源的消耗。
十.只在必要的情况下才使用事务begin translation SQL Server中一句SQL语句默认就是一个事务，在该语句执行完成后也是默认commit的。其实，这就是begin tran的一个最小化的形式，好比在每句语句开头隐含了一个begin tran，结束时隐含了一个commit。 有些情况下，我们需要显式声明begin tran，比如做“插、删、改”操作需要同时修改几个表，要求要么几个表都修改成功，要么都不成功。begin tran 可以起到这样的作用，它可以把若干SQL语句套在一起执行，最后再一起commit。 好处是保证了数据的一致性，但任何事情都不是完美无缺的。Begin tran付出的代价是在提交之前，所有SQL语句锁住的资源都不能释放，直到commit掉。 可见，如果Begin tran套住的SQL语句太多，那数据库的性能就糟糕了。在该大事务提交之前，必然会阻塞别的语句，造成block很多。 Begin tran使用的原则是，在保证数据一致性的前提下，begin tran 套住的SQL语句越少越好！有些情况下可以采用触发器同步数据，不一定要用begin tran。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07f817e95944a2f293e0ac35817d30ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21efdb403767923b49becf02d85f5313/" rel="bookmark">
			C&#43;&#43;数组或vector求最大值最小值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以用max_element（）及min_element（）函数，二者返回的都是迭代器或指针。
头文件：#include&lt;algorithm&gt;
1.求数组的最大值或最小值
1）vector容器
例 vector&lt;int&gt; vec
最大值：int maxValue = *max_element(v.begin(),v.end()); 最小值：int minValue = *min_element(v.begin(),v.end());
2）普通数组
例 a[]={1,2,3,4,5,6};
最大值：int maxValue = *max_element(a,a+6); 最小值：int minValue = *min_element(a,a+6);
2.求数组最大值最小值对应的下标
1）vector容器
例 vector&lt;int&gt; vec
最大值下标：int maxPosition = max_element(v.begin(),v.end()) - v.begin(); 最小值下标：int minPosition = min_element(v.begin(),v.end()) - v.begin();
2）普通数组
例 a[]={1,2,3,4,5,6};
最大值下标：int maxPosition = max_element(a,a+6) - a; 最小值下标：int minPosition = min_element(a,a+6) - a;
注意：返回的是第一个最大（小）元素的位置。
参考：
C++笔记——std::min_element和std::max_element
C++中Vector求最大值最小值
C++ 数组或vector最大值最小值
转载于:https://www.cnblogs.com/Tang-tangt/p/9352093.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/942e2ff2b50593373da4b073e44c5908/" rel="bookmark">
			C#ADO.NET模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ADO.NET是一组向.NET程序员公开数据访问服务的类。
ADO.NET为创建分布式共享应用程序提供了一组丰富的组件。
ADO.NET提供了一系列的方法，用于支持对Microsoft SQL Server 和XML等数据源进行访问，还提供了通过OLE DB 和XML公开的数据源提供一致访问的方法。
数据客户端应用程序可以使用ADO.NET来连接到这些数据源，并查询、添加、删除和更新所包含的数据。
ADO.NET支持两种访问数据的模型：无连接模型和连接模型。
无连接模型：将数据下载到客户机上，并在客户机上将数据封装到内存中，然后可以像访问本地关系数据库一样访问内存中的数据（例如DataSet）。
连接模型：依赖于逐记录的访问，这种访问要求打开并保持与数据源的连接。
ADO.NET对象模型：
1.数据库：
存储了大量数据。
想象为水源
2.Connection对象：
保持与数据库的连接，只有它与数据库进行了连接，其他对象才可以获取数据。
是一个连接对象，主要功能是建立与物理数据库的连接。
像进水龙头
代码示例：
using System.Data.SqlClient;
string connectionString = "server= ; database = ; uid = ;pwd= ;";//用于连接数据库所需的必要信息
SqlConnection conn = new SqlConnection(connectionString);//创建一个SqlConnection对象
conn.open(); //打开连接
if(conn.State == ConnectionState.Open){...;} //判断当前连接的状态
3.Command对象
为获取数据提供动力和执行方法。
像抽水机
4.DataAdapter、DataReader:
担任着传输的任务，并起着桥梁的作用。
像输水管
5.DataSet对象：
项目中用来存放数据，把从数据库获得的数据按一定关系的DataTable 进行存放。
即使断开连接，离线状态，也可以保持数据的存在。这也正是ADO.NET的核心。
像大水库
6.DataTable对象：
独立的存储对象，分别存储不同类型的数据。
像大水库中一个个的水池子
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8307d3c9ca2445ed31b07d6dc8bbce89/" rel="bookmark">
			咆哮  垃圾codeforces！！1004  A. Sonya and Hotels / B. Sonya and Exhibition
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A 就是能不能在中间建旅馆的问题，我自己随便选了一场做，……
垃圾codeforces！！！！数据范围给了1e9 ，按照codeforces的习惯肯定会在边界处捣鬼，然后！！！！！！！！
就算你在1e9和-1e9处有宾馆，也可以建三个！！！！！！！
因为超出了数据给的范围，但是还是可以建！！！！！！
又没让你给出具体位置！！！！！！！！！！
这个题只要中间常规处理最后多+2就好了！！！！！！！
神tm坑！！！！！！！！！！！
B
又有点无语
感觉猛地一看不能做啊！！！！！！！
一看通过量5k啊！！！！！
啊我不能输给他们啊！！！！！！
看题目的意思要满足最大的，二进制有10位就完了啊！！！！！
1000拿头做啊！！！！！！！！
随便写了一下本来想贪心满足最大的！！！！！！
忽然发现只要相间进行此题就完了啊！！！！！！
真tm希望以后所有看起来束手无策 的题都能够这样啊！！！！！
暑假还要牛客网的题！！！1
脚指头想想都会很难啊！！！！！！！！！！
每题光签到吧然后就在乱七八糟的机房里发呆了！！！！！！
200块大洋啊！！！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4d48f89283bd567083a9ddba496109f/" rel="bookmark">
			面试应答
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 什么是面试？ 面试在我看来便是如何在有限的时间中让对方更好的了解你、认识你、认可你。于此你便成功了。那么，针对于我们IT技术面试而言应该如何做呢？ 一、技术准备（那些技术呢？） 数据结构和算法：数据结构很多人都可能对此不是很熟悉。那么，你为什么没有去查一下呢？！数据结构是一种概念，其中集合和堆栈等都是其具体的一种体现。所以也就要求我们对于这两个技术点要好好看一下； 算法：二叉、冒泡、递归、快速排序等常用算法至少要保证会手写吧！ 设计模式：单例（懒汉、恶汉手写）、代理、工厂等这几种设计模式是我在工作中基础常用的。那么，这块大家是否知道其原理和在何处使用呢？ 协议：HTTP、socket等协议单这些协议基本都是基于TCP、UDP协议的这两种协议就需要我们好好看一下了； 数据库：一直以来数据库便是面试和工作中的重点，涉及到SQL语句的优化、存储过程、索引等都是比较常问的； 框架：spring（AOP、IOC）、hibernate（缓存和优化）以及目前逐渐开始普及的微服务框架springboot、springcloud等是面试官的一个主要侧重点； 线程：重点常问，创建线程的方式、锁机制、线程优化和多线程并发处理使用场景等； 基础：web常用标签、九大内置对象、拦截器和过滤器、四大作用域、int和integer之间的区别、==和equals的区别、stringbuffer和stringbuilder的区别、JDK1.8的新特性、JVM优化和GC机制等； 常用技术点：fastdfs、POI、shiro、redis（几种数据类型、应用场景、问题解决）、dubbo、zookeeper、Nginx等。 以上基本是面试过程中经常出现的，当然每场面试面试官和公司不同各有侧重。有备无患，希望大家多多准备。 即便，这样准备了；即便，我们都知道基本也就这些知识点。可是面试效率还是比较低，为什么呢？对于知识点的理解不足（换一种问法就蒙圈了）、临场能力弱（先将自己比较熟练的点表达清楚，一个技术在项目中的应用可能只是其中的某一部分方法）、考虑不周（一面试可能由于紧张慌乱了知识点表达不清楚，作为一个优秀的程序员怎能没有一颗逻辑脑呢）、胡诌、技术点和项目业务点结合不当等。 当遇到这些、这样的种种问题的时候你是否对于自己的这场面试进行了反思和总结呢？面试的过程本就是成长的过程但是很多人都在这一阶段慢慢的被消磨、打击了。所以，当你不清楚、不明白的时候找一个你所信任的人和其沟通（当然我希望你多去沟通因为你会发现每个人都会有此不同的见解学会分析问题）；面试的过程对于大多数人来说是一个枯燥和压力较大的一个过程所以我希望你能够学会给自己减压（健身房、压马路、逛超市、听一首音乐、整理内务、做一次自己喜欢的饭等都是不错的选择）。 说了这么多，那面试呢？ 面试我们本就是和面试官处于平等的位置不必紧张、不必慌张。当紧张的时候不妨告诉自己：“小子，你很紧张啊！好丢脸啊！”自嘲一下毕竟我也要学会自娱自乐嘛！（女生除外哦！） 自我介绍 要素：技能、工作经验等。 例：面试官您好！我是李阳。现在已经从事Java领域3年了期间所从事的项目类型还是比较丰富的诸如简历上所见有仓储、ERP和互联网等项目，目前主要在互联网领域主要涉及的技术有redis、dubbo、MQ等常用技术。现在所常用的springboot也是不错的。目前还在职，之前对贵公司有过简单了解（将了解的情况说简单说一下）您所发布的岗位信息我认真匹配过与我的情况和发展规划是比较吻合的，所以很感谢您的这次面试机会。（其内容结合自己实际情况来表达） 停顿几秒后没有回复，你就可以开始介绍你的项目和技术了！ 当然这是一种情况有的可能上来就问你项目和技术了！ 无论是介绍项目还是业务，都要记住一点业务的实现时依赖于技术的，而技术是应用在业务上的。两者相辅相成。 比如：商品管理这块对于商品信息的存储主要使用了redis，数据类型更多一点并且方便持久化。在进行商品查询的时候我主要调用了list方法，可以进行索引效率更高一点。 也有很多人问，自己的期望薪资是XXK应该准备到什么程度呢？“取之法上，得之法中；取之法中，得之法下；取之法下，一无所得。”尽可能的去丰富整理、整理好自己的面试话术并不断的对其丰富，有备无患嘛！ 知识点准备几个自己能够熟练表达出来的：知其然而知其所以然。 最后，很多时候面试官免不了要问，“您这块还有什么想要了解的吗”关于这个问题，作为技术岗，建议侧重于技术。例如：你好，您这块方便介绍一下咱们的项目组成吗？；您好，咱们项目目前处于什么开发阶段呢？等。给自己提前准备两个。 不错的两句话，送给大家！ 如今你的气质里，藏着你走过的路，读过的书和爱过的人。 其实所有纠结做选择的人心里早就有了答案，咨询只是想得到内心所倾向的选择。最终的所谓命运，还是自己一步步走出来的。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7605dbec5a0388588a926b71381f5941/" rel="bookmark">
			shell脚本之工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习了shell脚本的基本语法，命令，符号之后，接下来要看的就是shell脚本使用的所有工具了。
在shell脚本中，工具的使用简化了所要编写的代码。接下来就介绍几个shell下经常使用的工具。
1、sort
sort工具的常用语法就是将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，默认是升序。
sort工具常用的一些选项：
-r选项：将文件按降序排列；-u选项：它的作用很简单，就是在输出行中去除重复行；-n选项：以数值来排序；
-t选项：可以设定间隔符；-k选项：指定了间隔符之后，就可以用-k来指定列数进行排序；-f选项：会将小写字母都转换为大写字母来进行比较，亦即忽略大小写；-c选项：会检查文件是否已排好序，如果乱序，则输出第一个乱序的行的相关信息，最后返回1-C选项：会检查文件是否已排好序，如果乱序，不输出内容，仅返回1-b选项：会忽略每一行前面的所有空白部分，从第一个可见字符开始
2、uniq
uniq工具作用效果是为消除相邻的重复行，如果重复行不再相邻的位置，就不会消除，因此，uniq工具一般与sort工具联合使用。
uniq工具常用的一些选项：
-c选项: 显示输出中，在每行行首加上本行在文件中出现的次数。它可取代-u和-d选项。-d选项: 只显示重复行-u选项: 只显示文件中不重复的各行。 uniq工具的应用：求两个文件的交集、并集、补集。
3、paste
paste单词的字面意思是粘贴。该命令主要用来将多个文件的内容合并。paste工具按行将不同文件行信息放在一行。缺省情况下， paste连接时，用空格或tab键分隔新行中不同文本。
通常我们把一行称为一条文本记录，每一行有多少列由列分隔符决定；按照列分隔符可以将一行分为多个域；进行行列划分时，应该考虑两个因素：行分隔符和列分隔符；行分隔符一般有\n,列分隔符为空格，tab
paste工具的常用选项：
-d选项: 指定域分隔符; -s选项: 将每个文件合并成行而不是按行粘贴 - 确实是该命令的一个选项。对每一个（-），从标准输入中读一次数据。默认使用空格或者tab作域分隔符，该选项可以定制输出格式。 4、cut
cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。 如果不指定 File 参数，
cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。
-b选项 ：以字节为单位进行分割-c 选项：以字符为单位进行分割。 对于英文字符-c和-b差别不大，但对于汉字类的字符差别就出来了
。
用-c则会以字符为单位，输出正常；而-b只会以字节（8位二进制位）来计算，输出就是乱码。这里的字符，不是我们C当中的占有一个字节的字符！可以简单理解成，汉字是由多个字节组成的多字节字符！ -d 选项：自定义分隔符，默认为制表符。-f 选项：与-d一起使用，指定显示哪个区域。 5、xargs（***）
xargs命令是给其他命令传递参数的一个过滤器，也是组合多个命令的一个工具。它擅长将标准输入数据转换成命令行参数，xargs能够处理管道或者stdin并将其转换成特定命令的命令参数。xargs也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。xargs的默认命令是echo，空格是默认定界符。这意味着通过管道传递给xargs的输入将会包含换行和空白，不过通过xargs的处理，换行和空白将被空格取代。xargs是构建单行命令的重要组件之一。
xargs工具的使用：
默认是对文件进行格式化输出，将多行输入转成单行输出；-n选项:指定列数，并多行输出-d选项: 自定义一个域分隔符，将特定列打散，并指定格式输出 将格式化的字符串作为命令行参数传递给其他命令，组装完成批量任务。
xargs的一个选项-I，使用-I指定一个替换字符串{}，这个字符串在xargs扩展时会被替换掉，当-I与xargs结合使用，每一个参数命令都会被执行一次.
Ls / |xargs -I {} touch {}.log 创建ls下的所有文件并且以.log结尾
-print0 ：不再按照空格等字符作为文件名结束标志，而变成以NULL结尾。
-0：告诉xargs,给xargs传参的字符不以空格为结束标志
6、grep
grep工具的常用选项：
-V 显示不匹配的-r/R 递归方式搜索-q 安静模式匹配 -i 忽略大小写-n 显示匹配结果以及匹配结果的行号-o: 只输出文件中匹配到的部分 7、sed(*****)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7605dbec5a0388588a926b71381f5941/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd20486af90e47ae75e3852d8e1a7149/" rel="bookmark">
			java基础学习一java 基本规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、类为最小程序单位 java不允许执行语句、方法等单独存在，必须包含在类里面 二、类中没有main不会编译报错，但是程序运行时会提示错误，找不到程序入口，所以jvm规定，如果一个类能被解释执行，必须有main方法，必须用public static void 修饰main方法，并且main方法的形参必须是 字符串数组 String[] args,因此程序的入口是固定的 public static void main(String[] args),当然那些没有main方法的类也是有用的，一般情况下 程序只需要一个类有main,其它类可以被main直接或者间接的调用 三、java程序源文件的主文件的命名：如果定义了一个public类，那么主文件名必须与类名一致，并且只能包含一个public类，当然可以定义多个非public类。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49932a04c23452b43c1b8c27dac2822f/" rel="bookmark">
			关于SLAM十四讲中 非模板类Sophus库的安装问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近开始学习高翔博士的《视觉SLAM十四讲》，第四章要求安装一个非模板类的Sophus库。在安装书中提供的第三方库时出现错误。在安装过程中，使用Cmake ..的时候能够顺利通过，接着执行make命令的时候就会出现错误如下：
***1. Sophus/sophus/so2.cpp:33:26:error: lvalue required as left operand of assignment unit_complex_.real() = 1.; 2. Sophus/sophus/so2.cpp:33:26:error: lvalue required as left operand of assignment unit_complex_.imag() = 1.;* 我以为是书中提供的第三方库存在问题，于是按照书中的方法在网上重新下载Sophus库，编译之后仍旧出现这种错误。 自己在网上查找了好久很少有人提出解决这个问题的方法。最终幸运的在一篇博客中找到了解决的方法。鉴于网上的解决方法少，故分享如下。 解决方法如下：
1 SO2::SO2() 2 { 3 //unit_complex_.real() = 1.; 4 //unit_complex_.imag() = 0.; 5 unit_complex_.real(1.); 6 unit_complex_.imag(0.); 7 } 打开so2..cpp文件，将系统提示出错的位置代码改成上述的代码即可。 用改正后的非模板类Sophus库运行《视觉SLAM十四讲》第四章的实践代码，代码输出的结果是正确的，运行代码结果如下：
SO3 from matrix : 0 0 1.5708 SO3 from vector : 0 0 1.5708 SO3 from quaternion : 0 0 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49932a04c23452b43c1b8c27dac2822f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbdec2e67b848c307eaa9219c5b3b095/" rel="bookmark">
			A. Sonya and Hotels
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 A. Sonya and Hotels#include &lt;bits/stdc++.h&gt; using namespace std ; int n ; int d,a[110] ; int main(){ scanf("%d%d",&amp;n,&amp;d) ; for (int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]) ; int ans=2; for (int i=2;i&lt;=n;i++){ if (a[i]-a[i-1]&gt;=2*d+1) ans+=2 ; if (a[i]-a[i-1]==2*d) ans++ ; } printf("%d\n",ans) ; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffa9761cc3ca0fcba832700f83ccd281/" rel="bookmark">
			ResNet介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ResNet介绍 1 简要概括 ResNet（Residual Neural Network）由微软研究院的Kaiming He等四名华人提出，通过使用ResNet Unit成功训练出了152层的神经网络，并在ILSVRC2015比赛中取得冠军，在top5上的错误率为3.57%，同时参数量比VGGNet低，效果非常突出。ResNet的结构可以极快的加速神经网络的训练，模型的准确率也有比较大的提升。同时ResNet的推广性非常好，甚至可以直接用到InceptionNet网络中。
ResNet的主要思想是在网络中增加了直连通道，即Highway Network的思想。此前的网络结构是性能输入做一个非线性变换，而Highway Network则允许保留之前网络层的一定比例的输出。ResNet的思想和Highway Network的思想也非常类似，允许原始输入信息直接传到后面的层中，如下图所示。
这样的话这一层的神经网络可以不用学习整个的输出，而是学习上一个网络输出的残差，因此ResNet又叫做残差网络。
2 创新点 提出残差学习的思想。传统的卷积网络或者全连接网络在信息传递的时候或多或少会存在信息丢失，损耗等问题，同时还有导致梯度消失或者梯度爆炸，导致很深的网络无法训练。ResNet在一定程度上解决了这个问题，通过直接将输入信息绕道传到输出，保护信息的完整性，整个网络只需要学习输入、输出差别的那一部分，简化学习目标和难度。VGGNet和ResNet的对比如下图所示。ResNet最大的区别在于有很多的旁路将输入直接连接到后面的层，这种结构也被称为shortcut或者skip connections。
3 网络结构 在ResNet网络结构中会用到两种残差模块，一种是以两个3*3的卷积网络串接在一起作为一个残差模块，另外一种是1*1、3*3、1*1的3个卷积网络串接在一起作为一个残差模块。他们如下图所示。
ResNet有不同的网络层数，比较常用的是50-layer，101-layer，152-layer。他们都是由上述的残差模块堆叠在一起实现的。
4 代码实现 #%% # Copyright 2016 The TensorFlow Authors. All Rights Reserved. # # Licensed under the Apache License, Version 2.0 (the "License"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffa9761cc3ca0fcba832700f83ccd281/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d8957ea06e46da4d4f7252618ab308a/" rel="bookmark">
			CF   B. Sonya and Exhibition
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A. Sonya and Hotels 题目网址 点击打开链接 time limit per test 1 second memory limit per test 256 megabytes input standard input output standard output Sonya decided that having her own hotel business is the best way of earning money because she can profit and rest wherever she wants.
The country where Sonya lives is an endless line. There is a city in each integer coordinate on this line. She has nn hotels, where the ii-th hotel is located in the city with coordinate xixi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d8957ea06e46da4d4f7252618ab308a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa1c596a173a006801a374840e54507f/" rel="bookmark">
			c语言错误：error C2018: unknown character &#39;0xa3&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两天的我，一直在怼课设，然而，现实并不总是像想象的那么容易，总是会伴有很多小插曲，就比如这个今天困扰我数个小时的问题：error C2018: unknown character '0xa3' 经过百度查询对比之后，现在终于解决了
出错原因：由于我的一时疏忽，英文大括号（'{'）被我打成了中文的（逐行检查，只要是中文字符如空格，分号等等）
今后一定要重视“全角符号”和“半角符号”，不能放过任何一个小细节。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/113/">«</a>
	<span class="pagination__item pagination__item--current">114/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/115/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>