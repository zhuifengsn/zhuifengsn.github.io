<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7b63566a3f41ec84f5d0e2356d5ec33/" rel="bookmark">
			【R语言-20行代码】牛顿迭代法求伽马函数极大似然估计法的参数估计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简述 研究了下计算公式，简化了一下，用r语言实现了。
算法解释 牛顿迭代法
x k + 1 = x k − f ( x k ) f ′ ( x k ) x_{k+1} = x_k - \frac{f(x_k)}{f&amp;#x27;(x_k)} xk+1​=xk​−f′(xk​)f(xk​)​
求解的方程是
f ( x ) = 0 f(x) = 0 f(x)=0
通过极大似然估计，构造对数似然方程，之后再关于 α \alpha α和 β \beta β 求偏导数。之后，得到关于 α \alpha α的非线性对数似然方程。然后， β \beta β可以用 α \alpha α表示。
再进一步的简化（去掉无关的项，再整理相关的项）
得到需要求解的方程为
l o g ( α ) + d i g a m m a ( α ) = 0 log(\alpha) + digamma(\alpha) = 0 log(α)+digamma(α)=0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7b63566a3f41ec84f5d0e2356d5ec33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a41709f835cca51dd802850b4bc56fb/" rel="bookmark">
			ajax的简单表单登录异步验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AJAX 解释：Asynchronous JavaScript And XML 异步的JavaScript和XML
AJAX是多个技术的联合产物 是浏览器客户端上的前端技术 PHP .NET C# Python 等
注意 ：只要做web开发，B/S架构，都要学习。不管服务器编程语言
通俗理解：
看视频时，看到一半的时候，网页视频已经缓存完毕，这时候如果登录的话，只会在账户小范围等部分刷新，不用完全刷新页面。
百度地图的扩大等， 只会扩大小范围，不会涉及到全局
多个下拉列表的联动，通过ajax，可以实时更新下一个列表的内容，不需要把全部的数据发送到客户
经典案例：
Google的输入框自动补全 auto_complete
Google的谷歌地图
浏览器本身软件也是支持多线程并发的，其中的ajax请求就是一个线程，一个页面可以可以发送多个请求
传统请求：
请求只要一发送，浏览器数据全部清除，准备迎接新的页面如果上一个请求未完成，新的请求开始，则会放弃上个请求操作传统请求会刷新整个页面，会造成一定时间的空白 AJAX操作 ：
用户登录功能，输入错误的话，会在下面提示用户输入错误等，不会重新刷新页面，只刷新下面的块元素等。用户请求不会间断，用户可以继续操作。在页面的其他地方继续操作 AJAX的发送请求全靠浏览器内置的这个对象：XMLHttpRequest 对象.
使用这个对象可以在浏览器中单独起用一个线程，通过浏览器线程发送该请求，达到异步效果
base标签可以用来设置基础地址&lt;base href=""+&gt; ${pageCOntext.request.scheme}---协议方式 如https ${pageCOntext.request.serverName}---服务器名字 ${pageCOntext.request.serverPort}--- 服务器端口 ${pageCOntext.request.contextPath}--- 基础路径 发送ajax的请求包含四步：
创建ajax核心对象，XMLHttpRequest，（浏览器内置的，可以直接使用）；
var xhr = new XMLhttpRequest();
注册回调函数
// 程序执行到这里的时候，后面的回调函数并不会执行，只是将回调函数注册给xhr对象 // xhr的对象发生改变的时候，后面的回调函数会执行 /* * 对象在请求和响应的过程中，从 0 到 4 * 0: 请求未初始化 * 1: 服务器连接已建立 * 2: 请求已接收 * 3: 请求处理中 * 4: 请求已完成，且响应已就绪 */ xhr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a41709f835cca51dd802850b4bc56fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b216e9ba5baf024f3bd9358104fbeef7/" rel="bookmark">
			CAS算法与ABA问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		锁是用来做并发最简单的方式，当然代价也是最高的。
独占锁是一种悲观锁，synchronized就是一种独占锁；它假设最坏的情况，并且只有在确保其它线程不会造成干扰的情况下执行，会导致其它所有需要锁的线程挂起直到持有锁的线程释放锁。
所谓乐观锁就是每次不加锁,假设没有冲突而去完成某项操作;如果发生冲突了那就去重试，直到成功为止。
CAS(Compare And Swap)是一种有名的无锁算法。CAS算法是乐观锁的一种实现。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B并返回true，否则返回false。
注:synchronized和ReentrantLock都是悲观锁。
注:什么时候使用悲观锁效率更高、什么使用使用乐观锁效率更高，要根据实际情况来判断选择。
提示:atomic中包下的类，采用的即为CAS乐观算法。
以AtomicInteger的public final int getAndSet(int newValue)方法，进行简单说明，
该方法是这样的:
其调用了Unsafe类的public final int getAndSetInt(Object var1, long var2, int var4)方法:
而该方法又do{…}while(…)循环调用了本地方法public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);
注:至于Windows/Linux下public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5)本地
方法是如何实现的，推荐阅读https://blog.csdn.net/v123411739/article/details/79561458。
CAS(Compare And Swap)原理简述： 某一线程执行一个CAS逻辑(如上图线程A),如果中途有其他线程修改了共享变量的值(如:上图中线程A执行到笑脸那一刻时),导致这个线程的CAS逻辑运算后得到的值与期望结果不一致，那么这个线程会再次执行CAS逻辑(这里是一个do while循环),直到成功为止。
注:可能上图中某些地方写得并不规范，主要理解意思即可，不要在意细节。
ABA问题： 如图所示，线程A进行CAS逻辑，在从内存中获取到var值到开始进行逻辑之间（对应图中笑脸处）,会有一个时间差;如果刚好在这个时间差内，有其他某线程对var做了一系列的操作,但最后又恢复了var的值，即:出现“偷梁换柱”的情况;虽然此时线程A仍然能CAS成功，但是中间多出的那些过程仍然可能引发问题。
注:可能上图中某些地方写得并不规范，主要理解意思即可，不要在意细节。
注:上图A变为B再变回A,A的属性被修改了，如果程序此时刚好需要用上A的属性,那么就可能造成实际结果与理想结果不
一致的情况。
注:根据实际情况，判断是否处理ABA问题。如果ABA问题并不会影响我们的业务结果，可以选择性处理或不处理;如果
ABA会影响我们的业务结果的，这时就必须处理ABA问题了。
追注:对于AtomicInteger等,没有什么可修改的属性;且我们只在意其结果值，所以对于这些类来说，本身就算发生了
ABA现象，也不会对原线程的结果造成什么影响。
解决ABA问题： 我们可以通过加一个标识来解决这个问题;即:所有要用到某一共享引用的线程，如果在用到该引用时，都对该引用对应的标识进行推进的话，那么CAS在进行“上图中笑脸前笑脸后”对比时，除了要对比原来的引用(上图中的A)外，还要对比标识的值是否一样，这样就解决了ABA问题。
注:可能上图中某些地方写得并不规范，主要理解意思即可，不要在意细节。
注:这个标识只有一个职责，那就是计数，我们并不拿其值做什么业务有关的操作。
注:各种乐观锁的实现中通常都会用版本戳version来标记对象，进而避免ABA问题。在Java中，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b216e9ba5baf024f3bd9358104fbeef7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b2b92a3db5c64fa05451fb8f219948b/" rel="bookmark">
			因子分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、与主成分的联系与区别
区别 主成分是通过线性组合将原变量综合成几个主成分
因子分析通过构建若干意义比较明确的公因子
主成分分析是变异数导向的方法
因子分析是共变异数导向的方法
联系因子分析是主成分分析的推广 二、因子分析思想
特点 因子变量数远少于原变量数
因子变量是一种新的综合
因子变量之间没有相关关系
因子变量具有明确的解释性
用途 减少分析变量个数
通过对变量间关系探测，将原变量进行分类
基本思想 将相关性较高的分在同一类中，每一类代表了一个基本结构，即公因子
用少数不可测的公共因子的线性函数来描述原观测的每一分量
Q型和R型因子分析 Q型因子分析：样品间的因子分析
R型因子分析：变量间的因子分析
三、R型因子分析模型
1、R型因子模型
2、因子载荷A的估计：因子估计方法：极大似然估计（R默认）、主因子估计
（1）极大似然估计
（2）主因子估计法
3、因子载荷的意义
4、因子旋转
（1）旋转目的
寻找每个主因子的实际意义如果各主因子的典型代表变量不突出，就需要进行旋转使因子载荷矩阵中载荷的绝对值向0和1两个方向分化 （2）旋转方法
5、因子得分
6、因子分析基本步骤
7、R语言因子分析过程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f088d1def6af098fe634d40ed8e38803/" rel="bookmark">
			Docker常用命令（详细图解演示一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：Docker的介绍,安装参看我的这篇文章.Linux下Docker安装（详细图解演示）这里把常用的命令做一个简单的总结.
Linux上面安装Docker.满足一下条件.
CPU是64位.
Linux内核必须在3.10版本以上. 1. 查看Docker的版本号. docker version (可以看到Docker的架构Client,Server,Registry) 2. 列出镜像. docker images 3. 显示Docker引擎的详细信息. docker info 4. 拉取镜像.(这里演示拉取Tomcat的Docker镜像). 首先进行docker search tomcat docker pull tomcat(由于直接访问的是Docker Hub，国外的下载速度较慢,超时报错.) 一种解决的方案就是在拉取镜像的时候修改为国内的镜像仓库地址.（修改为阿里云的Docker加速器也行的.在配置文件里面）. docker pull registry.docker-cn.com/library/tomcat vim /etc/docker/daemon.json 修改镜像地址.这样永久性更改. { "registry-mirrors": ["https://registry.docker-cn.com"] } 至此拉取镜像成功. 5.运行镜像. docker run -i -t -p 8080:8080 registry.docker-cn.com/library/tomcat /bin/bash -i :表示容器启动后，可以使用键盘进行输入. -t:将与服务器建立一个会话. -p:做端口映射. /bin/bash:表示运行容器中的bash应用程序,因为我们此时并不许要运行其他程序,只想进入容器. exit:退出容器 2c03a0376e56（这个是容器ID.12位长）. 启动容器.(启动已经停止的容器,指定容器ID或者容器名称). 6. 列出容器. 7. 停止容器.（等待很短的一段时间,才对容器发送SIGKILL信号的，才终止容器）. docker kill 容器ID（终止容器,使用该命令可对容器发送SIGKILL信号,以及终止容器）. 8. 重启容器 9：执行命令. docker exec -i -t 2c03a0376e56 ls -l 10 删除容器（rm 是删除已经停止运行的容器的.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f088d1def6af098fe634d40ed8e38803/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/253b77d025768cef41fc4f386885e787/" rel="bookmark">
			为什么要设置链表头结点？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;整理资料&gt;
Q：什么是头结点？
A：数据结构中，在单链表的开始结点之前附设一个类型相同的结点，称之为头结点。头结点的数据域可以不存储任何信息，头结点的指针域存储指向开始结点的指针（即第一个元素结点的存储位置）。
A：头结点其实就是一个数据域为空的结点（当然也可储存链表的长度之类的数据，一般对链表操作无影响），而首元结点就是第一个元素结点，即头结点后边的第一个结点。
Q：用来干嘛？
A：
1、防止单链表是空的而设的。当链表为空的时候,带头结点的头指针就指向头结点。如果当链表为空的时候,单链表没有带头结点,那么它的头指针就为NULL。
2、在第一个元素结点前插入结点（或删除第一个结点），使其操作与对其它结点一致。带头结点时，不论删除哪个位置上的结点，用到的代码都一样；不带头结点时，删除第1个元素和删除其它位置上的元素用到的代码不同，相对比较麻烦。
此处网友解释清楚：https://www.cnblogs.com/cs-lcy/p/7045303.html
3、头结点的存在使得空链表与非空链表的处理操作一致。单链表加上头结点之后，无论单链表是否为空，头指针始终指向头结点，因此空表和非空表的处理也统一了。
4、对单链表的多数操作应明确对哪个结点以及该结点的前驱。不带头结点的链表对首元结点、中间结点分别处理等；而带头结点的链表因为有头结点，首元结点、中间结点的操作相同 ,从而减少分支，使算法变得简单 ,流程清晰。对单链表进行插入、删除操作时，如果在首元结点之前插入或删除的是首元结点，不带头结点的单链表需改变头指针的值，在C 算法的函数形参表中头指针一般使用指针的指针(在C+ +中使用引用 &amp;)；而带头结点的单链表不需改变头指针的值，函数参数表中头结点使用指针变量即可。
感谢：https://blog.csdn.net/leo115/article/details/8602621
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccf9663b5f837f830d779319055afa50/" rel="bookmark">
			图像金字塔分解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Gauss Laplacian Pyramid 详情见:https://blog.csdn.net/zhuwei0710/article/details/69499498?utm_source=blogxgwz6
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/329afb5debfe250beee57f90f1dc58d0/" rel="bookmark">
			X光图像增强（Gauss Laplacian Pyramid）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		X光图像增强（Gauss Laplacian Pyramid） https://blog.csdn.net/zhuwei0710/article/details/69371642?utm_source=blogxgwz2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dc05b158d5c15fa6140d4a81c9f079d/" rel="bookmark">
			记一次在台式机上安装OPENWRT的过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将openwrt安装在台式机上，可以充当智能的路由器。当然，你也可以选择将OPENWRT刷到某些支持的硬件路由器上，但由于其功耗有限，功能当然也会受到一些限制。此外，刷路由器固件需要一定的技术含量，并有一定的风险。在台式机上安装，缺点是耗电量高，噪音大。
硬件准备 U盘一个（不小2G）具有PCI-E X4或PCI-E X8的台式机一台（该插槽需要空闲，如果有显卡在上面，可以将显示拔掉，然后使用板载的显卡)PCI-E多口网卡一个（我选择的是82580芯片，原因是驱动会默认安装）可以上网的路由器一台网线一根可以与路由器连接的其它电脑一台 网卡链接 店家比较负责的淘宝店 软件准备 U深度PE http://www.ushendu.com/ IMG写盘工具 http://www.onlinedown.net/soft/620414.htm openwrt x86安装镜像（下载后解压成img文件） openwrt下载地址：https://downloads.openwrt.org/releases/ 选择一个版本，然后点targets/x86/64/，来到下载列表。
下载这个ext4的即可。
操作步骤 将网卡插到PCE-E插槽中，并用网线将其中的一个口以路由器相连。
制作PE启动盘 将U盘插入电脑，并运行下载的U深度PE安装文件。完成后，U盘将被分成两个区，一个安装了PE系统，还有一个是数据盘。
将下载的IMG写盘工具以及openwrt x86安装镜像（IMG文件）复制到U盘的数据盘中。
启动台式机 台式机设置为U盘启动，插入U盘，启动电脑，选择一个PE版本（尽量选择老版本），进入PE系统。
运行IMG写盘工具，选择台式机硬盘和openwrt x86安装镜像（IMG文件），点击start写盘。
成功后，插掉U盘，重新启动电脑。
进入openwrt管理界面 系统重新启动后，将进行openwrt管理界面，默认的地址是192.168.1.1，默认的用户名为root，密码为空。进行系统后，可以进行更改。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/691826d517dd01b11b02a4b9094d4a66/" rel="bookmark">
			解决plt.show()闪退
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决plt.show()闪退 我今天在Linux下进行实验时，发现简单的plt.show()竟然不能显示图片了，一闪就没了。
报错如下： python: relocation error: /home/magic/anaconda2/plugins/xcbglintegrations/libqxcb-glx-integration.so: symbol _ZNK14QXcbConnection12xlib_displayEv, version Qt_5_PRIVATE_API not defined in file libQt5XcbQpa.so.5 with link time reference 在网上并没有搜索到相关解决方法，于是自己仔细看了一下错误提示。发现是libqxcb-glx-integration.so这个文件没有链接到libQt5XcbQpa.so.5，于是解决方案也就来了。
1.首先定位到/home/magic/anaconda2/plugins/xcbglintegrations/libqxcb-glx-integration.so文件
2.利用locate命令定位出libQt5XcbQpa.so.5文件所在目录。我的如下：
/home/magic/anaconda2/envs/flownet2/lib/libQt5XcbQpa.so.5 /home/magic/anaconda2/envs/flownet2/lib/libQt5XcbQpa.so.5.9 /home/magic/anaconda2/envs/flownet2/lib/libQt5XcbQpa.so.5.9.6 /home/magic/anaconda2/envs/tensorflow/lib/libQt5XcbQpa.so.5 /home/magic/anaconda2/envs/tensorflow/lib/libQt5XcbQpa.so.5.6 /home/magic/anaconda2/envs/tensorflow/lib/libQt5XcbQpa.so.5.6.2 /home/magic/anaconda2/lib/libQt5XcbQpa.so.5 /home/magic/anaconda2/lib/libQt5XcbQpa.so.5.6 /home/magic/anaconda2/lib/libQt5XcbQpa.so.5.6.2 /home/magic/anaconda2/pkgs/qt-5.6.2-2/lib/libQt5XcbQpa.so.5 /home/magic/anaconda2/pkgs/qt-5.6.2-2/lib/libQt5XcbQpa.so.5.6 /home/magic/anaconda2/pkgs/qt-5.6.2-2/lib/libQt5XcbQpa.so.5.6.2 /home/magic/anaconda2/pkgs/qt-5.6.2-5/lib/libQt5XcbQpa.so.5 /home/magic/anaconda2/pkgs/qt-5.6.2-5/lib/libQt5XcbQpa.so.5.6 /home/magic/anaconda2/pkgs/qt-5.6.2-5/lib/libQt5XcbQpa.so.5.6.2 /home/magic/anaconda2/pkgs/qt-5.6.2-h974d657_12/lib/libQt5XcbQpa.so.5 /home/magic/anaconda2/pkgs/qt-5.6.2-h974d657_12/lib/libQt5XcbQpa.so.5.6 /home/magic/anaconda2/pkgs/qt-5.6.2-h974d657_12/lib/libQt5XcbQpa.so.5.6.2 /home/magic/anaconda2/pkgs/qt-5.9.6-h8703b6f_2/lib/libQt5XcbQpa.so.5 /home/magic/anaconda2/pkgs/qt-5.9.6-h8703b6f_2/lib/libQt5XcbQpa.so.5.9 /home/magic/anaconda2/pkgs/qt-5.9.6-h8703b6f_2/lib/libQt5XcbQpa.so.5.9.6 /usr/lib/x86_64-linux-gnu/libQt5XcbQpa.so.5 #找到此目录 /usr/lib/x86_64-linux-gnu/libQt5XcbQpa.so.5.5 /usr/lib/x86_64-linux-gnu/libQt5XcbQpa.so.5.5.1 3.利用ln -s软连接两个文件即可。（cd到/home/magic/anaconda2/plugins/xcbglintegrations目录下）
ln -sf /usr/lib/x86_64-linux-gnu/libQt5XcbQpa.so.5 libqxcb-glx-integration.so posted on 2018-10-10 19:53 Magic_chao 阅读(...) 评论(...) 编辑 收藏 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57c1dd339af8897ca0ac2f93ec14dda8/" rel="bookmark">
			DICOM：DICOM标准学习路线图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/zssureqh/article/details/49231303
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61937d2a35bdc7f823d9da10518370d8/" rel="bookmark">
			final关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当final修饰的是基本数据类型时，它指的是数值恒定不变（就是编译期常量，如果是static final修饰，则强调只有一份），而对对象引用而不是基本类型运用final时，其含义会有一点令人迷惑，因为用于对象引用时，final使引用恒定不变，一旦引用被初始化指向一个对象，就无法再把它指向另一个对象。然而，对象其自身却是可以被修改的，Java并未提供使任何对象恒定不变的途径（但可以自己编写类以取得使对象恒定不变的效果），这一限制同样适用数组，它也是对象。
使用final方法真的可以提高程序效率吗？
将一个方法设成final后，编译器就可以把对那个方法的所有调用都置入“嵌入”调用里。只要编译器发现一个final方法调用，就会（根据它自己的判断）忽略为执行方法调用机制而采取的常规代码插入方法（将自变量压入堆栈；跳至方法代码并执行它；跳回来；清除堆栈自变量；最后对返回值进行处理）。相反，它会用方法主体内实际代码的一个副本来替换方法调用。这样做可避免方法调用时的系统开销。当然，若方法体积太大，那么程序也会变得雍肿，可能受不到嵌入代码所带来的任何性能提升。因为任何提升都被花在方法内部的时间抵消了。
虚拟机（特别是hotspot技术）能自动侦测这些情况，并颇为“明智”地决定是否嵌入一个final 方法。然而，最好还是不要完全相信编译器能正确地作出所有判断。通常，只有在方法的代码量非常少，或者想明确禁止方法被覆盖的时候，才应考虑将一个方法设为final。
类内所有private 方法都自动成为final。由于我们不能访问一个private 方法，所以它绝对不会被其他方法覆盖（若强行这样做，编译器会给出错误提示）。可为一个private方法添加final指示符，但却不能为那个方法提供任何额外的含义。
记住：只有在方法的代码量非常少，或者想明确禁止方法被覆盖的时候，才应考虑将一个方法设为final。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad6ea161aa653b91f56cd1014a8395f4/" rel="bookmark">
			组合和继承之间的选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组合和继承都允许在新的类中放置子对象，组合是显式的这样做，而继承则是隐式的做。
组合技术通常用于想在新类中使用现有类的功能而非它的接口这种情形。即在新类中嵌入某个对象，让其实现所需要的功能，但新类的用户看到的只是为新类所定义的接口，而非所嵌入对象的接口。为取得此效果，需要在新类中嵌入一个现有类的private对象。但有时，允许类的用户直接访问新类中的组合成分是极具意义的，即将成员对象声明为public。如果成员对象自身都隐藏了具体实现，那么这种做法是安全的。当用户能够了解到你正在组装一组部件时，会使得端口更加易于理解。比如Car对象可由public的Engine对象、Wheel对象、Window对象和Door对象组合。但务必要记得这仅仅是一个特例，一般情况下应该使域成为private。
在继承的时候，使用某个现有类，并开发一个它的特殊版本。通常，这意味着你在使用一个通用类，并为了某种特殊需要而将其特殊化。稍微思考一下就会发现，用一个“交通工具”对象来构成一部“车子”是毫无意义的，因为“车子”并不包含“交通工具”，它仅是一种交通工具（is-a关系）。
“is-a”（是一个）的关系是用继承来表达的，而“has-a”（有一个）的关系则是用组合来表达的。
到底是该用组合还是继承，一个最清晰的判断方法就是问一问自己是否需要从新类向基类进行向上转型，需要的话就用继承，不需要的话就用组合方式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4b97e18a10c3c545d20e60ddc78dec6/" rel="bookmark">
			运行时类型信息（RTTI &#43; 反射）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行时类型信息使得你可以在程序运行时发现和使用类型信息。
Java是如何让我们在运行时识别对象和类的信息的，主要有3种方式
“传统的”RTTI，它假定我们在编译时已经知道了所有的类型，比如Shape s = (Shape)s1；
“反射”机制，它运行我们在运行时发现和使用类的信息，即使用Class.forName()。
关键字instanceof，它返回一个bool值，它保持了类型的概念，它指的是“你是这个类吗？或者你是这个类的派生类吗？”。而如果用==或equals比较实际的Class对象，就没有考虑继承—它或者是这个确切的类型，或者不是。
RTTI：Run-Time Type Identification，即运行时类型识别，是指在运行时识别一个对象的类型，其对应的类是Class对象，每个java里面的类都对应一个Class对象(在编写并且编译后)，这个对象被保存在这个类的同名class文件里。
要理解RTTI在Java中的工作原理，首先必须知道类型信息在运行时是如何表示的，这项工作是由称为Class对象的特殊对象完成的，它包含了与类有关的信息。Java送Class对象来执行其RTTI，使用类加载器的子系统实现。
无论何时，只要你想在运行时使用类型信息，就必须首先获得对恰当的Class对象的引用，获取方式有三种：
a.如果你没有持有该类型的对象，则Class.forName()就是实现此功能的便捷途，因为它不需要对象信息。
b.如果你已经拥有了一个感兴趣的类型的对象，那就可以通过调用getClass()方法来获取Class引用了，它将返回表示该对象的实际类型的Class引用。
c.使用类字面常量。比如这样：String.class;来引用。
这样做不仅更简单，而且更安全，因为它在编译时就会受到检查（因此不需要置于try语句块中），并且它根除了对forName方法的引用，所以也更高效。类字面常量不仅可以应用于普通的类，也可以应用于接口、数组以及基本数据类型。
注意：
当使用“.class”来创建对Class对象的引用时，不会自动地初始化该Class对象，初始化被延迟到了对静态方法（构造器隐式的是静态的）或者非final静态域（注意final静态域不会触发初始化操作）进行首次引用时才执行。
而使用Class.forName时会自动的初始化。
为了使用类而做的准备工作实际包含三个步骤：
- 加载：由类加载器执行。查找字节码，并从这些字节码中创建一个Class对象
- 链接：验证类中的字节码，为静态域分配存储空间，并且如果必需的话，将解析这个类创建的对其他类的所有引用。
- 初始化：如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。
如果不知道某个对象的确切类型，RTTI可以告诉你，但是有一个限制：这个类型在编译时必须已知，这样才能使用RTTI识别它，也就是在编译时，编译器必须知道所有要通过RTTI来处理的类。如果要突破这个限制就需要使用反射机制。
反射的原理：
Class类与java.lang.reflect类库一起对反射的概念进行了支持，该类库包含了Field、Method以及Constructor类（每个类都实现了Member接口）。这些类型的对象是由JVM在运行时创建的，用以表示未知类里对应的成员。这样你就可以使用Constructor创建新的对象，用get()/set()方法读取和修改与Field对象关联的字段，用invoke()方法调用与Method对象关联的方法。另外，还可以调用getFields()、getMethods()和getConstructors()等很便利的方法，以返回表示字段、方法以及构造器的对象的数组。这样，匿名对象的类信息就能在运行时被完全确定下来，而在编译时不需要知道任何事情。
反射与RTTI的区别
当通过反射与一个未知类型的对象打交道时，JVM只是简单地检查这个对象，看它属于哪个特定的类（就像RTTI那样），在用它做其他事情之前必须先加载那个类的Class对象，因此，那个类的.class文件对于JVM来说必须是可获取的：要么在本地机器上，要么可以通过网络取得。所以RTTI与反射之间真正的区别只在于：对RTTI来说，编译器在编译时打开和检查.class文件（也就是可以用普通方法调用对象的所有方法）；而对于反射机制来说，.class文件在编译时是不可获取的，所以是在运行时打开和检查.class文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07354de6a6586faee529572203c4b368/" rel="bookmark">
			Linux中 2&gt;&amp;1 的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Linux中 2&gt;&amp;1 的用法 在跑视频数据集的时候，经常看到脚本文件中出现了 sh run_pascal.sh 2&gt;&amp;1 | tee train.log 类似的用法，那么2&gt;&amp;1究竟是怎么用的呢？
在linux中，0表示标准输入，即stdin；1表示标准输出，即stdout；2表示标准错误，即stderr。
&gt;表示重定向，&amp;表示取地址，那么&amp;1就是取到了标准输出的地址，也就是 2&gt;&amp;1表示的是将标准错误重定向到了标准输出，也就是将运行脚本中出错的信息重定向到了标准输出。
举例：
ls 2&gt;1测试一下，由于ls命令会列出当前目录的文件列表，不会产生错误信息，于是会产生一个空的文件1。
ls xxx 2&gt;1测试，ls xxx会列出xxx的文件列表，如果没有xxx文件，会产生错误信息，于是会产生一个有错误信息的文件1。
ls xxx 2&gt;&amp;1测试，如果没有xxx文件，会产生错误信息在屏幕上，即标准输出。
ls xxx &gt;out.txt 2&gt;&amp;1, 实际上就是ls xxx 1&gt;out.txt 2&gt;&amp;1。如果没有xxx文件，会产生一个标准错误重定向到了标准输出，而标准输出又重定向到了out.txt，于是结果会产生一个有错误信息的文件out.txt。如果有xxx文件，那么结果会将输出存入文件out.txt。总的说来，就是将输出和错误都存入了文件out.txt。
那么sh run_pascal.sh 2&gt;&amp;1 | tee train.log 也就好理解了，就是将sh run_pascal.sh的运行结果（输出和错误）都重定向到标准输出，同时，利用tee命令将信息存入train.log文件。
posted on 2018-10-04 11:15 Magic_chao 阅读(...) 评论(...) 编辑 收藏 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d3d6791df7356fbd4be643fe3f6fa3a/" rel="bookmark">
			遗传算法的特点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遗传算法是解决搜索问题的一种通用算法，对于各种通用问题都可以使用。搜索算法的共同特征为：
① 首先组成一组候选解
② 依据某些适应性条件测算这些候选解的适应度
③ 根据适应度保留某些候选解，放弃其他候选解
④ 对保留的候选解进行某些操作，生成新的候选解。
在遗传算法中，上述几个特征以一种特殊的方式组合在一起：基于染色体群的并行搜索，带有猜测性质的选择操作、交换操作和突变操作。这种特殊的组合方式将遗传算法与其它搜索算法区别开来。
遗传算法
遗传算法
遗传算法还具有以下几方面的特点：
(1)遗传算法从问题解的串集开始搜索，而不是从单个解开始。这是遗传算法与传统优化算法的极大区别。传统优化算法是从单个初始值迭代求最优解的；容易误入局部最优解。遗传算法从串集开始搜索，覆盖面大，利于全局择优。
(2)遗传算法同时处理群体中的多个个体，即对搜索空间中的多个解进行评估，减少了陷入局部最优解的风险，同时算法本身易于实现并行化。
(3)遗传算法基本上不用搜索空间的知识或其它辅助信息，而仅用适应度函数值来评估个体，在此基础上进行遗传操作。适应度函数不仅不受连续可微的约束，而且其定义域可以任意设定。这一特点使得遗传算法的应用范围大大扩展。
(4)遗传算法不是采用确定性规则，而是采用概率的变迁规则来指导他的搜索方向。
(5)具有自组织、自适应和自学习性。遗传算法利用进化过程获得的信息自行组织搜索时，适应度大的个体具有较高的生存概率，并获得更适应环境的基因结构。
(6)此外，算法本身也可以采用动态自适应技术，在进化过程中自动调整算法控制参数和编码精度，比如使用模糊自适应法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1efbdd1c6341feb91d305c6b88436949/" rel="bookmark">
			遗传算法的运算过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遗传算法（Genetic Algorithm）是一类借鉴生物界的进化规律（适者生存，优胜劣汰遗传机制）演化而来的随机化搜索方法。它是由美国的J.Holland教授1975年首先提出，其主要特点是直接对结构对象进行操作，不存在求导和函数连续性的限定；具有内在的隐并行性和更好的全局寻优能力；采用概率化的寻优方法，能自动获取和指导优化的搜索空间，自适应地调整搜索方向，不需要确定的规则。遗传算法的这些性质，已被人们广泛地应用于组合优化、机器学习、信号处理、自适应控制和人工生命等领域。它是现代有关智能计算中的关键技术。
对于一个求函数最大值的优化问题(求函数最小值也类同)，一般可以描述为下列数学规划模型：式中x为决策变量，式2-1为目标函数式，式2-2、2-3为约束条件，U是基本空间，R是U的子集。满足约束条件的解X称为可行解，集合R表示所有满足约束条件的解所组成的集合，称为可行解集合。
遗传算法也是计算机科学人工智能领域中用于解决最优化的一种搜索启发式算法，是进化算法的一种。这种启发式通常用来生成有用的解决方案来优化和搜索问题。进化算法最初是借鉴了进化生物学中的一些现象而发展起来的，这些现象包括遗传、突变、自然选择以及杂交等。遗传算法在适应度函数选择不当的情况下有可能收敛于局部最优 [1] ，而不能达到全局最优。
遗传算法的基本运算过程如下：
a)初始化：设置进化代数计数器t=0，设置最大进化代数T，随机生成M个个体作为初始群体P(0)。
b)个体评价：计算群体P(t)中各个个体的适应度。
遗传算法
遗传算法
c)选择运算:将选择算子作用于群体。选择的目的是把优化的个体直接遗传到下一代或通过配对交叉产生新的个体再遗传到下一代。选择操作是建立在群体中个体的适应度评估基础上的。
d)交叉运算：将交叉算子作用于群体。遗传算法中起核心作用的就是交叉算子。
e)变异运算：将变异算子作用于群体。即是对群体中的个体串的某些基因座上的基因值作变动。
群体P(t)经过选择、交叉、变异运算之后得到下一代群体P(t+1)。
f)终止条件判断:若t=T,则以进化过程中所得到的具有最大适应度个体作为最优解输出，终止计算。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4db2a39974e952c9e96c709948c2cf1e/" rel="bookmark">
			页面浏览统计之(一) hitcount
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转：http://www.codingsoho.com/zh/blog/component-hitcount/
hit counter是用来计数模型对象的访问次数的。
Django hit counter application that tracks the number of hits/views for chosen objects.
https://github.com/thornomad/django-hitcount
安装 pip install django-hitcount
参考网站 http://django-hitcount.readthedocs.org/en/latest/installation.html
配置 将django-hitcount添加到INSTALLED_APPS，同时激活SESSION_SAVE_EVERY_REQUEST
settings.py
INSTALLED_APPS = ( ... 'hitcount' ) # needed for django-hitcount to function properly SESSION_SAVE_EVERY_REQUEST = True 更多配置查看http://django-hitcount.readthedocs.org/en/latest/settings.html
视图 urls.py中加入
urlpatterns = patterns('', ... url(r'hitcount/', include('hitcount.urls', namespace='hitcount')), ) 记录点击 https://django-hitcount.readthedocs.io/en/latest/installation.html#counting-hits
可以用HitCountMixin或者下面两个视图
HitCountJSONView: a JavaScript implementation which moves the business-logic to an Ajax View and hopefully speeds up page load times and eliminates some bot-trafficHitCountDetailView: which provides a wrapper from Django’s generic DetailView and allows you to process the Hit as the view is loaded 我的实现项目里有类视图和函数视图，用到了上面的HitCountMixin和HitCountDetailView两个方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4db2a39974e952c9e96c709948c2cf1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f4016540a665eab88c38e91d1ec893a/" rel="bookmark">
			C/C&#43;&#43;——C语言跳出多重循环方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c语言的break语句只能跳出离它最近的一层循环，但是我们有时候需要跳出多层循环，以下有几种跳出多重循环的方法：
1. 使用goto for (int i = 0; i &lt; MAX1; i++) { for (int j = 0; j &lt; MAX2; j++) { if (condition) { symbol = 1; goto outloop; } } } outloop: //somecode 2. 写成函数 return for () { for () { for () { if(condition) { symbol = 1; return; } } } } 3. 直接修改外层循环条件 for(int i = 0; i &lt; MAX1; i++) { for(int j = 0; j &lt; MAX2; j++) { if(condition1) { symbol = 1; i = MAX1; break; } } } 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f4016540a665eab88c38e91d1ec893a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee3be6e7569864d66b3ffbbe48d28d44/" rel="bookmark">
			人工智能的定义详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人工智能的定义可以分为两部分，即“人工”和“智能”。“人工”比较好理解，争议性也不大。有时我们会要考虑什么是人力所能及制造的，或者人自身的智能程度有没有高到可以创造人工智能的地步，等等。但总的来说，“人工系统”就是通常意义下的人工系统。
关于什么是“智能”，就问题多多了。这涉及到其它诸如意识（CONSCIOUSNESS）、自我（SELF）、思维（MIND）（包括无意识的思维（UNCONSCIOUS_MIND））等等问题。人唯一了解的智能是人本身的智能，这是普遍认同的观点。但是我们对我们自身智能的理解都非常有限，对构成人的智能的必要元素也了解有限，所以就很难定义什么是“人工”制造的“智能”了。因此人工智能的研究往往涉及对人的智能本身的研究。其它关于动物或其它人造系统的智能也普遍被认为是人工智能相关的研究课题。
人工智能在计算机领域内，得到了愈加广泛的重视。并在机器人，经济政治决策，控制系统，仿真系统中得到应用。
尼尔逊教授对人工智能下了这样一个定义：“人工智能是关于知识的学科――怎样表示知识以及怎样获得知识并使用知识的科学。”而另一个美国麻省理工学院的温斯顿教授认为：“人工智能就是研究如何使计算机去做过去只有人才能做的智能工作。”这些说法反映了人工智能学科的基本思想和基本内容。即人工智能是研究人类智能活动的规律，构造具有一定智能的人工系统，研究如何让计算机去完成以往需要人的智力才能胜任的工作，也就是研究如何应用计算机的软硬件来模拟人类某些智能行为的基本理论、方法和技术。
人工智能是计算机学科的一个分支，二十世纪七十年代以来被称为世界三大尖端技术之一（空间技术、能源技术、人工智能）。也被认为是二十一世纪三大尖端技术（基因工程、纳米科学、人工智能）之一。这是因为近三十年来它获得了迅速的发展，在很多学科领域都获得了广泛应用，并取得了丰硕的成果，人工智能已逐步成为一个独立的分支，无论在理论和实践上都已自成一个系统。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/111/">«</a>
	<span class="pagination__item pagination__item--current">112/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/113/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>