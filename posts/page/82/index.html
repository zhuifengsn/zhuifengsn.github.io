<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d86e785cd61d83695a78285c1b28a58c/" rel="bookmark">
			Bert加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83ca31d0072d877de4428b739ee391d1/" rel="bookmark">
			Airtest IDE 自动化测试11 - text 和 keyevent
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在 Airtest IDE 的 Airtest录制辅助窗内，包含有三种类型的录制按钮:
操作类型辅助类型断言类型touchtextassert_existsswipekeyeventassert_not_existswaitsleepassert_equalexistassert_not_equalsnapshot text 输入文本 在目标设备上输入文本，文本框需要处于激活状态
参数:
text :要输入的文本enter :完成输入后默认执行 Enter 操作 ，默认是 Truesearch :完成输入后强制执行search 操作，默认是 False 返回: None
支持平台: Android, Windows, iOS
使用示例
&gt;&gt;&gt; text("test") &gt;&gt;&gt; text("test", enter=False) 在Android上，有时你需要在输入完毕后点击搜索按钮:
text("test", search=True) Module airtest.core.android.ime.YosemiteIme.code
如果你想输入其它键，可以使用这个接口::
&gt;&gt;&gt; text("test") &gt;&gt;&gt; device().yosemite_ime.code("3") # 3 = IME_ACTION_SEARCH keyevent 在设备上执行 keyevent 按键事件
keyname – 平台相关的按键名称**kwargs – 平台相关的参数 kwargs，请参考对应的平台接口文档 返回 None 支持平台：Android, Windows, iOS
Android: 相当于执行了 adb shell input keyevent KEYNAME
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83ca31d0072d877de4428b739ee391d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99e1bd3d30f0211cd85624e1f44205da/" rel="bookmark">
			Web基础与布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
任务一：使用富文本编辑器
拓展：CSS盒子模型
自测
参考资料
任务一：使用富文本编辑器 实现编辑器没有的功能，例如让表格隔行换色、加入JavaScript按钮。工具：开源富文本编辑器（https://summernote.org/） &lt;style&gt; /* table 中的 class 为编辑器自动添加，使用的是它内置的样式 这里主要讲表格隔行换色 */ /*奇数行*/ table tr:nth-child(odd) { background-color: gray; } /*偶数行*/ table tr:nth-child(even) { background-color: red; } &lt;/style&gt; &lt;p&gt;Hello world!&lt;/p&gt; &lt;table class="table table-bordered"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;input type="button" onclick="alert('确定')" value="确定"&gt; &lt;button id="btn" onclick="alert('确定')"&gt;OK&lt;/button&gt; 编写好表格代码后，在css代码中，使用 nth-child 方法区别表格中每一行的奇偶数（奇数行：odd，偶数行：even），给奇数和偶数列分别赋予不同的颜色
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99e1bd3d30f0211cd85624e1f44205da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7d731ab3982bde6b10f7cf4f37d8c29/" rel="bookmark">
			(2021-05-28)JVM概览学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面试准备，jvm也需要再回顾一下。
目录
1.什么是JVM
2.JVM的组成
2.1 类加载子程序
1.加载
2.验证
3.准备
4.解析
5.初始化
2.2 运行时数据区
1. 线程私有数据
2.线程共享数据
2.3 执行引擎
3. GC
3.1 GC的判断方法
3.2 GC ROOT
3.2 内存泄漏和内存溢出
4.分代机制
4.1 新生代
4.2 老年代
5.垃圾回收器
5.1 serial - serial old
5.2 Parallel Scavenge（PS）—Parallel Old（PO）
5.3 parNew—CMS
5.4 G1
1.什么是JVM JVM应该是我们平时很难实际接触到，但是面试又很容易问到的一个知识点了。首先，简单的介绍一下JVM。JVM（Java Virtual Machine），是一个跨平台的工具。不光java，c++以及Python等语言也是适用的，而且不光在Windows平台，linux等平台也是适用的。
而在我看来，JVM就是一个“翻译器”，为什么说它是“翻译器”呢？下面用一张图，来直观的感受一下
在我们.java文件运行之后（通过javac执行之后），会变成.class文件。而字节码文件（.class）是JVM能够识别并且处理的文件。
简单的来过一下流程，类加载器将字节码文件，java类库进行加载，然后通过字节码解释器来读对应的代码，以及通过JIT将其解析成为本机的机器码，让后通过执行引擎对机器码进行执行（机器码也就是二进制语言：010111）
2.JVM的组成 JVM是由 类加载子程序，运行时数据区，执行引擎 这三部分组成。
2.1 类加载子程序 它的过程简单来讲就是：加载.class文件到内存，并对数据进行校验，解析和初始化。最后让它形成可以被虚拟机直接使用的类型。
详细点来说的话，分为5个步骤
加载、验证、准备、解析、初始化
1.加载 其实就是通过类加载器把字节码文件(.class)加载到内存中，以及java对应的核心库等数据源
什么是类加载器呢？——实现通过类的权限定名获取该类的二进制字节流的代码块
常见的四种类型加载器：
启动加载器：用来加载java核心类库，无法被java程序直接引用的扩展加载器：它用来加载java的扩展库系统加载器：根据java应用的类路径来加载java类用户自定义类加载器：通过继承java.lang.ClassLoader类的方式实现 2.验证 主要为了确保class文件的字节流中的信息不会危害的虚拟机，或者说导致虚拟机无法正确的执行操作。具体有四种验证：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7d731ab3982bde6b10f7cf4f37d8c29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f327d320ffd3d2f3b8eb061118f7392b/" rel="bookmark">
			android l tv 模拟器,Android TV开发之模拟器的设立
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进行Android TV开发时，会碰见模拟器显示的效果跟在盒子上或电视上差异很大，屏幕的大小都是1920*1080的，为什么会差别这么大呢，原因就是像素密度的问题。我们可以用一下代码进行测试：
DisplayMetrics dm =getResources().getDisplayMetrics();
int w_screen = dm.widthPixels;
int h_screen = dm.heightPixels;
ToastUtil.showToast( "屏幕尺寸1：宽度 = " + w_screen + "高度 = " + h_screen + "密度 = " + dm.densityDpi);
会发现，在盒子上的密度值和模拟器上的密度值不一样，这就需要修改模拟器的pixel-density的值。在android studio 的Virtual Manager上默认提供的是xhdpi的分辨率，density的值为320。如果这个值和盒子上的值不一致，就会导致，显示差异。我们可以用如下方法，创建和盒子的密度值一致的模拟器：
1.在Virtual Configuration界面上选择一个1920*1080的配置，右键，export，存储为xml文件。
2.然后打开存储的xml文件，修改d:name节点的值和d:pixel-density值。如何修改，下面有个对应关系：
xhdpi 320
hdpi 240
mdpi 160
3.修改完毕后在Virtual Configuration界面上，点击Import Hardware Profiles，选中刚才修改过的文件，
导入配置，点击右下角的刷新按钮，完成后在TV 的列表中就会新增一个device definition。就可以用这个device definition
来创建模拟器，就可以在模拟器上运行app，并达到跟真实盒子或电视基本一致的显示效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9c239e8a43d377f0d9aa5ce5a8b4553/" rel="bookmark">
			二叉搜索树的完整操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉搜索树完全实现 二叉搜索树，又叫二叉查找树（Binary Search Tree）；
请问你思考过没有？有了哈希表，为什么我们还需要二叉树？
其中最主要的一个原因，就是哈希表如果要按照顺序输出的时候，就比较麻烦，因为元素分布是无序的，而二叉树的特殊形态 ---- 二叉搜索树就比较简单了，只需要中序遍历就好了。
而hashmap的底层红黑树其实也是一种特殊的二叉搜索树；也许有的同学很想啃下来红黑树，当面试的时候面试官问起hashmap源码的时候做到游刃有余，那么二叉搜索树算是前面的一个小BOSS。
什么是二叉搜索树
二叉搜索树是一种特殊的二叉树；二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。
那么为什么二叉搜索树有了这种特性之后中序遍历就一定是按照顺序的呢？因为中序遍历就是树上的任意一个节点，左子树上面的所有值都在这个节点输出之前输出，右子树上面的所有节点的值都在这个节点输出之后输出，所以一定是有序的。
中序遍历伪代码
public List&lt;Integer&gt; order(TreeNode root, List&lt;Integer&gt; res) { if (Objects.nonNull(root)) { order(root.left, res); res.add(root.val); order(root.right, res); } return res; } 如何完成二叉搜索树基本的操作 我们完成的二叉搜索树是一棵没有重复元素的二叉搜索树。
二叉搜索树的基本操作可以分为增、删、查。修改可以看做先删再插。
添加元素的操作
增加相对来说比较简单，我们先看一下树的根节点是不是有值，如果没有值的话，就把当前的元素赋值为根节点即可；如果有值的话，确认一个指针point，指向根节点，然后比教指针上面的值和待插入元素的值：
如果指针的元素的值比较大，那么判断指针的左子节点是否为空，为空的话就将待插入节点当做指针节点的左子节点，并完成增加操作，跳出循环；不是空的话，指针就指向指针的左子节点。如果指针的元素的值比较小，那么判断指针的右子节点是否为空，为空的话就将待插入节点当做指针节点的右子节点，并完成增加操作，跳出循环；不是空的话，指针就指向指针的右子节点。 查找元素的操作
查找的话和插入差不多，也是定义一个指针节点指向根节点。定义一个循环，比较指针节点的值和代插入节点的值，如果待插入的节点比指针节点大，那么指针就指向指针的右子节点，反之则指向左子节点，如果相等就返回，跳出循环。
删除元素的操作
删除的话，是比较复杂的情况。我们需要和查找的方法一样，首先找到待删除的节点，然后判断这个节点是否有左右子节点，如果没有左子节点的话，就直接把待删除节点的父节点的子节点设置为待删除节点的右子节点。如果没有右子节点的话，就直接把待删除节点的父节点的子节点设置为待删除节点的左子节点。
如果既有左子节点也有右子节点的话，那么就要找到待删除节点的后继节点（一个节点的后继节点就是比当前节点的值大的所有节点中最小的那个，可以保证这个节点是不会有左子节点的）。然后把待删除的节点的值设置成这个后继节点的值，等遍历到了这个后继节点的时候，把它的父节点的子节点设置成这个节点的右子节点（因为它肯定没有左子树）。
同理，也可以操作待删除节点的前驱节点，大家可以试一下。
完整代码
package com.darwin.algorithm.tree; import com.darwin.algorithm.tree.util.TreeNode; import sun.reflect.generics.tree.Tree; import java.util.*; /** * 二叉搜索树的操作 */ public class BinarySearchTree { private TreeNode root; public void insert(TreeNode node) { if (root == null) { root = node; return; } TreeNode point = root; while (true) { if (point.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9c239e8a43d377f0d9aa5ce5a8b4553/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44ffd6647ca796365c5509bf410cdcab/" rel="bookmark">
			什么叫做覆盖索引？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在了解覆盖索引之前我们先大概了解一下什么是聚集索引(主键索引)和辅助索引(二级索引)
聚集索引（主键索引）：
聚集索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的即为整张表的记录数据。
聚集索引的叶子节点称为数据页，聚集索引的这个特性决定了索引组织表中的数据也是索引的一部分。
辅助索引（二级索引）：
非主键索引，叶子节点=键值+书签。Innodb存储引擎的书签就是相应行数据的主键索引值。
再来看看什么是覆盖索引，有下面三种理解：
解释一： 就是select的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。解释二： 索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫 做覆盖索引。解释三：是非聚集组合索引的一种形式，它包括在查询里的Select、Join和Where子句用到的所有列（即建立索引的字段正好是覆盖查询语句[select子句]与查询条件[Where子句]中所涉及的字段，也即，索引包含了查询正在查找的所有数据）。 不是所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引的列，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引
当发起一个被索引覆盖的查询(也叫作索引覆盖查询)时，在EXPLAIN的Extra列可以看到“Using index”的信息
从执行结果上看，这个SQL语句只通过索引，就取到了所需要的数据，这个过程就叫做索引覆盖。
几种优化场景： 1.无WHERE条件的查询优化： 执行计划中，type 为ALL，表示进行了全表扫描
如何改进？优化措施很简单，就是对这个查询列建立索引。如下，
ALERT TABLE t1 ADD KEY(staff_id); 再看一下执行计划 explain select sql_no_cache count(staff_id) from t1 *************************** 1. row *************************** id: 1 select_type: SIMPLE table: t1 type: index possible_keys: NULL key: staff_id key_len: 1 ref: NULL rows: 1023849 Extra: Using index 1 row in set (0.00 sec) possible_key: NULL，说明没有WHERE条件时查询优化器无法通过索引检索数据，这里使用了索引的另外一个优点，即从索引中获取数据，减少了读取的数据块的数量。 无where条件的查询，可以通过索引来实现索引覆盖查询，但前提条件是，查询返回的字段数足够少，更不用说select *之类的了。毕竟，建立key length过长的索引，始终不是一件好事情。
查询消耗 从时间上看，小了0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44ffd6647ca796365c5509bf410cdcab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71ed2a4294f570b7936fc66d340c3a40/" rel="bookmark">
			北大学生控诉字节跳动backup制度，怎么破解职场pua？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5月13日下午，一名北大学生在校内论坛未名BBS上写下4000多字长文，陈述自己在字节跳动实习的经历。
该同学表示，2021年1月份在字节跳动办理实习生入职，四月中旬实习期已满，且因毕业事宜繁忙向leader表达了近期需要离职的诉求，但竟遭遇字节独创的backup制度，即leader以没有继任入职无法交接为由让她继续工作兼找继任，而后因找不到合适的工作接替者，被上级领导禁批离职申请和薪资证明。
请问在字节工作签的是合约，还是包身工那样的卖身契？？？
该用户还表示，同时遭leader语言暴力“你的工作能力太差，找两个backup是为了弥补你工作的缺陷”“别人都能做到的你就是做不到”。
当事女生忍无可忍、无须再忍，在律师的帮助和鼓励之下，她在5月13日直接跟HR部门最后摊牌，在暗示所有聊天记录都是证据后，当班HR迅速的把能管事的小领导和HR领导都拉入群聊。
法律不是挡箭牌，用起来却真的好用。再暗示要诉诸法律之后，仅仅过了一刻钟，该女生的离职申请和该拿的实习工资等，全部审批通过。看来字节跳动的HR们，不是不懂法律，而是专门找不懂法律的实习生软柿子捏，欺人太甚！
对此，字节跳动企业纪律与职业道德委员会在内部回应称，已经第一时间与当事人取得联系，进行调查核实，并称，“很遗憾在即将结束实习的这段时间，这名同学在公司遇到了不好的体验。我们会继续推进调查，形成最终调查结论后，将第一时间向当事人和各位同学同步”。
字节跳动方面表示，公司制度和规定中，从未有过、也绝不会有任何形式的“无继任者禁止离职”要求。
这场事件也算告一段落，关注高校俱乐部的小伙伴，有不少还是学生，也有不少是初出茅庐的职场新人，如果有碰到类似的问题，记住一定要用法律作为保护自己的武器，千万不要听信HR的一派胡言，自乱阵脚，最后受伤的只会是自己。
其实，职场pua早已不是新鲜事，让你长期超负荷的工作，996是福报，苦一点累一点都是应该的，想苦想累却没机会的人一抓一大把，所以赶紧收起你的“矫情”。这些都是职场PUA的惯常操作。“职场PUA”隐蔽性强，危害较深，许多职场新人，甚至职场“社畜”深陷其中而不自知。
希望字节跳动能从这件事中“吃一堑长一智”，如今的95后已经不吃pua那套了。其实“小厂”pua事件更普遍，除开这件事，互联网大厂的薪资待遇诱人、晋升路径清晰、用人管理规范，进大厂拿高薪是很多小伙伴的梦想~
具体来说，想进大厂拿高薪的小伙伴应如何更好地“刷新”自己技能呢？大家先来看看小编对包括字节跳动在内5家互联网大厂前端开发工程师招聘JD的解读。
从上图的JD解读可以看出，最核心的就是精通html+js+css语言，然后在此基础上配备其他技能。但大家往往会遇到一个问题：自己掌握的程语言能力还不能够匹配上大厂的标准。
在我看来，造成这种情况的原因，主要有这么两方面：
1.没有清晰的学习路径，知识碎片化，不成系统。
2.缺乏如编程能力，编程思想，算法能力，架构能力胜任。
为了让大家少走弯路，小编针对大厂面试中前端常见问题做出了一系列全面整理，包含JS正则表达式、markdown语法和前端面试题精选等内容，让小伙伴们先将主要的应用方向知识点都了解、学习一遍，从而建立编程思维、扎实编程能力，确定学习路径建立完整的知识框架。
扫码添加小助手获取
以上根据C认证核心知识点，系统整理CSDN点击破万，收藏过千的硬核干货文章合集，每日分享至群内，汇集成系统性知识库，帮助大家自主学习~
百万知识库等你领取！ 目前已梳理Python知识库600篇、java知识库600篇、前端知识库600篇，it软件工程师基础能力500篇，既包含小白+1的基础能力学习，也包含进大厂需要拥有的项目能力学习教程。知识库持续更新中，欢迎加入我们一起学习吧！
C站知识库覆盖以下知识点，每日更新中，欢迎进群一起系统学习！
部分资料预览：
资料太多，无法一一截图，欢迎大家添加老师领取哟~
扫码领取，备注：百万知识库
下图是C站（CSDN）软件工程师能力认证标准中的C1/C4-能力认证图，分为基础能力和项目能力两大模块，可以看到模块中的技能点能够全覆盖一线大厂前端开发工程师的招聘JD要求。
通过以上，大家可以清晰地看到大厂招聘要求与能力认证一一对应、紧密相连。
C站（CSDN）软件工程师能力认证，已上线74天，覆盖全国高校300+，C认证清晰定义了软件工程师的能力，能够夯实软件开发核心技术，掌握企业级开发框架，吃透分布式架构，玩转微服务架构，搞定性能调优，完全胜任编程能力，编程思想，算法能力，架构能力。C站期待更多小伙伴们通过认证，进大厂挑大梁拿高薪！
通过提供免费训练，在训练过程中采用基于“明确路径+领取任务+刻意练习+大咖指导”的学习模型，让学员提升自我能力，满足大厂招聘要求！
认证官网：https://ac.csdn.net/
最后是广告时间，CSDN软件工程师能力认证（以下简称C系列认证）是由中国软件开发者网CSDN制定并推出的一个能力认证标准。C系列认证历经近一年的实际线下调研、考察、迭代、测试，并梳理出软件工程师开发过程中所需的各项技术技能，结合企业招聘需求和人才应聘痛点，基于公开、透明、公正的原则，甑别人才时确保真实业务场景、全部上机实操、所有过程留痕、存档不可篡改。
C系列认证步骤：
1.打开官网（https://ac.csdn.net/），预约认证，报名成功。
2.扫描下方二维码，进群领取学习资料和学习任务，群内还有任务直播讲解以及答疑，一起来记录自己的成长过程吧~
预约后可进入C认证任务小组
小组内有：
1、C认证每阶段学习资料
2、C认证每阶段实践任务，完成后还可收获合作企业赞助奖学金红包！
3、任务直播讲解以及大咖答疑
4、每天更新系统化的干货文章合集，汇集成系统性知识库，帮助大家自主学习
快快添加小助手，一起来记录自己的成长过程吧~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23e76dea5d416234e51f0bc016f3ac28/" rel="bookmark">
			分割字符串c语言strsep,C语言 字符串切割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include #include #include /* 字符串切割函数 */
/*
知识补充:
1. 函数原型:
char *strtok(char *str, const char *delim);
char *strsep(char **stringp, const char *delim);
2. 功能:
strtok和strsep两个函数的功能都是用来分解字符串为一组字符串。str为要分解的字符串，delim为分隔符字符串。
3. 参数说明:
str(stringp)要求不可以是 const char *，因为 strtok 或者 strsep 都会修改 str 的值(修改指针的值)
delim 可以多个字符的集合，strtok(strsep)会按单个字符切割子串
4. 返回值:
从str开头开始的第一个子串，当没有分割的子串时返回NULL。
5. 相同点:
两者都会改变源字符串，想要避免，可以使用strdupa(由allocate函数实现)或strdup(由malloc函数实现)。
6. 不同点:
a. strtok函数第一次调用时会把s字符串中所有在delim中出现的字符替换为NULL。然后通过依次调用strtok(NULL, delim)得到各部分子串。
b. strsep函数第一次调用时会把s字符串中所有在delim中出现的字符替换为'\0'。然后通过依次调用strtok(stringp, delim)得到各部分子串。
c. strsep在切割字符串的过程中，可能多次返回空字符串('\0')，但是 strtok 只会在结束时才返回 NULL
d. strtok 内部记录上次调用字符串的位置，所以不支持多线程，可重入版本为strtok_r
e. strsep支持多线程
*/
void test()
{
char p[] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23e76dea5d416234e51f0bc016f3ac28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4717e56f99c79d45863b624f3af79444/" rel="bookmark">
			c编写linux cp,C 语言实现Linux cp 命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux cp 命令用来将一个或多个源文件或者目录复制到指定的目的文件或目录。小编今天介绍的项目课程就是教你用C语言来实现这个Linux cp命令，对C语言学习者来说是非常不错的练手项目。
项目名称：
【C 语言实现Linux cp 命令】
项目简介：
该项目通过完成C 语言实现Linux cp 命令，掌握Linux操作系统中的文件IO相关的系统函数和目录相关操作的系统函数，比如open, write, opendir, readir。深入了解Linux环境系统编程。
涉及知识点：
Linux cp 命令的用法。
系统调用 open, opendir 函数的使用
系统调用 careat 函数的使用
系统调用 read, readdir 函数的使用
系统调用 write 函数的使用
系统调用 close 函数的使用
系统调用 open 函数的使用
系统调用 link, symlink 函数的使用
函数 getopt 的使用
C 语言字符串处理
项目主要分三步完成：
设计主函数 main 的流程；
设计基本文件拷贝函数 copyF2F；
设计目录拷贝函数 copyD2D；
效果截图：
关于该项目的详细开发流程以及代码详解，点击最下方的“阅读原文”，即可马上查看了~
在线开发环境：
项目学习怎能少动手！！实验楼给每个学习者都提供了在线的开发环境，可以跟着教程随时动手操作，边看教程边写代码，高效快速的掌握的项目开发！
在线开发环境示意图
点击“阅读原文”，即可查看如何用C语言实现Linux cp命令~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbefe6f35a21a2cf67e302eb9c4fbe44/" rel="bookmark">
			C&#43;&#43;将一个cpp文件中的变量应用到另一个cpp文件中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情况说明：有两个cpp文件 ： A.cpp B.cpp 头文件为 A.h B.h
其中A.cpp中定义了一个函数void a()，该函数生成一个变量C，现在要将C的值在B.cpp中使用。
方法1：在A.cpp中将C声明成全局变量，然后在B.cpp中先用extern type C先声明，然后调用。如使用cout&lt;&lt;C&lt;&lt;endl; 可用输出此时C的值。
方法2：在A.h中声明extern type C，然后在B.cpp中#include “A.h”，这样就可以在B中使用变量C了。
————————————————
版权声明：本文为CSDN博主「公子恒」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_27942333/article/details/84719737
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9a6cb5da208a7e5b84d04c1d7af572d/" rel="bookmark">
			if和assert的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		if()和assert区别
1.1、从本质上来说
assert是断言函数，是程序所提供的一个函数。
if则是一个关键字
1.2从语义上来讲
在debug模式下，assert(条件1),若条件一不满足，则会终止程序的向下执行。帮助程序员可以定位错误，在大多数情况下，可以节省程序员查错的时间。在release模式下，它不会做任何操作。
if()条件，即是一个判断语句，无论是在调试模式下或者发行版本下，if(条件2)语句都会对条件2进行判断，满足就执行其后的语句，不满足的话就不执行。
1.3在使用方面
assert()是对我们程序的一种合法性(有效性)的判断。通常用于debug模式下。
if()为条件判断，通常根据条件的正确性(区别于有效性)来确定程序的正常执行与否。
二、ifndef和#pragma once
3.1#ifndef 的方式依赖于宏名字不能冲突，这不光可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件不会被不小心同时包含。当然，缺点就是如果不同头文件的宏名不小心"撞车"，可能就会导致头文件明明存在，编译器却硬说找不到声明的状况
#pragma once则由编译器提供保证：同一个文件不会被包含多次。注意这里所说的"同一个文件"是指物理上的一个文件，而不是指内容相同的两个文件。带来的好处 是，你不必再费劲想个宏名了，当然也就不会出现宏名碰撞引发的奇怪问题。对应的缺点就是如果某个头文件有多份拷贝，本方法不能保证他们不被重复包含。当 然，相比宏名碰撞引发的"找不到声明"的问题，重复包含更容易被发现并修正。
方式一由语言支持所以移植性好（因为pragma once 为微软提出的，所以移植性较差），方式二 可以避免名字冲突（但在一定程度上可以避免宏定义冲突问题）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed1dd8783bcbe1c0345e3c716d4c0cb3/" rel="bookmark">
			用户行为分析埋点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用户行为分析系统是指由第三方提供的集合了数据采集SDK、数据分析模型、分布式算法与存储架构的用户属性与行为事件数据分析的系统。比如国外MixPanel、Heap等，用户行为数据分析的前提是在前期埋点时打好扎实的基础。
事件触发的条件、需要追踪的属性以及想要分析的维度，这些核心分析要素设置的好坏，将会直接影响到你在分析时的体验。错误的埋点触发条件，混乱的属性名设置，以及重要属性的遗漏，都会影响分析的效率与准确性。糟糕的埋点往往在完备性和易理解性两个方面存在不足。
完备性指的是事件与属性的设置能够完全实现数据分析的需求；易理解性指的是所有相关人员能够快速清晰地理解每个事件及属性的意义。
那么如何构建完备、易理解的数据埋点方案呢？以手游的数据埋点为例。
一、保障数据埋点的完备性
1、以规整清晰地格式记录的埋点方案
使用文档来记录埋点方案，是相当好的使用习惯，但如果在记录时结构不够系统，内容过于杂乱的话，那么文档的作用将会大打折扣。建议在构建文档时注意结构的规整以及内容的清晰，可以按照网舟科技建议的如下格式来构建埋点文档：
字段说明：
是否完成：如果项目十分庞大，且版本迭代频繁，那么有必要在文档中记录哪些事件是已经完成、哪些事件还在埋点中、哪些玩法尚未上线，这对于了解项目进度会很有帮助。
所属模块：建议按照游戏的系统与玩法模块来进行埋点。
事件名：埋点时使用的事件名。
事件中文名：事件的中文名，应和后台设置的映射名一致。
事件描述：对该事件的描述，补充解释事件的意义。
触发条件：埋点触发的条件，对于理解事件的意义很有帮助，也可以帮助使用者排查埋点是否正确。
重要程度：用来标识该事件的重要程度，对于庞大项目来说，优先级的标识会很有帮助。
属性描述：用以描述该事件的属性，可以按照需求加入或删除某些字段。
属性名：埋点时使用的属性名。
属性中文名：属性的中文名，应和后台设置的映射名一致。
属性类型：属性的类型，有需求可以添加。
属性描述：对属性的描述，可以写下诸如取值的枚举、易混淆属性的解释以及难理解属性的说明等。
以上的格式是推荐示例，可以根据实际情况进行修改。请注意，进行文档记录的核心目的是将有价值的信息规整地汇总起来，以便项目成员的理解、沟通和分析，在进行文档记录时要牢记这一点。
2、按照系统、玩法模块进行埋点
在上一小节中提到了根据模块来设置埋点的思路，这么做的好处在于两点：一是可以避免埋点的遗漏，对于玩法复杂、系统庞大的项目而言，能够帮助快速理清思路；二是对于同一模块的多个事件，一些属性实际上是通用的，因此在设计埋点的时候，应该将这些事件设置为同一个属性，根据模块设计埋点可以很好让你发掘哪些属性可以被多个事件共用。
3、将重要的属性设置为公共属性
当你需要分析多个事件时，可以根据这些事件共有的属性，也就是这些事件的属性交集，作为维度进行查看。一个常见的例子是，当你想要进行渠道分析，并且所有的事件都有“渠道”这一属性时，你可以便捷地选择“按渠道维度”进行查看。因此将重要的属性设置在每个事件中就显得相当重要了，如果你使用客户端接入，那么建议你将这些属性设置为公共属性。
如果你根据系统模块来设置埋点，那么应该优先关注那些与KPI相关的属性，诸如渠道、区服等等，像这样的属性，在设置的时候可以不去考虑具体的事件，而只需考虑哪些属性更重要，也就是说就算有些事件中该属性是冗余的、无意义的，也应该将其设置进去。同时如果有新的事件需要追踪，也需要将这些属性添加进去。
4、将所有的改动记录下来
你的游戏随着版本的更新迭代后，一些属性可能会失去作用，同时也会产生新的需要追踪的属性。由于后续的属性变动不会作用到老数据上，因此任何属性上的改动都会导致前后的属性不一致。为了避免增删属性对历史数据的分析造成影响，请将所有的改动都记录在文档中，当某个属性被弃用时，请不要将其从文档中删除，而是通过底色或者字体颜色等方式标注出该字段被弃用。这样能够保证在分析过往数据时，仍能查找到所有属性的意义。 二、确保数据埋点的易理解性
易理解性是一个容易被忽视的设计原则，因为在大多数情况下，对它的忽视并不会阻碍分析的进行。如果我们将不完备的埋点比作堵塞分析道路的巨岩，那么理解困难的埋点只相当于路上的小碎石，然而这种微小问题的累积却会对分析效率产生负面影响，尤其当项目变得越发庞大复杂，其造成的影响也将成倍扩大。使用者可能需要花费大量时间去询问事件及属性的意义，同时还要记下这些含义以防遗忘，这种糟糕体验对于分析的流畅性来说简直是毁灭性的破坏，因此设计埋点时需要考虑埋点的易理解性。
对于易理解性的理想要求是：任何用户可以只通过中文名理解该事件或属性的意义。这一要求可能相对难以达到，但至少要保证用户在少量说明的帮助下能够理解所有的事件及属性。为了达到这点，网舟科技提出如下的优化建议：
1、将所有的属性汇总起来
相较于理解事件的意义，使用者更可能在理解属性意义时犯难，因此埋点的设计者最好将所有的属性汇总起来，便于排查属性设置的问题。可以参考下述给出的建议格式构建你的属性汇总文档：
字段说明：
属性名：埋点时使用的属性名。
属性中文名：属性的中文名，应和后台设置的映射名一致。
属性类型：属性的类型。
属性说明：属性的说明，也可以加入取值的枚举等补充说明。
是否为公共属性：标识该属性是否是公共属性。
建议埋点设计者在项目伊始就进行属性汇总，并且每增加一个埋点，就立刻将所有属性更新到汇总文档中，这么做的好处是可以迅速排查出新埋点的设计是否合理，比如公共属性是否设置、是否有可以合并的属性、属性名是否有重复等等。
2、保持属性意义的独立
建议你将多个事件中具有相同意义的属性进行合并，但需要避免让一个属性在不同的事件中承载不同含义，比如说level在一系列事件中指代“用户等级”，在其它事件中又代表“难度”或“层数”，这样的属性设置使得中文名只能写上所有的含义，而使用者在进行分析时就必须去猜测这个属性到底指的是哪个含义，这就显得相当不便了。
实际上这个问题的本质是不同事件的属性重名，通过属性汇总文档，很容易就可以排查出这一问题，而解决方法也十分简单，只需更改其中一个事件中的属性名即可。
如果你的项目比较庞大，很容易频繁出现重名的情况，可以在这些属性名前加入模块或者事件的名称，比如misson_type，weapon_name，product_id等，即可有效避免属性重名。
3、属性的类型最好与实际操作相匹配
大多数情况下，属性的类型不会对理解产生太大的困扰，但仍有可能出现这样的情况：使用数值型来表示布尔值时，可以使用0与1、1与2或者-1与1等多种方式来指代“真”与“假”，对于使用者而言，需要花费时间确认项目中使用的是哪种方法，另外还有可能出现同时使用两种方法的情况，使用者的理解成本又会因此上升，所以最好直接设置成布尔型。另外，对于诸如“商品ID”“关卡ID”等以数字表示但无计算需求的属性，建议你将这些属性设置成字符串型。这是因为属性的类型决定了其在分析时可进行的操作，不同类型可进行不同的操作，这样设置既避免了无意义操作，比如计算“关卡ID”的总和，同时增加了有意义的操作，比如使用正则表达式查找“道具ID”。
综上所述，建议你根据属性的实际意义以及具体的操作来设置类型，布尔型优先使用布尔型，需要进行计算的使用数值型，不需要进行计算的设置为字符串型。
4、属性值能用中文尽量用中文
对于可以用中文来表示的属性，建议尽可能地直接使用中文，比如描述用户购买的商品，你可以使用数字为主的“商品ID”去指代，也可以使用中文的“商品名”去表示，这种情况下推荐使用中文的“商品名”表示。直接使用中文属性值，使用者在分析的时可以不需要查表，即可了解属性值的意义。请注意，中文请使用UTF-8进行编码。
在构建了完备、清晰的埋点方案与记录文档后，借助网舟科技用户行为分析系统，可以打通APP、小程序、网站等的用户行为数据，快速的进行用户分群、用户事件、留存、漏斗、行为序列等分析，从数据中挖掘能够推动用户快速增长的有效策略。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/965e106beee98076fca01e1d7339338d/" rel="bookmark">
			如何在PC端快速下载B站视频，不是唧唧Down，学不会来打我！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如何在PC端快速下载B站视频，亲测可用 学不会来打我！！！ 哔哩哔哩如今已经从开始小众网站，慢慢进入了越来越多的人的视野和生活中。现在除了看动漫，我们还可以在上面看纪录片、电影、连续剧、科普、以及各种学习资源等！百度了几种方法，感觉都不太好，今天，推荐一个超级好用的在PC端快速下载b站视频的方法，不是唧唧Down
学不会来打我！！ 第一步：安装星愿浏览器
第二步：直接搜索哔哩哔哩
第三步：下载你喜欢的视频
第五步：打开视频所在目录 就可以观看了 哈哈哈哈
这是下载好的视频 超级清晰
最后，你学会了嘛！学不会来打我！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80324bf86bf934c431c38f7ca92a56d4/" rel="bookmark">
			PICT工具算法图解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章已经对PICT工具的基本获取以及使用做了介绍,本文将介绍PICT工具的核心生成用例的算法
文章目录 PICT工具算法思想图解演示 PICT工具算法思想 PICT工具在生成测试用例时,使用的是启发式算法(greedy heuristic),此算法的主要思想就是用精度换复杂度,应用到PICT工具上就是 在每次生成用例时候会在相对较快的时间生成相对精简的用例(注意,不是最精简的),换句话说 就是生成用例的条数可能不是最少的(可能不是最优解).
对于工具生成用例的流程,主要分为两大步骤,组合与生成
即先将参数进行正交组合(根据用户配置的组合维度,默认是两两组合),然后根据每种组合进行生成用例. 下图是PICT生成用例部分的算法伪代码:
这个伪代码看起来比较生硬,如果在不了解PICT内部基本运行流程的情况下之间来看这个伪代码,会比较吃力.接下来我会图解演示这个伪代码的执行流程.在看完图解演示后回看这个伪代码,可能就会理解了.
图解演示 假设我们有如下的入参列表:
A01-B234C567 为方便起见,我们对这些参数不添加任何的约束条件.
首先我们先将A B C三个入参两两组合,分别为AB,AC,BC 对于这三个组合的可能值如下:
在组合好后,AB列与AC列均为6种组合,BC列有9种组合.对于每一个组合,PICT工具会将其分为三种状态 覆盖,未覆盖,被约束,由于我们此次演示不写入任何约束条件,所以对于所有的组合只有 覆盖和未覆盖两种状态.在最初状态,所有组合均为未覆盖状态.
根据PICT中算法的思想,先从拥有未覆盖组合最多的列随机选择一个组合用于生成用例(同优先级的情况下随机选择一个组合).
为了演示方便,我们此处使用优先左上的原则来填入(同优先级的情况下选择最左上的组合).
因此我们首先选择BC=25填入生成列表,并将这个组合标记为已覆盖(黄颜色背景):
在填入之后,就限定了当前用例的B=2,C=5.因此,我们需要在AB,AC列中找出满足这两个条件的所有组合:
AB=02,12 AC=05,15
根据同优先级左上优先的原则,我们填入AB = 02,在填A=0后,此用例也满足AC=05,因此将这个组合也标记为覆盖.
第1条用例 0,2,5 生成了.
接下来重复上面步骤,找出拥有包含未覆盖组合最多的列.目前还是BC中最多,选择BC=26填入生成列表中,并将其标记为覆盖.
然后从AB,AC中寻找满足BC=26的未覆盖组合,分别为: AB=12,BC=06,16. 如果填入AB=12,可以外覆盖AC=16,填入AC = 06,则无法额外覆盖其他组合,因此优先级比填入 AB=12,AC=16低,根据左上优先选择,我们填入AB=12来生成用例,并且额外覆盖了AC=16:
第2条用例 1,2,6 生成了.
继续重复上面步骤,从BC中选择BC=27填入,并将其标记为覆盖:
AB,AC中满足BC=27的未覆盖组合为 AC=07,17 而这两个填入后均无法额外覆盖其他组合,所以优先级一致,根据左上原则,我们填入AC=07,并将其标记为覆盖:
第3条用例 0,2,7 生成了.
继续重复,填入BC=35,并将其标为已覆盖:
AB,AC中满足BC=35的分别为 AB=03,13 BC=15 而只有填入AB=13可达到额外覆盖其他组合(AC=15),所以填入AB=13,并将所覆盖的标记为已覆盖:
第4条用例 1,3,5 生成了.
接下来重复上面步骤,填入BC=36,并将其标为覆盖:
AB,AC中满足BC=36的为AB=03,AC=06,而这两个随便填入一个都可以将对方覆盖,所以我们选择AB=03填入,并将所覆盖的标记为已覆盖:
第5条用例 0,3,6 生成了.
重复上述步骤,选择BC=37填入,将其标记为覆盖:
此时AB,AC的未覆盖组合中,只有AC=17满足此条件,所以填入AC=17
第6条用例 1,3,7 生成了.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80324bf86bf934c431c38f7ca92a56d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdcd1f0a90fad741e6fbd73f767b6e7f/" rel="bookmark">
			PICT用例设计工具介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PICT用例设计工具介绍 本文对PICT工具的描述以及基本使用做出介绍
文章目录 PICT用例设计工具介绍0.成对测试1.PICT工具获取2.PICT工具基本功能使用2.1 基本使用2.2 添加约束 4.总结 0.成对测试 在我们进行接口测试时,如果遇到一些入参规模比较庞大的接口,通常会采用等价类划分法和边界值分析法来减小测试用例的规模. 但是当被测接口会被多个入参因子共同影响时,使用穷举测试依旧会造成测试用例过于庞大的问题. 而成对测试的思想可以有效的解决测试用例规模过大的问题.
成对测试主要是将多个入参因子进行两两正交,得到测试用例集合.可以保证不同入参的任意两个因子能同时包含在一个用例里边.
根据统计研究发现,两两正交生成的测试用例,可以发现70%以上的bug.三三正交可以发现90%以上的bug.
对于本文所要讲述的PICT工具,正是基于成对测试的思想,用来设计测试用例的工具.
1.PICT工具获取 PICT是微软开源的用例设计工具,使用C++编写. git地址为:
https://github.com/microsoft/pict 可以将其下载下来编译后生成pict工具.此工具支持在Windows/Linux环境下进行编译
Linux 下安装g++等编译工具在代码根目录执行 make指令即可编译Windows 下运行根目录下执行编译的bat脚本即可 在此本文使用Linux下来编译此工具:
框住的即是编译处的PICT工具
2.PICT工具基本功能使用 2.1 基本使用 比如我们设定如下几个入参类型以及对应的值:
NameGenderAgeHightPhoneTonymale20160appleMacfemale30170samsungJohn40180huaweiLucy50xiaomiMarryoppovivo 我们要新建一个txt,讲这些值写入:
Name:Tony,Mac,John,Lucy,Marry Gender:male,female Age:20,30,40,50 Hight:160,170,180 Phone:apple,samsung,huawei,xiaomi,oppo,vivo 基本的格式为:
入参类型:入参因子1,入参因子2,... # 注意入参类型与因子之间用":"隔开,因子与因子间用","隔开 编写好后将其保存为txt文件,在此我将其保存为"test.txt",之后运行pict工具:
会得到如上的结果,我们可以从里边找出包含任意两个不同类型参数的因子的组合的用例.
2.2 添加约束 从上面生成的测试用例中,我们会发现其实有些是不合逻辑的,比如 Marry 是一个女性的名字,但是有些用例会将其生成为男性(male),或者John是男性名字,但有用例将其生成为女性.
如果我们手动删掉这些不合理的用例,是万万不可行的.因为这些所谓"不合理"的用例,里边可能包含了其他的两两组合,如果直接手动删掉,会导致漏测的风险
比如上面生成的第3条用例,Mac对应的是female,40岁,170身高,使用samsung. 假如在这个接口中Mac + samsung会导致一个bug出来,而我们手动删掉这条后,就会造成此bug没有被查出.
所以我们需要手动在txt中添加约束来规范化这些用例,假设我们添加如下几个约束:
姓名为 Tony,Mac,John 均为男性姓名为 Lucy,Marry 均为女性女性身高 &lt; 170 (拳师们手下留情,只是随便举一个不恰当的例子来演示此工具)使用apple的年龄 &lt; 40 那么对应的test.txt需要改为这样:
Name:Tony,Mac,John,Lucy,Marry Gender:male,female Age:20,30,40,50 Hight:160,170,180 Phone:apple,samsung,huawei,xiaomi,oppo,vivo IF [Gender] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdcd1f0a90fad741e6fbd73f767b6e7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a90fae357b11b0d718865898459b03f/" rel="bookmark">
			Git版本回退的两种方式及回退方式推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 综述背景说明查看提交历史1 格式化2 筛选检索3 最近提交 版本回退1 `reset`方法回退2 `revert`方法回退 恢复回退 综述 本文档主要用于详细说明如何使用Git进行版本回退，主要包含四个方面：
背景说明查看提交历史版本回退恢复回退 背景说明 在使用git版本控制进行开发的过程中，我们有时会出现错误提交的情况，存在误提交的时候怎么办呢？，此时我们希望能撤销提交操作，让程序回到提交前的样子，本文总结了两种解决方法：reset复位、revert恢复。
查看提交历史 在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是git log命令。
git log如果不带任何参数，它会列出所有历史记录，最近的排在最上方，显示提交对象的哈希值(commit id)，作者、提交日期、和提交说明。如果记录过多，则按Page Up、Page Down、↓、↑来控制显示；按Q退出历史记录列表。
查看git log命令文档
下面介绍几种常用的git log使用方式：
1 格式化 如果想获取每条日志的简要信息，可以使用git log --pretty=oneline，精简一行显示；
如果想在查看的时候只显示简略的commit id，那么可以使用git log --abbrev-commit；
如果想在查看的时候想获取全部基本信息，可以使用git log --pretty=full，这也是默认的形式。因此直接使用git log也可以；
如果想获取更详细的信息，使用git log --pretty=fuller;
如果想查看带图形的日志使用git log --graph;
定制记录的显示格式显示使用git log --pretty=format:"%h - %an, %ar : %s"；点击查看常用格式选项
--pretty这个选项可以使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。比如oneline会将每个提交放在一行显示，在浏览大量的提交时非常有用。 另外还有short，full和fuller选项，它们展示信息的格式基本一致，但是详尽程度不一。
2 筛选检索 支持通过作者来查询git log --auther='作者名'；
支持时间，--after、--before，after在某个时间点后；before在某个时间点前git log --before='2021-03-12 12:29:29'；
支持时间区间，各个条件之间是与的关系，可以联合使用；
3 最近提交 直接使用git log -n查看即可，n为一个具体数字，前n条，可省略，省略则分页展示全部；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a90fae357b11b0d718865898459b03f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/098b2fe14db13469187e9b57c2b8722d/" rel="bookmark">
			docker部署sentinel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker run --name sentinel -d --restart=always -p 8080:8858 -d bladex/sentinel-dashboard:1.8.0 登录名与密码：sentinel/sentinel
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b557cc22fe0449a103649c68226ca85e/" rel="bookmark">
			linux图书管理系统,C语言——图书管理系统（Linux版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include"stdio.h"
#include"stdlib.h"
#include"string.h"
#define N 20
#define T sizeof(struct book)
#define SC "%ld %s %s %s %s
%d",&amp;p1-&gt;num,p1-&gt;name,p1-&gt;author,p1-&gt;kind,p1-&gt;press,&amp;p1-&gt;quantity
#define PR11
"\033[30;42m%-8ld\033[47m%-16s\033[42m%-16s\033[47m%-16s\033[42m%-16s\033[47m%-8d\033[0m\n",p-&gt;num,p-&gt;name,p-&gt;author,p-&gt;kind,p-&gt;press,p-&gt;quantity
#define PR21
"\033[30;47m%-8ld\033[42m%-16s\033[47m%-16s\033[42m%-16s\033[47m%-16s\033[42m%-8d\033[0m\n",p-&gt;num,p-&gt;name,p-&gt;author,p-&gt;kind,p-&gt;press,p-&gt;quantity
#define PR12
"\033[30;42m%-8ld\033[47m%-16s\033[42m%-16s\033[47m%-16s\033[42m%-16s\033[41m%-8d\033[0m\n",p-&gt;num,p-&gt;name,p-&gt;author,p-&gt;kind,p-&gt;press,p-&gt;quantity
#define PR22
"\033[30;47m%-8ld\033[42m%-16s\033[47m%-16s\033[42m%-16s\033[47m%-16s\033[41m%-8d\033[0m\n",p-&gt;num,p-&gt;name,p-&gt;author,p-&gt;kind,p-&gt;press,p-&gt;quantity
#define PR "\033[30;43mnumber name author kind press quantity\033[0m\n"
int password()//----------------------密码系统
{ int i;
char zh[9],ZH[9]="123456",mm[7],MM[7]="123456";
printf("\t\t\t\t\t\t\t\033[33m请输入帐号：");
scanf("%s",zh);
printf("\n\033[0m");
while(strcmp(zh,ZH)!=0)
{ printf("\t\t\t\t\t\t\t\033[31m您的输入错误，没有该帐号！请重输！\033[0m\n\n");
printf("\t\t\t\t\t\t\t\033[33m请再次输入帐号：");
scanf("%s",zh);
printf("\n\033[0m");
}
printf("\t\t\t\t\t\t\t\033[33m请输入密码：");
system("stty -echo");
scanf("%s",mm);
system("stty echo");
printf("******\n\n\033[0m");
for(i=0;i&lt;7;i++)
{ if(strcmp(mm,MM)==0)
{ printf("\t\t\t\t\t\t \033[32m欢迎进入该系统！按"Enter"键进入！\033[0m\n");
return 0;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b557cc22fe0449a103649c68226ca85e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eb1a54db57ba35b0669fba681379354/" rel="bookmark">
			linux为什么重启网络失败怎么办,centos系统重启网络失败怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境：centos7系统
问题描述：[root@localhost Desktop]# systemctl start network.service
Job for network.service failed. See 'systemctl status network.service' and 'journalctl -xn' for details.
解决方法：
1、HWADDR错误 ，查到正确的HWADDR
输入 ip addr，查找到HWADDR
进入 cd /etc/sysconfig/network-scripts 目录编辑对应的 vim ifcfg-ensXX，将HWADDR设置正确，重启service network restart
如果到这还是不行，那么需要重新设置下IP。
2、IP检查及设置
进入主机cmd 命令窗口 ，输入 ipconfig /all
再进入centos7虚拟机 cd /etc/sysconfig/network-scripts 目录编辑对应的 vim ifcfg-ensXX
然后关闭网络：root@localhost Desktop]# service NetworkManager stop
Redirecting to /bin/systemctl stop NetworkManager.service
再重启：[root@localhost Desktop]# service network restart
Restarting network (via systemctl): [ OK ]
相关视频教程推荐：linux视频教程
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/81/">«</a>
	<span class="pagination__item pagination__item--current">82/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/83/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>