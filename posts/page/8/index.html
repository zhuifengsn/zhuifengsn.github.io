<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e137fdb16f297a65c26a3fb63cc86340/" rel="bookmark">
			云原生高级第一次作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
实验需求：
第一个实验步骤：
openEuler 二进制方式安装MySQL 8.0.x
1.首先需要获取软件包
2.然后安装tar和xz格式可进行解压工具
3.接下来就是安装MySQL
4.配置环境变量
5.登入并修改密码
6.停止服务脚本
7.提供配置文件
8.进入/etc/my.cnf进行配置
9.重启mysql以及验证
第二个实验步骤：
备份数据库，备份数据库school到/backup目录
1.创建一个数据库，并插入一些数据
2.备份数据库school到/backup目录
第三个实验步骤：
备份MySQL数据库为带删除表的格式，能够让该备份覆盖已有数据库而不需要手动删除原有数据库
第四个实验步骤：
直接将MySQL数据库压缩备份
实验需求： 1、openEuler 二进制方式安装MySQL 8.0.x。
2、备份数据库
3、备份数据库school到/backup目录
4、备份MySQL数据库为带删除表的格式，能够让该备份覆盖已有数据库而不需要手动删除原有数据库
5、直接将MySQL数据库压缩备份
第一个实验步骤： openEuler 二进制方式安装MySQL 8.0.x 1.首先需要获取软件包 [root@localhost ~]# wget -c https://mirrors.aliyun.com/mysql/MySQL-8.0/mysql-8.0.28-linux-glibc2.12-x86_64.tar.xz
2.然后安装tar和xz格式可进行解压工具 [root@localhost ~]# dnf install tar xz -y
看到Complete!就安装成功
3.接下来就是安装MySQL [root@localhost ~]# groupadd -g 27 -r mysql #增加组
[root@localhost ~]# useradd -u 27 -g 27 -c 'MySQL Server' -r -s /sbin/nologin mysql #增加用户
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e137fdb16f297a65c26a3fb63cc86340/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/019cbdea4361b0615ff39466154a97c2/" rel="bookmark">
			Excel之index、MATCH面试题、VLOOKUP函数，
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VLOOKUP() 在表格的首列查找指定的数值，并返回表格当前行中指定列处的数值。
结构：=VLOOKUP(查找值,查找区域,列序数,匹配条件)
解释：=VLOOKUP(找谁,在哪里找,第几列,0或1)
1.目的：根据【产品】查找【销量】
公式：=VLOOKUP(E2,$B$1:$C$11,2,0)
说明：“查找值”E2也就是【产品】，“查找区域”根据查找值【产品】在所选的数据表中，也就是$B$1:$C$11中必须位于第一列。“列序数”为3，表示对应结果【销量】在所选区域中排第3列；“匹配条件”为0，表示精确匹配，若为1则代表近似匹配。
2.目的：根据【产品】查找【日期】
公式：=VLOOKUP(E2,$B$1:$D$11,3,0)
说明：“查找值”G2也就是【产品】，由于数据表中【产品】列在【日期】列的后面，无法按照VLOOKUP函数的使用方法（查找区域要根据查找值位于第一列进行）所以我们要将【产品】排列在数据表中的第一列，则增加一列【辅助列】代表【日期】列，数据表所选区域也就是$B$1:$D$11区域。“列序数”为3，表示对应结果【辅助列】在所选区域中排第3列；“匹配条件”为0，表示精确匹配
=VLOOKUP(E2,$B$1:$D$11,3,0)
VLookup():用于从一列或一行或数组中查找一个值。
“=VLOOKUP(A14,A1:A11,B1:B11)”获得了第一个进价。这个公式里有三个参数，值如下：
第一个参数“Lookup_value”：A14，是要查找的值；第二个参数“lookup_vector”：A1:A11，是要查找的范围；第三个参数“Result_vector”：B1:B11，是要获得的值。 index函数 Index函数：根据数据区域中的行列号返回区域中对应的值
INDEX(array, row_num, [column_num])
第1参数：要查找的单元格区域；第2参数：返回单元格区域的某行；第3参数：返回单元格区域的某列； match函数 语法：=MATCH(lookup_value, lookup_array, [match_type])
第一参数：查找值第二参数：查找的数据区域第三参数：匹配类型，在这里我们将其设置为0即可，表示精确匹配 INDEX和MATCH结合使用
=INDEX($G$2:$G$5,MATCH(C2,$F$2:$F$5,1))
countif():在指定区域中按指定的条件对单元格进行计数
=countif（range，criteria）
参数意义：
参数range：表示要计算其中满足条件的非空单元格数目的单元格区域；参数criteria：表示统计条件，其条件的形式可以为数字、表达式或文本，也可以使用通配符。 统计空白单元格
COUNTBLANK函数是计算区域内空白单元格的个数。
COUNTBLANK()
SUMPRODUCT函数：返回相应的数据或区域乘积之和
在列表中计数操作： OFFSET：函数用于返回一个单元格或单元格区域的引用，该引用是相对于另一个单元格或区域的。
OFFSET(reference, rows, cols, [height], [width])
reference 是起始单元格或区域的引用。rows 是从起始单元格或区域开始要偏移的行数（可以是负数，表示向上偏移）。cols 是从起始单元格或区域开始要偏移的列数（可以是负数，表示向左偏移）。[height] 和 [width] 是可选参数，分别表示返回引用区域的高度和宽度。 =SUM(OFFSET(D3,,,,MATCH($B$1,$D$2:$O$2,0)))
通过单独获取累计的操作： SUM(INDEX(D5:O12,MATCH(B15,B5:B12,0),MATCH(B16,D4:O4,0)):INDEX(D5:O12,MATCH(B15,B5:B12,0),MATCH(B17,D4:O4,0)))
解说：
这个Excel公式使用了INDEX和MATCH函数来动态地确定一个范围，并对这个范围内的单元格进行求和。让我们逐步解析这个公式：
MATCH函数:
MATCH(lookup_value, lookup_array, [match_type])
MATCH函数返回lookup_value在lookup_array中的相对位置。match_type参数决定了查找的类型，其中0表示精确匹配。
在你的公式中，有三个MATCH函数：
MATCH(G17,B5:B12,0)：查找G17单元格中的值在B5:B12范围内的位置。MATCH(G18,D4:O4,0)：查找G18单元格中的值在D4:O4范围内的位置（这通常是一个标题行，表示列的标识）。MATCH(G19,D4:O4,0)：查找G19单元格中的值在D4:O4范围内的位置。 INDEX函数:
INDEX(array, row_num, [column_num], [area_num])
INDEX函数返回指定数组中某个单元格的值，该单元格由行号和列号确定。
在你的公式中，有两个INDEX函数：
第一个INDEX函数确定了范围的起始单元格：INDEX(D5:O12,MATCH(G17,B5:B12,0),MATCH(G18,D4:O4,0))。这里，它找到G17在B5:B12中的行号，以及G18在D4:O4中的列号，从而确定了起始单元格。第二个INDEX函数确定了范围的结束单元格：INDEX(D5:O12,MATCH(G17,B5:B12,0),MATCH(G19,D4:O4,0))。与第一个INDEX类似，但它使用G19的值来确定列号，从而确定了结束单元格。 SUM函数:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/019cbdea4361b0615ff39466154a97c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee3ba2621b86f7de9baac5e0920ab5c9/" rel="bookmark">
			C语言翻译环境：预编译&#43;编译&#43;汇编&#43;链接详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
翻译环境和运行环境
翻译环境
预处理（预编译）
编译
词法分析
语法分析
语义分析
汇编
链接
运行环境
⭐翻译环境和运行环境 在ANSI C的任何⼀种实现中，存在两个不同的环境。
第1种是翻译环境，在这个环境中源代码被转换为可执行的机器指令。第2种是运行环境，它用于实际执行代码。 可执行程序中存储的是二进制指令（机器指令）
⭐翻译环境 那翻译环境是怎么将源代码转换为可执行的机器指令的呢？这里我们就得展开开讲解⼀下翻译环境所做的事情。
其实翻译环境是由编译和链接两个大的过程组成的，而编译⼜可以分解成：预处理（有些书也叫预编译）、编译、汇编三个过程。
⼀个C语言的项目中可能有多个.c文件⼀起构建，那多个.c文件如何生成可执行程序呢？
多个.c文件单独经过编译器，编译处理生成对应的目标文件（后缀为.obj）。注：在Windows环境下的目标文件的后缀是.obj，Linux环境下目标文件的后缀是.o多个目标文件和链接库⼀起经过链接器处理生成最终的可执行程序。链接库是指运行时库(它是支持程序运行的基本函数集合)或者第三方库。
如果再把编译器展开成3个过程，那就变成了下面的过程：
🏲预处理（预编译） 在预处理阶段，源文件和头文件会被处理成为.i为后缀的文件。
在(Linux) gcc 环境下想观察一下，对 test.c 文件预处理后的.i 文件，命令如下：
gcc -E test.c -o test.i 预处理阶段主要处理那些源文件中#开始的预编译指令。比如：#include,#define，处理的规则如下：
将所有的#define删除，并展开所有的宏定义。处理所有的条件编译指令，如： #if、#ifdef、#elif、#else、#endif 。处理#include预编译指令，将包含的头文件的内容插入到该预编译指令的位置。这个过程是递归进行的，也就是说被包含的头文也可能包含其他文件。删除所有的注释添加行号和文件名标识，方便后续编译器生成调试信息等。或保留所有的#pragma的编译器指令，编译器后续会使用。 经过预处理后的 .i 文件中不再包含宏定义，因为宏已经被展开（替换）。并且包含的头文件都被插入到 .i 文件中。所以当我们无法知道宏定义或者头文件是否包含正确的时候，可以查看预处理后的 .i 文件来确认。
🏲编译 编译过程就是将预处理后的文件进行⼀系列的：词法分析、语法分析、语义分析及优化，生成相应的汇编代码文件。
编译过程的命令如下：
gcc -S test.i -o test.s
对下面代码进行编译的时候，会怎么做呢？假设有下面的代码
array[index] = (index+4)*(2+6); ⚡词法分析 将源代码程序被输入扫描器，扫描器的任务就是简单的进行词法分析，把代码中的字符分割成⼀系列的记号（关键字、标识符、字⾯量、特殊字符等）。
array[index] = (index+4)*(2+6); 上面程序进行词法分析后得到了16个记号：
记号类型array标识符[左方括号index标识符]右方括号=赋值(左圆括号index标识符+加号4数字)右圆括号*乘号(左圆括号2数字+加号6数字)右圆括号 ⚡语法分析 接下来语法分析器，将对扫描产生的记号进行语法分析，从而产生语法树。这些语法树是以表达式为节点的树。
⚡语义分析 由语义分析器来完成语义分析，即对表达式的语法层⾯分析。编译器所能做的分析是语义的静态分
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee3ba2621b86f7de9baac5e0920ab5c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0eae4e43322047462e2c51d88030856a/" rel="bookmark">
			产品渲染3D效果图一张多少钱，哪个平台更有性价比？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品渲染3D效果图的价格受到多方面因素的影响，包括但不限于产品类型、渲染难度以及输出尺寸等。如果效果图需要后期处理，还有可能增加其他费用。接下来，我们来了解一下产品渲染效果图的费用情况。
1.产品渲染3D效果图一张多少钱？ 从市场上的调查来看，目前渲染产品3D效果图的行情价格在几十元到数千元不等，具体的价格还要根据具体情况而定。如果需要渲染复杂的场景，例如汽车产品，价格可能会大幅增加。
2.效果图渲染平台对比 （1）某宝/某书/个人工作室
也许大家首先会考虑在某宝、某书或个人工作室上寻找适合的代渲染服务。这些平台的费用通常较高，一般50元起步，根据尺寸和数量计算，上不封顶。如果你需要大量产品渲染，选择这种方式很不划算。更何况个人工作室的机器数量有限，如果项目紧急，很难在短时间内完成交付，这就会带来一些不必要的损失。
（2）云渲染农场
云渲染农场是将渲染任务上传到云端服务器，利用高性能计算集群来进行渲染，从而帮助设计师获得更精确、更快速的渲染结果。云渲染农场不仅渲染速度更快，而且价格也更低，性价比很高。
比如蓝海创意云渲染农场蓝海创意云渲染农场https://render-still.vsochina.com/cn能够提供多种渲染模式和计费方式，价格也非常实惠。10分钟内免费渲染，单图渲染封顶低至0.6元，单张渲染10元封顶。而之前我们提到的某宝、某书或个人工作室，50元起步、上不封顶。这一对比，差距立显。
蓝海创意云渲染计费：
除了蓝海创意云外，还有其他一些云渲染平台，比如下面的平台B。他们因为其大平台的热度，也有不少的用户会使用。但由于除了云渲染外，平台B还涉及模型、教程等其他业务，所以在云渲染这一块并不特别重视，性价比并不高。从计费方式、封顶价格到活动优惠等方面来看，与蓝海创意云相比，平台B都没有竞争力。
平台B渲染计费：
蓝海创意云渲染计费和平台B计费对比：
下面是我最近做的各大平台效果图测评对比，其中包括渲染时长和价格，数据一律真实，感兴趣的可以看一看：
云渲染效果图贵吗？哪个云渲染平台更有性价比？https://news.vsochina.com/cn/industry/4853
云渲染年中最新测评！2023最佳云渲染平台揭晓！https://blog.csdn.net/LhcyyVSO/article/details/132410498
综合而言，如果只是需要单一的产品效果图渲染，而且对渲染质量要求不高，完全可以使用个人电脑完成，只是需要耐心等待较长的渲染时间。但是，如果想要将产品效果图与场景一起渲染，并且需要较高的分辨率，那么可以借助“蓝海创意云渲染农场”，帮助大家在短时间内快速得到理想的渲染效果。蓝海创意云渲染农场https://render-still.vsochina.com/cn
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fa14c1ba5a5cde3bc8309ef20bdf15b/" rel="bookmark">
			mysql 数据备份与恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql数据库备份分为物理备份和逻辑备份两种，物理备份指将数据库data下的数据文件进行直接copy备份，逻辑备份指通过备份数据库的逻辑结构和数据。也就是数据库的对象对应的create语句和数据表的insert语句。这里主要说逻辑备份。
dump数据文件（mysqldump） mysqldump [options] db_name [table_name ...] 连接参数： -h, --host=name :指定数据库主机
-P, --port=#：指定连接端口号
-u, --user=name：指定用户名
-p, --password[=name]：指定用户密码
连接参数是必须的，访问数据库数据需要用户认证。host和port如果不指定默认访问本机数据库服务
数据库实例参数 –all-databases：导出所有数据库
mysqldump -uroot -p --all-databases &gt; all.sql 导出所有数据库会包含mysql本身自带的数据库，像mysql、sys、information_schema、performance_schema库。
如果明确导出一个具体的数据库，可以在mysqldump命令行上直接写明数据库名进行导出
mysqldump -uroot -p db_test &gt; db_test.sql 上面的语句就是直接导出db_test数据库。
导出多个数据库
使用–databases指定数据库列表
mysqldump -uroot -proot --databases db_test nacos210 &gt; db_multi.sql 导出db_test和nacos210两个数据库。
导出多个数据库会带有创建数据库的脚本，例如上面语句会有：
CREATE DATABASE /*!32312 IF NOT EXISTS*/ `db_test`; USE `db_test`; 可以添加–add-drop-database参数会在create数据库之前添加drop数据库语句。生成的好像drop语句是被注释的。
表设置参数 指定要备份的表
mysqldump -uroot -p --databases db_test --tables account test &gt; db_tb1.sql –tables后面跟要导出的表列表，这里导出了account和test两个表。当在明确要备份几个表名时使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fa14c1ba5a5cde3bc8309ef20bdf15b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abc76910c7acfb7e50e4184a1080150c/" rel="bookmark">
			设置主从复制时发生报错Could not find first log file name in binary log index file‘；解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如图所示，slave_io_runnind:no,slave_sql_running:yes
此时，主从配置错误，我们可以查看Last_IO_Error:来查看报错信息
此时，我们需要停止从服务器的主从服务，
mysql&gt; stop slave; Query OK, 0 rows affected, 1 warning (0.00 sec) 到master机器登陆mysql：
记录master的bin的位置，例如：
mysql&gt; show master status;
必要时使用flush log;进行刷新
然后。我们到从服务器进行修改
mysql&gt; stop slave; Query OK, 0 rows affected, 1 warning (0.00 sec) mysql&gt; change master to master_log_file='service-bin.000004',master_log_pos=157; Query OK, 0 rows affected, 3 warnings (0.01 sec) mysql&gt; change master to master_host='master1',master_user='rep',master_password='Wyxbuke00.',master_log_file='service-bin.000004'; Query OK, 0 rows affected, 8 warnings (0.02 sec) mysql&gt; start slave; Query OK, 0 rows affected, 1 warning (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abc76910c7acfb7e50e4184a1080150c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95e0929459a46b05ea390d3ff4e5c456/" rel="bookmark">
			Sora - 探索AI视频模型的无限可能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着人工智能技术的飞速发展，AI视频模型已成为科技领域的新热点。而在这个浪潮中，OpenAI推出的首个AI视频模型Sora，以其卓越的性能和前瞻性的技术，引领着AI视频领域的创新发展。让我们将一起探讨Sora的技术特点、应用场景以及对未来创作方式的深远影响。
方向一：技术解析 Sora作为OpenAI推出的首个AI视频模型，采用深度学习和自然语言处理技术实现视频内容的智能生成和互动。其技术架构融合了先进的神经网络算法，通过对视频内容进行分析和理解，在视频创作中展现出卓越的性能和前瞻性。
方向二：应用场景 Sora在影视制作、广告创意、游戏设计、在线教育等领域拥有无限潜力。例如，Sora可以帮助电影制作团队快速生成特效场景，为广告公司提供个性化的创意方案，或者为在线教育平台定制交互式学习视频，为用户呈现全新的体验。
方向三：未来展望 Sora的问世将彻底改变数字内容创作方式。创作者们可以借助Sora突破传统限制，实现更加个性化、高效和创新的创作过程。AI视频模型如Sora将助力内容创作者更灵活地表达创意，提高生产效率，并推动数字内容产业向智能化方向发展。
方向四：伦理与创意 随着AI技术的普及，平衡技术创新与伦理道德显得尤为重要。虽然Sora等AI视频模型提升了创意效率，但我们也需要考虑尊重原创精神、保护知识产权等问题。创作者和技术开发者需共同探讨如何在创意产业中维护伦理标准。
方向五：用户体验与互动 Sora致力于提升用户体验和互动性。通过智能化的视频生成和个性化推荐，Sora可以更好地满足用户需求，实现更自然和高效的人机交互。用户将享受到更智能、更符合自身兴趣的视频内容，从而提升观赏体验和参与感。
Sora的推出将引领AI视频模型的发展，拓展数字内容创作的边界，为创作者和用户带来全新的体验和无限可能。愿Sora的出现为数字内容创作开启崭新篇章，不断激发创意灵感，促进行业创新与发展！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e42bcb8fa8d527bde6c56cac8d3966ab/" rel="bookmark">
			前端（vue）数据存储方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 本需求文档旨在明确前端项目中的数据存储需求，包括数据类型、数据结构、数据交互方式等。它定义了前端项目中需要存储和处理的数据，以及对这些数据进行访问和操作的要求。
功能需求 数据存储按数据类型分为 持久存储、内存存储（响应式）、内存存储（非响应式），根据不同的业务场景选择合适的存储方式。
持久存储(localStorage) 数据存储在本地磁盘，关闭网页或异常退出程序时数据不会被清除，可长期存在于磁盘中。可用于保存: 登录信息，程序设置信息等
export class LocalStorageConstant { /** * 用户 token */ static USER_TOKEN = "USER:TOKEN"; /** * 用户信息 */ static USER_INFO = "USER:INFO"; /** * 微信信息 */ static WX_USER_INFO = "WX:USER:INFO"; } export class LocalStorageUtil { // 静态属性 引用 LocalStotrage 类的唯一实例对象 static localStorageUtil: LocalStorageUtil; // 区分不同的环境，避免 iOS 小程序与小程序，小程序与公众号间本地存储混乱 public ecologyName: string | null; // 私有化构造器 private constructor() { this.ecologyName = store.getters.ecologyName; } // 提供一个外部可访问的的静态方法 public static getInstance() { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e42bcb8fa8d527bde6c56cac8d3966ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/516860fee75476d5c60a5a99193afb0e/" rel="bookmark">
			华为OD机试真题-最大坐标值-2023年OD统一考试（C卷）--Python--开源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：
考察内容：
for +if + 异常处理+细节（负数-1， 指令为0，且幸运数为0，不进不退）
代码：
""" 题目分析： 异常处理：try -except 当指令为0，且幸运数字为0， 不进，也不退 输入： int 指令的总数 1，100 int 幸运数 -100， 100 int n个指令， -100，100 输出： 最大坐标处 eg: 2 1 -5 1 5 -5 -5 1 6 0 -7 异常：12345 思路： """ try: n = int(input()) m = int(input()) list_n = list(map(int, input().split())) res = [0] init = 0 for i in list_n: # 如果num是0，直接跳过 # 因为即使幸运数是0，也不会往前或往后走 if i == 0: continue if m == i: # 如果是负数，需要-1 if i &lt; 0: init += i-1 res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/516860fee75476d5c60a5a99193afb0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45b2bfc916c8f87f4ca627dd13551e1f/" rel="bookmark">
			springmvc&#43;mybatis&#43;springboot航空飞机订票售票系统_f48cp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		互联网发展的越来越快了，在当下社会节点，人们也开始越来越依赖互联网。通过互联网信息和数据，极大地满足用户要求[5]。飞机订票系统使用了B/S模式，并且不需要安装第三方插件，他们甚至能直接在电脑上随机随地实现飞机订票管理，还能实现更加准确的提供机票信息。现社会无论各行各业都应尽量摒弃传递错误信息，尤其是口头传输信息。而网络却并不会像电话那样一次只能传输一次，效率低下还间连不断，此时利用网络来处理信息也就会更加的容易。我们甚至可以通过网络技术节省时间和人力成本。于是传统的管理方式
课题主要分为二大模块：即管理员模块和用户模块，主要功能包括：个人信息修改、用户、机票信息、在线留言、系统和订单等；
关键词：飞机订票系统； jdk版本：1.8 及以上
ide工具：IDEA 或者eclipse
数据库: mysql 编程语言: python
tomcat: 8.0 及以上
框架：SSM/springboot都有
maven: 3.6.1
前端：layui+bootstrap
详细技术：HTML+CSS+JS+jsp+SSM+MYSQL+JQUERY+MAVEN
前台首页页面：若进入本网站，需要注册自己的账号和密码，输入正确的账号和密码，用户才可以成功登录到飞机订票系统主页面，进入飞机订票管理页面后，用户可以在搜索栏中查询自己所需的机票信息、公告栏、在线留言等，在个人中心用户可以修改自己的个人详细信息。
后台管理员页面：主要是管理员登录本网站。管理员输入管理员账号密码后，校验无误后方可进入后台管理主界面，对用户使用的权限管理等管理以及对网站信息进行管理。
目录
摘 要 I
Abstrac II
目录 III
1绪论 1
1.1 研究背景 3
1.1.1国内研究现状 3
1.1.2国外研究现状 3
1.2研究的目的和意义 4
1.2.1研究目的 4
1.2.2 研究意义 4
1.3 论文的内容和结构 4
2系统相关技术概述 5
2.1 JSP技术介绍 6
2.2 MySQL数据库技术简介 6
2.3 B/S结构 7
2.4 SSM框架 7
3系统需求分析 8
3.1需求分析概述 8
3.2可行性分析 8
3.2.1技术可行性 9
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45b2bfc916c8f87f4ca627dd13551e1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fed52242bd0565ab1700b7ed213dcb9/" rel="bookmark">
			Sovit3D数字孪生平台 助力智慧海上风电场项目加速
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们常说地球是蓝色星球，那是因为海洋约占地球面积的71%。如今，我国正在向“双碳”目标不断奋斗，海上风电也作为一种潜力清洁能源，迸发出前所未有的活力，海上吹来的风成为未来清洁能源新方向。 2024年海上风电项目加速推进 2023年中国风电新增吊装容量77.1GW，同比上涨58%，创历史新高。其中，陆上风电新增69.4GW，同比增长59%;海上风电新增7.6GW，同比增长48%。值得注意的是，2023年是中国风电市场在停止补贴新增风电项目后首年实现陆上海上双增长。
2024年开年从业内了解到，国家能源集团、国家电投等多个央国企海风项目陆续获批核准，2024年海上风电开工、建设、并网节奏加快。此外，海南、福建等清洁能源大省相继公布2024年重大海风项目投资计划，依托海上风电资源，加快发展海上风电产业。
业内人士预计，2024年海上风电并网规模仍将不断扩大，海上风电项目建设将保持较快增长，需求释放将拉动海上风电产业出货量持续增长。
2024年智慧海上风电解决方案 背景 智慧化方面从国家层面而言，我们国家的“十四五”规划以及新基建都明确提出在智慧能源方面的建设，同时也是希望开展智慧能源建设帮助企业进行智慧化转型。为了贯彻落实数字中国、数字经济和智慧能源等战略，2035战略为指引国家电投目标打造数字化国家电投，建设智慧能源体系，将数字化、智能化融入到能源生产运营通过数字化实现产业在规划、设计、建设、运营等环节提质降本增效的目的。
定义 智慧海上风电场利用大数据实时监控电量分析，并通过数字可视化大屏进行信息展示，使参观总览、集团调度、远程运维状态一目了然。此外，智慧海上风电场还具备海底电缆设计与智能运维核心技术，建立起风机、海缆等主要设备健康状态的预警模型，实现设备初期劣化和故障预警、诊断，有效防止设备欠维护和过维护。
体系架构 智慧海上风电场旨在将整个风电场作为一个整体场景，统一设计风电机组及箱变、海上升压站、陆上站的各类子系统;采用统一的标准化接口，使其能无缝融合在统一的信息数据交换平台上;使用统一的人机交互界面，进行统一的运行控制和管理维护。在陆上集控中心就可实施对全场景的远程实时可视化监控，并进行各类数据(如故障分析与预测、设备管理、工单管理等)的统一智能化管理，实现海上无人值守、陆上少人集控的智慧化运维管理模式。
开发平台 系统基于WebGL标准下的B/S框架，前端采用HTML5+JavaScript技术为基础，进入Sovit2D/Sovit3D可视化平台后，结合真实世界建立数字孪生三维场景(也可上传背景图)，在线拖拽资源库中的风机、升压站、设备等组件，配置颜色、动画效果，可视化直观呈现海上风场运行状态。通过对场景进行放大、缩小平移等操作查看场景效果和细节。并将环境参数、实时发电指标、节能减排信息等数据接入 2D 面板，便于运维人员对整个风电场运行的有效掌控。
物联网3D可视化三维数字孪生平台Sovit3D-数维图​www.sovitjs.com/sovit3D_detail.html​编辑
功能设计 #1全局概览
展示海上风电场运维中心及风电场总体生产运营信息，包括实时指标、机组状态、环境参数、发电统计、风机数量等信息。
#2设备管理
智能设备是智慧海上风电场的数据基础。智能装置是智能设备层的基本元素，应使用标准通信接口和协议，实现数字化监测和网络化控制;应具备就地综合评估、实时状态报告、故障诊断等功能。
#3风机监测
在风机上采用先进的状态监测、数据分析、智能控制技术，使机组准确地感知自身和外部环境，建立数据监测、异常告警机制，智能锁定故障位置。为风机匹配机械传动链、塔筒、基础、桨叶以及重要的螺栓载荷等重要元部件的状态监测，实现对机组参数渐变、突变事件的智能化故障预警与诊断。
#4海缆监测
海底电缆是海上风电场电能传输的关键部件，海底电缆的事故将导致极大的损失。有必要实时监测海缆的温度和应力变化。借助海缆中的光纤线芯，通过对接光纤分布式传感新技术，判断电缆是否受损及周围环境是否发生变化，并对海缆异常进行报警和定位。
#5环境监测
海上环境相对更加复杂，环境参量的在线监测显得尤为重要。通过对接传感器监测结果数据和高速传输介质，将海上风电运营区的海洋环境统一展示，实时测量并显示风速、风向、气温、相对湿度、气压;并对作业海区未来7天的天气现象、气压、风向、风力、气温、浪高、能见度等要素进行预报，安排预警和预处理方案及出海作业策略。
#6智能巡检
鉴于海上风电场水域大、环境复杂、维护难，在海上升压站、配电室等主要区域，以第一视角漫游巡检，实现 1：1 场景还原的智能巡检系统，结合物联网、三维建模等技术，实现巡检当前状态数据展示，巡检摄像头实时监控信息回传，从管理、安防、节能、隐患排查等多维度对海上风电场实施动态监控及预警。
#7视频监控
根据风电场监控摄像头分布情况，在三维场景中设置视频监控点位，以摄像头图标展示其位置。支持场景交互来调取相应监控视频，对异常目标的自动抓拍、抓摄和留存，出现异常警告时，监控点位会有声光报警效果。满足运维人员对场景进行实时态势感知、历史数据回溯比对、应急处理预案等监测需求。
#8电子围栏
海上风电场水域电子围栏一旦有非法入侵时，智能跟踪球机立即自动跟踪现场目标，并在现场和监控中心发出声光报警。通过对接船事系统可获取到施工船只、渔船、非法入侵船只等相关信息，结合入侵时间、离开时间，可实时定位船舶位置(经度及纬度)和绘制历史轨迹，提高监控管理效率。
#9智能预警
建立预警触发机制，对风场设备、环境进行实时监控，在识别到后台状态数据时，将状态以差异化的形式呈现在设备模型上，当设备状态为异常时，系统将持续发出声光报警，并弹出异常警报。并联动视频监控将镜头聚焦，展示报警设备详情及位置，方便运维人员即时做出决策处理。
#10建设价值
利用数维图(SovitJs)应用自主研发的 Sovit2D、Sovit3D 产品，无缝融合 2D、3D 技术，搭建3D 可视化智慧海上风电场大数据管理平台。实现可交互式的 Web 二三维场景，基于多维感知、场景物联、物信融合的技术理念，不断丰富与完善海上风电场全面感知，实现设备设施智能巡检、环境风险监测预警，助力集控中心生产调度，辅助决策和全局掌控。
总结 建设智慧海上风电场，实现海上风电场设备、资产的智慧化监控与管理，对提高风电场自动化水平和运维效率、降低运维成本、提高海上风电的径济和社会效益、提高抵御风险的能力具有重要意义。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b28152dcc305e8bd06766d18fa3b23e7/" rel="bookmark">
			gcc/g&#43;&#43; 编译器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gcc/g++ 编译器 1 gcc/g++ 编译器1.1 gcc编译过程1.1.1 预处理1.1.2 编译1.1.3 汇编1.1.4 链接 1.2 其他编译选项1.3 静态库和动态库1.3.1 静态库1.3.2 动态库1.3.3 符号链接生成1.3.4 查看库的依赖关系1.3.5 升级版本 1.4 gcc 优化选项 1 gcc/g++ 编译器 Linux 下最常用的C语言编译器是gcc。g++是用来编辑C++程序的，但所有的C++编译器都可以用来编译C程序。g++编译器实际上调用的也是gcc，只是以必要的选项参数来调用，使gcc能识别出C++源代码。
gcc -v：查看gcc的版本，从而确定某些语法特性是否可用。
常用的选项：
-c：表示编译源文件
-o：表示输出目标文件
-g：表示在目标文件中产生调试信息，用于gdb调试
-D：&lt;宏定义&gt;编译时将宏定义传入进去
-Wall：打开所有类型的警告
1.1 gcc编译过程 使用gcc编译程序的过程是预处理、编译、汇编和链接，所使用的工具依次是预处理器、编译器、汇编器as、链接器ld。预处理将源文件中的宏进行展开；gcc将c文件编译成汇编文件，汇编器将汇编文件编译成机器码；链接器将目标文件和外部符号进行连接，得到一个可执行二进制文件。
1.1.1 预处理 gcc -E test.c -o test.i
1.1.2 编译 gcc -S test.i -o test.s
1.1.3 汇编 as test.s -o test.o
利用as命令（汇编器）可以将汇编文件编译成机器码。.o 文件中为目标机器上的二进制文件，使用nm命令可以查看文件中的符号表。
1.1.4 链接 得到.o文件后，如果直接执行这个文件，就会提示无法运行。这是因为前面的符号表当中还有很多U的部分，也就是地址未确定的部分，这种文件是无法执行的。在完成链接以后，各个部分的代码的地址都确定以后，文件才能执行。使用gcc命令可以完成链接。
gcc test.o -o test
ld test.o [其他系统库文件] -o test
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b28152dcc305e8bd06766d18fa3b23e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e31bcc4bff92ed0fda4210f892659ed6/" rel="bookmark">
			python子域名收集工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在网络安全领域中，发现和管理攻击面绝对是一项必须的任务，而对域名的寻找和分析是发现攻击面的重要步骤。今天我们将与您分享关于域名发现的四种方法，并附带Python示例代码来帮助您更好的理解和掌握这些方法。
1. 主域名链式证书提取域名信息（Chain of Trust from Root Domain） import ssl import OpenSSL def get_cert_chain(domain): cert = ssl.get_server_certificate((domain, 443)) x509 = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert) return [value for value in x509.get_subject().get_components()] print(get_cert_chain('example.com')) 2. 证书透明度日志（Certificate Transparency Logs） import requests def query_crt_sh(domain): url = f"https://crt.sh/?q={domain}&amp;output=json" response = requests.get(url) try: return [result['name_value'] for result in response.json()] except: return [] print(query_crt_sh('example.com')) 3. 站长工具（Webmaster Tools） import requests from bs4 import BeautifulSoup def query_webmaster_tools(domain): base_url = f"https://whois.chinaz.com/{domain}" page = requests.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e31bcc4bff92ed0fda4210f892659ed6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7954aac1750f0baa92d48b2e24cb8214/" rel="bookmark">
			2024.2.21 模拟实现 RabbitMQ —— 实现转发规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
需求分析
直接交换机（Direct ）
主题交换机（Topic ）
扇出交换机（Fanout ）
Topic 交换机转发规则
routingKey 组成
bindingKey 组成
匹配规则
情况一
情况二
情况三
实现 Router 类
校验 bindingKey 和 routingKey
消息匹配机制
Topic 交换机匹配规则
针对 Router 单元测试
需求分析 直接交换机（Direct ） 通过设定 消息的 routingKey = 队列名，以此指定该消息需传给哪个队列 实例理解
如下图所示，此时可直接无视绑定关系，直接从内存中拿到对应队列名的队列然后再将消息传给该队列即可 主题交换机（Topic ） 依据 Topic 交换机的转发规则，判定消息需传给哪些队列 扇出交换机（Fanout ） 给该交换机中所有绑定好的队列均传入消息 Topic 交换机转发规则 bindingKey：创建绑定时，给绑定指定的特殊字符串（相当于出题）routingKey：发布消息时，给消息上指定的特殊字符串（相当于做答案）当 routingKey 的答案能够与 bindingKey 相对应时，便可将消息转发给该队列 routingKey 组成 数字、字母、下划线使用 . 将整个 routingKey 分成多个部分 实例理解
aaa.bbb.ccc 合法aaa.110.bbb 合法aaa 合法 bindingKey 组成 数字、字母、下划线使用 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7954aac1750f0baa92d48b2e24cb8214/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44eef07d8f89fc08c1be870dc4a4d258/" rel="bookmark">
			dell戴尔电脑灵越系列Inspiron 15 3520原厂Win11系统中文版/英文版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Dell戴尔笔记本灵越3520原装出厂Windows11系统包，恢复出厂开箱预装OEM系统
链接：https://pan.baidu.com/s/1mMOAnvXz5NCDO_KImHR5gQ?pwd=3nvw 提取码：3nvw
原厂系统自带所有驱动、出厂主题壁纸、系统属性联机支持标志、Office办公软件、MyDell等预装程序
文件格式：esd/wim/swm
安装方式：PE模式安装
注意：安装系统时会格式化系统盘，请提前备份好重要资料！
如果不是想要的型号，请私信或留言。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2470e49b2d0f46f338ca67e773f1b794/" rel="bookmark">
			HTTP 与 HTTPS-HTTP 解决了 HTTP 哪些问题?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资料来源 : 小林coding
小林官方网站 : 小林coding (xiaolincoding.com)
HTTP 解决了 HTTP 哪些问题? HTTP 由于是明文传输，所以安全上存在以下三个风险:
窃听风险，比如通信链路上可以获取通信内容，用户号容易没。篡改风险，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。冒充风险，比如冒充淘宝网站，用户钱容易没。 HTTPS 在 HTTP 与 TCP 层之间加入了 SSL/TLS 协议，可以很好的解决了上述的风险:
信息加密:交互信息无法被窃取，但你的号会因为「自身忘记」账号而没校验机制:无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告身份证书:证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没 可见，只要自身不做「恶」，SSL/TLS 协议是能保证通信是安全的。
HTTPS 是如何解决上面的三个风险的?
混合加密的方式实现信息的机密性，解决了窃听的风险摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。将服务器公钥放入到数字证书中，解决了冒充的风险。 1.混合加密 通过混合加密的方式可以保证信息的机密性，解决了窃听的风险
HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式:
在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。 采用「混合加密」的方式的原因
对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。非对称加密使用两个密钥:公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢 2.摘要算法+ 数字签名 为了保证传输的内容不被篡改，我们需要对内容计算出一个「指纹」，然后同内容一起传输给对方。
对方收到后，先是对内容也计算出一个「指纹」，然后跟发送方发送的「指纹」做一个比较，如果「指纹」相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。
那么，在计算机里会用摘要算法(哈希函数)来计算出内容的哈希值，也就是内容的「指纹」，这个哈希值是唯一的，且无法通过哈希值推导出内容，
通过哈希算法可以确保内容不会被篡改，但是并不能保证「内容+哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明。
举个例子，你想向老师请假，一般来说是要求由家长写一份请假理由并签名，老师才能允许你请假。
但是你有模仿你爸爸字迹的能力，"你用你爸爸的字迹写了一份请假理由然后签上你爸爸的名字，老师一看到这个请假条，查看字迹和签名，就误以为是你爸爸写的，就会允许你请假。
那作为老师，要如何避免这种情况发生呢?现实生活中的，可以通过电话或视频来确认是否是由父母发出的请假，但是计算机里可没有这种操作。
那为了避免这种情况，计算机里会用非对称加密算法来解决，共有两个密钥
一个是公钥，这个是可以公开给所有人的一个是私钥，这个必须由本人管理，不可泄露 这两个密钥可以双向加解密的，比如可以用公钥加密内容，然后用私钥解密，也可以用私钥加密内容，公钥解密内容。
流程的不同，意味着目的也不相同:
公钥加密，私钥解密。这个目的是为了保证内容传输的安全，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容私钥加密，公钥解密。这个目的是为了保证消息不会被冒充，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的 一般我们不会用非对称加密来加密实际的传输内容，因为非对称加密的计算比较耗费性能的。
所以非对称加密的用途主要在于通过「私钥加密，公钥解密」的方式，来确认消息的身份，我们常说的数字签名算法，就是用的是这种方式，不过私钥加密内容不是内容本身，而是对内容的哈希值加密。
私钥是由服务端保管，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被公钥解密就说明该消息是由服务器发送的。
引入了数字签名算法后，你就无法模仿你爸爸的字迹来请假了，你爸爸手上持有着私钥，你老师持有着公钥。
这样只有用你爸爸手上的私钥才对请假条进行「签名」，老师通过公钥看能不能解出这个「签名」，如果能解出并且确认内容的完整性，就能证明是由你爸爸发起的请假条，这样老师才允许你请假，否则老师就不认。
3.数字证书 前面我们知道:
可以通过哈希算法来保证消息的完整性可以通过数字签名来保证消息的来源可靠性(能确认消息是由持有私钥的一方发送的) 但是这还远远不够，还缺少身份验证的环节，万一公钥是被伪造的呢?
还是拿请假的例子，虽然你爸爸持有私钥，老师通过是否能用公钥解密来确认这个请假条是不是来源你父亲的。
但是我们还可以自己伪造出一对公私钥啊!
你找了个夜晚，偷偷把老师桌面上和你爸爸配对的公钥，换成了你的公钥，那么下次你在请假的时候，你继续模仿你爸爸的字迹写了个请假条，然后用你的私钥做个了「数字签名」。
但是老师并不知道自己的公钥被你替换过了，所以他还是按照往常一样用公钥解密，由于这个公钥和你的私钥是配对的，老师当然能用这个被替换的公钥解密出来，并且确认了内容的完整性，干是老师就会以为是你父亲写的请假条，又允许你请假了。
后面你的老师和父亲发现了你伪造公私钥的事情后，决定重新商量一个对策来应对你这个臭家伙。
既然伪造公私钥那么随意，所以你爸把他的公钥注册到警察局，警察局用他们自己的私钥对你父亲的公钥做了个数字签名，然后把你爸爸的「个人信息+公钥+数字签名」打包成一个数字证书，也就是说这个数字证书包含你爸爸的公钥。
这样，你爸爸如果因为家里确实有事要向老师帮你请假的时候，不仅会用自己的私钥对内容进行签名，还会把数字证书给到老师。
老师拿到了数字证书后，首先会去警察局验证这个数字证书是否合法，因为数字证书里有警察局的数字签名，警察局要验证证书合法性的时候，用自己的公钥解密，如果能解密成功，就说明这个数字证书是在警察局注册过的，就认为该数字证书是合法的，然后就会把数字证书里头的公钥(你爸爸的)给到老师。
由于通过警察局验证了数字证书是合法的，那么就能证明这个公钥就是你父亲的，于是老师就可以安心的用这个公钥解密出请假条，如果能解密出，就证明是你爸爸写的请假条。
正是通过了一个权威的机构来证明你爸爸的身份，所以你的伪造公私钥这个小伎俩就没用了。
在计算机里，这个权威的机构就是 CA (数字证书认证机构)将服务器公钥放在数字证书(由数字证书认证机构颁发)中，只要证书是可信的，公钥就是可信的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2470e49b2d0f46f338ca67e773f1b794/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/263957943eefbbfe08bbe68adf7869e2/" rel="bookmark">
			HarmonyOS—添加/删除Module
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Module是应用/服务的基本功能单元，包含了源代码、资源文件、第三方库及应用/服务配置文件，每一个Module都可以独立进行编译和运行。一个HarmonyOS应用/服务通常会包含一个或多个Module，因此，可以在工程中创建多个Module，每个Module分为Ability和Library两种类型。
在工程中添加Module 创建新的Module 1.通过如下两种方法，在工程中添加新的Module。
方法1：鼠标移到工程目录顶部，单击鼠标右键，选择New &gt; Module…，开始创建新的Module。方法2：选中工程目录中任意文件，然后在菜单栏选择File &gt; New &gt; Module…，开始创建新的Module。 2.在New Project Module界面中，选择需要创建的模板，单击Next。
3.在Module配置页面，设置新增Module的基本信息，然后单击Next。
Module name：新增模块的名称。Module type：仅在Ability模板存在该字段，可以选择Feature和Entry类型。如果同一类型的设备已经存在Entry模块，添加新Module选择Entry类型时，还需要配置distroFilter分发规则。Enable Super Visual：是否使用低代码开发方式。Language：选择该Module的开发语言。Device type：选择模块的设备类型，如果新建模块的Module type为feature，则只能选择该工程原有的设备类型；如果Module type为entry，可以选择该Module支持的其他设备类型。Enable native：仅Library模板存在，将创建一个可以调用C/C++的共享包。 4.若该Module的模板类型为Ability，还需要设置新增Ability的Ability name和Exported参数，Exported参数表示该Ability是否可以被其它应用/服务所调用（FA模型下为Visible参数)。
勾选（true）：可以被其它应用/服务调用。不勾选（false）：不能被其它应用/服务调用。 5.单击Finish，等待创建完成后，可以在工程目录中查看和编辑新增的Module。
导入Module HarmonyOS工程支持从其它工程中导入HarmonyOS模块的功能，导入的模块只能是HarmonyOS工程中的模块。当前仅支持FA模型的模块导入到FA模型，Stage模型的模块导入到Stage模型，不支持FA模型的模块导入到Stage模型或Stage模型的模块导入到FA模型。
1.在菜单栏单击File &gt; New &gt;Import… &gt;Import Module。
2.选择导入的模块时。其中SDK 4-7的工程既可以选择模块也可以选择工程，而SDK 8-9的工程只可以选择模块。下面以SDK 8-9的工程为例介绍导入模块的具体操作。
在指定路径下，选择导入的模块，单击OK。导入的模块可以为文件夹，也可以为zip格式。
配置distroFilter分发规则 同一类型的设备（Phone、Wearable、Lite Wearable等）可能在系统API版本（apiVersion）、屏幕形状（screenShape）、分辨率（screenWindow）上存在差异。针对这些差异，开发者需要针对同一类型设备的不同型号进行适配开发，然后在应用市场实现精准的分发，以便不同设备的用户能获得更好的使用体验。为了实现应用市场的精准分发，需要在一个工程中，针对同一类型设备添加多个Entry模块来适配不同型号的设备，然后再配置不同的分发规则。具体规则如下：
通过DeviceType与screenShape等属性的组合唯一确定一个Entry。distroFilter中至少包含属性中的一个标签。如果一个Entry模块中配置了screenShape等任意一个或多个标签，则其他的Entry模块也必须包含相同的标签。一般情况下，screenShape和screenWindow标签用于Lite Wearable设备中。不同属性标签的配置格式如下。其中，policy取值为include时，表示设备满足value取值时，应用市场向该设备进行分发；policy取值为exclude时，表示除了value的取值外，其它合法的取值，应用市场都会向设备进行分发。 说明
screenWindow标签的policy取值只能为include。
Stage模型配置分发规则 1.在entry &gt; src &gt; main &gt; resources &gt; profile文件中新建一个.json文件，并根据开发实际需要，配置如下代码信息。Stage模型下分发规则请参见distroFilter标签。
{ "distroFilter": { "apiVersion": { //API 版本 "policy": "include", "value": [4, 5] }, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/263957943eefbbfe08bbe68adf7869e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b742a2945996bfebeb494e712ef910bb/" rel="bookmark">
			【JVM】五种对象引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📝个人主页：五敷有你 🔥系列专栏：JVM
⛺️稳中求进，晒太阳
几种常见的对象引用 可达性算法中描述的对象引用，一般指的是强引用，即是GCRoot对象对普通对象有引用关系，只要这层关系存在，普通对象就不会被回收。除了强引用之外，Java中还设计了几种其他引用方式：
软引用弱引用虚引用终结器引用 软引用 软引用相对于强引用是一种比较弱的引用关系，如果一个对象只有软引用关联到它，当程序内存不足时，就会将软引用中的数据进行回收。在JDK 1.2版之后提供了SoftReference类来实现软引用，软引用常用于缓存中。
软引用的执行过程如下：
将对象使用软引用包装起来，new SoftReference(对象)。内存不足时，虚拟机尝试进行垃圾回收。如果垃圾回收仍不能解决内存不足的问题，回收软引用中的对象。如果依然内存不足，抛出OutOfMemory异常。 软引用中的对象如果在内存不足时回收，SoftReference对象本身也需要被回收。如何知道哪些SoftReference对象需要回收呢？
SoftReference提供了一套队列机制：
软引用创建时，通过构造器传入引用队列在软引用中包含的对象被回收时，该软引用对象会被放入引用队列通过代码遍历引用队列，将SoftReference的强引用删除 软引用也可以使用继承自SoftReference类的方式来实现，StudentRef类就是一个软引用对象。
通过构造器传入软引用包含的对象，以及引用队列。
弱引用 弱引用的整体机制和软引用基本一致，区别在于弱引用包含的对象在垃圾回收时，不管内存够不够都会直接被回收。
在JDK 1.2版之后提供了WeakReference类来实现弱引用，弱引用主要在ThreadLocal中使用。
弱引用对象本身也可以使用引用队列进行回收。
虚引用和终结器 引用这两种引用在常规开发中是不会使用的。
虚引用也叫幽灵引用/幻影引用，不能通过虚引用对象获取到包含的对象。虚引用唯一的用途是当对象被垃圾回收器回收时可以接收到对应的通知。Java中使用PhantomReference实现了虚引用，直接内存中为了及时知道直接内存对象不再使用，从而回收内存，使用了虚引用来实现。
终结器引用指的是在对象需要被回收时，终结器引用会关联对象并放置在Finalizer类中的引用队列中，在稍后由一条由FinalizerThread线程从队列中获取对象，然后执行对象的finalize方法，在对象第二次被回收时，该对象才真正的被回收。在这个过程中可以在finalize方法中再将自身对象使用强引用关联上，但是不建议这样做
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d12ec16f86e1bcb73fa69713904c583/" rel="bookmark">
			嵌入式基础准备 | Linux命令（包括 文件、目录和压缩、系统操作、vi、vim、ctags、cscope）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、使用 ctrl+alt+t 打开命令行
2、按tab键补全文件名
3、ctrl+c 停止正在进行的过程
4、向上键向下键翻历史的命令（只有在当前用户才有效，比如切换根用户之后就无了）
5、根用户创建的文件 其他用户只有查看内容的权限，不能修改
6、具体命令：Linux vi/vim 使用
1、文件、目录和压缩 1.1 目录操作 $ ls //查看里面有什么东西(浏览目录内容) 默认开始进入主目录 $ tree // 查看当前目录（直接出树状结构）（安装命令(软件) sudo apt-get install tree，sudo表示要用根用户（当前普通用户）） $ tree -L 2 //查看当前的前两层目录树 $ tree /home //查看home目录下的子目录树 $ cd /　//切换到系统根目录（/） cd (change directory) $ cd ~ //切换到当前用户目录 $ pwd //查看当前路径 $ cd ..　//切换到上一层目录（两个点 ） $ mkdir hello //创建目录（文件夹） $ rm -rf hello/ //删除目录(文件夹hello) $ cd hello //切换到当前目录下的hello子目录 $ ln -s /mnt/hgfs .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d12ec16f86e1bcb73fa69713904c583/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b27b8d5e6f2429d939253cf35f6c7057/" rel="bookmark">
			【Linux】MySQL数据库的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Linux】MySQL数据库的使用 一、访问MySQL数据库二、创建及删除库和表1、创建新的库2、创建新的表3、删除一个数据表4、删除一个数据库 三、管理表中的数据记录1、插入数据记录2、查询数据记录3、修改数据记录4、删除数据记录 四、数据库用户授权1、授予权限2、查看权限3、撤销权限 linux中部署MySQL详见我的上一篇博文：
Ubuntu22部署MySQL5.7详细教程
本篇文章将介绍在Ubuntu中如何使用MySQL数据库。
一、访问MySQL数据库 首先使用root用户登录MySQL
mysql -u root -p 验证成功以后将会进入提示符为‘mysql&gt;”的数据库操作环境，用户可以输入各种操作语句对数据库进行管理。
每条MySQL操作语句以分号 ‘;’ 表示结束，输入时可以不区分大小写。
status;表示查看当前数据库服务的基本信息。
status; show databases;表示用于查看当前MySQL服务器中包含的库。
show databases; 经初始化后的MySQL服务器，默认建立了四个库：test.mysql.information_schema和performance_schema（其中mysql库是mysql正常运行所需的库，其中包含了用户认证相关的表）。
使用Navicat远程连接数据库可以看到这四个库
show tables;用于查看当前所在的库中包含的表。 在操作之前，需要先使用USE语句切换到所使用的库，例如，执行以下操作可以显示mysql库中包含的所有表。
use mysql; show tables; describe用于显示表的结构，即组成表的各字段（列）的信息。需要指定“库名.表名” 作为参数；若只指定表名参数，则需先通过USE语句切换到目标库。 例如，执行以下操作可以查看mysql库中的user表的结构。与直接执行“DESCRIBE mysql.user;’”语句的效果相同。
use mysql; describe user; 在“mysql&gt;”操作环境中，执行 “exit”或“quit”命令 可以退出mysql命令工具，返回原来的Shell环境。
二、创建及删除库和表 1、创建新的库 CREATE DATABASE语句：用于创建一个新的库，需指定数据库名称作为参数。 例如，执行以下操作可以创建一个名为auth的库。
create database auth; 刚创建的数据库是空的，其中不包含任何表，在数据库存放目录下会自动生成一个与新建的库名相同的文件夹。
使用以下命令可以查看数据库存放目录。
SHOW VARIABLES LIKE 'datadir'; 可见在数据库存放目录下新增了一个auth文件夹。
2、创建新的表 CREATE TABLE 语句：用于在当前库中创建新的表，需指定数据表名称作为参数，并定义该表格所使用的各字段，基本格式如下所示。
CREATE TABLE 表名 (字段1名称 类型, 字段2名称 类型, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b27b8d5e6f2429d939253cf35f6c7057/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/7/">«</a>
	<span class="pagination__item pagination__item--current">8/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/9/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>