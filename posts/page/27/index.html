<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da020dff8c6bd651357d648c687a0d48/" rel="bookmark">
			【原创】解决Windows/macOS 双系统时间不一致问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果把macOS和Windows安装在同一个硬件上，也会发现一个时间不一致的问题。
具体表现：一旦进入过 macOS 系统，再回到Windows后, 就会发现时间会比实际时间慢8个小时。
原因是： macOS系统和Windows系统对时间的处理方式不同。
macOS 则把硬件时间当作 UTC，操作系统中显示的时间是硬件时间经过换算得来的。
Windows把系统硬件时间当作本地时间（Local Time），操作系统中显示的时间和 BIOS 中是一样的。
操作系统在同步时间的时候，同时会修改BIOS时间，因此导致Windows/macOS显示的时间不一致。
最简单的解决办法，修改Windows注册表。
Reg add HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1 下次启动Windows后，Windows会采用与macOS系统一致的时间处理方式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b3f328e85853c18bdca2bf4f0fb8c85/" rel="bookmark">
			如何使用FME开发自动化分析报告功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、使用的技术栈
二、技术难点解析
1.专题图
2.WORD文档实现
2.1 动态标题
2.3动态表格和文本
2.3专题图插入
三、完成NewGIS部署
四、模板总览图
总结
前言 一个标准项目分析报告需要需要包括3个方面：
文本叙述，主要体现在对某项专项数据的分布情况，总体情况，分类情况进行描述，需要使用真实数据，能够直观的反馈数据的存在情况。表格展示，使用表格数据展示，能够更加直观的反馈数据的数量，分布，分类情况。专题图展示，一个标准的专题图，需要包括图例、图样、行政区界限等要素，让数据的分布情况一目了然。 按照常规的生产模式，一个分析报告往往涉及多个图层、多种数据、多种维度的数据分析。以城镇国土空间监测项目为例，完成一个分析报告往往需要好几天时间。通过城镇国土空间监测分析报告自动处理方案，能够实现在3分钟以内，完成分析报告的自动化编制，并且能实现无任何逻辑错误，文档和数据库的一致性。
一、使用的技术栈 整套方案整体流程通过FME开发，数据分析通过FME和pandas分析库辅助实现，专题图通过FME和python的opencv库实现，word文档和表格部分通过python-docx库实现。
二、技术难点解析 1.专题图 众所周知，大部分的专题图都是由专业软件Arcgis或者Qgis等制作，需要手动配置图例，样式，文本，颜色，指北针等信息。优点是自定义化程度高，能实现各式各样的专题图制作，缺点也很明显，很难实现自动化图，样式，图例随动的出图，同时也不能和WORD联动，实现自动插图。
FME虽然在出图方面没有arcgis优秀，但其优秀的数据处理和整合能力是无可比拟的。它能让你的逻辑图形化，让你的思维能更加清晰。
以城镇国土空间监测项目为例，我们先做一个config配置表格，通过该文件实现对图层名称，颜色的配置。
行政区裁剪和环绕文本制作，先上成果图
首先我们先说一下如何实现文字环绕的逻辑，其实非常简单，就是将行政区buff后，裁剪当前区域，获得环绕行政区
再通过一系列的数学算法，让文本均匀分布在图形内部，同时保证字的顺序的方向性一致。
然后是就是需要注意字体大小和图形面积是有比例关系的，因为很多样本的图形大小差距很大，将字体大小固定下来的话就很难有适配性，那么就应该通过总面积大小求得一个比例参数，并将该参数发布为全局变量。
文本的固定使用TextStroker转换器实现，该转换器可以将label的点文字注记转换为文本的几何。
考虑到部分要素面积小，要素个数较少，很难在图形上看到分布，则设置一个阈值将文字标记展示出来。
但是这样也会存在一个问题，就是文字注记的压盖，这里我们使用了一个算法，来调整几个文本box的空间位置，让其能较好的分布。整体的逻辑就是使用递归，不断的调整相互重叠字体的位置，来达到比较正常分布。
import fme import fmeobjects import copy def adjust_boxes(boxes): moved_boxes = copy.deepcopy(boxes) # 创建一个副本用于移动 overlap = True # 初始化重叠标志为True while overlap: overlap = False for i in range(len(boxes)): for j in range(i+1, len(boxes)): if check_overlap(moved_boxes[i], moved_boxes[j]): overlap = True move_box(moved_boxes, i, j) return moved_boxes def check_overlap(box1, box2): # 检查两个box是否重叠 return not (box1[1] &lt; box2[0] or box1[0] &gt; box2[1] or box1[3] &lt; box2[2] or box1[2] &gt; box2[3]) def move_box(boxes, index1, index2): # 移动box2以保证与box1不重叠 box1 = boxes[index1] box2 = boxes[index2] x_overlap = min(box1[1], box2[1]) - max(box1[0], box2[0]) y_overlap = min(box1[3], box2[3]) - max(box1[2], box2[2]) x_offset = max(box1[1], box2[1]) - min(box1[0], box2[0]) + 1 - x_overlap y_offset = max(box1[3], box2[3]) - min(box1[2], box2[2]) + 1 - y_overlap if x_offset &lt; y_offset: # 选择较小的偏移方向 if box1[1] &lt; box2[0]: # box2在box1的右侧 offset = x_offset else: # box2在box1的左侧 offset = -x_offset boxes[index2][0] += offset boxes[index2][1] += offset else: if box1[3] &lt; box2[2]: # box2在box1的上方 offset = y_offset else: # box2在box1的下方 offset = -y_offset boxes[index2][2] += offset boxes[index2][3] += offset class FeatureProcessor(object): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b3f328e85853c18bdca2bf4f0fb8c85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c36b82deb92509fd785c230b5e621753/" rel="bookmark">
			上位机与stm32的串口通信（适合萌新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 之前准备电赛期间就搞过opemv和stm32之间的通信，这次工训赛又给忘了，遂记录一下。
上位机 安装python和serial库 一般来说上位机都是要用python的serial库来实现串口通信的，那么肯定要现在环境中装好python环境，选择3.8左右就可以，接着在终端里：
pip install serial -i https://pypi.tuna.tsinghua.edu.cn/simple 这样就完成python上位机的基本配置。
下位机 stm32端的配置，由于本人习惯使用DMA串口中断进行收发，所以顺便讲一下DMA如何配置
1.首先用cubemx完成基本配置后，接着在串口那里异步通信
2.接着开启DMA，选择normal模式即可
3.开启DMA中断
4.记得不要勾选这个
接着生成工程就创建完毕了，然后代码部分
5.手动在main函数的init部分开启DMA中端（收发数组就自己创建吧）
6.然后再重新定义这个函数（名字一定要一样，因为这个函数本身是个弱定义，否则就不发达成收发闭环）
如此一来，stm32就配置好了。
正片开始 上位机发float，下位机收 上位机端代码部分
import serial import struct import time if __name__ == "__main__": ser = serial.Serial('COM10',baudrate=115200) float_values = [3.14, 2.718, 1.234] while True: for value in float_values: data_to_send = struct.pack('f', value) # 'f'表示单精度浮点数 ser.write(data_to_send) print(data_to_send) time.sleep(1) ser.close() 说明：“COM10”是windows电脑的样式，如果是Linux上位机的话应该是“/dev/ttyUSB0”的样子。
发送的结果就是字节发送float类
stm32端代码部分
说明：这里使用一个联合体将收到的字节型数据和float类型做了一个转换，可以看到这里的发送是大端模式，所以0对0，1对1，如果收到结果不对可以试试反向映射。
我这里是用串口2来接受电脑发的数据，再用串口1打印回去便于可视化。
结果就是
然后int类型和float类型一模一样，
string类型的话就直接当作单个字符来接受就好，没什么难度，这里就不赘述了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/313030450692be2d57c8eaad239325cb/" rel="bookmark">
			VirtualBox&#43;Vagrant安装虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VirtualBox官网：[https://www.virtualbox.org/](https://www.virtualbox.org/)
Vagrant官网：[https://www.vagrantup.com/](https://www.vagrantup.com/)
Vagrant镜像仓库：[https://app.vagrantup.com/boxes/search](https://app.vagrantup.com/boxes/search)
安装VirtualBox和Vagrant，下一步，下一步。vagrant安装完成后需要重启计算机。
在cmd命令窗口输入 `vagrant` 命令弹出如下内容表示 `vagrant` 安装成功
通过Vagrant安装虚拟机：
* 创建一个空的目录，cmd切换到该目录中，然后执行 `vagrant init centos/7` 会创建Vagrantfile文
件
* 执行 `vagrant up` 第一次执行的时候会远程下载相关的镜像文件，并启动虚拟机。
* 连接虚拟机通过 `vagrant ssh` 连接
安装成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2933f9536a232c440acf201e65c098f/" rel="bookmark">
			centos docker redis安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拉取Redis最新版本镜像
docker pull redis
```
先创建对应的Redis的映射配置文件
mkdir -p /mydata/redis/conf
touch /mydata/redis/conf/redis.conf
```
创建容器命令docker run -d -p 6379:6379 --name mall-redis -v /mydata/redis/data:/data -v /mydata/redis/conf:/etc/redis redis redis-server /etc/redis/redis.conf
启动后测试连接：
[root@manager-node conf]# docker exec -it 4e redis-cli
127.0.0.1:6379&gt; keys *
(empty array)
127.0.0.1:6379&gt; 设置容器自启动
[root@localhost ~]# docker update --restart=always mysql
mysql
[root@localhost ~]# docker update --restart=always mall-redis
mall-redis
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85112b1eec5bd11d80b59eb70b544269/" rel="bookmark">
			Git管理神器SourceTree使用教程详解（连接远程仓库，克隆，拉取，提交，推送，新建/切换/合并分支，冲突解决，提交PR）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 俗话说的好工欲善其事必先利其器，Git分布式版本控制系统是我们日常开发中不可或缺的。目前市面上比较流行的Git可视化管理工具有SourceTree、Github Desktop、TortoiseGit，综合网上的一些文章分析和自己的日常开发实践心得个人比较推荐开发者使用SourceTree，因为SourceTree同时支持Windows和Mac，并且界面十分的精美简洁，大大的简化了开发者与代码库之间的Git操作方式。该篇文章主要是对日常开发中使用SourceTree可视化管理工具的一些常用操作进行详细讲解。
SourceTree | Github Desktop | TortoiseGit 可视化管理工具对比： https://blog.csdn.net/hmllittlekoi/article/details/104504406/
SourceTree介绍和Atlassian账号注册和登录教程： https://www.cnblogs.com/Can-daydayup/p/13128511.html
连接Gitee or GitHub，获取代码: 注意：这里介绍的是使用SSH协议获取关联远程仓库的代码，大家也可以直接使用过HTTPS协议的方式直接输入账号密码获取关联代码！
全面概述Gitee和GitHub生成/添加SSH公钥： https://www.cnblogs.com/Can-daydayup/p/13063280.html 在SourceTree中添加SSH密钥： 工具=&gt;选择：
添加SSH密钥位置：C:\Users\xxxxx\.ssh\id_rsa.pub：
SSH客户端选择OpenSSH：
Clone对应托管平台仓库（以Gitee为例）： 打开码云，找到自己需要Clone的仓库！
SourceTree设置默认工作目录： 由上面我们可以发现每次Clone克隆项目的时候，克隆下来的项目默认存储位置都是在C盘，因此每次都需要我们去选择项目存放的路径，作为一个喜欢偷懒的人而言当然不喜欢这种方式啦，因此我们可以设置一个默认的项目存储位置。
设置SourceTree默认项目目录： 点击工具=&gt;选项=&gt;一般=&gt;找到项目目录设置Clone项目默认存储的位置：
SourceTree代码提交： 1.首先切换到需要修改功能代码所在的分支： 2.将修改的代码提交到暂存区： 3.将暂存区中的代码提交到本地代码仓库： 注意：多人同时开发项目的时候，不推荐默认选中立即推送变更到origin/develop，避免一些不必要的麻烦！
4.代码拉取更新本地代码库，并将代码推送到远程仓库： 勾选需要推送的分支，点击推送到远程分支：
代码成功推送到远程代码库：
5.在Gitee中查看推送结果： SourceTree分支切换，新建，合并： 1.分支切换： 双击切换：
单击鼠标右键切换：
2.新建分支： 注意：在新建分支时，我们需要在哪个主分支的基础上新建分支必须先要切换到对应的主分支才能到该主分支上创建分支，如下我们要在master分支上创建一个feature-0613分支：
3.合并分支: 注意：在合并代码之前我们都需要将需要合并的分支拉取到最新状态（**避免覆盖别人的代码，或者丢失一些重要文件）!!!!!
在master分支上点击右键，选择合并feature-0613至当前分支即可进行合并:
分支合并成功：
SourceTree代码冲突解决： 首先我们需要制造一个提交文件遇到冲突的情景： 在SoureceTree中在Clone一个新项目，命名为pingrixuexilianxi2，如下图所示：
我们以项目中的【代码合并冲突测试.txt】文件为例：
在pingrixuexilianxi2中添加内容，并提交到远程代码库，添加的内容如下：
在pingrixuexilianxi中添加内容，提交代码（不选择立即推送变更到origin/master），拉取代码即会遇到冲突：
冲突文件中的内容：
直接打开冲突文件手动解决冲突： 由下面的冲突文件中的冲突内容我们了解到：
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD6月19日 pingrixuexilianxi添加了内容=======6月18日 pingrixuexilianxi2修改了这个文件哦&gt;&gt;&gt;&gt;&gt;&gt;&gt; a8284fd41903c54212d1105a6feb6c57292e07b5 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD到 =======里面的【6月19日 pingrixuexilianxi添加了内容】是自己刚才的Commit提交的内容=======到 &gt;&gt;&gt;&gt;&gt;&gt;&gt; a8284fd41903c54212d1105a6feb6c57292e07b5里面的【6月18日 pingrixuexilianxi2修改了这个文件哦】是远程代码库更新的内容（即为pingrixuexilianxi2本地代码库推送修改内容）。 手动冲突解决方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85112b1eec5bd11d80b59eb70b544269/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e68bd5550f1506cd9d3f46a9066e938/" rel="bookmark">
			Springboot整合shiro
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		教程视频：去哔哩哔哩搜索楠哥教你学Java。里面有一篇SpringBoot整合Shiro的视频
这里是我自己整理的一个笔记，除了视频里教的，还有一些扩展功能以及一些解释
目录
1、什么是Shiro？
2、什么是RBAC？
3、Shiro核心组件
4、Springboot整合Shiro
5、认证和授权规则
6、Shiro整合Thymeleaf
7、Controller示例
8、权限管理标准5张表
9、密码加密、加盐
10、多个Realm
11、记住我
1、什么是Shiro？ 官网：Apache Shiro | Simple. Java. Security.
是一款主流的Java安全框架，不依赖任何容器，可以运行在Java SE和Java EE项目中，它的主要作用是对访问系统的用户进行身份认证、授权、会话管理、加密等操作。
Shiro 就是用来解决安全管理的系统化框架。Shiro是基于session的身份认证和访问控制框架。
2、什么是RBAC？ RBAC是Role-Based Access Control（基于角色的访问控制）的缩写。它是一种广泛应用于安全管理中的访问控制模型。RBAC模型通过授予用户不同的角色，并将角色与权限进行关联，来管理对资源的访问。
RBAC模型中的关键概念包括以下几个部分：
角色（Role）：角色是一组具有相似职责和权限的用户集合。例如，管理员、编辑、访客等都可以是角色。
权限（Permission）：权限是指执行特定操作或访问特定资源的能力。例如，读取、写入、删除等操作可以被视为不同的权限。
用户（User）：用户是系统中的个体，可以被授予一个或多个角色。
资源（Resource）：资源是系统中受到访问控制的对象。可以是文件、数据库记录、API接口等。
3、Shiro核心组件 用户、角色、权限
会给角色赋予权限、给用户赋予角色
1、UsernamePasswordToken，Shiro用来封装用户登录信息，使用用户的登录信息来创建令牌Token。
2、SecurityManager，Shiro的核心部分，负责安全认证和授权。
3、Subject，Shiro的一个抽象概念，包含了用户信息。
4、Realm，开发者自定义的模块，根据项目的需求，验证和授权的逻辑全部写在Reaim中。
5、AuthenticationInfo，用户的角色信息集合，认证时使用。
6、AuthorzationInfo，角色的权限信息集合，授权时使用。
7、DefaultWebSecurityManager，安全管理器，开发者自定义的Realm需要注入到DefaultWebSecurityManager进行管理才能生效
8、ShiroFilterFactoryBean，过滤器工厂，Shiro的基本运行机制是开发者定制规则，Shiro去运行，具体的执行操作就是由ShiroFilterFactoryBean
Shiro的运行机制如下图所示： 4、Springboot整合Shiro SpringBoot集成Shiro官网：Integrating Apache Shiro into Spring-Boot Applications | Apache Shiro
这里说一下，我从一开始学习就用的Springboot3，而3版本整合shrio出现了Servlet和Shiro不生效等问题。所以还是推荐使用Springboot2的版本去整合Shiro。
不过，后面发现一位大佬把这个问题完美的解决了！！！(膜拜大佬╰(*°▽°*)╯）Java17和springboot3.0使用shiro报ClassNotFoundException_星海蔚蓝的博客-CSDN博客
根据大佬，重新将shiro依赖引入，再去使用Springboot3的版本就没有问题了！！！
即使看懂了上面的概念，你不去看视频教学，下面的代码很难看懂的。所以先去看看教学视频，跟着教学实操。
1、创建Spring Boot应用，集成Shiro及相关组件(这里是我练习模块中的依赖，我直接粘过来的)
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e68bd5550f1506cd9d3f46a9066e938/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00e4b1507205303fec2bbb726cdd098d/" rel="bookmark">
			【C语言】字符函数和内存操作函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是苏貝，本篇博客带大家了解字符函数和内存操作函数，如果你觉得我写的还不错的话，可以给我一个赞👍吗，感谢❤️
目录 一.字符函数1.1 字符分类函数1.2 字符转换函数 二.内存操作函数2.1 memcpy2.2 memmove2.3 memset2.4 memcmp 一.字符函数 1.1 字符分类函数 下面函数的头文件都是&lt;ctype.h&gt;
函数如果他的参数符合下列条件就返回真即非0，不符合则返回0iscntrl任何控制字符isspace空白字符：空格‘ ’，换页‘\f’，换行’\n’，回车‘\r’，制表符’\t’或者垂直制表符’\v’isdigit十进制数字 0~9isxdigit十六进制数字，包括所有十进制数字，小写字母a~ f，大写字母A~ Fislower小写字母a~zisupper大写字母A~Zisalpha字母a~ z 或 A~Zisalnum字母或者数字，a~ z,A~ Z,0~9ispunct标点符号，任何不属于数字或者字母的图形字符（可打印)isgraph任何图形字符isprint任何可打印字符，包括图形字符和空白字符 其实字符分类函数很简单，下面就挑两个作为范例
范例1：
int main() { int ret1 = islower('X');//X不是小写字母，返回0 int ret2 = islower('f');//f是小写字母，返回非0的数 printf("%d %d", ret1, ret2); return 0; } 范例2：
int main() { int ret1 = isxdigit('a');//a是16进制数字 int ret2 = isxdigit('z');//z不是16进制数字，返回0 int ret3 = isxdigit('4');//4是16进制数字 printf("%d %d %d", ret1, ret2, ret3); return 0; } 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00e4b1507205303fec2bbb726cdd098d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a498a9ba56fc17e30dc14ac8ac21fac/" rel="bookmark">
			C语言操作符详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作符目录 1. 算术操作符2. 移位操作符2.1 整数二进制的表现形式2.2 ''&lt;&lt;''左移操作符2.3 "&gt;&gt;''右移操作符 3. 位操作符3.1 ''&amp;''按位与3.2 ''|''按位或3.3 "^''按位异或 4. 赋值操作符5. 单目操作符5.1 单目操作符介绍5.1.1 "!''逻辑反操作符5.1.2 ''-''、''+''负值、正值5.1.3 ''&amp;''取地址符5.1.4 ''~''对一个数的二进制（补码）按位取反5.1.5 ''--''前置、后置"--"、''++''前置、后置"++"5.1.6"*''间接访问操作符(解引用操作符)5.1.7 "(类型)''强制类型转换 5.2 sizeof 和 数组 6. 关系操作符7. 逻辑操作符7.1 "&amp;&amp;''逻辑与7.2 ''||''逻辑或7.3 区分''&amp;&amp;''与"&amp;"、"||"与"|"的作用 8. 条件操作符（三目操作符）9. 逗号表达式10. 下标引用、函数调用和结构成员11. 小结10.1 移位操作符 和 位操作符使用小技巧：10.2 ---&gt;[布尔值、false、true](https://editor.csdn.net/md?articleId=130754246)10.3 关于操作符"&amp;&amp;"和"||"的短路现象 1. 算术操作符 + -	*	/	% 除了 % 操作符之外，其他的几个操作符可以作用于整数和浮点数。
对于 / 操作符如果两个操作数都为整数，执行整数除法。而只要有浮点数执行的就是浮点数除法。
% 操作符的两个操作数必须为整数。返回的是整除之后的余数。
2. 移位操作符 2.1 整数二进制的表现形式 有三种表现形式：原码、反码、补码
（正整数的原码、反码、补码都是相同的）
（负整数的原码、反码、补码是要计算的）原码：根据正负直接写出的二进制序列就是原码
（不管正整数还是负整数都可以直接写出二进制原码）反码：原码的符号位（0为正1为负）不变，其他的按位取反，得到的就是反码补码：反码+1就是补码
（整数在内存中存储的是补码）
（计算机也是用补码计算的）1个整数是4个字节 = 32 bit位 正整数：10 原码：00000000000000000000000000001010 反码：00000000000000000000000000001010 补码：00000000000000000000000000001010 负整数：-10 原码：10000000000000000000000000001010 反码：11111111111111111111111111110101 补码：11111111111111111111111111110110 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a498a9ba56fc17e30dc14ac8ac21fac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/757549d0b172e775624f3863dda26a94/" rel="bookmark">
			一文搞懂C&#43;&#43;常见运算符优先级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一文搞懂C++常见运算符优先级 文章目录 一文搞懂C++常见运算符优先级结论前置&amp;后置递增和递减前置&amp;后置递增和递减出现在同一表达式的优先级 四则运算例题检测 (理解后可以直接到这里做题) 对于初学 C++ 的同学来说，第一个让人混乱的便是 C++ 中复杂的算术表达式。下面是一个简单的例子：
例题1：int a = 1; int b = 2; int c = 3; int d = 4; int e = 5; int result = a + b * c / d - e; //result = -3 例题2：int a = 5; int b = 2; int c = ++a + b++ * 2; //c = 10 int d = a++ + (++b) * 2; //d = 14 看完结果之后你可能不相信我写的答案，没关系！实践出真知，下面为运行结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/757549d0b172e775624f3863dda26a94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aed8ac011bbf4b988c42565abddf0571/" rel="bookmark">
			ffmpeg视频转码（支持.qsv爱奇艺视频文件等格式的文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ffmpeg下载
Download FFmpeg
下载完后进入 cmd
视频转码（支持.qsv文件）
ffmpeg -i input.avm output.mp4
视频转码并截取其中一段
开始时间 截取时长（min）
ffmpeg -ss 00:00:00 -i input.mp4 -c copy -t 60 output.mp4
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15cd09297e4946c63b772f12e2774a07/" rel="bookmark">
			C# 调用Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介
IronPython 是一种在 NET 和 Mono 上实现的 Python 语言，由 Jim Hugunin（同时也是 Jython 创造者）所创造。
Python是一种跨平台的计算机程序设计语言。 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。
Python是一种解释型脚本语言，可以应用于以下领域：
● 科学计算和统计
● 人工智能
● 桌面界面开发
● 软件开发
● 后端开发
● 网络爬虫
二、创建 C# 项目
新建一个 Winform 项目 CSharpCallPython
为了更方便的看到控制台打印的效果，在 项目属性 --&gt; 应用程序 将输出类型改为控制台输出
三、C# 调用 Python
1.IronPython 插件
在 NuGet 中安装 IronPython 插件
在项目的 Debug 目录下添加一个 Python 脚本 test.py ，
在 test.py 中添加下面的代码：
def sayHi():
print("f**k you")
def add(x,y):
try:
return x + y
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15cd09297e4946c63b772f12e2774a07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c63734a13916db5ae2069fa369ee3bd8/" rel="bookmark">
			【Android网络请求】 OkHttp &#43; Retrofit 响应数据过长，导致精度丢失的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【问题描述】
使用简易版的 OkHttp + Retrofit 请求网络数据时，响应数据的id结果是一串超长的字符。拿到id后继续请求查询接口，发现查不到数据，百思不得其解，逐一向上排查发现是精度丢失的问题（文字描述看不清？那就直接上图）
PostMan接口响应数据（美化后）
PostMan接口响应数据（原生数据）
As打印的log数据 （直接变成了科学计数法显示）
【排查定位】
发现数据显示异常的原因在于我的Retrofit配置错了，解析Json的框架用了GSON解析，但是在拿到响应数据后，我又用了FastJosn解析，导致数据解析出错了
【END】
附上FastjsonConverter2Factory配置类信息~
/** * @Author: Bean * @Date: 2023-09-21 20:06 * @Description: FastJson解析配置类 */ public class FastjsonConverter2Factory extends Converter.Factory { public static FastjsonConverter2Factory create() { return new FastjsonConverter2Factory(); } private FastjsonConverter2Factory() { } @Override public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) { return new FastjsonResponseBodyConverter&lt;&gt;(type); } @Override public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) { return new FastjsonRequestBodyConverter&lt;&gt;(); } private static class FastjsonResponseBodyConverter&lt;T&gt; implements Converter&lt;ResponseBody, T&gt; { private final Type type; FastjsonResponseBodyConverter(Type type) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c63734a13916db5ae2069fa369ee3bd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f4e3be298e717fc5e3cda0e5af336de/" rel="bookmark">
			矩阵键盘的扫描原理与基础应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 基础知识 原理图 首先需要先将 J5 跳帽放到1和2之间。
表示选择的是矩阵键盘。
简化原理图 扫描原理：
以左上角按键为例。
先向 R1 输出低电平，向 R2，R3，R4 输出高电平。
再然后向 C1，C2，C3，C4 输出高电平，然后再读取这四个引脚上的电平。
若某一个引脚为低电平，则说明某一个按键被按下。
代码 #include &lt;reg52.h&gt; #define uint unsigned int #define uchar unsigned char // P4引脚，头文件没有定义，需要自行定义 sfr P4 = 0xC0; // 根据原理图来定义 sbit R1 = P3 ^ 0; sbit R2 = P3 ^ 1; sbit R3 = P3 ^ 2; sbit R4 = P3 ^ 3; // 根据原理图来定义 sbit C4 = P3 ^ 4; sbit C3 = P3 ^ 5; sbit C2 = P4 ^ 2; sbit C1 = P4 ^ 4; // 数码管的段码 uchar code SMG_duanma[18] = {0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 0x80, 0x90, 0x88, 0x83, 0xc6, 0xa1, 0x86, 0x8e, 0xbf, 0x7f}; // 选通HC138的某个信道 void HC138(uchar channel) { switch(channel) { case 4: P2 = (P2 &amp; 0x1f) | 0x80; break; case 5: P2 = (P2 &amp; 0x1f) | 0xa0; break; case 6: P2 = (P2 &amp; 0x1f) | 0xc0; break; case 7: P2 = (P2 &amp; 0x1f) | 0xe0; break; } } // 数码管展示value这个数值 void DisplayKeyNum(uchar value) { HC138(6); P0 = 0x01; HC138(7); P0 = value; } // 判断扫描的按键 uchar key_num; // 扫描键盘函数 void ScanKeysMulti() { // 判断第一行的按键 R1 = 0; R2 = R3 = R4 = 1; // 先向引脚输出高电平 C1 = C2 = C3 = C4 = 1; // 然后再检测哪个为低电平 if (C1 == 0) { // 等松手之后再进行判断 while (C1 == 0); key_num = 0; // 展示数码 DisplayKeyNum(SMG_duanma[key_num]); } else if (C2 == 0) { while(C2 == 0); key_num = 1; DisplayKeyNum(SMG_duanma[key_num]); } else if (C3 == 0) { while(C3 == 0); key_num = 2; DisplayKeyNum(SMG_duanma[key_num]); } else if (C4 == 0) { while(C4 == 0); key_num = 3; DisplayKeyNum(SMG_duanma[key_num]); } // 判断第二行的按键 R2 = 0; R1 = R3 = R4 = 1; C1 = C2 = C3 = C4 = 1; if (C1 == 0) { while (C1 == 0); key_num = 4; DisplayKeyNum(SMG_duanma[key_num]); } else if (C2 == 0) { while(C2 == 0); key_num = 5; DisplayKeyNum(SMG_duanma[key_num]); } else if (C3 == 0) { while(C3 == 0); key_num = 6; DisplayKeyNum(SMG_duanma[key_num]); } else if (C4 == 0) { while(C4 == 0); key_num = 7; DisplayKeyNum(SMG_duanma[key_num]); } // 判断第三行的按键 R3 = 0; R1 = R2 = R4 = 1; C1 = C2 = C3 = C4 = 1; if (C1 == 0) { while (C1 == 0); key_num = 8; DisplayKeyNum(SMG_duanma[key_num]); } else if (C2 == 0) { while(C2 == 0); key_num = 9; DisplayKeyNum(SMG_duanma[key_num]); } else if (C3 == 0) { while(C3 == 0); key_num = 10; DisplayKeyNum(SMG_duanma[key_num]); } else if (C4 == 0) { while(C4 == 0); key_num = 11; DisplayKeyNum(SMG_duanma[key_num]); } // 判断第四行的按键 R4 = 0; R2 = R3 = R1 = 1; C1 = C2 = C3 = C4 = 1; if (C1 == 0) { while (C1 == 0); key_num = 12; DisplayKeyNum(SMG_duanma[key_num]); } else if (C2 == 0) { while(C2 == 0); key_num = 13; DisplayKeyNum(SMG_duanma[key_num]); } else if (C3 == 0) { while(C3 == 0); key_num = 14; DisplayKeyNum(SMG_duanma[key_num]); } else if (C4 == 0) { while(C4 == 0); key_num = 15; DisplayKeyNum(SMG_duanma[key_num]); } } void main() { while(1) { ScanKeysMulti(); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4f670859b16ea57d4a2e5ea985fe9e7/" rel="bookmark">
			因子分析 FA | Factor Analysis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、因子分析是什么？
二、因子分析的优点和缺点
三、因子分析的应用场景
四、构建因子分析模型的注意事项
五、因子分析模型的实现类库
六、因子分析模型的评价指标
七、类库factor_analyzer实现因子分析的例子
八、因子分析的模型参数
总结
前言 因子分析是机器学习中无监督学习的一种降维算法。
一、因子分析是什么？ 因子分析是无监督机器学习中降维的一种，是一种数据简化技术。旨在用少量的潜在变量或因子描述可观测的变量，也称公因子分析。
通过观测变量的线性组合，来解释观测变量的共有变异，对观测变量做出有意义的解释，减少变量数。基本思想是根据相关性大小把变量分组，使得同组内的变量之间相关性较高，但不同组的变量不相关或相关性较低，每组变量代表一个基本结构即公共因子。
因子分析分为探索性因子分析和确认行因子分析。
探索性因子分析：事前不对因子之间的关系做出任何假设，任何变量都可以与任何因子有关联，这有助于识别变量之间的复杂关系，并根据共同因素对他们进行分组。
确认性因子分析：事前假设变量与特定因子相关，并使用预先建立的理论来确认其对模型的预期。
二、因子分析的优点和缺点 优点： 可以降低数据维度：因子分析算法可以将高维数据降低到低维空间中，从而减少数据的维度，提高计算效率和模型的泛化能力。可以去除冗余信息：因子分析算法可以去除数据中的冗余信息，提取出最重要的特征，从而提高模型的准确率和泛化能力。可以处理多变量问题：因子分析算法可以处理多变量问题，从而提高模型的复杂度和准确率。可以进行数据压缩：因子分析算法可以将数据压缩到较小的空间中，从而减少存储和传输数据的成本。可以处理缺失数据：因子分析算法可以处理缺失数据，从而提高模型的鲁棒性。可解释性强：有助于发现高维变量下的潜在影响因子； 缺点： 需要选择因子个数：因子分析算法需要人为选择因子个数，选择不当可能会导致模型的准确率下降。对数据正态性要求较高：因子分析算法要求数据服从正态分布，如果数据不满足这个条件，则可能导致模型的准确率下降。需要注意的是，在实际应用中，因子分析算法的性能还受到许多其他因素的影响，例如因子旋转、因子载荷等，需要根据具体情况进行调整和优化。 三、因子分析的应用场景 因子分析是一种常见的数据降维和变量分析技术，其应用场景包括但不限于以下几个方面：
心理学：因子分析可以用于心理学中，将多个相关的心理测量指标降维成少数几个无关的因子，从而更好地进行心理测量和分析。市场调查：因子分析可以用于市场调查中，将多个相关的市场调查指标降维成少数几个无关的因子，从而更好地进行市场调查和分析。金融风险管理：因子分析可以用于金融风险管理中，将多个相关的资产数据降维成少数几个无关的因子，从而更好地进行风险管理和投资决策。医学诊断：因子分析可以用于医学诊断中，将多个相关的生理指标降维成少数几个无关的因子，从而更好地进行疾病诊断和治疗。教育评估：因子分析可以用于教育评估中，将多个相关的教育指标降维成少数几个无关的因子，从而更好地进行教育评估和改进。人口统计学：因子分析可以用于人口统计学中，将多个相关的人口指标降维成少数几个无关的因子，从而更好地进行人口统计和分析。图像处理：因子分析可以用于图像处理中，将多个相关的图像特征降维成少数几个无关的因子，从而更好地进行图像处理和分析。机器学习：因子分析可以用于机器学习中，将多个相关的特征数据降维成少数几个无关的因子，从而更好地进行模型训练和预测。社交网络分析：因子分析可以用于社交网络分析中，将多个相关的社交网络数据降维成少数几个无关的因子，从而更好地进行社交网络分析和挖掘。 总之，因子分析是一种非常灵活的数据降维和变量分析技术，可应用于多种领域，特别是需要进行多个变量分析和降维的场景下。
四、构建因子分析模型的注意事项 因子分析的实现步骤包括收集数据，清洗数据，数据转换，适用性检验，计算相关系数矩阵，计算载荷矩阵，选择因子数量，因子旋转，计算因子对变量的得分，计算每个样本实例的因子得分，结果解释等。
其中以下步骤对于因子分析的结果影响较大：
数据转换：对原始数据进行中心标准化等转换，统一量纲；适用性检验：KMO检验（变量之间的相关性检验，取值0-1）和Bartlett球形检验（变量之间是否相互独立的检验，输出P值），变量之间存在一定的相关性才比较适合进行因子分析；选择因子数量：可以依据因子的特征值（通常大于1）或累计方差贡献率（通常大于80%）来确定，也可以借助PCA分析来确定；因子旋转：因子旋转可以是每个因子在特征变量上的方差极端化，也就是拉开各因子之间的差异，以得到最佳的变量分组效果，也便于最终的解释； 五、因子分析模型的实现类库 Python中可以使用多个类库来实现因子分析，以下是其中的几个：
FactorAnalyzer：FactorAnalyzer是一个Python类库，提供了因子分析的实现。它支持多种因子提取方法和旋转方法，并提供了许多用于评估因子分析结果的指标。Statsmodels：Statsmodels是一个Python模块，它提供了许多统计模型和统计测试的功能，包括因子分析。您可以使用该库中的Factor类来拟合因子模型，并使用fit函数来估计因子载荷和因子得分。Scikit-learn：Scikit-learn也提供了因子分析的实现。您可以使用该库中的FactorAnalysis类来拟合因子模型，并使用transform函数来估计因子得分。 这些类库都提供了不同的方法来实现因子分析，您可以根据自己的需要选择合适的方法。
六、因子分析模型的评价指标 因子分析的常见评价指标包括累计方差贡献率、特征值、因子载荷、可解释方差、共同因子比率、残差相关矩阵等。
其中，累计方差贡献率可以用来评价因子对原始变量的解释程度，特征值可以用来评价因子的重要性，因子载荷可以用来评价因子与原始变量之间的关系，可解释方差可以用来评价因子对原始变量方差的解释程度，共同因子比率可以用来评价公共因子和独特因子的比例，残差相关矩阵可以用来评价模型的拟合程度。
七、类库factor_analyzer实现因子分析的例子 from factor_analyzer import FactorAnalyzer from sklearn.datasets import load_iris # 加载数据集 iris = load_iris() df = iris.data # 训练因子分析模型 fa = FactorAnalyzer(n_factors=2, rotation='varimax') fa.fit(df) # 获取因子分析结果 loadings = fa.loadings_ factors = fa.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4f670859b16ea57d4a2e5ea985fe9e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bab87ede709be13e84a56cfa7e54ce5/" rel="bookmark">
			一文教你搞懂Redis集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Redis主从 1.1、搭建主从架构 单节点的Redis的并发能力是有上限的，要进一步的提高Redis的并发能力，据需要大家主从集群，实现读写分离。
共包含三个实例，由于资源有限，所以在一台虚拟机上，开启多个redis的实例，端口不同，下面是具体的配置
IPPORT角色192.168.152.1337001master192.168.152.1337002slave/replica192.168.152.1337003slave/replica 第一步：准备实例和配置 要在同一台虚拟机上开启三个redis实例，就必须要准备三分不同的redis.conf的配置文件，为了方便管理，这里创建三个文件夹，存放不同的配置文件
创建目录 创建出三个分别以端口号命名的文件夹7001，7002，7003
# 进入redis的按照目录 cd /usr/local/bin # 创建目录 mkdir -p 7001 7002 7003 ll 如图：
修改配置文件 修改redis.conf的配置文件，将其中的持久化模式改为开启rdb，关闭aof，并指定ip，端口。
其中如果想要用redis的可视化连接工具链接，还需要关闭保护模式protected-mode no
# 关闭aof appendonly no 思考：为什么要开启rdb模式，关闭aof呢❓
拷贝配置文件到7001，7002，7003 #方式一：逐个拷贝 cp /opt/redis-5/redis.conf ./7001/ cp /opt/redis-5/redis.conf ./7002/ cp /opt/redis-5/redis.conf ./7003/ #方式二：管道操作 echo 7001 7002 7003 | xargs -t -n 1 cp redis-5/redis.conf 修改端口，数据保存目录 sed -i -e 's/6379/7001/g' -e 's/dir .\//dir \/usr\/local\/bin\/7001\//g' ./7001/redis.conf sed -i -e 's/6379/7002/g' -e 's/dir .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bab87ede709be13e84a56cfa7e54ce5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e0ad3aa0f42c8ea61348a4d6b1e992f/" rel="bookmark">
			Spring Boot：实现与数据库的连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步骤 写在前面示例代码定义数据库连接信息添加MySQL驱动依赖创建数据库创建数据源： 控制台输出创建成功 写在前面 spring boot框架的Java项目的优点:
快速开发：Spring Boot提供了一系列的开箱即用的功能和特性，使得开发人员可以快速构建和部署应用程序。简化配置：Spring Boot自动配置了许多常见的配置，如数据源、Web服务器、安全等等，这样开发人员可以专注于业务逻辑的实现，而不是配置。易于部署：Spring Boot可以将应用程序打包成可执行的JAR或WAR文件，这样可以方便地部署到任何支持Java的平台上。易于测试：Spring Boot提供了一系列的测试工具和框架，可以方便地进行单元测试、集成测试和端到端测试。高度可扩展：Spring Boot是基于Spring框架构建的，因此可以利用Spring框架的各种扩展和插件来扩展应用程序的功能。易于维护：Spring Boot提供了一系列的监控和管理工具，可以方便地监控和管理应用程序的状态和性能。生态丰富：Spring Boot拥有庞大的社区和生态系统，有许多第三方库和插件可以与其集成，为开发人员提供了更多的选择和灵活性。 一个spring boot框架的Java项目要实现与数据库的连接，需要以下步骤：
示例代码 定义数据库连接信息 application.properties文件中 #数据源的地址 spring.datasource.url=jdbc:mysql://127.0.0.1:3306/db_boot_base?serverTimezone=GMT%2b8&amp;useUnicode=true&amp;characterEncoding=utf8 spring.datasource.username=root spring.datasource.password= spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.datasource.continue-on-error=false spring.datasource.test-while-idle=true 添加MySQL驱动依赖 pom.xml文件中 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 创建数据库 创建数据源： package hanshuhuan.test.controller.admin.entity.admin; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table; /** * 后台操作日志记录表 * @author shuhu * */ @Entity @Table(name="hansh_operator_logs") public class OperaterLog { @Column(name="id",nullable=false,length=11) @GeneratedValue(strategy=GenerationType.IDENTITY) @Id private Long id;//唯一id @Column(name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e0ad3aa0f42c8ea61348a4d6b1e992f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20f2ad4e7ea3c7e958bef03b9afcacef/" rel="bookmark">
			LCD1602工作原理介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LCD1602液晶显示屏简介 LCD1602（Liquid Crystal Display）是一种工业字符型液晶，能够同时显示16×02即32字符(16列两行)，LCD1602主要用来显示数字、字母、图形以及少量自定义字符。可以显示2行16个字符，拥有16个引脚，其中8位数据总线D0-D7，和RS、R/W、EN三个控制端口，工作电压为5V，并且带有字符对比度调节V0和背光源AK。
LCD1602实物图 LCD1602主要参数 显示字符:16×2个字符工作电压:4.5~5V工作电流:2.0mA工作温度：-20°C~70°C模块最佳工作电压:5.0V单个字符尺寸2.95×4.35（W×Hmm）引脚：16脚 LCD1602引脚功能 引脚1(VSS/GND)：地引脚
引脚2(VDD/VCC)：电源引脚
引脚3(VL)：液晶显示器对比度引脚，接正电源时对比度最弱，接地时对比度最高,使用时可以通过外接一个电位器调整其对比度。
引脚4(RS)：寄存器选择脚，高电平时选择数据寄存器、低电平时选择指令寄存器。
引脚5(R/W)：读(read)/写(write)信号线，高电平时进行读操作，低电平时进行写操作。当RS和R/W共同为低电平时可以写入指令或显示地址；当RS为低电平，R/W为高电平时，可以读忙信号；当RS为高电平，R/W为低电平时，可以写入数据。
引脚6(E)：使能端，当E端由高电平跳变为低电平时，液晶模块执行命令。
引脚7-14(D0~D7)： 8位双向数据线 用于单片机向1602写入数据和从1602读取数据
引脚15(BLA)：背光源正极
引脚16(BLK)：背光源负极
LCD1602引脚接线（51单片机） 虽然看到LCD1602的引脚很多，但是总体分下来其实只需要分成三个部分记忆去接线就好了。
第一部分（电源、接地）：这里会分为两组，一组是VDD/GND组，主要给模块供电、另一组是BLA/BLK组，主要给背光源供电。由于VL引脚接地，也将它放在此部分记忆。
注：两组我的写法都是以接5V电源/接地的顺序写的，当然也可以按着引脚说明部分自己注意甄别。
第二部分（IO口）：也就是引脚7-14（D0-D7）由于他是8位双向数据线，所以按照顺序依次接51单片机P0^0引脚-P0^7引脚
第三部分（信号线）：引脚RS（数据命令选择端）、R/W（读写选择端）、E（使能信号）可以随意选择其他IO口接线，这里以我自己写的代码所定义的引脚为例（C代码）：
LCD1602的RAM地址 LCD1602,总共显示为16行2列，对应着32个RAM地址，在使用的时候，需要在哪个位置显示，就写入对应的RAM地址，然后再写入需要的字符，对应就会显示该字符。
下图是LCD1602的内部显示地址
一共32个地址，对应2行16列
如果我要在第二行第一个位置显示字符，它的地址是 40H，那么是否直接写入 40H 就可以将光标定位在第二行第 一个字符的位置呢？
答：这样不行，因为写入显示地址时要求最高位 D7 恒定为高电平 1 所以实 际写入的数据应该是 01000000B(40H) +10000000B(80H)=11000000B(C0H)。
那要显示什么字符呢就需要结课ASCII码表
如上图所示，需要写入哪个字符，就直接设置对应进制码就可以了，比如数字1，代码是0011 0001与ASCII码一致。也就是表中的ASCII码字符的地址和实际的ASCII码字符是一样的。
读时序、写时序及数序参数 以下为读时序和写时序的图以及数序参数。
读时序：
写时序：
数序参数：
写时序代码实现 首先我们先来观察写时序的图，通过时序图来确定代码
在前面引脚功能部分有提到RS引脚为寄存器选择脚，高电平（1）时为选择数据寄存器、低电平（0）时为选择指令寄存器。我们知道液晶显示模块需要先有告诉在显示屏哪个地址显示字符后，再做显示字符操作，选择指令寄存器就是告知模块指令或地址、选择数据寄存器则是写入数据操作。不过要结合R/W来看。
告知模块指令或地址时的写时序中一开始需要让RS = 0，继续观察写时序图我们会发现E一开始也是低电平，R/W一开始可高可低，但是根据后续变化来看，主要实现操作的电平为低电平，所以干脆直接在写时序里全程低电平，即：
RS = 0;
R/W = 0;
EN = 0;//在定义时，将E接口命名成了EN
如图，我们需要延时tsp1的时间为传输数据做准备，而后E会给到一个上升沿，这个时候指令就开始写入LCD中，此刻根据数序参数给到一定的延时后，将E置低电平。
在准备传输数据阶段期间，其实已经开始将指令数据送到数据口D0~D7，所以综合以上时序的解析，代码如下：
注：这个是一个自己写的函数，在主程序中调用，其中char cmd传进来的是需要显示字符的地址，check_busy();这个是读忙的函数，后续会提到，databuffer是之前定义的P0口，其中用到_nop_();做延时作用，它是一个空函数，运行它时大概需要1.085微妙，足够满足数序参数的需求。不过值得注意的是_nop_();需要加头文件#include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20f2ad4e7ea3c7e958bef03b9afcacef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19a387d2cac8d002b0b3d442988596b2/" rel="bookmark">
			12大常用自动化测试工具，请记得转发收藏！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用自动化测试工具
1、Appium AppUI自动化测试
Appium 是一个移动端自动化测试开源工具，支持iOS 和Android 平台，支持Python、Java 等语言，即同一套Java 或Python 脚本可以同时运行在iOS 和Android平台，Appium 是一个C/S 架构，核心是一个 Web 服务器，它提供了一套 REST 的接口。当收到客户端的连接后，就会监听到命令，然后在移动设备上执行这些命令，最后将执行结果放在 HTTP 响应中返还给客户端
2、Selenium WebUI自动化测试
Selenium是一个用于Web应用程序测试的工具，Selenium已经成为Web自动化测试工程师的首选。Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。支持的浏览器包括IE(7、8、9)、Mozilla Firefox、Mozilla Suite等。这个工具的主要功能包括：测试与浏览器的兼容性——测试你的应用程序看是否能够很好得工作在不同浏览器和操作系统之上。测试系统功能——创建回归测试检验软件功能和用户需求。支持自动录制动作和自动生成 .Net、Java、Perl等不同语言的测试脚本。Selenium 是ThoughtWorks专门为Web应用程序编写的一个验收测试工具。其升级版本为Webdriver
3、Postman 接口测试
Postman 提供功能强大的 Web API 和 HTTP 请求的调试，它能够发送任何类型的HTTP 请求 (GET, POST, PUT, DELETE…)，并且能附带任何数量的参数和 Headers。不仅如此，它还提供测试数据和环境配置数据的导入导出，付费的 Post Cloud 用户还能够创建自己的 Team Library 用来团队协作式的测试，并能够将自己的测试收藏夹和用例数据分享给团队
4、Soapui 接口测试
SoapUI提供了所有所需的工具来测试和完善的测试。总览标签给你一个项目的所有内容和全面的看法。只需一次点击，您可以添加任何数量的断言为验证传入的消息TestStep。使用功能强大的HTTP监视器记录，分析甚至修改客户机 - 服务器通信，因为它发生。和SoapUI临带来了更专业和先进的功能，保持遥遥领先其他测试工具。轻松创建和运行数据驱动测试。该数据源TestStep读取测试数据从任何外部来源 - Excel中，XML，JDBC，文件，等等 - 到标准SoapUI属性
现在我也找了很多测试的朋友，做了一个分享技术的交流群，共享了很多我们收集的技术文档和视频教程。 如果你不想再体验自学时找不到资源，没人解答问题，坚持几天便放弃的感受 可以加入我们一起交流。而且还有很多在自动化，性能，安全，测试开发等等方面有一定建树的技术大牛 分享他们的经验，还会分享很多直播讲座和技术沙龙 可以免费学习！划重点！开源的！！！ qq群号：110685036 5、Robot Framework
Robot Framework是一款python编写的功能自动化测试框架。具备良好的可扩展性，支持关键字驱动，可以同时测试多种类型的客户端或者接口，可以进行分布式测试执行。主要用于轮次很多的验收测试和验收测试驱动开发。
Robot framework为不同的自动化测试需求提供了不同的框架。它的测试能力可以通过 Python 和 Java 测试库得到扩展。Selenium WebDriver 是 Robot Framework 中内置的流行库。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19a387d2cac8d002b0b3d442988596b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42c4bffece9e1b05faa99436378152cc/" rel="bookmark">
			【Node.js操作SQLite指南】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Node.js操作SQLite指南 在本篇博客中，我们将学习如何在Node.js中操作SQLite数据库。我们将使用sqlite3模块来创建数据库、创建表以及进行数据的增删改查操作。
文章目录 Node.js操作SQLite指南安装sqlite3模块创建数据库创建表数据的增删改查插入数据查询数据更新数据删除数据 关闭数据库连接SQLite3的Node.js工具类 安装sqlite3模块 首先，我们需要安装sqlite3模块。在终端中运行以下命令来安装sqlite3模块：
npm install sqlite3 创建数据库 使用sqlite3模块创建一个数据库连接，并创建一个数据库文件。以下是示例代码：
const sqlite3 = require('sqlite3').verbose(); // 创建数据库连接 const db = new sqlite3.Database('mydatabase.db'); 创建表 使用SQL语句在数据库中创建表。以下是示例代码：
// 创建表 db.run(`CREATE TABLE IF NOT EXISTS users ( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, age INTEGER )`); 数据的增删改查 使用SQL语句执行数据的增删改查操作。以下是一些示例代码：
插入数据 // 插入数据 db.run(`INSERT INTO users (name, age) VALUES ('John Doe', 25)`); 查询数据 // 查询数据 db.all(`SELECT * FROM users`, (err, rows) =&gt; { if (err) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42c4bffece9e1b05faa99436378152cc/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/26/">«</a>
	<span class="pagination__item pagination__item--current">27/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/28/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>