<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67930f529125879c025feb1ac39876cc/" rel="bookmark">
			【AAAI 2021】Document-Level RE with Adaptive Thresholding and Localized Context Pooling
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【AAAI 2021】Document-Level Relation Extraction with Adaptive Thresholding and Localized Context Pooling 论文：https://ojs.aaai.org/index.php/AAAI/article/view/17717
代码： https://github.com/wzhouad/ATLOP
Abstract 与句子级关系提取相比，文档级关系提取提出了新的挑战。一个文档通常包含多个实体对，并且一个实体对在与多个可能关系相关联的文档中多次出现。在本文中，我们提出了两种新的技术，自适应阈值和局部上下文池化，来解决多标签和多实体问题。自适应阈值化用可学习的实体相关阈值代替了先前工作中用于多标签分类的全局阈值。本地化的上下文池化直接将注意力从预先训练的语言模型转移到定位有助于确定关系的相关上下文。我们在三个文档级RE基准数据集上进行了实验：最近发布的大规模RE数据集DocRED，以及生物医学领域的两个数据集CDR和GDA。我们的ATLOP模型在DocRED的F1得分为63.4，在CDR和GDA方面也显著优于现有模型。
Introduction 文档级关系抽取和句子级关系抽取的对比：句子级关系抽取：一个句子仅包含一个实体对需要分类；文档级关系抽取：一个文档包含多个实体对，我们需要同时对它们之间的关系进行分类。它要求RE模型识别并关注具有特定实体对的相关上下文的文档部分。此外，一个实体对可以在与文档级别RE的不同关系相关联的文档中多次出现，与句子级别RE的每个实体对一个关系形成对比。文档级关系提取的这种多实体（要在文档中分类的多个实体对）和多标签（特定实体对的多个关系类型）特性使其比句子级的对应项更难提取。图1很好地展示了文档级关系抽取的困难。
然而，由于基于Transformer的模型可以隐式地对长距离依赖性进行建模，尚不清楚图结构是否仍有助于预训练的语言模型（如BERT）。也有一些方法可以在不引入图结构的情况下直接应用预训练的语言模型。他们简单地对实体标记的嵌入进行平均以获得实体嵌入，并将其输入分类器以获得关系标签。然而，每个实体在不同的实体对中都有相同的表示，这可能会带来来自无关上下文的噪声。
在本文中，我们提出了一种本地化的上下文池技术，而不是引入图结构。该技术解决了对所有实体对使用相同实体嵌入的问题。它通过与当前实体对相关的附加上下文来增强实体嵌入。我们没有从头开始训练新的上下文注意力层，而是直接从预训练的语言模型中转移注意力头来获得实体级的注意力。然后，对于一对中的两个实体，我们通过乘法将它们的注意力合并，以找到对它们都重要的上下文。
对于多标签问题，现有的方法将其简化为二分类问题。在训练之后，将全局阈值应用于类概率以获得关系标签。该方法涉及启发式阈值调整，并在来自验证数据的调整阈值可能不是所有实例的最优阈值时引入决策错误。
在本文中，我们提出了自适应阈值技术，用可学习的阈值类代替全局阈值。阈值类是用我们的自适应阈值损失来学习的，这是一种基于秩的损失，在模型训练中，它将正类的logits推到阈值之上，并将负类的logit拉到阈值之下。在测试时，我们返回logits高于阈值类的类作为预测标签，或者如果不存在此类，则返回NA。这种技术消除了对阈值调整的需要，并且还使阈值可针对不同的实体对进行调整，从而获得更好的结果。
本文的主要贡献：
我们提出了自适应阈值损失，这使得能够学习依赖于实体对的自适应阈值，并减少了使用全局阈值引起的决策误差。我们提出了本地化的上下文池化技术，它将预训练的注意力转移到抓取实体对的相关上下文，以获得更好的实体表示。我们在三个公共文档级别的关系提取数据集上进行了实验。实验结果证明了我们的TLOP模型的有效性，该模型在三个基准数据集上实现了最先进的性能。 Problem Formulation 给出一个文档 d d d和一系列的实体 { e i } i = 1 n \{ e_i \}_{i=1}^n {ei​}i=1n​，文档级关系抽取的任务是预测所有实体对 ( e s , e o ) s , o = 1 … n ; s ≠ o (e_s,e_o)_{s,o=1 \dots n;s \ne o} (es​,eo​)s,o=1…n;s=o​存在的关系 R ∪ { N A } \mathcal{R} \cup \{ NA \} R∪{NA}。一个实体 e i e_i ei​可能通过提及 { m j i } j = 1 N e i \{ m_j^i \}_{j=1}^{N_{e_i}} {mji​}j=1Nei​​​在文档中出现多次。如果实体对 ( e s , e o ) (e_s,e_o) (es​,eo​)之间的关系通过它们的任何一对提及来表达，那么它就存在。不表达任何关系的实体对被标记为NA。在测试时，模型需要预测文档 d d d中所有实体对 ( e s , e o ) s , o = 1 … n ; s ≠ o (e_s,e_o)_{s,o=1 \dots n;s \ne o} (es​,eo​)s,o=1…n;s=o​。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67930f529125879c025feb1ac39876cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/867497ebcd317ca8f86ce4d4cfa40318/" rel="bookmark">
			matlab画一张风速时程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		clear
clc
close all
% 设置参数
Fs = 100; % 采样率（赫兹）
T = 10; % 信号持续时间（秒）
t = 0:1/Fs:T-1/Fs; % 时间向量
% 生成非均匀风速信号
mean_wind_speed = 5; % 平均风速（米/秒）
wind_speed_variation = 2; % 风速波动范围（标准差）
wind_speed = mean_wind_speed + wind_speed_variation * randn(size(t)); % 正态分布随机噪声
% 进行风速信号的频谱分析
figure;
subplot(3,1,1);
plot(t, wind_speed);
title('原始风速信号');
xlabel('时间（秒）');
ylabel('风速（米/秒）');
subplot(3,1,2);
[pxx, f] = pwelch(wind_speed, [], [], [], Fs);
semilogx(f, 10*log10(pxx)); % 使用log10为底的对数坐标
title('风速信号功率谱密度');
xlabel('频率（赫兹）');
ylabel('功率谱密度 (dB/Hz)');
% 对风速信号进行滤波处理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/867497ebcd317ca8f86ce4d4cfa40318/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76742140783a703fe5e1dd65116bcf62/" rel="bookmark">
			创建进程、进程终止、进程等待及进程一些概念的补充
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建进程——fork函数 在linux中fork函数是非常重要的函数，它从已存在进程中创建一个新进程。新进程为子进程，而原进程为父进程。
1.fork函数 头文件
#include &lt;unisted.h&gt;
函数
pid_t fork(void)
返回值
fork函数调用成功，返回两次
返回值为0 代表当前进程是子进程
返回值为非负数（id） 代表当前进程是父进程
调用失败，返回-1
fork返回的值又叫pid，全称叫进程标识符，每个进程都有一个非负整数表示的唯一ID，叫做pid
pid=0：交换进程（swapper） 作用：进程调度
pid=1：init进程 作用：系统初始化
示例代码如下
int main(void) { pid_t pid; printf("Before: pid is %d\n", getpid()); if ((pid = fork()) == -1)perror("fork()"), exit(1); printf("After:pid is %d, fork return %d\n", getpid(), pid); sleep(1); return 0; } 运行结果： [root@localhost linux]# . / a.out Before : pid is 43676 After : pid is 43676, fork return 43677 After : pid is 43677, fork return 0 我们可以从上面的代码发现，在使用fork之后，pid的值出现了两种分别是43676、43677，但是其中有一项与没使用fork时，一样，用下面一张图来对其进行解释。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76742140783a703fe5e1dd65116bcf62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a4eca09ac084c10d19dbfb0275eefaf/" rel="bookmark">
			Vue基知识六
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 vuex 1.1 简介 在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。
1.2 何时使用？ 多个组件需要共享数据时，即
多个组件依赖于同一状态来自不同组件的行为需要变更同一状态 1.3 案例 纯vue实现
Count.vue
&lt;template&gt; &lt;div&gt; &lt;h1&gt;当前求和为：{{sum}}&lt;/h1&gt; &lt;!--.number表示里边的数据类型是number的--&gt; &lt;select v-model.number="n"&gt; &lt;option value="1"&gt;1&lt;/option&gt; &lt;option value="2"&gt;2&lt;/option&gt; &lt;option value="3"&gt;3&lt;/option&gt; &lt;/select&gt; &lt;button @click="increment"&gt;+&lt;/button&gt; &lt;button @click="decrement"&gt;-&lt;/button&gt; &lt;button @click="incrementOdd"&gt;当前求和为奇数再加&lt;/button&gt; &lt;button @click="incrementWait"&gt;等一等再加&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name:'Count', data() { return { n:1, //用户选择的数字 sum:0 //当前的和 } }, methods: { increment(){ this.sum += this.n }, decrement(){ this.sum -= this.n }, incrementOdd(){ if(this.sum % 2){ this.sum += this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a4eca09ac084c10d19dbfb0275eefaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f66433203b7ec9433133585397d7ae0b/" rel="bookmark">
			yarn install 提示 Error: certificate has expired
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 网上找的后台开源模板安装依赖报错 问题大概率是因为开了代理服务器访问。
解决办法是关闭代理
yarn config set "strict-ssl" false -g 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/203e62559375da07b4e58cb6666c907f/" rel="bookmark">
			数学分析(六)-微分中值定理及其应用03：泰勒公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		§ 3 § 3 §3 泰勒公式
多项式函数是各类函数中最简单的一种,
用多项式逼近函数是近似计算和理论分析的一个重要内容.
一、带有佩亚诺型余项的泰勒公式
我们在学习导数和微分概念时已经知道, 如果函数 f f f 在点 x 0 x_{0} x0​ 可导, 则有
f ( x ) = f ( x 0 ) + f ′ ( x 0 ) ( x − x 0 ) + o ( x − x 0 ) . f(x)=f\left(x_{0}\right)+f^{\prime}\left(x_{0}\right)\left(x-x_{0}\right)+o\left(x-x_{0}\right) . f(x)=f(x0​)+f′(x0​)(x−x0​)+o(x−x0​).
即在点 x 0 x_{0} x0​ 附近, 用一次多项式
f ( x 0 ) + f ′ ( x 0 ) ( x − x 0 ) f\left(x_{0}\right)+f^{\prime}\left(x_{0}\right)\left(x-x_{0}\right) f(x0​)+f′(x0​)(x−x0​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/203e62559375da07b4e58cb6666c907f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99524d7056def67b8f44008d321f25c0/" rel="bookmark">
			数学分析(六)-微分中值定理及其应用01：拉格朗日定理和函数的单调性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		§ 1 拉格朗日定理和函数的单调性
在这一章里, 我们要讨论怎样由导数 f ′ f^{\prime} f′ 的已知性质来推断函数 f f f
所应具有的性质.微分中值定理（包括罗尔定理、拉格朗日定理、柯西定理、泰勒定理）正是进行这一讨论的有效工具.
本节首先介绍拉格朗日定理以及它的预备定理一一罗尔定理,并用此讨论函数的单调性.
一、罗尔定理与拉格朗日定理
定理 6.1 (罗尔 (Rolle) 中值定理) 若函数 f f f 满足如下条件:
(i) f f f 在闭区间 [ a , b ] [a, b] [a,b] 上连续;
(ii) f f f 在开区间 ( a , b ) (a, b) (a,b) 上可导;
(iii) f ( a ) = f ( b ) f(a)=f(b) f(a)=f(b),
则在 ( a , b ) (a, b) (a,b) 上至少存在一点 ξ \xi ξ, 使得
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99524d7056def67b8f44008d321f25c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd046b3f12a7ee1419ef6ab4d8246ad3/" rel="bookmark">
			人工智能：更多有用的 Python 库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
推荐
JupyterLab 入门
复杂的矩阵运算
其它人工智能和机器学习的 Python 库
前言 在这篇文章中，我们将了解更多的矩阵操作，同时再介绍几个人工智能 Python 库。
推荐 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站
在进入主题之前，我们先讨论几个人工智能和机器学习中常用的重要术语。人工神经网络(artificial neural network)（通常简称为神经网络(neural network)，NN）是机器学习和深度学习的核心。顾名思义，它是受人脑的生物神经网络启发而设计的计算模型。本文中我没有插入神经网络模型的图片，因为在互联网上很容易找到它们。我相信任何对人工智能感兴趣的人应该都见过它们，左边是输入层，中间是一个或多个隐藏层，右边是输出层。各层之间的边上的权重(weight) 会随着训练不断变化。它是机器学习和深度学习应用成功的关键。
监督学习(supervised learning) 和 无监督学习(unsupervised learning) 是两个重要的机器学习模型。从长远来看，任何立志于从事人工智能或机器学习领域工作的人都需要学习它们，并了解实现它们的各种技术。这里我认为有必要简单说明两种模型之间的区别了。假设有两个人分别叫 A 和 B，他们要把苹果和橘子分成两组。他们从未见过苹果或橘子。他们都通过 100 张苹果和橘子的图片来学习这两种水果的特征（这个过程称为模型的训练）。不过 A 还有照片中哪些是苹果哪些是橘子的额外信息（这个额外信息称为标签）。这里 A 就像是一个监督学习模型，B 就像是无监督学习模型。你认为在是识别苹果和橘子的任务上，谁的效果更好呢？大多数人可能会认为 A 的效果更好。但是根据机器学习的理论，情况并非总是如此。如果这 100 张照片中只有 5 张是苹果，其它都是橘子呢？那么 A 可能根本就不熟悉苹果的特征。或者如果部分标签是错误的呢？在这些情况下，B 的表现可能比 A 更好。
在实际的机器学习应用中会发生这样的情况吗？是的！训练模型用的数据集可能是不充分的或者不完整的。这是两种模型都仍然在人工智能和机器学习领域蓬勃发展的众多原因之一。在后续文章中，我们将更正式地讨论它们。下面我们开始学习使用 JupyterLab，它是一个用于开发人工智能程序的强大工具。
JupyterLab 入门 在本系列的前几篇文章中，为了简单起见，我们一直使用 Linux 终端运行 Python 代码。现在要介绍另一个强大的人工智能工具——JupyterLab。在本系列的第一篇文章中，我们对比了几个候选项，最终决定使用 JupyterLab。它比 Jupyter Notebook 功能更强大，为我们预装了许多库和包，并且易于团队协作。还有一些其它原因，我们将在后续适时探讨它们。
在本系列的第一篇文章中，我们已经学习了如何安装 JupyterLab。假设你已经按文中的步骤安装好了 JupyterLab，使用 jupyter lab 或 jupyter-lab 命令在会默认浏览器（如 Mozilla Firefox、谷歌 Chrome 等）中打开 JupyterLab。（LCTT 译注：没有安装 JupyterLab 也不要紧，你可以先 在线试用 JupyterLabjupyter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd046b3f12a7ee1419ef6ab4d8246ad3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18b724c96bc412d525b03fa543ae4e9f/" rel="bookmark">
			[office] 用VBA禁止使用“另存为”来保存excel工作簿 #职场发展#学习方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用VBA禁止使用“另存为”来保存excel工作簿
如果某个工作簿需要由多人合作，分不同的阶段完成，为了避免其中的某个用户将文件另存为其他文件名而影响下一个使用者，可以用VBA代码禁止用户使用“另存为”来保存工作簿。方法如下：
1.按Alt+F11，打开VBA编辑器，在“工程”窗口中双击“ThisWorkBook”，在右侧的代码窗口中输入下列代码：Private Sub workbook_BeforeSave(ByVal SaveAsUI As Boolean, _
Cancel As Boolean)
Dim response As Long
If SaveAsUI = True Then
response = MsgBox("该工作簿不允许用“另存为”来保存，" &amp; _
"你要用原工作簿名称来保存吗？ ", vbQuestion + vbOKCancel)
Cancel = (response = vbCancel)
If Cancel = False Then Me.Save
Cancel = True
End If
End Sub2.关闭VBA编辑器，保存工作簿。如果是Excel 2007，需保存为xlsm格式。这样，该工作簿只允许通过“保存”命令来保存，当执行“文件→另存为”命令时，将出现不允许使用“另存为”的提示。 单击“确定”按钮将在原文件夹用原名称来保存工作簿，单击“取消”按钮则取消本次操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d17bd3d88fc837dce3f53b5e481af459/" rel="bookmark">
			单片机学习笔记---矩阵键盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
矩阵键盘的介绍
独立按键和矩阵按键的相同之处：
矩阵按键的扫描
代码演示
代码模块化移植
Keil自定义模板步骤：
代码编写
矩阵键盘就是开发板上右下角的这个模块
这一节的代码是基于上一节讲的LCD1602液晶显示屏驱动代码进行的
矩阵键盘的介绍 在键盘中按键数量较多时，为了减少I/O口的占用，通常将按键排列成矩阵形式
采用逐行或逐列的“扫描”，就可以读出任何位置按键的状态。
数码管扫描（输出扫描）
原理：显示第1位→显示第2位→显示第3位→……，然后快速循环这个过程，最终实现所有数码管同时显示的效果
矩阵键盘扫描（输入扫描）
原理：读取第1行(列)→读取第2行(列) →读取第3行(列) → ……，然后快速循环这个过程，最终实现所有按键同时检测的效果
以上两种扫描方式的共性：节省I/O口
独立按键和矩阵按键的相同之处： 独立按键是把按键公共的一端直接接地（低电平0），另一端接在IO口上
然后我们发现矩阵键盘和独立按键有个相似的地方就是如果只看一种一行，将这一整行接地的话，只看这一行两节IO口时，和独立按键的连接方式其实是一样的。
所以矩阵按键可以说是独立按键的复杂版，而独立按键是简单化的版本。
矩阵按键的扫描 比如想要判断第二行，那P16就给0，其他的给1
然后如果P13给0，就是S5按下了，如果P12给0，就是S6按下了，如果P11给0，就是S7按下了，如果P10给0，就是S6按下了。
其实这个和数码管的操作原理差不多，可以理解为上面4个引脚为使能，下面四个为读取，也可以说上面四个是位选，后四个事段选。
同理，如果想要判断第三行，和第四行，那就是P15和P14分别给0
就是这样一行一行读下来，就相当于把键盘扫描一遍。
要注意的一点是，这个P15口会连接到步进电机上，它相当于驱动器（增大输出电流能力的）
然后BZ就连接到蜂鸣器上
我们这个开发板上的蜂鸣器是无源蜂鸣器，所以这个BZ口以一定的频率高低变化，蜂鸣器就会响。
所以我们逐行扫描矩阵按键出现的问题就是蜂鸣器会自己响，并且关不掉，是引脚冲突造成的。
为了避免这个问题，我们可以采用逐列扫描。
怎么逐列扫描呢？
就是反过来，给下面四个IO口赋值，然后读取上面四个IO口
比如我们要判断第一行，就给P13口0，然后其余给1，然后如果P17口给0，就是S1按下了，如果P16给0，就是S5按下了，如果P15给0，就是S9按下了，如果P14给0，就是S13按下了。同理，其他列是一样的方式。
代码演示 接下来开始代码演示：
新建一个工程，写上框架
代码模块化移植 本节用到的所有程序源码文件可以到评论区自取！
我们把上一节用到的四个文件拷贝过来放进这节的工程文件夹中
这个过程就叫做模块化移植
然后我们把这四个文件添加进来
这样我们就可以引用这几个模块化的程序了。
然后我们需要再创建一个矩阵按键的.c和.h文件
这个时候发现只出现了MatrixKey的.c文件，.h文件我们要自己再添加
这样就能看到它的.h文件了
然后双击MatrixKey.h文件，写上防止重复定义的程序
如果嫌每次都写#ifndef这个框架很麻烦的话，可以把它做成一个templates模板
Keil自定义模板步骤： 左栏点击函数模板
可以看到一些已经被定义好的模板，我们也可以自己添加一个
点击右键-构建模板
点击新建模板
填写模板名称
填写模板内容
点击OK
这样就可以使用了
试一下，双击模板名称
框架就自动出来了！
把它补充完整：
.h文件的框架写好之后，可以写.c文件了
代码编写 根据原理图，我们在MatrixKey.c文件上编写一个程序扫描矩阵按键上的每一个按键，实现的效果是：当我们按下某个按键的时候，屏幕上就给我们提示所按下的按键的编号
写好之后在MatrixKey.h文件里面声明一下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d17bd3d88fc837dce3f53b5e481af459/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c51a2d0ef229d74134b999828a883f53/" rel="bookmark">
			QT 信号与槽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基本概念介绍 QT（即Qt）是一个跨平台的C++开发框架，用于创建高性能、可扩展和易于维护的应用程序。QT的核心概念之一就是信号与槽（Signals and Slots）机制。
信号与槽是一种用于对象间通信的机制，通过信号和槽的连接，一个对象可以发出一个信号，而其他对象则通过连接到这个信号的槽来接收并响应该信号。信号和槽可以跨越不同的对象、线程和模块，提供了一种松耦合和灵活的通信方式。
在Qt中，一个类可以定义自己的信号和槽。信号是类内定义的特殊函数，用于向外界发出通知，而槽是接收信号并处理相应事件的函数。通过使用connect()函数，可以将一个信号连接到一个槽上，使得信号被触发时，相关的槽函数会被调用。
二、信号与槽创建图形化方式 2.1方式一 在下面选择信号与槽，点击+号按键
2.2 方式二 三、信号与槽使用代码实现 3.1 自动连接方式 自动生成对应的槽函数
函数widget.h
#ifndef WIDGET_H #define WIDGET_H #include &lt;QWidget&gt; #include &lt;iostream&gt; QT_BEGIN_NAMESPACE namespace Ui { class Widget; } QT_END_NAMESPACE class Widget : public QWidget { Q_OBJECT public: Widget(QWidget *parent = nullptr); ~Widget(); private slots: void on_pushButton_clicked(); private: Ui::Widget *ui; }; #endif // WIDGET_H 函数widget.c
#include "widget.h" #include "ui_widget.h" Widget::Widget(QWidget *parent) : QWidget(parent) , ui(new Ui::Widget) { ui-&gt;setupUi(this); } Widget::~Widget() { delete ui; } void Widget::on_pushButton_clicked() { std::cout &lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c51a2d0ef229d74134b999828a883f53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8d5805fadee0176bf7228b37433d339/" rel="bookmark">
			什么是图形组态软件？可视化组态工具的特点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组态软件的定义 组态软件主要作为SCADA系统及其他控制系统的上位机人机界面的开发平台，为用户提供快速地构建工业自动化系统数据采集和实时监控功能服务。它使用灵活的组态方式，提供快速构建工业自动控制系统监控功能的通用层次的软件工具。
组态软件的组成 组态软件是一种集成化的软件系统，它主要由以下几个部分组成：
人机交互界面 人机界面系统实际上就是所谓的工况模拟动画。在人机界面组态中，要利用组态软件提供的工具，制作出友好的图形界面给控制系统用，其中包括被控过程流程图、曲线图、棒状图、饼状图、趋势图，以及各种按钮、控件等元素。人机界面组态中，除了开发出满足系统要求的人机界面外，还要注意运行系统中画面的显示、操作和管理。
实时数据库 实时数据库是组态软件的数据处理中心，特别是对于大型分布式系统，实时数据库的性能在某种方面就决定了监控软件的性能。它负责实时数据运算与处理、历史数据存储、统计数据处理、报警处理、数据服务请求处理等。实时数据库实质上是一个可统一管理的、支持变结构的、支持实时计算的数据结构模型。在系统运行过程中，各个部件独立地向实时数据库输入和输出数据，并完成自己的差错控制以减少通信信道的传输错误，通过实时数据库交换数据，形成互相关联的整体。因此，实时数据库是系统各个部件及其各种功能性构件的公用数据区。
组态软件的特点 可视化开发设计：组态软件提供了一套完整的工具和库，用户可以通过拖拽、配置和编程等简单操作，快速地构建出满足实际需求的工业自动控制系统监控功能。这大大缩短了开发周期，提高了开发效率。
数据采集与处理：组态软件可以对各种工控设备和传感器进行数据采集，包括温度、压力、流量、位移等物理量，并将采集到的数据转化为可在计算机上处理的格式。
实时监控与控制：组态软件能够实时监控工业生产过程，对设备运行状态、工艺流程等进行监控，并通过图形界面直观地展示给操作人员。同时，它还可以根据预设的控制逻辑或操作员的指令对设备进行控制，确保生产过程的稳定和安全。
数据分析与决策：组态软件可以对采集到的数据进行处理、分析和挖掘，提供各种图表和统计信息，帮助企业了解生产状况、优化工艺参数、提高生产效率。同时，这些数据还可以用于决策支持，为企业制定战略规划和决策提供依据。
系统集成与协同：组态软件可以与其他工业自动化系统集成，实现设备之间的数据共享和协同工作。通过组态软件的集成功能，可以将多个子系统整合为一个统一的整体，实现信息互通和资源共享，提高整个系统的运行效率和可靠性。
安全性与可靠性：组态软件具备完善的安全机制和权限管理功能，可以防止非法访问和数据泄露。同时，它还具有故障诊断和异常处理功能，能够及时发现和解决系统中的问题，确保系统的安全和可靠性。
组态开发工具 Sovit2D简介 Sovit2D是长沙数维图信息科技有限公司自主研发的新一代拖拽式前端可视化产品，可灵活、快捷地设计各类交互式前端常规屏和大屏可视化效果，强大的Web绘图工具，具有广泛的设计功能，提供丰富的行业标准元器件图元库及多行业模板和组件，在浏览器端即可完成便捷的人机交互，简单的拖拽即可完成可视化页面的编排设计，可快速构建现代化的SCADA、HMI、仪表板、IIOT系统等，广泛应用于工业、水利、电力、能源、油气、环境、园区、交通等领域。Sovit2D具有跨平台、简单、高效、与外部系统易对接等特点，最大程度减少企业研发和运维的成本，即便是没有编程基础也可零代码轻松开发实现Web组态、SCADA等。
Sovit2D 功能 私有化部署：消除客户对数据存储安全性的顾虑——在决定Sovit2D技术选型之初，考虑到客户对数据的安全与隐私有顾虑，同时客户需要积累自己的用户行为数据资产，对数据深度应用与功能二次开发，因此我们将私有化部署作为Sovit2D数据的产品核心设计理念。
可视化编辑：支持灵活的自由式布局、组件化的设计使设计更加方便、丰富的组件库涵盖各行业模型组件，用户也可以自定义组件，以及对组件进行属性、数据、动画，事件等设置。用户只需通过简单的拖拉拽及配置几分钟上手就可以快速地制作出一张敏捷数据动态可视化模型页面。
数据源绑定：提供多种数据源与外部系统通过界面配置进行无缝对接，致力于开发人员或用户0代码即可开发数据可视化展示平台。
交互式动效：通过设置实现Web场景中图形的动画效果如旋转、变色、闪烁、心跳、报警、高度变化、水管流动、沿轨道移动等各种动画，让你的页面展现更加的生动。同时这些动画可以通过与后台数据绑定，由数据触发动画的执行，比如可以根据数据的大小控制旋转的速度，根据状态数据切换控制闪烁效果或者报警效果等，以此实现模拟实际运行效果的目的。
第三方集成：提供简洁的集成方式，模型制作发布后，模型访问地址通过或JS简单的几行代码即可引入到第三方系统中。
如果您有项目正在沟通或者正在开发，作为全新一代物联网、工业互联网Web前端可视化组态开发平台，Sovit2D绝对是个不错的选择，目前行业中流行的部分可视化工具，有的专注于可视化报表，有的专注大屏，有的专注于3D……而数维图依据多年开发经验，自主研发了SovitChart、Sovit2D、Sovit3D可视化工具，集报表/大屏、2D组态、三维可视化等于一身，使用更便捷，维护更简单。
相信看到这，大家都有跃跃欲试的冲动。
我们期待着数维图的可视化产品能够与你的业务场景深度结合，助力客户业务高速发展。欢迎大家登陆数维图官网进行免费体验!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/493cd19d656f65d9c37a2e1e0f8eec33/" rel="bookmark">
			c&#43;&#43;实现：把字符串转换成整数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目连接
class Solution { public: int StrToInt(string str) { int sum = 0; int i = 0; int flag = 0;//如果出现负数的情况，标记一下 for (i = 0;i &lt; str.length();i++) { if (i == 0) {//第一位可以是+-或者数字 if ((str[i] &gt;= 49 &amp;&amp; str[i] &lt;= 57))//1-9ascii码是49-57 { sum += (str[i] - 48); } else if (str[i] == '+' || str[i] == '-') { if (str[i] == '-') { flag = 1; } } else { return 0; } } else { if (str[i] &gt;= 49 &amp;&amp; str[i] &lt;= 57)//中途出现数字 { sum *= 10; sum += str[i] - 48; } else {//出现非数字 return 0; } } } if (flag == 1) { sum = 0 - sum; } return sum; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49219fe72586d4f8ba2fe31038ad006f/" rel="bookmark">
			Java获取节假日信息工具类（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022年写的那个不知道由于网站做了改变，导致那个方法获取到的不对，故重新写一个供广大网友参考
import com.alibaba.fastjson.JSONArray; import com.alibaba.fastjson.JSONObject; import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.URL; import java.net.URLConnection; import java.util.Map; import java.util.Set; /** * * ClassName: SaveHoliday.java &lt;br&gt; * Description: 每年保存法定节假日&lt;br&gt; * Create Time: 2024年1月25日&lt;br&gt; */ public class SaveHoliday { public static void main(String[] args) { syncHoliday(); } public static void syncHoliday() { String url = "https://timor.tech/api/holiday/year/"; BufferedReader reader = null; StringBuffer sbf = new StringBuffer(); try { URL realUrl = new URL(url); URLConnection connection = realUrl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49219fe72586d4f8ba2fe31038ad006f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e15f3aa38630c20c1961ce6570c62d8/" rel="bookmark">
			Vue基知识四
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文对前边几章所学习的内容，以案例的形式做一个总结
一 TodoList案例 即待办事项案例，效果如下
1.1 组件化编码流程（通用） 这是编码时的通用流程，以后也可以按照这个流程来写代码（熟悉后这个流程的顺序就无所谓了）
实现静态组件：抽取组件，使用组件实现静态页面效果展示动态数据：
2.1. 数据的类型、名称是什么？
2.2. 数据保存在哪个组件？交互——从绑定事件监听开始 抽取组件
抽取组件时，既不能抽取的太多，也不能抽取太少，需要自己把握；现在我们可以把它拆成三个组件，如下
如果再细拆的话，list里的还可以再拆出一个组件（即共四个组件）
1.2 编码 定义四个组件
MyFooter.vue
&lt;template&gt; &lt;div class="todo-footer" v-show="total"&gt; &lt;label&gt; &lt;!-- &lt;input type="checkbox" :checked="isAll" @change="checkAll"/&gt; --&gt; &lt;input type="checkbox" v-model="isAll"/&gt; &lt;/label&gt; &lt;span&gt; &lt;span&gt;已完成{{doneTotal}}&lt;/span&gt; / 全部{{total}} &lt;/span&gt; &lt;button class="btn btn-danger" @click="clearAll"&gt;清除已完成任务&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name:'MyFooter', props:['todos','checkAllTodo','clearAllTodo'], computed: { //总数 total(){ return this.todos.length }, //已完成数 doneTotal(){ //此处使用reduce方法做条件统计 /* const x = this.todos.reduce((pre,current)=&gt;{ console.log('@',pre,current) return pre + (current.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e15f3aa38630c20c1961ce6570c62d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b5eee2c6d721590fb3b7bb7fff073be/" rel="bookmark">
			C# 实现 Word 加盖骑缝章效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
实现效果
范例运行环境
Office DCOM 配置
设计实现
创建stamp图章类 电子章图片的计算与定位
旋转图片方法
总结 实现效果 在OA的自动化处理系统中，通过审批的最终节点，可能会对WORD文件加盖电子章，比如定位带有指定文字的Range周围加盖电子章，骑缝章，甚至水印图片。比如如下效果图：
范例运行环境 操作系统： Windows Server 2019 DataCenter
操作系统上安装 Office Word 2016 ，客户端使用的 Office Word 2019
.net版本： .netFramework4.7.1 或以上
开发工具：VS2019 C#
Office DCOM 配置 请参考我的文章《C# 读取Word表格到DataSet》有对Office DCOM详细配置介绍，这里不再赘述。 设计实现 创建stamp图章类 导出WORD文件可以传入多个图章类（如果需要的话），图章类主要包括实现如下设置：
1、可设置三种图片（标准的盖章图片、骑缝章图片、水印图片）
2、标准的盖章图片是否显示，不显示则可以只显示骑缝章或水印图片，这个可以模拟多次盖骑缝章的效果
3、定位盖章文字，可以设置一下 x、y的偏移量，以校准指定的模板文件，达到最佳重叠效果。
4、可设置各种章的翻转角度（可随机选取）
示例代码如下： public class stamp { public string stampImageFilename = ""; //盖章图片 public string stampImageFilename2 = ""; //骑缝章图片 public string stampImageFilename3 = ""; //水印章图片 public bool stampImageVisible = true; //主章是否可显示 public string findWord = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b5eee2c6d721590fb3b7bb7fff073be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2adf885166dc33208153e050333ebadc/" rel="bookmark">
			解决pycharm缓存文件过大问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		content.dat.storageData是Pycharm的缓存文件，其作用是为程序运行提供临时数据存储，如果不影响正常使用的情况下是可以删除的。
解决pycharm缓存文件过大问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa2abc860a30c98a677ee78e93292fb0/" rel="bookmark">
			Pycharm Debug时断点不生效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Pycharm调式代码，明明打了断点，但却不生效，并看到如下提示：
pydev debugger: New process is launching (breakpoints won't work in the new process).
pydev debugger: To debug that process please enable 'Attach to subprocess automatically while debugging?' option in the debugger settings.
根据提示，我们可以进行如下设置即可：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/993c346e3eed5ac5aac88d71c0e9fbbf/" rel="bookmark">
			CSDN上传资源出现报错：“资源上传中断，点击下方按钮继续上传该资源”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在上传资源的时候一直报错，查找也没找到合适的方法。
我后来换了一个浏览器就可以了，edge换成了联想浏览器
问题解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d18703f7a2590fcecd7d6316f9ec35de/" rel="bookmark">
			什么是工控软件？一款很火的Web工业控制组态软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着工业4.0和智能制造的发展，工控软件的应用越来越广泛，它们在提高生产效率、降低能耗和减少人力成本等方面发挥着越来越重要的作用。
什么是工控软件？ 工控软件是指用于工业控制系统的软件，主要应用于各种生产过程控制、自动化设备和系统中的监测、控制和优化。
工控软件主要包括嵌入式软件、工业控制组态软件、PLC编程软件等。嵌入式软件是安装在控制系统硬件中的软件，主要用于控制和监测设备的工作状态和参数，如各种传感器、执行器等。工业控制组态软件主要用于构建工业控制系统的人机界面，包括数据采集、监控、报警等功能。PLC编程软件则是用于编写可编程逻辑控制器的程序，实现各种逻辑控制和顺序控制功能。
工控软件从狭义来讲即所谓工业控制软件。自从采用可编程控制器以来，工控软件就成为工业自动化密不可分的一部分，但在实际应用中控制软件并不是孤立的，而是与其它软件相集成才能发挥其应有的作用，所以从广义来讲包括数据采集、人机界面、软件应用、过程控制、数据库、数据通信等，其涵盖的内容也随着技术的发展不断的丰富，从单纯的控制走向与管理融为一体的工厂信息化。
什么是组态？ “组态”的概念是伴随着集散型控制系统(DCS)的出现，开始被广大的生产过程自动化技术人员所熟知。而“组态”的概念最早出现在工业计算机控制中，如DCS(集散控制系统)组态，PLC(可编程控制器)梯形图组态，人机界面生成软件就叫工控组态软件。
官方定义组态为 “配置”、“设定”、“设置”等，是指用户通过类似“搭积木”的简单方式来完成自己所需要的软件功能，而不需要编写计算机程序，也就是所谓的“组态”。
通俗定义组态就是利用软件制作操作画面，监控画面等。这个软件就是组态软件了。因此制作触摸屏的画面的过程也就是一个组态的过程。
什么是组态软件？ 组态软件指一些数据采集与过程控制的专用软件，是面向监控与数据采集(SCADA)的自动控制系统监控层一级的软件平台和开发环境，能以灵活多样的组态方式(而不是编程方式)提供良好的用户开发界面和简捷的使用方法。
什么是Web组态工具？ Web组态工具是指通过浏览器操作组态工具、浏览组态画面，实现工程管理、组态编辑以及组态运行三大功能。通过实现图元组态、可视化图表组态、数据库组态的配置与关联，完成基于Web服务的实时数据监控与服务端的多用户访问等。
例如：数维图科技自研的Sovit2D就是一款功能强大的Web组态软件，基于HTML5标准，采用B/S架构进行开发，支持 2D/3D图形组态，支持 MQTT 协议接入。配置界面可单独发布，可与企业自有平台无缝集成。Sovit2D具有广泛的设计功能，提供丰富的行业标准元器件图元库及多行业模板和组件，在浏览器端即可完成便捷的人机交互，简单的拖拽即可完成可视化页面的编排设计，可快速构建现代化的SCADA、HMI、仪表板、IIOT系统等，广泛应用于工业、水利、电力、能源、油气、环境、园区、交通等领域。
综上所述，组态软件是工业控制系统中不可或缺的一部分，它为工业自动化提供了强大的支持，简化了开发过程，提高了生产效率。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/16/">«</a>
	<span class="pagination__item pagination__item--current">17/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/18/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>