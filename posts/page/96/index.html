<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/248b4e9fbf1c3954b5d2563b63b4fefa/" rel="bookmark">
			python-将多个空列添加到pandas DataFrame
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python-将多个空列添加到pandas DataFrame
转自：https://www.itranslater.com/qa/details/2582599586510537728
https://blog.csdn.net/zx1245773445/article/details/99445332
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9bc830f3d318a31b1fd472c391b37ef/" rel="bookmark">
			引用在链表删除结点的巧妙用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近复习到数据结构的链表部分，做到了一道题，题目为设计一个递归算法，删除不带头结点的单链表L中所有值为x的结点。
在答案中，可以看到当删除结点时，是令L=L-&gt;next，随后直接free了p指针。猛然一看，可能就会很迷惑为什么没有更改删除结点前驱结点的next，直接就free了，这样不会造成断链吗？
但是大家仔细观察该函数的形参，第一个参数为引用类型，引用也就相当于我有一个物品a，我又给它起了个名字叫做b，本质上是一个东西，只是名字进行了改变。这样对于前驱结点的next赋值有什么用呢？
用处在于，在else语句中，在当前结点的data值不为x时，我们递归调用Del_X_3函数的时候，传递的参数是当前结点的next，也就是说，我们在这种情况下，所调用的实参&amp;L，只是前驱结点的另一个名字而已。为了便于理解，我们暂且假设当前结点的名字为A，且A结点的data值不为x，下一个结点B的data值为x，所以在A结点执行else中递归调用Del_X_3函数的时候，我们将A-&gt;next作为参数，传入了函数，接着继续执行递归调用的函数，此时当前结点转换为B，由于B的data值前提中假设为x，所以执行if语句中的L=L-&gt;next语句，其实就是执行A-&gt;next=A-&gt;next-&gt;next=B-&gt;next，因为当前L的值就是A-&gt;next。这样就完成了对当前结点的前驱结点的next值的更新
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd23eb1a75210a2681ae4a91f8db21ae/" rel="bookmark">
			git 查看当前仓库地址以及设置新的仓库地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.查看当前仓库地址 git remote show origin 2.设置新的仓库地址 git remote set-url origin "新的仓库地址" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e01f5e436a014223271de1b28b35cac9/" rel="bookmark">
			anaconda无法正常创建虚拟环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 之前创建anaconda虚拟环境时经常loading一会儿环境突然又消失了，没有任何报错信息，一直无法正常的创建环境。
解决方案 考虑到加载时间长可能是anaconda默认源比较慢的原因，更换国内清华镜像源。
1、用记事本打开C盘用户文件夹下的.condarc文件进行修改，文件位置如下图所示
2、进入清华镜像站官网，复制如下代码，写入并覆盖到.condarc文件中
channels: - defaults show_channel_urls: true channel_alias: https://mirrors.tuna.tsinghua.edu.cn/anaconda default_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/pro - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2 custom_channels: conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud 3、最后打开anaconda navigator，会显示adding featured channel，等待adding完成后即可正常创建虚拟环境。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a63b762618c7917ae76259d3d8be63f/" rel="bookmark">
			Sklearn Impute SimpleImputer 处理缺失值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sklearn 有专门处理缺失值的模块 sklearn.impute.SimpleImputer，本文将探究如何用 Sklearn 中的预处理模块中的 Impute.SimpleImputer 处理缺失值。
一、模块介绍
官网详解在 part 6.4 Imputation of missing values：https://scikit-learn.org/stable/modules/impute.html
它包含四个重要参数：
二、示例应用
接下来将用实例来讲解如何使用填补缺失值：
1）数据来源及数据基本信息
&gt;&gt;&gt; from sklearn.impute import SimpleImputer &gt;&gt;&gt; import pandas as pd &gt;&gt;&gt; import numpy as np &gt;&gt;&gt; data=pd.read_csv(r'C:\Users\Administrator\Desktop\titanic\train.csv',index_col=0) &gt;&gt;&gt; data.info() &lt;class 'pandas.core.frame.DataFrame'&gt; Int64Index: 891 entries, 1 to 891 Data columns (total 11 columns): Survived 891 non-null int64 Pclass 891 non-null int64 Name 891 non-null object Sex 891 non-null object Age 714 non-null float64 SibSp 891 non-null int64 Parch 891 non-null int64 Ticket 891 non-null object Fare 891 non-null float64 Cabin 204 non-null object Embarked 889 non-null object dtypes: float64(2), int64(4), object(5) memory usage: 83.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a63b762618c7917ae76259d3d8be63f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/738fcc6ef2f74f42456e998fae9535b7/" rel="bookmark">
			7. MySql高级之优化SQL步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 MySql高级之优化SQL步骤1. 查看SQL执行频率2. 定位低效率执行SQL3. explain分析执行计划☆3.1 环境准备3.2 explain 之 id3.3 explain 之 select_type3.4 explain 之 table3.5 explain 之 type3.6 explain 之 key3.7 explain 之 rows3.8 explain 之 extra 4. show profile分析SQL5. trace分析优化器执行计划 ☆ MySql高级之优化SQL步骤 在应用的的开发过程中，由于初期数据量小，开发人员写 SQL 语句时更重视功能上的实现，但是当应用系统正式上线后，随着生产数据量的急剧增长，很多 SQL 语句开始逐渐显露出性能问题，对生产的影响也越来越大，此时这些有问题的 SQL 语句就成为整个系统性能的瓶颈。因此我们必须要对它们进行优化，本文将介绍在 MySQL 中优化 SQL 语句的方法。当面对一个有 SQL 性能问题的数据库时，我们应该从何处入手来进行系统的分析，使得能够尽快定位问题 SQL 并尽快解决问题。 1. 查看SQL执行频率 MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。show [session|global] status 可以根据需要加上参数“session”或者“global”来显示 session 级（当前连接）的计结果和 global 级（自数据库上次启动至今）的统计结果。如果不写，默认使用参数是“session”。 -- 显示了当前 session 中所有统计参数的值： -- 注意是7个_ show status like 'Com_______'; show status like 'Innodb_rows_%'; Com_xxx 表示每个 xxx 语句执行的次数，我们通常比较关心的是以下几个统计参数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/738fcc6ef2f74f42456e998fae9535b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d38bde31ab1d7e984de698feb10e20da/" rel="bookmark">
			为什么spring单例要使用三级缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		熟悉spring框架的同学应该都知道spring单例使用的三级缓存，简单回顾下哪三级缓存，源码类：DefaultSingletonBeanRegistry
一级缓存：singletonObjects二级缓存：earlySingletonObjects三级缓存：singletonFactories 直接使用一级缓存不可以吗？ 一级缓存，也就是直接将单例bean缓存至singletonObjects，去除其他缓存。设想下面这个场景
创建单例A初始化单例A（单例A强依赖单例B），注入单例B从工厂中获取单例B发现不存在，则创建创建单例B初始化单例B（单例B强依赖单例A），注入单例A从工厂中获取单例A发现不存在（因为正在创建中），则创建？？？？？？ 没错，问题来了，循环依赖，死循环，直接凉凉。
直接使用二级缓存不可以吗？ 对于直接使用一级缓存的问题已经暴露，如何解决？那么有同学就要问了，那我在创建单例A时就直接将单例A放入缓存中不可以吗？这样不就解决了循环依赖问题？是的，这样处理是可以的。但是我们如何判断从工厂中获取的一个单例初始化完成了？对单例的所有依赖注入的属性进行一次判空来判断？依赖注入的实例是否完成了初始化？使用工厂中的单例还要各种判空是不是很恶心？增加二级缓存岂不快哉
使用二级缓存：earlySingletonObjects+singletonObjects
创建单例A单例A放入二级缓存：earlySingletonObjects初始化单例A（单例A强依赖单例B），注入单例B从工厂中获取单例B发现不存在，则创建创建单例B单例B放入二级缓存：earlySingletonObjects初始化单例B（单例B强依赖单例A），注入单例A从一级缓存singletonObjects获取单例A，存在则返回，不存在继续查询二级缓存：earlySingletonObjects，如果不存在则创建单例A（此时发现循环依赖抛出异常），但是看到前面已经缓存在二级缓存中注入单例A（可能是未完成初始化的单例A）完成初始化单例B完成，移除二级缓存中的单例B，缓存单例B至一级缓存，返回单例B注入单例B完成初始化单例A完成，移除二级缓存中的单例A，缓存单例A至一级缓存，返回单例A 可以看到我们之前的问题全部迎刃而解，只要从工厂中的一级缓存中获取的单例均是完成了初始化，并且依赖注入的实例也均是完成了初始化，只是如果是循环依赖场景，可能得到的依赖注入时未完成初始化的，即某些依赖注入属性可能为null，例如：@Value注入的一些值。
为什么spring单例要使用三级缓存？ 那么二级缓存已经解决了问题，为什么还要引入三级缓存呢？设想下，如果我想要在读取二级缓存：earlySingletonObjects对象时统一增加一些日志或者其他处理动作，如何解决？在读取earlySingletonObjects对象实例后，对实例进行回调某些接口方法？当然没问题，可以看到spring对于非单例bean也采用该方法来处理前置、后置动作的回调。
else if (mbd.isPrototype()) { // It's a prototype -&gt; create a new instance. Object prototypeInstance = null; try { beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); } finally { afterPrototypeCreation(beanName); } bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); } // getNonSingletonFactoryBeanForTypeCheck方法中也有同样对prototype类型bean的前后置回调处理代码 但是每次修改回调动作都要对所有读取earlySingletonObjects对象的地方进行修改，岂不是很恶心？每次增加一个读取earlySingletonObjects对象的动作都要记得加入相应的回调。是不是很容器遗漏和出错？那么如果我们缓存的是一个接口而不是一个单例对象问题是不是就解决了呢？只需要对接口增加对应的动作即可，例如：
合并bean定义后回调：MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition自定义决定使用哪个构造器构造bean：SmartInstantiationAwareBeanPostProcessor.determineCandidateConstructors创建bean前的属性值处理回调：InstantiationAwareBeanPostProcessor.postProcessPropertyValues创建bean前的处理回调：InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation创建bean后的处理回调：InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation二级缓存bean的处理回调：SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference断言特殊bean的bean类型，例如FactoryBean：SmartInstantiationAwareBeanPostProcessor.predictBeanType 对于循环依赖注入的未完成初始化的单例，如果有特殊需求，期望保证其一些属性的提前注入，可以通过该扩展对提前曝光的对象进行一些个性化定制的处理，例如：将@Value的值提前从Environment中获取并注入到提前曝光的对象。而不需要修改框架代码，只需要增加对应的接口实现即可
总结 循环依赖已经完全解决了吗？并没有，对于构造器注入的循环依赖时无法解决的，这个是无解的#-_-!!!二级缓存是为了解决属性字段级别的循环依赖注入问题三级缓存是为了增强框架的扩展性 Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'a': Unsatisfied dependency expressed through field 'b'; nested exception is org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d38bde31ab1d7e984de698feb10e20da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5b481265e7a0cd3782abf2cce10010e/" rel="bookmark">
			[GCC]告警信息梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		-Wall,-Wextra开启的告警 -Waddress：可能是无意义的地址使用方式(包括函数地址、变量地址等)。 void f (int, int, int, bool, int *); void g (int i) { f (1, 2, 3, &amp;i, &amp;i); } warning: the address of ‘i’ will always evaluate as 'true' [-Waddress] -Warray-bounds：数组越界告警，如数组下标访问越界。 int array[3]; void foo(int n) { // 没有对入参进行校验，可能出现数组访问越界 for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; i; ++j) if (array[i] == array[j]) array[i + j] = 0; } warning: array subscript is above array bounds [-Warray-bounds] -Wbool-compare：布尔值与整形数据比较。 int fn1 (int a, int b) { return ((a &amp;&amp; b) &lt;= 4); } warning: comparison of constant ‘4’ with boolean expression is always true[-Wbool-compare] Wbool-operation：对布尔类型进行加减等操作。 int main(int argc, char **argv) { bool a = true; bool b = a++; bool c = ++b; bool d = argc; bool e = a &amp; argc; bool f = b | argc; bool g = c ^ argc; f &amp;= argc; g |= argc; e ^= argc; if (f1(argc)) e--; else --e; if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5b481265e7a0cd3782abf2cce10010e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8421db486ffe0142a12b849f788c9bcb/" rel="bookmark">
			Linux Centos中network无法启动的几种解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos7的网络因MetworkManager方面的原因导致网卡启动失败，无法连接网络的几种解决方案。
查看主机地址 ip addr link/other 后既是主机地址修改/etc/sysconfig/network-scripts/ifcfg-ens33 查看HWADDR地址如果没有，添加，如果和ip addr一致，问题解决;关闭NetworkManager systemctl stop NetworkManagersystemctl
disable NetworkManager
重新启动网络：
systemctl start network.service
通过修改虚拟机地址解决选中虚拟机—&gt;设置-----&gt;高级设置------&gt;生成主机地址关机并启动虚拟机（非reboot重启）重新配置/etc/sysconfig/network-scripts/ifcfg-ens33
5) 执行命令对网卡进行重启 //禁用ens33网卡服务，系统版本不一，可能网卡名称不一
ifdown ens33
或
ifconfig ens33 down
// 启动
ifup ens33
或
ifconfig ens33 up
修改/etc/sysconfig/network-scripts中相应的网卡配置文件。 将其中的NBOOT=no 改为NBOOT=yes
7) 重启网络
systemctl restart network
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1aac6ff32b39c20201d9c6168ac61e0e/" rel="bookmark">
			Python-Opencv学习总结（五）：形态学转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		形态学转换主要针对是二值图像
两个输入对象：1.二值图像，2.卷积核：一个数组
1、图像腐蚀 图像的边变得更细了。可以去除噪声（边上的毛刺）
卷积核的中心点逐个像素扫描原始图像；被扫描到的原始图像中的像素点，只有当卷积核对应的元素值均为1时，其值才为1,否则值为0。
卷积核中心点遍历原始图像，当卷积核中心点所在位置的两边都是白色，即像素值为1的时候，才保留原始图像这个点。
当卷积核中心点所在位置的两边颜色不一样时，则将该处的原始图像设置为0，即变成黑色了。
使用函数erode
dst=cv2.erode(src,kernel,iterations)
src:源图像
kernel:卷积核,一般用一个5行5列的全是1的数组，生成：kernel=np.ones((5,5),np.uint8)
iterations:迭代次数,要进行多少次腐蚀
iterations默认情况下，迭代次数是1，根据需要可以进行多次腐蚀操作。
kernel = np.ones((5,5),np.uint8)
erosion = cv2.erode(o,kernel) 迭代次数为1
erosion = cv2.erode(o,kernel,iterations = 9) 迭代9次
import cv2 import numpy as np o=cv2.imread(r'D:\image\test1.png',cv2.IMREAD_UNCHANGED) k=np.ones((5,5),np.uint8) r=cv2.erode(o,k,iterations=4) cv2.imshow('o',o) cv2.imshow('r',r) cv2.waitKey() cv2.destroyAllWindows() 2、图像膨胀 是腐蚀操作的逆操作，图像变大了
图像被腐蚀后，去除了噪声（边上的毛刺），但是会压缩图像。对腐蚀过的图像，进行膨胀处理，可以去除噪声，并保持原有形状。
使用函数dilate
dst=cv2.dilate(src，kernel，iterations)
src:源图像
kernel:卷积核,kernel二np.ones((5,5),np.uint8)
iterations:迭代次数,
import cv2 import numpy as np o=cv2.imread(r'D:\image\test1.png',cv2.IMREAD_UNCHANGED) k=np.ones((5,5),np.uint8) r=cv2.dilate(o,k,iterations=5) cv2.imshow('o',o) cv2.imshow('r',r) cv2.waitKey() cv2.destroyAllWindows() 3、图像开运算 经过两次运算：腐蚀+膨胀
关键词：cv2.MORPH_OPEN
函数morphologyEx
opening=cv2.morphologyEx(img,cv2.MORPH_OPEN, kerne)
opening：开运算结果
img：源图像
cv2.MORPH_OPEN：开运算（固定）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1aac6ff32b39c20201d9c6168ac61e0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73061a1ed1c1588bfd3760b77af2a935/" rel="bookmark">
			Airtest测试Windows窗口翻车？还是想跟你们聊聊测试win窗口的一些问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权声明：允许转载，但转载必须保留原链接；请勿用作商业或者非法用途
此文章来源于项目官方公众号：“AirtestProject”
前言 很多同学反馈在测试Windows应用窗口的时候，经常遇到 窗口连接不上 、不知道窗口句柄是什么 ，发送 删除/回车 等 keyevent 的时候总是 不生效 的情况，所以今天我们带大家一起来看看用airtest测试Windows窗口的常见问题。
1.在IDE中连接Windows窗口 airtest提供了多种连接Windows应用窗口的方法，嵌入式连接和无嵌入式连接等，如果你使用嵌入式连接的方式不能正常连接待测的Windows窗口，比如出 现窗口被拉伸 、窗口黑屏、不能正常录制脚本 等情况，你还可以选择用无嵌入式连接或桌面模式。
嵌入式连接 而嵌入式连接又分两种，一种是“选定窗口”，另外一种是“搜索窗口”。
“选定窗口”的方式很简单，直接在IDE的Windows窗口连接那块面板上点击“选定窗口”，之后再把鼠标移动到待测窗口上，此时待测窗口会被一个绿色的矩形框圈住，单击鼠标左键即可把待测窗口嵌入到我们的IDE中：
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-GSaIdyme-1594810082407)(https://note.youdao.com/yws/public/resource/3304e6dc5125f0b2a20423dea86ea776/xmlnote/EE2DDA1FCC4143208E8AF9ABB7E464A0/26734)]
当然如果我们不使用“选定窗口”，而是使用其旁边的“搜索窗口”，IDE则会弹出一个当前所有已打开窗口的title列表，此时我们只需要找到待测窗口的title，然后点击右侧对应的 连接 按钮即可把应用窗口嵌入到我们的IDE中：
无嵌入式连接 无嵌入式连接，即 不用把应用窗口嵌入到IDE 上去，依旧可以对待测应用进行自动化测。在IDE的顶部菜单栏依次选择 选项--设置--勾选上Windows窗口无嵌入连接--OK ，之后再点击“选定窗口”，将鼠标移动到待测窗口上并单击，此时应用窗口没有被嵌入到IDE中，并且IDE的设备窗口也会自动隐藏起来。之后我们就可以像嵌入窗口那样对待测应用进行自动化测试操作：
桌面模式 假如同学们想要测试的窗口不止一个（即拥有多个不同的窗口句柄），单独 嵌入/选定 一个窗口可能无法满足测试需求，此时我们就可以使用“桌面模式”。
点击桌面模式按钮，此时AirtestIDE右侧的设备窗口将会完全隐藏，进入Windows桌面模式。在此模式下，录制脚本与运行脚本都与正常情况下没有区别，只不过执行时将会对整个桌面进行截图识别，甚至可以识别到AirtestIDE代码窗口里的截图语句（因此在执行脚本时，请尽量缩小AirtestIDE的窗口，避免脚本界面里的截图干扰执行结果）。
2.用代码连接Windows窗口 使用窗口句柄 在AirtestIDE里连接的窗口，都是用窗口句柄连接的。窗口句柄是每个Windows窗口对象拥有的独一无二的32位无符号整数，而且每次打开窗口，句柄的数值都会变化。
这就意味着，假如我们用某个窗口嵌入到AirtestIDE里写出了一个脚本，虽然这次可以直接运行，但是通过复制AirtestIDE里的脚本命令行的方式，是无法保证下一次还能够运行的。因为AirtestIDE里的命令行，将会有这样的参数内容 --device Windows:///句柄，而下次再打开窗口，可能句柄已经发生了变化。
使用句柄连接窗口的脚本我们可以这么写：
auto_setup(__file__,devices=["Windows:///133194"]) 但是该连接脚本仅对本次打开的Windows窗口有效，如果Windows窗口被关闭后重新打开，句柄也将会发生变化，该脚本失效。
使用正则表达式 上文我们提到，使用“搜索窗口”连接窗口的时候，IDE会列出当前所有打开窗口的title，我们可以 写一个正则表达式去匹配到待测窗口的title，并使用这个正则表达式来连接该窗口：
# 例如匹配“吹梦到西洲”后面跟着换行符以外的任意字符的窗口title auto_setup(__file__,devices=["Windows:///?title_re=吹梦到西洲.*"]) 大多数情况下，窗口的title比较不容易变化，所以使用正则表达式匹配窗口title来连接待测窗口的脚本，会相对稳定些。
连接整个桌面 如果不需要置顶某个窗口应用的话，我们还可以使用如下代码直接连接整个桌面来做自动化：
auto_setup(__file__,devices=["Windows:///"]) 3.在Windows应用上发keyevent 最后我们来看一下在Windows应用上发送 keyevent 的失效的问题。举个很常见的例子：很多同学反馈，自己想在Windows窗口的某个输入框内删除一些字符，所以使用了 DELETE 这个键码，但是实际运行效果是不仅没有生效，而且还把键码 DELETE 写到了输入框里面，这是为什么呢？
其实是因为同学们把Android的按键码和Windows的按键码混淆了。Android的按键码是基于ADB的，而Airtest的Windows模块则封装使用了pywinauto 支持的按键码，所以这就导致了 DELETE 键码在Android设备中生效，而在Windows窗口就不生效。
在 pywinauto 库中，删除的键码实际上是 {DELETE} ，所以我们想要在Windows窗口上实现删除字符的效果，可以这么写：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73061a1ed1c1588bfd3760b77af2a935/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/089565dae5f99d1553b026ba5c62b4a2/" rel="bookmark">
			SQL分页查询：offset xxx rows fetch next xxx rows only 方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分页：offset xxx rows fetch next xxx rows only 方式 分页实现的方法又多了一种，在SQL Server 2012版本中，TSQL在Order By子句中新增 Offset-Fetch子句，用于从有序的结果集中，跳过一定数量的数据行，获取指定数量的数据行，从而达到数据行分页的目的。经过测试，从逻辑读取数量和响应的时间消耗来测评，使用Offset-Fetch实现的分页方式，比Row_Number()方式性能要高很多。
Offset-Fetch子句要求结果集是有序的，因此，只能用于order by 子句中，语法如下：
// x1：跳过的行数 x2：显示的行数 ORDER BY 字段 ASC/DESC offset x1 rows fetch next x2 rows only 例如：
// LEN(字段名)取长度 @pageIndex:第几页 @pageLine：一页显示的条数 // 假如一页显示3条数据，查询第2页需要显示的数据,则 // ((@pageIndex - 1) * @pageLine)=(2-1)*3 @pageLine=3 ORDER BY LEN(MW.WREA_CODE),MW.WREA_CODE offset((@pageIndex - 1) * @pageLine) rows fetch next @pageLine rows only 关键字解析：
•Offset子句：用于指定跳过（Skip）的数据行；
•Fetch子句：该子句在Offset子句之后执行，表示在跳过（Sikp）指定数量的数据行之后，返回一定数据量的数据行；
•执行顺序：Offset子句必须在Order By 子句之后执行，Fetch子句必须在Offset子句之后执行；
分页实现的思路：
1.在分页实现中，使用Order By子句，按照指定的columns对结果集进行排序；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/089565dae5f99d1553b026ba5c62b4a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18a33d6367adc78d37b332b87fbac2af/" rel="bookmark">
			实用干货！因子分析超全步骤总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因子分析是统计数据分析方法之一，因子分析包括探索性因子分析和验证性因子分析。本文主要讨论探索性因子分析。
一、研究背景 关于工作满意度有14个问题，调研得到215份问卷结果。希望通过因子分析，用少量因子反映14个题目的信息，从而达到降低维度，便于分析的目的，并对因子命名用于后续分析。
二、分析步骤 Step1数据准备：
依据研究目的，收集相关数据。本例中就是我们收集得到的14个问题的有关数据。
因子分析要求数据一定为定量数据，问卷数据一般为量表题。
Step2选项设置：
点击【进阶方法】--【因子分析】。
将分析项拖拽至右侧，点击[开始分析]，即可得到分析结果。
设置[因子个数]：如果有预期想提取的因子个数，可以主动设置输出的因子个数。勾选[因子得分]：可自动保存因子得分。勾选[综合得分]：可自动保存综合得分。 Step3结果解释：
①判断数据是否适合因子分析
首先考察收集到的原有变量适不适合进行因子分析，我们利用KMO检验和Bartlett的检验结果进行判断。
表1：KMO和Bartlett的检验
上表展示KMO检验和Bartlett的检验结果。
通常KMO值的判断标准为0.6。大于0.6说明适合进行分析，反之，说明不适合进行分析。同时Bartlett检验对应P值小于0.05也说明适合分析。
SPSSAU输出的结果中会给出智能解读结果，直接查看智能分析：
②判断提取因子个数
多数情况下，我们在分析时已经带着主观预期，希望题项如何归类，此时可以直接设置对应的因子个数。
本例中，工作满意度预期分为4个维度，因此将因子个数设为4。再进行分析。
因子个数设为4
表2：方差解释率表格
方差解释率表格，主要用于判断提取多少个因子合适。以及每个因子的方差解释率和累计方差解释率情况。方差解释率越大说明因子包含原数据信息的越多。因子分析中，主要关注旋转后的数据部分。
从上表可知：本次共提取了4个因子。此4个因子旋转后的方差解释率分别是24.993%,22.049%,20.191%,18.809%，旋转后累积方差解释率为86.042%。
说明4个因子能够提取14个分析项86.042%的信息量，这个值没有固定标准，一般超过60%都可以接受。
如果研究人员并没有预设维度。而选择默认选项，SPSSAU默认以特征根大于1作为标准。
特征根：指标旋转前每个因子的贡献程度。此值的总和与项目数匹配，此值越大，代表因子贡献越大。
当然因子分析通常需要综合自己的专业知识综合判断，即使是特征根值小于1，也一样可以提取因子。
碎石图
同时可结合碎石图辅助判断因子提取个数。当折线由陡峭突然变得平稳时，陡峭到平稳对应的因子个数即为参考提取因子个数。
实际研究中更多以专业知识，结合因子与研究项对应关系情况，综合权衡判断得出因子个数。
③判断因子与题项对应关系
上面提到确定因子提取个数除了要考虑以上指标，更重要的是结合因子与研究项对应关系情况判断。
因子载荷系数表，正是反映因子和研究项对应关系情况。
表3：旋转后因子载荷系数表格
从结果中可以看出，使用因子分析对14个项进行浓缩处理，浓缩为四个因子。
因子与题项对应关系，其中Q12-Q14在F1因子上有较高的载荷，说明F1因子可以解释这几个分析项，它们主要反映了工作报酬方面的满意度；
Q9-Q11在F2上有较高的载荷，它们主要反映了领导管理方面的满意度；
Q5-Q8在F3上有较高的载荷，它们主要反映了工作环境方面的满意度；
Q1-Q4在F1上有较高的载荷，它们主要反映了个人发展方面的满意度。
Step4结果调整：
如果出现因子分析结果与预期结果不一致，这种情况是非常常见的。对于不理想的题项可以移出该项，再次分析，直至所有分析项与因子对应关系良好。
如果出现以下3种问题，则需要对不合理题项进行删除:
第一类：如果分析项的共同度值小于0.4,则对应分析项应该作删除处理;
第二类：某分析项对应的”因子载荷系数”的绝对值,全部均小于0.4,也需要删除此分析项;
第三类：如果某分析项与因子对应关系出现严重偏差（通常也称作‘张冠李戴’）,也需要对该分析项进行删除处理。
这部分在帮助手册中有详细介绍，有需要可阅读帮助手册中对应内容：
https://spssau.com/front/spssau/helps/advancedmethods/factor.html
Step5因子命名：
当确定了最终提取的因子数及题项对应关系，即可对提取的因子命名。
可以结合旋转后的因子载荷矩阵结果进行命名，最终将四个因子分别命名为F1工作报酬、F2领导管理、F3工作环境、F4个人发展。
三、后续分析 因子分析往往是预处理步骤，后续还需要结合具体研究目的进行分析，如回归分析、聚类分析等。
此时，可能需要用到因子得分，返回分析页面勾选[因子得分]即可生成因子得分。
如果是量表数据，建议通过【数据处理】--【生成变量】计算均值得到维度均值，用于后续研究。
四、其他说明 有关因子分析过程中可能遇到的问题，在之前的文章已经整理过，具体可参考：因子分析常见问题汇总，你想知道的都在这里
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12342ea447a6ceded5e3c2b371dd2300/" rel="bookmark">
			Wpf中Dispatcher.Invoke和Dispatcher.BeginInvoke的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看下面的代码：
new Thread(()=&gt; { Application.Current.Dispatcher.BeginInvoke(new Action(() =&gt; { while (true) { Thread.Sleep(1000); } }), null); Console.WriteLine("test"); }).Start(); 这段代码，会在控制台打印test，然后界面会一直卡住。界面卡住，说明while循环是在ui线程执行的，能够打印test，说明在执行Application.Current.Dispatcher.BeginInvoke时并没有阻塞当前界面，如果把BeginInvoke改成Invoke，那么test将不会被打印，说明Invoke方法的逻辑是把委托交给ui线程执行，并阻塞当前线程，直到委托结束。而BeginInvoke方法则首先新开一个线程，那新开的线程，再将委托交给ui线程处理。注意，最终执行委托的线程都是ui线程。所以，BeginInvoke由于有个新开线程的过程，不会阻塞当前线程。但仍然会阻塞界面。
另外BeginInvoke是可以指定优先级的，通过方法BeginInvoke(DispatcherPriority, Delegate)来设置优先级。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf3b6eb0cf041b2bb2ea7c57da7cbdb9/" rel="bookmark">
			弱网测试工具-qnet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		备注：个人学习笔记整理，仅供测试同学学习，切莫转载商用，有错误或者更好的方案可以留言，一同进步！
参考学习：
https://www.cnblogs.com/quark/p/10734587.html 简单了解软件下载安装及测试参数含义支持的功能 Android/iOS双端支持
iOS：正在上架App Store
Android版支持弱网自动化测试：基于adb命令驱动
一：简单了解
QNET是腾讯WeTest开发平台推出的弱网测试工具。
QNET无需ROOT手机，无需连接数据线，以独立app的方式，为用户提供给快捷、可靠、功能完善的弱网络模拟服务。
QNET还支持TCP/UDP网络协议抓包。
二：软件下载安装及测试
QNET下载：https://wetest.qq.com/product/qnet
点击【点击选择测试程序】-【选择测试模版】
测试模版可以自定义
然后点击【开始测试】，第一次会有悬浮窗权限授权，开了就行
也可能有VPN服务的确认框，开了就行
控制悬浮窗：
双击Q按钮可以切回QNET应用
暂停按钮：停止弱网状态恢复正常网络
下拉按钮：切换弱网模板
信息悬浮窗
时延：数据包从发送开始到接收到该数据，所耗费的时间，单位通常是ms（毫秒）。时延反映了网络的速度，越小越好。抖动：指时延的变化，即两个数据包时延的差值。抖动反映了网络的稳定性，越小越好。 三：参数含义
上下行延时（Delay）
上下行延时抖动（Jitter）
上下行带宽（Bandwidth）
上下行随机丢包（Random Packet Loss）
上下行连续丢包（Continuous Packet Loss）
TCP/UDP协议控制（Protocol）
这些具体看弱网测试这文章吧~
四：支持的功能
（1）网络抓包
导出为Pcap文件，可以在PC上用Wireshark工具打开分析，目前支持TCP, UDP, DNS协议
在设置里面打开开关
（2）连续丢包可以实现周期性断网的弱网场景，常用在测试游戏流畅性，验证游戏对网络波动的支持程度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0481a205a5d69d58b1c7e91bc355cdbb/" rel="bookmark">
			group by与order by的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. order by order by比较简单，作用就是排序
asc 从上到下慢慢升序
desc 从上到下慢慢降序
默认为升序(就是你sql后面不写order by 它就是升序)
order by后面跟多个字段时，排序按就近原则依次而来
2. group by group by我的理解是：聚合分组，值相等即为一组
聚合的意思就是聚合函数：例如 sum()、avg()、count()、max()等等
直接上个栗子：
看到这，能明白GROUP BY把重复的元素(三个蛮王)分为了一组。
所谓对NAME进行GROUP BY，其实就是对NAME进行了分组聚合, 值相等的为一组。
继续往下走
单独查询一个name时，对name进行GROUP BY是🆗的
但是这里查询中多了一个money字段，再对name进行GROUP BY 就会报错
继续往下
看到这里，应该就明白：在对NAME字段进行GROUP BY 聚合的条件下，如果还要查询MONEY字段，就应该也用聚合函数对MONEY进行操作，否则这样查出来的MONEY是没有意义的（money前面的name都被分组聚合了，你还要查这一个个单独的money有什么用？誰是誰的誰？）。
接着往下，如果我在此基础上，还要查询sum(money)大于100的人呢？
会报错，原因是：聚合函数是针对结果集进行的，但是where条件并不是在查询出结果集之后运行，所以主函数放在where语句中，会出现错误。
归根结底就一句话：聚合函数操作的是已查出的数据，where后面是查询条件，数据还没有，又怎么能当条件放到where里？
解决方法：having关键字
注意：
1.having只能用在group by之后，对分组后的结果进行筛选(即：要使用having，你必须先用group by分组)。
2.如果还要使用where，那么where要放在group by 之前。
3.where后的条件表达式里不允许使用聚合函数，但having可以。
再来个大总结：
首先 ，是这样的：
接着，是这样的：
最后，是这样的：
附：下面是另一个sql例子，看不看无所谓，大家可以无视。
CREATE TABLE `comment` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `user_id` int(10) unsigned NOT NULL, `content` varchar(200) NOT NULL, `addtime` datetime NOT NULL, `lastmodify` datetime NOT NULL, PRIMARY KEY (`id`), KEY `user_id` (`user_id`), KEY `addtime` (`addtime`), KEY `uid_addtime` (`user_id`,`addtime`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; INSERT INTO `comment` (`id`, `user_id`, `content`, `addtime`, `lastmodify`) VALUES (1, 1, '评论1', '2017-05-17 00:00:00', '2017-05-17 00:00:00'), (2, 1, '评论2', '2017-05-17 00:00:01', '2017-05-17 00:00:01'), (3, 2, '评论1', '2017-05-17 00:00:02', '2017-05-17 00:00:02'), (4, 2, '评论2', '2017-05-17 00:00:03', '2017-05-17 00:00:03'), (5, 3, '评论1', '2017-05-17 00:00:04', '2017-05-17 00:00:04'), (6, 1, '评论3', '2017-05-17 00:00:05', '2017-05-17 00:00:05'), (7, 4, '评论1', '2017-05-17 00:00:06', '2017-05-17 00:00:06'), (8, 4, '评论2', '2017-05-17 00:00:07', '2017-05-17 00:00:07'), (9, 4, '评论3', '2017-05-17 00:00:08', '2017-05-17 00:00:08'), (10, 4, '评论4', '2017-05-17 00:00:09', '2017-05-17 00:00:09'), (11, 3, '评论2', '2017-05-17 00:00:10', '2017-05-17 00:00:10'); select * from comment; +----+---------+---------+---------------------+---------------------+ | id | user_id | content | addtime | lastmodify | +----+---------+---------+---------------------+---------------------+ | 1 | 1 | 评论1 | 2017-05-17 00:00:00 | 2017-05-17 00:00:00 | | 2 | 1 | 评论2 | 2017-05-17 00:00:01 | 2017-05-17 00:00:01 | | 3 | 2 | 评论1 | 2017-05-17 00:00:02 | 2017-05-17 00:00:02 | | 4 | 2 | 评论2 | 2017-05-17 00:00:03 | 2017-05-17 00:00:03 | | 5 | 3 | 评论1 | 2017-05-17 00:00:04 | 2017-05-17 00:00:04 | | 6 | 1 | 评论3 | 2017-05-17 00:00:05 | 2017-05-17 00:00:05 | | 7 | 4 | 评论1 | 2017-05-17 00:00:06 | 2017-05-17 00:00:06 | | 8 | 4 | 评论2 | 2017-05-17 00:00:07 | 2017-05-17 00:00:07 | | 9 | 4 | 评论3 | 2017-05-17 00:00:08 | 2017-05-17 00:00:08 | | 10 | 4 | 评论4 | 2017-05-17 00:00:09 | 2017-05-17 00:00:09 | | 11 | 3 | 评论2 | 2017-05-17 00:00:10 | 2017-05-17 00:00:10 | +----+---------+---------+---------------------+---------------------+ 在comment表中，每个用户最后评论的内容就是id为6,4,11,10的记录。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0481a205a5d69d58b1c7e91bc355cdbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ae99670d4a626bffd78e99f01be19db/" rel="bookmark">
			Docker镜像与容器常用命令图文详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker镜像,容器常用命令 一.系统命令二.镜像命令:1 .镜像是什么?(1): UnionFS(联合文件系统)(2): Docker镜像加载原理(3): 分层的镜像(4): 为什么Docker镜像要采用这种分层的结构(5): 特点 2.查看本机镜像:3.搜索镜像:4.下载镜像:5.删除镜像:6.通过$()表达式删除镜像: 三.容器命令:1.新建容器并启动:2.后台启动容器:3.退出容器:4. 查看正在运行的容器:5.删除容器:6.启动,重启,停止容器:7.查看容器日志:8.查看容器中的进程:9.获取容器/镜像的元数据:10进入正在运行的容器:①: 第一种:②: 第二种: 11.拷贝文件:①: 从容器中拷贝内容到主机:②: 从主机中中拷贝内容到容器: 12.commit提交镜像 四.综合使用: 一.系统命令 #查看docker版本 docker version #查看docker的系统信息,包含镜像容器的数量 docker info #查看docker的所有命令 docker --help #查看该docker命令的帮助信息 docker 命令 --help 二.镜像命令: 1 .镜像是什么? 镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件
(1): UnionFS(联合文件系统) UnionFS（联合文件系统）：Union文件系统是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下，Union文件系统是Dokcer镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的镜像。
特性:一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统加载起来，这样最终的文件系统会包含所有的底层文件和目录
(2): Docker镜像加载原理 docker的镜像实际上是由一层一层的文件系统构成，这种层级的文件系统UnionFS。
主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的linux/unix系统是一样的，包含boot加载器内核。当boot加载完之后整个内核就都在内存中了，此时内存的使用权已经由bootfs交给内核了，此时系统也会卸载bootfs
平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M。
对以一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就行，因为底层直接用host和kernel，自己只需要提供rootfs就行。由此可见对于不同的Linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版可以公用bootfs。
(3): 分层的镜像 以pull为例，在下载的过程中我么可以看到docker的镜像好像是在一层一层的下载
(4): 为什么Docker镜像要采用这种分层的结构 最大一个好处就是——共享资源
比如：有多个镜像都从相同的base镜像构建而来，那么宿主机只需要在磁盘上保存一份base镜像，同时内存中也需要加载一份base镜像，就可以为所有服务器服务了。而且镜像的每一层都可以被共享。
(5): 特点 docker镜像都是只读的
当容器启动时，一个新的可写层被加载到镜像的顶部。
这一层通常被称作“容器层”，“容器层”之下都叫“镜像层”
所有的docker镜像都源自于基础镜像层，当我们进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。举一个简单的例子，假如基于Ubuntu Linux16.04创建一个新的镜像，这就是新镜像的第一层；如果在新镜像中添加Python包，就会在基础镜像层上创建第二个镜像层；如果继续添加一个安全补丁，就会添加第三个镜像层。如下图:
2.查看本机镜像: #查看本机所有镜像 docker images [可选命令] 从下图我们可以看到镜像的信息,
每个标签的含义如下:
标签含义REPOSITORY来自于哪个仓库，比如 ubuntuTAG镜像的标签,TAG 信息用来标记来自同一个仓库的不同镜像,例如 ubuntu 仓库中有多个镜像，通过 TAG 信息来区分发行版本，例如 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ae99670d4a626bffd78e99f01be19db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/720bf2139aa77f33e504a1cf631e10b2/" rel="bookmark">
			Linux大实验 (图书管理系统)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《程序设计基础综合实验》讲义 综合实验又称为课程设计，需要学生综合运用所学知识解决与实际应用紧密结合的、规模较大的问题，通过分析、设计、编码和调试等各环节的训练，使学生深刻理解、牢固掌握、综合运用数据结构和算法设计技术，增强分析问题、解决问题的能力，培养项目管理与团队合作精神。
本课程要求实验采用基本的软件工程开发方法，将软件开发过程分为需求分析、系统设计、编码实现、系统测试4个阶段。每个阶段设置相应的里程碑进行检查，对学生的设计过程进行评价。
（1）需求分析阶段
首先要充分分析和理解问题，明确要求做什么？限制条件是什么？即要确定需要实验那些功能（任务），并对所需完成的任务做出明确的回答，如，输入数据的类型、值的范围及输入的形式；输出数据的类型、值的范围及输出的形式；若是会话式输入，结束标志是什么？是否接受非法输入？对非法输入的回答方式是什么等。另外，还应该为调试程序准备好测试数据，包括合法的输入数据与非法的输入数据。同时，实验小组应该对设计工作进行分工，并形成小组成员通过的书面记录。
（2）概要设计和详细设计阶段
设计通常分为概要设计与详细设计两步。
在进行概要设计时，确定数据的逻辑结构，并要求按照自顶向下逐步求精的原则划分模块，画出模块间的调用关系图。
在进行详细设计时，要求定义数据的存储，并画出各模块（函数）的程序流程图或写出伪代码。
（3）编码实现阶段
在详细设计的基础上，用特定的程序设计语言编写程序。良好的程序设计风格可以保证较快地完成程序测试。程序的每行不要太长，每个函数不要太大，当一个函数太大时，可以考虑将其分解为较小的函数。对函数功能、核心语句、重要的类型和变量等应给出注释。一定要按凹入格式书写程序，分清每条语句的凹入层次，上下对齐层次的括号，以便发现语法错误。
（4）测试阶段
采用测试数据进行测试，列出实际的输入、输出结果、预期结果。
（5）总结与整理报告阶段
调试正确后认真整理源程序及注释，提交带有完整注释且格式良好的源程序，并撰写课程设计报告。
课程设计报告中除了上面提到的分析、设计过程外，还用给出下面几方面的内容。
① 调试分析：调试过程中主要遇到哪些问题？如何解决的？
② 算法分析：核心算法的时间复杂性与空间复杂性分析。
③ 改进设想、经验和体会。
一、图书管理信息系统的设计与实现 (难度系数：1)
1.问题描述
图书管理信息系统实现图书馆馆藏图书的信息管理与图书借阅。图书管理信息系统包括用户管理、读者管理、图书管理、图书流通功能。
2.整体要求
该系统应具有合理的界面设计，并易于操作；
编码风格良好；
该系统用控制台程序即可实现；
编程语言为C语言，编程环境为VC++ 6.0
3.设计要求
（1）登录系统时，要求用户输入用户名与密码，用户名与密码无误方可使用系统，最多可以尝试三次。用户分为：普通读者、图书管理员、系统管理员三种。普通读者只能使用“用户管理子系统”中“用户密码修改”功能和“图书管理子系统”中“图书信息查询”功能；图书管理员只能使用“图书管理子系统”和“图书流通管理子系统”；系统管理员只能使用“用户管理子系统”和“读者管理子系统”。
（2）图书管理信息系统包括：用户管理、读者管理、图书管理、图书流通管理这四个子系统。“图书管理信息系统”主菜单要求包含如下选项：
**********************************
1.用户管理
2.读者管理
3.图书管理
4.图书流通管理
5.退出系统
要求在选择退出功能之前，可以反复选择系统的各项功能使用系统。 1）用户管理子系统：
应包括用户信息输入、用户信息修改、用户信息删除、用户信息显示、用户密码修改等功能。其中“普通读者”只能使用“用户密码修改”功能。
“用户管理”菜单要求包括如下选项:
1. 用户信息输入 2. 用户信息修改 用户信息删除用户信息显示用户密码修改返回主菜单 “用户管理子系统”要求用文件与链表实现。
2）读者管理子系统：
应包括读者信息输入、读者信息修改、读者信息删除、读者信息按名查询等功能。
“读者管理”菜单要求包括如下选项:
1. 读者信息输入 2. 读者信息修改 3. 读者信息删除 4. 读者信息查询 5. 读者信息显示（按读者姓氏排序） 6. 返回主菜单 ******************* “读者管理子系统”要求用文件与链表实现。 3）图书管理子系统：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/720bf2139aa77f33e504a1cf631e10b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/326b359688db152a240b07aa4e80e22d/" rel="bookmark">
			计算机组成原理笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、计算机的基本组成二、总线2.1 总线控制 三、主存储器3.1 RAM3.2 存储器与CPU相连3.3 存储器校验3.4 提高存储器访问速度3.5 cache 四、输入输出系统4.1 I/O接口4.2 程序中断方式4.3 DMA方式 五、数字运算5.1 无符号数与有符号数5.2 定点数与浮点数 六、机器指令七、指令与中断7.1 指令系统7.2 中断系统 八、微指令控制单元8.1 微操作指令8.2 控制单元 九、控制单元设计9.1 组合逻辑设计9.2 微程序设计 十、参考文档 一、计算机的基本组成 MDR：memory data register主存数据寄存器MAR：memory address register主存地址寄存器 完成一条指令分为了三个阶段：取指令-分析指令-执行指令。
下面我们分析上图的取数指令。（取数指令 ≠ 取指令 ， 取数指令需要实施取指令、分析指令）
取指令
要执行的指令的地址我们是保存在PC当中的，取数指令这条指令的地址是保存在存储体当中的。所以，取指令的第一个操作，就是PC（PC给出了取数指令这条指令它所在的内存单元地址）要把指令的地址送给MAR，再由MAR送给存储体。在控制器的控制下，存储体把指定存储体中保存那条取数指令取出送到MDR中。取出的指令送到IR（IR的功能就是保存当前正在执行的指令）。总结就是取指令将内存中的取数指令取出送到了IR。分析指令
指令寄存器IR当中保存的指令（当前为取数指令）的操作码部分送给CU，经过译码，CU上面的信号将控制相应的执行部件去执行指令要去的相关操作。
执行指令
我们这条指令是取数指令，取数指令的功能是把保存在内存单元M中的数据取到ACC寄存器中，为了完成这个操作，在控制器的控制下，我们要把指令当中的地址部分送给存储器，以便我们把数据从存储体取出。
这个操作还是从IR开始，因为IR当中保存了当前这条指令，同时也保持了当前这条指令操作数的地址，我们从IR的地址码部分把地址取出送给MAR，然后由MAR送入给存储体，在控制器的控制之下，从存储体中把我们取数指令取的数取出送入MDR，然后送给ACC。总结就是执行取数指令，将取出的数放到ACC。
二、总线 我们采用总线方式实现外部设备与系统主机的连接，外部设备有地址，主机通过地址确认这次数据传输与哪个设备参与此次输入输出。
2.1 总线控制 问，小端不是87654321吗？
三、主存储器 3.1 RAM 3.2 存储器与CPU相连 3.3 存储器校验 3.4 提高存储器访问速度 采用更高速器件采用层次结构 cache - 主存调整主存结构 下面主要介绍第三种。
原本我们介绍的主存的结构都是主存当中一个存储字长等于机器字长，也就是说cpu在执行一条指令的时候，如果想取指令的话，指令长度假设和存储字长相等，一次在存储器当中只能取一条指令（一次在存储器当中，如果取数也只能取机器字长相等的数据）。
这是我们就需要调整主存结构使得CPU和存储器存储速度能够匹配。
多体并行方式有两种，其中高位交叉编址的多体存储器中，程序按体内地址顺序存放，而低位交叉编址的多体存储器中，程序连续存放在相邻体中 。
高位交叉：各个体并行工作
并行工作的高位交叉编址的多体存储器结构示意图，图中程序因按体内地址顺序存放（一个体存满后，再存入下一个体），故又有顺序存储之称。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/326b359688db152a240b07aa4e80e22d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28ed4bfb1b4e2ee1b91cc8f0f6751626/" rel="bookmark">
			VNC Viewer连接树莓派无法调整分辨率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 使用VNC Viewer连接树莓派，但分辨率太低，修改树莓派本身的分辨率并reboot后依然是默认的低分辨率。
解决方法 了解发现，raspi-config修改的是树莓派的分辨率，修改成功后树莓派本身的分辨率（包括连接显示器时的分辨率）会发生改变，但不会影响VNC端的分辨率；而vncserver这条命令修改的是VNC端的分辨率，但只能一次生效，开启一个:1的端口以供连接。因此，可以用两行shell解决问题：
#!/bin/sh vncserver -geometry 1920x1080 #修改分辨率，并开启:1端口 lxappearance #解决连接后指针变成X的问题 可以将脚本放在pi主目录下，每次VNC连接后执行一次，然后再切换窗口，由于每次开启的都是:1端口，所以不用每次新建，只要保留这两个就行：
这个方法其实没简单多少，如果嫌麻烦可以直接windows远程连接，但我远程连接经常很卡，不如VNC流畅，所以才采用了这种方法，如果有更简单的方案欢迎分享。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/95/">«</a>
	<span class="pagination__item pagination__item--current">96/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/97/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>