<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53204eea5ccb06be143f6cce0fbda671/" rel="bookmark">
			Python中嵌套自定义类型的JSON序列化与反序列化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于经常用python开发得小伙伴来说，Python的JSON序列化和反序列化功能非常方便和实用。JSON（JavaScript Object Notation）其实就是一种轻量级的数据交换格式，易于阅读和编写，也易于机器解析和生成。在Python中，可以使用json模块来进行JSON序列化和反序列化操。但是再开发过程中我们还是会经历各种各样得问题。
1、问题背景
在Python开发中，我们经常需要将复杂的数据结构序列化为JSON字符串，以便存储或传输数据。然而，当数据结构中包含嵌套的自定义类型时，使用内置的json库进行序列化可能会遇到困难。例如，我们可能需要序列化一个包含多个部门、人员和技能的组织结构。
2、 解决方案
为了解决这个问题，我们可以采用以下步骤：
定义一个自定义的JSON编码器，以便将自定义类型转换为字典。使用json.dump()函数将数据序列化为JSON字符串，并指定自定义编码器。定义一个自定义的JSON解码器，以便将字典转换为自定义类型。使用json.load()函数将JSON字符串反序列化为数据结构，并指定自定义解码器。 代码例子
以下是一个简单的示例，演示如何使用自定义编码器和解码器来序列化和反序列化一个包含嵌套自定义类型的组织结构：
import json class Company(object): def __init__(self, company_id): self.company_id = company_id self.name = '' # other 10 attributes with simple type ... self.departments = [] #list of Dept objects class Dept(object): def __init__(self, dept_id): self.dept_id = dept_id self.name = '' # other 10 attributes with simple type ... self.persons = [] #list of Person objs class Person(object): def __init__(self, per_id): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53204eea5ccb06be143f6cce0fbda671/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/151b6749c66929ace22bb596cf7ac2a3/" rel="bookmark">
			使用 Nginx 将 HTTP 重定向到 HTTPS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置重定向 HTTP 流量在 80 号端口被监听。这里我们将全部 HTTP 的流量都永久重定向到 HTTPS（301）。重定向时，保留原有的主机（host）和请求 URI。
server { listen 80; server_name _; return 301 https://$host$request_uri; } 注意，这里的服务器名字（server name）是个通配符_：也就是无论 URL 中包含什么域名，当请求到达 Nginx 服务器以后，都会被重定向到 HTTPS。比如说，无论是 http://h5.1024bugs.top 还是 http://www.1024bugs.top，都会被重定向到它们相应的 HTTPS 链接。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5afa16f11b74f84cdbfb158ddbcca760/" rel="bookmark">
			python（23）——while循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在Python中，while 循环用于重复执行一段代码块，只要指定的条件保持为真（True）。一旦条件变为假（False），循环就会终止。while 循环通常用于在不知道循环将执行多少次的情况下进行迭代。
while循环语法格式：
while条件运算:程序区块 提一点：程序设计时，如果忘了设计条件可以离开循环，程序造成无限循环状态，此时可以同时按Ctrl+C键，中断程序的执行。
正文 循环语句在生活中的应用非常广泛，循环广告牌、批量修图、视频轮播、音乐轮播、图片轮播、大喇叭喊话、动态壁纸等等。
while循环的简单应用 i=0 while i&lt;10: print("爱你一万年") i =i+1 通过while循环完成1—10的加和 i=1 sum=0 while i&lt;10: sum = sum + i i =i+1 print(i) print(sum) 使用while循环完成猜数字游戏 这个是一个简单的猜数字游戏，用户需要猜一个预先设定的数字（在这个例子中是7）。程序会提示用户输入一个数字，然后根据用户的输入与预设的秘密数字（secret）进行比较，给出相应的提示。
guess=0 secret=7 times=1 print("---------欢迎参加猜数字游戏，请开始---------") while guess!=secret: guess=int(input("@数字区间0-9，请输入你猜的数字：")) print("你输入的数字是：",guess) if guess==secret: print("你猜了{}次，猜对了。真厉害". format(times)) else: if guess&lt;secret: print("你猜的数字小于正确答案") else: print("你猜的数字大于正确答案") times+=1 print("游戏结束") while循环的嵌套使用 嵌套循环在生活中也有许多的例子，比如：
购物清单：当你准备购物时，你可能会首先列出需要购买的商品类别（如蔬菜、水果、肉类等），然后在每个类别下列出具体的商品。这个过程可以看作是一个嵌套循环。外层循环遍历每个商品类别，内层循环遍历每个类别下的具体商品。
打印一下99乘法表 i=1 #设定i初始值 while i &lt;= 9: j =1 while j &lt;= 9: result=i*j print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5afa16f11b74f84cdbfb158ddbcca760/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/146692d38997f695bf7b8340fb1f52ee/" rel="bookmark">
			深度学习的进展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习的进展 深度学习作为人工智能领域的重要分支之一，利用神经网络模拟人类大脑的学习过程，通过数据训练模型以自动提取特征、识别模式、进行分类和预测等任务。近年来，深度学习在多个领域取得显著进展，尤其在自然语言处理、计算机视觉、语音识别和机器翻译等方面实现了突破性进展。
方向一：深度学习的基本原理和算法
深度学习基于神经网络概念，涉及反向传播、卷积神经网络、循环神经网络等算法。这些算法模拟人脑神经元间的信息传递和学习过程，实现对复杂数据模式的自动学习和抽取。
方向二：深度学习的应用实例
深度学习在自然语言处理、计算机视觉、语音识别和机器翻译等领域有广泛应用。例如，深度学习已在图像识别、语音助手和自然语言处理任务中取得显著成就，推动了这些领域的发展。
方向三：深度学习的挑战和未来发展方向
深度学习面临数据标注、模型泛化能力、可解释性和隐私保护等挑战。未来，可以通过增强学习、元学习等方法解决这些问题，并将深度学习与其他技术结合，拓展其应用范围。
方向四：深度学习与机器学习的关系
深度学习是机器学习的一个分支，其优势在于可以处理大规模数据并学习复杂特征。未来，深度学习和机器学习将相辅相成，结合各自优点，实现更广泛的应用。
方向五：深度学习与人类的智能交互
深度学习致力于模拟人类认知和感知过程，促进智能系统与人类之间更自然的交互。未来，深度学习可能带来更智能、更智能化的人机界面，推动人工智能技术与人类社会的融合和发展。
深度学习的不断进步将继续影响我们的生活和工作方式，为未来的科技发展开启更加广阔的前景。愿深度学习的发展在智能时代为我们带来更多惊喜与改变！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dc15cf8d7e22444983971df2450eb78/" rel="bookmark">
			spring boot集成redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引入依赖 &lt;!-- redis依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 连接池依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt; application.yml配置文件 server: port: 8456 spring: data: redis: host: 127.0.0.1 password: 123456 port: 6379 database: 2 lettuce: pool: max-active: 8 # 最大连接 max-idle: 8 # 最大空闲连接 min-idle: 0 # 最小空闲连接 max-wait: 100ms # 等待时间 序列化配置类 import com.fasterxml.jackson.annotation.JsonAutoDetect; import com.fasterxml.jackson.annotation.PropertyAccessor; import com.fasterxml.jackson.databind.ObjectMapper; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.connection.RedisConnectionFactory; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer; import org.springframework.data.redis.serializer.StringRedisSerializer; @Configuration public class RedisConfig { @Bean @SuppressWarnings("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dc15cf8d7e22444983971df2450eb78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15fa8a25ecc5b33caa0631403f551bee/" rel="bookmark">
			C# TCP/IP协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C#中编写TCP/IP通信 //开启监听各个网络的连接是否成功
//开启服务端，监听，并且进入监听线程
try
{ IPAddress ip = IPAddress.Parse(HostAddress);
IPEndPoint ipe = new IPEndPoint(ip, HostPort);
m_services = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
m_services.Bind(ipe);
m_services.Listen(0);
}
catch (Exception ex)
{
MessageBox.Show("服务器打开失败，请打开设置页面重新设置服务器地址");
return;
}
//发送8位的16进制数据
byte[] NetRd = { 0x01, 0x02, 0x00, 0x00, 0x00, 0x18, 0x78, 0x00 };
Connect_Socket.Send(NetRd);
Socket connection = (Socket)sender;
IPEndPoint IPend = (IPEndPoint)connection.RemoteEndPoint;
IPAddress IP = IPend.Address;
byte[] buffer = new byte[1024 * 2];
int aa = -1;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15fa8a25ecc5b33caa0631403f551bee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f29a479b601d48fbd161f1edf1eaac0/" rel="bookmark">
			HTTP 状态消息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		消息
描述
100 Continue
服务器仅接收到部分请求，如果服务器没有拒绝该请求，客户端应该继续发送其余的请求。
101 Switching Protocols
服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。
103 Checkpoint
或者 POST 请求恢复失败时的恢复请求建议。
200 OK
请求成功
201 Created
请求被创建完成，同时新的资源被创建。
202 Accepted
供处理的请求已被接受，但是处理未完成。
203 Non-Authoritative Information
请求已经被成功处理，但是一些应答头可能不正确，因为使用的是其他文档的拷贝。
204 No Content
请求已经被成功处理，但是没有返回新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。
205 Reset Content
请求已经被成功处理，但是没有返回新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。
206 Partial Content
客户发送了一个带有Range头的GET请求，服务器完成了它。
300 Multiple Choices
多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。
301 Moved Permanently
所请求的页面已经转移至新的 URL 。
302 Found
所请求的页面已经临时转移至新的 URL 。
303 See Other
所请求的页面可在别的 URL 下被找到。
304 Not Modified
未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。
305 Use Proxy
客户请求的文档应该通过Location头所指明的代理服务器提取。
306 Switch Proxy
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f29a479b601d48fbd161f1edf1eaac0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/834ad13f48f83f9aebfc1259e4b88e3b/" rel="bookmark">
			详解小程序配置服务器域名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置小程序的服务器域名是小程序开发过程中的一个关键步骤，主要涉及到设置小程序后端服务的网络通信。这通常是为了确保小程序能够安全、稳定地与服务器进行数据交换。以下是配置小程序服务器域名的详细步骤：
1. 准备服务器域名 首先，你需要有一个已经注册并备案的域名，以及一个已部署好的服务器。通常，你的服务器会有一个公网IP地址，你需要将这个IP地址与你的域名绑定。域名备案是根据国家和地区的不同而有所不同的法律要求。
2. 配置服务器 确保你的服务器配置了SSL/TLS证书，使得服务器能够支持HTTPS。这是小程序要求的一个安全标准，以确保数据传输的加密和安全性。
3. 登录小程序管理平台 访问对应的小程序平台（例如微信小程序平台）。使用你的开发者账号登录。 4. 进入开发设置 在小程序管理平台中，找到“开发”或“开发设置”部分。这通常在小程序管理后台的侧边栏或顶部导航栏中。
5. 设置服务器域名 在“开发设置”中，找到服务器域名的配置部分。通常，这里会有几个不同的配置选项，包括：
请求域名：用于API调用。WebSocket域名：用于WebSocket通信。上传文件域名：用于文件上传。下载文件域名：用于文件下载。 在这些部分输入你的服务器域名。确保输入的是HTTPS协议的域名（例如：https://www.yourdomain.com）。
6. 验证域名 根据平台的要求，你可能需要对添加的域名进行验证，以证明你拥有该域名的管理权限。这通常涉及在你的服务器上上传一个特定的文件或设置一个DNS记录。
7. 发布和测试 完成域名设置后，你可以发布一个新版本的小程序来测试这些设置。确保进行全面的测试，包括API调用、文件上传下载等功能，以验证配置是否正确。
注意事项 安全考虑：小程序平台通常要求服务器支持HTTPS来确保数据安全。域名变更限制：某些平台可能对域名的更改有限制，比如更改次数限制。开发与生产环境：在开发阶段，你可以设置不同的域名用于测试。一旦进入生产阶段，确保使用正确的生产环境域名。备案要求：特别是在中国大陆地区，对于互联网服务，域名备案是必须的。 通过以上步骤，你可以为你的小程序配置服务器域名，确保小程序能够安全、高效地与后端服务进行通信。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cba873c4a741d3b4bd46cf9f6795dccd/" rel="bookmark">
			dockerfile文件书写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.dockerfile构建nginx镜像 1.1书写dockerfile文件 mkdir nginx #创建nginx目录 cd nginx vim dockerfile # 修改文件 FROM centos # 基础镜像，默认最新的centos8操作系统 MAINTAINER xianchao # 指定镜像的作者信息 RUN rm -rf /etc/yum.repos.d/* # centos8默认的yum源不可以使用，需要更换yum源 COPY Centos-vault-8.5.2111.repo /etc/yum.repos.d/ # 将nginx目录下的文件拷贝到镜像中 RUN yum install wget -y # 下载wget命令 RUN yum install nginx -y # 下载nginx服务 COPY index.html /usr/share/nginx/html/ # 将nginx目录下的文件拷贝到镜像中 EXPOSE 80 # 暴露端口 ENTRYPOINT ["/usr/sbin/nginx","-g","daemon off;"] # 执行命令，开启nginx服务 1.2准备nginx目录下的文件 准备yum源准备index.html文件 vim index.html &lt;html&gt; &lt;head&gt; &lt;title&gt;page added to dockerfile&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello ,My Name is tiandameng &lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cba873c4a741d3b4bd46cf9f6795dccd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14edbb063d725aaf5e867bac77590193/" rel="bookmark">
			消息队列-RabbitMQ：发布确认—发布确认逻辑和发布确认的策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		九、发布确认 1、发布确认逻辑 生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID (从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者 (包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了，（单个）如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置 basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。(批量)
（异步）confirm 模式最大的好处在于它是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息。
2、发布确认的策略 开启发布确认的方法：发布确认默认是没有开启的，如果要开启，需要调用方法 confirmSelect，每当你要想使用发布确认，都需要在 channel 上调用该方法（反复确认）。
1）单个确认发布 这是一种简单的确认方式，它是一种同步确认发布的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布，waitForConfirmsOrDie(long) 这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。
这种确认方式有一个最大的缺点就是:发布速度特别的慢，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说这可能已经足够了。
/** * 单个发送 */ public static void publishMessageIndividually() throws Exception { Channel channel = RabbitMqUtils.getChannel(); //队列声明 String queueName = UUID.randomUUID().toString(); channel.queueDeclare(queueName, true, false, false, null); //开启发布确认 channel.confirmSelect(); long begin = System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14edbb063d725aaf5e867bac77590193/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfe95b36429ca88dcc7747dbdc5c7895/" rel="bookmark">
			将yolov8权重文件转为onnx格式并在c#中使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yolo模型转ONNX 在yolov8中，我们将训练结果的.pt权重文件转换为onnx格式只需要使用ultralytics库中的YOLO类，使用pip安装ultralytics库，然后执行下面python代码
from ultralytics import YOLO # 加载YOLOv8模型 model = YOLO("best.pt") # 将模型导出为ONNX格式 success = model.export(format="onnx", simplify=True) # 检查是否成功导出 assert success 此程序就会加载当前根目录下的best.pt并转换为ONNX格式进行导出
C#中使用ONNX 创建一个.NET 8.0的项目，因为自己写比较繁琐，我们直接使用封装好的Nuget包YoloDotNet
地址：NuGet Gallery | YoloDotNet 1.2.0
安装Nuget包命令
NuGet\Install-Package YoloDotNet -Version 1.2.0 这个包比较大，安装时间可能有点久，耐心等待！！！
安装完成后，我们通过如下代码读取ONNX文件，下面代码中创建yolo实例有两个构造函数的参数，第一个就是onnx文件的地址，第二个就是你是否使用GPU来进行识别，如果你的电脑有装英伟达的GPU并且按照了cuda，就设置为true。我的电脑没有，所有只能使用cpu来跑，因此我设置为false
new Yolo(@"D:\best.onnx", false); 然后就是读取你的图片，调用yolo的RunObjectDetection，将图片作为第一个参数，第二个参数就是识别的阈值
using var image = Image.Load&lt;Rgba32&gt;(@"D:\testphoto\1.jpg"); var results = yolo.RunObjectDetection(image, 0.3); 如果你的模型不是目标检测，而是图像分类或者其他，可以使用yolo的其他方法
然后就是将识别图片结果保存本地了，下面是示例的所有代码
class Program { public static void Main(string[] args) { using var yolo = new Yolo(@"D:\best.onnx", false); using var image = Image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfe95b36429ca88dcc7747dbdc5c7895/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/457e69200ba3af52e303e28eb715b7f1/" rel="bookmark">
			MySql重要知识梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.索引1.索引概述2.索引优缺点3. 索引结构为什么InnoDB存储引擎选择使用B+tree索引结构? 4.索引分类思考InnoDB主键索引的B+tree高度为多高? 5. 索引语法1.索引语法2.sql性能分析1.SQL执行频率2.慢查询日志3.explain执行计划 3.索引使用规则1.最左前缀法则2.索引失效情况3.SQL提示4.覆盖索引&amp;回表查询5.前缀索引6.单列索引与联合索引7.索引设计原则 二.SQL优化1.插入优化2.主键优化1.页分裂2.页合并3.主键设计原则3.order by优化order by优化原则: 4.group by优化group by优化原则: 5.limit优化limit优化原则: 6.COUNT优化7.update优化 SQL优化总结 三.锁1.全局锁1.语法2.特点 2.表级锁介绍1.表锁2.元数据锁3.意向锁 3.行级锁介绍1.行锁数据演示 2.间隙锁&amp;临键锁数据演示 总结 四.InnoDB引擎1.概述2.MySQL的架构图1.内存结构2.磁盘结构3.后台线程 五.事务原理1.事务基础2.redo log2.undo log3.MVCC1.隐藏字段数据演示 2.undolog版本链1.介绍2.版本链3.readview4.原理分析1.RC隔离级别2.RR隔离级别 5.事务总结 一.索引 1.索引概述 索引(index)是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现查找算法，这种数据结构就是索引。
2.索引优缺点 优势劣势提高数据检索的效率,降低数据库的IO成本(提高查询速度)索引列也是要占用空间的。通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。(提高排序速度)索引大大提高了查询效率,同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低。(因为要重新维护索引结构) 3. 索引结构 索引InnoDBMyISAMMemoryB+tree索引支持支持支持Hash索引不支持不支持支持R-tree索引不支持支持不支持Full-text5.6版本之后支持支持不支持 我们平时所说的索引,如果没有特别指明,都是指B+树结构组织的索引。 mysqlB+tree优化
Hash索引
Hash索引特点
1.Hash索引只能用于对等比较(=,in),不支持范围查询(between,&gt;,&lt;,…)
2.无法利用索引完成排序操作
3.查询效率高，通常只需要一次检索就可以了，效率通常要高于B+tree索引
存储引擎支持 在MySQL中，支持hash索引的是Memory引擎,而InnoDB中具有自适应hash功能，hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的。 为什么InnoDB存储引擎选择使用B+tree索引结构? 相对于二叉树,层级更少,搜索效率高；对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值对减少，指针跟着减少，要保存大量数据，只能增加树的高度，导致性能降低；相比Hash索引，B+tree支持范围匹配以及排序操作； 4.索引分类 分类含义特点关键字主键索引针对与表中主键创建的索引默认自动创建，只能有一个PRIMARY唯一索引避免同一个表中某数据列中的值重复可以有多个UNIQUE常规索引快速定位特定数据可以有多个全文索引全文索引查找的是文本中的关键词,而不是比较索引中的值可以有多个FULLTEXT 在InnoDB存储引擎中,根据索引的存储形式，又可以分为以下两种:
分类含义特点聚集索引(Clustered Index)将数据存储与索引放到了一块,索引结构的叶子节点保存了行数据必须有,而且有一个二级索引(Secondary Index)将数据与索引分开存储,索引结构的叶子节点关联的是对应的主键可以存在多个 聚集索引选取规则:
如果存在主键,主键索引就是聚集索引。如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引。如果表没有主键，或没有合适的唯一索引，则InnoDDB会自动生成一个rowid作为隐藏的聚集索引。
思考InnoDB主键索引的B+tree高度为多高? 由上看出来即使存储2000多万行的数据树的高度只有三层，可见检索效率是非常高效的。
5. 索引语法 1.索引语法 2.sql性能分析 1.SQL执行频率 MySQL客户端连接成功后，通过show[session|global] status命令可以提供服务器状态信息。通过如下指令,可以查看当前数据库的 INSERT 、UPDATE、DELETE、SELECT的访问频次:
SHOW GLOBAL STATUS LIKE 'Com_______'; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/457e69200ba3af52e303e28eb715b7f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e76f7547ec260e42dd73ee7e17c5cec/" rel="bookmark">
			MySQL-基本使用，数据类型，简单操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 数据库概述 1.1 数据库(DatBase) 数据库，就是遵循一定数据格式的数据集合，可以认为他是对文件系统的改进。它解决了不同操作系统之间，数据格式的兼容性问题。也就是说，只要是同一个数据库的数据文件，即使从windows迁移到了Linux上，也可以正常运行的。
1.2 关系型和非关系型的区别 关系型数据库： 关系型数据库是一种采用关系模型（或称为表格模型）来组织和存储数据的数据库管理系统（DBMS）。在关系型数据库中，数据以行和列的形式存储在表格中，并通过表格之间的关系进行组织和管理。关系型数据库通常使用结构化查询语言（SQL）作为数据操作语言。
对于Java而言，一个类就可以对应一个表，一个类对象就可以对应表中的一条数据，一个成员变量可以对应表中的一个列，能够做到一 一映射，数据库中是以表作为基本单位的。
非关系型数据库：非关系型数据库（NoSQL，Not Only SQL）是一种不使用传统的关系型表格模型来组织和存储数据的数据库系统。与关系型数据库相比，非关系型数据库通常具有更灵活的数据模型和更高的可伸缩性，适用于不同类型的数据处理需求。非关系型数据库是存储键值对的，如Redis，mongoDB等。
1.3 MySQL介绍 MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle旗下产品。MySQL 是最流行的关系型数据库关系系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS(Relational Database Management System，关系数据库管理系统) 应用软件之一。
MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。
MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。
1.4 数据库对象 表：就是存储数据的表格，里面有一条条记录，记录有字段组成，每个字段都有自己的字段名，字段值，字符段类型。字段是存储数据的基本单元。类似java中的对象，由于存储数据。
视图: 可以理解为一张虚表(它在物理磁盘上并不真实存在)。视图是基于select语句查询生成的结果集。当一条select语句比较复杂且调用频率较高时，我们不想再写一遍语句，这时候可以把这条select语句创建为一个视图。每次使用视图的时候，就可以把它当成一张表来用。
函数：常是一个功能的实现，我们大部分使用的是系统函数（MYSQL提供的），我们也可以自定义函数。它的调用套路通过使用select 函数名(参数1,参数2..);来调用。它只有一个返回值。
存储过程：也是一个功能的实现。我们所说的数据库编程，SQL语句编程，就主要是指自定义一个存储过程。调用存储过程是使用exec 存储过程名 参数1等来调用。它是可以返回多个值，也可以没有返回值。
索引：就像书的目录一样，为了加快我们的查询速度而建立的。
2 MySQl基本使用 2.1 用户创建和授权 1. 创建用户：需要切换到mysql数据库下，操作user表
username: 用户名； host： 指定在哪个主机上可以登录，本机可用localhost，%通配所有远程主机； password：用户登录密码
-- 创建用户 CREATE USER '用户名'@'HOST' IDENTIFIED BY '密码' CREATE USER 'nono'@'localhost' IDENTIFIED BY '123123'; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e76f7547ec260e42dd73ee7e17c5cec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e38e03dc4afae4febf9eb053cfa39d1f/" rel="bookmark">
			K8S临时小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 k8s是什么？能解决什么问题？ k8s是容器管理平台，一套复杂的开源系统 如何更好的维护pod，k8s第二大要素（pod控制器） k8s的很多对容器（pod）管理的高级特性，都是基于控制器而来 为什么要学习k8s？ 引入k8s是为了更好的维护容器化部署业务，跨机器的容器、容器化业务需要考虑的网络、存储、配置文件、负载均衡、高可用性等问题，都可以用k8s默认功能处理，k8s属于是前期投入有点困难，搭建起来之后，除了学习成本，是非常好用的，从市场可以得以验证 k8s的核心组件有哪些（⭐️⭐️⭐️⭐️⭐️）？ 组件功能描述部署位置etcd数据库，用于存储pod的信息可以单独部署，也可部署在masterapi-serverk8s所有请求的入口，k8s所有组件通信都走ssl证书，为了足够安全，你的请求是可信任，被允许，认证授权两道关卡部署在mastercontroller manager为了让你的pod更好的运行部署在masterscheduler调度器，决定pod调度到那台机器上部署在masterkubelet安装在目标的node节点上（拉镜像、运行容器、设置容器iptables流量转发规则）部署在master和node节点container runtime接纳任意符合容器规范的软件，如docker软件部署在masterkube-proxyk8s的网络管理，service、ingress规则，生成iptables规则等部署在master和node节点kubectl管理，维护k8s客户端换，和服务端交互的一个命令行工具部署在master和node节点kubelet管理pod的工具，增删改查pod再具体机器上部署在master和node节点flannel网络插件负责pod之间的网络通讯，也有其他的网络插件，如：calico部署在master和node节点 k8s-master上运行哪些核心组件 etcd（非必安装在master上）、apt-server、controller manager、scheduler、kube-proxy、kubectl、kubelet、flannel、docker k8s-node上运行哪些核心组件 docker、kube-proxy、kubectl、kubelet、flannel pod创建流程是什么样的？
k8s集群安装方法
kubeadm初始化，下载k8s必备组件的镜像，运行pod生成k8s的证书，配置文件部署网络插件k8s-node 是用kubeadm join 加入集群 kubectl 命令 是否指定namespace设置好bash补全：安装 bash-completion-extras增删改查pod资源：kubectl get pods -owide快速创建一个nginx-pod： kubectl run nginx-test --image=nginx:1.20修改nginx-pod的内容： kubectl exec nginx-test – sh -c “echo ‘这是一个测试页面’ &gt; /usr/share/nginx/html/index.html” 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/410f1e52dd1ee703bb8e37e4dd056034/" rel="bookmark">
			使用 Nginx 将部署多个子域名&amp;http服务重定向到https服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先在阿里云解析对应的子域名 打开自己的域名解析
点击添加记录
然后在nginx的配置文件下新增以下内容 # ssl证书地址,是你自己服务器上证书存放的地址 ssl_certificate /ssl/fullchain.cer; ssl_certificate_key /ssl/cert.key; #请按照以下协议配置 ssl_protocols TLSv1.2 TLSv1.3; #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; #表示优先使用服务端加密套件。默认开启 ssl_prefer_server_ciphers on; # http 重定向到 https server { listen 80; server_name _; return 301 https://$host$request_uri; } server { listen 443 ssl; server_name www.1024bugs.top; # 对应项目1地址 root /www/web/dist; index index.html index.htm; } server { listen 443 ssl; server_name h5.1024bugs.top; # 对应项目2的地址 root /www/h5/h5-vant; index index.html index.htm; } server { listen 443 ssl; server_name web.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/410f1e52dd1ee703bb8e37e4dd056034/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2f1965d2b5960a92efd71d55967558d/" rel="bookmark">
			Python学习-基础（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习笔记-Python
学习地址：Python教程 - 廖雪峰的官方网站
健忘选手，做好笔记，温故而知新
注释代码块数据类型/，//，%字符编码格式化 一：注释
#python注释（ctrl+/）：也可以选中当多行注释用 备注：在java中注释有 单行注释（Ctrl + /）：// 多行注释（选中代码，Ctrl+Shift+/）：/* ...... */ 取消还是同样操作 二：代码块
每一行都是一个语句，当语句以冒号:结尾时，缩进的语句视为代码块，使用4个空格的缩进 //使用pycharm直接帮我缩进了 if a &gt;= 0: print(a) 备注：java是这样写的 if (a &gt;= 0){ System.out.println(a); } 三：数据类型
#整数：Python3 支持 int（长整型）、float、bool、complex（复数） a = int(input("输入十进制数字10：")) print("二进制:", bin(a), "八进制:", oct(a), "十六进制:", hex(a)) 结果：二进制: 0b1010 八进制: 0o12 十六进制: 0xa 二进制：以0B或者0b开头 八进制：以0o或0O开头 十六进制：以0X或0x开头 print(type(a)) &lt;class 'int'&gt; print(isinstance(a, int)) True //整数 十六进制用0x前缀和0-9，a-f表示 //浮点数 对于很大或很小的浮点数，用科学计数法表示，把10用e替代，1.23x109(9是次方)就是1.23e9；0.000012可以写成1.2e-5 //字符串 以单引号'或双引号"括起来的任意文本 如果'本身也是一个字符，那就可以用""括起来 如果字符串内部既包含'又包含"，可以用转义字符\来标识：如\',\" // r'内容' , ''内部的字符串默认不转义 print(r'a\\1,') 结果a\\1, // r'''内容'''(里面的内容换行输出可以换行) print('''111 222 333''') //布尔值 布尔值只有True、False两种值 布尔值可以用and（与）、or（或）和not（非）（单目运算符）运算 not True输出的false //空值 用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值 还有列表、字典、自定义类型等 备注：java是这样的 Java中8种基本数据类型(内置数据类型)： 逻辑类型：boolean 整数类型：byte,short,int,long 字符类型：char 浮点类型：float,double 还有引用类型：如string //变量 变量名必须是大小写英文、数字和_的组合，且不能用数字开头 可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据 a = 'ABC' b = a a = 'XYZ' print(b) b输出的是ABC #静态语言，动态语言 a = 1 这种变量本身类型不固定的语言称之为动态语言 在java中 int a = 1 这种就是静态语言，a被定义整型，如果a = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2f1965d2b5960a92efd71d55967558d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf0ec05d3417b43f5c9257a0e789ae9d/" rel="bookmark">
			什么是去中心化云计算？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		去中心化云计算是一种新型的云计算方式，它与传统的中心化云计算不同，将数据和计算任务分布到多个节点上，而不是将数据集中存储在中心服务器上。这种云计算方式具有许多优势，包括提高数据安全性、降低运营成本、增强可扩展性和灵活性等。
1、去中心化云计算可以提高数据安全性
由于数据被分散存储在多个节点上，即使部分节点遭到攻击或损坏，数据也不会丢失或被窃取。此外，由于数据的分散性，去中心化云计算还可以有效防止单点故障的出现，从而提高了系统的可靠性和稳定性。
2、去中心化云计算可以降低运营成本
在传统的中心化云计算中，需要大规模投资才能获得回报，而且需要专业的IT人员来维护和管理。而去中心化云计算可以通过众包的方式，将计算任务分配给多个节点，从而降低了运营成本。此外，去中心化云计算还可以通过共享经济的方式，将闲置的IT资源整合起来，从而提高了资源的利用率。
3、去中心化云计算具有可扩展性和灵活性
由于数据和计算任务被分散到多个节点上，去中心化云计算可以轻松地扩展系统的规模，以满足不断增长的业务需求。此外，由于节点的多样性和可配置性，去中心化云计算还可以根据不同的业务需求进行定制化开发，从而提高了系统的灵活性和适应性。
4、去中心化云计算还具有透明性和可审计性
由于数据和计算任务被分散到多个节点上，每个节点都有自己的数据和计算任务记录，从而使得整个系统的运行状态可以被实时监控和审计。这有助于提高系统的透明度和可信度，从而增强了用户对系统的信任和依赖。
综上所述，去中心化云计算是一种具有许多优势的新型云计算方式。它可以提高数据安全性、降低运营成本、增强可扩展性和灵活性、提高透明度和可审计性等。未来随着技术的发展和应用的普及，去中心化云计算将会在更多领域得到应用和推广。
​
​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bd95d5847274dd99528689a38b4bf18/" rel="bookmark">
			PostgreSQL定期清理归档(pg_wal)日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行了5个月的数据库，突然发现服务器磁盘快满了，一看是归档日志很大，打算写个脚本在不影响数据库运行的情况下定期清理PostgreSQL中的archive日志。
我的postgresql.conf中的归档日志配置（不做配置的话默认归档日志在pg_wal中）：
archive_mode = on archive_command = 'cp %p /home/archive/%f' 1. 清理方法 读取控制文件以确定可以清理的WAL（Write-Ahead Logging）文件范围。可以使用pg_controldata命令来获取这些信息。
pg_controldata $PGDATA 将显示当前可以删除的WAL文件的范围。
下图中表示：000000010000003700000007这个文件之前的文件都可以删除了
也可以通过pg_archivecleanup清理（前提是没有配置archive_command路径，使用默认路径pg_log）
执行如下命令将会清除000000010000003700000007之前的所有日志。
pg_archivecleanup -d $PGDATA/pg_wal 000000010000003700000007 PS：我自己是直接用下面的脚本清理，很好用！
定时任务：每周5的凌晨2点执行
0 2 * * 5 cd /home/scripts &amp;&amp; ./wal_clean.sh &gt;&gt; ./logfile.log 2&gt;&amp;1 2. 定期清理archive日志脚本 #!/bin/bash # 设置归档目录路径 archive_directory="/home/archive" TIME="$(date +%Y-%m-%d-%H-%M)" # 执行pg_controldata命令并提取Latest checkpoint's REDO WAL file的值 result=$(pg_controldata "$PGDATA" | grep "Latest checkpoint's REDO WAL file") value=$(echo "$result" | awk '{print $6}') # 输出结果 echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bd95d5847274dd99528689a38b4bf18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf2a4ce31a3f0fb99732fdd85e6aaa4c/" rel="bookmark">
			说一下 JVM 有哪些垃圾回收算法？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、标记-清除算法 标记无用对象，然后进行清除回收。
标记-清除算法（Mark-Sweep）是一种常见的基础垃圾收集算法，它将垃圾收集分为两个阶段：
标记阶段：标记出可以回收的对象。清除阶段：回收被标记的对象所占用的空间。 标记-清除算法之所以是基础的，是因为后面讲到的垃圾收集算法都是在此算法的基础上进行改进的。
优点：实现简单，不需要对象进行移动。
缺点：标记、清除过程效率低，产生大量不连续的内存碎片，提高了垃圾回收的频率。
标记-清除算法的执行的过程如下图所示
二、复制算法 为了解决标记-清除算法的效率不高的问题，产生了复制算法。它把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾收集时，遍历当前使用的区域，把存活对象复制到另外一个区域中，最后将当前使用的区域的可回收的对象进行回收。
优点：按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。
缺点：可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。
复制算法的执行过程如下图所示
三、标记-整理算法 在新生代中可以使用复制算法，但是在老年代就不能选择复制算法了，因为老年代的对象存活率会较高，这样会有较多的复制操作，导致效率变低。标记-清除算法可以应用在老年代中，但是它效率不高，在内存回收后容易产生大量内存碎片。
因此就出现了一种标记-整理算法（Mark-Compact）算法，与标记-清除算法不同的是，在标记可回收的对象后将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起，然后对端边界以外的内存进行回收。回收后，已用和未用的内存都各自一边。
优点：解决了标记-清理算法存在的内存碎片问题。
缺点：仍需要进行局部对象移动，一定程度上降低了效率。
标记-整理算法的执行过程如下图所示
四、分代收集算法 分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代
(YoungGeneration)。
老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。
当前商业虚拟机都采用分代收集的垃圾收集算法。分代收集算法，顾名思义是根据对象的存活周期将内存划分为几块。一般包括年轻代、老年代 和 永久代，如图所示：
当前主流 VM 垃圾收集都采用”分代收集” (Generational Collection)算法, 这种算法会根据对象存活周期的不同将内存划分为几块, 如 JVM 中的 新生代、老年代、永久代， 这样就可以根据各年代特点分别采用最适当的 GC 算法
新生代： 复制算法
老年代：标记-整理算法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fb1b9604b3315c429d1bd37956ae761/" rel="bookmark">
			Git基本操作（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git基本操作（2） 上交文件之后，git文件的变化git cat-file HEAD指针里面有啥文件被修改git statusgit diff + 文件名 版本回退（git reset）撤销回退git reflog 撤销的三种情况还没有addgit checkout -- [file] 已经add还没有commit已经add且commit 从本地仓库删除文件git rm 文件名 今天我们来继续了解Git的操作
上交文件之后，git文件的变化 我们之前不是上交了几个文件嘛，我们可以看看我们隐藏的.git文件发生什么变化没有：
我们发现，我们的对象库中记录了每次上交的commit编号，而编号的前两位就是此次上交储存在对象库中的文件名。
objects 为Git的对象库，里面包含了创建的各种版本库对象及内容。当执行git add 命令时，暂存区的目录树被更新，同时⼯作区修改（或新增）的文件内容被写⼊到对象库中的⼀个新的对象中，就位于?“.git/objects”?目录下，查找object时要将commit id 分成2部分，其前2位是⽂件夹名称，后38位是文件名称
git cat-file 找到这个⽂件之后，⼀般不能直接看到里面是什么，该类⽂件是经过? sha （安全哈希算法）加密过的文件，好在我们可以使用 git cat-file 命令来查看版本库对象的内容：
其中还有一行tree b7a6dcbed4b5f267fde31ed7438195daaace7755，我们也可以打印来看看
如果我们此时继续查看，我们就可以查看My_file里面的内容：
因为我的My_file里面没有任何内容，所以没有打印任何内容。
通过这次操作，我们可以大概理解，git会记录我们的修改操作，我们找到对应的修改操作之后，就可以找到对应的文件。
HEAD指针里面有啥 除此之外，我们可以看看HEAD指针里面有啥：
我们来看看日志：
这时候我们知道了，HEAD指针里面储存了最近一次上交时的commit编号。
文件被修改 首先，我们得知道git是追踪修改痕迹（这里的修改痕迹指的是新增文件，修改文件，删除文件）的版本控制器。我们之前把My_file文件已经上交了，如果此时我们将My_file里写入文字：
此时我们修改了工作区中的My_file文件。
git status 此时我们可以用git status来查看我们git仓库的状态：
这里提示我们工作区中一个文件被修改了，就是我们的My_file。而我们的暂存区没有改动。
git diff + 文件名 我们可以用git diff + 文件名来查看到底我们的文件有了哪些变化：
我们看到带有加号的内容就是新增的内容。
我们还可以用git diff HEAD – [file] 命令来查看版本库和工作区文件的区别。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fb1b9604b3315c429d1bd37956ae761/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/10/">«</a>
	<span class="pagination__item pagination__item--current">11/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/12/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>