<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a720fc21688ad1d7d0800655475297e/" rel="bookmark">
			窗口函数ROW_NUMBER、RANK、DENSE_RANK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 SQL 中，窗口函数是一种特殊的函数，它可以在结果集的特定窗口或分区上计算聚合、排名、行数和其他类似的分析操作。下面是一些常见的窗口函数：
1. ROW_NUMBER：为结果集的每一行分配一个唯一的整数值。
select Score, ROW_NUMBER() over(order by Score DESC) as Rank from Scores 2. RANK：为结果集的每一行分配一个唯一的排名（相同值具有相同的排名，下一个值的排名将递增）。
select Score, rank() over(order by Score DESC) as Rank from Scores 3. DENSE_RANK：为结果集的每一行分配一个唯一的密集排名（相同值具有相同的排名，下一个值的排名可能会跳过）。
select Score, DENSE_RANK() over(order by Score DESC) as Rank from Scores 4. NTILE：将结果集划分为指定数量的相等大小的桶，然后为每个桶分配一个标识号。
SELECT column1, NTILE(4) OVER (ORDER BY column1) AS bucket FROM your_table; 5. SUM, AVG, MIN, MAX：这些聚合函数可以与窗口函数一起使用，在特定的窗口或分区上计算聚合值。
SELECT column1, SUM(column2) OVER (PARTITION BY column3) AS total FROM your_table; 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a720fc21688ad1d7d0800655475297e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1600b8dbb1ac4ad1640d25b6cdb12e64/" rel="bookmark">
			谁说 Linux 不能玩游戏？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上个世纪最早推出视频游戏的例子是托马斯·戈德史密斯（Thomas T. Goldsmith Jr.）于1947年开发的“「Cathode Ray Tube Amusement Device」”，它已经显着发展，并且已成为人类生活中必不可少的一部分。
通过美国游戏行业的统计数据，游戏行业在2023年获得了966.8亿美元的利润。
尽管在此之前，还有早期的免费游戏，例如Nethack，Neterek，Xbill等。它们的数量有限，并且主要是著名的街机游戏或文字冒险的翻版。
除此之外，随着Nvidia和AMD等专有Linux驱动程序的使用，Linux上运行的游戏的性能与Windows上的游戏变得可比。现在，从街机，动作，冒险等开始，几乎所有类型的游戏都是由数千名喜欢它们的游戏迷为Linux开发的。
这是精选的10款游戏，每款游戏都因广受好评而赢得了自己的位置，这转化为开发人员的可观利润。
1. Death Stranding Director’s Cut Death Stranding Director’s Cut 是Hideo Kojia的首张游戏《 Death Stranding》的扩展。但是，这个版本并没有进行全面大修，而是设法引入了新内容，升级的视觉效果，扩展的游戏玩法等等，同时又忠于原始游戏的愿景。
该游戏设置在后世界末日的美国，您是在为桥梁工作的搬运工山姆·布里奇斯（Sam Bridges）。您的目标是在面对愤怒的鬼魂，危险的地形和极端天气的同时，将货物交付给幸存者。游戏的古怪情节，动作，探索和社交互动动态都融合在一起，创造出了不起的游戏体验。
2. Stray Stray是由Blue Twelve Studio开发的屡获殊荣的冒险游戏。在这个游戏中，主角是一只流浪猫，它陷入了充满机器人和独特机器的广阔网络。目的是浏览城市，并在机器人同伴的帮助下找到回家的路。
该游戏提供了很多东西，但在提供令人惊叹的艺术风格，身临其境的世界和未来派游戏玩法方面表现出色。您可以参加第三人称，并进步以扩展障碍物，解决难题并与地图互动以访问新途径。通常，Stray 是您在Linux上可以找到的最好的休闲冒险游戏之一。
3. Dying Light 由Techland开发的《Dying Light》系列是最受欢迎的生存恐怖游戏系列之一。由于其故事情节，令人印象深刻的视觉效果和身临其境的游戏玩法，这款世界末日后的游戏赢得了许多游戏玩家的心。该系列有两个版本 -《Dying Light》和《Dying Light 2》。
《Dying Light》设置在一个充满僵尸的广阔的开放世界中，您是作为卧底特工的扮演，其工作是渗透到哈兰隔离区。
游戏玩法包括跑酷和一个夜间周期的城市。僵尸在白天较慢，晚上更活跃，因此您必须在白天寻找用品和工艺武器，并在晚上防御僵尸。
总体游戏玩法，创新战斗系统和合作模式（可让您最多邀请3个玩家）使《 Light》成为Linux上最好的僵尸游戏之一。
4. Elden Ring 我们怎么能不提到2022年度年度最佳游戏奖得主埃尔登·雷恩（Elden Ring）？该游戏由FromSoftware创作，由Bandai Namco Entertainment发布，是一个动作RPG。
该游戏的事件发生在一个充满城堡，地牢和其他奇妙地标的广阔世界中。对于Linux游戏玩家来说，幸运的是，由于其首次亮相Elden Ring在Linux上非常合作。
Valve在Steam Deck和Linux方面做得很好，这从Elden Ring在释放时兼容这一事实可以很明显。
游戏的黑暗灵魂般的主题以及G.R.R Martin的投入确实为这场比赛带来了奇迹。该游戏的接待非常好，并通过其动态战斗，隐形力学和广阔的开放世界进一步推广。如果您正在寻找最终的幻想体验，请潜入Elden Ringworld。
5. Tomb Raider Crystal Dynamics和Eidos-Montreal的这一合作努力是游戏史上最著名的动作冒险系列之一。 《古墓丽影》（Tomb Raider）是一款以女性考古学家，勇士和冒险家的身份拉拉·克罗夫特（Lara Croft）为中心的游戏。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1600b8dbb1ac4ad1640d25b6cdb12e64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e57100117c77a6072f38c9fae897e736/" rel="bookmark">
			吊打98%的JAVA同行，这份阿里P8架构师升级手册登上天梯！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 我们都是IT人，所以，我们注定了很像。
前段时间有个朋友去阿里面试，作为一个社招生，太多痛苦了。都知道进大厂最好的时机就是应届生的时候。作为社招生，太难了。
我这位朋友经历了五轮面试最后才上阿里做了P6的职位。我也不得不佩服这位朋友的社交能力，和阿里的一个P8熟悉后，那个大佬看他学习能力强，有上进心，于是把他的个人经验手册给了他学习。为了感谢我之前送给他的P6面试笔记，又把这份文档送给了我。所以今天我分享出来。
对于面试题想要的看我之前的文章：从GitHub火到头条！这份万众期待的阿里内部JAVA面试手册，开源了
今天主要是想分享这份阿里P8的晋升手册。 简述一下这份文档说了那些技术栈：“JVM ==&gt; JAVA集合 ==&gt; Java多线程和并发 ==&gt; JAVA基础 ==&gt; Spring原理 ==&gt; 微服务 ==&gt; Netty与RPC ==&gt; 网络 ==&gt; 日志 ==&gt; Zookeeper ==&gt; kafka ==&gt; RabbitMQ ==&gt; Hbase ==&gt; MongoDB ==&gt; Cassandra ==&gt; 设计模式 ==&gt; 负载准衡 ==&gt; 数据库 ==&gt; 一致性算法 ==&gt; Java算法 ==&gt; 数据结构 ==&gt; 加密算法 ==&gt; 分布式缓存 ==&gt; Hadop ==&gt; Spark ==&gt; Storm ==&gt; YARN ==&gt; 机器学习 ==&gt; 云计算 ”
共29个技术栈，看名字都能眼花缭乱的了。
内容是彩版的。
限于文章篇幅原因，只能以截图的形式展示出来，有需要的小伙伴帮忙文末↓↓↓获取相关资料
内容节选 JVM篇：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e57100117c77a6072f38c9fae897e736/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1cac96b4f105c337cb1954659ecf250/" rel="bookmark">
			重磅！程序员都在学的Spring实战（第6版），你竟然还没有掌握？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 不知不觉已经接近年底了，可能很多程序员还在迷茫阶段，不知道该如何学习进步。
但是你该起来学习了，在躺平下去就真的废了，没有经济来源，没有工作，也就赶不上明年金三银四招聘旺季。
很不巧的是，《Spring实战第5版》新升级——第六版竟然重磅上市！这些总有的学了吧？
限于文章篇幅原因，只能以截图的形式展示出来，有需要的小伙伴帮忙点赞凭截图文末↓↓↓名片获取相关资料
首先，大家看下目录 其次，看包含的主要内容 全文包含四部分的内容，其中四部分的内容又划分为18章，为大家展开介绍spring，从spring使用框架，springboot，以及spring系统中的其他组成部分。
第1部分（第1章~第6章）涵盖了构建Spring应用的基础知识。
第2部分（第7章~第10章）讨论了如何讲Spring应用与其他应用进行集成。可以学习创建 Web 应用、处理数据、保证应用安全，以及管理应用配置等内容
第3部分（第11章~第14章）探讨了Spring对反应式编程提供的全新支持，学习包括使用新的RSocket通信协议在内的反应式编程内容。
第4部分（第15章~第18章）介绍了如何做好应用投入生产环境前的准备工作，以及如何进行部署。将会学习各种部署方案，在生产环境中准备应用程序，完成整个Spring学习。
全文的内容安排从易到难、从简单到复杂，读者可以从简单的初始化着手，慢慢接触更复杂的项目内容，在作者保姆式的教学下完成上线部署一个完整的Spring项目。
那如何投入学习呢？ 电子版Spring实战（第六版）已经为大家准备好了，希望大家能够喜欢！
下方↓↓↓名片获取相关资料
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3d41af9d6d19b98dd37cb2be1adb3aa/" rel="bookmark">
			HashMap源码详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HashMap简介 HashMap是Java语言中的一种集合类，它实现了Map接口，用于存储Key-Value对。它基于哈希表数据结构，通过计算Key的哈希值来快速定位Value的位置，从而实现高效的插入、删除和查找操作。下面我们对照着JAVA1.8中的HashMap源码来分析一下它的内部实现逻辑
基本的结构 在开始分析HashMap的实现逻辑之前，我们需要先了解一下基础的组成和内部的成员变量都有哪些，分别代表什么意思。
1、Node&lt;K,V&gt; 首先我们看一下HashMap其中一个子类:Node&lt;K,V&gt;，这个子类用于存储基本的元素，即Key-Value对、Key的Hash值以及指向下一个节点的Node&lt;K,V&gt;变量。在HashMap内部，由Node&lt;K,V&gt;类型组成的数组用来存储所有的元素。 Node&lt;K,V&gt;实现自Map.Entry&lt;K,V&gt;接口，并且实现了接口中规定的多个基本方法:
interface Entry&lt;K,V&gt; { K getKey(); V getValue(); V setValue(V value); boolean equals(Object o); int hashCode(); ... } 同时，在Node&lt;K,V&gt;类中，定义了4个成员变量：
public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;,Cloneable,Serializable { .... static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3d41af9d6d19b98dd37cb2be1adb3aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ee9c5d85b227f0c6140bb8202fd807f/" rel="bookmark">
			【C语言】动态内存管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是苏貝，本篇博客带大家了解动态内存管理，如果你觉得我写的还不错的话，可以给我一个赞👍吗，感谢❤️
目录 一. 为什么存在动态内存分配二. 动态内存函数的介绍2.1 malloc和free2.2 calloc2.3 realloc 三. 常见的动态内存错误四. 几个经典的笔试题4.14.24.34.4 五. C/C++程序的内存开辟六. 柔性数组6.1 柔性数组的特点6.3 柔性数组的优势 一. 为什么存在动态内存分配 我们已经掌握的内存开辟方式有：
int val = 20; 在栈空间上开辟四个字节
char arr[10] = {0}; 在栈空间上开辟10个字节的连续空间
但是上述的开辟空间的方式有两个特点：
空间开辟大小是固定的。数组在申明的时候，必须指定数组的长度，它所需要的内存在编译时分配。 但是对于空间的需求，不仅仅是上述的情况。有时候我们需要的空间大小在程序运行的时候才能知道，那数组的编译时开辟空间的方式就不能满足了。这时候就只能试试动态存开辟了
二. 动态内存函数的介绍 2.1 malloc和free C语言提供了一个动态内存开辟的函数:
这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。
○如果开辟成功，则返回一个指向开辟好空间的指针
○如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查。
○返回值的类型是 void* ，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定。
○如果参数 size 为0，malloc的行为是标准是未定义的，取决于编译器
○使用malloc函数后，一定要记得判断malloc函数的返回值是否为NULL
○要记得对malloc函数开辟的空间进行释放
C语言提供了另外一个函数free，专门是用来做动态内存的释放和回收的，函数原型如下：
free函数用来释放动态开辟的内存。
○如果参数 ptr 指向的空间不是动态开辟的，那free函数的行为是未定义的。
○如果参数 ptr 是NULL指针，则函数什么事都不做
malloc和free都声明在 stdlib.h 头文件中
示例1：
int main() { //申请一块空间，用来存放10个整型 int* p = (int*)malloc(10 * sizeof(int)); //int* p = (int*)malloc(40);也可 if (p == NULL) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ee9c5d85b227f0c6140bb8202fd807f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a0b54b1bdde8c9f77c5faacb4b862e6/" rel="bookmark">
			vue项目没有路径别名智能提示如何解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在项目根目录下 配置tsconfig.json或者jsconfig.josn 没有的话就手动创建一下
{ "compilerOptions": { "experimentalDecorators": true, //主要是这一段 start "baseUrl": "./", "paths": { "@/*": ["src/*"], "components/*": ["src/components/*"], "assets/*": ["src/assets/*"], "views/*": ["src/views/*"], "common/*": ["src/common/*"], } //end }, "exclude": ["node_modules", "dist"] } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd787e6121e63c11ac662ae5e74523b3/" rel="bookmark">
			SQL server查看各表的索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、要查看 SQL Server 数据库中的索引，可以使用如下 SQL 语句：
SELECT TableName = t.name, IndexName = ind.name, ind.type_desc, ind.is_unique, ind.is_primary_key, ColumnNames = stuff( ( select ', ' + col.name + case when ic.is_descending_key = 1 then ' desc' else '' end from sys.index_columns ic inner join sys.columns col on ic.object_id = col.object_id and ic.column_id = col.column_id where ic.object_id = ind.object_id and ic.index_id = ind.index_id order by ic.index_column_id for xml path ('') ),1,2,'' ) FROM sys.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd787e6121e63c11ac662ae5e74523b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24e3b43000d450cfd8e7077c5e9f8e96/" rel="bookmark">
			司马阅再升级，明显领先国产AI文档同行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		司马阅再升级！！！
AI读论文/合同/报告/简历/财报…等文档
提升办公、学习效率10倍
【升级功能】
01、新增DOCX、DOC、TXT、HTML文档上
传除了最主流的PDF文档外，本次升级支持了Word文档（DOCX、DOC）、纯文本（TXT）、网页（HTML）上传，方便更多用户朋友体验到AI文档分析的便利，不再需要转换文档格式。
02、上传分析文档速度更快
可能是目前市面上上传、解析文档最快的产品之一。
03、更深度理解、分析文档
本次升级了司马阅独家AI文档智能算法，更深度、更精准理解文档。
如图，理解论文的公式，并根据论文数据进行复杂公式运算。
04、升级「文档库」，提升跨文档理解性能
如图，上传雷军4年演讲，对雷军整体演讲进行分析总结。
*除上述更新升级外，还有更多细节优化，欢迎登录司马阅官网使用：
https://smartread.cc/
【司马阅VS国产同类AI】
我们将市面上的「国产AI文档阅读产品」做了对比测评包括(司马阅、WPSAI、网易旗下的有道速读、360旗下的AI数字员工、科大讯飞旗下的讯飞星火文档问答)，「司马阅」在更复杂的文档「分析精准度」方面优势，表现更明显，更适合专业人士使用。
↓到官方查看国产AI文档产品对比视频↓
推荐
《60份精选AI研究报告,彻底读透AI应用场景与商业逻辑》（到官方领取）
司马阅(SmartRead)，是一款AI文档阅读分析工具，基于AI智能文档技术，快速从复杂文档提取信息。 通过聊天互动形式，精准、灵活地获取关键信息及灵感，极大节省文档阅读和信息检索时间，高效应用于工作、学习场景，如读报告、读论文、读合同…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e673257e73087a56b3901c5b88a75f8/" rel="bookmark">
			Vue数据更新页面却没有更新的几种情况以及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情况一：Vue无法检测实例被创建时不存在于data中的变量 原因：由于 Vue 会在初始化实例时对 data中的数据执行 getter/setter 转化，所以 变量必须在 data 对象上存在才能让 Vue 将它转换为响应式的。
例如： 1 2 3 4 5 new Vue({ data:{}, template: '&lt;div&gt;{{message}}&lt;/div&gt;' }) this .message = 'Hello world!' // `message` 不是响应式的页面不会发生变化 解决方法：
1 2 3 4 5 6 7 new Vue({ data: { message: '' , }, template: '&lt;div&gt;{{ message }}&lt;/div&gt;' }) this .message = 'Hello world!' 情况二：vue也不能检测到data中对象的动态添加和删除 例如：
1 2 3 4 5 6 7 8 9 10 new Vue({ data:{ obj: { id: 1 } }, template: '&lt;div&gt;{{ obj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e673257e73087a56b3901c5b88a75f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9d68a94631a3d02d5d66550f2a1cb54/" rel="bookmark">
			java_stream流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		stream 流
文章目录 1. stream 流初体验2. 获取 Stream 流2.1 单列集合 获取 stream 流2.2 双列集合 获取 Stream 流2.3 数组获取 stream 流2.4 一堆零散数据获取 Stream 流 3. Stream 流的中间方法3.1 filter 过滤方法3.2 limit 和 skip 方法3.3 distinct 去重方法3.4 cancat 方法3.5 map 方法 4. Stream 流的终结方法4.1 forEach 遍历方法4.2 count 统计方法4.3 toArray 收集方法 (数组)4.4 Collect 收集方法 (集合) 5. Stream 流练习5.1 数据过滤5.2 自定义对象过滤并收集 前言 :
为啥要学习Steam , Stream（流）是一种在编程中处理数据序列的概念。它提供了一种高效、便捷的方式来对数据进行操作和处理。
Stream 可以看作是一个元素序列，可以是数组、集合或输入/输出资源等。与传统的集合操作不同，Stream 并不是存储数据的容器，而是通过一系列的操作来处理数据并生成结果。
使用 Stream，我们可以进行各种数据操作，例如过滤、映射、排序、聚合等。这些操作可以按照链式的方式组合，形成一个操作流水线。每个操作都会在数据上进行处理，并将结果传递给我们
本文是基于 B站 Stream 流学习的笔记 相关学习视频
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9d68a94631a3d02d5d66550f2a1cb54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e0755cef3c4dc65bffb65c1279acd00/" rel="bookmark">
			docker安装目录迁移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在安装docker时通常是默认安装的系统盘目录/var/lib/docker，而该目录通常是比较小的，一旦镜像过多就可能出现docker无法运行的情况，这时进行docker目录的迁移就可以很好地解决问题。
docker目录的迁移其实非常简单，有以下两种方法可以实现。
方法一（推荐） 1) 目录拷贝 docker镜像, 容器等信息通常是默认存储在/var/lib/docker目录下的，因此需要先将/var/lib/docker整个目录拷贝到需要迁移的目录中去
停掉docker服务： systemctl stop docker将docker存储目录拷贝到要迁移的目录中去(例如，此处为/home/nas/)： rsync -r -avz /var/lib/docker /home/nas/ 2) 链接迁移目录到原目录 mv /var/lib/docker /var/lib/docker-old ln -s /home/nas/docker /var/lib/ 3) 重启docker和验证 重启docker： systemctl start docker / systemctl restart docker 验证镜像和容器可以正常运行，即可删除/var/lib/docker-old目录（注意：在未确定镜像和容器正常运行前，千万别删除/var/lib/docker-old目录）
方法二 1) 目录拷贝 和方法1一样进行目录拷贝迁移
停掉docker服务： systemctl stop docker将docker存储目录拷贝到要迁移的目录中去(例如，此处为/home/nas/)： rsync -r -avz /var/lib/docker /home/nas/ 2) 修改配置 如果不存在配置目录则创建，存在则忽略：mkdir -p /etc/systemd/system/docker.service.d/编辑devicemapper.conf： vi /etc/systemd/system/docker.service.d/devicemapper.conf , 内容如下： [Service] ExecStart= ExecStart=/usr/bin/dockerd --graph=/home/nas/docker vi /etc/docker/daemon.json 添加 {"storage-driver": "devicemapper" } , 此处不修改可能会出现Job for docker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e0755cef3c4dc65bffb65c1279acd00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ce63422f72eb09c0bb55ab6cf9beec6/" rel="bookmark">
			快速入门Shiro - 整合SpringBoot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. Shiro简介1.1 什么是Shiro?1.2 有哪些功能？1.3 Shiro架构(外部)1.4 Shiro架构(内部) 2. HelloWorld2.1 快速实践 3. Springboot整合Shiro3.1 Shiro实现登录拦截3.2 Shiro实现用户认证3.3 Shiro整合Mybatis3.4 Shiro请求授权实现3.5 其他功能 4. shiro整合thymeleaf 1. Shiro简介 1.1 什么是Shiro? Apache Shiro是一个Java的安全(权限)框架Shiro可以非常容易的开发出足够好的应用，其不仅可以用在JavaSE环境，也可以用在JavaEE环境Shiro可以完成认证，授权，加密，会话管理，Web集成，缓存等下载地址：http://shiro.apache.org/ 1.2 有哪些功能？ Authencaition：身份认证，登录，验证用户是不是拥有相应的身份Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限，即判断用户能进行什么操作Session Manager：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中，会话可以是普通的JavaSE环境，也可以是Web环境Crytography：加密，保护数据的安全性，如密码加密储存到数据库中，而不是明文存储Web Support：Web支持，可以非常容易的集成到Web环境中Caching：缓存，比如用户登录后，其用户信息，拥有的角色，权限不必每次去查，这样可以提高效率Concurrency：Shiro支持多线程应用的并发验证，即，如在一个线程中开启另一个线程，能把权限自动的传播过去Testing：提供测试支持Run As：允许一个用户假装为另一个用户(如果他们允许)的身份进行访问Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了 1.3 Shiro架构(外部) 从外部来看shiro，即从应用程序角度来观察如何使用shiro完成工作：
subject：应用代码直接交互的对象是Subject，也就是说Shiro的对外API核心就是Subject，Subject代表了当前的用户，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等，与Subject的所有交互都会委托给SecurityManager，Subject其实是一个门面，SecurityManager才是实际的执行者SecurityManager：安全管理器，即所有与安全有关的操作都会与SecurityManager交互，并且它管理者所有的Subject，可以看出它是Shiro的核心，它负责与Shiro的其他组件进行交互，它相当于SpringMVC的DispathcherServlet的角色Realm：Shiro从Realm获取安全数据(如用户，角色，权限)，就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较，来确定用户的身份是否合法，也需要从Realm得到用户相应的角色，权限，进行验证用户的操作是否能够进行，可以把Realm看出DataSource 1.4 Shiro架构(内部) 2. HelloWorld 2.1 快速实践 创建一个普通的maven父工程，用于shiro的学习，删掉不必要的东西
创建一个普通的maven子工程，demo01
根据官方文档，我们来导入Shiro依赖
&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- configure logging --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ce63422f72eb09c0bb55ab6cf9beec6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/528e10d5ca6edc1c8908b937cdf3ecc7/" rel="bookmark">
			SpringBoot - 简单构建web服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 第一个springboot程序2. IDEA快速创建springboot项目3. Springboot自动装配原理3.1 启动器3.2 主程序 4. yaml4.1 yaml语法4.2 给属性赋值的几种方式 5. JSR303数据校验6. 多环境配置及配置文件位置6.1 配置文件可以存在的位置6.2 多套配置环境直接快速切换 7. 自动配置原理再理解7.1 精髓7.2 其他 8. SpringBoot Web开发8.1 静态资源导入8.2 首页订制8.3 图标订制8.4 模板引擎8.5 Thymeleaf语法8.6 扩展装配SpringMVC 9. 员工管理系统9.1 首页配置9.2 国际化9.3 登录功能实现9.4 登录拦截器9.5 展示员工列表9.6 404页面处理 10. 整合JDBC11. 整合Druid数据源12. 整合Mybatis13. SpringSecurity(安全)13.1 用户认证和授权13.2 注销及权限控制13.3 记住我及登录页定制13.3 记住我及登录页定制 1. 第一个springboot程序 springboot:https://start.spring.io/
通过该网站进行项目搭建，下载压缩包，解压后导入IDEA
程序的主入口（该类本身就是spring的一个组件）：
@SpringBootApplication public class HelloworldApplication { public static void main(String[] args) { SpringApplication.run(HelloworldApplication.class, args); } } springboot可以直接运行，内置了tomcat
我们项目的目录要和程序的主入口类在同一目录下，如
写一个Controller，我们不需要任何配置，就可以直接访问
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/528e10d5ca6edc1c8908b937cdf3ecc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20348fe75392ee6a338cf7c2b543237a/" rel="bookmark">
			SpringMVC - 学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 SpringMVC1. 初识SrpingMVC2. SpringMVC执行原理3. 使用注解实现SpringMVC4. RestFul风格5. 重定向和转发6. 接收请求参数及数据回显6.1 处理提交数据6.2 数据回显到前端 7. 乱码问题解决9. 补充10. 拦截器11. 文件上传 SpringMVC 1. 初识SrpingMVC ssm：spring+springmvc+mybatis MVC三层架构
Spring：IOC 和 AOP
SpringMVC：SpringMVC的执行流程！
MVC：模型(dao,service)，视图(jsp)，控制器(Servlet)
pojo：实体类，如User
vo：视图层的对象实体类，如UserVo
dto：数据传输的时候的对象实体类，如UserDto
SpringMVC特点：
轻量级，简单易学高效，基于请求响应的MVC框架与Spring兼容性好，无缝结合约定优于配置功能强大：RESTful，数据验证，格式化，本地化，主题等简洁灵活 Spring的web框架围绕DispatcherServlet设计。DispatcherServlet的作用是将请求分发到不同的处理器。从Spring2.5开始，使用java5或以上版本的用户可以采用注解的controller声明方式
快速入门：
在web.xml配置
&lt;!--注册DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--关联一个springmvc配置文件：springmvc-servlet.xml--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--启动级别1--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--/ 匹配所有的请求：(不包括.jsp)--&gt; &lt;!--/* 匹配所有的请求：(包括.jsp)--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 新建一个配置文件spring-mvc.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!--处理器映射器--&gt; &lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20348fe75392ee6a338cf7c2b543237a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dedb1a0f7d3db47e0eb4abb29a42b7d4/" rel="bookmark">
			https 的 crt 和 key 证书生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、检查 openssl 环境 1️⃣确定是否安装 openssl
which openssl
2️⃣如果没有安装，可以通过 apt-get 或者 yum 等方式安装。
sudo apt-get install openssl
二、生成过程 1️⃣首先生成 ssl.pass.key：
openssl genrsa -des3 -passout pass:666 -out ssl.pass.key 2048
2️⃣利用 ssl.pass.key 生成 ssl.key：
openssl rsa -passin pass:666 -in ssl.pass.key -out ssl.key
3️⃣删除中间文件
rm ssl.pass.key
4️⃣接着利用 ssl.key，进一步生成 ssl.csr。执行此行命令会提示输入自定义信息，按需回车即可：
openssl req -new -key ssl.key -out ssl.csr
5️⃣最后利用 ssl.key 和 ssl.csr 生成 ssl.crt，也就是自签名的 ssl 证书文件：
openssl x509 -req -days 36500 -in ssl.csr -signkey ssl.key -out ssl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dedb1a0f7d3db47e0eb4abb29a42b7d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66de4d43e17d5ea727eabe82f5738d45/" rel="bookmark">
			转载：玩转大模型，让CodeShell跳跃于手机终端全攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：玩转大模型，让CodeShell跳跃于手机终端全攻略 背景 最近在Medium上阅读了一篇非常引人入胜的文章-“Unleashing the Potential of LLM: CodeShell’s Journey to Bringing Quantized Models to Mobile Endpoints”，该文详细介绍了如何在智能手机上部署多语言代码大模型CodeShell，颇具趣味。但出于众所周知的原因，很多人无法访问开源的github以及模型所在的huggingface。因此，我将文章翻译成中文并转载在这里，并将模型文件和运行环境一并打包上传到百度网盘，以供大家下载使用。
模型文件和模型运行环境(百度网盘): 下载链接
提取码: 2yur
Termux: 下载链接 提取码: ivlz
介绍 不久前，我发现了备受瞩目的开源大模型项目 CodeShell。该项目提供了在个人电脑CPU环境下部署 4 bit 量化模型的解决方案。这激发了我将这一解决方案移植到移动手机端的想法。本文将详细记录这一实施过程。
1. 环境准备 1. 1 下载并安装 Termux 下载 Termux 应用并安装：Termux Releases，安装后打开Termux，进入如下页面 1.2 准备基础环境 在 Termux 中执行以下命令：
$ pkg update $ pkg upgrade $ pkg install vim openssh openssl 建议将手机和电脑连接到同一网络，以便通过 SSH 更便捷地进行操作。
$ sshd $ ifconfig # 请记录一下手机的IP地址，例如：192.168.43.1 $ id # 请记录下 Android 平台下的用户名 $ passwd # 为手机的临时用户设置密码，方便在电脑上使用 SSH # 在电脑终端中执行 $ ssh -p 8022 ANDROID_USERNAME@192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66de4d43e17d5ea727eabe82f5738d45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d6e22683cae5084bf0b36d80cb982ea/" rel="bookmark">
			C# 使用Microsoft Edge WebView2的相关总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首页其他C# C# 使用Microsoft Edge WebView2的相关总结 2023年5月15日 上午3:18 • C#
下面是关于“C#使用MicrosoftEdgeWebView2的相关总结”的完整攻略，包含两个示例。
1. MicrosoftEdgeWebView2简介 MicrosoftEdgeWebView2是一个基于Chromium的Web浏览器控件，可以嵌入到Windows应用程序中。它提供了一组API，用于在应用程序中显示Web内容，并与Web内容进行交互。
2. 使用MicrosoftEdgeWebView2 以下是使用MicrosoftEdgeWebView2的步骤：
2.1 安装MicrosoftEdgeWebView2运行时 在使用MicrosoftEdgeWebView2之前，需要先安装MicrosoftEdgeWebView2运行时。可以从Microsoft官网下载并安装MicrosoftEdgeWebView2运行时。
2.2 创建MicrosoftEdgeWebView2控件 在C#中，可以使用Windows Forms或WPF创建MicrosoftEdgeWebView2控件。以下是一个使用Windows Forms创建MicrosoftEdgeWebView2控件的示例：
using Microsoft.Web.WebView2.WinForms; public partial class Form1 : Form { private WebView2 webView; public Form1() { InitializeComponent(); webView = new WebView2(); webView.Dock = DockStyle.Fill; this.Controls.Add(webView); } } 在上面的示例代码中，我们创建了一个名为“webView”的WebView2控件，并将其添加到Windows Forms窗体中。
Python技术站热门推荐：
PDF电子发票识别软件，一键识别电子发票并导入到Excel中！
10大顶级数据挖掘软件！
人工智能的十大作用！
2.3 加载Web内容 可以使用WebView2控件的Navigate方法加载Web内容。以下是一个示例，演示了如何使用Navigate方法加载Web内容：
webView.Navigate("https://www.example.com"); 在上面的示例代码中，我们使用WebView2控件的Navigate方法加载了一个名为“https://www.example.com”的Web内容。
2.4 与Web内容交互 可以使用WebView2控件的各种事件和方法与Web内容进行交互。以下是一些常用的WebView2控件事件和方法：
NavigationStarting：在开始导航时发生。NavigationCompleted：在导航完成时发生。SourceChanged：在WebView2控件的源更改时发生。ExecuteScriptAsync：在WebView2控件中执行JavaScript脚本。 以下是一个示例，演示了如何使用ExecuteScriptAsync方法在WebView2控件中执行JavaScript脚本：
webView.CoreWebView2.ExecuteScriptAsync("alert('Hello, World!');"); 在上面的示例代码中，我们使用ExecuteScriptAsync方法在WebView2控件中执行了一个JavaScript脚本，该脚本弹出一个名为“Hello, World!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d6e22683cae5084bf0b36d80cb982ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ce35d563d685d1dde00a6df23209f6e/" rel="bookmark">
			RabbitMQ (4)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RabbitMQ (4)
文章目录 1. 死信的概念2. 死信的来源3. 死信代码案例3.1 TTL 过期时间3.2 超过队列最大长度3.3 拒绝消息 前言
上文我们已经学习完 交换机 ，知道了几个交换机的使用 ，下面我们来学习一下 死信队列
1. 死信的概念 先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息 进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。
应用场景：为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效。
2. 死信的来源 消息 TTL 过期 : TTL 是 Time To Live 的缩写， TTL 就是 生存时间队列达到最长长度 : 队列满了 ， 无法添加数据到 MQ 中消息被拒绝 （basic.reject 或 basic.nack） 并且 requeue = false 3. 死信代码案例 这里 创建一个 direct 交换机 ，两个消费者 ， 一个生产者 ， 两个 队列 (一个为 消息队列 ， 一个为死信队列)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ce35d563d685d1dde00a6df23209f6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ea53667ab7af436bac078590e2cfd06/" rel="bookmark">
			C# 海康威视平台API接入 和网页摄像头部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言相关网址综合安防管理平台网址获取Appkey和Secret/密码和密钥测试个人魔改工具类 海康视频接入获取摄像头Id下载海康Web插件原生Html导入网页设置 JS封装封装代码使用设置成功！ 前言 最近有个需求是将海康的摄像头视频画面传到我们平台上，作为一个全干工程师，网页后端都要我来做。
相关网址 海康开发平台 资源中心
综合安防管理平台 我这里用的是综合安防管理平台
网址 综合安防管理平台 API
OpenApi 下载
获取Appkey和Secret/密码和密钥 具体步骤可以看这个
python调用海康视频汇聚平台API，获得所有摄像头设备编号、实时播放rtsp地址、回放rtsp地址
保证有默认合作方
拿到Key和Secret
测试 随便找个Api测试
测试成功，有返回信息就可以了
个人魔改工具类 还是不喜欢全局静态的写法
using System; using System.Collections.Generic; using System.Linq; using System.Net.Security; using System.Net; using System.Security.Cryptography.X509Certificates; using System.Security.Cryptography; using System.Text; using System.Threading.Tasks; namespace HaiKang { public class HaiKangService { /// &lt;summary&gt; /// 平台ip /// &lt;/summary&gt; private string _ip; /// &lt;summary&gt; /// 平台端口 /// &lt;/summary&gt; private int _port = 443; /// &lt;summary&gt; /// 平台APPKey /// &lt;/summary&gt; private string _appkey; /// &lt;summary&gt; /// 平台APPSecret /// &lt;/summary&gt; private string _secret; /// &lt;summary&gt; /// 是否使用HTTPS协议 /// &lt;/summary&gt; private bool _isHttps = true; /// &lt;summary&gt; /// 设置信息参数 /// &lt;/summary&gt; /// &lt;param name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ea53667ab7af436bac078590e2cfd06/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/24/">«</a>
	<span class="pagination__item pagination__item--current">25/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/26/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>