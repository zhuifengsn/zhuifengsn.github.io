<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d6deeab965b771c5a2af1cf0c14463a/" rel="bookmark">
			【浙江大学 C&#43;&#43; 翁恺老师】学习笔记P10-P20
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 10 对象初始化11 new&amp;delete12 访问限制13 初始化列表14 对象组合15 继承16 父类子类的关系17 函数重载和默认参数（缺省参数值）18 内联函数19 Const20 不可修饰的对象 浙江大学 C++ 翁恺老师 B站视频链接
10 对象初始化 C语言可以在函数的任意位置定义变量（不一定放在函数的最前面），但要求在第一次使用之前。
空间在进入函数大括号时分配，而构造器在运行到定义行时才被调用。
default constructor：自己写的没有参数的构造函数。
11 new&amp;delete new：分配空间得到地址+调用构造函数
delete：调用析构函数+通过地址释放空间
new创建数组则要使用delete[]（否则释放了所有空间，但只调用了一次析构函数）。
12 访问限制 public：公开的，任何函数都可以访问。private：私有的，只有类的成员函数可以访问。
同一个类的实例化对象之间可以互相访问私有成员。 如下：set()、f()和g()是类的成员函数，而main()不是。
friend：在X类中声明Y是X的朋友，则Y可以访问X的私有成员。
protect：只有类自己和其子类可以访问。 struct和class在C++中的区别：
不限制访问属性时，struct默认是public，而class默认是private。
13 初始化列表 14 对象组合 软件重用的一种方式。
Composition：声明类时，其成员变量可以是另外一个类对象。
包含的方式：
Fully：整个置于类内。By reference：通过地址访问。 15 继承 软件重用的一种方式。
Inheritance：用一个已有类来定义一个新类的手段。
如下：已有Person类，Student类继承了Person类。所以Person是Student的父类，Student是Person的子类（超集）。
举例：
16 父类子类的关系 当构造子类对象时，会调用父类的构造函数。
若父类的构造函数有参数，子类需写自身的构造函数，并通过initialize list传入参数。
构造时先调用父类构造函数，再调用子类构造函数。
析构时先调用子类析构函数，再调用父类析构函数。
当子类和父类函数同名时，它俩没有关系。
17 函数重载和默认参数（缺省参数值） 返回类型不能作为重载的条件。
若不能找到参数类型完全匹配的重载函数，则报错。
/
Default argument：在声明函数时预先给一个值作为默认值（缺省参数值）。
声明时，只能在.h中声明默认值，而.cpp仍与原函数相同。
在调用函数时，可以从最右边开始省略。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d6deeab965b771c5a2af1cf0c14463a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2752cd4493c3bb329f5673b51ad4d13c/" rel="bookmark">
			【浙江大学 C&#43;&#43; 翁恺老师】学习笔记P1-P9
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 2 什么是面向对象3 面向对象基本原理4 自动售票机例子5 头文件6 时钟的例子7&amp;8 成员变量9 构造和析构 浙江大学 C++ 翁恺老师 B站视频链接
2 什么是面向对象 对象=属性（是什么）+服务（提供什么）
面向过程：按照时间顺序，一步步发生什么样的事情。
面向对象：场景中存在什么东西object，东西间的关系如何。
以上课为例：略。
以程序为例：C的struct中只有数据，C++的class中有数据和操作。
什么是面向对象：是一种分析思路和代码实现的方法。重点是关注问题领域中存在什么物件，而不是整个流程。
3 面向对象基本原理 对象间通过发送和接受消息来行动。（不要伸手直接操纵”蛋黄“）
消息：由发送方撰写，由接收方分析，通过方法来实现。消息可能导致接收方更改状态或返回结果。
东西Object：具体到某一个实体。
类Class：某一类实体的集合，是一种概念。
面向对象的五条原则：
所有东西都是对象。程序是一个通过发送消息的方式，告诉彼此应该做什么what to do的对象集合。每一个对象有由其他对象组成的内存。每一个对象有一个类型。一个特定类型的所有的对象都可以接收相同的消息。 接口Interface的作用：交流和保护。
内部的隐藏：让类的创造者更改类的内部，而让类的使用者远离类的内部。
面向对象的三大原则：
封装Encapsulation 将数据和处理这些数据的方法捆绑在一个对象中隐藏数据和操作的详细信息仅限制对公开方法的访问 继承多态性 4 自动售票机例子 直接创建TicketMachine的类，自动生成相应的**.h头文件和.cpp文件**。 h头文件：声明类。 #ifndef TICKETMACHINE_H_ //如果这个头文件没有被包含 #define TICKETMACHINE_H_ //就包含这个头文件并且定义这个变量 class TicketMachine { public: TicketMachine(): //构造函数 virtual ~TicketMachine(); //析构函数 void showPrompt(); void insertMoney(int money); void showBalance(); void printTicket(); void showTotal(); private: const int PRICE; int balance; int total; }; #endif /* TICKETMACHINE_H_ */ cpp文件：先#include TicketMachine.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2752cd4493c3bb329f5673b51ad4d13c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a19f1f091619a8cebf801a3ee65a6592/" rel="bookmark">
			opencv3安装(ubuntu18.04）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 运行环境：1.1 环境依赖1）安装cmake2）安装依赖 2.1 opencv下载1）解压2）编译3）安装 3.1 环境配置1)修改ld.so.conf文件2)修改bash.bashrc文件3)检验是否安装成功 运行环境： ubuntu18.04.6 melodic
宏基暗影骑士笔记本
1.1 环境依赖 1）安装cmake sudo apt-get install cmake 2）安装依赖 sudo apt-get install build-essential libgtk2.0-dev libavcodec-dev libavformat-dev libjpeg-dev libswscale-dev libtiff5-dev sudo apt-get install libgtk2.0-dev sudo apt-get install pkg-config 2.1 opencv下载 https://opencv.org/releases/
1）解压 cd /home/duduzai/opencv-3.4.16 mkdir build cd build 注意cmake路径设置
在opencv-3.4.16路径下，新建local文件夹
sudo cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/home/duduzai/opencv-3.4.16/local .. 2）编译 sudo make -j32 3）安装 sudo make install 3.1 环境配置 1)修改ld.so.conf文件 sudo gedit /etc/ld.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a19f1f091619a8cebf801a3ee65a6592/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d530287986a085f7f13b09cad954f57/" rel="bookmark">
			MFC加载动态gif图片文件C&#43;&#43;语言，基于MFC的动画播放控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 MFC加载动态gif图片，使用VS2015环境 一、将下载的PictureEx.h和PictureEx.cpp放在工程文件的目录下，动态gif图片放在工程文件的res文件夹下；（GIF动图下载 https://icons8.com/preloaders/en/search/move）
（PictureEx下载 https://download.csdn.net/download/qq_41508747/87711545）
二、在“解决方案资源管理器”的头文件个源文件分别导入PictureEx.cpp和PictureEx.h
源文件&gt;添加&gt;现有项（找到在工程文件目录下的PictureEx.h和PictureEx.cpp打开）；
三、在“资源视图”，右键点击工程名称，点击“添加资源”，点击“自定义”，新建GIF类型；
四、在新建的“GIF”类型里面导入目标gif动图命名为m_GIF，在“资源管理器”的资源文件里面在此加入目标gif动图；
五、
1、在对话框中添加一个Static或者Picture Control控件，修改ID为m_pic（并将TYPE属性：选Rectangle）；
2、为控件添加一个Control类型的变量，如CStatic m_picture；
3、在.h文件里面导入头文件#include "PictureEx.h"，在把刚刚添加的CStatic m_picture改为CPictureEx m_picture（一定要先导图#include "PictureEx.h"，不然直接改会报错）；
4、在.cpp文件里面的OnInitDialog()，加入代码
CString strFile = _T(".\\res\\目标gif动图");//动图相对路径 if (m_picture.Load(strFile)) { m_picture.Draw(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34cc510634572170761c9c32d15ca07b/" rel="bookmark">
			明辰智航网络一点通网络性能测试仪可以做什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络性能测试仪（Network Performance Tester）可以帮助公司或组织测试和评估网络连接的质量和性能。以下是网络性能测试仪可以做的事情:
带宽：网络性能测试仪可以通过测试网络传输带宽，以确定计算机或网络设备之间的最大连接速度。
时延：测试网络传输时延，可帮助确定网络或设备传输数据延迟从而提高网络效率和提高用户体验。
性能：通过模拟多个网络活动，如数据传输、多个用户，网络性能测试仪 aid 运营商和 IT 支持人员检查网络中的瓶颈，缓存、服务质量和其他潜在问题。
可靠性：网络性能测试仪可测试网络运行时间、网络传输可靠性以及潜在的网络故障可能性，以确定网络的质量和可靠性。
网络安全性：网络性能测试仪可以对网络进行安全扫描，以检测潜在的漏洞和安全威胁，帮助加强网络安全。
总之，明辰智航网络性能测试仪可以帮助网站管理员和 IT 支持人员识别并解决网络问题，提高网络连接的质量和性能，并加强网络安全以确保企业和个人数据的安全。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da9d914d64b94a28b197511da86529d0/" rel="bookmark">
			明辰智航网络性能测试仪可以帮助企业做什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络性能测试仪可以帮助企业做以下几件事情：
系统性能测试：网络性能测试仪可以测试网络硬件（如交换机、路由器等）和软件（如网络应用程序或操作系统）的性能和效率。这样可以帮助企业确定是否需要升级硬件或软件，并提升整体系统性能。
网络带宽测试：网络性能测试仪可以测试网络的带宽，帮助企业确定网络的最大吞吐量以及网络的传输速率，以此来确保企业网络的流畅性和稳定性。
网络安全测试:网络性能测试仪还可以测试网络安全，包括探测网络漏洞、监视流量和检测是否有非法攻击等。它可以帮助企业加强网络安全性，确保网络不受外部攻击和威胁。
网络故障排除:网络性能测试仪可以检查网络中的故障点，例如损坏的设备、错误的配置等。通过快速的故障排除，它可以帮助企业减少损失和停机时间，提高生产效率和顾客满意度。
网络质量检测:网络性能测试仪可以评估网络的质量，例如延迟时间、数据包损失率等。企业可以根据这些数据来优化网络、提高网络的速度和可靠性。
综上所述，网络性能测试仪可以帮助企业提高网络性能、网络安全、网络质量和快速故障排除。它既可以保证企业网络的正常运行，也可以提升企业的生产效率和顾客满意度
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee779583630931499ee7b3557f395cc6/" rel="bookmark">
			如何修改rpm安装包内容，修改完成后如何重新打包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 背景 前段时间项目中有一个引入novnc服务的需求，就是使用第三方的软件包部署为服务，在我的其他文章中有介绍如何使用。最近提了个新需求：vnc服务的页面标题需要修改，里面的密码需要自动填充。也就是说，需要将第三方软件包里面的某些内容进行修改。在网上找了一些教程文章，都比较繁琐麻烦，所以我简单整理了一下
思路 正常情况下，我们拿到了rpm包只能是进行安装操作，没办法改里面的东西。所以要想办法将rpm包解压，获得安装包里面的文件，按照需求修改完后，再把文件打成rpm包。
所需工具 1、rpmbuild：用来解压和制作rpm包工具，制作rpm包时，依赖rpm包中的spec文件 安装方法：yum install rpm-build
2、rpmrebuild：用来提取原rpm包中的spec文件 安装方法：
下载安装包：http://rpmfind.net/linux/rpm2html/search.php?query=rpmrebuild
执行命令：rpm -ivh 安装包文件名.rpm
步骤 1、创建工作目录：在根目录下创建一个文件夹，后续的解压打包操作都在此文件夹内操作 本人有幸踩坑，没有创建专用的工作文件夹，直接在home目录下搞的，最后用rpmbuild打包的时候，里面有rm -rf脚本，把我的home目录干没了…血哭，项目、数据库啥的都在home目录下，全没了…cao！！
2、将要修改的rpm包放到工作目录下，执行命令进行解压： rpm2cpio rpm包名.rpm | cpio -div 3、解压完成后按照自己的需求，修改里面的文件 4、提取原rpm包的spec文件，执行命令： rpmrebuild -p -n -s test.spec rpm包名.rpm 当前目录下生成test.spec文件
5、如果有增删的文件，则要修改spec文件（如果只是修改里面某些文件的内容，则跳过此步骤） 举例：
打开spec文件：vi test.spec
原内容为：%attr(0644, root, root) “/usr/lib/123.jar”
修改文件时，将123.jar替换为了456.jar
则新内容改为：%attr(0644, root, root) “/usr/lib/456.jar”
保存test.spec
6、完成修改后，重新制作rpm rpmbuild -ba --buildroot /路径/test.spec 7、新的rpm包路径：/root/rpmbuild/RPMS 附rpm基本命令 1、安装 rpm -ivh xxx.rpm 2、查看已安装rpm软件 rpm -qa | grep xxx 3、卸载已安装rpm软件 rpm -e xxx --nodeps 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3732f362a469d8f37652812533193c48/" rel="bookmark">
			springboot中记录链路日志traceId
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 相关概念 在分布式服务架构下，一个 Web 请求从网关流入，有可能会调用多个服务对请求进行处理，拿到最终结果。在这个过程中每个服务之间的通信又是单独的网络请求，无论请求流经的哪个服务除了故障或者处理过慢都会对前端造成影响。
在分布式链路追踪中有两个重要的概念：跟踪（trace）和 跨度（span）。trace 是请求在分布式系统中的整个链路视图，span 则代表整个链路中不同服务内部的视图，span 组合在一起就是整个 trace 的视图。
traceId：用于标识某一次具体的请求ID。当用户的请求进入系统后，会在RPC调用网络的第一层生成一个全局唯一的traceId，并且会随着每一层的RPC调用，不断往后传递，这样的话通过traceId就可以把一次用户请求在系统中调用的路径串联起来。spanId：用于标识某一次RPC调用在分布式请求中的位置。请求到达每个服务后，服务都会为请求生成spanId。parent-spanId：用于标识上游RPC调用在分布式请求中的位置。请求到达每个服务后，随请求一起从上游传过来的上游服务的 spanId 会被记录成 parent-spanId，或者叫 pspanId。当前服务生成的 spanId 随着请求一起，在传到下游服务时，这个 spanId 又会被下游服务当作 parent-spanId 记录。MDC：（Mapped Diagnostic Context）映射诊断环境，是 log4j 和 logback 提供的一种方便在线多线程条件下记录日志的功能，可以看成是一个与当前线程绑定的 ThreadLocal。 public class MDC { // 添加 key-value public static void put(String key, String val) {...} // 根据 key 获取 value public static String get(String key) {...} // 根据 key 删除映射 public static void remove(String key) {...} // 清空 public static void clear() {.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3732f362a469d8f37652812533193c48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c97202d1faf3dccbc7475e23bc0d92d/" rel="bookmark">
			【Vue】Vue-route路由
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue-router官网
由vue-router模块控制，需要额外安装依赖。参考官网
npm install vue-router --save 组成 router-link：路由链接，跳转至路由视图，展示指定路由组件信息router-view：路由视图，展示路由组件信息route：路由信息router：路由对象 router-link 路由跳转，类似a标签，路由跳转作用
&lt;router-link to="" /&gt; router-view 路由视图，用于其他组件在该视图位置显示。
&lt;router-view name="name" /&gt; &lt;!-- 可以指定视图名，在路由跳转时可通过视图名指定视图位置跳转路由 --&gt; route { path:'/url', name:'name', components:{ // one,two会绑定对应名称的路由视图上&lt;router-view name='name'/&gt; default: ComponentZero, one:ComponentOne, two:ComponentTwo, }, meta: { transition: 'slide-right' }, // 路由元信息，可以通过router.meta获取指定元信息 component:ComponentZero, //在默认路由视图上跳转 redirect:'', // 重定向，也可详细描述route信息{path:'url'} children:[ // 嵌套路由 { path:'/url1', // 即/url/url1/的访问 component:ComponentOne, }, { path:'/url2', // 即/url/url2/的访问 component:ComponentTwo, } ], beforeEnter:(to, from) =&gt; { // 路由守卫，独享 // reject the navigation return false }, } router { history:createWebHashHistory(), // history模式，hash式和非hash式 routes:routes,// 绑定路由集 strict: true, // 严格区分大小写，也可在单个路由配置 sensitive: true, // 不区分大小写，也可在单个路由配置 scrollBehavior (to, from, savedPosition) { //滚动行为 // return 期望滚动到哪个的位置 }, } 匹配规则 自定义正则可重复参数大小写敏感控制可选参数 const routes = [ // 匹配 /o/3549 { path: '/o/:orderId' }, // 匹配 /p/books { path: '/p/:productName' }, // /:orderId -&gt; 仅匹配数字 { path: '/:orderId(\\d+)' }, // /:productName -&gt; 匹配其他任何内容 { path: '/:productName' }, // /:chapters -&gt; 匹配 /one, /one/two, /one/two/three, 等,至少有一个参数，否则异常 { path: '/:chapters+' }, // /:chapters -&gt; 匹配 /, /one, /one/two, /one/two/three, 等 { path: '/:chapters*' }, // 匹配 /, /1, /1/2, 等 { path: '/:chapters(\\d+)*' }, // 将匹配 /users/posva 而非： // - /users/posva/ 当 strict: true // - /Users/posva 当 sensitive: true { path: '/users/:id', sensitive: true }, // 将匹配 /users, /Users, 以及 /users/42 而非 /users/ 或 /users/42/ { path: '/users/:id?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c97202d1faf3dccbc7475e23bc0d92d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3012e2373144d338e72a3b90f0d23ac5/" rel="bookmark">
			SpringBoot项目jar、war包启动解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、jar包和war包的区别 1.1 war包 war包是Java Web应用程序的一种打包方式符合Servlet标准，它是Web Archive的缩写，主要用于存储Web应用程序相关的文件，包括Java类文件、JSP、HTML、CSS、JavaScript、图片等资源文件。war包需要部署到web服务器中（Tomcat、Apache、IIS） 1.2 jar包 jar包是类的归档文件，主要用于存储Java类文件和相关资源文件。它通常被用于封装Java应用程序或Java类库，方便程序的部署和发布jar包可以被JVM直接加载和运行。 1.3 主要区别： jar包主要用于存储Java类文件和相关资源文件，而war包主要用于存储Web应用程序相关的文件。jar包可以被JVM直接加载和运行，而war包需要被Web服务器加载和运行。jar包通常用于封装Java应用程序或Java类库，而war包用于封装Java Web应用程序。 二、SpringBoot使用war包启动 war包启动：需要先启动外部的Web服务器，实现Servlet3.0规范中引导应用启动类，然后将war包放入Web服务器下，Web服务器通过回调引导应用启动类方法启动应用。
2.1 Servlet3.0规范中引导应用启动的说明 在Servlet容器（Tomcat、Jetty等）启动应用时，会扫描应用jar包中 ServletContainerInitializer 的实现类。框架必须在jar包的 META-INF/services 的文件夹中提供一个名为 javax.servlet.ServletContainerInitializer 的文件，文件内容要写明 ServletContainerInitializer 的实现类的全限定名。这个 ServletContainerInitializer 是一个接口，实现它的类必须实现一个方法：onStartUp可以在这个 ServletContainerInitializer 的实现类上标注 @HandlesTypes 注解，在应用启动的时候自行加载一些附加的类，这些类会以字节码的集合形式传入 onStartup 方法的第一个参数中。 public interface ServletContainerInitializer { void onStartup(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx) throws ServletException; } 复制代码 2.2 SpringBootServletInitializer的作用和原理 Spirng中SpringServletContainerInitializer实现了Servlet的规范
@HandlesTypes(WebApplicationInitializer.class) public class SpringServletContainerInitializer implements ServletContainerInitializer { @Override public void onStartup(Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext) throws ServletException { // SpringServletContainerInitializer会加载所有的WebApplicationInitializer类型的普通实现类 List&lt;WebApplicationInitializer&gt; initializers = new LinkedList&lt;WebApplicationInitializer&gt;(); if (webAppInitializerClasses !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3012e2373144d338e72a3b90f0d23ac5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c1ae42186e4d8c870bef49ce447fe45/" rel="bookmark">
			原地移除数组中的所有元素val
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、原地移除数组中的所有元素val，要求时间复杂度尾O(N)，空间复杂度尾O(1)。
思路1：找到一个val后面数据依次前移覆盖。
思路2：思想将不是val的数放入一个新的数组。
思路3：双指针。——符合要求
思路3实现代码
int removeElement(int* num, int numSize, int val) { int src = 0; int dst = 0; while (src &lt; numSize) { if (num[src] != val) { num[dst++] = num[src++]; } else { src++; } } return dst; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f2e08f3a2149b52b6ab289c0a4be26e/" rel="bookmark">
			王道oj训练总结day4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 王道oj训练总结一、问题描述二、代码示例1.源代码 总结 王道oj训练总结 提示：本问题皆来自于王道oj训练营
以下是本篇文章正文内容，下面案例可供参考
一、问题描述 Description
输入一个整型数，然后申请对应大小空间内存，然后读取一个字符串，字符串的输入长度小于最初输入的整型数大小，最后输出输入的字符串即可（无需考虑输入的字符串过长，超过了内存大小）；
注意下面问题：
char *p;
scanf(“%d”,&amp;n);
p=malloc(n);
scanf(“%c”,&amp;c);//注意在scanf和gets中间使用scanf(“%c”,&amp;c),去除换行
gets§;
注意：OJ不支持fflush(stdin)清空标准输入缓冲区操作
Input
一个整型数和一个字符串，例如
10
hello
Output
输出输入的字符串，上面输入的是hello，那么输出hello
Sample Input 1
10
hello
Sample Output 1
hello
二、代码示例 1.源代码 代码如下（示例）：
#include "stdio.h" #include "stdlib.h" int main(){ int n; scanf("%d",&amp;n); char *p; char c; p=(char *)malloc(n); scanf("%c",&amp;c);//注意在scanf和gets中间使用scanf("%c",&amp;c),去除换行 gets(p); puts(p); return 0; } 总结 gets()和puts()函数的相关知识点
gets()和scanf()的区别：
gets() 的作用是从键盘上读取字符串，scanf()函数也可以进行读取，gets() 可以接收空格、Tab键， 碰到回车键输入才结束，但是scanf碰到空格、回车、Tab键 都会结束输入。
gets()和printf()的区别：
puts()的作用是输出字符并换行，printf()需要添加"\n’用来换行，而puts在输出的时候会将字符串末尾的\0’自动换成\n’。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d9a8e58d22f7a6eef685d2328c4a0c5/" rel="bookmark">
			【C#】多线程处理 --《C#本质论》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、多线程基础知识
二、System.Threading
（一）线程管理
（二）Thread.Sleep()
（三）Thread.Abort()
（四）线程池处理
三、异步任务
（一）从Thread到Task
（二）任务延续
（三）异常处理 AggregateException
（四）未处理异常
（五）取消任务
1、Task.Run()
2、长时间运行的任务
3、对任务进行资源清理
（六）C# 5.0基于任务的异步模式
1、通过async和await实现基于任务的异步模式
2、异步Lambda
3、自定义异步方法
(七)并行迭代
取消并行循环
四、设计规范
一、多线程基础知识 任务是可能出现高延迟的工作单元，作用是产生结果值或者希望的副作用。任务和线程的区别是：任务代表需要执行的一件工作，而线程代表做这件工作的工作者。
多线程处理主要用于两个方面：实现多任务和解决延迟。
操作系统通过时间分片机制模拟多个线程并发运行。处理器执行一个线程的时间周期称为时间片或量子，在某个核心上更改执行线程的行动称为上下文切换。（上下文切换是有代价的）
无论是真正的多核并行运行，还是使用时间分片技术模拟，我们说“一起”进行的两个操作是并发。实现并发操作需要异步调用，被调用的操作的执行和完成都独立于调用它的控制流。异步分配的工作与当前控制流并行执行就实现了并发性。
并行编程是指将一个问题分解成较小的部分，异步发起对每一部分的处理，最终使它们全部并发执行。
多线程程序比单线程复杂的根本原因在于单线程程序中一些成立的假设在多线程中变得不成立了，问题包括缺乏原子性、竞态条件、复杂的内存模型以及死锁。
竞态条件：当两个或多个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。
死锁：假如不同线程以不同顺序获取锁，线程就会被冻结，彼此等待对方释放它们的锁，就可能发生死锁
线程A线程B获得A上的锁获得B上的锁请求B上的锁请求A上的锁死锁，等待B死锁，等待A 二、System.Threading public const int Repetition = 500; public static void Main(string[] args) { ThreadStart threadStart = DoWork; Thread thread = new Thread(threadStart); thread.Start(); for (int i = 0; i &lt; Repetition; i++) { Console.Write("-"); } thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d9a8e58d22f7a6eef685d2328c4a0c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66c209be341aa6a43001fd56a9f380af/" rel="bookmark">
			视频存储对公安行业有什么影响
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视频存储对公安行业有非常重要的影响。通过视频存储技术，公安机关可以将现场的监控视频和其他重要视频资料保存在电子媒介上，便于随时查阅和分析。这不仅方便了公安机关对案件的调查和取证，也提高了破案效率和准确率。
另外，视频存储技术还可以为公安机关提供更多的数据来源，便于对犯罪行为进行预测和预防。例如，在城市交通监控方面，公安机关可以通过视频存储技术收集大量的交通流量信息，了解城市的出行规律，提高交通管理效率，预防交通事故和犯罪。
总的来说，视频存储技术对公安行业的影响是十分重要的，它可以提高公安机关的工作效率，为社会治安的维护和公共安全提供更全面、更高效、更科学的保障。
那么针对以上，每时每秒都在产生这海量的视频数据，针对视频存储，有没有什么办法可以降低存储空间、电费、硬盘损耗等节省海量视频数据带来的存储压力呢？
视频传输存储压缩系统可以有效的帮助公安行业对海量监控视频存储压力大等问题进行解决：
航天安网监控视频压缩存储系统针对这一问题可以帮助公安解决以下问题：
（1）平均节省90%存储空间，码流降低90%以上
（2）首创BBW视频格式
（3）多种AI算法
（4）高清无损压缩
（5）视频存储10倍扩容
（6）减少90%传输宽带
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cff04431a174b5a5c18fd3cedf17bdad/" rel="bookmark">
			海量监控视频如何存储？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		海量监控视频的存储可以采用以下几种方式：
磁盘阵列：磁盘阵列主要采用RAID技术，将多块硬盘组合起来，实现海量数据的存储和备份，具有数据读写速度快、容量大、数据可靠性高等优点。区域存储网络（SAN）：SAN是一种高速、高可用性的存储体系结构，可满足海量数据的存储和备份需求。SAN还支持可动态扩充存储容量的功能。网络附属存储（NAS）：NAS可以提供标准化存储服务，其灵活性和可伸缩性使其适用于海量监控视频存储。云存储：云存储可以提供安全、高可用、灵活、高性能的存储服务，为监控视频存储提供了一种优秀的解决方案。同时，云存储可以支持多种数据备份和恢复功能，保证数据安全性。
以上4种方法涵盖了大多数行业对海量监控视频存储的方法，但是这些方法都会遇到一个问题，那么就是海量的监控视频数据每年带来的存储成本是巨大的，无论是从硬盘数量、硬盘损耗、电费、存储空间场地等等。
北京航天安网微视拓视频数据智能管理系统提供以视频压缩、传播溯源、视频确权为特色的视频数据整体解决方案。在技术方面已实现国产化的自主可控，产品性能达到国际标准，在全球范围内具有绝对的领先优势与行业的不可替代性。平均为企业节省90%存储空间，码流降低90%以上、首创独有视频格式、多种AI算法、高清无损压缩、视频存储10倍扩容、减少90%传输宽带。
无论采用哪种方式，都需要对海量监控视频的存储进行规划和管理，包括数据的备份、恢复、定期清理等，以保证存储系统的稳定性和可靠性。选择北京航天安网微视拓视频数据智能管理系统可以有效的节省每年对视频数据存储带来的高额费用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/418162c1f38b310a1a4bda8bc63bd5de/" rel="bookmark">
			监控视频无损压缩解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着监控技术的快速发展，大量的监控视频数据被保存下来供后续分析使用。然而，这些视频文件通常是庞大而且消耗大量的存储空间，特别是那些长时间的监控记录。为了解决这一问题，压缩技术被用于减少存储空间的使用。
一种常见的压缩技术是H.265/HEVC，它是一种高效的视频压缩标准，能够将视频文件的大小减少到更小的尺寸。这种技术能够减少视频文件的大小，同时保持视频的视觉质量。此外，还有一些其他的压缩技术，如H.264和MPEG-4，也可以用来压缩监控视频。
航天安网公司自主研发的视频压缩技术可在不改变帧率、不改变视频分辨率、不改变时长、不损失特征点、不影响后续AI智能分析等条件下实现高清视频平均10倍以上无损压缩，压缩后视频文件大小平均为原文件大小的1/10。
通过自主编码的方式，率先采用以语义分割为核心的智能编码技术，通过卷积神经网络，混合高斯模型和超分辨率卷积神经网络等多种方法进行技术实现，领先优势显著。
通过对视频数据进行结构化处理，提升边缘计算效能，使视频压缩系统在不改变帧率、不改变视频分辨率、不改变时长、不损失特征点、不影响后续AI智能分析等条件下，实现高清视频平均10倍以上无损压缩
总之，压缩技术能够有效地减少监控视频存储空间的使用，提高数据的可用性和存储效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afe01a1aff6bb2a755b99a8be804c1b7/" rel="bookmark">
			王道oj训练总结day3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		王道oj训练总结 作业5-2 问题描述 Description
读取一个字符串，字符串可能含有空格，将字符串逆转，原来的字符串与逆转后字符串相同，输出0，原字符串小于逆转后字符串输出-1，大于逆转后字符串输出1。例如输入 hello，逆转后的字符串为 olleh，因为hello 小于 olleh，所以输出-1
注意最后的判断一定要这么写，因为strcmp标准C中并不是返回-1和1，而是负值和正值
Input
输入一个字符串，例如 hello，当然输入的字符串也可能是 how are you，含有空格的字符串
Output
输出是一个整型数，如果输入的字符串是hello，那么输出的整型数为-1
Sample Input 1
hello
Sample Output 1
-1
Sample Input 2
cba
Sample Output 2
1
Sample Input 3
aba
Sample Output 3
0
代码示例 #include &lt;stdio.h&gt; #include &lt;string.h&gt; #define N 1000 int main(){ char c[N],d[N]; gets(c); int length = strlen(c); int j; for (int i = length-1; i &gt;=0 ; i--) { d[j]=c[i]; j++; } int result = strcmp(c, d); if (result &lt; 0) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afe01a1aff6bb2a755b99a8be804c1b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e0d17daa0e6eba029aa21e8402d5f86/" rel="bookmark">
			usb_cam相机标定实践 ROS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 运行环境：1.1 usb_cam连接：1.2 ROS包下载1.3 准备棋盘格1.4 启动相机1.4 开始标定2.1 保存标定结果2.2 移动yaml文件2.3 在launch中添加标定文件1） 添加标定文件路径 2.4 报错解决1)修改 yaml 文件相机名称2)安装v4l-utils依赖tip:标定后相机精度有所提升 运行环境： ubuntu20.04 noetic
杰瑞微通usb_cam（分辨率640x480）
宏基暗影骑士笔记本
1.1 usb_cam连接： 1）相机usb--电脑usb 1.2 ROS包下载 mkdir -p cam_calib_ws/src cd cam_calib_ws/src sudo apt-get install ros-noetic-camera-calibration cd .. catkin_make 1.3 准备棋盘格 打印A4棋盘格（某宝可购买）：
https://markhedleyjones.com/projects/calibration-checkerboard-collection
图像阵列：12 x 9
尺寸size：11 x 8
边长square: 20mm = 0.02m
1.4 启动相机 相机配置参考博客：usb_cam 相机ROS配置
cd /home/duduzai/SPbot/usb_cam_ws roscore source ./devel/setup.bash roslaunch usb_cam usb_cam-test.launch 1.4 开始标定 启动标定程序
cd cam_calib_ws rosrun camera_calibration cameracalibrator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e0d17daa0e6eba029aa21e8402d5f86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef07aea1dea166577deaf7fef5f1454a/" rel="bookmark">
			pytorch进阶学习（三）：在数据集数量不够时如何进行数据增强
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对图片数据增强，可以对图片实现：
1. 尺寸放大缩小
2. 旋转（任意角度，如45°，90°，180°，270°）
3. 翻转（水平翻转，垂直翻转）
4. 明亮度改变（变亮，变暗）
5. 像素平移（往一个方向平移像素，空出部分自动填补黑色）
6. 添加噪声（椒盐噪声，高斯噪声）
目录
一、放大缩小
二、水平/垂直翻转
三、旋转
四、明亮度
五、平移
六、添加噪声
七、模糊
八、对一张图片进行单种变换
九、对一张图片进行多种变换
十、对数据集中所有类别的图片进行变换
数据集文件夹名为data4，第一个分类daisy中只有五张图片。 一、放大缩小 import os import numpy as np import cv2 # 放大缩小 def Scale(image, scale): return cv2.resize(image,None,fx=scale,fy=scale,interpolation=cv2.INTER_LINEAR) def TestOnePic(): test_jpg_loc = r"data4/daisy/1.jpg" test_jpg = cv2.imread(test_jpg_loc) cv2.imshow("ShowImg", test_jpg) img1 = Scale(test_jpg,0.5) cv2.imshow("Img1", img1) img2 = Scale(test_jpg,2) cv2.imshow("Img2", img2) cv2.waitKey(0) cv2.destroyAllWindows() if __name__ == "__main__": TestOnePic() 二、水平/垂直翻转 import os import numpy as np import cv2 # flipcode=1为水平翻转,flipcode=0为垂直翻转 def Horizontal(image): return cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef07aea1dea166577deaf7fef5f1454a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/721758454c1b0bad7ede9fdfe6a2a091/" rel="bookmark">
			[pytorch]pytorch官方安装法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		v1.13.1
Conda
OSX
# conda
conda install pytorch==1.13.1 torchvision==0.14.1 torchaudio==0.13.1 -c pytorch
Linux and Windows
# CUDA 11.6
conda install pytorch==1.13.1 torchvision==0.14.1 torchaudio==0.13.1 pytorch-cuda=11.6 -c pytorch -c nvidia
# CUDA 11.7
conda install pytorch==1.13.1 torchvision==0.14.1 torchaudio==0.13.1 pytorch-cuda=11.7 -c pytorch -c nvidia
# CPU Only
conda install pytorch==1.13.1 torchvision==0.14.1 torchaudio==0.13.1 cpuonly -c pytorch
Wheel
OSX
pip install torch==1.13.1 torchvision==0.14.1 torchaudio==0.13.1
Linux and Windows
# ROCM 5.2 (Linux only)
pip3 install torch torchvision torchaudio --extra-index-url
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/721758454c1b0bad7ede9fdfe6a2a091/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/38/">«</a>
	<span class="pagination__item pagination__item--current">39/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/40/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>