<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/184a3cb7bde20c13a79308e37c49da97/" rel="bookmark">
			matplotlib画图- 时间序列折线图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天做了一下毕设的图（关于结果比较的 时间序列图）
首先我说明 找了半天的博客 没有找到好的方法做x轴为datetime，很麻烦 所以我打算做int32类型的，但发现没法转换 结果采用特殊方法解决的 1.数据集查看 int64有个问题：就是在x轴的时候会出现0.5
2.将year转换为index a = data.set_index(['YEAR']) a.index Int64Index([2011, 2012, 2013, 2014], dtype='int64', name='YEAR') 3. 转存数据 TAS = a.iloc[:,0] QLD = a.iloc[:,1] WA = a.iloc[:,2] NATION = a.iloc[:,3] VIC = a.iloc[:,4] NSW = a.iloc[:,5] SA = a.iloc[:,6] TAS1 = a.iloc[:,7] QLD1= a.iloc[:,8] WA1 = a.iloc[:,9] NATION1 = a.iloc[:,10] VIC1 = a.iloc[:,11] NSW1=a.iloc[:,12] SA1=a.iloc[:,13] index类型还是int64 如何解决呢？
3.plot 注意 ：解决 设置xy轴的刻度 xticks 和yticks进行限制 plt.figure(1) #plt.subplot(221) plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/184a3cb7bde20c13a79308e37c49da97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d12d4fc6365e03da9e22bced0c02c5c/" rel="bookmark">
			idea Disconnected from the target VM, address: &#39;127.0.0.1:xxxxx&#39;, transport: &#39;socket&#39; 报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目中使用IntelliJ IDEA。运行项目的时候就报了
Disconnected from the target VM, address: ‘127.0.0.1:xxxxx’, transport: ‘socket’
如图：
IDEA没有明显错误提醒。然后就百度。
百度说的有三种：
1.你的端口号被占用。在任务管理器中查询这个端口号，结束任务就好了。我试过以后并不是这个问题。
2.静态类，或者静态方法使用大写字母开头。我经过检查同这个问题没关。
3.是IDEA编辑器与Maven不匹配。我之前是好的，突然不能使用，我运行其他的项目又是好的。所以不是这个问题。
百度没用了。只能自己排查。我经过仔细排查发现是类名冲突导致的。如图：
我在不同的包里面有两个同名的类。然后就不行了。改掉以后就好了。不知道为什么IDEA不提示。原因还在找…
知道的大佬也可以评论告诉我一下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a99c1b821aa489fe80a8edcea8918d5/" rel="bookmark">
			Android PupopWindow适配全面屏  全屏显示覆盖状态栏 简单实用只需两步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发中有一个需求弹出一个弹窗广告，背景需要半透明全屏显示，覆盖状态栏（见下图）。我选用了PupopWindow实现。
然后设置了属性宽高为WindowManager.LayoutParams.MATCH_PARENT
结果可想而知，根本无法全屏显示，状态栏部分无法遮盖。看网上有很多方法，都说需要自定义PopupWindow，我觉得实现一个全屏显示就需要自定义太麻烦了。就开始找查资料，找方法。
最后得出了一个两步解决问题的方法：
第一步：获取屏幕的高，设置popupWindow的高为屏幕的高+顶部状态栏的高+底部虚拟按键的高
int height = getResources().getDisplayMetrics().heightPixels;// 屏幕的高 actionPopupWindow = new PopupWindow(view, WindowManager.LayoutParams.MATCH_PARENT, height + getStatusBarHeight(mContext) + getBottomKeyboardHeight（mContext）);//设置popupWindow的高为屏幕的高+顶部状态栏的高+底部虚拟按键的高 /** * 获取状态栏高度 * * @param context context * @return 状态栏高度 */ public static int getStatusBarHeight(Context context) { // 获得状态栏高度 int resourceId = context.getResources().getIdentifier("status_bar_height", "dimen", "android"); return context.getResources().getDimensionPixelSize(resourceId); } /** * 获取底部虚拟键盘的高度 */ public static int getBottomKeyboardHeight(Activity context) { int screenHeight = getAccurateScreenDpi(context)[1]; DisplayMetrics dm = new DisplayMetrics(); context.getWindowManager().getDefaultDisplay().getMetrics(dm); int heightDifference = screenHeight - dm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a99c1b821aa489fe80a8edcea8918d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c417e2c3986684f62ec80c9636a9f04/" rel="bookmark">
			UI自动化测试工具Airtest学习之一 —— 简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AirtestIDE 是一个跨平台、多端（Windows、web、android、ios、游戏）的UI自动化测试编辑器。
支持自动化脚本录制、一键回放、报告查看，轻而易举实现自动化测试流程，自有编辑器一站式解决。
支持基于图像识别的Airtest 框架，适用于所有Android 和Windows 游戏，会截图就能写脚本。
支持基于UI 控件搜索的 Poco 框架，适用于Unity3d，Cocos2d与Android、ios App、web。
能够运行在Windows和MacOS上。
网易内部已成功应用在数十个项目上，利用手机集群进行大规模自动化测试，手机集群没有开源。
使用python编写，兼容2、3，推荐使用3。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43f7a63aec8b7590291e9c92d6bd24de/" rel="bookmark">
			word文档中交叉引用（利用于论文参考文献的使用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、word文档如何设置交叉引用
https://jingyan.baidu.com/article/a501d80c4a9374ec630f5e84.html
二、word论文中交叉引用更新
https://jingyan.baidu.com/article/a24b33cd04fecb19ff002b74.html
省事了很多。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c15164298c160a21d1fb0cd9ef573c5b/" rel="bookmark">
			科研常用网址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IEEE投稿模板与格式检查https://ieeeauthorcenter.ieee.org/#opennewwindow
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ccff4719b07dd7c2ab1f6bd50d8f374/" rel="bookmark">
			视频转格式消重 修改视频md5还有效吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 视频转格式消重 修改视频md5还有效吗 都知道现在短视频市场很火爆，吸粉、变现，容易赚钱等等。通常情况下，你应该多读一下这篇文章的标题，收集更多的头条新闻，培养自己的语感，并有合适的场景模拟程序或技能称号。但是不是每个人都有自己的团队，也不是每个人都可以去做原创视频，那么怎么去用别人的视频成为我们的原,视频消重软件是真的但不是每个人都有自己的团队，不是每个人都可以制作原创视频。,创视频，这个给大家详细的说一下怎么让别人的视频成为我们的原创视频并且躲过后台的识别。
那么，我们如何制作这些材料呢！只有一种技能，这是特别好的方法。。
视频转格式消重
尤其是研究领导的团队。。 视频自媒体最主要的就是素材，如果你的视频素材对了，标题起的不要太烂，播放量是差不到哪里去的。以今天的标题为例。视频播放主要通过系统建议获得。其智能推荐系统（通常称为人工智能）是向对其感兴趣的人推荐适当的新闻。如果说你的素材不对，就算你的标题起的再好，播放量也高不到哪里去。 那么我们如何做素材呢!只有一个窍门，放之四海皆准的窍门，无论是历史类也好，娱乐也好，体育也好，都是这个窍门，因为它们非常有用，所以在查看之前它们会很有用。就是读者相关性。 读者打开电脑或打开手机，为什么会选择观看这个视频而不是另外一个视频， 就是因为这视频，因此，对于媒体中的很多人来说，短片的口号是“这个镇上没有这样的商店”。独特缺少的是让你出局的一步。跟他的生,万兴剪辑手视频消重,活、爱好、兴趣、心情，至少有一个点产生了共鸣，从而促使读者去打开阅读。 只要阅读体验良好，您就可以充分利用文章公告中显示的缺点和短视频。目前关于娱乐明星，两性、热点、社会事件能引发读者共鸣，都是好的题材。传统内容的平台，货币化的模式是非常有限的，标题产品的功能肯定给媒体一千个兴奋剂。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/409759482a8a7130083d3b7b5429b708/" rel="bookmark">
			不要使用 Dispatcher.Invoke，因为它可能在你的延迟初始化 Lazy 中导致死锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不要使用 Dispatcher.Invoke，因为它可能在你的延迟初始化 Lazy 中导致死锁 原文: 不要使用 Dispatcher.Invoke，因为它可能在你的延迟初始化 Lazy 中导致死锁 版权声明：本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。欢迎转载、使用、重新发布，但务必保留文章署名吕毅（包含链接：https://walterlv.blog.csdn.net/），不得用于商业目的，基于本文修改后的作品务必以相同的许可发布。如有任何疑问，请与我联系（walter.lv@qq.com）。 https://blog.csdn.net/WPwalter/article/details/85222847 WPF 中为了 UI 的跨线程访问，提供了 Dispatcher 线程模型。其 Invoke 方法，无论在哪个线程调用，都可以让传入的方法回到 UI 线程。
然而，如果你在 Lazy 上下文中使用了 Invoke，那么当这个 Lazy&lt;T&gt; 跨线程并发时，极有可能导致死锁。本文将具体说说这个例子。
本文内容 一段死锁的代码此死锁的触发条件此死锁的原因此死锁的解决方法更多死锁问题 一段死锁的代码 请先看一段非常简单的 WPF 代码：
private Lazy&lt;Walterlv&gt; _walterlvLazy = new Lazy&lt;Walterlv&gt;(() =&gt; new Walterlv()); private void OnLoaded(object sender, RoutedEventArgs e) { Task.Run(() =&gt; { // 在后台线程通过 Lazy 获取。 var backgroundWalterlv = _walterlvLazy.Value; }); // 等待一个时间，这样可以确保后台线程先访问到 Lazy，并且在完成之前，UI 线程也能访问到 Lazy。 Thread.Sleep(50); // 在主线程通过 Lazy 获取。 var walterlv = _walterlvLazy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/409759482a8a7130083d3b7b5429b708/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db748283ff746ae7e02567ebb5f37e83/" rel="bookmark">
			Spring Cloud Ribbon自定义负载均衡算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上篇介绍了Ribbon的几种负载均衡算法，在实际工作中有可能会用自己定义的算法，根据自己的编写的算法来进行负载均衡
Ribbon是客户端的负载均衡技术，即消费者微服务端的负载均衡
启动项目查看Eureka Server:
一个微服务有3个不同的实例
先来针对一个服务使用不同的负载均衡策略。关键注解:@RibbonClient，此注解是放在启动类上
上面截图@RibbonClient的意思是，针对YPPCLOUD-DEPT这个微服务使用MyRibbon我们自己定义的负载均衡策略以及算法
注意一点:自定义负载均衡的策略以及算法不能放在@ComponentScan所扫描的包下，不然会被所有Ribbon所共享(即所有的微服务都会使用该策略，包含YPPCLOUD-DEPT)
复习Spring Boot知识:都知道启动类自动扫描启动类平级以及子包里面所有的配置信息以及bean。关键点在于@SpringBootApplication这个注解，点击@SpringBootApplication注解进去看，是用了@ComponentScan。
所以我们要新建一个包,用上我们自定义的负载均衡类:
MyRibbon.java:
package com.ypp.myribbon; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import com.netflix.loadbalancer.IRule; import com.netflix.loadbalancer.RandomRule; @Configuration public class MyRibbon { @Bean public IRule rule(){ return new RandomRule(); } } Ribbon默认使用的轮训的负载均衡策略，MyRibbon这里我们使用的是随机的负载均衡策略，但是这个随机负载均衡策略是针对YPPCLOUD-DEPT这个微服务下面的实例,其他的微服务还是使用的默认的轮训负载均衡策略，因为我们刚才启动类配置只针对YPPCLOUD-DEPT它配置的MyRibbon。
访问下YPPCLOUD-DEPT，看看下面的实例是否以随机进行访问
ypp-springcloud3代表8003这个实例，数据库也是ypp-springcloud3
ypp-springcloud2代表8002这个实例，数据库也是ypp-springcloud2
ypp-springcloud代表8001这个实例，数据库也是ypp-springcloud
每个实例我都是单独的数据库，以下是访问的结果，显而易见是随机，并没有任何规则或者顺序
自定义负载均衡策略的算法
Ribbon提供了一个规范核心组件IRule，这个在上篇文章有说，就像java的JPA，然后hibernate来进行实现。
我们来对IRule进行自己的策略和算法，源码地址在github有。地址:https://github.com/Netflix/ribbon/tree/master/ribbon-loadbalancer/src/main/java/com/netflix/loadbalancer
就拿默认的轮训来定义我们自己的，比如每个实例访问5次或者10次，或者一个实例访问是5天，然后是其他的实例每个也是5天这样的规则
RoundRobinRule这是默认轮训的源码，我们在它的基础上更改，改源码要比看源码更牛。不是只会调用API，多年工作经验的只会使用以及调用API等，那不是有多年工作经验，而是一个经验用了多年，差距甚大。这也就是同样的工作经验，为什么别人那么牛，为什么能当架构师，而自己只能一直成为码农的区别。作为程序员，至少都要有一个目标，成为码神，才能走得更远
RoundRobinRule继承了AbstractLoadBalancerRule，AbstractLoadBalancerRule 实现了IRule，源码自己去看，不多说
我们自定义一个MyRoundRobinRule类，也来继承AbstractLoadBalancerRule,然后把RoundRobinRule里面的源码直接拷贝过来自己更改
更改后的MyRoundRobinRule.java:
package com.ypp.myribbon; import java.util.List; import java.util.concurrent.atomic.AtomicInteger; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.context.annotation.Configuration; import com.netflix.client.config.IClientConfig; import com.netflix.loadbalancer.AbstractLoadBalancerRule; import com.netflix.loadbalancer.ILoadBalancer; import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db748283ff746ae7e02567ebb5f37e83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9f7f7a73fd94322d720153a742c6bdd/" rel="bookmark">
			Docker -- 安装（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Ubuntu Docker 安装 Docker 支持以下的 Ubuntu 版本：
Xenial 16.04 (LTS)Bionic 18.04 (LTS)Cosmic 18.10Disco 19.04其他更新的版本…… Docker Engine - Community 支持上 x86_64（或 amd64）armhf，arm64，s390x （IBM Z），和 ppc64le（IBM的Power）架构。
1、前提条件 Docker 要求 Ubuntu 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的 Ubuntu 版本是否支持 Docker。
通过 uname -r 命令查看你当前的内核版本。
2、使用官方安装脚本自动安装 （1）安装命令如下： curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 也可以使用国内 daocloud 一键安装命令：
curl -sSL https://get.daocloud.io/docker | sh 3、手动安装 (1) 卸载旧版本 Docker 的旧版本被称为 docker，docker.io 或 docker-engine 。如果已安装，请卸载它们：
$ sudo apt-get remove docker docker-engine docker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9f7f7a73fd94322d720153a742c6bdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce4b36474821fe52271ec9be17424edd/" rel="bookmark">
			小视频伪原创工具 苹果手机短视频去水印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 小视频伪原创工具 苹果手机短视频去水印 当读卡器打开电脑或手机时，为什么选择观看此视频而非另一个视频？。
视频自媒体最主要的就是素材，如果你的视频素材对了，标题起的不要太烂，播放量是差不到哪里去的。特别后，启动讨论主题，引导用户发表评论，然后选择一些好的评论来回答。如果说你的素材不对，就算你的标题起的再好，播放量也高不到哪里去。
那么我们如何做素材呢!只有一个窍门，放之四海皆准的窍门，无论是历史类也好，娱乐也好，体育也好，都是这个窍门，这是因为这段视频至少在他们的生活，兴趣，兴趣和情感中产生共鸣，鼓励读者打开阅读。就是读者相关性。
读者打开电脑或打开手机，为什么会选择观看这个视频而不是另外一个视频， 就是因为这视频，但不是每个人都有自己的团队，不是每个人都可以制作原创视频。跟他的生,手机视频批量消重软件,活、爱好、兴趣、心情，至少有一个点产生了共鸣，从而促使读者去打开阅读。
这是因为文章形式的内容跳过率自然很高。目前关于娱乐明星，两性、热点、社会事件能引发读者共鸣，都是好的题材。内容角度接近生命。与公众接近的特别大优势之一是阅读的基础非常大。
小视频伪原创工具
视频伪原创是进行短视频引流的核心基础，如果发布的视频原创度不够，就获得不了平台的推荐，那价值就不大，账号权重不高，对视频大小修改、添加元素、增加滤镜、修改帧率、修改MD5值小视频伪原创工具等操作，提升原创度，指数的五个维度不再重复：原创性，垂直性，沟通，健康和注意力。在这里，我专注于特别难传播，关注和健康的程度。这些操作都需要借助视频编辑软件，给大家准备好了强大的软件，在文章图片中有获取方式
帐户的累计读取/累计金额越高，转移越大。有两个中心点可以提高你的注意力：1。账户速度快，注意力高，粉丝有更多评论和高度关注。。
小视频伪原创工具 苹果手机短视频去水印 自媒体运营技巧：短视频优质素材选题方向1. 多分析一些50万到100万的视频。当读卡器打开电脑或手机时，为什么选择观看此视频而非另一个视频？特别是一些做的比较大的自媒体平台（头条，百家，企鹅等等）看看它们的一些逻辑，今天的标题是平台上的大量流量，以满足您的需求。是什么导致这个视频播放量那么高？是标题封面更多关注同事的信息将帮助您更好地找到灵感。。吸引人，还是找到了热点的切入口，又或者是关键词的运用到位等等。
关注一些同行的账号。可以分析他们的最近选题方向，他们的题材都来自哪里，要怎么做这个题材.多关注结果证明不是好事，有什么办法吗？。同行信息会帮你更好的去找到选题灵感。
一些视频网站也可以拿来做分析。如果你的视频资料是正确的，标题不应该那么糟糕，播放量也不会那么糟糕。这些视频网站的首页播放往往是一些潜在热点。帐户的累计读取/累计金额越高，转移越大。有两个中心点可以提高你的注意力：1。账户速度快，注意力高，粉丝有更多评论和高度关注。特别是一些明星的影视剧，一不留神就会上热搜的。
----------------------------------------------------------------------- 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21d70557a8a7dfa44846847b5407773e/" rel="bookmark">
			算法学习笔记（使用追赶法解三对角方程组）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、应用背景
解三次样条插值会遇到解三对角方程组问题
1、三对角方程组如下：
这是一种特殊的稀疏矩阵，非零元素集中分布在主对角线及其相邻两条对角线上，称为三对角矩阵。
2、追赶法：追赶法的基本思想与高斯消元法及三角分解法相同，只是由于系数中出现了大量的零，计算中可将它们撇开，从而使得计算公式简化，大大减少了计算量。
二、求解过程
1、知识补充：
Crout分解：
Doolittle分解（与crout分解相反）：
举例：
2、追赶法求解 三对角线性方程组
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7413b73ae2a514655501d2102720bf8f/" rel="bookmark">
			关于springboot集成activiti6.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自学了一段时间的activiti，发现网上有很多的demo都用不起。找了很多，都比较失望。所以今天自己写一个简单的基于springboot的activiti项目。
ok，开始
首先，我们需要先创建一个springboot项目。下面这个pom依赖。
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-spring-boot-starter-basic&lt;/artifactId&gt; &lt;version&gt;6.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;24.0-jre&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 这里注意一下 ，mysql的依赖包不应版本太高，否则无法自动建表。
然后在启动类上面加上这句话
@SpringBootApplication(exclude = SecurityAutoConfiguration.class) 接下来创建我们自己的流程文件，
在resource下面创建一个文件夹来存放对应的文件，当然这个命名随你喜好。
然后在配置文件里面加上
spring.datasource.type=com.alibaba.druid.pool.DruidDataSource spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.datasource.url=jdbc:mysql:///activitidb?serverTimezone=GMT%2B8 spring.datasource.username=root spring.datasource.password=123456 spring.jpa.hibernate.ddl-auto=update spring.jpa.show-sql=true #spring.activiti.history-level=full spring.activiti.database-schema-update=true #spring.activiti.check-process-definitions=false spring.activiti.process-definition-location-prefix=classpath:/processes/ 最后，来写一段简单的代码
private static final Logger LOGGER = LoggerFactory.getLogger(UserServiceImpl.class); @Autowired private IdentityService identityService; @Autowired private RuntimeService runtimeService; @Autowired private TaskService taskService; @Autowired private FormService formService; @Override public String submitMsg() { // identityService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7413b73ae2a514655501d2102720bf8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d39670f9d5d01e56af4477592893b526/" rel="bookmark">
			数据结构实验 实验3 二叉树的遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、【实验目的】
了解二叉树的前序、中序、后序和层次序列排列；将C语言同二叉树的数据结构联系起来；掌握生成的二叉树的链表结构；掌握如何按层次输出二叉树的所有结点；掌握如何将动态二叉树转换为静态二叉链表。 二、【实验内容】
创建一个二叉树，对这棵动态二叉树进行分析，将其用静态二叉链表表示。二叉树的动态二叉链表结构中的每个结点有三个字段：data，lchild，rchild。静态二叉链表是用数组作为存储空间，每个数组元素存储二叉树的一个结点，也有三个字段：data，lchild，rchild。lchild和rdhild分别用于存储左右孩子的下标。
三、【实验步骤与要求】
1、实验前的准备
（1）了解二叉树的基本概念；
（2）了解二叉树的基本结构。
2、上机操作
（3）了解二叉树的前序和中序序列排列；
将C语言同二叉树的数据结构联系起来；掌握生成的二叉树的链表结构；掌握如何按层次输出二叉树的所有结点；掌握如何将动态二叉树转换为静态二叉链表。 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; //函数结果状态代码 #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2 #define MAX_StaticTree 100 typedef int Status; //Status是函数的类型，其值是函数结果代码 typedef char TElemType; //树结点数据类型定义为char型 //------二叉树的二叉链表存储表示------- typedef struct BiTNode { TElemType data; struct BiTNode *lchild,*rchild; //左右孩子指针，指向孩子结点 int index; //先序创建时的标号 }BiTNode,*BiTree; //结构体变量，原型和指针型 //------用数组存储的静态树存储表示----- typedef struct static_BiTNode { TElemType data; int lchild,rchild; //lchild和rdhild分别用于存储左右孩子的下标。 }static_BiTNode; //------基本操作的函数原型说明------ static int counts=0; //用于给结点标号 Status CreateBiTree(BiTree *T); //按先序次序输入二叉树中结点的值(一个字符),#字符表示空树， //构造二叉链表表示的二叉树T。 Status PrintElement(TElemType e); //最简单的Visit函数 //输出元素e的值 Status PreOrderTraverse(BiTree T,Status (*Visit)(TElemType e)); //采用二叉链表存储方式，Visit是对结点操作的应用函数。 //先序遍历二叉树T，对每个结点调用函数Visit一次且仅一次。 //一旦Visit()失败，则操作失败 Status InOrderTraverse(BiTree T,Status (*Visit)(TElemType e)); //采用二叉链表存储方式，Visit是对结点操作的应用函数。 //中序遍历二叉树T，对每个结点调用函数Visit一次且仅一次。 //一旦Visit()失败，则操作失败 Status PostOrderTraverse(BiTree T,Status (*Visit)(TElemType e)); //采用二叉链表存储方式，Visit是对结点操作的应用函数。 //后序遍历二叉树T，对每个结点调用函数Visit一次且仅一次。 //一旦Visit()失败，则操作失败 Status LevelOrderTraverse(BiTree T,Status (*Visit)(TElemType e)); //采用二叉链表存储方式，Visit是对结点操作的应用函数。 //层序遍历二叉树T，对每个结点调用函数Visit一次且仅一次。 //一旦Visit()失败，则操作失败 int LevelSub(BiTree T, int level,Status (*Visit)(TElemType e)); //层序辅助递归函数 Status TreeToArray(BiTree T,static_BiTNode t[]); //将动态二叉树转换为静态二叉链表 //按先序次序给结点编号，lchild和rdhild分别用于存储左右孩子的下标 int main() { BiTree T; static_BiTNode a[MAX_StaticTree];//静态二叉链表是用数组作为存储空间 CreateBiTree(&amp;T); //创建二叉树 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d39670f9d5d01e56af4477592893b526/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/119b825a45af3914501cffd23381fe7e/" rel="bookmark">
			数据结构实验 实验二 一元多项式相加
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、【实验目的】
1、了解链式存储结构的基本知识；
2、掌握算法思想和数据结构的描述；
3、结合一元多项式相加的运算规则。
二、【实验内容】
结合书上第41页的例子，采用链式存储结构，将两个线性链表表示的一元多项式相加，并输出。此一元多项式遵循多项式相加运算规则：对于两个一元多项式中存在指数相同的项时，其对应系数相加。合并后系数和为零时，删除“和多项式”中此项；合并后系数和不为零时，则构成“和多项式”中的一项。对于两个一元多项式中存在的指数不相同的项，则分别复抄到“和多项式”中去，原多项式保持不变。
三、【实验步骤与要求】
1、实验前的准备
（1）了解C语言的基本概念；
（2）了解C语言的基本段落。
2、上机操作
（1）了解链式存储结构的基本知识；
（2）掌握算法思想和数据结构的描述；
（3）掌握一元多项式相加的运算规则。
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2 #define LIST_INIT_SIZE 100 typedef int Status; //Status是函数的类型，其值是函数结果代码 struct node{ //项结点 float coeff; //系数coefficient int expn; //指数exponent }; typedef struct Polynomial{ //多项式 struct node elem; //多项式元素 struct Polynomial *next; //指向下一个多项式的结构体指针 }*PolyList; //创建一元多项式链表 void CreatePolyn(PolyList *ha,int n) { float coe; //coe表示系数 int exp; //x2表示指数 PolyList p; //创建临时多项式链表 *ha=NULL; //首先为空时ha指向空 while(n--){ scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/119b825a45af3914501cffd23381fe7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38ed742f2a54d412acee2d2025e2a9d9/" rel="bookmark">
			SQL函数之聚合函数（求和，平均值，最大值，最小值，统计，取不重，取重）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		聚合函数 聚合函数对一组值进行计算并返回单一的值，通常聚合函数会与SELECT语句的GROUP BY子句一同使用，在与GROUP BY子句使用时，聚合函数会为每一个组产生一个单一值，而不会为整个表产生一个单一值.
在这张数据表的基础上执行语句
SUM(求和)函数 SUM函数返回表达式中所有值的和或仅非重复值的和。SUM 只能用于数字列。空值将被忽略。
参数说明：
ALL：对所有的值应用此聚合函数。ALL是默认值。
DISTINCT：指定 SUM 返回唯一值的和。SUM (DISTINCT(字段名))
--SUM 求和 SELECT SUM(AGE) AS 年龄总和 FROM UserInfor(表名) --DISTINCT	去重 SELECT SUM(DISTINCT(AGE)) AS 唯一值年龄总和 FROM UserInfor(表名) AVG(平均值)函数 --AUG	平均值 SELECT AVG(AGE) AS 年龄平均值 FROM UserInfor(表名) SELECT AVG(DISTINCT(AGE)) AS 唯一值年龄平均值 FROM UserInfor(表名) MIN（最小值）函数 --MIN	最小值 SELECT MIN(AGE) AS 最小年龄 FROM UserInfor WHERE SEX='男' MAX（最大值）函数 --MAX	最大值 SELECT MAX(AGE) AS 最大年龄 FROM UserInfor WHERE SEX='女' COUNT(统计)函数 COUNT函数返回组中的项数。COUNT 返回 int 数据类型值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38ed742f2a54d412acee2d2025e2a9d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/223096f0e54ed625f7f4c70696486cec/" rel="bookmark">
			BitmapData类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/zhangj1012003_2007/article/details/6283032
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d84129be6684f484227c98eb87838fe/" rel="bookmark">
			js:商品排序功能(图片自己找)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		html &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;5.index.html&lt;/title&gt; &lt;link rel="stylesheet" href="css/5.reset.css"&gt; &lt;link rel="stylesheet" href="css/5.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;div class="tab"&gt; &lt;div class="label"&gt;排序&lt;/div&gt; &lt;ul id="tab"&gt; &lt;li&gt;上架时间&lt;/li&gt; &lt;li&gt;价格&lt;/li&gt; &lt;li&gt;热度&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;ul class="goodsList" id="goodsList"&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src="js/5.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 复制代码 css .container{ width: 1200px; margin: auto; } .tab{ background: yellow; padding: 12px 30px; line-height: 38px; overflow: hidden; margin-bottom: 30px; } .goodsList li{ width: 200px; } .label{ float: left; padding-right: 30px; } #tab{ float: left; overflow: hidden; } #tab li{ float: left; padding: 0 30px; position: relative; } #tab li:before{ display: block; content: ''; width: 0; height: 0; border: 8px solid transparent; border-bottom:8px solid #333333; position: absolute; right: 0; top: 0; } #tab li.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d84129be6684f484227c98eb87838fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/566010d3e1bc289378dfe227808d100a/" rel="bookmark">
			[SDOI2009]晨跑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这道题是一个很裸的费用流题目。
一般点之过一次的套路就是拆点连边。
其他的模拟下就水过去了。
1 #include &lt;bits/stdc++.h&gt; 2 3 using namespace std; 4 5 #define re register 6 #define rep(i, a, b) for (re int i = a; i &lt;= b; ++i) 7 #define repd(i, a, b) for (re int i = a; i &gt;= b; --i) 8 #define maxx(a, b) a = max(a, b); 9 #define minn(a, b) a = min(a, b); 10 #define LL long long 11 #define INF (1 &lt;&lt; 30) 12 13 inline int read() { 14 int w = 0, f = 1; char c = getchar(); 15 while (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/566010d3e1bc289378dfe227808d100a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8617dba6718cb68586c1d89313c30b90/" rel="bookmark">
			实验二 单链表的基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.实验目的
了解线性表的链式存储存储结构和顺序存取特性，熟练掌握线性表的链式存储结构的C语言描述方法，熟练掌握动态链表的基本操作，查找、插入、定位等，能在实际应用中选择适当的链式结构。掌握用链表表示特定形式的数据的方法，并能编写出有关运算的算法。
2.实验内容
（1）已知线性表中的元素以递增有序排列，并以单链表作为存储结构，试写出一个高效算法，删除表中所有值大于mink且小于maxk的元素（若表中存在这样的元素）同时释放被删除结点的空间，并分析你的算法的时间复杂度。
（2）完成单链表上的如下操作：
&lt;1&gt;逆序建立单链表
&lt;2&gt;遍历单链表（输出单链表中每一个元素的位置）
&lt;3&gt;在单链表第5个元素前插入一个值为999的元素
&lt;4&gt;删除单链表的第5个元素
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #define TRUE 1 #define FALSE 0 #define ERROR 0 #define OVERFLOW 0 #define OK 1 typedef int ElemType; typedef int Status; typedef struct LNode { ElemType data;//数据域 struct LNode *next;//指针域 }LNode, *LinkList; LinkList CreateList_L_Tail(int n) {//尾插法建立单链表 LinkList L; LNode *p, *r; L = (LinkList)malloc(sizeof(LNode));//创建头结点 r = L;//r始终指向尾节点，开始时指向头结点 for (int i = n; i &gt; 0; i--) {//循环建立数据节点 p = (LinkList)malloc(sizeof(LNode));//生成新结点 scanf_s("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8617dba6718cb68586c1d89313c30b90/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/109/">«</a>
	<span class="pagination__item pagination__item--current">110/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/111/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>