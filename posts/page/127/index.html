<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53619a16d3dc74b04503f5d4eb4ba4e1/" rel="bookmark">
			QListView的样式-转载于http://no001.blog.51cto.com/1142339/378917
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载于 http://no001.blog.51cto.com/1142339/378917 这里简单的一个应用QListView的样式。
首先建立一个文本文档，改名为xx.qss 。
qss内容为：
QListView::item:selected {
border: 1px solid #6a6ea9;
}
QListView::item:selected:!active {
background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
stop: 0 #ABAFE5, stop: 1 #8588B2);
}
QListView::item:selected:active {
background: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,
stop: 0 #6a6ea9, stop: 1 #888dd9);
}
然后本人习惯把所有的资源都加进 到 xx.qrc 中去，
然后在mainWindow.cpp中加入如下语句：
因为我是加入到qrc文件中，所以路径前面要加一个：
QFile qss(":css.qss");
qss.open(QFile::ReadOnly); qApp-&gt;setStyleSheet(qss.readAll()); qss.close(); 这样样式表就能很好的使用了。
鉴于这种模式，如果你要对按钮或者别的控件改变，，只需改变qss，增加里面的内容就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5387af573f829ca7fa2f0d191683477/" rel="bookmark">
			Qt 中用QListView 按照缩略图的方式显示图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Qt 中用QListView 按照缩略图的方式显示图标 qt 2010-07-10 10:31:12 阅读129 评论0 字号：大中小 订阅 使用QListView显示图标，可以如下： setViewMode( IconMode ); 设置图标的大小： setIconSize( QSize(80, 80) ); 设置网格的大小： setGridSize( QSize(100, 100) ); 设置QListView大小改变时，图标的调整模式，默认是固定的，但可以改成自动调整： setResizeMode( Adjust ); 设置图标可不可以移动，默认是可移动的，但可以改成静态的： setMovement( Static ); 最后给QListView一个QAbstractItemModel的数据： setModel 获取选中的项，返回值是一个QModelIndexList类型的： selectionModel()-&gt;selectedIndexes(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9143ac8705f946eef7cdea41e6f217c4/" rel="bookmark">
			Alpha混合浅谈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Alpha混合浅谈
alpha混合技术对熟悉游戏的人来说不会陌生，这种技术在如今的游戏特效里已经被用烂了。3D的游戏就不说了，2D的游戏里，这种技术也是满眼皆是。 alpha混合听上去很神秘，实际非常简单，其作用就是要实现一种半透明效果。假设一种不透明东西的颜色是A，另一种透明的东西的颜色是B，那么透过B去看A，看上去的颜色C就是B和A的混合颜色，可以用这个式子来近似，设B物体的透明度为alpha(取值为0-1，0为完全透明，1为完全不透明)
R(C)=alpha*R(B)+(1-alpha)*R(A)
G(C)=alpha*G(B)+(1-alpha)*G(A)
B(C)=alpha*B(B)+(1-alpha)*B(A)
R(x)、G(x)、B(x)分别指颜色x的RGB分量。看起来这个东西这么简单，可是用它实现的效果绝对不简单，应用alpha混合技术，可以实现出最眩目的火光、烟雾、阴影、动态光源等等一切你可以想象的出来的半透明效果。
火光、烟雾的效果是事先做好一个火或雾的图和一个alpha通道图(用过Photoshop的人都该知道什么是alpha通道)，画上去的时候每点每点计算，得到的就是火光掩映的效果。雾化效果在3D里还需要模糊一下，在这里就免了，本来alpha混合就有不小的计算量了，算法再不优化再加上模糊或其它的一些什么原因，那么你就是在看幻灯片了。(关于优化，网上见仁见智，我再找时候再讲)。
动态光源，听起来高深的一塌。那我先讲一下阴影，这个就简单了，以往的游戏也有阴影(象《仙剑》)，不过我们把它升一下级，从不透明变成半透明而已。就是把一个影子图放在地表上面作alpha混合(而且可以简化，因为影子的alpha值可以是一定的，这样就可以大幅提高计算速度)就OK了。
该讲动态光源了。我们把没有光源的地方想象成一张黑幕蒙在屏幕上，没光也就什么都看不到。那么我们就加上一个光源，相当于在黑幕上挖了一个洞，这个洞的大小就是被照亮的范围，现在我们可以看到下面的东西了。但现在这个效果说是光源，倒不如说是个窗户，要显得象光源，就要让光源的中心最亮，逐渐向四周暗下去，最后到什么都看不见，这才象个光源。具体实现就是alpha混合啦，蒙版的颜色是黑，中心alpha值为0，完全透明，到光源的尽头alpha值为1，完全不透明，成果就是这个样子，象这么回事吧！光源做好了，动态的光源就是实时生成一个动态的alpha蒙版，然后盖上去就行了。
不难吧！游戏里(其实也不只游戏，好多算法也是这样)的一些技术听起来很玄，说通了也就是那么回事，只不过不是一下子就能想到就是了。
Diablo里面就大量应用了alpha混合技术(至少我看上去象)，那些眩目的魔法产生出来的半透明效果，还有乱飞的火球照亮迷宫，每个火球也就是个小的光源，一堆光源产生出来的蒙版(就是对应的alpha相加，超过255就截断)再蒙上去。(真正的光源应该是这样的：当alpha值超过255时，alpha=alpha-255，alpha是一个Byte时也就是回绕，同时该点蒙版的色彩变为白色，这才是对的，不过简单起见，还是原来那样就可以了)。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c5f036feedd40802d879259a3aaeba1/" rel="bookmark">
			const char * 赋值给 char*
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚才写了一个函数，需要的参数为char* 但是返回的是const char *strReturn; 使用了CString 进行转换 过程如下： CString strItem(strReturn);
char *pBuf = strItem.GetBuffer();
则得到了pBuf
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d45707e4c2ca9dfbf4f69e4c2f2c4210/" rel="bookmark">
			C#中子类重写父类方法的几种情况(virtual,abstract,override,new)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		研究了一下C#中子类重写父类方法的几种情况，关键字：virtual、abstract、override、new。
virtual：标识可能但不是必须被子类重写的方法，父类必须给出默认实现，子类可以重写（使用override,new,或无特殊标识的普通方法），也可以不重写该方法。
abstract：标识必须被子类重写的方法，父类不给出实现，子类必须用override关键字重写该方法。
override：标识重写父类的方法，父类方法必须是用abstract，virtual，override之一声明，运行时将根据实例的类型而不是引用的类型调用对象的方法。
new：标识重写父类的方法，父类方法可以用virtual、override、new之一声明，也可以是没有特殊标识的普通方法，运行时会根据引用的类型选择调用父类还是子类的方法，重写父类方法时，使用new关键字与使用没有特殊标识的普通方法是等效的，但是后者会给出一个编译警告。
下面的表格总结了子类重写父类方法的各种情况（Class B继承自Class A，重写了A的Test()方法）：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cae67242c402b2a3b1c9cdfe85587a1c/" rel="bookmark">
			Android 画图方式总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android apk 里面的画图分为2D和3D两种：2D是由Skia 来实现的，也就是我们在框架图上看到的SGL，SGL也会调用部分opengl 的内容来实现简单的3D效果；3D部分是由OpenGL|ES实现的
先了解一下Android apk的几种画图方式，然后再来来看一看这一整套的图形体系是怎么建立的
画图都是对供给应用程序的一块内存进行数据填充，也就是对这块surface内存进行操作，说穿了就是我们要么调用2D 的API画图，要么调用3D的API画图，然后将画下来的图保存在这个内存中，最后这个内存里面的内容会被Opengl渲染以后变为可以在屏幕上的像素信 息
一、2D画图
1、Simple Graphics in View
只是把Graphic 资源（images，shapes，colors，pre-defined animation等等这些Android已经实现的一些画图操作）放入View体系，由系统 来将这些Graphic画出来。 在这里没有一笔一画地构造出一个图形出来，即并没有自己去定义画图操作，
而是将这些内容放入View中，由系统来将这些内容画出来。这种方式只能画静态或者极为简单的2D图画，对于实时性很强的动画，高品质的游戏都是没法实现 的
2、Canvas
这个Canvas是一个2D的概念，是在Skia中定义的。可以把这个Canvas理解成系统提供给我们的一块内存区域(但实际上它只是一套画图的API，真正的内存是下面的Bitmap)。这种方式下我们能一笔一划或者使用Graphic来画我们所需要的东西了，要画什么要显示什么都由我们自己控制。这种方式分为两种。两种的主要是区别就是可以在SurfaceView中定义一个专门的线程来完成画图工作，应用程序不需要等待View的刷图，提高性能。前面一种适合处理 量比较小，帧率比较小的动画，比如说象棋游戏之类的；而后一种主要用在游戏，高品质动画方面的画图
2.1 View canvas---使用普通View的canvas画图
(1) 定义一个自己的View ：class your_view extends View{} ；
(2) 重载View的onDraw方法：protected void onDraw(Canvas canvas){} ；
(3) 在onDraw方法中定义你自己的画图操作 ；
除此之外：可以定义自己的Btimap:
Bitmap b = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
Canvas c = new Canvas(b);// 必须将这个Bitmap放入View的canvas中，画的 图才能显示出来
2.2 Surface View Canvas---使用专门的SurfaceView的canvas来画图
(1) 定义一个自己的SurfaceView : class your_surfaceview extends SurfaceView implements SurfaceHolder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cae67242c402b2a3b1c9cdfe85587a1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60d995c57f35dd74197af43fd60cbcca/" rel="bookmark">
			Prism之事件IEventAggregator
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		event事件，相信大家都知道有什么作用吧，主要用于在特定情况触发下，处理相关操作，它是一个异步处理过程，因此prism事件一般使用在需要异步处理的情况下。
Prism的事件IEventAggregator是全局性的，什么意思？以前我们开发项目，不经常会用到全局变量吗，这里Prism使用容器，通过方法
protected void RegisterTypeIfMissing(Type fromType, Type toType, bool registerAsSingleton);
来定义全局变量，它可是单例的哟，保证了唯一性，你可以通过ServiceLocaor.Current.GetInstance&lt;IEventAggregator&gt;()在你项目的任何地方获取唯一实例。
事件采用订阅、发布原理实现。
事例代码如下：
（1）订阅：ServiceLocaor.Current.GetInstance&lt;IEventAggregator&gt;().GetEvent&lt;myEvent&gt;().Subscribe(myMethod);　//参数是触发者传送的参数，调用者与被调用者参数类型要保持一致。　public void myMethod(object o)//这个方法一定是公有的，不然事件触发时找不到，会报错。
{
//...
}　public class myEvent: CompositePresentationEvent&lt;object&gt;{} //CompositePresentationEvent是prism提供的接口。
（2）发布：ServiceLocaor.Current.GetInstance&lt;IEventAggregator&gt;().GetEvent&lt;myEvent&gt;().Publish（new object()）;
注：记得在事件触发完后，如果不再需要触发，或是创建了另一个实例也调用这个事件，一定要取消订阅哟，不然可能会被二次调用。取消方式如下：
ServiceLocaor.Current.GetInstance&lt;IEventAggregator&gt;().GetEvent&lt;myEvent&gt;().Unsubscribe（myMethod）;
一般在myMethod方法里取消。
转载于:https://www.cnblogs.com/xiaominblog/archive/2010/09/24/1834138.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8bcda3fc27a197e4cf66d45201f5c87/" rel="bookmark">
			Android中数据存储的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看文章 Android中数据存储的几种方法 在Android中，可供选择的存储方式有 SharedPreferences、 文件存储、SQLite数据库方式、内容提供器（Content provider）和 网络 2010-05-20 23:12 一，Preferences Preferences是一个较轻量级的存储 数据的方法，具体使用方法： 在A中保存值： SharedPreferences.Editor sharedata = getSharedPreferences("data", 0).edit(); sharedata.putString("name","shenrenkui"); sharedata.commit(); 在B中取值： SharedPreferences sharedata = getSharedPreferences("data", 0); String data = sharedata.getString("name", null); Log.i(TAG,"data="+data); 注意，Context.getSharedPreferences(String name,int type)的参数更我们在创建数据的时候的数据权限属性是一样的，存储和取值的过程这有点像HashMap但是比HashMap更具人性化，getXXX(Object key,Object defualtReturnValue),第二个参数是当你所要的key对应没有时候返回的值。这就省去了很多逻辑判断。。。。 二，Files 在 Android上面没有的File就是J2se中的纯种File了，可见 功能之强大，这里就算是走马观花地严重路过了。 //创建 文件 file = new File(FILE_PATH , FILE_NAME); file.createNewFile(); //打开文件file的OutputStream out = new FileOutputStream(file); String infoToWrite = "纸上得来终觉浅，绝知此事要躬行"; //将字符串转换成byte数组写入文件 out.write(infoToWrite.getBytes()); //关闭文件file的OutputStream out.close(); //打开文件file的InputStream in = new FileInputStream(file); //将文件内容全部读入到byte数组 int length = (int)file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8bcda3fc27a197e4cf66d45201f5c87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f0bce1ae135603d3cd0456353092e0a/" rel="bookmark">
			date命令的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在linux shell编程中，经常用到日期的加减运算
以前都是自己通过expr函数计算，很麻烦
其实date命令本身提供了日期的加减运算
非常方便。例如：得到昨天的时间
date +%Y%m%d --date="-1 day"
date 用法：
使用格式：
date [OPTION]... [+FORMAT]
date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]
date 可以用来显示或设定系统的日期与时间。
1.在显示方面，使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记，其中可用的标记列表如下:
时间方面 :
% : 打印出 %
%n : 下一行
%t : 跳格
%H : 小时(00..23)
%I : 小时(01..12)
%k : 小时(0..23)
%l : 小时(1..12)
%M : 分钟(00..59)
%p : 显示本地 AM 或 PM
%r : 直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M)
%s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f0bce1ae135603d3cd0456353092e0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c173b7182069eaabab0d57bf8ac27031/" rel="bookmark">
			个人理论，不信的可以跟帖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一切事物的起始状态都是静止的，上帝也不例外。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb6697d01b23511c9549b6bafcc79192/" rel="bookmark">
			vnc启动命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VNC服务的启动命令是vncserver 不要再前面加service
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/545d5e357498f361fe21e6c5ed17505e/" rel="bookmark">
			php字符串函数的大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PHP字符串函数大全 AddSlashes: 字符串加入斜线。 bin2hex: 二进位转成十六进位。 Chop: 去除连续空白。 Chr: 返回序数值的字符。 chunk_split: 将字符串分成小段。 convert_cyr_string: 转换古斯拉夫字符串成其它字符串。 crypt: 将字符串用 DES 编码加密。 echo: 输出字符串。 explode: 切开字符串。 flush: 清出输出缓冲区。 get_meta_tags: 抽出文件所有 meta 标记的资料。 htmlspecialchars: 将特殊字符转成 HTML 格式。 htmlentities: 将所有的字符都转成 HTML 字符串。 implode: 将数组变成字符串。 join: 将数组变成字符串。 ltrim: 去除连续空白。 md5: 计算字符串的 MD5 哈稀。 nl2br: 将换行字符转成 。 Ord: 返回字符的序数值。 parse_str: 解析 query 字符串成变量。 print: 输出字符串。 printf: 输出格式化字符串。 quoted_printable_decode: 将 qp 编码字符串转成 8 位字符串。 QuoteMeta: 加入引用符号。 rawurldecode: 从 URL 专用格式字符串还原成普通字符串。 rawurlencode: 将字符串编码成 URL 专用格式。 setlocale: 配置地域化信息。 similar_text: 计算字符串相似度。 soundex: 计算字符串的读音值 sprintf: 将字符串格式化。 strchr: 寻找第一个出现的字符。 strcmp: 字符串比较。 strcspn: 不同字符串的长度。 strip_tags: 去掉 HTML 及 PHP 的标记。 StripSlashes: 去掉反斜线字符。 strlen: 取得字符串长度。 strrpos: 寻找字符串中某字符最后出现处。 strpos: 寻找字符串中某字符最先出现处。 strrchr: 取得某字符最后出现处起的字符串。 strrev: 颠倒字符串。 strspn: 找出某字符串落在另一字符串遮罩的数目。 strstr: 返回字符串中某字符串开始处至结束的字符串。 strtok: 切开字符串。 strtolower: 字符串全转为小写。 strtoupper: 字符串全转为大写。 str_replace: 字符串取代。 strtr: 转换某些字符。 substr: 取部份字符串。 trim: 截去字符串首尾的空格。 ucfirst: 将字符串第一个字符改大写。 ucwords: 将字符串每个字第一个字母改大写。 返回值: 字符串 函数种类: 资料处理 内容说明: 本函数使需要让数据库处理的字符串，引号的部份加上斜线，以供数据库查询 (query) 能顺利运作。这些会被改的字符包括单引号 (')、双引号 ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/545d5e357498f361fe21e6c5ed17505e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ad2f900dc60939ed6d69ab3af1a6585/" rel="bookmark">
			二进制的大整数乘法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/*******二进制大整数乘法**********/
function multipication_b ($A,$B){
$sResult = "";
//反转字符串
$A=strrev($A);
$B =strrev($B);
//建立temp变量
$flag = array();
for($i=0;$i&lt;(strlen($A)+strlen($B)+1);$i++){
$flag[$i]= "0";
}
//依次相乘叠加
for ($i =0;$i&lt;strlen($A);$i++){
for($j =0;$j&lt;strlen($B);$j++){
$temp= ($A[$i]&amp;$B[$j]);
$flag[$i+$j+1] =$flag[$i+$j+1]+(int)(($flag[$i+$j]+$temp)/2);
$flag[$i+$j] =($flag[$i+$j]+$temp)%2;
}
}
// //再次叠加
// for($i=count($flag)-1;$i&gt;=0;$i--){
// $flag[$i+1] =(int)( $flag[$i]/2);
// $flag[$i] = $flag[$i]%2;
// }
//去除高位无用的0；
$mark = 0;
for($i=count($flag)-1;$i&gt;=0;$i--){
//echo $flag[$i];
if($flag[$i]!=0&amp;&amp;$mark==0){
$mark = $i;
}
if($mark!=0){
$sResult =$sResult.$flag[$i];
}
}
return $sResult;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0238d7d65097757e93eb47ceec8c7964/" rel="bookmark">
			php写的大整数的乘法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/*************十进制大整数相乘****************/
/*********
* $A，$B均为字符串
*/
function multipication ($A,$B){
$sResult = "";
//反转字符串
$A=strrev($A);
$B =strrev($B);
//建立temp变量
$flag = array();
for($i=0;$i&lt;(strlen($A)+strlen($B)+1);$i++){
$flag[$i]= "0";
}
//依次相乘叠加
for ($i =0;$i&lt;strlen($A);$i++)
for($j =0;$j&lt;strlen($B);$j++){
$flag[$i+$j] = $flag[$i+$j]+($A[$i]*$B[$j])%10;
$flag[$i+$j+1] = $flag[$i+$j+1]+(int)(($A[$i]*$B[$j])/10);
} //再次相乘叠加
for($i=0;$i&lt;count($flag)-1;$i++){
$flag[$i+1] = $flag[$i+1]+(int)($flag[$i]/10);
$flag[$i] = $flag[$i]%10;
}
//去除高位无用的0；
$mark = 0;
for($i=count($flag)-1;$i&gt;=0;$i--){
//echo $flag[$i];
if($flag[$i]!=0&amp;&amp;$mark==0){
$mark = $i;
}
if($mark!=0){
$sResult =$sResult.$flag[$i];
}
}
return $sResult;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d26267026e3eb3d0ae9fa333252d965/" rel="bookmark">
			FI &amp; MM &amp; CO T-CODE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事务码 描述(中英文) F.52 G/L: Acct Bal.Interest Calculation 总帐:计算科目余额利息 F-06 Post Incoming Payments 收款记帐 F-07 Post Outgoing Payments 付款记帐 FB1S Clear G/L Account 结算总分类帐科目 FB41 Post Tax Payable 应付税款记帐 FBB1 Post Foreign Currency Valuation 外币评估记帐 FBL3 Display G/L Account Line Items 显示总帐科目行项目 FBL4 Change G/L Account Line Items 更改总分类帐科目的行项目 FBX0 Change Documents for Ext.Documents 外部凭证的更改凭证 FBX1 Post External Documents Received 收到外部凭证记帐 FBX2 Change External Documents to be Sent 更改将送出的外部凭证 FBX3 Display Extern.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d26267026e3eb3d0ae9fa333252d965/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3530f201bbffd76fc3f3daaab2319a30/" rel="bookmark">
			dicom学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dicom学习笔记 2008年09月10日 星期三 11:37 DICOM是Digital Imaging and Communications in Medicine的英文缩写，即医学数字成像和通信标准。是ACR（American College of Radiology,美国放射学会）和NEMA（National Electrical Manufactorers Association,国家电子制造商协会）为主制定的用于数字化医学影像传送、显示与存储的标准。在DICOM标准中详细定义了影像及其相关信息的组成格式和交换方法，利用这个标准，人们可以在影像设备上建立一个接口来完成影像数据的输入/输出工作。
DICOM标准以计算机网络的工业化标准为基础，它能帮助更有效地在医学影像设备之间传输交换数字影像，这些设备不仅包括CT、CR/DR、MR、核医学和超声检查，而且还包括胶片数字化系统、视频采集系统和HIS／RIS信息管理系统等。
不过好象他也是转的，呵呵）
Meta Element Group Length (0002,0000) 1 UL File Meta Information Version (0002,0001) 1 OB Media Storage SOP Class UID (0002,0002) 1 UI Media Storage SOP Instance UID (0002,0003) 1 UI Transfer Syntax UID (0002,0010) 1 UI Implementation Class UID (0002,0012) 1 UI Implementation Version Name (0002,0013) 1 SH Source Applica... Entity Title (0002,0016) 1 AE [/img]Identifying Group Length (0008,0000) 1 UL Specific Character Set(0008,0005) 1 CS 特殊字符集 Image Type (0008,0008) 1-n CS 图像类型 AXIAL = 确定一个CT轴图像 LOCALIZER = 确定一个CT定位器图像 SOP Class UID (0008,0016) 1 UI SOP类UID SOP Instance UID (0008,0018) 1 UI SOP实例UID Study Date (0008,0020) 1 DA 研究信息获得开始的日期 Series Date (0008,0021) 1 DA 序列开始的日期 Acquisition Date (0008,0022) 1 DA 产生这个图象的数据获得开始的日期 Image Date (0008,0023) 1 DA 图象数据开始创建的日期 Study Time (0008,0030) 1 TM 研究信息获得开始的时间 Series Time (0008,0031) 1 TM 序列开始的时间 Acquisition Time (0008,0032) 1 TM 产生这个图象的数据获得开始的日期 Image Time (0008,0033) 1 TM 图象数据开始创建的时间 Accession Number (0008,0050) 1 SH RIS产生的标识研究顺序的号码 Modality (0008,0060) 1 CS 最初获得数据来创建这个序列中的图象的设备的类型 Manufacturer (0008,0070) 1 LO 产生数字图象的设备的制造商 Institution Name (0008,0080) 1 LO 设备位于的机构 Referring Physician's Name (0008,0090) 1 PN 这次就诊病人的主要负责医师 Station Name (0008,1010) 1 SH 用户定义的名字，标识产生数字图象的机器 Study Description (0008,1030) 1 LO 机构产生的描述或已执行的研究（组件）的分类 Institutional Department Name (0008,1040) 1 LO 产生数字图象的设备定位的机构内的部门 Performing Physician's Name (0008,1050) 1-n PN 执行研究的医师 Name of Physic.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3530f201bbffd76fc3f3daaab2319a30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/613ebca98ab799e3eedb942a88ce0d45/" rel="bookmark">
			C#多线程编程实例实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#多线程编程实例实战&lt;?xml:namespace prefix = o ns = "urn:schemas-microsoft-com:office:office" /&gt; 单个写入程序/多个阅读程序在.Net类库中其实已经提供了实现，即System.Threading.ReaderWriterLock类。本文通过对常见的单个写入/多个阅读程序的分析来探索c#的多线程编程。 问题的提出 所谓单个写入程序/多个阅读程序的线程同步问题，是指任意数量的线程访问共享资源时，写入程序（线程）需要修改共享资源，而阅读程序（线程）需要读取数据。在这个同步问题中，很容易得到下面二个要求： 1） 当一个线程正在写入数据时，其他线程不能写，也不能读。 2） 当一个线程正在读入数据时，其他线程不能写，但能够读。 在数据库应用程序环境中经常遇到这样的问题。比如说，有n个最终用户，他们都要同时访问同一个数据库。其中有m个用户要将数据存入数据库，n-m个用户要读取数据库中的记录。 很显然，在这个环境中，我们不能让两个或两个以上的用户同时更新同一条记录，如果两个或两个以上的用户都试图同时修改同一记录，那么该记录中的信息就会被破坏。 我们也不让一个用户更新数据库记录的同时，让另一用户读取记录的内容。因为读取的记录很有可能同时包含了更新和没有更新的信息，也就是说这条记录是无效的记录。 实现分析 规定任一线程要对资源进行写或读操作前必须申请锁。根据操作的不同，分为阅读锁和写入锁，操作完成之后应释放相应的锁。将单个写入程序/多个阅读程序的要求改变一下，可以得到如下的形式： 一个线程申请阅读锁的成功条件是：当前没有活动的写入线程。 一个线程申请写入锁的成功条件是：当前没有任何活动（对锁而言）的线程。 因此，为了标志是否有活动的线程，以及是写入还是阅读线程，引入一个变量m_nActive，如果m_nActive &gt; 0，则表示当前活动阅读线程的数目，如果m_nActive=0，则表示没有任何活动线程，m_nActive &lt;0，表示当前有写入线程在活动，注意m_nActive&lt;0，时只能取-1的值，因为只允许有一个写入线程活动。 为了判断当前活动线程拥有的锁的类型，我们采用了线程局部存储技术（请参阅其它参考书籍），将线程与特殊标志位关联起来。 申请阅读锁的函数原型为：public void AcquireReaderLock( int millisecondsTimeout )，其中的参数为线程等待调度的时间。函数定义如下： public void AcquireReaderLock( int millisecondsTimeout ) { // m_mutext 很快可以得到，以便进入临界区 m_mutex.WaitOne( ); // 是否有写入线程存在 bool bExistingWriter = ( m_nActive &lt; 0 ); if( bExistingWriter ) { //等待阅读线程数目加1,当有锁释放时，根据此数目来调度线程 m_nWaitingReaders++; } else { //当前活动线程加&lt;?xml:namespace prefix = st1 ns = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/613ebca98ab799e3eedb942a88ce0d45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35cc09c6ccb65c3feaeac7b2ef4f5063/" rel="bookmark">
			vnc的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：作为一名DBA，在创建Oracle数据库的过程中一般要使用dbca和netca图像化进行建库和创建监听（如果使用脚本建库另说），如果您身体好估计可以在瑟瑟发抖的机房中完成数据库的创建过程，由于本人对寒冷比较敏感，有不想通过这样的方式锻炼身体，所以更愿意在舒适的房间内一边品味着咖啡的浓香，顺便度过相对枯燥的数据库安装和配置的过程，So，图形化操作工具是必不可少的，在Linux操作系统最流行的图形化操作软件莫过于VNC，俺本着总结、共享及提醒的目的完成了这个详细的小文儿，希望大家喜欢。
1.确认VNC是否安装默认情况下，Red Hat Enterprise Linux安装程序会将VNC服务安装在系统上。确认是否已经安装VNC服务及查看安装的VNC版本[root@testdb ~]# rpm -q vnc-servervnc-server-4.1.2-9.el5[root@testdb ~]#若系统没有安装,可以到操作系统安装盘的Server目录下找到VNC服务的RPM安装包vnc-server-4.1.2-9.el5.x86_64.rpm，安装命令如下rpm -ivh /mnt/Server/vnc-server-4.1.2-9.el5.x86_64.rpm2.启动VNC服务使用vncserver命令启动VNC服务，命令格式为“vncserver :桌面号”，其中“桌面号”用“数字”的方式表示，每个用户连个需要占用1个桌面启动编号为1的桌面示例如下[root@testdb ~]# vncserver :1You will require a password to access your desktops.Password:Verify:xauth: creating new authority file /root/.XauthorityNew 'testdb:1 (root)' desktop is testdb:1Creating default startup script. /root/.vnc/xstartupStarting applications specified in /root/.vnc/xstartupLog file is /root/.vnc/testdb:1.log以上命令执行的过程中，因为是第一次执行，需要输入密码，这个密码被加密保存在用户主目录下的.vnc子目录（/root/.vnc/passwd）中；同时在用户主目录下的.vnc子目录中为用户自动建立xstartup配置文件（/root/.vnc/xstartup），在每次启动VND服务时，都会读取该文件中的配置信息。BTW：/root/.vnc/目录下还有一个“testdb:1.pid”文件，这个文件记录着启动VNC后对应后天操作系统的进程号，用于停止VNC服务时准确定位进程号。3.VNC服务使用的端口号与桌面号的关系VNC服务使用的端口号与桌面号相关，VNC使用TCP端口从5900开始，对应关系如下桌面号为“1” ---- 端口号为5901桌面号为“2” ---- 端口号为5902桌面号为“3” ---- 端口号为5903……基于Java的VNC客户程序Web服务TCP端口从5800开始，也是与桌面号相关，对应关系如下桌面号为“1” ---- 端口号为5801桌面号为“2” ---- 端口号为5802桌面号为“3” ---- 端口号为5803……基于上面的介绍，如果Linux开启了防火墙功能，就需要手工开启相应的端口，以开启桌面号为“1”相应的端口为例，命令如下[root@testdb ~]# iptables -I INPUT -p tcp --dport 5901 -j ACCEPT[root@testdb ~]# iptables -I INPUT -p tcp --dport 5801 -j ACCEPT4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35cc09c6ccb65c3feaeac7b2ef4f5063/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d681e6068e0c7c24c81e37a8db6ac1af/" rel="bookmark">
			信息管理与信息系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		信息管理与信息系统
1.什么是信息管理与信息系统？
信息管理 ： 是指在整个管理过程中，人们收集、加工和输入、输出的信息的总称。信息管理的过程包括信息收集、信息传输、信息加工和信息储存。信息收集就是对原始信息的获取。信息传输是信息在时间和空间上的转移，因为信息只有及时准确地送到需要者的手中才能发挥作用。信息加工包括信息形式的变换和信息内容的处理。信息的形式变换是指在信息传输过程中，通过变换载体，使信息准确地传输给接收者。信息的内容处理是指对原始信息进行加工整理，深入揭示信息的内容。经过信息内容的处理，输入的信息才能变成所需要的信息，才能被适时有效地利用。信息送到使用者手中，有的并非使用完后就无用了，有的还需留做事… 信息系统 ： 从技术上说就是为了支持决策和组织控制而收集（或获取）、处理、存储、分配信息的一组相互关联的组件。除了支持决策、协作和控制，信息系统也可用来帮助经理和工人分子问题，使复杂性可视化，以及创造新的产品，从商业角度看，一个信息系统是一个用于解决环境提出的挑战的，基于信息技术的组织管理方案。我们用“信息系统”这个词时，特指依赖于计算机技术的信息系统。一个基于计算机的信息系统是以计算机软件、硬件、存储和电信等技术为核心的人机系统。 2.业务培养目标： 本专业培养具备现代管理学理论基础、计算机科学技术知识及应用能力，掌握系统思想和信息系统分析与设计方法以及信息管理等方面的知识与能力，能在国家各级管理部门、工商企业、金融机构、科研单位等部门从事信息管理以及信息系统分析、设计、实施管理和评价等方面的高级专门人才。 业务培养要求：本专业学生主要学习经济、管理、数量分析方法、信息资源管理、计算机及信息系统方面的基本理论和基本知识，受到系统和设计方法以及信息管理方法的基本训练，具备综合运用所学知识分析和解决问题的基本能力。 毕业生应获得以下几方面的知识和能力： l．掌握信息管理和信息系统的基本理论基本知识； 2．掌握管理信息系统的分析方法、设计方法和实现技术； 3．具有信息组织、分析研究、传播与开发利用的基本能力； 4．具有综合运用所学知识分析和解决问题的基本能力； 5．了解本专业相关领域的发展动态； 6．掌握文献检索、资料查询、收集的基本方法，具有一定的科研和实际工作能力。[编辑本段]主干课程 主干学科：管理学、经济学、计算机科学与技术。 主要课程：经济学、会计学、市场营销学、生产与运作管理、组织战略与行为学、管理学原理、应用数理统计、运筹学、计算机系统与系统软件、数据结构与数据库等。 主要实践性教学环节：程序设计实习、管理软件实习、毕业设计等。一般安排18周，其中毕业设计不少于12周。 3.专业介绍： 这个专业主要是研究信息管理以及信息系统分析、设计、实施、管理和评价等方面的基本理论和方法。通俗地讲，就是从信息中发掘财富。现代社会正是信息化社会，大量纷繁的信息如何管理，并且从中获得有效的信息，正是信息管理科学的研究重点。与计算机结合，使计算机作为工具，信息管理更加有效和实用。随着企业经营规模的现代化，对信息管理的要求越来越强烈。例如铁路订票系统，就是对车票这种信息的查询和管理系统。可以说软件开发的最主要面向的客户就是帮助企业制作良好的信息管理系统。信息管理涉及咨询、服务、物流等很多行业，有很多的就业机会。 授课的内容— 偏重计算机、涉及管理课程 学习的内容涵盖计算机学科和管理学科的核心课程。管理学科方面有会计学、经济学、管理学、统计学；计算机方面有高级语言程序设计、数据结构、数据库、操作系统、计算机网络。两学科综合课程有电子商务、管理信息系统等。独立设计、实现小型信息系统或大型信息系统中的某一子系统，并在此基础上完成毕业设计论文，最后一个学期还应安排相应的管理软件上机实习。 专门设置信息管理和信息系统专业的院校很多，如中国人民大学、清华大学、北京大学、武汉大学、哈尔滨工业大学、西安交通大学、浙江大学、西交利物浦大学等。其中工科院校偏重对计算机应用的学习，文理院校偏重在管理上的研究，另外西交利物浦大学（由西安交通大学和英国利物浦大学在中国苏州联合创办的一所具有独立法人的招分在一本以上的大学）所开设的此专业方向则为“电子金融方向”。电子金融是指应用电子通信和电子计算来提供金融服务和金融市场，它包括电子支付系统、金融服务企业的运营以及金融市场的操作。计算机系统、互联网及其相关技术作为新的分配渠道，为金融服务企业有效地创造满足他们客户的需求的产品提供了条件。同时，这些新的技术让客户能轻松的利用广泛的资源和供应商得到金融信息和服务，从而打破了金融服务企业竞争的壁垒。这使得金融服务行业需要不断的创新，也加大了市场对既拥有必要的计算机技能，还同时了解金融产品、金融服务以及金融服务商如何运营等专业知识的毕业生的需求。电子金融专业就是为了满足市场的这一需求而开设的。 信息管理”顾名思义就是对信息进行管理，信息管理的活动包括信息的获取，整理，存储，加工，传输和输出等，管理的目的是让人们在需要的时刻获得所需要的信息。 例如，有上千人参加一场考试，每个考生的姓名，性别，年龄，职业，成绩等信息如果随意登记在册，要查询某一个学生的成绩就会很费时间，如果设立准考证号，并且按准考证号编排学生花名册，那就很容易查到一个学生的成绩，这个“设立准考证号，并且按准考证号编排学生花名册”就是一种简单的信息管理。 那么什么是信息系统呢？信息系统是为了实现信息管理的目标而建立的一套工作系统，它的组成包括信息、管理信息的人，管理信息的规程，管理信息的设备等等。 信息管理与信息系统是随信息而生的，自古就有，只是到了上个世纪的60年代由于计算机科学与技术的发展才发生了革命性的变化。计算机的特点是处理速度快，存储能力强，远远超过了人的能力，这两个显著特点用到信息管理上，人类进行信息管理的能力发生了飞跃。 例如，上面提到的上千学生按准考证号编排的学生花名册要改成一个按考试成绩排名的名单，若依靠手工处理，够几个人忙几天的，而用计算机处理，一眨眼的工夫这个名单就出来了。 所以，近几十年来，基于计算机的信息系统应运而生，并且随着信息技术的飞速发展日新月异，现在我们提到信息系统都是这种应用计算机进行信息管理的系统。 如今在我们的生活和工作中信息系统无处不在，政府、企业、学校、超市、医院、航空公司等各类各行的组织机构都建立了计算机信息系统。 假如今天你在自动取款机ATM上取钱，你就在使用银行的信息系统了，ATM从银行卡上获得你的帐号，同时从键盘的输入上获得你的密码和取款数目，通过网络把这些信息传输到银行信息系统的计算机里，与存储在数据库里你原有的存储信息进行核实，核实通过后，系统就向ATM发出支付信息，ATM进行付款操作，同时银行的计算机也修改了你的存储信息以及整个系统中与你的取款相关的信息，例如当日银行总取款数的信息。 如今，银行的所有业务都运行在银行信息系统上，系统每天要处理无数笔业务，系统既要确保数据的准确安全可靠，又要使用方便快捷，系统的技术和管理的复杂性是不言而喻的。 信息系统的普及和发展使得信息系统成为一个新兴的领域，这个领域专门从事信息系统的规划、设计、开发、维护和更新。从20世纪80年代开始在我国高校开设了相应的专业，专门培养信息系统领域需要的大量专业人才。早期这类专业的名称并不一致，1998年教育部调整专业时，正式定为“信息管理与信息系统”，归于管理学的管理科学与工程学科。 常有这样的误解：信息系统无非是计算机的一种应用，所以计算机专业人才就可以作为信息系统的专业人才。其实计算机专业人才与信息系统专业人才有本质的差别，前者是技术型人才，后者是技术与管理结合的综合型人才。 以财务信息系统为例，信息系统开发人员如果不懂财务管理，开发出来的必定是一个失败的系统或者是一个财务人员不愿意使用的系统。信息管理与信息系统专业的学生既要学习信息技术也要学习管理的理论和方法，他们不仅要掌握信息技术的基本知识和最新发展，也必须懂得如何把这些技术用于管理，既能够与技术人员沟通，也能够与业务领域人员沟通，是复合型人才。 专业知识的学习主要包括三个方面，一是学习管理学、经济学、运筹学等管理科学；二是学习数据库、网络和编程语言等信息技术；三是学习管理信息系统、信息系统分析与设计等信息系统的理论与方法。在信息系统发达的国家，还提倡学习行为科学和认知科学，使得建立的信息系统对用户更具有友好性。 除了具有上述的综合性的特点外，信息管理与信息系统专业也强调实践性，从编程开始，通过数据库应用，网络应用程序开发，一直到信息系统的设计与开发，学生在四年内一直有动手实践的机会，只有通过这些实践才能使学生理解书本上的知识和培养他们解决实际问题的能力。 信息管理与信息系统专业的毕业生有广泛的就业机会，可从事的职业大致可分为三个方面：信息系统开发业、信息系统管理业和信息系统咨询服务业。 从事信息系统开发的工作属于IT行业，在信息系统开发公司就业，如SAP，金碟，用友都是著名的信息系统开发商，中小型的开发商也有很多； 信息系统管理的工作遍布各行各业，几乎所有的组织机构都已经或即将成立独立的信息管理部门，有的称为信息中心，有的叫信息处，有的叫信息办，不管怎么称呼，其职能都是负责该组织的信息系统的建设和正常运行，这些部门提供了信息系统专业学生大量的就业机会； 信息系统咨询服务是一个新兴的行业，是一个中介性质的行业，它独立于系统开发商，为企业等组织提供关于信息系统的可行的解决方案，这样的公司正如雨后春笋般地出现。 当前，我国把信息化建设放在战略位置的高度上，提出了“以信息化带动工业化”的国策，各行各业的信息系统建设正方兴未艾，这种形势为信息管理与信息系统专业的发展提供了有利的机遇和光明前景。 有关联的其他专业：计算机科学与技术、企业管理、情报学、图书馆学。 名称不同但实质相同的专业： 计算机信息管理 信息管理专业，是一个涵盖面很广的专业，所以，在不同的学校的内容可能差异很大。专家提醒： 这是一个适应面相当广的专业。就业机会很多，近年来主要是： 软件开发人员-----帮助企业和组织问题，起薪一般在2000-3000元/月； 要注意这个专业在有的学校实际是学习计算机软件，有的可能是以前的图书馆系的改名，报考是一定要查明这些情况。 毕业后干什么— 主要是与计算机应用相关的工作，还有一些信息管理的工作 网络或系统管理员------企业或组织高效运行的保障，起薪一般在1500-3000元/月； 企业信息管理员 —— 在企业中从事信息搜集、管理工作，起薪一般在1000-3000元/月。 报考什么样的学校—— 应查明各校研究方向上 4.专业课程： 01计算机基础 02形势与政策 03思想道德修养与法律基础 04体育 05军事理论 06大学生心理素质拓展训练 07高级语言程序设计 08西方经济学原理 09线性代数 10数据库应用 11中国近现代史纲要 12高等数学 13管理学原理 14概率论与数理统计 15数据结构 16面向对象程序设计 17中国化马克思主义 18大学英语 19数据库系统原理 20计算机操作系统 21市场调查与预测 22计算方法 23多媒体技术 24计算机硬件技术概论 25马克思主义基本原理 26离散数学 27运筹学 28管理应用软件开发 29市场营销概论 30电子商务概论 31可视化程序设计 32财务管理 33动态网页应用 34计算机网络 35企业战略管理 36数据仓库与数据挖掘 37信息系统分析设计 38管理信息系统 39Unix系统与编译技术 40文学修养 41就业指导 42决策支持系统 43企业资源计划 44统一建模语言（UML） 45人力资源管理 46微观经济学 47宏观经济学 48信息安全概论 49数据库原理 50JAVA语言 51知识产权法 52企业竞争情报 53信息分析与预测 54计算机实用软件 55编译原理 56概率论与数理统计 57计算机系统维护 58市场营销学 59线性代数 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d681e6068e0c7c24c81e37a8db6ac1af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bc186a708c0d117538dc97a79c5b73a/" rel="bookmark">
			【VNC】Linux环境VNC服务安装、配置与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：作为一名DBA，在创建Oracle数据库的过程中一般要使用dbca和netca图像化进行建库和创建监听（如果使用脚本建库另说），如果您身体好估计可以在瑟瑟发抖的机房中完成数据库的创建过程，由于本人对寒冷比较敏感，又不想通过这样的方式锻炼身体，所以更愿意在舒适的房间内一边品味着咖啡的浓香，顺便度过相对枯燥的数据库安装和配置的过程，So，图形化操作工具是必不可少的，在Linux操作系统最流行的图形化操作软件莫过于VNC，俺本着总结、共享及提醒的目的完成了这个详细的小文儿，希望大家喜欢。
1.确认VNC是否安装默认情况下，Red Hat Enterprise Linux安装程序会将VNC服务安装在系统上。确认是否已经安装VNC服务及查看安装的VNC版本[root@testdb ~]# rpm -q vnc-servervnc-server-4.1.2-9.el5[root@testdb ~]#若系统没有安装,可以到操作系统安装盘的Server目录下找到VNC服务的RPM安装包vnc-server-4.1.2-9.el5.x86_64.rpm，安装命令如下rpm -ivh /mnt/Server/vnc-server-4.1.2-9.el5.x86_64.rpm2.启动VNC服务使用vncserver命令启动VNC服务，命令格式为“vncserver :桌面号”，其中“桌面号”用“数字”的方式表示，每个用户连个需要占用1个桌面启动编号为1的桌面示例如下[root@testdb ~]# vncserver :1You will require a password to access your desktops.Password:Verify:xauth: creating new authority file /root/.XauthorityNew 'testdb:1 (root)' desktop is testdb:1Creating default startup script. /root/.vnc/xstartupStarting applications specified in /root/.vnc/xstartupLog file is /root/.vnc/testdb:1.log以上命令执行的过程中，因为是第一次执行，需要输入密码，这个密码被加密保存在用户主目录下的.vnc子目录（/root/.vnc/passwd）中；同时在用户主目录下的.vnc子目录中为用户自动建立xstartup配置文件（/root/.vnc/xstartup），在每次启动VND服务时，都会读取该文件中的配置信息。BTW：/root/.vnc/目录下还有一个“testdb:1.pid”文件，这个文件记录着启动VNC后对应后天操作系统的进程号，用于停止VNC服务时准确定位进程号。3.VNC服务使用的端口号与桌面号的关系VNC服务使用的端口号与桌面号相关，VNC使用TCP端口从5900开始，对应关系如下桌面号为“1” ---- 端口号为5901桌面号为“2” ---- 端口号为5902桌面号为“3” ---- 端口号为5903……基于Java的VNC客户程序Web服务TCP端口从5800开始，也是与桌面号相关，对应关系如下桌面号为“1” ---- 端口号为5801桌面号为“2” ---- 端口号为5802桌面号为“3” ---- 端口号为5803……基于上面的介绍，如果Linux开启了防火墙功能，就需要手工开启相应的端口，以开启桌面号为“1”相应的端口为例，命令如下[root@testdb ~]# iptables -I INPUT -p tcp --dport 5901 -j ACCEPT[root@testdb ~]# iptables -I INPUT -p tcp --dport 5801 -j ACCEPT4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bc186a708c0d117538dc97a79c5b73a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/126/">«</a>
	<span class="pagination__item pagination__item--current">127/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/128/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>