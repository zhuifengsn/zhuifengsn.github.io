<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88b12bf99d788bf3c07886a934c10a78/" rel="bookmark">
			C语言中为什么 字符串 可直接赋值给字符指针变量？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“ ”，双引号做了三件事，
1.申请空间（在常量区），存放字符串
2.在字符串结尾加了 ‘\0‘ 3.返回地址 4.指针P接收的就是字符串的地址，而不是字符串本身。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ad53abf5f8e191a6bcd0d9584353620/" rel="bookmark">
			Java面试高频题汇总：消息中间件篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先来看看本篇内容的知识点如下： 在开始正式的面试题之前，我们先来介绍下这篇文章，左边目录是题目，大家可以选择查看，按照顺序学习是最好的。另外，面试官下面的【图片/文字】内容，均为知识点。候选人的文字，则是口语的回答！关于知识点也嵌入在回答中了，希望大家能看明白~
面试官：RabbitMQ-如何保证消息不丢失 候选人：
嗯！我们当时MYSQL和Redis的数据双写一致性就是采用RabbitMQ实现同步的，这里面就要求了消息的高可用性，我们要保证消息的不丢失。主要从三个层面考虑；
第一个是开启生产者确认机制，确保生产者的消息能到达队列，如果报错可以先记录到日志中，再去修复数据；
第二个是开启持久化功能，确保消息未消费前在队列中不会丢失，其中的交换机、队列、和消息都要做持久化；
第三个是开启消费者确认机制为auto，由spring确认消息处理成功后完成ack，当然也需要设置一定的重试次数，我们当时设置了3次，如果重试3次还没有收到消息，就将失败后的消息投递到异常交换机，交由人工处理。
面试官：RabbitMQ消息的重复消费问题如何解决的 候选人：
嗯，我想想~
其实这个就是典型的幂等的问题，比如，redis分布式锁、数据库的锁都是可以的
面试官：RabbitMQ中死信交换机 ? （RabbitMQ延迟队列有了解过嘛） 候选人：
我们当时的xx项目有一个xx业务，需要用到延迟队列，其中就是使用RabbitMQ来实现的。
延迟队列就是用到了死信交换机和TTL（消息存活时间）实现的。
如果消息超时未消费就会变成死信，在RabbitMQ中如果消息成为死信，队列可以绑定一个死信交换机，在死信交换机上可以绑定其他队列，在我们发消息的时候可以按照需求指定TTL的时间，这样就实现了延迟队列的功能了。
我记得RabbitMQ还有一种方式可以实现延迟队列，在RabbitMQ中安装一个死信插件，这样更方便一些，我们只需要在声明交互机的时候，指定这个就是死信交换机，然后在发送消息的时候直接指定超时时间就行了，相对于死信交换机+TTL要省略了一些步骤。
面试官：如果有100万消息堆积在MQ，如何解决？ 候选人：
我在实际的开发中，没遇到过这种情况，不过，如果发生了堆积的问题，解决方案也所有很多的
第一:提高消费者的消费能力 ,可以使用多线程消费任务
第二：增加更多消费者，提高消费速度
使用工作队列模式, 设置多个消费者消费消费同一个队列中的消息
第三：扩大队列容积，提高堆积上限
可以使用RabbitMQ惰性队列，惰性队列的好处主要是
①接收到消息后直接存入磁盘而非内存②消费者要消费消息时才会从磁盘中读取并加载到内存③支持数百万条的消息存储 面试官：RabbitMQ的高可用机制有了解过嘛 在生产环境下，使用集群来保证高可用性普通集群、镜像集群、仲裁队列 候选人：
嗯，熟悉的~
我们当时项目在生产环境下，使用的集群，当时搭建是镜像模式集群，使用了3台机器。
镜像队列结构是一主多从，所有操作都是主节点完成，然后同步给镜像节点，如果主节点宕机后，镜像节点会替代成新的主节点，不过在主从同步完成前，主节点就已经宕机，可能出现数据丢失
面试官：那出现丢数据怎么解决呢？ 候选人：
我们可以采用仲裁队列，与镜像队列一样，都是主从模式，支持主从数据同步，主从同步基于Raft协议，强一致。
并且使用起来也非常简单，不需要额外的配置，在声明队列的时候只要指定这个是仲裁队列即可.
面试官：Kafka是如何保证消息不丢失？ 候选人：
嗯，这个保证机制很多，在发送消息到消费者接收消息，在每个阶段都有可能会丢失消息，所以我们解决的话也是从多个方面考虑。
第一个是生产者发送消息的时候，可以使用异步回调发送，如果消息发送失败，我们可以通过回调获取失败后的消息信息，可以考虑重试或记录日志，后边再做补偿都是可以的。同时在生产者这边还可以设置消息重试，有的时候是由于网络抖动的原因导致发送不成功，就可以使用重试机制来解决。
第二个在broker中消息有可能会丢失，我们可以通过kafka的复制机制来确保消息不丢失，在生产者发送消息的时候，可以设置一个acks，就是确认机制。我们可以设置参数为all，这样的话，当生产者发送消息到了分区之后，不仅仅只在leader分区保存确认，在follwer分区也会保存确认，只有当所有的副本都保存确认以后才算是成功发送了消息，所以，这样设置就很大程度了保证了消息不会在broker丢失。
第三个有可能是在消费者端丢失消息，kafka消费消息都是按照offset进行标记消费的，消费者默认是自动按期提交已经消费的偏移量，默认是每隔5s提交一次，如果出现重平衡的情况，可能会重复消费或丢失数据。我们一般都会禁用掉自动提价偏移量，改为手动提交，当消费成功以后再报告给broker消费的位置，这样就可以避免消息丢失和重复消费了。
面试官：Kafka中消息的重复消费问题如何解决的？ 候选人：
kafka消费消息都是按照offset进行标记消费的，消费者默认是自动按期提交已经消费的偏移量，默认是每隔5s提交一次，如果出现重平衡的情况，可能会重复消费或丢失数据。我们一般都会禁用掉自动提价偏移量，改为手动提交，当消费成功以后再报告给broker消费的位置，这样就可以避免消息丢失和重复消费了；
为了消息的幂等，我们也可以设置唯一主键来进行区分，或者是加锁，数据库的锁，或者是redis分布式锁，都能解决幂等的问题。
面试官：Kafka是如何保证消费的顺序性 应用场景： 即时消息中的单对单聊天和群聊，保证发送方消息发送顺序与接收方的顺序一致 充值转账两个渠道在同一个时间进行余额变更，短信通知必须要有顺序 候选人：
kafka默认存储和消费消息，是不能保证顺序性的，因为一个topic数据可能存储在不同的分区中，每个分区都有一个按照顺序的存储的偏移量，如果消费者关联了多个分区不能保证顺序性；
如果有这样的需求的话，我们是可以解决的，把消息都存储同一个分区下就行了，有两种方式都可以进行设置，第一个是发送消息时指定分区号，第二个是发送消息时按照相同的业务设置相同的key，因为默认情况下分区也是通过key的hashcode值来选择分区的，hash值如果一样的话，分区肯定也是一样的。
面试官：Kafka的高可用机制有了解过嘛 候选人：
嗯，主要是有两个层面，第一个是集群，第二个是提供了复制机制。
kafka集群指的是由多个broker实例组成，即使某一台宕机，也不耽误其他broker继续对外提供服务。
复制机制是可以保证kafka的高可用的，一个topic有多个分区，每个分区有多个副本，有一个leader，其余的是follower，副本存储在不同的broker中；所有的分区副本的内容是都是相同的，如果leader发生故障时，会自动将其中一个follower提升为leader，保证了系统的容错性、高可用性。
面试官：解释一下复制机制中的ISR 候选人：
ISR的意思是in-sync replica，就是需要同步复制保存的follower；
其中分区副本有很多的follower，分为了两类，一个是ISR，与leader副本同步保存数据，另外一个普通的副本，是异步同步数据，当leader挂掉之后，会优先从ISR副本列表中选取一个作为leader，因为ISR是同步保存数据，数据更加的完整一些，所以优先选择ISR副本列表。
面试官：Kafka数据清理机制了解过吗？ 候选人：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ad53abf5f8e191a6bcd0d9584353620/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79340541654323f62c3b69d5cb400405/" rel="bookmark">
			51单片机扫描按键短按、双击、长按功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按键扫描是一个常见的任务，涉及到硬件交互和状态处理。本篇教程将讲解一个简单的51单片机按键扫描程序，基于状态机实现短按、双击、长按功能，并解释其实现原理。按键消抖采用的非阻塞式，这样可以大大提高单片机效率。
1. 介绍 以下是一个基于51单片机的按键扫描程序，其中包括按键去抖动、短按、双击和长按检测。我们将一步步地解析该程序的实现原理。
#include &lt;reg51.h&gt; sbit KEY = P1^0; typedef enum { IDLE, PRESSED, RELEASED, WAIT_DOUBLE_CLICK, DOUBLE_CLICKED, WAIT_LONG_PRESS, LONG_PRESSED } KeyState; unsigned char debounceCounter = 0; void checkKeyPress(KeyState *state); void main() { KeyState state = IDLE; while (1) { checkKeyPress(&amp;state); } } void checkKeyPress(KeyState *state) { switch (*state) { // 状态机处理逻辑在下文中给出 } } 2. 实现原理解析 2.1 状态机 按键扫描的实现基于状态机的概念，通过不同状态的切换来处理按键的各种操作。
typedef enum { IDLE, PRESSED, RELEASED, WAIT_DOUBLE_CLICK, DOUBLE_CLICKED, WAIT_LONG_PRESS, LONG_PRESSED } KeyState; IDLE: 初始状态。PRESSED: 按键按下。RELEASED: 按键释放。WAIT_DOUBLE_CLICK: 等待第二次按下，检测双击。DOUBLE_CLICKED: 双击状态。WAIT_LONG_PRESS: 等待长按。LONG_PRESSED: 长按状态。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79340541654323f62c3b69d5cb400405/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22ee8e9aad022a2ebb9ccaa8f9f532b5/" rel="bookmark">
			.NET源码分析之List
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		List类图
上图展示了List的继承和实现关系。
构造函数
List构造函数一共有3个，
1、无参构造，创建的集合是一个空数组。
2、带集合大小的构造，如果传入的是有效的集合大小，则创建对应大小的数组。
3、实现了IEnumerable类型的构造，将传入的数据copy到新的数组中去。
PS：List底层的实现是通过Array数组来实现的（private T[] _items）。
Count：这个属性最常用，指的是当前集合中元素的数量。
Capacity：这个属性代表了当前集合所使用数组的容量，上面也提示过了，List的底层是数组，数组在声明的时候是需要有一个固定长度的，Capacity指的就是数组的长度，Capacity的值一定是大于等于Count。
方法
Add和Insert类方法
往集合中添加数据，最终是往数组_items中增加数据
下图展示的是Add方法的源码，从源码中可以看到
刚初始化的空集合第一次添加数据时，默认设置数组的长度_defaultCapacity为4，当给集合添加第5个元素时，底层实现数组则是创建一个新数组，新数组的长度是当前数组的2倍，然后将当前数组的数据拷贝到新数组中，最后将第5个新元素加入数组中；
Find类方法
从源码中可以看到Find方法的根子是使用for循环来实现的，传入的是lambda表达式进行对比。
Indexof类方法
indexof类方法调用的是Array数组的indexof方法，最终使用for循环进行查找下标。
Remove方法
remove方法实现是使用数组的copy来实现的，比如当前集合5个元素，要移除第3个元素，实际结果是将数组的第4个元素到最后一个元素拷贝然后粘贴替换到数组的从第3个元素开始，这样就把第三个元素给替换掉了，然后再把数组的最后一个元素给置为默认。
RemoveAll方法
removeAll方法实现如下图所示，是先将所有符合移除条件的元素通过前后位置交换的方式，全部替换到数组的尾部，这样需要移除的元素都是在一起并且是在数组的尾部，然后再通过Array的clear方法，将尾部的元素全部移除。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d63033517c48e4176831be93c5b6d998/" rel="bookmark">
			【WinForm】使用Costura.Fody打包编译成可独立运行的桌面程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新建项目 在建项目的时候要注意，选择Windows 窗体应用（.NET Framework），然后打开
安装包 在解决方案资源管理器中，选择刚才的项目名，鼠标右键找到并打开管理NuGet包，然后在浏览选项卡里，输入一个Costura.Fody并查找，有就点安装，安装前需要注意选择支持的对应版本和依赖项
静态编译 接下来，重新编译项目，没报错的话，项目里会出现一个隐藏的文件FodyWeavers.xml，这样就是可以了，这是Costura的配置文件，参考官方的文档修改吧，能按自己设置的条件编译程序，一般情况下不用管，使用默认配置即可
如果没有看到FodyWeavers.xml文件，那就自己手动添加
添加文件步骤
选择你的项目，单击鼠标右键，选择“添加” → “新建项” → 找到“ XML文件 ”，在新建XML文件名输入框填入“ FodyWeavers. xml “，然后把如下内容复制粘贴到新建的文件内容里 &lt;?xml version="1.0" encoding="utf-8" ?&gt; &lt;Weavers&gt; &lt;Costura /&gt; &lt;/Weavers&gt; 最后，确定一下是否会打包编译成可独立运行的桌面程序，打开项目里的目录bin/Debug/或者bin/Release/下看看，如下图所示，所有依赖的dll文件都打包在一个exe可执行程序里
接着，清理一下，然后重新生成，再看看输出文件夹里，是否减少了dll依赖文件， 遇到问题 看到有些dll文件依旧存在？ 创建一两个文件夹，Costura64或者Costura32，根据你编译的运行环境选择，把生成的依赖文件复制那文件夹里面
再把复制到的一些文件，设置包括到项目中，然后修改属性生成操作为嵌入的资源
重新编译后，可以发现生成的exe可执行程序的文件大小，是否变大了，接下来，删除除exe可执行程序之外的一些依赖文件，再点击运行exe可执行程序试试，没问题就OK 收工 到此结束，一个可执行的桌面程序绿色版本就这样弄出来了，
无需安装，直接运行，方便分享程序给他人使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4c27ede8e9d375b03e8349ec27c893e/" rel="bookmark">
			实时时钟DS1302原理详解和单片机编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、DS1302的功能 DS1302是美国DALLAS推出的一款高性能、低功耗的日历时钟芯片。
DS1302是一种串行接口的实时时钟，芯片内部具有可编程的日历时钟和31个字节的静态RAM，日历时钟可以自动进行闰年补偿，计时准确，接口简单，使用方便，工作电压范围宽（2.5~5.5V），芯片自身还具有对备用电池进行涓流充电功能，可有效延长备用电池的使用寿命。
DS1302用于数据记录，能实现数据与该数据出现的时间同时记录，因此广泛应用于测量系统中。
二、DS1302硬件及引脚功能 各引脚功能为：
1、VCC1：主电源。 VCC2：备用电源。当VCC2大于VCC1+0.2V时由VCC2向DS1302供电否则由VCC1向DS1302供电。
2、SCLK：串行时钟输入端，控制数据输入与输出；
3、I/O ：双向输入线；
4、CE：使能端，CE为高时允许读写DS1302数据，为低时禁止读写。
三、DS1302寄存器 时钟日历和控制寄存器如图所示：
如上图所示，时钟日历寄存器包含在7个读/写寄存器内，读/写寄存器中的数据是BCD码。
秒寄存器（81h、80h）的BIT7定义为时钟暂停标志（CH）。当该位置为1时，时钟振荡器停止，DS1302处于低功耗状态；当该位置为0时，时钟开始运行。
小时寄存器（85h、84h）的BIT7用于定义DS1302是运行于12小时模式还是24小时模式，当为1时，选择12小时模式，此时BIT5为AM/PM位，在24小时模式时此位为小时数据位。
控制寄存器（8Fh、8Eh）的BIT7是写保护位（WP），其它7位均为0。在任何对时钟或RAM读写操作之前，WP位必须为0。当WP位为1时，不能对任何时钟日历寄存器或RAM进行写操作。
31个字节静态RAM寄存器如图所示
突发模式配置寄存器如图所示
四、DS1302通信时序 DS1302读写数据时序，图8为读一字节时序，图9为写一字节时序，数据的传输是从最低位开始（BIT0）。数据是以位（BIT）为单位依次写入或读出，读写数据操作中SCLK上升沿时执行写入数据，下降沿时执行读出数据。
读数据：CE端从低到高的一个上升沿开始允许开始读数据，拉低CE端则禁止读写数据；开始的8个SCLK周期，写命令字节，数据的后8个SCLK 周期读出数据。
写数据：CE端从低到高的一个上升沿开始允许开始写数据，拉低CE端则禁止读写数据；开始的8个SCLK周期，写命令字节，数据的后8个SCLK 周期写入数据。
五、BCD码的转换 在DS1302中有关于时钟日历的寄存器数据存储格式为BCD码；
BCD码介绍：
我们时钟日历寄存器使用的是8421码型的BCD码，BCD码还有5421码、2421码等，其中8421码型的BCD码最最常用；
BCD码是用四位二进制数表示一位十进制数的0-9这十个数简称BCD码；
8421
8421码型BCD码最小值为0000（二进制），最大值为1001（二进制）；9
一个字节的8421码型BCD码中的低四位用于表示十进制的个位，高四位用于表示十进制的十位，如10（十进制）的8421码型BCD码=0001 0000；
BCD码用程序转换实例：
例：把十进制数45转换为8421型BCD码
unsigned char data1, data2 = 45; //声明2个无符号char型变量data1和data2并且data2赋初值45
data1 = data2/10; data2 = data2%10; data2 = data2 + data1*16; //data2最终等于69这个数
把69这个8421型BCD码换算回十进制数：
data1 = data2/16; data2 = data2%16; data2 = data2 + data1*10; //data2最终等于45
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4c27ede8e9d375b03e8349ec27c893e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b90bbe1116bf716370912de1babc044/" rel="bookmark">
			1.1.1操作系统的概念、功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 熟悉的操作系统1.操作系统概念（定义）2.系统资源的管理者3.OS向上层提供方便易用的服务命令接口程序接口 4.最为接近硬件的层次总结 熟悉的操作系统 1.操作系统概念（定义） 2.系统资源的管理者 3.OS向上层提供方便易用的服务 封装：操作系统把硬件功能封装成简单易用的服务，使用户能跟方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可。作为用户和计算机硬件系统之间的接口。操作系统提供的接口分为两类，分别是命令接口和程序接口。 命令接口 用户可以直接使用的，利用这些操作命令来组织和控制作业的执行联机命令接口又称交互式命令接口，适用于分时或实时系统的接口，由一组键盘操作命令组成。用户输入一条指令，操作系统就执行一条指令
脱机命令接口又称批处理接口，用于处理系统，由一组作业控制命令组成。用户输入一堆指令，操作系统运行一堆指令操作系统运行这些指令时用户不可以干预
程序接口 程序接口：由一组系统调用（也称广义指令）组成
比如常见的图形用户界面程序接口GUI
不过，有的教材会把命令接口和程序接口统称为“用户接口”，即，狭义的用户接口其实不包含GUI。
4.最为接近硬件的层次 总结 参考：《2021王道考研操作系统》
bilibili: https://www.bilibili.com/video/av70156862
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f48e04e5237964c9962748460c4136d/" rel="bookmark">
			1.1.2操作系统的四个基本特征
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.并发并行 2.共享并发与共享的关系 3.虚拟4.异步总结 1.并发 定义：指两个或者多个事件在同一时间间隔内发生。这些事件宏观上时同时发生的，但是在微观上是交替发生的。 并行 定义：指两个或多个事件在同一时刻发生。 举个例子
所以，理论理解为
2.共享 定义：共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。
并发与共享的关系 3.虚拟 定义：是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）实际存在的，而逻辑上对应物（后者）是用户感受到的。就是给一个大的时间段你完成这些任务，你完成了，可以认为你在大时间段里一起完成这些任务，但实际上你是分成一小段时间完成一个任务，最后在这个大时间段了把所有任务完成。
虚拟技术
4.异步 定义：异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。 当执行第一道程序时，由于老渣把心给了一号，所以当执行到和二号约会时，二号让老渣把心给她，但老渣已经把心给了一号，所以就无法把心给二号，程序运行到这里就阻塞了，反之把心给二号亦然。 总结 参考：《2021王道考研操作系统》
bilibili: https://www.bilibili.com/video/av70156862
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c372a6f153a0a3dd56a6ac7b9af140b/" rel="bookmark">
			1.3.1 操作系统的运行机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 程序运行内核程序 VS 应用程序应用程序内核程序 特权指令 VS 分特权指令使用者 内核态 VS 用户态内核态用户态 内核态与用户态的切换总结 程序运行 程序的运行过程其实就是CPU执行一条一条的机器指令的过程。指令就是处理器CPU能够识别、执行的最基本的命令。注意：不少人把命令提示符“小黑框”中使用的命令称为“指令”，但这其实是“交互式命令接口”的命令行所输入的命令。这里所讲的指令指的是二进制机器指令。
内核程序 VS 应用程序 应用程序 普通程序员写的程序。 内核程序 微软、苹果公司的专业人员负责实现操作系统的，他们写的就是“内核程序”
有很多内核程序组成“操作系统内核”，简称“内核”
内核是操作系统最重要最核心的部分，也就是最接近硬件的部分
甚至可以说，一个操作系统只有一个内核就够了（如：Docker -&gt; 仅需Linux内核）注意：图形化用户界面GUI是操作系统的功能，但并不在内核中。 特权指令 VS 分特权指令 在CPU设计和生产时候就划分了特权指令和非特权指令，因此CPU执行一条指令前就能判断指令的类型。 使用者 应用程序：
应用程序只能使用“非特权指令”，如：加法指令、减法指令内核程序
操作系统内核作为“管理者”，有时会让CPU执行一些“特权指令”，如：内存清零指令。这些指令影响重大，只允许“管理者”——即，操作系统内核来使用。 内核态 VS 用户态 CPU有两种状态，“内核态”和“用户态”。拓展： CPU中有个寄存器叫程序状态字寄存器（PSW），其中有个二进制位，1表示“内核态”，0表示“用户态”。 内核态 处于内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令。别名： 内核态 = 核心态 = 管态 用户态 处于用户态时，说明此时正在执行的是应用程序，此时只能执行非特权指令。别名： 用户态 = 目态 内核态与用户态的切换 故事理解用户态和内核态的转换
总结 参考：《2021王道考研操作系统》
王道B站视频课
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdefc7f6ed925a1554bc1a97a4025c87/" rel="bookmark">
			3.6.1 局域网基本概念和体系结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 局域网局域网拓扑结构局域网介质访问控制方法 局域网的分类IEEE 802标准MAC子层和LLC子层LLC子层MAC子层 总结 局域网 局域网：简称LAN（Local Area Nerwork），是指在某一区域内有多台计算机互联成的计算机组，使用广播信道。
特点
覆盖的地理范围较小。只在一个相对独立的局部范围内联，如一座或集中的建筑群内。使用专门铺设的传输介质（双绞线、同轴电缆）进行联网，数据传输速率高（10Mb/s~10Gb/s）。通信延迟时间短，误码率低，可靠性较高。各站为平等关系，共享传输信道。多采用分布式控制和广播式通信，能进行广播和组播。 决定局域网的主要要素为：网络拓扑，传输介质与介质访问控制方法。
局域网拓扑结构 局域网传输介质
有线局域网：双绞线、同轴电缆、光纤（三个比较常用）
无线局域网：电磁波（常用）
局域网介质访问控制方法 CSMA/CD 常用于总线型局域网，也用于树型网络令牌总线 常用于总线型局域网，也用于树型网络
它是把总线型或树型网络中的各个工作站按一定顺序如按接口地址大小排列形成一个逻辑环。只有令牌持有者才能控制总线，才有发送信息的权力。令牌环 用于环形局域网，如令牌环网 局域网的分类 IEEE 802标准 IEEE 802系列标准是IEEE 802 LAN/MAN标准委员会制定的局域网、城域网技术标准(1980年2月成立）。其中最广泛使用的有以太网、令牌环、无线局域网等。这一系列标准中的每一个子标准都由委员会中的一个专门工作组负责。 主要了解的：
MAC子层和LLC子层 IEEE 802标准所描述的局域网参考模型只对应OSI参考模型的数据链路层与物理层，它将数据链路层划分为逻辑链路层LLC子层和介质访问控制MAC子层。
LLC子层 逻辑链路控制子层LLc负责识别网络层协议，然后对它们进行封装。LLC报头告诉数据链路层一旦帧被接收到时，应当对数据包做何处理。为网络层提供服务:无确认无连接、面向连接、带确认无连接、高速传送。 MAC子层 介质访问控制子层MAC子层的主要功能包括数据帧的封装/卸装，帧的寻址和识别，帧的接收与发送，链路的管理，帧的差错控制等。MAC子层的存在屏蔽了不同物理链路种类的差异性。 总结 笔记出处
王道计算机考研 计算机网络
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1451b9b2603c574c1f414362cfa9c6d1/" rel="bookmark">
			如何下载 CT Image Storage 的.dcm数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CT Image Storage 的.dcm数据集下载 因为网上少有.dcm详细下载方式，所以记录一下，这里我们以肺部CT分割挑战2017数据集为例。
首先，来到数据集官网Lung+CT+Segmentation+Challenge+2017 (科学上网)
Windows系统下
下载 LCTSC_v2_20190508.tcia接着下载 NBIA Data Retriever-4.2.msi 下载完以后，双击打开NBIA Data Retriever-4.2.msi并下载NBIA Data Retriever，下载完，安装以后，可能桌面上没有相关的快捷方式，可以到电脑左下角搜索栏输入NBIA Data Retriever就可以找到该应用了，即，应用已下载。
现在双击 LCTSC_v2_20190508.tcia 文件，然后会出现弹窗，不用理，点击 X
再次出现弹窗，点击agree
来到数据集下载处，修改数据集存储路径（下方箭头所指处）
然后点击要下载的数据集，这里点击第一行
然后点解Start，下载过程progress那里有进度条显示，下载完，点击close，关掉就好了。
来到你刚刚的那个路径，点进去查看
下载成功。
这里来个dcm图片显示的py脚本
import pydicom import numpy as np from PIL import Image from matplotlib import pyplot path = r'E:\test\exp_3\manifest-1678623383837\LIDC-IDRI\LIDC-IDRI-0001\01-01-2000-NA-NA-30178\3000566.000000-NA-03192\1-040.dcm' data = pydicom.dcmread(path, force=True) # 查看患者基本信息 print(data) print(data.keys()) # print(data[('0008', '0018')]) # data = np.array(data.pixel_array) # filename = path dataset = pydicom.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1451b9b2603c574c1f414362cfa9c6d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6bca94257e14a57fdf429a76fe7ed96/" rel="bookmark">
			六.聚合函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		聚合函数 1.什么是聚合函数1.1AVG和SUM函数1.2MIN和MAX函数1.3COUNT函数 2.GROUP BY2.1基本使用2.2使用多个列分组2.3GROUP BY中使用WITH ROLLUP 3.HAVING3.1基本使用3.2WHERE和HAVING的区别 4.SELECT的执行过程4.1查询的结构4.2SELECT执行顺序4.3SQL执行原理 1.什么是聚合函数 聚合函数作用于一组数据，并对一组数据返回一个值。
聚合函数类型 AVG()SUM()MAX()MIN()COUNT() 聚合函数语法
聚合函数不能嵌套调用。比如不能出现类似AVG(SUM(字段名称))形式的调用。 1.1AVG和SUM函数 可以对数值型数据使用AVG和SUM函数
SELECT AVG(salary), MAX(salary),MIN(salary), SUM(salary) FROM employees WHERE job_id LIKE '%REP%'; 1.2MIN和MAX函数 可以对任意数据类型的数据使用MIN和MAX函数
SELECT MIN(hire_date), MAX(hire_date) FROM employees; 1.3COUNT函数 COUNT(*)返回表中记录总数，适用于任意数据类型 SELECT COUNT(*) FROM employees WHERE department_id = 50; COUNT(expr)返回expr不为空的记录总数 SELECT COUNT(commission_pct) FROM employees WHERE department_id = 50; 问题：用count(*)，count(1)，count(列名)谁好呢？
其实，对于MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。
Innodb引擎的表用count(*),count(1)直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但好于具体的count(列名)。问题：能不能使用count(列名)替换count(*)？
不要使用 count(列名)来替代 count() ， count() 是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。
说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6bca94257e14a57fdf429a76fe7ed96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d3219d2ab6dc744f6da5dd8e79e7788/" rel="bookmark">
			12月编程榜新鲜出炉！是谁笑到最后？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		圈内的小伙伴们都知道，TIOBE排行榜是编程语言流行趋势的一个重要指标，这个排行榜可以直观的展示编程语言的市场占比变化，它的评判依据来自于互联网上的程序员、课程、供应商和搜索引擎的数据。
IT技术发展日新月异，作为开发者，只有时刻关注这些前沿变化，才能与时俱进，洞悉未来科技发展风向以及发现更多搞钱机会。
2023年最后一个月，第一名花落谁家？哪些语言脱颖而出？本月TIOBE编程语言排行榜正式发布，让我们一起来看看吧！
TIOBE本月TOP10编程语言
详细榜单可参考官网：https://www.tiobe.com/tiobe-index/
与上个月相比，编程语言Top5没有太多变化，Python依旧最受欢迎，牢牢稳坐榜首。值得一提的是，从2023年1月开始，一直到12月，Python连续一年拿下编程语言TOP1！
在竞争激烈的编程领域，也许没有绝对的“最好”，但是Python能够取得这样的排名，达到这样高的市场占比，足以说明它的强大。
播妞经常听到很多同学说“人生苦短，我用Python”，现在来看，它不仅仅是一句口号，随着Python的急速发展，无论是岗位薪资还是招聘需求，都有了进一步提升。
我相信，在无数程序员心中，Python就是真正的编程语言“王者”！ 编程语言千千万，当你在考虑学习哪种的时候，不妨从榜单中“名列前茅”的语言下手，第一名的Python就是很好的选择！Python具有简单、易学、免费、开源、可移植、可扩展、面向对象等优点。
并且，从事Python开发，可以选择的岗位非常多，比如Python工程师、Python自动化测试、数据工程师、数据挖掘、人工智能等等。
从薪资角度看，根据第三方平台数据，北京Python开发工程师一个月平均23.2K，其中 20K-30K 的占比最多，而人工智能、机器学习、算法等岗位，薪资更是高达 30K 以上。
在黑马，Python+大数据开发也是同学们争相报名的课程之一，黑马第三季度就业报告显示，Python+大数据开发学科平均就业薪资11789元，最高薪资28000元，就业速度屡破纪录。
下面，播妞汇总了一些黑马同学的故事，来看看他们是怎么成功逆袭的吧！
胡同学 ｜薪资15K｜广州校区
从安稳的国企转行至Python，在一些人眼中是大胆的选择，但在学长眼中，只有找到自己真正喜欢的工作，一切都是值得的。很庆幸，通过黑马，胡同学成功上了心中的“岸”，之前月薪6K，现在月薪15K！
→胡同学完整故事戳我查看
黑马项目课程实战
t同学 ｜薪资25K｜北京校区
黑马t同学说，自己虽然是一位极其平凡的中年男人，但却不甘心拿着微薄的工资混日子，都说80后已经被生活磨平了棱角，但t同学选择重新“支棱”起来！从黑马Python毕业后，t同学入职一家月薪15K的公司，后来通过自己的努力，跳槽拿到25K！
→t同学完整故事戳我查看
黑马老师课程辅导
周同学 ｜薪资20K｜北京校区
周同学毕业后一直从事IT行业，但两年来，工作一直没有什么起色，为了跳出舒适圈，找到更高薪的工作，他决定来黑马进修Python课程，系统的提升一下自己的编程技能。
本身编程基础较好，学期期间又很努力，周同学毕业后被大厂抢着要，他说“有几家公司为了留住我，还给我加薪了，这种场景我想都没想过，但真的在我身上发生了！”
→周同学完整故事戳我查看
黑马同学上课场景
看完学长学姐们的就业故事，是不是进一步感受到了Python+大数据开发的魅力？但是你要知道，在来黑马之前他们也是零基础，而帮助他们一步一步成长并最终拿到高薪offer的，就是黑马Python+大数据开发课程！
一位学长真诚地说：学习虽然很痛苦，但取得胜利的时候却一切都值得。所以你要相信，所有的坚持不懈，都会得到岁月的奖赏。
在数字时代，懂Python、懂大数据开发的人才已经越来越吃香，各大城市、各大企业都在高薪争夺相关人才，现在学习，正当时！
如果你也想成为“高薪”中的一员，但不知道自己能不能学Python，参考下方人群对号入座吧！
0基础 → 系统提升
应届生 → 入行、长线发展
转岗 → 快速上手
初级工程师 → 跳槽/升职/涨薪
为了帮助更多学生从入门到就业，成为实力派数据工程师，我们的Python+大数据开发课程经过无数次精雕细琢，科学打磨。
当前已正式推出V4.0版本，我们与阿里云强强联合，采用国内行业领先阿里云大数据平台，对接企业实际大数据开发需求，提升学员就业竞争力。
此外，黑马与FlineBI合作共建大数据BI课程，将FCP认证体系融入课程，增加学生就业宽度，帮助同学们稳扎稳打进阶为高级数据开发工程师！
课程优势一 项目驱动式教学，还原真实职场
黑马对标企业实际招聘需求，依托于黑马大型项目库，覆盖14大行业，涉及18个“大厂级”项目、400+业务指标，包含230+技术点，全流程项目实战还原真实职场，锻炼学生实战能力。
课程优势二 大厂级技术解决方案，搞定难题
黑马的课程覆盖数字化企业转型主流的技术和业务解决方案，专属“技术模板库”能够倍速搞定工作，解决职场常见技术难题，开发不必从0开始，助你更快成为团队核心技术人员。
课程优势三 项目课程启用新模式，助力面试
· 大数据项目阶段采用一套泛电商业务场景，从离线数仓、实时数仓、用户画像、推荐系统到数据治理，完成全套大数据解决方案，助力企业数字化转型。
· 使用同一套业务学习，减轻学生业务学习压力，同时项目采用讲练结合、项目实战融合的方式，让学生真正从听得懂到练得会。
· 课程实施“讲A练B”与“看图说话”新模式，以思路分析为导向提高学生独立开发能力，并推动学生在逻辑思维与语言表达能力方向的持续提升，为学生在面试中以及在企业独立开发中打下坚实的基础。
在数字化浪潮之下，Python已经成为重要的主流编程语言，在大数据、云计算、5G、人工智能等领域前景无限。
很多小伙伴面对个人就业问题，一直处于犹豫和挣扎中，当前工作，食之无味弃之可惜？想升职加薪，却没有出众的技能？成年人抱怨解决不了任何问题，何以解忧，唯有实干！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d3219d2ab6dc744f6da5dd8e79e7788/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07da2db3bbd233364282aabd4f8c6392/" rel="bookmark">
			docker安装rabbitMq
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker安装rabbitMq 拉取 docker pull rabbitmq:3.7.7-management
带有management后缀的版本,代表拥有可视化窗口
部署 #挂载文件目录 home=/home/docker/config/rabbitmq; #rabbitmq 密码 password=123456; #创建文件并赋权 mkdir -p ${home}/data; chmod 777 ${home}/data; docker run -d --privileged --name rabbitmq -p 5672:5672 -p 15672:15672 -v ${home}/data:/var/lib/rabbitmq/mnesia --hostname lotsrabbitmq --restart=always -e RABBITMQ_DEFAULT_VHOST=/ -e RABBITMQ_DEFAULT_USER=root -e RABBITMQ_DEFAULT_PASS=${password} rabbitmq:3.9-management #rabbitmq 密码 ctrl+f5 清空浏览器缓存 hostname 名称RABBITMQ_DEFAULT_VHOST最好为/不然不能远程连接RABBITMQ_DEFAULT_USER 用户名RABBITMQ_DEFAULT_PASS 密码pwd为当前目录的路径 下载对应版本延时插件
https://gitcode.net/mirrors/rabbitmq/rabbitmq-delayed-message-exchange/-/releases
docker cp /home/docker/config/rabbitmq_delayed_message_exchange-3.9.0.ez rabbitmq:/opt/rabbitmq/plugins/
进入容器内 docker exec -it rabbitmq bash
查看插件列表 rabbitmq-plugins list
开启插件支持 rabbitmq-plugins enable rabbitmq_delayed_message_exchange
退出容器 ctrl + p +q
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07da2db3bbd233364282aabd4f8c6392/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c12b299b45ac65fd7b0d909b11e5019f/" rel="bookmark">
			读取dicom序列并存为nii文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import os import glob import nibabel as nib import pydicom import numpy as np #import SimpleITK as sitk # 定义输入和输出文件夹 dicom_folder = "D:/Segment/airway/Chest-anonymization" nifti_folder = "D:/Segment/airway/Chest-anonymization" # 遍历输入文件夹下的所有文件和子文件夹 # 遍历DICOM文件夹中的所有子文件夹 for subdir in os.listdir(dicom_folder): if os.path.isdir(os.path.join(dicom_folder, subdir)): # 获取DICOM文件夹中所有dcm文件的路径 dcm_files = glob.glob(os.path.join(dicom_folder, subdir, "*.dcm")) if len(dcm_files) &gt; 0: # 读取第一个dcm文件获取图像信息 dcm = pydicom.read_file(dcm_files[0]) data = np.zeros((len(dcm_files), dcm.Rows, dcm.Columns)) for i, dcm_file in enumerate(dcm_files): # 读取dcm文件并将像素值存储到numpy数组中 dcm = pydicom.read_file(dcm_file) data[i] = dcm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c12b299b45ac65fd7b0d909b11e5019f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/041e609e1f9807c8801ad91f0410f0f2/" rel="bookmark">
			MySQL InnoDB Replication部署方案与实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 概述 MySQL Innodb ReplicaSet 是 MySQL 团队在 2020 年推出的一款产品，用来帮助用户快速部署和管理主从复制，在数据库层仍然使用的是主从复制技术。
ReplicaSet 主要包含三个组件：MySQL Router、MySQL Server 以及 MySQL Shell 高级客户端。
MySQL Shell 负责管理 ReplicaSet 包括部署、切换、节点加入等，都可以通过内置 AdminAPI 自动化完成。
MySQL Router 是一款轻量级中间件，可在应用程序和 ReplicaSet 之间提供透明路由和读写分离功能。
2. 适用场景 InnoDB ReplicaSet至少由两台MySQL服务器实例组成，提供MySQL主从复制功能。InnoDB ReplicaSet基于异步的主从复制实现，因此适用于用户对高可用性要求不高的环境。可以通过MySQL Shell快速搭建及管理主从复制，避免了搭建主从复制时大量的手动操作。
InnoDB ReplicaSet的不足之处有：
不支持自动故障转移。主库不可用时，需要通过AdminAPI手动发起故障转移。
发生计划外的服务不可用时，可能会丢失部分数据。由于主备之间是异步复制，主库发生故障时，未提交的事务会丢失。
发生计划外的服务不可用时，可能会产生数据不一致。例如由于网络原因导致主库连不上，将备库提升为主库后，可能会同时存在两个主库，即发生“脑裂”。
不支持多主模式，即同一时刻只有一个主库可写。
读扩展受限，不能像组复制那样对流量进行控制。
所有的备库都从同一个主库复制数据。在有大量的小更新时，可能会对主库造成影响。
仅支持MySQL 8.0及其以后的版本。
仅支持基于GTID的日志复制。
仅支持基于行的日志复制（Row-Based Replication, RBR），不支持基于SQL语句的复制（Statement-Based Replication, SBR）。
不支持复制过滤。
RS为一个主库加多个从库的架构。需要通过MySQL Router监视RS中的实例，因此从库的数量不能无限制增加。
必须通过MySQL Shell配置和管理，包括复制用户的创建。
3. 安装部署 IProlehostname版本OS192.168.10.31Mastermysql-rs-1MySQL 8.2Centos_7.9_x86_x64192.168.10.32Secondarymysql-rs-2MySQL 8.2Centos_7.9_x86_x64 3.1. 安装MySQL servers 分别在两个MySQL服务器下载MySQL Server安装包，并进行安装。
# 配置主机名 echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/041e609e1f9807c8801ad91f0410f0f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/105a55132e5efe98c1b8d7dd176a4567/" rel="bookmark">
			@Autowired 找不到Bean的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 排查思路 检查包扫描：查询的Bean是否被spring扫描装配到检查该Bean上是否配上注解（@Service/Component/Repository…）如果使用第三方，检查相关依赖是否已经安装到当前项目 @Autowired和@Resource的区别 @Autowired 是spring提供的注解默认是按类型进行装配。如果要允许null值，可以设置它的required属性为false。如果想使用名称装配可以结合@Qualifier注解进行使用。 @Resource 是J2EE提供的注解（JDK1.6以上支持）默认是按名字进行装配 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f32b54f1ed19f73b769db20a5f376ddd/" rel="bookmark">
			svn: E170013: Unable to connect to a repository at URL ‘‘ svn: E230001: Server SSL certificate
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体错误提示信息如下： svn: E170013: Unable to connect to a repository at URL ‘https://127.0.0.1/svn/xxxx/trunk’ svn: E230001: Server SSL certificate verification failed: certificate issued for a different hostname, issuer is not trusted
意思是服务器的SSL证书验证失败，证书为不同主机名颁发。
解决方法：打开CMD并执行如下命令
svn ls https://ip/svn/xxxx 将ip替换为你要访问的svn仓库的ip,将xxxx替换为项目目录地址 然后会让你选择R（拒绝）、t（暂时接受）、或者p（永久接受）
我们输入p后按回车，会提示输入当前电脑用户的密码，然后提示输入svn的账号密码，按着提示操作就行
都输入完成后，回车就可以解决了
由于正确的路径没有任何记录，故用错误演示来记录，大概意思是一样的，便于各位进行查看
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a67124f70554804e01c57c6586de285/" rel="bookmark">
			pict安装以及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 实践证明及研究发现，大约70％的软件故障是由一个或两个参数共同作用引起的。所以组合测试，尤其是两两组合测试，在实际工程的软件测试中被公认为是一种非常有效的测试方法。
而PICT是 Microsoft 内部使用一款测试用例设计工具。PICT可以有效的按照两两测试的原理来创建和设计测试用例，以获得参数的全面组合覆盖。
二、下载 1、 下载pict：https://files.cnblogs.com/files/kikyoqiang/pict.zip
2、以管理员身份启动cmd，进入pict的安装目录，输入命令 PICT测试是否安装成功
（更多的参考网上相关教程，也可尝试在线服务Pairwise Pict Online，但是功能受限）
三、PICT工具的简单使用
（1）首先需要准备一个测试配置文件，如下图所示的一个txt文件，该文件测试有五个参数。
同时将这个txt文件放在pict.exe的同级目录下 ！！！注意文件中的标点符号（冒号和逗号）均为英文； （3）使用cmd命令进入到test.txt文件所在的目录处；
如下载在D盘
打开cmd后命令如下
（4）使用命令：PICT test.txt，即可得到两两组合测试用例集
（5）也可以将输出重定向为另一个txt文件：PICT test.txt&gt;test.txt 或者 将输出重定向为另一个xlsx文件PICT test.txt&gt;test.xlsx，在同级目录下生产的test.txt文件或者test.xlsx文件存放测试用例。
四、可能遇见的问题 中文乱码解决方案：将test.txt另存为ANSI版本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87ae29275b1094e8cec5b26cd0a9840e/" rel="bookmark">
			STM32 使用DMA进行串口发送和接收
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32 使用DMA进行串口发送和接收 本文主要介绍
通过UART和DMA进行数据接收，支持不定字节数的数据
本文的应用程序指这两个主题的STM32实现代码（标准库）
目录 文章目录 STM32 使用DMA进行串口发送和接收目录缩写UART基本介绍空闲线路（Idle Line）事件和接收器超时（Receiver Timeout）事件DMA基本介绍结合UART和DMA进行数据接收结合UART和DMA进行数据发送RX下，DMA HT/TC 和 UART IDLE 组合起来的细节中断优先级至关重要 示例代码下载 缩写 DMA：STM32 中的直接内存访问控制器UART：通用异步接收器和发送器USART：通用同步异步接收发送器TX：发送RX：接收HT：半传输完成 DMA 事件/标志TC：传输完成 DMA 事件/标志RTO：接收器超时 UART 事件/标志IRQ：中断 UART基本介绍 STM32拥有USART、UART、或LPUART等外设。他们之间的差异跟本文章的目的并不重要，简而言之，USART支持在异步（UART）基础上的同步操作，而LPUART支持在STOP模式下的低功耗操作。当不使用同步模式或低功耗模式时，USART、UART和LPUART可以被视为相同的。
在本文章中，我将仅使用术语UART
STM32中的UART可以通过配置选择不同的发送（TX）和接收（RX）模式：
轮询模式（无DMA，无IRQ）
P：轮询状态位，以检查是否已传输/接收任何字符，并快速读取，以便不漏掉任何字节P：易于实现，只需几行代码C：在复杂应用程序中，如果CPU无法快速读取寄存器，则很容易会遗漏数据C：仅适用于低波特率（&lt;= 9600） 中断模式
P：UART触发中断，CPU跳转到服务例程以单独处理每个接收到的字节P：嵌入式应用中常用的方法P：与常见波特率良好配合，115200，最高可达~921600C：中断服务例程针对每个接收到的字符都会执行C：如果为高速波特率触发每个字符的中断，可能会降低系统性能 DMA模式
DMA用于在硬件级别将数据从USART RX数据寄存器传输到用户内存。此时不需要应用程序交互，除非需要时由应用程序处理接收到的数据P：从USART外设到内存的传输在硬件级别上完成，无需CPU交互P：可以很容易的与操作系统配合使用P：针对最高波特率 &gt; 1Mbps 和低功耗应用进行了优化P：在大量数据突发的情况下，增加数据缓冲区大小可以改善功能C：DMA硬件必须事先知道要传输的字节数C：如果通信失败，DMA可能无法及时或完整地将已传输的字节信息通知给应用程序 这篇文章只关注RX操作的DMA模式，并解释如何处理未知数据长度
所有STM32都至少有一个（1）UART IP和至少一个（1）DMA控制器。这是本文所需的全部。
实现TX的操作非常的直截了当（设置指向数据的指针，定义其长度……），但对于接收并非如此。在实现DMA接收时，应用程序需要知道在被视为 完成 [^1]之前DMA必须处理的接收字节数。然而UART协议不提供这样的信息（它可以与更高级别的协议一起工作，本文章不涉及。我们假设我们必须实现非常可靠的低级通信协议）。
空闲线路（Idle Line）事件和接收器超时（Receiver Timeout）事件 STM32的UART具有检测RX线在一段时间内未活动的能力。这是通过两种方法实现的：
Idle Line事件： 当RX线在最后接收字节后处于空闲状态[^2]1帧时间时触发。帧时间基于波特率。更高的波特率意味着单字节的帧时间更短。
RTO（Receiver Timeout）事件：当线路在可编程时间内处于空闲状态时触发，完全由固件配置。
这两个事件都可以触发中断，这是确保有效的接收操作的一项重要功能。
并非所有 STM32 都具有 IDLE LINE 或 RTO 功能。 如果不可用，则可能不会使用有关这些功能的示例。
一个例子：以115200波特率传输1 byte，大约需要~100us；对于3 bytes，总共约为~300us。当接收到第三个字节后，线路进入空闲状态，空闲状态达到 1 帧时间（在本例中为 100us）时，空闲线路（Idle Line）事件会触发中断。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87ae29275b1094e8cec5b26cd0a9840e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/21/">«</a>
	<span class="pagination__item pagination__item--current">22/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/23/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>