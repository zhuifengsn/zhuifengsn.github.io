<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b30e225905155321812d4c375153f0a7/" rel="bookmark">
			【web系列十六】idea下使用Maven搭建spring boot开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
安装软件
idea
maven
配置环境变量
配置环境
maven
添加本地仓库路径
添加国内镜像源
常用maven命令
idea
创建工程
新建工程
继承Spring Boot父工程
添加Web场景依赖
添加主程序
添加Controller
添加配置文件
运行服务 常见问题
Inspects a Maven model for resolution problems
第一种：
第二种：
第三种：
参考资料
安装软件 idea 直接前往官网下载安装即可。
IntelliJ IDEA：JetBrains 功能强大、符合人体工程学的 Java IDE
maven 直接前往官网下载安装。
Maven – Download Apache Maven
配置环境变量 在环境变量中添加MAVEN_HOME环境变量，在该目录下有conf等文件夹
在系统变量中的path中添加路径
配置完成后可以在命令窗口中输入 mvn -v 进行检测，显示下图则表示成功
配置环境 maven 打开maven安装目录下的conf\setting.xml文件。
添加本地仓库路径 该路径可以是任意位置，用于存放下载的依赖。
添加国内镜像源 这样下载jar包速度很快。默认的中央仓库有时候甚至连接不通。一般使用阿里云镜像库即可。
&lt;mirrors&gt; &lt;!--阿里云公共仓库是central仓和jcenter仓的聚合仓--&gt; &lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;阿里云公共仓库&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;阿里云谷歌仓库&lt;/name&gt; &lt;url&gt;https://maven.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b30e225905155321812d4c375153f0a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/965fa8ad82088d173ed507ef7e7777f0/" rel="bookmark">
			城市公交车交通分析【python爬虫/R语言绘图】【2】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		r语言绘图结果展示 在分析交通上本文分别绘制了柱状图，条形图，线路图，热力密度图；对应的r语言代码在后面。
r语言代码以及对应数据 柱状图 library(ggplot2) library(xlsx) data1 &lt;- read.xlsx("D:/curriculums/vis/production/car_info.xls",sheetIndex = 1,header = T) ggplot(data1,aes(reorder(市别,线路长度比条数),线路长度比条数))+ geom_bar(stat="identity", position=position_dodge(), color="black", width=.8, fill="lightblue")+ geom_hline(aes(yintercept = 21.29862,colour="均线"), size = 1)+ annotate('text',x=1,y=22,label="21.3", size=4,color='red')+ labs(title = "广东省公交线路信息", # 定义主标题 subtitle = "长度和条数之比", # 定义子标题 x = "城市", # 定义x轴文本 y = "线路长度/线路条数")+# 定义y轴文本 theme(legend.title = element_blank(), legend.background = element_blank(), legend.position = c(0.08,0.9),#位置 plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5)) 折线图 library(xlsx) library(ggplot2) data &lt;- read.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/965fa8ad82088d173ed507ef7e7777f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0eb60ba328a7afbad3697327a7fb3a5d/" rel="bookmark">
			【Python】强化学习：原理与Python实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搞懂大模型的智能基因，RLHF系统设计关键问答
RLHF（Reinforcement Learning with Human Feedback，人类反馈强化学习）虽是热门概念，并非包治百病的万用仙丹。本问答探讨RLHF的适用范围、优缺点和可能遇到的问题，供RLHF系统设计者参考。
📕作者简介：热爱跑步的恒川，致力于C/C++、Java、Python等多编程语言，热爱跑步，喜爱音乐的一位博主。
📗本文收录于恒川的日常汇报系列，大家有兴趣的可以看一看
📘相关专栏C语言初阶、C语言进阶系列、恒川等，大家有兴趣的可以看一看
📙Python零基础入门系列，Java入门篇系列、docker技术篇系列、Apollo的学习录系列正在发展中，喜欢Python、Java、docker的朋友们可以关注一下哦！
原理与Python实战 1. RLHF是什么？2. RLHF适用于哪些任务？3. RLHF和其他构建奖励模型的方法相比有何优劣？4. 什么样的人类反馈才是好的反馈5. RLHF算法有哪些类别，各有什么优缺点？6. RLHF采用人类反馈会带来哪些局限？6.1 提供人类反馈的人群可能有偏见或局限性。6.2 人的决策可能没有机器决策那么高明。6.3 没有将提供反馈的人的特征引入到系统。6.4 人性可能导致数据集不完美。 7. 如何降低人类反馈带来的负面影响？ 1. RLHF是什么？ 强化学习利用奖励信号训练智能体。有些任务并没有自带能给出奖励信号的环境，也没有现成的生成奖励信号的方法。为此，可以搭建奖励模型来提供奖励信号。在搭建奖励模型时，可以用数据驱动的机器学习方法来训练奖励模型，并且由人类提供数据。我们把这样的利用人类提供的反馈数据来训练奖励模型以用于强化学习的系统称为人类反馈强化学习，示意图如下。
图： 人类反馈强化学习：用人类反馈的数据训练奖励模型，用奖励模型生成奖励信号
2. RLHF适用于哪些任务？ RLHF适合于同时满足下面所有条件的任务：
要解决的任务是一个强化学习任务，但是没有现成的奖励信号并且奖励信号的确定方式事先不知道。为了训练强化学习智能体，考虑构建奖励模型来得到奖励信号。
反例：比如电动游戏有游戏得分，那样的游戏程序能够给奖励信号，那我们直接用游戏程序反馈即可，不需要人类反馈。
反例：某些系统奖励信号的确定方式是已知的，比如交易系统的奖励信号可以由赚到的钱完全确定。这时直接可以用已知的数学表达式确定奖励信号，不需要人工反馈。
不采用人类反馈的数据难以构建合适的奖励模型，而且人类的反馈可以帮助得到合适的奖励模型，并且人类来提供反馈可以在合理的代价（包括成本代价、时间代价等）内得到。如果用人类反馈得到数据与其他方法采集得到数据相比不具有优势，那么就没有必要让人类来反馈。
3. RLHF和其他构建奖励模型的方法相比有何优劣？ 奖励模型可以人工指定，也可以通过有监督模型、逆强化学习等机器学习方法来学习。RLHF使用机器学习方法学习奖励模型，并且在学习过程中采用人类给出的反馈。
比较人工指定奖励模型与采用机器学习方法学习奖励模型的优劣：这与对一般的机器学习优劣的讨论相同。机器学习方法的优点包括不需要太多领域知识、能够处理非常复杂的问题、能够处理快速大量的高维数据、能够随着数据增大提升精度等等。机器学习算法的缺陷包括其训练和使用需要数据时间空间电力等资源、模型和输出的解释型可能不好、模型可能有缺陷、覆盖范围不够或是被攻击（比如大模型里的提示词注入）。
比较采用人工反馈数据和采用非人工反馈数据的优劣：人工反馈往往更费时费力，并且不同人在不同时候的表现可能不一致，并且人还会有意无意地犯错，或是人类反馈的结果还不如用其他方法生成数据来的有效，等等。我们在后文会详细探讨人工反馈的局限性。采用机器收集数据等非人工反馈数据则对收集的数据类型有局限性。有些数据只能靠人类收集，或是用机器难以收集。这样的数据包括是主观的、人文的数据（比如判断艺术作品的艺术性），或是某些机器还做不了的事情（比如玩一个AI暂时还不如人类的游戏）。
4. 什么样的人类反馈才是好的反馈 好的反馈需要够用：反馈数据可以用来学成奖励模型，并且数据足够正确、量足够大、覆盖足够全面，使得奖励模型足够好，进而在后续的强化学习中得到令人满意的智能体。
这个部分涉及的评价指标包括：对数据本身的评价指标（正确性、数据量、覆盖率、一致性），对奖励模型及其训练过程的评价指标、对强化学习训练过程和训练得到的智能体的评价指标。
好的反馈需要是可得的反馈。反馈需要可以在合理的时间花费和金钱花费的情况下得到，并且在成本可控的同时不会引发其他风险（如法律上的风险）。
涉及的评价指标包括：数据准备时间、数据准备涉及的人员数量、数据准备成本、是否引发其他风险的判断。
5. RLHF算法有哪些类别，各有什么优缺点？ RLHF算法有以下两大类：用监督学习的思路训练奖励模型的RLHF、用逆强化学习的思路训练奖励模型的RLHF。
在用监督学习的思路训练奖励模型的RLHF系统中，人类的反馈是奖励信号或是奖励信号的衍生量（如奖励信号的排序）。
直接反馈奖励信号和反馈奖励信号衍生量各有优缺点。这个优点在于获得奖励参考值后可以直接把它用作有监督学习的标签。缺点在于不同人在不同时候给出的奖励信号可能不一致，甚至矛盾。反馈奖励信号的衍生量，比如奖励模型输入的比较或排序。有些任务给出评价一致的奖励值有困难，但是比较大小容易得多。但是没有密集程度的信息。在大量类似情况导致某部分奖励对应的样本过于密集的情况下，甚至可能不收敛。
一般认为，采用比较类型的反馈可以得到更好的性能中位数，但是并不能得到更好的性能平均值。
在用逆强化学习的思路训练奖励模型的RLHF系统中，人类的反馈并不是奖励信号，而是使得奖励更大的奖励模型输入。即人类给出了较为正确的数量、文本、分类、物理动作等，告诉奖励模型在这时候奖励应该比较大。这其实就是逆强化学习的思想。
这种方法与用监督学习训练奖励模型的RLHF相比，其优点在于，训练奖励模型的样本点不再拘泥于系统给出的需要评判的样本。因为系统给出的需要评估奖励的样本可能具有局限性（因为系统没有找到最优的区间）。
在系统搭建初期，还可以将用户提供的参考答案用于把最初的强化学习问题转化成模仿学习问题。
这类设计还可以根据反馈的类型进一步分类，一类是让人类独立给出专家意见，另一类是在让人类在已有数据的基础上进行改进。让人类提供意见就类似于让人类提供模仿学习里的专家策略（当然可能略有不同，毕竟奖励模型的输入不只有动作）。让用户在已有的参考内容上修改可以减少人类每个标注的成本，但是已有的参考内容可能会干扰到人类的独立判断（这个干扰可能是正面的也可能是负面的）。
6. RLHF采用人类反馈会带来哪些局限？ 前面已经提到，人类反馈可能更费时费力，并且不一定能够保证准确性和一致性。除此之外，下面几点会导致奖励模型不完整不正确，导致后续强化学习训练得到的智能体行为不能令人满意。
6.1 提供人类反馈的人群可能有偏见或局限性。 这个问题和数理统计里的对样本进行抽样方法可能遇到的问题类型。为RLHF系统提供反馈的人群可能并不是最佳的人群。有的时候出于成本、可得性等因素，会选择人力成本低的团队，但是这样的团队可能在专业度不够，或是有着不同的法律、道德和宗教观念，包括歧视性信息。反馈人中可能有恶意者，会提供有误导性的反馈。
6.2 人的决策可能没有机器决策那么高明。 在一些问题上，机器可以比人做的更好，比如对于象棋围棋等棋盘游戏，真人就比不过人工智能程序。在一些问题上，人能够处理的信息没有数据驱动的程序处理的信息全面。比如对于自动驾驶的应用，人类只能根据二维画面和声音进行决策，而程序能够处理连续时间内三维空间的信息。所以在理论上人类反馈的质量是不如程序的。
6.3 没有将提供反馈的人的特征引入到系统。 每个人都是独一无二的：每个人有自己的成长环境、宗教信仰、道德观念、学习和工作经历、知识储备等，我们不可能把每个人的所有特征都引入到系统。在这种情况下，如果忽略不同的人之间在某个特征维度上的差别，那么就会损失到许多有效信息，导致奖励模型性能下降。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0eb60ba328a7afbad3697327a7fb3a5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c79d21ec30b6404f516db5f432ef791a/" rel="bookmark">
			除了SmartGit，还有哪些Git客户端工具推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多用户使用SmartGit作为自己的Git客户端，其实除了这个，还有一些非常不错、大家也在使用的Git客户端工具。
Git客户端是一种用于管理和协作开发的版本控制系统。它允许多个开发者在同一项目上进行并行开发，并跟踪每个开发者所做的更改。Git客户端提供了一个图形化界面，使用户可以更轻松地使用Git命令和功能。
通过Git客户端，用户可以创建新的代码库（repository），将代码添加到代码库中，查看和比较不同版本的代码，合并不同分支的代码，撤销更改，提交代码等操作。Git客户端还提供了可视化的工具，如分支图、历史记录查看器等，帮助用户更好地理解和管理代码的变动。
一些流行的Git客户端包括GitHub Desktop、GitKraken、SourceTree等，它们都提供了直观友好的界面和丰富的功能，使开发者能够更高效地使用Git进行版本控制和团队协作。
GitHub Desktop for Mac(Github官方桌面客户端)
GitHub Desktop 是 GitHub 官方推出的桌面端应用程序，可以帮助开发者更加便捷地管理自己的代码仓库。 GitHub Desktop 的特点主要包括以下几个方面： 可视化操作：GitHub Desktop 提供了图形界面，使得开发者不需要通过命令行操作即可完成常用的 Git 操作，例如提交代码、拉取代码、创建分支等。 平台支持：GitHub Desktop 支持 Windows 和 Mac 两个平台，可以满足大多数开发者的需求。 版本控制：GitHub Desktop 集成了 Git 的版本控制功能，可以让开发者更加方便地进行版本管理和协作。 代码审查：GitHub Desktop 可以方便地进行代码审查，开发者可以轻松地查看代码变更、提交评论和回复评论等操作。 多账户管理：GitHub Desktop 支持多个 GitHub 账户的管理，可以帮助开发者更好地管理自己的代码。
SourceTree for Mac(Git客户端工具)
SourceTree Mac是一款针对mac平台研发并推出的Git 和 Hg 客户端管理工具，拥有创建、克隆、提交、push、pull和合并等常见的基本操作，完全支持DVCS,并且简化了你与Git和Hg库的交互方式，可以通过直观、简洁、干净、友好的客户端更好的管理本地和远程的代码仓库，同时通过SourceTree美观的界面，你可以放弃命令行的开发编辑操作，实现开发者与代码库之间的分布式协同开发方式。
GitKraken for Mac(强大的Git客户端)
GitKraken是一款强大的Git客户端，可以帮助开发者更轻松地管理和协作Git仓库。 直观易用的界面：GitKraken的界面非常直观，使用起来非常容易上手。您可以通过拖放操作来完成Git操作，或者使用快捷键来更快地完成任务。 支持多种Git仓库：无论您是使用GitHub、GitLab还是Bitbucket等Git托管服务，GitKraken都可以轻松地与它们集成。 强大的团队协作功能：GitKraken支持多人协作，您可以轻松地共享代码、协作开发，以及管理团队的Git仓库。 可视化的Git工作流：GitKraken可以帮助您更好地理解Git工作流程，以及在Git仓库中进行分支和合并操作。 内置的代码编辑器：GitKraken内置了一个代码编辑器，支持多种语言，可以让您轻松地编写和编辑代码。
Tower for Mac(强大的Git客户端)
Tower是OS X的强大Git客户端，可以轻松，高效地使用Git。用户可以从其优雅而全面的界面和功能集中受益，让他们享受Git的全部功能。用tower学习Git。Tower在一个易于使用的界面中抽象出Git的复杂性。例如，可以通过拖放简单地执行许多操作，并且可以轻松地撤消错误。使用Tower作为专家。高级用户可以通过单行分段，子模块支持或文件历史记录等功能提高工作效率。
Fork for Mac(Git客户端)
Fork是一款适用于Mac和Windows平台的Git客户端，它提供了一系列强大的功能，包括分支管理、代码比较、合并和冲突解决等。 以下是Fork的一些特点和优点： 直观的用户界面：Fork具有直观的用户界面和简单易用的操作，可以帮助用户快速地学习和使用Git。 分支管理：该软件提供了强大的分支管理功能，可以帮助用户创建、合并、删除和重命名分支等操作。 代码比较：Fork支持代码比较功能，可以帮助用户轻松地比较代码差异，以便更好地进行代码审查和合并。 冲突解决：该软件还支持冲突解决功能，可以帮助用户更好地解决代码冲突问题。 快速的性能：Fork具有快速的性能和低系统资源占用，可以帮助用户更加高效地进行Git操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c79d21ec30b6404f516db5f432ef791a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ce5528312c76d674ae6379b179ab712/" rel="bookmark">
			【计算机图形学/Unity游戏开发】判断圆与矩形是否相交（SC-102-L06课后习题 2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视频链接：【银鸟工作室课程】SC-102 Unity游戏开发 I 第六课：程序化物理
SC-102 第六课：程序化物理 课后习题 2 题目：编写一个判断圆与矩形是否相交的函数。
首先将问题拆解简化为：圆与矩形的四条边是否相交。显然，若至少存在一条与圆相交的边，则该矩形也相交。特别地，若四条边都不相交，此时有可能是矩形完全包含圆，需要特别判断。
接下来，从理论上分析如何判断圆与线段是否相交（默认已知：线段端点和圆心坐标、圆半径）。
线段所在直线与圆心的距离大于半径。【相离】
两点式直线方程： x − x 1 x 1 − x 2 = y − y 1 y 1 − y 2 \frac{x-x_1}{x_1-x_2}=\frac{y-y_1}{y_1-y_2} x1​−x2​x−x1​​=y1​−y2​y−y1​​，转换为一般直线方程（ y = k x + b y=kx+b y=kx+b）：
Y a b = y 1 − y 2 x 1 − x 2 x + x 1 y 2 − x 2 y 1 x 1 − x 2 Y_{ab}=\frac{y_1-y_2}{x_1-x_2}x+\frac{x_1y_2-x_2y_1}{x_1-x_2} Yab​=x1​−x2​y1​−y2​​x+x1​−x2​x1​y2​−x2​y1​​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ce5528312c76d674ae6379b179ab712/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1fe4828213bb545f8e87373f8c55d45/" rel="bookmark">
			Selenium webdriver_manager根据浏览器版本自动下载对应驱动程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 webdriver_manager是什么？ webdriver_manager 是 Python 中的一个库，用于管理 Web 驱动程序。它的作用是自动下载和设置不同浏览器（如 Chrome、Firefox、Edge 等）的 Web 驱动程序，以便在自动化测试中使用这些浏览器。
在进行 Selenium 测试时，需要一个与浏览器相匹配的 Web 驱动程序，以便控制和操作浏览器。webdriver_manager 为您提供了一种简便的方式，可以自动检测所需浏览器的版本并下载相应的 Web 驱动程序。这样，您就不需要手动下载和设置 Web 驱动程序，可以减轻您的负担，提高测试的可靠性和可维护性。
一、导入模块 pip install webdriver_manager pip install Selenium 二、Chrome用法 # Selenium4.0以下版本使用该方法 from selenium import webdriver from webdriver_manager.chrome import ChromeDriverManager # 使用 ChromeDriverManager 安装 ChromeDriver，并返回驱动程序的路径 driver_path = ChromeDriverManager().install() # 打印驱动程序路径 print(driver_path) # 创建 Chrome WebDriver，并指定驱动路径 driver = webdriver.Chrome(executable_path=driver_path) # 打开百度网页 driver.get("https://www.baidu.com") # Selenium4.0以上版本使用该方法 from selenium import webdriver from selenium.webdriver.chrome.service import Service from webdriver_manager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1fe4828213bb545f8e87373f8c55d45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21be3d4984a4bca202f90b7366e1a56b/" rel="bookmark">
			nfs挂载根文件系统失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 nfs挂载根文件系统失败 问题一：挂载前，需要得知nfs使用的版本 确认host端的nfs支持的版本，使用命令nfsstat -v查看
原因：
​ 以前使用的16.04版本的ubuntu没问题，现在更换了18.04版本，开始报错。从Ubuntu17.04开始，nfs默认只支持协议3和协议4，而kernel中默认支持协议2。
如何查看板子kernel支持的协议：
​ 可以通过编译内核配置查看
​ File systems —&gt;
​ Network File Systems —&gt;
这里可以看到板子作为客户端，支持2、3、4版本，默认支持协议2。
1. 如果kernel只支持协议2 修改 NFS 配置文件： sudo vim /etc/default/nfs-kernel-server 在末尾添加： RPCNFSDOPTS="--nfs-version 2,3,4 --debug --syslog" 重启NFS服务： sudo /etc/init.d/nfs-kernel-server restart 2. kernel版本较高支持协议3 可以修改u-boot的bootargs，例如：
setenv bootargs root=/dev/nfs rw nfsroot=192.168.9.119:/nfs/rootfs,v3 console=ttyS0,115200 init=/linuxrc ip=192.168.9.110 添加一个v3或者nfsvers=3
问题二：Ubuntu22.04使用上述bootargs不能成功使用NFS挂载 问题就出在ubuntu 22.04默认关闭了nfs的udp端口连接
而kernel默认使用的是udp连接
方法一： 添加一个参数，使用tcp挂载：
setenv bootargs root=/dev/nfs rw nfsroot=192.168.9.119:/nfs/rootfs,v3,tcp console=ttyS0,115200 init=/linuxrc ip=192.168.9.110 方法二： 添加/etc/nfs.conf.d/udp.conf文件，启动主机的udp连接：
[nfsd] udp=n 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6ba62d0c9714dde9b690e26977e42d7/" rel="bookmark">
			PCL点云——滤波算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PCL点云——滤波算法 文章目录 PCL点云——滤波算法@[TOC] 0、点云滤波概述0.1 Why0.2 How 一、直通滤波PassThrough1.1 原理1.3 PCL类1.3 例子1.3.1 Z轴1.3.2 Z、X轴（多维度直通滤波） 二、VoxelGrid (降采样)2.1 原理2.2 PCL例程2.2.1 pcl:VoxelGrid 方法2.2.2 pcl:ApproximateVoxelGrid 方法2.2.3 显示点云函数2.2.4 pcl:VoxelGrid完整示例2.2.5 出现的问题及解决办法 三、离群点移除3.1 概述3.1.1 Why3.1.2 How 3.2 实现方式3.2.1 StatisticalOutlierRemoval（统计学离群点移除过滤器）3.2.2 ConditionalRemoval 条件滤波 &amp; RadiusOutlierRemoval 半径离群值滤波3.2.3 双边滤波 点云滤波器继承关系参考文章链接 0、点云滤波概述 0.1 Why 在获取点云数据时，由于设备精度、操作者经验、环境因素等带来的影响，以及电磁波衍射特性、被测物体表面性质变化和数据拼接配准操作过程的影响，点云数据中将不可避免地出现一些噪声点。实际应用中除了这些测量随机误差产生的噪声点之外，由于受到外界干扰如视线遮挡、障碍物等因素的影响，点云数据中往往存在着一些离主体点云较远的离散点，即离群点。不同的获取设备点云噪声结构也有不同。
点云滤波针对的情形：
1.下采样，数据量过大，不易于处理
2.离群点，通常由遮挡引起
3.点云数据的密度不均匀，需要平滑
4.噪声数据
0.2 How 下图显示了一个噪声消除的示例。 由于测量误差，某些数据集会出现大量阴影点。 这使局部点云3D特征的估算变得复杂。通常通过对每个点的邻域进行统计分析，并修剪掉不符合特定条件的那些异常值，进而可以过滤掉某些异常值。
PCL中实现这些稀疏离群值的消除，需要计算数据集中的点与邻居距离的分布。 即对于每个点，都会计算从它到所有相邻点的平均距离。 通过假设结果分布是具有均值和标准差的高斯分布，可以将那些平均距离在**【由全局距离均值和标准差定义的区间】**之外的所有点视为离群值，并将之从数据集中进行修剪。
一、直通滤波PassThrough 1.1 原理 过滤掉在指定维度方向上取值不在给定值域内的点。
首先，指定一个维度以及该维度下的值域，其次，遍历点云中的每个点，判断该点在指定维度上的取值是否在值域内，删除取值不在值域内的点，最后，遍历结束，留下的点即构成滤波后的点云。直通滤波器简单高效，适用于消除背景等操作。
1.3 PCL类 class pcl: : PassThrough&lt; PointT &gt; 类 PassThrough 实现对用户给定点云某个字段的限定下，对点云进行简单的基本过滤，例如限制过滤掉点云中所有 X 字段不在某个范围内的点，该类的使用比较灵活但完全取决于用户的限定字段和对应条件 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6ba62d0c9714dde9b690e26977e42d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/091f089e0545a66893be9be4fcaeda98/" rel="bookmark">
			玩转 JS 逆向：RPC 加持，爬虫效率飙升
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是安果！
一些复杂的网站针对参数是层层加密，如果选择硬刚，去扣代码、补环境，耗时耗力的同时，不一定能获取完整的加密逻辑
在 JS 逆向中，我们可以通过 RPC 通信，直接调用浏览器的方法生成加密参数，这样可以省去扣代码的时间
本篇文章将介绍 Sekiro RPC 进行 JS 逆向的完整流程
目标网站：
aHR0cHM6Ly93d3cueGluZ3R1LmNuL3N1cC9jcmVhdG9yL2hvdA==
具体操作步骤如下：
1、Sekiro RPC
Sekiro 是一个多语言的、分布式网络拓扑无关的服务发布平台
它能基于长连接和代码注入 API 服务暴露的框架，可用于逆向（包含 JS 逆向和 App 逆向）
官网：
https://sekiro.iinti.cn/sekiro-doc/
2、分析网站
打开目标网站，发现接口 /h/api/gateway/handler_get 中的查询参数 sign 是加密的
在 Sources - Page 面板下，通过关键字 sign: 全局查询
发现加密参数生成的具体逻辑如下：
PS：通过方法 generatePayload 生成 sign，其中 c、l 为参数
文件位置：
https://*/obj/goofy/star/idou_fe/assets/vendor-a1b40867.js
然后，在方法 generatePayload 方法内添加条件断点
这样，通过多次 Debugger 分析，可以得出参数的生成规则（即：参数固定值、参数生成逻辑）
//条件监听 //条件：c.service_name==='author.AdStarAuthorService' 这样，在调试模式下，我们可以在浏览器控制台进行测试了
如下，直接调用方法可以拿到加密后的参数
3、加密文件重写 Overrides
在本地新建一个文件夹，Sources - Overrides 关联该本地目录
PS：开启 Overrides 并授予权限
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/091f089e0545a66893be9be4fcaeda98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f565a7a697679c3caa6872bcfa617b76/" rel="bookmark">
			【51单片机篇】LCD1602显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、初识LCD1602 1.LCD1602是一种工业字符型液晶，能够同时显示 16×02 即 32 字符(16列两行)。
2.引脚说明
二、显示逻辑 1.搞明白在哪里显示（地址）？显示什么（内容）？
在哪里显示 显示什么 三、时序分析 1.写操作时序
（1）RS=1:写内容；RS=0:写地址;
（2） RW = 0：写操作;
（3）E：从低电平上升到高电平（这个过程中延时25ns）,然后高电平持续150ns，最后从高电平下降到低电平（这个过程中延时25ns），延时时间可以用_nop_()函数代替。
2.读操作时序
（1）RS：通过指令9可知，RS=0;
（2）RW=1:读操作;
（3）E:从低电平上升到高电平（这个过程中延时25ns）,然后高电平持续150ns，最后从高电平下降到低电平（这个过程中延时25ns），延时时间可以用_nop_()函数代替。
四、代码示例 1.编程实现LCD1602显示字符'C'
#include "reg52.h" #include &lt;intrins.h&gt; #define databuffer P0//定义8位数据线，P0端口组 sbit RS = P1^0; sbit RW = P1^1; sbit EN = P1^4; void Check_Busy() { char tmp = 0x80; databuffer = 0x80; while(tmp &amp; 0x80){//比较最高位 RS = 0; RW = 1; EN = 0; _nop_(); EN = 1; _nop_(); _nop_(); tmp = databuffer; EN = 0; _nop_(); } } void Write_Cmd_Func(char cmd)//写指令，RS低电平 { Check_Busy(); RS = 0; RW = 0; EN = 0; _nop_();//空函数，延时1us databuffer = cmd; _nop_(); EN = 1; _nop_(); _nop_(); EN = 0; _nop_(); } void Write_Data_Func(char cmd)//写数据，RS高电平 { Check_Busy(); RS = 1; RW = 0; EN = 0; _nop_();//空函数，延时1us databuffer = cmd; _nop_(); EN = 1; _nop_(); _nop_(); EN = 0; _nop_(); } void Delay15ms()	//@11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f565a7a697679c3caa6872bcfa617b76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17417f2c515ace4ad371594049419b21/" rel="bookmark">
			《VM虚拟机网线已拔出解决方案》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9af9b31e91d71d5a69af7582238f687/" rel="bookmark">
			内存对齐——#pragma pack()用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C/C++编译器的缺省字节对齐方式为自然对界。即在缺省情况下，编译器为每一个变量或是数据单元按其自然对界条件分配空间。编译器缺省的结构成员自然对界条件为“N字节对齐”，N即该成员数据类型的长度。如int型成员的自然对界条件为4字节对齐，而double类型的结构成员的自然对界条件为8字节对齐。若该成员的起始偏移不位于该成员的“默认自然对界条件”上，则在前一个节面后面添加适当个数的空字节。
1.#pragma简述 预处理指令，设定编译器的状态或者指示编译器完成一些特定的动作。#pragma指令对每个编译器给出了一个方法，在保持与C和C++语言完全兼容的情况下，给出主机或操作系统专有的特征。
2.#pragma pack()的作用 #pragma pack 的主要作用就是改变编译器的内存对齐方式，这个指令在网络报文的处理中有着重要的作用，#pragma pack(n)是他最基本的用法，其作用是改变编译器的对齐方式， 不使用这条指令的情况下，编译器默认采取#pragma pack(8)也就是8字节的默认对齐方式，n值可以取（1， 2， 4， 8， 16） 中任意一值。
#include &lt;stdio.h&gt; #include &lt;stdint.h&gt; #pragma pack (1) struct Test { uint32_t var1:24; uint32_t var2:8; uint16_t year; uint8_t moth[3]; }; #pragma pack () int main(void) { Test var = {1, 2, 3,4,5,6}; printf("sizeof(Test) = %lld\n", sizeof(Test)); printf("%d %d %d %d %d %d\n", var.var1, var.var2, var.year,var.moth[1],var.moth[2],var.moth[0]); return 0; } 运行结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4aca8b0fa9a0d1d20b00c45a6c6258d6/" rel="bookmark">
			SqlServer中去除字段空格及特殊空格/回车/换行等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决方式如下：
1.去除左边空格 LTRIM()
2.去除右边空格 RTRIM()
3.去除回车符 REPLACE(@str, CHAR(13) , '') 4.去除换行符 REPLACE(@str, CHAR(10), '') 5.去除回车换行符 REPLACE(@str, CHAR(13) + CHAR(10), '')
6.替换空格 REPLACE(@str,' ','')
实例如下：
-- 定义字符串str DECLARE @str nvarchar(100) ='" 100001", " 10002 ","10003","10004 "' DECLARE @sql varchar(max) -- 替换字符串中的空格等特殊字符 SET @str=REPLACE(REPLACE(REPLACE(LTRIM(RTRIM(@str)),'"',''),' ',''),CHAR(13) + CHAR(10), '') -- 将字符串拆分成列 set @sql='select col='''+ replace(LTRIM(RTRIM(@str)),',',''' union all select ''')+'''' PRINT @sql exec (@sql) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6705d26a99293e4d44f37dd0d4773fac/" rel="bookmark">
			记录解决方案：‘express‘ 不是内部或外部命令，也不是可运行的程序或批处理文件。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本地 安装express ：npm install express -g
然后还是会显示'express' 不是内部或外部命令，也不是可运行的程序或批处理文件。
继续安装：npm install express-generator -g
安装完检测 express，使用命令检查即可： express --version
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ad011aff9bff91a1be2fb91c0c6e0e0/" rel="bookmark">
			计算机组成原理(概述)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一, 计算机发展史
二, 计算机系统：
2.1 冯诺依曼（普林斯顿）结构
2.2 现代计算机
2.3 翻译程序 三, 计算机各硬件组成
3.1 运算器
3.2 控制器
3.3 主存
四, 计算机硬件指标
一, 计算机发展史 第一代：电子管计算机（1946-1958）第二代：晶体管计算机（1958-1964）第三代：中小规模集成电路计算机（1964-1971）第四代：大、超大规模集成电路计算机（1971年以后） 二, 计算机系统： 硬件+软件(系统软件+应用软件)
第一台电子数字计算机：1946年美国宾夕法尼亚大学的ENIAC
2.1 冯诺依曼（普林斯顿）结构 以运算器为中心 (占用运算器的时间，不利于高效利用运算器)。最根本特征是采用存储程序原理。
原理图: 2.2 现代计算机 以存储器为中心。
原理图: 计算机系统的层次结构图:
2.3 翻译程序 编译程序: 将源程序的全部语句一次全部翻译成机器语言程序,而后在执行。
解释程序: 将源程序的一条语句翻译成对应机器语言的一条语句并立即执行, 接着翻译源程序的下一条语句, 重复执行的语句也会被重新翻译。
三, 计算机各硬件组成 3.1 运算器 ACC: 累加寄存器MQ: 乘商寄存器X: 通用寄存器ALU: 算术逻辑单元 3.2 控制器 CU: 控制单元IR: 指令寄存器, 存放当前执行的指令PC: 程序计数器, 存放下一条指令的地址 3.3 主存 MDR: 地址寄存器, 位数=存储数量MAR: 数据寄存器, 位数=存储字长 原理图:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ad011aff9bff91a1be2fb91c0c6e0e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ec22030ab8079b86f93bd7bf2f75f84/" rel="bookmark">
			C语言基础：操作符详解，看这一个就够了！（内含详细图解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言中的操作符主要可以分为10个类型，这篇文章将带你详细了解各操作符的使用方法，希望能对你有帮助~
目录
1、算数操作符（+ - * / %）
/ 是除法运算符，与日常生活中的使用略有不同，分为两种情况
1、'/'左右两边都是整型：
2、'/'两边有一边是浮点型：
%是取模操作符
2、移位操作符（ &gt;&gt; &lt;&lt; ）
原码、补码、反码：
&lt;&lt; 左移操作符
&gt;&gt; 右移操作符
3、位操作符（ &amp; ^ | ）
4、赋值操作符（ = += -= *= /= &amp;= ^= |= &gt;&gt;= &lt;&lt;=）
5、单目操作符（ ! - + &amp; sizeof ~ -- ++ * (类型) )
1、逻辑反操作符 ！
2、正值和负值操作符 + -
3、取地址操作符与间接访问操作符(解引用操作符) &amp; *
4、sizeof操作符
5、~操作符
6、前置、后置-- 前置、后置++
7、(类型) 强制类型转换
6、关系操作符（ &gt; &gt;= &lt; &lt;= != ==）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ec22030ab8079b86f93bd7bf2f75f84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f9967e4a4b7df5cbd14418d3c5adbd6/" rel="bookmark">
			Failed to enable unit: Unit file DmServiceDMSERVER.service does not exist.记录Linux上安装DM数据库一个报错。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当执行到配置实例，执行命令的时候
在root下执行第二条指令会报错，报错如下箭头：
这里可以使用命令：
systemctl list-unit-files 查找出DmServiceDMSERVER.service的状态，如下：
没错，就是坏了，这里我采用了重新安装、换安装包、用别人的DmServiceDMSERVER.service，都失败了，最后在dm账号下的安装路径中的tool，打开了服务查看器：
cd /dm8/tool ./dmservice.sh 可以点击，强制打开服务，跳过DmServiceDMSERVER.service，这样实例就可以建好了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1b6923f45c102d1f2f728d51839c8f2/" rel="bookmark">
			MongooseError: Model.create() no longer accepts a callback 解决方法！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题如图所示：
原因就是：版本太高导致！
我安装的原先版本：7以上的版本。默认安装的就是最新的。
然后重新安装，降级
通过命令npm i mongoose@6.8.0 手动降级 。我采用的是cnpm安装
安装完之后，再次运行即可解决问题！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed089d366932961e9cc9e88bd5426896/" rel="bookmark">
			C#--调用Python（包含第三方库）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. C# 调用 Python 常见的方法有4种 参考链接
1.1 Pythonnet （推荐） 可以很好的支持第三方库。
推荐这个，经本人验证这个很好用。
后文 2. 详细使用。
1.2 IronPython 如果使用第三方库就放弃这个吧，真的用不了，使用时报各种错。
如果只是标准库，可以用这个。
只需要在 nuget 里装上 IronPython 和 IronPython.StdLib 即可。
使用参考链接
1.3 利用C#的 process 方式 弊端： 1.当传入参数过长时，此方式是用不了的。会报错，没有解决办法。 2.需要安装python环境，并在程序中指定 pyython.exe 位置，及 脚本.py的位置。 1.3.1 示例演示 此方式类似执行命令加参数，如：
#demo.py import sys def str_add(str1, str2): print("11111") return int(str1) + int(str2) if __name__ == '__main__': print(str_add(sys.argv[1],sys.argv[2])) 1.4 使用C++调用Python，然后将C++程序做成动态链接库 这个实现很复杂，不了解C++的就很难搞了，也不推荐。
2.Pythonnet 详细使用 gitee repositroy
3. 利用C#的 process 方式 详细使用 实现其实就一个方法，套用即可。
private string RunPythonByexe(string scriptName, params string[] args) { string result= null; try { using (var p = new Process()) { string path = System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed089d366932961e9cc9e88bd5426896/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69b30ab3f7aeb7ff48dc61a957e4321e/" rel="bookmark">
			最佳实战 | 教你用 Python 驾驭 Nacos 配置中心
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是安果！
Nacos 是阿里巴巴开源的项目，用于构建云原生应用的动态服务发现、配置管理和服务管理平台
核心特征包含：服务发现、服务健康监测、动态配置服务、动态 DNS 服务、服务及其元数据管理
如果想在 Python 项目中利用 Nacos 动态配置服务该怎么做呢？
1、安装依赖
nacos-sdk-python 项目是 Nacos OpenAPI 的 Python 实现，可用于监听 Nacos 配置文件的数据变动
# 安装以来 pip3 install nacos-sdk-python # Nacos配置文件为yaml的依赖 pip3 install pyyaml 项目地址：
https://github.com/nacos-group/nacos-sdk-python
2、基础使用（yaml）
以 YAML 配置文件为例
首先，通过 Nacos 连接信息（连接信息、命名空间、用户名及密码）创建一个 Nacos 客户端连接对象
import nacos # 连接地址 SERVER_ADDRESSES = "192.*.*.*" SERVER_PORT = '8848' # 命名空间 NAMESPACE = "public" # 账号信息 USERNAME = 'nacos' PASSWORD = 'nacos' # 创建一个连接对象 client = nacos.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69b30ab3f7aeb7ff48dc61a957e4321e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/29/">«</a>
	<span class="pagination__item pagination__item--current">30/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/31/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>