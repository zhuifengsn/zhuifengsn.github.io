<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1b3c4f10116990646bde91d46bde71f/" rel="bookmark">
			java 的Math函数库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java.math是一个包，提供用于执行任意精度整数(BigInteger)算法和任意精度小数(BigDecimal)算法的类。
java.lang.Math类中包含E和PI两个静态常量，以及进行科学计算的类(static)方法，可以直接通过类名调用。
public static final Double E = 2.7182818284590452354 public static final Double PI = 3.14159265358979323846 public static long abs(double x) 传回 x 的绝对值。X也可int long float public static long sin(double x) 传回x径度的正弦函数值 public static long cos(double x) 传回x径度的余弦函数值 public static long tan(double x) 传回x径度的正切函数值 public static long asin(double x) 传回x值的反正弦函数值。 public static long acos(double x) 传回x值的反余弦函数值。 public static long atan(double x) 传回x值的反正切函数值。 public static long atan2(double x, double y) 传回极坐标（polar）的θ值 public static long floor(double x) 传回不大于x的最大整数值 public static long ceil(double x) 传回不小于x的最小整数值。 public static long exp(double x) 传回相当于ex值 public static long log(double x) 传回x的自然对数函数值 public static long max(double x,double y) 传回x、y较大数 public static long min(double x,double y) 传回x、y较小数 public static long pow(double x,double y) 传回x的y次幂值 public static long sqrt(double x) 传回x开平方值 public static long rint(double x) 传回最接近x的整数值 public static long round(double x) 传回x的四舍五入值 public static long toDegrees(double angrad) 传回将angrad径度转换成角度 public static long toRadians(double angdeg) 传回将angdeg角度转换成径度 public static long random() 传回随机数值,产生一个0-1之间的随机数(不包括0和1) Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1b3c4f10116990646bde91d46bde71f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/211fc54133ca2be18351ebee983cb130/" rel="bookmark">
			SQL中 rtrim() 函数的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Rtrim舍去字符串右边的空字符串。rtrim是一个函数，返回删除字符串右边的空格后的字符串。
用例子说话：
select 'abc ', rtrim('abc '), 'abc ' + '123', rtrim('abc ') + '123' 返回的结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/800bc6839198db266896bc0d149c553f/" rel="bookmark">
			MySql事务隔离级别-已提交读（READ COMMITTED）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 准备工作以及SQL解释参考：https://mp.csdn.net/postedit/98398695
执行步骤
SESSION ASESSION BT1SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED; T2START TRANSACTION; T3 SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;T4 START TRANSACTION;T5 SELECT * FROM t1;
-- 结果为空
T6 INSERT INTO `t1` VALUES (1, 100);T7 SELECT * FROM t1;
-- 结果为空
T8 COMMIT;T9 SELECT * FROM t1;
-- 查询到记录【1，100】
SQL执行结果分析：
SESSION A在 T7 时刻没有读取到SESSION B在 T6 时刻添加的数据【1， 100】，解决了脏读问题。SESSION A在 T7 和 T9 时刻执行了相同的SQL，但是结果不同。出现了不可重复读问题。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13ce55a9b202accab87b6a091c26ec1e/" rel="bookmark">
			Python爬虫1.1 — urllib基础用法教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python爬虫1.1 — urllib基础用法教程 综述urllib库介绍urllib.request 介绍urlopen()urlretrleve() urllib.parse 介绍urlencode()parse_s()urlparse()urlsplit()urljoin() urllib.error 介绍 综述 本系列文档用于对Python爬虫技术进行简单的教程讲解，巩固自己技术知识的同时，万一一不小心又正好对你有用那就更好了。
Python 版本是3.7.4
urllib库介绍 它是 Python 内置的HTTP请求库，也就是说我们不需要额外安装即可使用，它包含四个模块(主要对前三个模块进行学习)：
request : 它是最基本的 HTTP 请求模块，我们可以用它来模拟发送一请求，就像在浏览器里输入网址然后敲击回车一样，只需要给库方法传入 URL 还有额外的参数，就可以模拟实现这个过程了。error : 异常处理模块，如果出现请求错误，我们可以捕获这些异常，然后进行重试或其他操作保证程序不会意外终止。parse : 用于解析URL，提供了许多URL处理方法，比如拆分、解析、合并等等的方法，以及对参数的拼接等待。robotparser : 主要是用来识别网站的robots.txt协议文件，然后判断网站的那些数据可以爬，哪些数据不可以爬的，其实用的比较少。 urllib.request 介绍 urlopen() 参数说明(仅写了四个最常用的参数)
url : 爬取目标的URL；data : 请求参数，如果设置该参数，则请求默认为post请求；没有默认为get请求；timeout : 用于设置超时时间，单位为秒；context : 必须是一个ssl.SSLContext类型,用来指定SSL设置,忽略未认证的CA证书; 具体用法
GET 请求方式 # 导入urllib库 import urllib.request # 向指定的url发送请求，并返回服务器响应的类文件对象 url = "http://www.baidu.com" response = urllib.request.urlopen(url=url) print(type(response)) # 类文件对象支持文件对象的操作方法，如read()方法读取文件全部内容，返回字符串 html = response.read() # html = response.readline() # 读取一行 # html = response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13ce55a9b202accab87b6a091c26ec1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50ec6650af0c38d488ae8d6490c636ea/" rel="bookmark">
			文件摆渡如何实现自动化传输？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着企业数字化转型逐步深入，企业的业务开展，越来越依赖于不断增加的办公、生产、研发等IT系统，也越来越频繁地需要与外部进行持续大量的内外网文件交换。主要会遇到以下场景：
·处在内网的员工，需要将设计图纸、项目资料等文件发送给外网的用户。
·客户、供应商、合作伙伴，需要通过互联网将文件发送给内网员工。
·科技型企业，需要持续将从外部获取的大量数据导入到研发网，进行机器学习、数据挖掘等数据处理工作。
所以，就需要在网络隔离的条件下，进行跨网文件摆渡。文件摆渡，说的通俗一点，就是数据导入导出。基本场景就是，你公司的内网和外网物理上是不通的，但是你们还是要数据通讯的需求，这个时候，你需要准备一台单独的机器，一会儿接入内网，一会儿接入外网，接入内网时，就把内网的数据拷到这台机器上，过会儿到外网了，就把数据导入外网，再把外网的数据拷回来。
但是，如果按照传统的方式进行文件交换的话，会出现很多问题。比如使用移动硬盘进行拷贝，如果数据量加剧，频次提高，IT部门往往不堪重负，而且移动硬盘的损坏导致数据流失，也会造成很大的损失。还有一些公司会通过网闸进行网间文件摆渡，但是网闸只能解决文件物理位置移动的问题，企业很难具体控制哪些文件可以被同步，哪些人有权限进行操作，同步之后的文件应该如何处理等问题，这种方式并不能完成一个具体业务的完整链条。
所以，对于企业来说，需要能在网络隔离的前提下，满足不同网络间的安全文件交换需求，就需要类似于Ftrans内外网文件安全交换解决方案这样的产品了，可以轻松实现以下功能：
1、支持多种网络隔离方案 无需改变现有架构
支持网闸、防火墙、DMZ等多种网络隔离方案，无需更改用户现有的网络设备架构。适用于生产制造型企业、政府机构等复杂的网络环境。
2、全自动化的跨网数据传输机制 大大减轻IT部门运维压力
平台管理员只需要根据企业对不同业务数据的安全管理要求，预先设定不同的审批及包裹安全策略，可以实现全自动化的数字包裹按需投递，使得IT部门可以从此摆脱手动干预的困扰。
3、添加审批流程 确保文件安全可追溯
根据不同安全要求，对数据包裹的内容、提取进行多维度的安全保护，并附加审批流程，确保传输内容及行为安全合规。
4、文件状态可视化跟踪 大大提高效率
数据包裹的发送者及相关管理员可以对包裹所处位置与当前状态进行持续跟踪，大大提升数据交换全过程的可视性，提高业务运转效率。
随着企业IT业务系统的日益成熟，可控的跨网数据传输需求也越来越强烈。企业需要Ftrans内外网文件安全交换解决方案这样的产品来走出当前的文件摆渡困境。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4446d881691ecdbf9c8b8d4c266ff71a/" rel="bookmark">
			从CAS底层原理说到ABA问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是CAS？
CAS（Compare and sweep）：比较并交换（compareAndSet），是解决多线程并行情况下使用锁造成性能损耗的一种机制。比较当前工作内存中的值和主内存中的值，如果相同则执行规定操作，否则继续比较知道主内存和工作内存中的值一致为止。CAS有3个操作数，内存值为V，旧的预期值为A，要修改的更新值为B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。java.util.concurrent.atomic包下的类大多是使用CAS操作来实现的。来看一段代码：
package cassssss; import java.util.concurrent.atomic.AtomicInteger; public class CASDemo { public static void main(String[] args) { AtomicInteger atomicInteger = new AtomicInteger(5); atomicInteger.getAndIncrement(); boolean flag = atomicInteger.compareAndSet(4,9); System.out.println(flag + " " + atomicInteger.get()); } } 首先初始化一个变量5，指定了递增操纵，执行compareAndSet方法比较并交换，其中左参数是主内存中期望的值，update是主内存中想要更新的值，在更新之前看一下是否是当初取出的值（也即没有别的进程修改），再决定是否更新。
public class AtomicInteger extends Number implements java.io.Serializable { private volatile int value; public AtomicInteger(int initialValue) { value = initialValue; } public final int getAndIncrement() { return unsafe.getAndAddInt(this, valueOffset, 1); } public final boolean compareAndSet(int expect, int update) { return unsafe.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4446d881691ecdbf9c8b8d4c266ff71a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61a2a91dc4e833f7228056d16efb213b/" rel="bookmark">
			概率算法（随机化算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概率算法也叫随机化算法。概率算法允许算法在执行过程中随机地选择下一个计算步骤。在很多情况下，算法在执行过程中面临选择时，随机性选择比最优选择省时，因此概率算法可以在很大程度上降低算法的复杂度。概率算法的一个基本特征是对所求解问题的同一实例用同一概率算法求解两次可能得到完全不同的效果。这两次求解问题所需的时间甚至所得到的结果可能会有相当大的差别。
概率算法大致分为四类： 数值概率算法蒙特卡罗（Monte Carlo）算法拉斯维加斯（Las Vegas）算法舍伍德（Sherwood）算法 基本特征 随机决策。在同一实例上执行两次其结果可能不同。在同一实例上执行两次的时间亦可能不太相同。 特点 不可再现性：在同一个输入实例上，每次执行结果不尽相同，例如N-皇后问题，概率算法运行不同次将会找到不同的正确解；找一给定合数的非平凡因子， 每次运行的结果不尽相同，但确定算法每次运行结果必定相同分析困难：要求有概率论，统计学和数论的知识。 大致分类（四类） 概率算法的一个基本特征是对所求解问题的同一实例用同一概率算法求解两次可能得到完全不同的效果。这两次求解问题所需的时间甚至所得到的结果可能会有相当大的差别。
数值概率算法
数值概率算法常用于数值问题的求解。这类算法所得到的往往是近似解。而且近似解的精度随计算时间的增加不断提高。在许多情况下，要计算出问题的精确解是不可能或没有必要的，因此用数值概率算法可得到相当满意的解。
蒙特卡罗算法
蒙特卡罗算法用于求问题的准确解。蒙特卡洛算法1945年由冯诺依曼行核武模拟提出的。它是以概率和统计的理论与方法为基础的一种数值计算方法，它是双重近似：
1 . 用概率模型模拟近似的数值计算；
2 . 用伪随机数模拟真正的随机变量的样本。
对于许多问题来说，近似解毫无意义。例如，一个判定问题其解为“是”或“否”，二者必居其一，不存在任何近似解答。又如，我们要求一个整数的因子时所给出的解答必须是准确的，一个整数的近似因子没有任何意义。用蒙特卡罗算法能求得问题的一个解，但这个解未必是正确的。求得正确解的概率依赖于算法所用的时间。算法所用的时间越多，得到正确解的概率就越高。蒙特卡罗算法的主要缺点就在于此。一般情况下，无法有效判断得到的解是否肯定正确。
拉斯维加斯算法
拉斯维加斯算法不会得到不正确的解，一旦用拉斯维加斯算法找到一个解，那么这个解肯定是正确的。但是有时候用拉斯维加斯算法可能找不到解。与蒙特卡罗算法类似。拉斯维加斯算法得到正确解的概率随着它用的计算时间的增加而提高。对于所求解问题的任一实例，用同一拉斯维加斯算法反复对该实例求解足够多次，可使求解失效的概率任意小。
舍伍德算法
舍伍德算法总能求得问题的一个解，且所求得的解总是正确的。当一个确定性算法在最坏情况下的计算复杂性与其在平均情况下的计算复杂性有较大差别时，可以在这个确定算法中引入随机性将它改造成一个舍伍德算法，消除或减少问题的好坏实例间的这种差别。舍伍德算法精髓不是避免算法的最坏情况行为，而是设法消除这种最坏行为与特定实例之间的关联性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/740c05f25db836e20e01fd62cfe0ffee/" rel="bookmark">
			插值、拟合和逼近的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		插值、拟合和逼近的区别 1. 拟合 据维基百科，科学和工程问题可以通过诸如采样、实验等方法获得若干离散的数据，根据这些数据，我们往往希望得到一个连续的函数（也就是曲线）或者更加密集的离散方程与已知数据相吻合，这过程就叫做拟合。
2.插值 在离散数据的基础上补插连续函数，使得这条连续曲线通过全部给定的离散数据点。
插值是离散函数逼近的重要方法，利用它可通过函数在有限个点处的取值状况，估算出函数在其他点处的近似值。插值：用来填充图像变换时像素之间的空隙。（即通过拟合得到的函数获得未知点的数据的方法，叫做插值）其中，拟合函数经过所有已知点的插值方法，叫做内插。
区别 拟合是已知点列，从整体上靠近它们；
插值是已知点列并且完全经过点列；
逼近是已知曲线，或者点列，通过逼近使得构造的函数无限靠近它们。
最小二乘意义下的拟合，是要求拟合函数与原始数据的均方误差达到极小，是一种整体意义的逼近，对局部性质没有要求。而所谓“插值”，就是要在原有离散数据之间“插入”一些值，这就要求插值函数必须通过所有的离散点，插值函数在离散点之外的那些点都相当于“插入”的值。插值有全局插值，也有局部插值（比如分段线性插值），插值误差通常考虑的是逐点误差或最大模误差，插值的好坏往往通过某些局部的性质来体现，比如龙格现象或吉布斯振荡。
插值方法请参考：
作者：-柚子皮-
名称：数值分析：数据插值方法：
链接：https://blog.csdn.net/pipisorry/article/details/62227459
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b643ef538a393356a5364bed5ee6c18/" rel="bookmark">
			如何在电脑上缓存哔哩哔哩的视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何在电脑上缓存哔哩哔哩的视频 进入哔哩哔哩官网，点击想下载的视频右键复制下载的网址打开硕鼠视频下载器将要下载的视频网址粘贴到搜索框里 并点击开始按钮鼠标点击“用硕鼠下载该视频”在新页面中点击“硕鼠专用链下载”选择好储存位置后点击确定，即可下载该视频 注：需要详情请参考 详情请参考：
怎样在电脑上下载哔哩哔哩的视频？
https://product.pconline.com.cn/itbk/vedio/1811/11981193.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f4e6e10d69fca19bad46b8604516204/" rel="bookmark">
			如何在个人博客首页中添加访问计数器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、去提供免费计数器的网站申请一个计数器，得到计数器的脚本代码。
备注：
我是在http://www.freeweblogger.com/下申请（计数器只能计数到6位），不过用IE打开的网页显示不完全，还是用FireFox打开的。
如果需要六位数以上的计数器，你可以在statcounter.com里申请。http://wayfarer.cnblogs.com/ 用的就是上述的计数器，我数了数一共有8位数。
2、进行如下操作
1）、设置首页显示公告
个人的博客→管理→选项→Preferences（常用选项）。拉动滚动条至“控件显示设置(选中时显示)”，
在“公告”选项后打上钩，即可在首页显示公告。
2）、在公告中添加计数器代码
个人的博客→管理→选项→Configure(博客设置)。拉动滚动条至“公告”发布框中，选择HTML，将1中申请到脚本代码复制到这里。最后保存。
做完以上操作后，重新打开首页即可在公告栏目下看见计数器了。
转载于:https://www.cnblogs.com/wj110reg/archive/2007/12/05/983467.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/927d7822b6ed8a74ff259ce1c017d26c/" rel="bookmark">
			C/C&#43;&#43;种extern关键字详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C/C++中extern关键字详解 转自chao_yu，cnblog.com
1 基本解释：extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外extern也可用来进行链接指定。
也就是说extern有两个作用，第一个,当它与"C"一起连用时，如: extern "C" void fun(int a, int b);则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的，C++的规则在翻译这个函数名时会把fun这个名字变得面目全非，可能是fun@aBc_int_int#%$也可能是别的，这要看编译器的"脾气"了(不同的编译器采用的方法不一样)，为什么这么做呢，因为C++支持函数的重载啊，在这里不去过多的论述这个问题，如果你有兴趣可以去网上搜索，相信你可以得到满意的解释!
第二，当extern不与"C"在一起修饰变量或函数时，如在头文件中: extern int g_Int; 它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块或其他模块中使用，记住它是一个声明不是定义!也就是说B模块(编译单元)要是引用模块(编译单元)A中定义的全局变量或函数时，它只要包含A模块的头文件即可,在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在连接时从模块A生成的目标代码中找到此函数。
2 问题：extern 变量
在一个源文件里定义了一个数组：char a[6];
在另外一个文件里用下列语句进行了声明：extern char *a；
请问，这样可以吗？ 答案与分析：
1)、不可以，程序运行时会告诉你非法访问。原因在于，指向类型T的指针并不等价于类型T的数组。extern char *a声明的是一个指针变量而不是字符数组，因此与实际的定义不同，从而造成运行时非法访问。应该将声明改为extern char a[ ]。
2)、例子分析如下，如果a[] = "abcd",则外部变量a=0x61626364 (abcd的ASCII码值)，*a显然没有意义
显然a指向的空间（0x61626364）没有意义，易出现非法内存访问。
3)、这提示我们，在使用extern时候要严格对应声明时的格式，在实际编程中，这样的错误屡见不鲜。
4)、extern用在变量声明中常常有这样一个作用，你在*.c文件中声明了一个全局的变量，这个全局的变量如果要被引用，就放在*.h中并用extern来声明。
3 问题：单方面修改extern 函数原型
当函数提供方单方面修改函数原型时，如果使用方不知情继续沿用原来的extern申明，这样编译时编译器不会报错。但是在运行过程中，因为少了或者多了输入参数，往往会照成系统错误，这种情况应该如何解决？
答案与分析：
目前业界针对这种情况的处理没有一个很完美的方案，通常的做法是提供方在自己的xxx_pub.h中提供对外部接口的声明，然后调用方include该头文件，从而省去extern这一步。以避免这种错误。
宝剑有双锋，对extern的应用，不同的场合应该选择不同的做法。
4 问题：extern “C”
在C++环境下使用C函数的时候，常常会出现编译器无法找到obj模块中的C函数定义，从而导致链接失败的情况，应该如何解决这种情况呢？
答案与分析：
C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。
下面是一个标准的写法：
//在.h文件的头上
#ifdef __cplusplus
#if __cplusplus
extern "C"{
#endif
#endif /* __cplusplus */ …
…
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/927d7822b6ed8a74ff259ce1c017d26c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5e577886109317ef9d85ff1f0f7fe95/" rel="bookmark">
			安卓金融类APP上线流程及审核规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家都知道在咱们国家，对金融类行业监管是非常严格的，APP产品也不例外，所有的金融类产品在安卓应用市场上架，都必须符合国家要求，并且提供相应的资质。不符合规范的应用是没办法上传发布的，这一点仅限于安卓应用商店，不适用于AppStore。
一、360应用市场
彩票类 彩票中心颁布的授权书或者合作协议。
与彩票中心的授权/代理/销售文件与彩票中心的合作协议 股票、基金、证券类 证监会颁发的交易证明文件。
《证券交易所的经营许可证》《基金销售业务资格证书》《基金管理资格证书》《证券投资咨询业务资格证书》《证券期货相关业务评估资格证书》《证券经营许可证》 银行类 人民银行银监会出具的资质证明文件。
包含此经营范围的营业执照《金融许可证》或者用该银行企业邮箱给360box@360.cn发邮件，在邮件中说明此软件为银行官方软件非盗版即可 第三方支付类 人民银行颁发的许可证
《支付业务许可证》
P2P网贷 （互联网金融） 指个人通过网络平台相互借贷。
即，由具有资质的网站（第三方网贷平台）作为中介平台，借款人在平台发放借款标，投资者进行竞标向借款人放贷的行为。
满足三个名单内会员之一与第三方支付平台签署资金托管协议，协议内容可确保平台不参与整体借贷资金实际运营（选交）第三方担保公司合作协议（担保方营业执照）（选交） 二、魅族应用市场
基金类经营范围涵盖基金业务经营的营业执照和《基金销售业务资格证书》或《基金管理资格证书》证券理财类经营范围涵盖证券业务经营的营业执照和《证券经营许可证》或《证券交易所的经营许可证》或《证券投资咨询业务资格证书》外汇类经营范围涵盖外汇业务经营的营业执照和《经营外汇业务许可证》支付类经营范围涵盖互联网支付营业执照和人民银行颁发的《支付业务许可证》股票类经营范围涵盖股票业务经营的营业执照和《经营股票承销业务资格证书》贵金属交易平台类 经营范围涵盖贵金属业务经营的营业执照+《贵金属交易会员证书》+贵金属交易所（中心）会员查询截图 三、阿里应用市场
股票类
《证券投资咨询业务资格证书》/《经营股票承销业务资格证书》/《经营证券期货业务许可证》（十证合一） 基金类
《证券交易所的经营许可证》/《基金销售业务资格证书》/《基金管理资格证书》/《经营证券期货业务许可证》（十证合一） 证券类
《证券投资咨询业务资格证书》/《证券期货相关业务评估资格证书》/《证券经营许可证》/《经营证券期货业务许可证》（十证合一） 期货类
《经营期货业务许可证》/《期货公司营业部经营许可证书》/《经营证券期货业务许可证》（十证合一）
贵金属类
《贵金属交易会员证书》/《环球商品交易中心之会员资格证书》
外汇类
《个人本外币兑换特许业务经营许可证》、国内合作公司相关资质文件（ICP证、ICP备、营业执照、软著、资金托管协议）
投资理财（综合类）
中国银行业监督管理委员会出具的相关资质文件
《金融许可证》《资金托管协议》营业执照经营范围：一般含有“互联网金融、资产管理、投资管理、投资管理咨询、实业/项目投资，投资咨询”等 银行类
人民银行银监会出具的资质证明文件。
包含此经营范围的营业执照《金融许可证》 第三方支付类
人民银行颁发的许可证《支付业务许可证》
保险类
中国保险监督管理委员会颁发的相关证件
《保险公司法人许可证》/《经营保险业务许可证》/《保险营销服务许可证》/《经营保险代理业务许可证》/《经营保险经纪业务许可证》/《经营保险公估业务许可证》/《保险兼业代理业务许可证》/《保险资产管理公司法人许可证》/《经营保险资产管理业务许可证》
典当类
中华人民共和国商务部颁发的相关证件
《典当经营许可证》/《特种行业许可证-典当业》等
P2P网贷 平台（互联网金融）
指个人通过网络平台相互借贷。即，由具有资质的网站（第三方网贷平台）作为中介平台，借款人在平台发放借款标，投资者进行竞标向借款人放贷的行为。
与银行签订的资金存管协议
P2P网贷 聚合平台（互联网金融）
指聚合各类P2P网贷平台投资项目的信息提供者，该聚合平台不涉及贷款交易，交易在各网贷平台上进行。
该聚合平台与各类P2P网贷平台的合作协议、关系说明，合作方与银行签订的资金存管协议等
信用卡业务类
涉及用户的信用卡申请、开卡等业务的第三方平台
所涉及信用卡银行的合作协议及相关银行的授权证明
以上是三家应用市场的金融类产品上架要求，大家仔细观察可以发现，不同的平台虽然细节上可能有所不同，但是大体上所要求提供的资质材料是基本一致的。建议大家安卓应用市场上架产品前取得所需的行业资质。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/945c5cd05ac4ed2fd4203fcf331c46e3/" rel="bookmark">
			C&#43;&#43;深度解析(2)—C/C&#43;&#43;中的const分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.C语言中的const
1.1 const只读变量
const修饰的变量是只读的，本质还是变量const修饰的局部变量在栈上分配空间const修饰的全局变量在全局数据区分配空间const只在编译期有用，在运行期无用const修饰的变量不是真的变量，它只是告诉编译器该变量不能出现在赋值符号的左边 1.2 const全局变量的分歧
在现代C语言编译器中，修改const全局变量将导致程序崩溃标准C语言编译器不会将const修饰的全局变量存储于只读存储区中，而是存储于可修改的全局数据区，其值依然可以改变。 #include &lt;stdio.h&gt; const int g_cc = 2; int main() { const int cc = 1; int *p = (int *)&amp;cc; printf("cc = %d\n", cc); *p = 3; printf("cc = %d\n", cc); p = (int *)&amp;g_cc; printf("g_cc = %d\n", g_cc); *p = 4; printf("g_cc = %d\n", g_cc); return 0; } gcc、VS2017、BCC(标准C)编译结果： 1.3 const的本质
C语言中的const使得变量具有只读属性现代C编译器中的const将具有全局生命周期变量存储于只读存储区（所以gcc、vs2017都会出错）const不能定义真正意义上的常量 #include &lt;stdio.h&gt; const int g_array[5] = {0}; void modify(int* p, int v) { *p = v; } int main() { int const i = 0; const static int j = 0; int const array[5] = {0}; modify((int *)&amp;i, 1); // ok modify((int *)&amp;j, 2); // error modify((int *)&amp;array[0], 3); // ok modify((int *)&amp;g_array[0], 4); // error printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/945c5cd05ac4ed2fd4203fcf331c46e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed60174bc81ea71deab378d987282b33/" rel="bookmark">
			多GPU训练机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 通常情况下，在深度学习中使用梯度下降算法进行训练时，往往需要较大的batch-size才能获得良好的性能。而当我们选择比较大型的网络时(如DenseNet121)，由于GPU资源有限，我们往往要减小batch-size。但是batch-size太小的话会影响性能，这时候如果硬件条件允许的情况下可以使用多GPU进行训练。
多GPU又分为单机多卡和多机多卡。这篇博客仅介绍单机多卡。
单机单卡(单GPU) 单机单卡，前向传播和反向传播都在一个GPU上进行，模型参数更新时只涉及一个GPU。训练是一个batch一个batch的计算，如果想要训练4个batch的话，这些计算是顺序计算的，这样的速度比较慢。
单机多卡(多GPU) 多GPU分为模型并行和数据并行。模型并行指模型的不同部分在不同GPU上运行。数据并行指不同GPU上训练数据不同，但模型是同一个（相当于是同一个模型的副本）。一般情况下我们常用的是数据并行。
下面是训练过程模型图。
单机多GPU-数据并行的训练机制：
如果单机多GPU-数据并行训练4个batch的话，CPU会将4个batch数据分到4个GPU中，在每个 GPU 上放一个模型副本，然后每个GPU处理一个batch的计算，最后4个GPU计算得到的梯度传回给CPU，CPU计算平均梯度，然后更新参数。然后循环整个过程至模型收敛。
不同的 GPU设备有同一模型的多个副本，将数据分片并分配到每个GPU上，然后将所有GPU的计算结果按照某种方式合并，进而可以增加训练数据的batch-size。主要可以解决单卡训练时只能将batch-size设置成1的情况。或者可以通过增大batch-size进而提高训练速度。
参考：
https://www.tensorflow.org/tutorials/images/deep_cnn
https://www.jianshu.com/p/fdb93e44a8cc
作者：GL3_24
来源：CSDN
著作权归作者所有。转载请联系作者获得授权。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4846c6112d22dfdb84579f74aa798c61/" rel="bookmark">
			数据结构—哈夫曼编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.哈夫曼编码的主要思想
在进行数据压缩时，为了使压缩后的数据文件尽可能短，可采用不定长编码。其基本思想是：为出现次数较多的字符编以较短的编码。为确保对数据文件进行有效的压缩和对压缩文件进行正确的解码，可以利用哈夫曼树来设计二进制编码。哈夫曼树中，约定左分支标记为0，右分支标记为1，则根结点到每个叶子结点路径上的0、1序列即为相应字符的编码。 2.哈夫曼编码有关概念
前缀编码：如果在一个编码方案中，任一个编码都不是其他任何编码的前缀(最左子串)则称编码是前缀编码。例如编码0,10, 110,111是前缀编码，而编码0,01,010,111就不是前缀编码。前缀编码可以保证对压缩文件进行解码时不产生二义性，确保正确解码。哈夫曼编码：对一棵具有n个叶子的哈夫曼树，若对树中的每个左分支赋予0，右分支赋予1，则从根到每个叶子的路径上，各分支的赋值分别构成一个二进制串，该二进制串就称为哈夫曼编码。 3.哈夫曼编码性质
性质1：哈夫曼编码是前缀编码。 证明：哈夫曼编码是根到叶子路径上的编码序列，由树的特点知，若路径A是另一条路经B的最左部分，则B经过了A，则A的终点一定不是叶子。而哈夫曼编码对应路径的终点一定为叶子，因此，任一哈夫曼码都不会与任意其他哈夫曼编码的前缀部分完全重叠，因此哈夫曼编码是前缀编码。性质2：哈夫曼编码是最优前缀编码。 对于包括n个字符的数据文件，分别以它们的出现次数为权值构造哈夫曼树，则利用该树对应的哈夫曼编码对文件进行编码，能使该文件压缩后对应的二进制文件的长度最短。 4.哈夫曼编码的算法实现
在构造哈夫曼树之后，求哈夫曼编码的主要思想是：依次以叶子为出发点,向上回溯至根结点为止。回溯时走左分支则生成代码0，走右分支则生成代码1。由于每个哈夫曼编码是变长编码，因此使用一个指针数组来存放每个字符编码串的首地址。哈夫曼编码表的存储表示：typedef char **Huffmancode; //动态分配数组存储哈夫曼编码表各字符的哈夫曼编码存储在由Huffman Code定义的动态分配的数组HC中，为了实现方便，数组的0号单元不使用，从1号单元开始使用，所以数组HC的大小为n+1，即编码表HC包括n+1行。但因为每个字符编码的长度事先不能确定，所以不能预先为每个字符分配大小合适的存储空间。为不浪费存储空间，动态分配一个长度为n(字符编码长度一定小于n)的一维数组cd，用来临时存放当前正在求解的第i(1≤i≤n)个字符的编码，当第i个字符的编码求解完毕后，根据数组cd的字符串长度分配HC[i]的空间，然后将数组cd中的编码复制到HC[i]中。因为求解编码时是从哈夫曼树的叶子出发，向上回溯至根结点。所以对于每个字符，得到的编码顺序是从右向左的，故将编码向数组cd存放的顺序也是从后向前的，即每个字符的第1个编存放在cd[n-2]中(cdn-1]存放字符串结束标志”0)，第2个编码存放在cdn-3]中，依此类推，直到全部编码存放完毕。算法步骤 ①分配存储n个字符编码的编码表空间HC，长度为n+1；分配临时存储每个字符编码的动态数组空间cd，cdn-1]置为”0°。②逐个求解n个字符的编码，循环n次,执行以下操作： 设置变量start用于记录编码在cd中存放的位置，start初始时指向最后，即编码结束符位置n-1;设置变量c用于记录从叶子结点向上回溯至根结点所经过的结点下标，c初始时为当前待编码字符的下标i，f用于记录i的双亲结点的下标；从叶子结点向上回溯至根结点，求得字符i的编码,当f没有到达根结点时,循环执行以下操作: 回溯一次start向前指一个位置，即- - start;若结点c是f的左孩子，则生成代码0，否则生成代码1，生成的代码0或1保存在 cd[start]中；继续向上回溯，改变c和f的值。根据数组cd的字符串长度为第i个字符编码分配空间HC[i]，然后将数组cd中的编码复制到HC[i]中③释放临时空间cd。算法描述 void CreatHuffmanCode(HuffmanTree HT, HuffmanCode &amp;HC, int n) { //从叶子到根逆向求每个字符的赫夫曼编码，存储在编码表HC中 int i, start, c, f; HC = new char*[n + 1]; // 分配n个字符编码的头指针矢量 char *cd = new char[n];	// 分配临时存放编码的动态数组空间 cd[n - 1] = '\0'; // 编码结束符 for (i = 1; i &lt;= n; ++i) { // 逐个字符求赫夫曼编码 start = n - 1; // start开始时指向最后，即编码结束符位置 c = i; f = HT[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4846c6112d22dfdb84579f74aa798c61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1e2a331ab1d8dccfea06fc8e04e2f5d/" rel="bookmark">
			StorageClass
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文个人博客地址：https://www.huweihuang.com/kubernetes-notes/storage/storage-class.html
StorageClass 1. StorageClass概述 StorageClass提供了一种描述存储类（class）的方法，不同的class可能会映射到不同的服务质量等级和备份策略或其他策略等。
StorageClass 对象中包含 provisioner、parameters 和 reclaimPolicy 字段，当需要动态分配 PersistentVolume 时会使用到。当创建 StorageClass 对象时，设置名称和其他参数，一旦创建了对象就不能再对其更新。也可以为没有申请绑定到特定 class 的 PVC 指定一个默认的 StorageClass 。
StorageClass对象文件
kind: StorageClass apiVersion: storage.k8s.io/v3 metadata: name: standard provisioner: kubernetes.io/aws-ebs parameters: type: gp2 reclaimPolicy: Retain mountOptions: - debug 2. StorageClass的属性 2.1. Provisioner（存储分配器） Storage class 有一个分配器（provisioner），用来决定使用哪个卷插件分配 PV，该字段必须指定。可以指定内部分配器，也可以指定外部分配器。外部分配器的代码地址为： kubernetes-incubator/external-storage，其中包括NFS和Ceph等。
2.2. Reclaim Policy（回收策略） 可以通过reclaimPolicy字段指定创建的Persistent Volume的回收策略，回收策略包括：Delete 或者 Retain，没有指定默认为Delete。
2.3. Mount Options（挂载选项） 由 storage class 动态创建的 Persistent Volume 将使用 class 中 mountOptions 字段指定的挂载选项。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1e2a331ab1d8dccfea06fc8e04e2f5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b3f8e4d49589c4452db0a07d619d824/" rel="bookmark">
			PersistentVolumeClaim
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文个人博客地址：https://www.huweihuang.com/kubernetes-notes/storage/persistent-volume-claim.html
PersistentVolumeClaim 1. PVC概述 PersistentVolumeClaim（简称PVC）是用户存储的请求，PVC消耗PV的资源，可以请求特定的大小和访问模式，需要指定归属于某个Namespace，在同一个Namespace的Pod才可以指定对应的PVC。
当需要不同性质的PV来满足存储需求时，可以使用StorageClass来实现。
每个 PVC 中都包含一个 spec 规格字段和一个 status 声明状态字段。
kind: PersistentVolumeClaim apiVersion: v1 metadata: name: myclaim spec: accessModes: - ReadWriteOnce volumeMode: Filesystem resources: requests: storage: 8Gi storageClassName: slow selector: matchLabels: release: "stable" matchExpressions: - {key: environment, operator: In, values: [dev]} 2. PVC的属性 2.1. accessModes 对应存储的访问模式，例如：ReadWriteOnce。
2.2. volumeMode 对应存储的数据卷模式，例如：Filesystem。
2.3. resources 声明可以请求特定数量的资源。相同的资源模型适用于Volume和PVC。
2.4. selector 声明label selector，只有标签与选择器匹配的卷可以绑定到声明。
matchLabels：volume 必须有具有该值的标签matchExpressions：条件列表，通过条件表达式筛选匹配的卷。有效的运算符包括 In、NotIn、Exists 和 DoesNotExist。 2.5. storageClassName 通过storageClassName参数来指定使用对应名字的StorageClass，只有所请求的类与 PVC 具有相同 storageClassName 的 PV 才能绑定到 PVC。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b3f8e4d49589c4452db0a07d619d824/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/439eb904a818b71ba2f4714f7215fe63/" rel="bookmark">
			浅聊个性化推荐系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 之前在一家游戏公司做项目管理。初步学习了一下个性化推荐系统，自己做一个总结并发散下思维，现在分享到博客园。
概念 我觉得我们可以从拆词游戏玩起来。个性化推荐系统，可以从“个性化”，“推荐”，“系统”来聊。
“个性化”是目的；“推荐”是手段；“系统”则是技术核心；
“个性化”就是向每个用户提供定制的符合其兴趣偏好的物品，从而达到千人千面的效果。举个简单的例子，大家都知道的抖音，笔者本身就是一个抖音重度使用者，每天上班没时间刷，那么上下班路上和晚上睡觉前都会忍不住去刷抖音。有时候我会问自己，“为什么会上瘾？”最终得到的核心答案是“抖音了解我，甚至比我自己更了解我！”。了解我到什么程度呢，也就是我不会让别人玩我的抖音，因为他会知道我的兴趣爱好是什么，抖音会暴露我的内在心理活动。
主动让网易云音乐了解我。在举个网易云音乐的例子，网易云音乐我用的最多的音乐播放器了，虽然很多音乐的版权它都没有，但是它的个性化推荐系统还是可以学习的。
上面是我自己的“每日推荐”和“我喜欢的音乐”的界面。我每天都会打开“每日推荐”，然后一首一首的听里面的歌，好听的我就点击“喜欢”并且疯狂循环播放，不喜欢的我就点击“不感兴趣”。一段时间后，我会发现“每日推荐”里的歌曲都是我喜爱的，有一种在训练产品的感觉。
“推荐”是一个过程。为什么要推荐，因为其实在很多时候，用户对于自己的需求也是不明确的，依旧拿网易云音乐来说，用户在需要听歌时打开播放器，但是对于具体想听什么类型歌曲，摇滚还是民谣？还是纯音乐？或者单纯的最近网红歌曲？用户的需求是模糊的，这时候他就需要一个被动的被推荐过程，这也是“每日推荐”解决的痛点之一。像搜索这类有目的性的操作往往是用户主动型的，这与推荐正好相反。
“系统”，既然被称为“系统”，说明这是一套由多个功能模块组成的整体。各个模块之间相互影响，最终把个性化信息推荐给用户。这里面涉及到很多模块，比如用户行为数据，内容信息的属性数据，物品属性，还有就是推荐系统的核心算法引擎。
个性化推荐系统的优势 在早期的推荐，往往是简单的物品分发机制，举个栗子，我在使用一款直播APP时，我分别安装两次，在安装时分别把性别设置成男和女，但是推荐的内容却是一模一样的。蛋疼，难道对于直播内容，男女的喜好都是一样的吗？虽说是冷启动时期，但是对于性别这样重要的属性是否考虑推荐不同内容？再说现在的内容类产品，特别是目前流行的短视频应用，新闻类应用，可以说是信息负载，那么对于这些海量信息，如何让用户快速找到自己感兴趣的产品，这时候个性化推荐就派上了很大的用处，举例“今日头条”。而且在内容类产品还有一个问题就是存在马太效应，就是热门的信息越来越热门，冷门的信息越来越冷门，那么数量巨大的长尾信息如何曝光呢？个性化推荐系统也是一个比较好的解决方案。
业务数据获取 说了那么多，那么个性化推荐系统毕竟是要有一个最重要的影响因素，就是有用数据。“系统”的成功落地是基于优质算法和有用数据的结合。那么具体有哪些数据呢？
能反应用户兴趣爱好的数据，最简单的就是让用户填兴趣爱好信息等物品属性，例如资讯类的标题，作者，正文内容，发布时间等用户属性，性别，职业，年龄，地址，单身情况，学历，收入等用户行为数据，点击，浏览时间，点赞，收藏，评论，转发基于社交网络的数据，比如获取用户通讯录信息，微博登录时获取微博关系网络信息。我到现在还没到明白抖音的社交数据从哪里来的，我小姨和我没有通话记录，通讯录没有她号码，我抖音也没有给她关注，点赞等任何操作，但是经常推送我小姨的视频（可能认识的人）。我只有我小姨微信号，但是我没有用微信在抖音上的任何操作，退一步说抖音和微信在撕逼也不可能把社交信息给抖音。要是有小伙伴知道还希望可以解惑基于上下文的数据，这里又分时间上下文和地点上下文。时间上下文，举个栗子，某外卖APP会根据早中晚用户点外卖类型来推送不同的食物，比如早上推送粥，中午推送米饭套餐，晚上推送小吃；地点上下文，比如推送给你周围的餐厅，而不是很远的餐厅用户消费水平数据，其实这可以放在用户属性里，但是我觉得比较重要就拿出来单独一点。对于消费型平台APP尤其要关注用户消费水平。举个栗子，前段时间某消费APP被爆出同一家酒店，同一间房，同一时间点入住，两个用户的价格不一样，相差在几十元。这说明什么？这个APP在根据你的消费水平实时改变物品单价。对于这种行为，的确在产品运营上可以说是创新，但是对于用户而言，一旦发现自己支付单价高于别人，那么那种不平衡的心理会让他觉得你的产品是骗子，最终远离你的产品。所以产品的“三观”我们还是要正视一下的。 先写这么多，有时间再来继续编辑吧
转载于:https://www.cnblogs.com/nanXing/p/11189685.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07d6279a3522c482951e5f8d0f9d1151/" rel="bookmark">
			10款炫酷的HTML5动画特效，附源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML5确实非常强大，很多时候我们可以利用HTML5中的新技术实现非常炫酷效果时，这些效果也非常消耗电脑的CPU，但是这些HTML5效果确实能给用户带来不一样的用户体验。
今天我要跟大家分享一些HTML5实现的惊艳特效，希望你可以喜欢。
1、HTML5 Canvas粒子模拟效果 这是一款利用HTML5 Canvas模拟出来的30000个粒子动画，当你用鼠标在canvas画布上移动时，鼠标周围的一些粒子就会跟着你移动，并形成一定的图案，就像你在玩沙画一样，效果非常不错。
这里，我们应用了一些HTML5的特性，让这个粒子动画显得相当动感。
2、基于 ApexCharts 的 HTML5 曲线图表 可选取数据范围 ApexCharts是一款基于JavaScript和HTML5的现代化图表库，功能十分强大。 我今天分享的这款曲线图表便是基于ApexCharts实现的，图表最终以SVG的形式展示在浏览器上。 这款图表的另一个特点是可以自定义选取数据的范围，范围确定后，图表中同时显示该范围中的曲线图形和柱状图形。 3、HTML5 Canvas图片马赛克模糊动画
我们经常可以在网上或者电视上看到被马赛克模糊的图片或者视频，而下面这个效果是利用HTML5 Canvas技术来实现图片的马赛克模糊效果。
在演示中我们可以拖动滑竿来设置马赛克模糊的程度，你可以在不同的值下观察图片被马赛克后的效果。
4、HTML5 Canvas实现会跳舞的时间动画 这是一款很有意思的HTML5 Canvas时间动画，总体来说，它是一个可以和客户端同步的时钟，其特点是当时间走动时，数字将会散落成一个个粒子动画。
5、HTML5 Canvas粒子效果文字动画特效 这是一款基于HTML5 Canvas的文字特效，输入框中输入想要展示的文字，回车后即可在canvas上绘制出粒子效果的文字动画，相当酷的动画效果。
6、HTML5火焰文字特效 这款HTML5文字特效是火焰燃烧的效果，比较消耗CPU，但是动画效果还是比较酷的。
7、HTML5/CSS3粒子效果进度条 超炫酷进度条动画 之前我已经分享了很多关于进度条的动画效果，像《75款纯CSS3打造的 Loading加载的炫酷动画效果》和《【源码下载】150款+炫酷的CSS3 loading加载动画，总有一款适合你》里面有很多。
而今天这款进度条插件在播放进度过程中出现粒子效果，就像一些小颗粒从进度条上散落下来，是一款别具特色的HTML5进度条插件。
8、HTML5粒子效果的文字动画特效 这是一款基于HTML5的粒子效果的文字动画特效，并且它可以实现每个文字的逐帧播放，形成一句很浪漫的诗句。
9、HTML5 Canvas 3D 倒计时爆炸特效
今天这款 HTML5 3D 动画特效非常给力，它是一个基于Canvas 的倒计时爆炸效果，随着时间的走动，时间数字傍边就会有爆炸的特效，一群像素点就会在数字中心爆发出来，感觉非常酷。而且应用了 HTML5 的 3D 特性，让整一个时钟显得非常有立体感。
10、HTML5房屋装饰工具 自定义房屋各个部位
这是一个基于HTML5和CSS3的房屋装饰工具，工具为房屋的各个部位提供了不同的材料和颜色，点击相应的材料即可将对应部位的材料切换成所选的。
这个工具有点类似人物形象换装工具，可以更换人物每个部位的穿着。另外这个工具的知识点在利用CSS3实现3D的动画特效，当你移动鼠标时你可以看到房屋的各个侧面情况。
写在最后
HTML5 除了实现以上那些功能外，它与WebGL技术相结合，可以实现很多的3D模型结构，像下面这些效果，都是HTML5与WebGL的产物。是不是很炫呀，但就是比较消耗CPU。
前端技术，会随着硬件设备的不断升级，它的体验会越来越好。当然对我们的要求也会越来越高。
最后，我把前面那10款HTML5的效果源码，分享给大家，供大家学习研究使用。
学习源码下载地址：
链接: https://pan.baidu.com/s/1tXx56vkmOv8v1Z5HLpScDw 提取码: tafr 最后，欢迎大家交流学习。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7ba6a59c145fdef95375b0de6226344/" rel="bookmark">
			httpClient 几种超时问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HttpClient的有3种超时时间，分别是： 1、 [java] view plaincopyprint? ConnManagerParams.setTimeout(params, 1000); ConnManagerParams.setTimeout(params, 1000); 2、 [java] view plaincopyprint? HttpConnectionParams.setConnectionTimeout(params, 2000); HttpConnectionParams.setConnectionTimeout(params, 2000);3、[java] view plaincopyprint? HttpConnectionParams.setSoTimeout(params, 4000); HttpConnectionParams.setSoTimeout(params, 4000); 下面分别解释： 1、定义了从ConnectionManager管理的连接池中取出连接的超时时间。 2、定义了通过网络与服务器建立连接的超时时间。HttpClient通过一个异步线程去创建与服务器的Socket连接，这就是该Socket连接的超时时间。 3、定义了Socket读数据的超时时间，即从服务器获取响应数据需要等待的时间。 以上3种超时分别会抛出ConnectionPoolTimeoutException,ConnectionTimeoutException与SocketTimeoutException。 转载于:https://www.cnblogs.com/sunfb/p/3298677.html
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/104/">«</a>
	<span class="pagination__item pagination__item--current">105/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/106/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>