<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b2546c94f5a2c4dd5a43cbf3b049947/" rel="bookmark">
			IOS系统模拟弱网方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语 有些APP开发完成后，需要在3G、山间小涧、电梯等信号不好、网络不稳定的地方进行测试。但是，现实往往不允许我们为了一个真实的弱网环境而消耗人力物力和时间。这时候，我们就需要模拟出一个弱网环境来。这次就说说ios弱网模拟的一种方法。
环境搭建及准备 1.正文内在电脑下载安装xcode；
2.用数据线将电脑和iPhone连接;
3.打开Xcode；
4.打开iPhone，选择【设置】-&gt;【开发者】-&gt;【Network Link Conditioner】-&gt;【Enable】-&gt;点亮Enable后的按钮；
5.此时，就可以根据实际需要来选择不同的环境了。比如：想要3G环境，就点击3G
工具网络、自定义网络及参数解读 自定义网络环境：Add a profile；
bandwidth是带宽，以k/s为单位；packet loss是丢包率，按百分比计算；delay延时，单位是毫秒，1000毫秒等于1秒；
如果新建了自定义网络，一定要在NAME的地方写入这个网络的名字，名字随机填写，中英文不限制，但必须要写，否则不能保存成功，而且软件不会提醒你没有写名字；
工具自身也带了多个选择项，包含以下配置，后面是配置对应的解释
实际界面标注 参考网络环境 1.略受影响的网络
2.较差的网络
3.接近断网
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c845f10ab30ee20e404cc8b4eb77c875/" rel="bookmark">
			PMCAFF上线ChatGPT回复！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PMCAFF是一个面向产品经理的社区，拥有丰富的文章和问答内容，帮助产品经理提升知识水平和实践能力。此外，PMCAFF还提供了ChatGPT的回复功能，使用户可以在线快速获得回答，提高工作效率。
现在就访问www.pmcaff.com提问，体验最新的人工智能回复效果！只需2分钟，就可以快速获得专业的回答，提高工作效率。加入PMCAFF社区，与专业的产品经理一起成长！
PS: 本段内容由ChatGPT编写
⬇️阅读原文，立即体验
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/366ab42313e0abf0b016908efc4b2044/" rel="bookmark">
			SQL调优的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.创建索引 （一）要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引
（二）
(1)在经常需要进行检索的字段上创建索引，比如要按照表字段username进行检索，那么就应该在姓名字段上创建索引，如果经常要按照员工部门和员工岗位级别进行检索，那么就应该在员工部门和员工岗位级别这两个字段上创建索引。
(2)创建索引给检索带来的性能提升往往是巨大的，因此在发现检索速度过慢的时候应该首先想到的就是创建索引。
(3)一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。
二.避免在索引上使用计算 在where字句中，如果索引列是计算或者函数的一部分，DBMS的优化器将不会使用索引而使用全表查询,函数
属于计算的一种,同时在in和exists中通常情况下使用EXISTS，因为in不走索引
效率低：
select * from user where salary*22&gt;11000(salary是索引列) 效率高：
select * from user where salary&gt;11000/22(salary是索引列) 三.使用预编译查询 程序中通常是根据用户的输入来动态执行SQL，这时应该尽量使用参数化SQL,这样不仅可以避免SQL注入漏洞攻击，最重要数据库会对这些参数化SQL进行预编译，这样第一次执行的时候DBMS会为这个SQL语句进行查询优化并且执行预编译，这样以后再执行这个SQL的时候就直接使用预编译的结果，这样可以大大提高执行的速度。
四.调整Where字句中的连接顺序 DBMS一般采用自下而上的顺序解析where字句，根据这个原理表连接最好写在其他where条件之前，那些可以过滤掉最大数量记录。
五.尽量将多条SQL语句压缩到一句SQL中 每次执行SQL的时候都要建立网络连接、进行权限校验、进行SQL语句的查询优化、发送执行结果，这个过程是非常耗时的，因此应该尽量避免过多的执行SQL语句，能够压缩到一句SQL执行的语句就不要用多条来执行。
六.用where字句替换HAVING字句 避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前刷选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数的过滤，除此之外，应该将条件写在where字句中。
七.使用表的别名 当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减少哪些友列名歧义引起的语法错误。
八.用union all替换union 当SQL语句需要union两个查询结果集合时，即使检索结果中不会有重复的记录，如果使用union这两个结果集同样会尝试进行合并，然后在输出最终结果前进行排序，因此如果可以判断检索结果中不会有重复的记录时候，应该用union all，这样效率就会因此得到提高
九.考虑使用“临时表”暂存中间结果 简化SQL语句的重要方法就是采用临时表暂存中间结果，但是，临时表的好处远远不止这些，将临时结果暂存在临时表，后面的查询就在tempdb中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。但是也得避免频繁创建和删除临时表，以减少系统表资源的消耗。
十.只在必要的情况下才使用事务begin translation SQL Server中一句SQL语句默认就是一个事务，在该语句执行完成后也是默认commit的。其实，这就是begin tran的一个最小化的形式，好比在每句语句开头隐含了一个begin tran，结束时隐含了一个commit。
有些情况下，我们需要显式声明begin tran，比如做“增、删、改”操作需要同时修改几个表，要求要么几个表都修改成功，要么都不成功。begin tran 可以起到这样的作用，它可以把若干SQL语句套在一起执行，最后再一起commit。 好处是保证了数据的一致性，但任何事情都不是完美无缺的。Begin tran付出的代价是在提交之前，所有SQL语句锁住的资源都不能释放，直到commit掉。
可见，如果Begin tran套住的SQL语句太多，那数据库的性能就糟糕了。在该大事务提交之前，必然会阻塞别的语句，造成block很多。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/366ab42313e0abf0b016908efc4b2044/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b9e63c2c41e2bdfaf02c7cdc8b8ddd2/" rel="bookmark">
			Redis的六种底层数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis的六种底层数据结构 1、简单动态字符串（SDS）2、链表3、字典哈希表哈希表节点字典 4、跳跃表跳跃表节点（zskiplistNode）跳跃表（zskiplist） 5、整数集合6、压缩列表 本文章内容摘自《Redis设计与实现》一书。
配套网站：http://redisbook.com/
1、简单动态字符串（SDS） Redis 虽然是用 C 语言写的，但Redis没有直接使用C语言传统的字符串表示（以空字符 ‘\0’ 结尾的字符数组），二是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型，并将 SDS 作为 Redis的默认字符串表示。
在Redis里面，C字符串只会作为字符串字面量（string literal）用在一些无须对字符串值进行修改的地方，比如打印日志。
SDS 的定义：
struct sdshdr{ //记录buf数组中已使用字节的数量 //等于 SDS 所保存字符串的长度 int len; //记录 buf 数组中未使用字节的数量 int free; //字节数组，用于保存字符串 char buf[]; } ① free 属性的值为 0，表示这个SDS没有分配任何未使用的空间。
② len 属性的值为 5，表示这个SDS保存了一个五字节长的字符串。
③ buf 属性是一个char 类型的数组，数组前五个字节分别保存了 ‘R’、‘e’、
‘d’、‘i’、‘s’ 五个字符，而最后一个字节则保存了空字符 ‘\0’ 。
（SDS遵循C字符串以空字符结尾的惯例，保存空字符的 1 字节空间不计算在SDS的 len属性里面，并且为空字符分配额外的 1 字节空间，以及添加空字符到字符串末尾等操作，都是由SDS 函数自动完成的，所有这个空字符对于SDS的使用者来说是完全透明的。遵循空字符结尾这一惯例的好处是，SDS可以直接重用C字符串函数库里面的函数。）
SDS 与 C 字浮串的区别：
（1）常数复杂度获取字符串长度
因为 C 字符串并不记录自身的长度信息， 所以为了获取一个 C 字符串的长度， 程序必须遍历整个字符串， 对遇到的每个字符进行计数， 直到遇到代表字符串结尾的空字符为止， 这个操作的复杂度为 O(N) 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b9e63c2c41e2bdfaf02c7cdc8b8ddd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc5ed8acda006b3f8024f3c7f0ab9a25/" rel="bookmark">
			图像处理之频率域数学基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的小程序： 待办计划：卷起来吧，少年！ 我们记账：年薪50w够花么？ 复数
复数C的定义如下：
其中R和I是实数，j是虚数，即。
C的共轭复数C*：
极坐标下表示复数：
其中，是该向量和实轴（x轴）的夹角。
根据欧拉公式：
有：
‘
另外，复函数F(u)可表述为：
其中，R(u)和I(u)分别表示实分量函数和虚分量函数。
一维 冲激 连续变量t的单位冲激表示为：
并且满足如下等式：
一个冲激具有如下的取样特性：
其中f(t)在t=0处是连续的。
在任意点的冲激表示为，它的取样特性为：
。
对于离散变量x，单位离散冲激如下：
并满足：
类似的，有取样特性：
或者：
无限多个分离的周期冲激单元之和是一个冲激串：
下图是一个冲激串：
傅里叶变换 傅里叶变换是空间域到频率域的变换。
连续函数f(t)的傅里叶变换为：
给定可通过傅里叶反变换得到f(t)，即：
上面两式称为傅里叶变换对。
求上图“盒状”函数f(t)的傅里叶变换：
最后一步根据 。另外最后一步是一个sinc函数：
sinc(0) = 1，对于m的其他所有整数，sinc(m) = 0。
傅里叶谱（频谱）为：
和的曲线如下图：
从图中可以看出和的零值位置与“盒状”函数f(t)的宽度W成反比。
前面提到的周期为的冲激串
的傅里叶变换为：
它仍是一个冲激串，周期变为1/。这种周期的反比关系与“盒状”函数及其变换之间的关系是类似的，这点很重要。
卷积 两个函数的卷积用表示（定义）：
卷积定理（与傅里叶变换的关系）：
其中，分别是f(t),h(t)的傅里叶变换，表示左边的式子通过傅里叶变换得到右边的式子，右边的式子通过傅里叶反变换得到左边的式子。如：
取样 取样的方法是用一个周期为的冲激函串作为取样函数去乘f(t)得到：
每个取样值可通过积分得到：
取样的傅里叶变换 取样后的函数的傅里叶变换是：
其中是冲激串的傅里叶变换，即：
由卷积的定义可继续得到：
最后一步根据冲激取样特性。上式表明，取样后的函数的傅里叶变换是的一个拷贝的无限、周期序列，拷贝间的间隔由1/决定。
下图中，图a是函数f(t)的傅里叶变换的简图，图b~d是不同的1/对应的，分别是过取样，临界取样和欠取样：
如果能从包含的拷贝的周期序列中分离出的一个拷贝，那么就可以从取样后的版本复原f(t)。上图中的欠取样情况图d，由于取样率1/偏低，不能保持的完整性，就不能从中完全回复f(t)。我们考虑临界取样的情况图c，将其放大：
从图中可以看出，要保持的完整性，拷贝间的距离要足够，即要求，或：
这就是取样定理：如果以超过函数最高频率的两倍的取样率来获取样本，连续的带限函数可以完全从它的样本集恢复。
带限函数：以原点为中心的有限区间（宽带）[]之外的频率值，其傅里叶变换为零的函数f(t)。如下图：
以下图过取样的情况为例，来看如何从复原f(t)：
图b的函数由下式定义：
根据：
可通过下式得到：
再通过傅里叶反变换复原f(t)：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc5ed8acda006b3f8024f3c7f0ab9a25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5f80776bc3f61010d65a519b4f15837/" rel="bookmark">
			Sekiro RPC框架部署使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关链接 点击 进入Sekiro框架官网 点击 进入JsRpc 项目地址 点击 进入Sekiro下载地址 点击 进入Sekiro-Client.js源码 一，下载地址 下载地址(https://oss.iinti.cn/sekiro/sekiro-demo)
二，运行(依赖java环境，自行安装) # win 运行 bin/sekiro.bat # linux 运行 bin/sekiro.sh 三，编写油猴脚本 （1） 编写好油猴脚本框架 // ==UserScript== // @name Sekiro // @namespace http://tampermonkey.net/ // @version 0.1 // @description try to take over the world! // @author You // @match http://www.nhc.gov.cn/* // @icon https://www.google.com/s2/favicons?sz=64&amp;domain=nhc.gov.cn // @grant none // ==/UserScript== (function() { 'use strict'; // Your code here... })(); （2）创建script标签引入Sekiro-Client.js（也可以直接复制这段js源码写入到油猴中） /** * 创建script标签引入js,省去复制源码的步骤 */ var newElement = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5f80776bc3f61010d65a519b4f15837/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e4845e8b004d571911f4ca3286e13a6/" rel="bookmark">
			linux mint无法启动，开机出现Firmware Bug:TSC_DEADLINE disabled due to Errata
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决：
在错误界面输入exit，查看提示哪个盘出错，其实就是系统启动盘；输入fsck -y /dev/你的启动盘。比如我的启动盘是/dev/sdb5，就输入fsck -y /dev/sdb5；（修复文件系统）再输入exit重新进入系统，应该就可以了。 我的小程序： 待办计划：卷起来吧，少年！ 我们记账：年薪50w够花么？ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e36b00f6397b734e033e39b0b5460d69/" rel="bookmark">
			【源码详解~蓝桥杯单片机必备技能】1.利用状态机思维实现矩阵键盘扫描
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按键长按、双击看下一篇文章
0.引言： 大一啥都不会，傻傻参加蓝桥杯单片机比赛，代码也几乎仿照网上的风格，现在学过STM32后，再来写51的代码，发现许多可以改进的地方，就从按键扫描开始。网上利用状态机思维实现的矩阵键盘扫描要么过于臃肿、不适合蓝桥杯比赛的限时性，要么封装严重、过于抽象化，本文将利用状态机，结合51单片机特点实现小白也能看的懂的矩阵键盘扫描程序 。
文章目录 0.引言：1.状态机概念：2.利用状态机思维实现矩阵键盘扫描的优势：3.按键过程抽象：3.1.按键状态分类3.2.按键状态转换图 4.代码逐句分析： 1.状态机概念： 状态机（英语：finite-state machine，缩写：FSM）是一个抽象的概念，表示把一个过程抽象为有限个状态之间的转移，且这些状态之间存在一定的联系。
状态机主要包括四个要素：
现态：是指当前所处的状态。条件：当一个条件满足后，将会触发一个动作，或者执行一次状态的迁移。动作：条件满足后执行的具体操作。动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。动作不是必需的，当条件满足后，也可以不执行任何动作，直接迁移到新状态。次态：条件满足后要迁往的新状态。“次态”是相对于“现态”而言的，“次态”一旦被激活，就转变为新的“现态”了。 2.利用状态机思维实现矩阵键盘扫描的优势： void Scan_Keys() { //S4按键检测 if(S4 == 0) { DelaySMG(500); //去抖动 if(S4 == 0) //按下S4按键 { /*......*/ } else { /*......*/ } while(S4 == 0); //松手检测 } } 传统按键检测运用delay函数延时消抖，不仅占用MCU的执行时间，而且在延时的时候MCU无法执行其他程序，降低MCU的利用率，并且经常和数码管显示、点灯冲突。
而利用状态机思维实现的按键检测算法，bug少，算法成熟，可以大大增加程序的稳定性。
3.按键过程抽象： 3.1.按键状态分类 根据状态机的原理，我们可以将按键过程抽象为三个状态：
按键抬起状态（KEY_UP）：按键没有按下。
按键消抖状态（KEY_DEBOUNCE）：消除按键抖动。
按键按下状态（KEY_DOWN）：确认按键已经按下。
3.2.按键状态转换图 基于蓝桥杯单片机开发板按键所处IO口，0是按下，1是没按。按键状态转换图如下：
4.代码逐句分析： 本历程通过2×2矩阵演示（S13、S12、S16、S17）（蓝桥杯比赛历届赛题考矩阵键盘都是2×2，除了很早以前一届是3×4）
#include "STC15F2K60S2.h" //矩阵键盘的行列定义 sbit Heng1 = P3^3; sbit Heng2 = P3^2; sbit Lie1 = P3^5; sbit Lie2 = P3^4; #define Key_Num 4 #define uint8_t unsigned char #define uint16_t unsigned int typedef enum { KEY_UP = 0, KEY_DEBOUNCE, KEY_DOWN }KEY_STATE; //按键的现态，通过枚举类型实现，也可以简单的用数组，但代码可读性差 //数组的特性，部分初始化对于没给初值的其他数组元素自动补0 KEY_STATE KeyState[Key_Num] = {KEY_UP}; uint8_t KeyFlag[Key_Num] = {0}; //按键按下标志，1按下，0没按 void Key_State(uint8_t i,bit Lie) { switch(KeyState[i]) { case KEY_UP: //按键没按下状态 { if(Lie == 0) //读到低电平，按键进入抖动状态 { KeyState[i] = KEY_DEBOUNCE; } } break; case KEY_DEBOUNCE: //按键抖动状态 { if(Lie == 0) //读到低电平，按键进入按下状态，并将按键按下标志置1 { KeyState[i] = KEY_DOWN; KeyFlag[i] = 1; } else //读到高电平，按键进入没按下状态 { KeyState[i] = KEY_UP; } } break; case KEY_DOWN: //按键按下状态 { if(Lie == 1) //读到高电平，按键进入没按下状态 { KeyState[i] = KEY_UP; KeyFlag[i] = 0; //防止一个按键在被按下同时，按另一个按键依然有效，保 证同一时间只有一个按键按下有效 } break; } } } void Scan_Key() { //列扫描先将列上面的所有IO口拉高，再把行上面的IO口拉低，当其中有一列内任何一个按键按下，那么整列被拉低，通过行和列，确定是哪个按键按下 Lie1 = 1; Lie2 = 1; Heng1 = 0; Heng2 = 1; Key_State(0,Lie1); //扫描S12按键 Key_State(1,Lie2); //扫描S16按键 Heng1 = 1; Heng2 = 0; Key_State(2,Lie1); //扫描S13按键 Key_State(3,Lie2); //扫描S17按键 } void Init_Timer0() //定时器设置为10ms，即每10ms扫描一次矩阵键盘，有效防止按键抖动 { TH0 = (65536 - 10000) / 256; TL0 = (65536 - 10000) % 256; TMOD = 0x01; //定时器设置为16位不自动重装模式 ET0 = 1; TR0 = 1; EA = 1; } void Service_Timer0() interrupt 1 { TH0 = (65536 - 10000) / 256; TL0 = (65536 - 10000) % 256; Scan_Key(); //调用按键扫描函数 } void Key() { if((KeyFlag[0] == 1)&amp;&amp;(KeyFlag[1] == 0)&amp;&amp;(KeyFlag[2] == 0)&amp;&amp;(KeyFlag[3] == 0)) { /*S12按键执行内容.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e36b00f6397b734e033e39b0b5460d69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/005f7cd61ae3105b255f3af626af57da/" rel="bookmark">
			rabbitmq 消息类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		收发模式
P将消息发送给队列，C从队列里去取（可以同步和异步）
工作分配
P将消息发送给队列，由消费者抢占式（轮流式）消费，一个消息只能被一个消费者接收
发布订阅
P将消息发布到X（Exchanges 交换机）由交换机路由到不同的队列
交换机(X)的四种类型fanoutdirectheaderstopic fanout类型，会将消息分发到所有绑定的队列，如下图的q1和q2
direct，可以根据routingkey分发到不同的队列，如下图的info分配到q1，error和warning的key 分配到q2队列
topic，可以指定匹配模式
以下消息会被q1和q2命中
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48b3c6a79ab7249b9c4d15e7ff9208f7/" rel="bookmark">
			【信贷业务】金融信贷存量客户运营管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：金融信贷存量客户运营管理
原作：Bonus_F
前言 近几年随着消费金融在我国的快速发展，银行零售业、消费金融公司、互联网金融等迎来了一个爆发式的增长，人均授信总额不断增加即居民杠杆率持续攀升。伴随着市场竞争日趋激烈、客群不断下探、监管收紧的大背景下，互联网金融、小贷公司、P2P行业洗牌和业务调整，将会导致次级下沉客户向银行、持牌消费金融公司传导，使共债风险持续增加、坏账率增高。因此，新客带来的业务增加将会遇到一个瓶颈期，各大金融机构缩减新客获取，至此国内消费金融市场将进入存量客户精细化运营管理时代。
一.存量客户精细化管理的必要性 1、新户成本上升
当前新户审批通过，客户激活和支用率普遍不高，各银行在优质客户获取上营销费用也直线上升，最高单客成本接近500元/人，而2017年初时，成本仅为70元左右；非银机构的获新成本基于不同贷超导流的新客提现成本最低已达到400元/人，部分渠道的新客提现成本甚至已突破2000元/人。
2、新户风险激增
受疫情影响，金融行业整体的欺诈风险、信用逾期风险持续走高。中美贸易摩擦、因疫情带来的全球性消费疲软和中小微企业严峻的生存压力将会传导至微观个体，部分客户将出现还款能力下降，特别是资质相对更差的次级客群，其受到的影响更大。而为了应对疫情，防范金融风险，各家金融机构必将进行业务调整，降低整体授信额度，收缩业务。而对于共债风险本身就高的次级人群而言，信贷需求未减的情况下，供给却大幅萎缩，因此他们中的一部分人转而通过欺诈手段，突破金融机构风控防线、获得贷款的动力更充足。另外，由于疫情的影响，个人消费减少，资质相对较好的客户借贷需求降低，客观上减少了总体人群中优质客户的数量，导致欺诈客户的占比升高。
3.存量客户风险及收益
信贷业务的主要收入都来分期业务的手续费收入、循环信用的利息收入和符合相关规定的合法收入等，银行信用卡业务除了传统信贷的业务收入外还包括年费、刷卡消费的佣金收入；而客户的成本主要是获客成本和风险损益，其中很大一部分来自于因客户逾期导致的风险损失。金融机构若想提高业务的利润率，追求利润最大化，必须从成本和收入两方面考虑问题，即在尽可能提高营业收入的同时，尽量减少各成本项。因此好的运营管理，既需要提升贷前风控能力和贷中风险管理能力，又需要提升客户价值。客户价值提升，新客放款流程的简化、通过率和支用率的提高，存量客户激活、默客促活、产品营销响应、客户流失预警和客户价值评估等方式方法，扩大新客群体，提高客户对循环信用、取现、消费分期、额度外现金贷等高价值产品的使用率，从而整体推高营业收入。贷中风险管理，采用客户画像等技术通过提前预判客户在还款能力和还款意愿上的变化，并根据这些洞察，采取相应的干预措施，防止信贷资产的风险恶化，从而减少未来因逾期导致的风险损失。相比新客来说，存量客户因为有贷后表现，风险相对可控，也没用新客的获客成本，因此存量客户管理至关重要，好的运营管理在不断提高营业收入，降低未来风险损失的同时，提高客户黏性，使得客户持续为金融机构创造价值。
二、信贷存量客户数字化运营 1、基于自生态的存量客户经营不能满足数字化运营的需求
金融机构一直以来都会基于已有数据开展自生态体系内的存量客户经营，其中传统运营的主要痛点如下：
运营管理主要依赖于业务人员经验，通过简单的业务规则进行风险预警，且无法对业务规则进行定期评估和优化。
人员密集型运营，人力资源投入较大，对沉默客户没有好的出活手段。
缺乏动态额度调整策略或者调额体系，用户体验不佳，易造成客户流失。
差异化管理难实现。缺少用户画像，差异化营销和风控和服务没有抓手，广撒网式的营销方式导致促活率或转化率低；对不同账龄的客群，采用同一套贷中管理策略，效果不佳。
IT解析要求高。金融机构存量客户规模大，需要强大的动态监控和IT解析能力，受系统解析能力限制，监控周期相对较长。
存量客户价值挖掘不够。海量数据分散，缺乏标准化的统一管理，缺乏投入和挖掘。难以识别高价值客户, 缺乏对长尾客户金融需求、金融风险的识别能力。
客户动态无法实时监测
随着行业竞争加剧，互金、信托、基金等渠道分流了传统金融机构大量存款和贷款客户，客群分层且风险动态化；基于自有系统和生态体系内的数据无法做到及时有效的识别，也缺乏待营销客户、待转化客户在自身内的市场需求。 2.信贷机构数字化运营方向
精准化运营的前提是客户关系管理，而客户关系管理的核心是客户分层。针对不同的客户推行不同的策略，实现精准化运营，以期获取最大的转化率。
数字化的存量客户经营策略需从产品体验、运营效率、品牌口碑三个方面着手建立存量客户数据运营体系，包括存量数据处理、客户画像标签体系搭建、建模平台建设、IT基建、策略平台五大模块。依靠流量入口APP和合作方引流渠道，整合内部生态和外部三方数据，探索和构建数字化获客模型，并结合各类营销手段推进存量客户数字化经营，对客户全生命周期价值进行深度挖掘打造新的获客增长点，在严控风险底线的大前提下，获取客户价值，优化数字获客结构，深化风控体系建设。
备注：来源于索引文章，仅供参考
1、明确存量客户定义
常见的存量客户包括五大类：断点客户、拒绝客户、集团客户、低价值客户、交叉营销客户；
1.断点客户：申请人可能由于事务打断、申请过程繁琐、需求变化等因素中断申请。
2.拒绝客户：金融机构从之前被拒绝的客户中，识别风险降低的客户，结合当前申请人的需求，形成再审批名单。
3.集团客户：集团各类业务积累的客户不能直接传递给金融机构，可通过过存量客户精准分层找到有意向客户，通过机器人营销，引导客户向金融机构申请，形成集团内部联动。
4.低价值客户：低价值客户包括非活跃客户、授信但未提现/消费的睡眠客户，但这类客户可能是其他金融机构的高价值客户，可通过交叉营销的方式促进客户活跃。
5.交叉营销客户：如储蓄客户转信用客户、消费分期客户转现金贷客户、现金贷客户转小微客户等，可以先做客户的分层，找准转化意向强的客户进行营销。
2、明确数字化运营目标
其主要的思想是基于对历史数据的探索和分析，开发基于数据驱动的规则和模型，结合业务人员经验，对未来逾期风险做出准确预警，并使用结果数据，不断优化原有规则模型，形成闭环，主要有以下几点：
根据客户的风险水平和客户价值，制定动态额度调整体系，提高支用率和复借率；
价值提升环节，使用机器学习算法构建各类模型，在高价值产品的交叉营销活动中，根据预测的客户响应度和对产品的需求度，采取差异化的营销策略和方式，一方面提高营销响应，另一方面有效避免营销资源浪费；
通过数据分析，挖掘那些高价值沉默客户，总结其行为特点，构建促活响应模型，制定差异化的促活策略；
技术密集型运营，引入人工智能和自动决策工具，替代人工，减少人力运营成本。
在具体的数字化运营目标中可将存量客群定义和分类为以下几类：
（1）存量客户风险预警：通过动态监控的方式实时了解贷款合约期内的客户的风险变化，以达到逾期风险早发现、早提醒、减少坏账的目的。
（2）休眠客户促活：针对本机构真假睡眠用户识别及促活；真睡眠客户是不仅在本机构失活，在全平台都表现出失活特征；假睡眠用户是指本机构失活客户，但在其他平台有借款，可捕捉假睡眠客户，及时营销促活。
（3）高价值客户流失预警：在本机构一般活跃，近期在其他机构非常活跃的高价值客户，提前进行预警及权益推送。
（4）存量客户交叉营销：结合营销规则、营销评分精准识别现有活跃客户的新增需求，如实时的新增贷款需求，形成优质客户白名单，并可通过智能机器人进行外呼，进行客户的触达，加深客户粘性。
备注：以银行零售业务中信用卡存量客户为例，图片来源于参考文章
3、存量客户标签体系搭建
基础标签体系的搭建，主要以当事人维度，对金融机构数据集市/数据仓库中相关库表进行梳理，并按数据禀赋类型进行基础标签分类，然后基于基础标签，提炼衍生出供业务使用的高级标签。
针对每类待营销客户，需额外提取强相关变量。以已结清客户为例，已结清客户的用户价值模型核心指标包括：
（1）复贷周期：紧抓客户复贷黄金营销时间段。一般以7天为互联网通用客户活跃期限；35天（5周）为营销周期；从还款时间开始取值。
（2）借款频率：基于客户借款频率、借款偏好确定用户价值。具体字段包括金融机构掌握的本机构不同信贷产品的借款频次、外部全行内不同信贷产品的借款频次。
（3）借款金额：基于客户借款金额确定客户创收价值。一般取放款金额，用年化方法做归一，并用1234或ABCDE法分群。
4、存量客户价值评分体系搭建-实现精准分层
在建立完善的存量客户标签库后，金融机构基于营销目标开发白名单筛选规则、营销响应分，整个精准分层精准围绕目标分层、营销执行、标签记录、模型调优等步骤展开。
（一）贷中风险管理构建方案
贷中风险管理至少应包含贷中预警策略、行为评分模型及配套应用策略等。
在贷中预警的初级阶段，可以基于标签表现，挖掘区分能力强的变量，生成命中率低且准确率高的强规则，对命中规则的客户给予红色预警。在数据挖掘阶段，重点关注客户的用卡行为、还款行为及逾期行为相关的变量。
业务成熟阶段，根据客户的行内外数据，开发贷中行为评分模型，预测客户在贷中阶段由正常客户转为逾期客户的概率；根据不同的风险等级给予不同的风险预警策略，实现贷中风险预警的目的；同时结合对客户的价值评估果，给出相应的动态调额策略和定价调整策略（图中策略仅为示例，具体情况视业务而定）。
备注：以银行零售信用卡客户为例，图片来源于索引文章
（二）存量客户价值提升构建方案
客户价值评估模型
使用行为评分模型对存量客户进行风险评分后，对于高风险客户需提前采取风险预警措施，包括预催收、甚至降额止付等，对于中低风险客户，需要进一步评估客户价值，从而进行动态额度调整及其他价值提升的营销活动。客户价值评估模型是存量客户价值提升的基础模型，其结果与行为评分模型结果形成交叉矩阵，指导风险预警及动态额度调整和其他基于客户价值的一系列活动。交叉矩阵可以将存量客户划分为四类客群，分别为主动的正向、被动的正向、被动的负向、主动的负向客群，根据不同客群的特征制定相应的策略。
备注：图片来源于索引文章 交叉营销模型
风险水平较低及还款行为较好的优质客户对现金分期、现金贷等的信贷服务的需求不同，因此对产品交叉营销的响应程度也不同，金融机构应尽可能的找到响应程度高的优质客户，从而将营销资源进行重点投入。交叉营销模型可通过对历史的产品销售数据和营销数据进行分析和挖掘，总结使用基于特定场景的信贷产品的客户特点，从而对存量客户做出总体预测；模型使用的变量包括但不限于：客户基本信息、客户消费习惯和消费偏好、交易行为信息及还款及逾期信息等。外部三方数据等将有效提升模型对高响应客户的识别能力。模型构建完成后，对存量客户进行整体预测，根据模型分数排序，选择响应度较高的客户形成营销名单，开展相应的营销活动；以信贷场景存量客户交叉营销为例，基于营销响应分、营销成单分，精准从沉睡客户/流失客户中找到贷款需求高的客户，作为精准营销对象，通过对高响应客户进行短信、IVR、人工等手段进行营销，可提高营销响应率，有效节约成本；同时无需求的客户不会被营销打扰，有需求的客户可及时找到合适的产品，用户体验逐步提升。
激活响应模型
基于历史数据来构建激活响应模型，挖掘那些支用或者活跃客户的行为特征（包括消费偏好、消费习惯、交易习惯等等），从而对未来客户能否支用和激活作出预测，并根据客户的响应程度，采取不同的促活策略。根据实际情况，可以构建是否支取并消费的单一模型，也可拆分是否消费后是否活跃两个细化模型。对于未来极易支取并消费的客户，可能使用最基本的触达方式，如微信、银行短信方式就可奏效；对于响应程度一般的客户，可能需要使用短线触达+息费优惠的政策；对于响应程度最低的客户，需要使用人工外呼触达+息费减免政策或首刷赠礼等政策最大程度的吸引客户。
客户流失预警
优质客户下迁最后流失，应尽力避免此类事件的发生。因此，应尽早发现具有流失倾向的优质客户，并采取能使其继续留存在我行的维挽措施。根据历史数据可构建流失预警模型，根据不同程度的流失倾向客户，结合客户价值，采取不同的返利措施进行客户维挽。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48b3c6a79ab7249b9c4d15e7ff9208f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54c7ebc0e57f6c450a1483d96aa44dba/" rel="bookmark">
			安装配置NFS文件服务器及挂载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、安装NFS服务器：apt-get install nfs-kernel-server
2、设置共享文件夹：vim /etc/exports，添加要共享的（多个）目录，如：
/home/sl/ding *(rw,sync,no_root_squash)
/home/hhit/workspace *(rw,sync,no_root_squash)
（前面那个目录/home/sl/ding是与nfs服务客户端共享的目录，*代表允许所有的网段访问（也可以使用具体的IP）
rw：挂接此目录的客户端对该共享目录具有读写权限
sync：资料同步写入内存和硬盘
no_root_squash：客户机用root访问该共享文件夹时，不映射root用户。（root_squash：客户机用root用户访问该共享文件夹时，将root用户映射成匿名用户））
3、重启NFS服务
/etc/init.d/rpcbind restart
/etc/init.d/nfs-kernel-server restart
4、在客户端挂载服务器目录：mount -t nfs -o nolock 服务器IP:共享目录 客户端目录。如：mount -t nfs -o nolock 192.168.1.162:/home/hhit/workspace /home（取消挂载：umount /home）
我的小程序：
待办计划：卷起来吧，少年！ 我们记账：年薪50w够花么？ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a58d89077e879730b898505d2a300817/" rel="bookmark">
			在TX2平台编译安装飞桨Paddlepaddle
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装nccl:
git clone https://github.com/NVIDIA/nccl.git
cd nccl
make -j4
sudo make install
配置CUDA:
(Bashrc配置:)
export PATH=/usr/local/cuda-10.2/bin:$PATH
export LD_LIBRARY_PATH=/usr/local/cuda-10.2/lib64:$LD_LIBRARY_PATH
下载Paddle-2.1.0源码并解压:
https://github.com/PaddlePaddle/Paddle/archive/refs/tags/v2.1.0.zip
paddle源码编译
cd Paddle-2.1.0
mkdir build
cd build
cmake .. -DWITH_GPU=ON -DWITH_TENSORRT=ON -DWITH_CONTRIB=OFF -DWITH_TESTING=OFF -DCMAKE_BUILD_TYPE=Release -DON_INFER=ON -DWITH_PYTHON=OFF -DWITH_XBYAK=OFF -DWITH_NV_JETSON=ON -DPY_VERSION=3
make -j4
我的小程序： 待办计划：卷起来吧，少年！ 我们记账：年薪50w够花么？ 参考链接：Jetson Nano上部署PaddleDection 原生预测方法经验分享 - 知乎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/688e05a42e383500ca0a5919ccdece74/" rel="bookmark">
			PICT测试用例设计工具的介绍和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、PICT是什么❓ “PICT工具”是针对“pairwise testing”实现的测试用例设计工具。通过他，我们可以直接将“正交表”转换为测试用例。pairwise testing直译中文是“成对测试”，是一种正交分析的测试技术。
“pairwise testing”能够覆盖因子取值的所有两两组合。在实际对缺陷的统计分析发现，相对于多因子的组合，大部分问题是可以通过因子的两两组合来发现，多个因子组合仅会发现少量的问题，但是多个因子的测试投入却是巨大的。所以来说，两两组合可以更有效的发现缺陷。
二、PICT的安装 1.Windows操作系统 下载地址： http://www.pairwise.org/tools.asp下载pict工具(pict.exe、PICTHelp.htm)
下载成功后，将pict工具解压后放在c:\PICT目录下
2. Mac系统 第一种方式：使用brew安装
终端直接输入：brew install pict
效果如下：
第二种方式：源码编译 (我没有尝试过，读者可以自行尝试)
先克隆到本地：git clone https://github.com/microsoft/pict.git
然后进行编译 ： make
cp pict /usr/local/bin
三、PICT的使用 比如，我们要分析的因子表是这样的：
行号
factor A
factor B
factor C
factor D
1
A1
B1
C1
D1
2
A2
B2
C2
D2
3
B3
C3
D3
4
C4
根据上面的因子表，我们现在将以数据按照下面的格式写入一个文件中，文件名为testpict.txt
factor A: A1,A2
factor B: B1,B2,B3
factor C: C1,C2,C3,C4
factor D: D1,D2,D3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/688e05a42e383500ca0a5919ccdece74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c82acc596d94817f6f6a04533017d36/" rel="bookmark">
			【沧海拾昧】C#调用Python代码的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#C0204
沧海茫茫千钟粟，且拾吾昧一微尘 ——《沧海拾昧集》@CuPhoenix
【阅前敬告】 沧海拾昧集仅做个人学习笔记之用，所述内容不专业不严谨不成体系 【如有问题必是本集记录有谬，切勿深究】 目录 前言一、测试环境准备二、实现过程1、准备 .py 文件2、C# 实现3、运行结果 前言 在使用 C# 调用 Python 代码时，有多种方法，如将Python封装为动态链接库 .dll 、用 IronPython 作为移植的依赖库直接调用 Python 的函数接口等，但在开发时最简单实用的方法莫过于利用 C# 命令行调用 .py 文件执行。
本文记录了在利用 C# 命令行调用 .py 文件执行的方法与可能遇到的常见问题。
一、测试环境准备 为演示如何 C# 命令行调用 .py 文件执行，本例的实现功能与准备如下：
实现功能：
单击 C# 窗口中的 button1，调用 .py 文件执行一个简单的加法，并将值传回给窗口，显示在 button1.Text 上。 软件版本：
Python 3.6.2 (x86)Visual Studio 2019 二、实现过程 1、准备 .py 文件 准备一段功能简单的 Python 代码作为样例测试所用。代码如下：
#main.py import sys import ctypes from ctypes import * def func(a,b): mydll = CDLL("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c82acc596d94817f6f6a04533017d36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3401201562ca471be9e04f3b83589aa0/" rel="bookmark">
			springboot集成activiti及使用方法（排除spring security）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、activiti依赖及工具 1、springboot依赖 注意排除mybatis和el表达式依赖
&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;7.0.0.Beta2&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;el-api&lt;/artifactId&gt; &lt;groupId&gt;javax.el&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 2、下载idea相关插件 画流程图相关插件
二、配置activiti 1、参数相关介绍如下 spring: activiti: #自动更新数据库结构 #1.flase：默认值。activiti在启动时，对比数据库表中保存的版本，如果没有表或者版本不匹配，将抛出异常 #2.true： activiti会对数据库中所有表进行更新操作。如果表不存在，则自动创建 #3.create_drop： 在activiti启动时创建表，在关闭时删除表（必须手动关闭引擎，才能删除表） #4.drop-create： 在activiti启动时删除原来的旧表，然后在创建新表（不需要手动关闭引擎） database-schema-update: true #activiti7默认不生成历史信息表，开启历史表 db-history-used: true #记录历史等级 可配置的历史级别有none, activity, audit, full #none：不保存任何的历史数据，因此，在流程执行过程中，这是最高效的。 #activity：级别高于none，保存流程实例与流程行为，其他数据不保存。 #audit：除activity级别会保存的数据外，还会保存全部的流程任务及其属性。audit为history的默认值。 #full：保存历史数据的最高级别，除了会保存audit级别的数据外，还会保存其他全部流程相关的细节数据，包括一些流程参数等。 history-level: full # ============================= #自动检查、部署流程定义文件 启动时自动部署定义的流程 check-process-definitions: true # asyncExecutorActivate是指activiti在流程引擎启动就激活AsyncExecutor,异步：true-开启（默认）、false-关闭 async-executor-activate: true #流程定义文件存放目录,要具体到某个目录 # process-definition-location-prefix: classpath:/processes/holliday/ #process-definition-location-suffixes: #流程文件格式 # - **.bpmn20.xml # - **.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3401201562ca471be9e04f3b83589aa0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebd75ea1dccd9310d489bc0430eaa899/" rel="bookmark">
			ping命令一直测试网络丢包原因及处理解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		所谓的网络丢包是我们在使用ping对目站进行询问时，数据包由于各种原因在信道中丢失的现象。ping 使用了ICMP 回送请求与回送回答报文。ICMP 回送请求报文是主机或路由器向一个特定的目的主机发出的询问，收到此报文的机器必须给源主机发送 ICMP 回送回答报文。这种询问报文用来测试目的站是否可到达以及了解其状态。
许多时候，我们可能都会碰到网络连接时断时续的故障现象，面对这种网络故障，不少网络管理员都会使用Ping命令对网络连通性进行测试，测试结果表明此时的网络传输线路数据丢包现象非常严重，那么究竟是什么因素导致了数据丢包现象比较严重呢?是连接线路接触不稳定?是网络病毒?还是其他的潜在因素?
原因一：物理线路故障
网管员发现广域网线路时通时断， 发生这种情况时， 有可能是线路出现故障， 也可能是用户方面的原因。为了分清是否是线路故障，可以做如下测试。
如果广域网线路是通过路由器实现的，可以登录到路由器，通过扩展 ping 向对端路由器广域网接口发送大量的数据包进行测试。如果线路是通过三层交换机实现，可在线路两端分别接一台计算机，并将 IP 地址分别设为本端三层路由交换机的广域网接口地址，使用 “ping 对端计算机地址 – t ”命令进行测试。
如果上述测试没有发生丢包现象， 则说明线路运营商提供的线路是好的， 引起故障的原因在于用户自身，需要进一步查找。
如果上述测试发生丢包现象， 则说明故障是由线路供应商提供的线路引起的， 需要与线路供应商联系尽快解决问题。
由物理线路引起的丢包现象还有很多，如光纤连接问题，跳线没有对准设备接口，双绞线及 RJ-45 接头有问题等。另外，通信线路受到随机噪声或者突发噪声造成的数据报错误，射频信号的干扰和信号的衰减等都可能造成数据包的丢失。我们可以借助网络测试仪来检查线路的质量。
原因二：设备故障
设备故障主要是指设备硬件方面的故障，不包含软件配置不当造成的丢包。如网卡是坏的，交换机的某个端口出现了物理故障，光纤收发器的电端口与网络设备接口，或两端设备接口的双工模式不匹配。
曾看过这样的例子，一交换机端口的光纤模块故障造成的丢包现象， 该交换机在通信一段时间后死机，即不能通信，重启后恢复正常。在经过一段时间观察后发现，某光纤模块存在问题，取一块新的模块替换，一切正常。
究其原因，交换机会对所有接收到的数据包进行 CRC 错误检测和长度校验，将检查出有错误的包丢弃，正确的包转发出去。但这个过程中有些有错误的包在 CRC 错误检测和长度校验中都均未检测出错误，这样的包在转发过程中不会被发送出去，也不会被丢弃，它们将会堆积在动态缓存中，永远无法发送出去，等到缓存中堆积满了，就会造成交换机死机的现象。最终结果是，数据包无法到达目的主机。
原因三：网络拥塞
网络拥塞造成丢包率上升的原因很多，主要是路由器资源被大量占用造成的。
如果发现网速慢， 并且丢包率呈现上升的情况， 这时应该 show process cpu 和 show process mem ，一般情况下发现 IP input process 占用过多的资源。接下来可以检查 fast switching 在大流量外出端口是否被禁用，如果是，则需要重新使用。
再看一下 Fast switching on the same interface是否被禁用，如一个接口配有多个网段并且这些网段间流量很大时，路由器工作在 process-switches 方式，这种情况下要在接口上执行命令“enable ip route-cache same- interface 。”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebd75ea1dccd9310d489bc0430eaa899/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72243202bbe12c9509bfc8264988446d/" rel="bookmark">
			C语言实现一元多项式相加
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言 链表实现一元多项式相加 这里的代码复制后，可以直接运行，按照规定的输入即可得出多项式的结果。 问题描述
设计一种单链表存储结构，每个节点成员有一个系数和一个指数，以及下一个节点的指针，数据类型都是整型，要求：实现多项式输入、相加、输出相加后的多项式。 规则：输入时逐项、按顺序输入一元多项式的系数、指数，输入系数为 0 时表述输入结束，如 p ( x ) = 5 + 2 x + 3 x 5 − 2 x 7 规则：输入时逐项、按顺序输入一元多项式的系数、指数，输入系数为\ 0\ 时表述输入结束，如 \ p(x)=5+2x+3x^5−2x^7 规则：输入时逐项、按顺序输入一元多项式的系数、指数，输入系数为 0 时表述输入结束，如 p(x)=5+2x+3x5−2x7
​ 即输入： 5 0 2 1 3 5 -2 7 0 0
举例：
A(x)=5+2x+3x^5 −2x^7 B(x)=12x+2x^7 +13x^15 则结果多项式为：
C(x)=5+14x+3x^5 +13x^15
这里构建链表创建函数，带头结点的链表，除了头指针，每一个节点存放一个系数和一个指数，通过循环实现输入并存到链表中，最后返回链表的头指针。 #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; //存放多项式某项的结点结构 struct node { int exp ; // 表示指数 int coef ; //表示系数 struct node *next; //指向下一个结点的指针 }; typedef struct node * PNODE ; /* 函数功能：生成多项式 函数名：createPoly 函数参数：无 返回值：指向多项式的头指针 */ PNODE createPoly(void) { //在此处填写代码，能实现创建一个多项式并返回多项式头指针的函数 //注意：头指针不存放多项式的项。 /********** Begin **********/ PNODE head, temp; int coef, exp; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72243202bbe12c9509bfc8264988446d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2881712fdc09db3699eaacafc28c175f/" rel="bookmark">
			树莓派VNC分辨率，修改无效的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树莓派系统版本： 2021-03-04-Raspios-Buster-arm64 sudo raspi-config 开启屏幕设定，因为系统版本不同，菜单位置略有差异，
Advanced Options &gt; Resolution
Display Options &gt; Resolution
最后选择一个更合适的分辨率并确认完成即可。
重启以后，连接VNC分辨率没有变化的化，用下面的方法
# 进入当前目录 cd ~ # 创建Scripts mkdir Scripts cd Scripts # 创建脚本 sudo nano vncserver.sh 构建自启动的脚本 #!/bin/sh
vncserver -geometry 1080x720 :1
sudo chmod 777 vncserver.sh sudo nano /etc/rc.local exit 0 前新增
su pi -c "exec /home/pi/Scripts/vncserver.sh"
重启树莓派，用vnc连接 ip:1 , 注意IP地址的后面加":1"
如果鼠标变成了 X ， 可以用指令 lxappearance
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0b299101b6b2f0bfa3b62887d57934f/" rel="bookmark">
			Nessus 扫描web服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章 Nessus介绍与安装
Nessus Host Discovery
Nessus 高级扫描
Nessus 扫描web服务 1.启动nessus
cd nessus sh qd_nessus.sh 2.进入nessus网站
https://192.168.3.47:8834/ 3.点击【New Scan】
4.点击【Web应用程序测试】
5.输入name【web扫描】，描述【web扫描】，目标【127.0.0.1】
6.点击【发现】
7.选择扫描类型【端口扫描(常用端口)】
8.点击【评估】
9.扫描类型选择【扫描所有web漏洞(快速)】
10.点击【证书】
11.点击【HTTP】
12.选择身份验证方法【自动认证】
13.输入用户名【xiaogang】，密码【123456】（需要扫描网站的用户名和密码）
14.点击【插件】
15.确认是否在可用的扫描插件
16.点击【保存】
17.选择【web扫描】，点击后边的【小三角】
18.点击【web扫描】
19.等待扫描完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcc135234b03e6710e5f52ae6930a7a8/" rel="bookmark">
			Nessus介绍与安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nessus介绍与安装 1.Nessus简介 Nessus号称是世界上最流行的漏洞扫描程序，全世界有超过75000个组织在使用它。该工具提供完整的电脑漏洞扫描服务，并随时更新其漏洞数据库。Nessus不同于传统的漏洞扫描软件，Nessus可同时在本机或远端上遥控，进行系统的漏洞分析扫描。Nessus也是渗透测试重要工具之一
2.kali安装Nessus 1.访问Nessus官网
https://www.tenable.com/downloads/nessus 下载安装包【Nessus-10.1.1-debian6_amd64.deb】到kali
2.安装Nessus程序
dpkg -i Nessus-10.1.1-debian6_amd64.deb You can start Nessus Scanner by typing /bin/systemctl start nessusd.service 启动服务命令
Then go to https://kali:8834/ to configure your scanner 访问地址
3.启动Nessus
service nessusd start 4.查看kali的ip
ip a 5.浏览器访问nessus的web网站
https://192.168.11.75:8834/#/ 6.选择 【Managed Scanner】选项，点击【Continue】
7.选择【Tenable.sc】
8.点击【Continue】
9.输入用户名【admin】，输入密码【123456】，点击【Submit】
10.等待配置插件
安装完成后是这样的界面,尚未激活,不能扫描,此时只有一个设置按钮,并无扫描按钮.
3.离线激活Nessus 去nessus官方申请激活码，姓名随便填，邮箱必须正确，用来接收激活码 https://zh-cn.tenable.com/products/nessus/nessus-essentials 2.进入填写的邮箱获取激活码
3.获得质询码（challenge code）
/opt/nessus/sbin/nessuscli fetch --challenge 4.获取离线插件包地址及激活证书
浏览器打开网页 https://plugins.nessus.org/v2/offline.php ，输入申请的激活码，以及上一步得到的质询码，点击【Submit】
https://plugins.nessus.org/v2/offline.php 5.得到更新插件地址，及license证书
6.下载更新包，下载证书nessus.license。
7.将下载好的激活证书和插件包复制到kali
8.离线激活nessus
/opt/nessus/sbin/nessuscli fetch --register-offline .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcc135234b03e6710e5f52ae6930a7a8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/45/">«</a>
	<span class="pagination__item pagination__item--current">46/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/47/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>