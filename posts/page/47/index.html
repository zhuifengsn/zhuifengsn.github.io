<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3093f7b2291bec5cfb95e560914cecd/" rel="bookmark">
			group by详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		group by功能
在SQL中group by主要用来进行分组统计，分组字段放在group by的后面；分组结果一般需要借助聚合函数实现。
group by语法结构
1、常用语法
语法结构
SELECT
column_name1,column_name2, …
聚合函数1,聚合函数2 , …
FROM table_name
GROUP BY column_name1,column_name2, …
说明：1、group by中的分组字段和select后的字段要保持一致；2、通常group by和聚合函数一起使用，但也可以不包含聚合函数，根据业务需求决定；3、常用的聚合函数有max()、min()、avg()、sum()、count()等。
语法举例
首先创建销售表：
CREATE TABLE sale_order_item
(
ID int primary key NOT NULL,
area_name varchar(10),
mall_name varchar(10),
product_count int
);
然后向表中插入数据：
insert into sale_order_item values(1,‘销售一区’,‘城东店’,20);
insert into sale_order_item values(2,‘销售二区’,‘城西店’,15);
insert into sale_order_item values(3,‘销售一区’,‘城南店’,10);
insert into sale_order_item values(4,‘销售一区’,‘城东店’,4);
insert into sale_order_item values(5,‘销售二区’,‘城西店’,6);
insert into sale_order_item values(6,‘销售一区’,‘城南店’,11);
insert into sale_order_item values(7,‘销售一区’,‘城东店’,15);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3093f7b2291bec5cfb95e560914cecd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59c7dddb912cdf6973e72d6efd26d61d/" rel="bookmark">
			C&#43;&#43;11动态内存与智能指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、动态内存 在C++中，动态内存的管理是用一对运算符完成的：new和delete，new:在动态内存中为对象分配一块空间并返回一个指向该对象的指针，delete：指向一个动态独享的指针，销毁对象，并释放与之关联的内存。
动态内存管理经常会出现两种问题：一种是忘记释放内存，会造成内存泄漏；一种是尚有指针引用内存的情况下就释放了它，就会产生引用非法内存的指针。
C++定义指针变量什么时候需要手动释放？
int*， char* ,这些定义是局部变量，存在于栈上，比如int *p;p在栈上，而且p的值也是栈的一个地址。但是当int *p = new int ;这时候，p这个变量是在栈上的。但是p的值是一个地址，这个地址是堆上的一个地址。如果不delete p;那么，这个地址会一直被占用着，不能被其他的对象所使用，所以我们用完这个地址，要把这个地址释放掉。因此栈的空间会自动释放，而堆里的空间必须手动释放。
二、智能指针 2.1 智能指针简介 智能指针是存储动态分配（堆）对象指针的类，用于生存周期控制，能够确保在离开指针所在作用域时，自动正确地销毁动态分配的对象，防止内存泄露。它的一种通用实现技术是使用引用计数，每使用一次，内部的引用计数加1，每析构一次，内部引用计数减1，减为0时，删除所指向的堆内存。
智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。C++ 11中最常用的智能指针类型为shared_ptr,它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一。只有引用计数为0时，智能指针才会自动释放引用的内存资源。对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过make_shared函数或者通过构造函数传入普通指针。并可以通过get函数获得普通指针。
c++ 11 提供了3种智能指针：std::shared_ptr、std::unique_ptr、std::weak_ptr ，使用时引用头文件 &lt;memory&gt;。
shared_ptr允许多个指针指向同一个对象unique_ptr则“独占”所指向的对象weak_ptr，它是一种弱引用，指向shared_ptr所管理的对象 2. 2 智能指针作用 因为智能指针是一个类，当超出了类的实例对象的作用域时，会自动调用对象的析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。
2.3 shared_ptr 共享的智能指针 std::shared_ptr 使用引用计数，每一个shared_ptr 的拷贝都指向相同的内存。在最后一个shared_ptr 析构时，内存才会被释放。
每个 shared_ptr 对象在内部指向两个内存位置：
1、指向对象的指针。
2、用于控制引用计数数据的指针。
共享所有权如何在参考计数的帮助下工作：
1、当新的 shared_ptr 对象与指针关联时，则在其构造函数中，将与此指针关联的引用计数增加1；
2、当任何 shared_ptr 对象超出作用域时，则在其析构函数中，它将关联指针的引用计数减1。如果引用计数变为0，则表示没有其他 shared_ptr 对象与此内存关联，在这种情况下，它使用delete函数删除该内存
多个 shared_ptr 对象可以共同托管一个指针 p，当所有曾经托管 p 的 shared_ptr 对象都解除了对其的托管时，就会执行delete p。
#include &lt;iostream&gt; #include &lt;memory&gt; using namespace std; class A { public: int i; A(int n):i(n) { }; ~A() { cout &lt;&lt; i &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59c7dddb912cdf6973e72d6efd26d61d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49fac67c5b41abe42426712767051343/" rel="bookmark">
			【C语言】操作符详解（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hello~~，我是~小鹿，超级详细的操作符讲解来康康吧
可以收藏随时找到这里哦~
【C语言】操作符详解（超详细） 1.算数操作符：+，-，*，/，%2.位移操作符：&lt;&lt; , &gt;&gt;（详解）3.位操作符：&amp;，|，^ 例题1.不允许创建临时变量，交换两个整数的内容例题2.输入一个整数 n ，输出该数32位二进制表示中1的个数。其中负数用补码表示。例题3.获取一个整数二进制序列中所有的偶数位和奇数位，分别打印出二进制序列例题4.编程实现：两个int（32位）整数m和n的二进制表达中，有多少个位(bit)不同？4.赋值操作符:+=，-=，*=，/=，&gt;&gt;=，&lt;&lt;=，%=5.单目操作符：！，-，+，&amp;，~，++，- -，*，(类型)，sizeofsizeof详解 6.关系操作符：&gt;，&gt;=，&lt;，&lt;=，!=，==7.逻辑操作符：&amp;&amp;，||8.条件操作符：exp1？exp2：exp39.逗号表达式：exp1，exp2，exp3，······10.下标引用操作符：[ ]，函数调用：( )，访问结构的成员： . ， -&gt; 1.算数操作符：+，-，*，/，% 算数操作符：+ ， - ， * ， /（除） ， %（取余）
%（取余）： 两端都必须为整数
int a=9%2; printf("a=%d",a);//运行结果为 a=1 /（除）： 两端都为整型时，结果为整数；若有一端为浮点数，则结果为小数
int a=9/2; printf("a=%d",a);//运行结果为 a=4 float a=9/2;//（ / 两边都为整型，结果为整数） printf("a=%d",a);//运行结果为 a=4.000000 float a=9/2.0; printf("a=%d",a);//运行结果为 a=4.500000 2.位移操作符：&lt;&lt; , &gt;&gt;（详解） 位移操作符： &lt;&lt;(左移操作符)，&gt;&gt;(右移操作符)
注意：
位移操作符移动的是二进制位
整数在存储中存放的是补码
正整数：原码=反码=补码
负数：存放在内存中，存放的是补码
原码：直接根据数值写出的二进制序列
反码：原码的符号位不变，其他位按位取反
补码：反码+1
例如：-1
原码：10000000 00000000 00000000 00000001
反码：11111111 11111111 11111111 11111110
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49fac67c5b41abe42426712767051343/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/612f2e55a577a2abd1fa8c6ab2032235/" rel="bookmark">
			R语言实现牛顿插值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 4 差商与牛顿插值差商牛顿插值 4 差商与牛顿插值 差商 如果采取间隔不等的采样，差商会变得稍显复杂，对于 x 0 , x 1 , … , x n x_0,x_1,\ldots,x_n x0​,x1​,…,xn​，若与 y 0 , y 1 , … , y n y_0,y_1,\ldots,y_n y0​,y1​,…,yn​通过映射 f f f一一对应，则定义比值
f [ x 0 , x 1 ] = f ( x 1 ) − f ( x 0 ) x 1 − x 0 f[x_0,x_1]=\frac{f(x_1)-f(x_0)}{x_1-x_0} f[x0​,x1​]=x1​−x0​f(x1​)−f(x0​)​
为 f ( x ) f(x) f(x)关于节点 x 0 , x 1 x_0,x_1 x0​,x1​的一阶差商。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/612f2e55a577a2abd1fa8c6ab2032235/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f77524355c54fc9037ebb7ac244799c9/" rel="bookmark">
			init进程启动流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、1.解析init进程启动过程二、2.解析service服务总结 前言 1.init简介(本文基于android12)
init进程是Android系统中用户空间的第一个进程，作为第一个进程，它被赋予了很多极其重要的工作职责，比如创建zygote(孵化器)和属性服务等。init进程是由多个源文件共同组成的，这些文件位于源码目录system/core/init。本文将基于Android12源码来分析Init进程。
2.引入init进程
说到init进程，首先要提到Android系统启动流程的前几步：
1.启动电源以及系统启动
当电源按下时引导芯片代码开始从预定义的地方（固化在ROM）开始执行。加载引导程序Bootloader到RAM，然后执行。
2.引导程序Bootloader
引导程序是在Android操作系统开始运行前的一个小程序，它的主要作用是把系统OS拉起来并运行。
3.linux内核启动
内核启动时，设置缓存、被保护存储器、计划列表，加载驱动。当内核完成系统设置，它首先在系统文件中寻找”init”文件，然后启动root进程或者系统的第一个进程。
4.init进程启动
一、1.解析init进程启动过程 init进程启动过程
android12流程和之前的有所区别首先进入main.cpp 只选取主要的过程 /system/core/init/main.cpp 51 int main(int argc, char** argv) { 61 if (argc &gt; 1) { ... 73 if (!strcmp(argv[1], "second_stage")) { 74 return SecondStageMain(argc, argv);2 75 } 76 } 78 return FirstStageMain(argc, argv);1 79 } /system/core/init/first_stage_init.cpp FirstStageMain //创建文件并挂载 202 CHECKCALL(mkdir("/dev/pts", 0755)); 203 CHECKCALL(mkdir("/dev/socket", 0755)); 204 CHECKCALL(mkdir("/dev/dm-user", 0755)); /system/core/init/init.cpp SecondStageMain 787 PropertyInit();1 初始化属性相关资源 805 Epoll epoll; 806 if (auto result = epoll.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f77524355c54fc9037ebb7ac244799c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb08a1687a7a68943965a8440520bfcd/" rel="bookmark">
			（一）.NET的历史介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（一）.NET 前世今生 2000 年至 2014 年：（.NET Framework） 2000 年末：微软发布第一个 .NET Framework Beta 版本，紧接着在 2001 年初发布第一个 .NET Framework 正式版 v1.0。在 2003 年升级到 v1.1，完善了桌面应用开发和 Web 开发，推出了 ASP.NET。
2006 年左右：微软相继推出了 .NET Framework 的 2.0 和 3.0 版本。在 3.0 版本中，微软推出了 WPC、WCF、WF 等框架。随着 3.0 的问世，微软进入黄金时代，称霸了一大半开发市场。
2009年左右：不过好景不长，在短短几年后的 2009 年左右，开发市场风起云涌，Web 开发大行其道，Java、PHP 崛起。微软先前打下的江山开始迅速被开源的 Java、PHP、Ruby 等瓜分。为了夺回失去的 Web 开发市场，微软在 2009 年发布了 Web 框架ASP.NET MVC 1.0 并完全开源，并在随后几年不断完善。
2010 年至 2014 年：.NET Framework 从 4.0 升级到 4.5。ASP.NET MVC 框架也在不断升级，期间不仅没有夺回 Web 开发市场，反而还在继续失守。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb08a1687a7a68943965a8440520bfcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/292eb64a91c1bc5cef807a21fff55c9c/" rel="bookmark">
			Java构建递归树工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java构建树结构工具类 import java.util.ArrayList; import java.util.List; public interface TreeUtil { /** * 节点树抽象类 * @param &lt;K&gt; 节点ID的数据类型 * @param &lt;T&gt; 节点的数据类型 */ interface Node&lt;K, T extends Node&lt;K, T&gt;&gt; { /** * 设置当前节点的ID */ void setId(K id); /** * 获取当前节点的ID * @return 当前节点的ID */ K getId(); /** * 设置当前节点的父节点ID */ void setPid(K pid); /** * 获取当前节点的父节点ID * @return 当前节点的父节点ID */ K getPid(); /** * 设置当前节点所拥有的的子节点数量 */ void setCount(int count); /** * 获取当前节点所拥有的的子节点数量 * @return 当前节点所拥有的的子节点数量 */ int getCount(); /** * 设置当前节点的子节点集合 * @param child 待设置的子节点集合 */ void setChild(List&lt;T&gt; child); /** * 获取当前节点的子节点集合 * @return 当前节点的子节点集合 */ List&lt;T&gt; getChild(); } /** * 构建节点树 * @param src 构建树的源集合（包含所有的子父级节点） * @param root 待填充子节点的根节点 */ static &lt;I, E extends Node&lt;I, E&gt;&gt; void buildTree(List&lt;E&gt; src, Node&lt;I, E&gt; root) { List&lt;E&gt; child = new ArrayList&lt;&gt;(); src.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/292eb64a91c1bc5cef807a21fff55c9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9394bfc68278b45062b60851894d9fef/" rel="bookmark">
			AWVS安装与激活
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AWVS安装与激活 1.AWVS简介 AWVS（Acunetix Web Vulnerability Scanner）是一款知名的网络漏洞扫描工具，通过网络爬虫测试网站安全，检测流行的Web应用攻击，如跨站脚本、sql 注入等。据统计，75% 的互联网攻击目标是基于Web的应用程序。
2.为什么要用AWVS 在今天，网站的安全是容易被忽视的，黑客具备广泛的攻击手段，例SQL注入，XSS，文件包含，目录遍历，参数篡改，认证攻击等，虽然你配置了正确的防火墙和WAF，但是这些安全防御软件仍然存在策略性的绕过，因此，需要您定期的扫描你的web应用，但是手动检测你所有的web应用是否存在安全漏洞比较复杂和费时，所以您需要一款自动化的web漏洞扫描工具来检测您的web应用是否存在安全漏洞。
3.windows 安装 AWVS下载地址：https://pan.baidu.com/s/1hA83j7iUP7cVKZAIp9A8QA?pwd=zhzx
1.解压 awvs14补丁.zip
2.双击 acunetix_14.1.210316110.exe 安装
3.点击【是】
4.点击【Next】
5.点击【I accept the agreement 】,点击【Next】
6.选择喜欢的位置安装，点击【Next】
7.选择喜欢的位置保存 Data，点击【Next】
8.输入账号名：admin@msb.com,密码：m123456@，点击【Next】
9.选择【Allow remote access to Acunetix】，选择IP，点击【Next】
10.点击【Next】
11.点击【install】
12.等待安装完成
13.点击【是】
14.点击【Finsh】
15.右键【我的电脑】，点击【管理】，选择【服务和应用成序】,点击【服务】
16.右键【Acunetix】和【Acunetix Database】，停止Acunetix和Acunetix Database服务
17.将【awvs14补丁】里的【license_info.json】 复制到【D:\ProgramData\Acunetix\shared\license】，点击【替换】
18.将【awvs14补丁】里的【wa_data.dat】复制到【D:\ProgramData\Acunetix\shared\license】
19.将【awvs14补丁】里的【wvsc.exe】复制到【D:\Program Files (x86)\Acunetix\14.1.210316110】
20.右键【Acunetix】和【Acunetix Database】，启动 Acunetix和Acunetix Database服务
21.刷新浏览器的管理页面，点击【高级…】,点击【接受风险并继续】
22.登录管理员账号 admin@msb.com,密码：m123456@
4. kali 安装AWVS 1.将acunetix_trial.sh 和 patch_awvs 复制到kali中
2.修改 acunetix_trial.sh 和 patch_awvs 权限
chmod 777 acunetix_trial.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9394bfc68278b45062b60851894d9fef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f0782e6df4fe0850ad37fc9b18f2cfd/" rel="bookmark">
			Web服务器和应用服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.Web服务器与应用服务器
Web服务器简介
什么是Web服务器
WEB即超文本（hypertext）、超媒体（hypermedia）和超文本传输协议（HTTP），获取这些静态资源实际上是在请求服务器上的文件。这些文件都一直保存在服务器的磁盘上一个固定的文件路径，并生成一个对应的地址。HTML页面就是WEB的数据元素，处理这些数据元素的应用软件就叫WEB服务器，WEB服务器常与客户端打交道，它要处理的主要信息有：session、request、response、HTML、JS、CS等。
常用的Web服务器
Nginx
Apache
Jetty （也支持动态页面处理，但主要还是静态页面）
IIS
应用服务器简介
什么是应用服务器
应用服务器是为客户端提供对业务逻辑的访问这种服务器，根据客户端的请求会将数据转化为动态内容，一般还需要数据库的支持，应用服务器的搭建很多时候依赖于应用程序的开发语言，各种编程语言生态下对应不同的软件， 比如使用Java语言开发的项目通常选择 Tomcat或者接jboss来作为程序运行的应用服务器，而使用python语言开发Web应用，一般会选用Django等python框架下的软件，来作为它的应用服务器。
常用的应用服务器
Tomcat
Jboss
WebLogic
有的应用服务器也提供http服务，如Tomcat，所以可以说，Tomcat是Web服务器也是应用服务器。
Web服务器和应用服务器的区别及联系
WEB服务器一般是通用的，而应用服务器一般是专用的，如Tomcat只处理JAVA应用程序而不能处理ASPX或PHP。而Apache是一个WEB服务器（HTTP服务器），它的数据源可以是配置在Tomcat中的JAVA应用，也可以是ASPX应用。 Web服务器只负责处理HTTP协议，只能发送静态页面的内容。而JSP，ASP，PHP等动态内容需要通过CGI、FastCGI、ISAPI等接口交给其他程序去处理，这个其他程序就是应用服务器。
Web服务器只处理静态html。走http协议。客户端为浏览器。
应用服务器主要是控制客户端和服务端的业务逻辑，通信格式不限制（如json、html或任何文件），也是走http协议。经常用来处理动态内容。客户端可以是浏览器，也可以是其他应用服务器，手机app等。Web服务器可以算是应用服务器的一个子集。
现在很多Web服务器通过加载插件也支持动态页面的处理，应用服务器本身也支持静态页面的处理。两者有很多重合的地方，现在也有人叫Web应用服务器。随着Web技术的火热，两者很多功能融合了，但是概念上还是有差异。
这里通过分析Nginx(Web服务器)和Tomcat(应用服务器)来展示二者之间的区别:
Tomcat的功能职责 ：
Tomcat运行在JVM之上，它和HTTP服务器一样，绑定IP地址并监听TCP端口，同时还包含以下指责：
管理Servlet程序的生命周期。
将URL映射到指定的Servlet进行处理。
与Servlet程序合作处理HTTP请求——根据HTTP请求生成HttpServletResponse对象并传递给Servlet进行处理，将Servlet中的HttpServletResponse对象生成的内容返回给浏览器。
Nginx的功能职责：
动静态资源分离——运用Nginx的反向代理功能分发请求：所有动态资源的请求交给Tomcat，而静态资源的请求（例如图片、视频、CSS、JavaScript文件等）则直接由Nginx返回到浏览器，这样能大大减轻Tomcat的压力。
负载均衡，当业务压力增大时，可能一个Tomcat的实例不足以处理，那么这时可以启动多个Tomcat实例进行水平扩展，而Nginx的负载均衡功能可以把请求通过算法分发到各个不同的实例进行处理。
两者的区别：
Apache/Nginx叫做Http server ;而Tomcat 则是一个application Server，或者说是一个servlet/jsp应用容器（python无法直接运行在Tomcat上，java可以） 一个 HTTP Server 关心的是 HTTP 协议层面的传输和访问控制，所以在 Apache/Nginx 上你可以看到代理、负载均衡等功能。客户端通过 HTTP Server 访问服务器上存储的资源（HTML 文件、图片文件等等）。而应用服务器，则是一个应用执行的容器。它首先需要支持开发语言的 Runtime（对于 Tomcat 来说，就是 Java），保证应用能够在应用服务器上正常运行。其次，需要支持应用相关的规范，例如类库、安全方面的特性。对于 Tomcat 来说，就是需要提供 JSP/Sevlet 运行需要的标准类库、Interface 等。为了方便，应用服务器往往也会集成 HTTP Server 的功能，但是不如专业的 HTTP Server 那么强大，所以应用服务器往往是运行在 HTTP Server 的背后，执行应用，将动态的内容转化为静态的内容之后，通过 HTTP Server 分发到客户端。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f0782e6df4fe0850ad37fc9b18f2cfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1f88cb28553f522d5b37ea6c1d8d796/" rel="bookmark">
			mac苹果电脑m1 mbp 缺电自动关机后，日期时间无法同步；自动同步日期和时间错误，到一个固定的日期时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现为mac苹果电脑上，只要选取自动同步日期和时间，就会同步到一个很早之前的固定日期（现在是2023年1月，会同步到2021年的12月），很奇怪。
网上各种方法，下面的内容是唯一能起作用的。
在https://www.v2ex.com/t/856623的基础上进行修改完善，供大家参考。
解决办法：删除 /etc/ntp.conf ，/var/db/timed/com.apple.timed.plist 。重启。
第一个文件可以找到，第二个文件找不到，所以分别执行以下两条命令：
sudo rm -rf /etc/ntp.conf
sudo rm -rf /var/db/timed/com.apple.timed.plist
接着重启。
亲测有效，花费了很多时间尝试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/894aa0ec6caf560a3f0b9cd8ad126dbd/" rel="bookmark">
			java 方法执行时间工具类StopWatch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，前言 在java中，我们想看方法执行时间的时候，通常使用System.currentTimeMillis()方法分段打出日志查看，但是这样很不方便，时间啥的需要自己计算
二，StopWatch工具类 StopWatch可以监控方法或代码段的执行时间，并以表格的形式打印出来
上代码：
StopWatch watch = new StopWatch("watchId"); watch.start("watchStart"); // 方法或代码段1 watch.stop(); watch.start("watchStart2"); // 方法或代码段2 watch.stop(); // 打印出结果 logger.info(watch.prettyPrint()); 使用watch.prettyPrint()可以打印出监控分析结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da4aae2a16a75e26c99ac4a769ddc494/" rel="bookmark">
			查找多个 PDF 文件中的关键字并替换为其它文字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 概要：在一个文件中查找并替换关键字的场景下，我们都知道怎么去操作，我们直接按住Ctrl+F5或者直接按软件界面上的查找按钮，并且替换就可以了。但是如果我们需要一次性的查找并替换PDF文件中的多个关键字，这个时候怎么办呢？一定要看一下这里的操作，它会颠覆你日常的认识。
PDF对我们平常处理来说是比较麻烦的一个格式，因为这个文件格式并不适合去编辑。如果我们平时需要查找这个文件格式中的关键字的话，还是比较方便的，我们直接在PDF软件上面点击查找按钮就可以查找到这个PDF文件中包不包含这个关键字。但是呢，如果我们需要修改这个关键字的时候该怎么办呢？很多软件它只能阅读PDF文件，它并不支持PDF文件的修改。如果我们遇到了需要批量修改PDF文件中的关键字，这个时候就没有办法了。其实我们只需要查找并替换一个关键字的话，我们也需要去编辑整个PDF文件，何况我们需要一次性的查找多个PDF文件中的关键字，并将他们一次性的替换成我们想要的文字内容。
这里就给大家介绍一种方法，如何去批量在多个PDF文件中统一的查找不同的关键字，并且呢把他们替换成为我们想要的文字，大家有了这个技能之后，以后就不用安装PDF编辑软件，可以直接使用这种方法去批量的修改PDF文件中的内容了。
打开「我的ABC软件工具箱」，然后进入到按规则查找并替换文件内容中。这个功能的意思就是说能够批量的查找并替换文件里面的文字内容。也就是说现在给大家演示了如何去批量的查找替换PDF文件中的内容，可以使用这个功能一次性的将很多个PDF文件都可以查找并替换。
当我们进入到批量修改文件内容的功能中之后呢，我们直接单击右上角的添加文件，这个时候把我们需要处理的PDF文件一次性的添加到下面的列表中，这里的意思就是让软件知道我们需要查找并替换这些PDF文件中的所有的内容。
当我们选择完需要批量修改的PDF文件之后呢，我们直接单击下一步，然后这个时候软件就提示我们设置修改的规则，这里我们选择精确文本，然后填写一个查找的旧内容，还有填写替换为的新内容。注意这里可以支持精确文本，模糊文本还可以支持正则表达式，如果大家有兴趣的话，一定仔细看一下界面的文字说明，这里的功能非常的强大，精确查找的意思就是说我们输入什么，然后软件在扫描这个PDF文件的内容的时候就查找到什么，如果我们使用模糊匹配也就是正则表达式，这个时候我们就可以利用正则表达式来实现模糊的PDF内容的查找。
当我们填写完需要查找并替换的文字内容之后呢，我们直接单击下一步。这个时候软件就一次性的批量将我们所有的PDF文件中的内容都进行了统一的扫描，并且搜索出这些PDF文件中是否包含我们想要查找的关键字，如果这些PDF文件中包含这些关键字的话，软件会统一的将它们替换成我们前面输入的新的关键字。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74ae60604ba5fc0c040a12eafa0a3a16/" rel="bookmark">
			如何让element-ui的el-row内容居中（水平垂直）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 水平垂直居中 如图，则主要代码是： type="flex" justify="center" align="middle"
2. 水平居中 如图，则主要代码是： type="flex" justify="center"
3. 垂直居中 如图，则主要代码是：type="flex" align="middle"
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4883722c7aad6107e10f5118c7047ad5/" rel="bookmark">
			linux编译安装的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux编译安装的方法大致如下:
下载源代码，一般是以.tar.gz或者.tar.bz2的形式提供下载。使用命令wget或者浏览器下载即可。
解压源代码。使用命令tar -zxvf 文件名.tar.gz或者tar -jxvf 文件名.tar.bz2解压源代码。
进入源代码目录。使用命令cd 文件名进入源代码目录。
配置源代码。使用命令./configure配置源代码，一般会根据系统自动检测依赖库并配置好。
编译源代码。使用命令make编译源代码。
安装。使用命令sudo make install安装编译好的二进制文件。
注意：在编译安装之前，通常需要安装编译所需的依赖库，使用命令sudo apt-get install或者sudo yum install安装即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c1b9693041246e8d5bd0e0f87f8cd8f/" rel="bookmark">
			C语言中移位操作（基础篇）之“＞＞“和“＜＜“的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先要了解一下C语言里所有的位运算都是指二进制数的位运算。即使输入的是十进制的数，在内存中也是存储为二进制形式。
一、“&lt;&lt;”用法： 格式是：a&lt;&lt;m，a和m必须是整型表达式，要求m&gt;=0。 功能：将整型数a按二进制位向左移动m位，高位移出后，低位补0。
二、“&gt;&gt;”用法： 格式是：a&gt;&gt;m，a和m必须是整型表达式，要求m&gt;=0。 功能：将整型数a按二进制位向右移动m位，低位移出后，高位补0。
三、小练习
char x=3;
x&lt;&lt;1是多少
思路：3转换成二进制是：0000 0011，x&lt;&lt;1是指x向左移动一位，遵循高位移出后，低位补0，最左边的一位移掉，然后在最低位补一个0，所以是0000 0110，转换成十六进制是6
x&gt;&gt;1是多少
思路：3转换成二进制是：0000 0011，x&gt;&gt;1是指x向右移动一位，遵循低位移出后，高位补0，最右边的一位移掉，然后在最高位补一个0，所以是0000 0001，转换成十六进制是1
本文目前先不考虑负数，若想了解，请看如下链接：
C语言中移位操作_Nerazzur的博客-CSDN博客_c语言移位
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acec9e69cf8a551b797baa05e310b714/" rel="bookmark">
			vue使用echarts很卡 &#39;requestAnimationFrame&#39; handler took 64ms
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue使用echarts的时候, 如果出现"requestAnimationFrame handler took xxx ms"的提示, 表示当前的图表渲染所用的时间超过了浏览器规定的最长时间(通常是16.7ms), 导致图表的渲染卡顿.
这种情况通常是由于数据量过大, 导致渲染所用的时间过长. 解决方法有:
尽量减少数据量, 使图表渲染所用的时间尽可能短.
对于一些复杂的图表, 可以使用图表组件内置的数据压缩算法, 比如echarts的dataZoom组件, 可以压缩数据的展示范围, 从而减少数据的量, 提高渲染速度.
可以尝试使用图表组件的 lazyUpdate
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47997be45cc3297bfcf9b63b4336dc25/" rel="bookmark">
			多项式加法（链表）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔者最近正在学习数据结构，碰到了这样一个问题——如何用链表实现多项式的加法？因书上仅给出了数组法的代码，所以笔者尝试自己解决这个问题。为此，笔者写本文来记录思考过程。
思路 一、创建合适的链表 a.分析 百度百科这样描述多项式——”在数学中，几个单项式的和，叫做多项式。”就像多项式由一个个单项式相加而成，链表也由一个个节点连接而成。只是，+连接单项式，指针连接节点。
多项式：
链表：
因此，一个节点应该存放一个单项式：
b.代码 typedef struct Polynomial // 多项式 { int Coefficient; // 系数 int Exponent; // 指数 } Polynomial; typedef struct Node // 节点 { Polynomial Poly; struct Node* Next; } Node; typedef Node* List; // 多项式的项在链表中按指数由大到小排列 二、对链表进行操作 a.初始化节点 /* 参数：1个：待初始化的节点的指针 结果：节点中的系数和指数都初始化为0 */ void ZeroPolynomial(Node* Ptr) { if (Ptr != NULL) // 防止传入空指针 { Ptr-&gt;Poly.Coefficient = 0; // 系数初始化为0 Ptr-&gt;Poly.Exponent = 0; // 指数初始化为0 Ptr-&gt;Next = NULL; } } b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47997be45cc3297bfcf9b63b4336dc25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f3bef836bc32a5e1317cc9f9f3541b6/" rel="bookmark">
			Linux树莓派开发——配置树莓派内核源码，内核编译，更换树莓派Linux内核
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、树莓派Linux源码配置
1、配置的三种方法
2、内核源码的下载
二、树莓派内核编译 1、树莓派的编译
​2、生成vmlinux
三、更换树莓派内核的详细步骤
一、树莓派Linux源码配置 驱动代码的编译需要一个提前编译好的内核，所以就需要进行内核的编译，编译内核就必须完成相关的配置，配置的最终目的是会生成 .config文件，该文件是指导Makefile去把有用东西组织成内核。
1、配置的三种方法 第一种：通常买了开发板厂家会配linux内核的源码，使用厂家的.config文件进行配置
查找厂家 .config 指令
find . -name *_defconfig 树莓派1的工程是bcmrpi_defconfig，2、3的工程是bcm2709_defconfig。
ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make bcm2709_defconfig 指定ARM架构 指定编译器 树莓派 主要核心指令 此命令功能是获取bcm2709_defconfig的配置到 .config里。
第二种方式：make menuconfig 一项项的进行配置，通常是基于厂家的config来配置。
ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make menuconfig 第三种方式：全靠自己来实现。
2、内核源码的下载 下载地址：https://github.com/raspberrypi/ 下载好后传送到Ubuntu 即可。
二、树莓派内核编译 对树莓派内核源码进行配置后，下一步要进行树莓派Linux内核的编译，需要树莓派交叉编译工具、树莓派内核。
交叉编译的下载和使用可以点交叉编译
需要用到的库
sudo apt-get install bc sudo apt-get install libncurses5-dev libncursesw5-dev sudo apt-get install zlib1g:i386 sudo apt-get install libc6-i386 lib32stdc++6 lib32gcc1 lib32ncurses5 1、树莓派的编译 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make -j4 zImage modules dtbs j4指定用多少电脑资源进行编译 （j4表示4核）zImage表示生成内核镜像 modules要生成驱动模块 dtbs生成配置文件 2、生成vmlinux 编译成功后，可以看到源码树目录多了vmlinux这个文件,如果编译失败则没有此文件，成功后，目标zImage镜像在arch/arm/boot目录下（此步ARM架构的芯片都是类似）(vmlinux是未压缩的liunx，zImage是压缩好的liunx)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f3bef836bc32a5e1317cc9f9f3541b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4118f0153f79851676af9f57ba588a9/" rel="bookmark">
			CPP基本语法笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cpp基本语法笔记 一.变量、输入输出、表达式和顺序语句 1.固定格式 #include&lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; "Hello World" &lt;&lt; endl; return 0; }u 2.变量类型 常用：
类型字节bool – &gt; false / true – &gt; 0/11bytechar ‘c’, ‘a’, ’ ', ‘\n’1byteint -1247483648 ~ 21474836474bytefloat 1.23, 2.5, 1.235e2 6~7位有效数字4bytedouble 15~16位有效数字8byte 更长
类型字节long long //-2^63 ~ 2^63-18bytelong double //18~19位有效数字16byte 3.输入输出 a+b
cin输入 cout输出
#include&lt;iostream&gt; using namespace std; int main() { int a,b; cin &gt;&gt; a &gt;&gt; b; //输入，方向 &gt;&gt; cout &lt;&lt; a + b &lt;&lt; a * b &lt;&lt; endl; //输出，方向 &lt;&lt;, endl-&gt;回车 return 0； } scanf输入 printf输出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4118f0153f79851676af9f57ba588a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a28416ecd105f8722f629969d0d40fa/" rel="bookmark">
			CSS实现3D卡片旋转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先准备两个div容器用来定义两张卡片的正反面
直接上代码
html代码
&lt;div class="card"&gt; &lt;div class="front side"&gt; &lt;p&gt;正面&lt;/p&gt; &lt;/div&gt; &lt;div class="back side"&gt; &lt;h1&gt;反面&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; CSS代码
.card { position: relative; /* 父级 相对定位*/ } .side { /* 两张卡片设置公共样式，使其重叠在一起 */ position: absolute; left: 0; top: 0; width: 300px; height: 400px; /* 设置两张卡片翻转到背后不可见，并设置过度动画效果 */ backface-visibility: hidden; transition: all 1.5s ease; } .front { background-color: blueviolet; /* 给正面卡片单独设置样式颜色 */ } .back { /* 反面 */ background-color: rgb(152, 222, 135); /* 给反面卡片单独设置样式颜色 */ /* 反面卡面默认翻转到后面 */ transform: rotateY(-180deg); } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a28416ecd105f8722f629969d0d40fa/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/46/">«</a>
	<span class="pagination__item pagination__item--current">47/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/48/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>