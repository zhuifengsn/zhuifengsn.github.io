<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03a48b1e6628b05519373aed36696ab9/" rel="bookmark">
			pytorch版本的lstm搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lstm：长短期记忆网络，其特点是有三个门（遗忘门，输入门，输出门）来控制远近记忆h_t对当前状态c_t的影响。
import torch class LSTM(torch.nn.Module): def __init__(self,num_vocab,num_hiden,num_classes): super().__init__() self.Wxf,self.Whf,self.bf = self.param_def(num_vocab,num_hiden) self.Wxi,self.Whi,self.bi = self.param_def(num_vocab,num_hiden) self.Wxc,self.Whc,self.bc = self.param_def(num_vocab,num_hiden) self.Wxo,self.Who,self.bo = self.param_def(num_vocab,num_hiden) # 全连接层参数 self.fc = torch.nn.Linear(num_hiden, num_classes) def param_def(self,num_vocab,num_hiden): Wx = torch.nn.Parameter(torch.randn(num_vocab,num_hiden))# 设置为参数 Wh = torch.nn.Parameter(torch.randn(num_hiden,num_hiden)) b = torch.nn.Parameter(torch.zeros(num_hiden)) return Wx,Wh,b def forward(self,Xs,C0,H0): Hs = [H0] Cs = [C0] for X in Xs: F = torch.sigmoid(X@self.Wxf+Hs[-1] @ self.Whf +self.bf) I = torch.sigmoid(X@self.Wxi+Hs[-1] @ self.Whi +self.bi) O = torch.sigmoid(X@self.Wxo+Hs[-1] @ self.Who +self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03a48b1e6628b05519373aed36696ab9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4e70adc16214bd5ccf59563e4fa71e1/" rel="bookmark">
			RedisUtil
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import jakarta.annotation.Resource; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.stereotype.Component; import org.springframework.util.CollectionUtils; import java.util.Collection; import java.util.List; import java.util.Map; import java.util.Set; import java.util.concurrent.TimeUnit; /** * redis工具类 */ @Component public final class RedisUtil { @Resource private RedisTemplate&lt;String, Object&gt; redisTemplate; public Set&lt;String&gt; keys(String keys){ try { return redisTemplate.keys(keys); }catch (Exception e){ e.printStackTrace(); return null; } } /** * 指定缓存失效时间 * @param key 键 * @param time 时间(秒) * @return */ public boolean expire(String key, long time) { try { if (time &gt; 0) { redisTemplate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4e70adc16214bd5ccf59563e4fa71e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43be20790fa1e77a7b9ac1f13395328c/" rel="bookmark">
			Spring Boot打war包部署到Tomcat，访问页面404 ！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		水善利万物而不争，处众人之所恶，故几于道💦
文章目录 Spring Boot打war包部署到Tomcat，访问页面404 ！！！解决办法：检查Tomcat版本和Jdk的对应关系，我的Tomcat是6.x，jdk是8版本显然不兼容。所以访问不到。更换9版本后，正常访问 Spring Boot打war包部署到Tomcat，访问页面404 ！！！ 解决办法：检查Tomcat版本和Jdk的对应关系，我的Tomcat是6.x，jdk是8版本显然不兼容。所以访问不到。更换9版本后，正常访问 tomcat官网对版本的介绍
注意：部署到外部tomcat的时候，启动类要继承SpringBootServletInitializer重写configure方法，然后在pom文件中排除自带的tomcat，添加servlet-api依赖，打war包，部署到外部tomcat
轻喷，本人已经两年没碰Java了，不知道版本关系了，已经落伍了😭
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7a79927a28641ed76ce64f59aafcbcb/" rel="bookmark">
			用纯HTML写一个凭证并打印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有个需求，需要通过网页把单子打印出来，就用html实现了一个，主要使用了windwos自带的print打印，全部代码如下：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"/&gt; &lt;title&gt;标题&lt;/title&gt; &lt;style type="text/css" media="all"&gt; * { margin: 0; padding: 0; font-size: 12px } table { width: 90%; border: 1px solid #000; border-collapse: collapse; margin: 5px auto } th, td { border: 1px solid #000; border-collapse: collapse; padding: 8px 5px } h1 { font-size: 24px } @media print { .no-print { display: none; } } .headStyle{ width: 90%; display: flex; justify-content: space-between; border-collapse: collapse; margin: 5px auto; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7a79927a28641ed76ce64f59aafcbcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a4aa0459672a66a62dc1d9f58171c29/" rel="bookmark">
			华清远见嵌入式学习——驱动开发——作业1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作业要求： 通过字符设备驱动分步注册过程实现LED驱动的编写，编写应用程序测试，发布到CSDN
作业答案： 运行效果： 驱动代码： #include &lt;linux/init.h&gt; #include &lt;linux/module.h&gt; #include &lt;linux/fs.h&gt; #include &lt;linux/io.h&gt; #include &lt;linux/device.h&gt; #include &lt;linux/slab.h&gt; #include &lt;linux/cdev.h&gt; #include &lt;linux/uaccess.h&gt; #include "head.h" struct cdev *cdev; char kbuf[128] = {0}; unsigned int major = 0; // 主设备号 unsigned int minor = 0; // 次设备号 dev_t devno; struct class *cls; struct device *dev; gpio_t *vir_led1; gpio_t *vir_led2; gpio_t *vir_led3; unsigned int *vir_rcc; // 封装操作方法 // 定义操作方法对象并初始化 int mycdev_open(struct inode *inode, struct file *file) { printk("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a4aa0459672a66a62dc1d9f58171c29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/315424600ca6b54cdc82edd33eafd5ba/" rel="bookmark">
			Linux文件系统原理分析（2）inode索引节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 **一、inode是什么？****二、inode的内容****三、inode的大小****四、inode号码****五、目录文件****六、硬链接****七、软链接****八、inode的特殊作用****九、拓展软硬链接****1、硬链接****2、软链接** 一、inode是什么？ 理解inode，要从文件储存说起。
文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。
扇区（Sector）和块（Block）都是存储设备中的基本单位，但它们所表示的概念略有不同。
扇区是存储设备中最小的物理数据单位，通常大小为512字节或4KB。每个扇区都有一个唯一的地址（扇区号），用于标识其在磁盘上的位置。
块是操作系统进行文件系统管理的基本单位，通常大小为4KB或更大。块是一个逻辑上的概念，由一定数量的扇区组成。通过块，文件系统可以对存储设备进行逻辑划分，便于管理和读写数据。
在操作系统中，文件通常按照块的方式进行读写。当需要读取或写入一个文件时，操作系统会将文件分割成若干个块，并根据需要读取或写入相应数量的块。这些块实际上是由若干个扇区构成的。
文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。
每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。
二、inode的内容 索引节点（Inode）是Unix/Linux文件系统中的一个重要概念，用于存储关于文件或目录的元数据信息。每个文件或目录在文件系统中都对应一个唯一的索引节点，索引节点中包含了该文件或目录的属性和指向数据块的指针等信息。
索引节点通常包含以下信息：
文件类型（regular file、directory、symbolic link等）文件大小文件权限（读、写、执行权限）拥有者和所属用户组创建时间、修改时间和访问时间链接计数（指向该索引节点的硬链接数量）数据块指针（用于指向存储文件内容的数据块） 通过索引节点，文件系统可以有效地管理文件和目录，包括定位文件数据块、维护文件属性、权限等信息。当应用程序需要访问文件时，操作系统会通过索引节点来查找文件的元数据信息，从而获取文件的相关属性和数据块指针。
另外，索引节点的链接计数是一个重要的概念。每个文件或目录的索引节点都有一个链接计数，用于记录指向该索引节点的硬链接数量。当创建一个文件的硬链接时，该文件的索引节点的链接计数会增加；当删除一个硬链接时，链接计数会减少。只有当链接计数减少到0时，文件的索引节点才会被释放，文件占用的存储空间才会被释放。
可以用stat命令，查看某个文件的inode信息：
$ stat f File: f Size: 0 Blocks: 0 IO Block: 4096 regular empty file Device: 10304h/66308d	Inode: 14976327 Links: 1 Access: (0664/-rw-rw-r--) Uid: ( 1000/ victory) Gid: ( 1000/ victory) Access: 2024-02-18 16:41:56.408716071 +0800 Modify: 2024-02-18 16:41:56.408716071 +0800 Change: 2024-02-18 16:41:56.408716071 +0800 Birth: 2024-02-18 16:41:56.408716071 +0800 总之，除了文件名以外的所有文件信息，都存在inode之中。至于为什么没有文件名，下文会有详细解释。
三、inode的大小 inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/315424600ca6b54cdc82edd33eafd5ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/098082a1e61e1c49d9d9b8b7425fafd1/" rel="bookmark">
			微信小程序按需注入和用时注入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 官网链接
按需注入 { "lazyCodeLoading": "requiredComponents" } 注意事项 启用按需注入后，小程序仅注入当前访问页面所需的自定义组件和页面代码。未访问的页面、当前页面未声明的自定义组件不会被加载和初始化，对应代码文件将不被执行。请开发者修改配置后务必确认小程序的表现正常。启用按需注入后，页面 JSON 配置中定义的所有组件和 app.json 中 usingComponents 配置的全局自定义组件，都会被视为页面的依赖并进行注入和加载。建议开发者及时移除 JSON 中未使用自定义组件的声明，并尽量避免在全局声明使用率低的自定义组件，否则可能会影响按需注入的效果。插件包和扩展库目前暂不支持按需注入。如果需要实现插件按需加载，可以考虑将插件置于一个分包，并通过「分包异步化」的形式异步引入。 用时注入 每个页面内，第一次渲染该组件前，该组件都不会被注入；每个页面内，第一次渲染该组件时，该组件会被渲染为其对应的占位组件，渲染流程结束后开始注入；注入结束后，占位组件被替换回对应组件 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62754b9da1fa0164e367d9b778cdcdf7/" rel="bookmark">
			测试333
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试333
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb597e3e8cde07b8f291d014ae4bc302/" rel="bookmark">
			c语言位域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 位域 1.1 概述 ：C 语言的位域（bit-field）是一种特殊的结构体成员，允许我们按位对成员进行定义，指定其占用的位数 注意这里说的是位数 不是字节
如果程序的结构中包含多个开关的变量，即变量值为 TRUE/FALSE，如下：
struct { unsigned int widthValidated; unsigned int heightValidated; } status; 这种结构需要 8 字节的内存空间，但在实际上，在每个变量中，我们只存储 0 或 1，在这种情况下，C 语言提供了一种更好的利用内存空间的方式。如果您在结构内使用这样的变量，您可以定义变量的宽度来告诉编译器，您将只使用这些字节。例如，上面的结构可以重写成
struct { unsigned int widthValidated : 1; unsigned int heightValidated : 1; } status; 现在，上面的结构中，status 变量将占用 4 个字节的内存空间，但是只有 2 位被用来存储值。如果您用了 32 个变量，每一个变量宽度为 1 位，那么 status 结构将使用 4 个字节，但只要您再多用一个变量，如果使用了 33 个变量，那么它将分配内存的下一段来存储第 33 个变量，这个时候就开始使用 8 个字节。让我们看看下面的实例来理解这个概念
#include &lt;stdio.h&gt; #include &lt;string.h&gt; /* 定义简单的结构 */ struct { unsigned int widthValidated; unsigned int heightValidated; } status1; /* 定义位域结构 */ struct { unsigned int widthValidated : 1; unsigned int heightValidated : 1; } status2; int main( ) { printf( "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb597e3e8cde07b8f291d014ae4bc302/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a3ee855c1a9751176414296ffd01d42/" rel="bookmark">
			概率基础——几何分布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概率基础——几何分布 介绍 在统计学中，几何分布是描述了在一系列独立同分布的伯努利试验中，第一次成功所需的试验次数的概率分布。在连续抛掷硬币的试验中，每次抛掷结果为正面向上的概率为 p p p，反面向上的概率为 1 − p 1-p 1−p。几何随机变量 X X X表示连续抛掷硬币直到第一次出现正面向上的试验次数。
理论及公式 几何分布的概率质量函数（PMF）为：
P ( X = k ) = ( 1 − p ) k − 1 × p P(X = k) = (1 - p)^{k-1} \times p P(X=k)=(1−p)k−1×p
其中， k k k是试验次数， p p p 是每次试验成功（正面向上）的概率。
几何分布的期望和方差可以通过其概率质量函数得到。设几何随机变量为 X X X，表示第一次成功所需的试验次数。
期望（均值）： E ( X ) = 1 p E(X) = \frac{1}{p} E(X)=p1​
方差： V a r ( X ) = 1 − p p 2 Var(X) = \frac{1-p}{p^2} Var(X)=p21−p​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a3ee855c1a9751176414296ffd01d42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7bb92c4099525ebb4469a9e79291cd6/" rel="bookmark">
			NNLM - 神经网络语言模型 | 高效的单词预测工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本系列将持续更新NLP相关模型与方法，欢迎关注！
简介 神经网络语言模型（NNLM）是一种人工智能模型，用于学习预测词序列中下一个词的概率分布。它是自然语言处理（NLP）中的一个强大工具，在机器翻译、语音识别和文本生成等领域都有广泛的应用。
Paper - A Neural Probabilistic Language Model(2003)[1]
原理 NNLM 首先学习词的分布式表示，也称为词嵌入，它捕捉了词之间的语义相似性。然后将这些嵌入输入到神经网络模型中，通常是一个前馈神经网络或循环神经网络（RNN），该模型根据前面的词提供的上下文来学习预测序列中的下一个词。
例如，给定句子“猫在坐在”，NNLM 可能会高概率地预测下一个词为“地板”，因为这是给定上下文的常见补充。
示例 假设我们有一个大型的文本语料库，比如一系列新闻文章。我们可以对这些数据进行 NNLM 训练，以学习单词和它们上下文之间的关系。训练完成后，模型可以生成连贯和与上下文相关的句子。
例如，如果我们提供初始短语“人工智能是”，NNLM 可能生成以下完成句子：“人工智能正在改变行业，重塑未来的工作。”
应用 机器翻译： NNLM 在机器翻译系统中发挥作用，通过预测源语言上下文的下一个词来生成流畅且准确的翻译。 语音识别： NNLM 在语音识别系统中起着至关重要的作用，通过从口语表达中预测最可能的词序列。 文本生成： NNLM 在各种文本生成任务中使用，包括对话生成、故事生成和内容摘要，在这些任务中，它们基于给定的输入生成连贯且与上下文相关的文本。 语言建模： NNLM 作为语言建模任务的基础，用于估计在给定上下文中序列单词发生的概率。这在拼写检查、自动完成和语法错误检测等任务中特别有用。 Code # code by Tae Hwan Jung @graykode
import torch
import torch.nn as nn
import torch.optim as optim
def make_batch():
input_batch = []
target_batch = []
for sen in sentences:
word = sen.split() # space tokenizer
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7bb92c4099525ebb4469a9e79291cd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69e5da7fd72939474701ae112ef33fc7/" rel="bookmark">
			c语言指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面学了那么多 基本都会涉及到指针的知识 那今天 我们正式来学习c语言的魅力之一 指针
正如我们所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用 &amp; 运算符访问的地址，它表示了在内存中的一个地址我们来看一段代码：
#include &lt;stdio.h&gt; int main () { int var_runoob = 10; int *p; // 定义指针变量 p = &amp;var_runoob; printf("var_runoob 变量的地址： %p\n", p); printf("var_runoob 变量： %d\n", *p); return 0; } 运行结果：
大家带着这个问题 输出 p 和输出*p的区别以及为什么？我们来学习指针
目录
一指针
1.1 概述
1.2如何使用指针
1.3 指针的算术运算
1.3.1递增一个指针
1.3.2指针的递减
1.3.3指针的比较
1.4指针数组
1.5指向指针的指针
1.6传递指针给函数
一指针 1.1 概述 ：指针也就是内存地址，指针变量是用来存放内存地址的变量。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明
基本格式：
type *var_name; 在这里，type 是指针的基类型，它必须是一个有效的 C 数据类型，var_name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明
int *ip; /* 一个整型的指针 */ double *dp; /* 一个 double 型的指针 */ float *fp; /* 一个浮点型的指针 */ char *ch; /* 一个字符型的指针 */ 所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69e5da7fd72939474701ae112ef33fc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a207a2710b1567545587ab80e27e5bd/" rel="bookmark">
			C#开源免费的Windows右键菜单管理工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 今天分享一个C#开源、免费、纯粹的Windows右键菜单管理工具：ContextMenuManager。
工具主要功能 程序支持国际化多语言显示。启用或禁用文件、文件夹、新建、发送到、打开方式、自定义文件格式、IE浏览器、WinX等右键菜单项目。对上述场景右键菜单项目进行修改名称、修改图标、导航注册表位置、导航文件位置、永久删除等操作。对上述场景右键菜单自定义添加项目，自定义菜单命令。 工具支持系统 适用于Win7、8、8.1、10、Vista。适用于 x64、x32 CPU 操作系统。 工具源代码运行 工具压缩文件下载 https://github.com/BluePointLilac/ContextMenuManager/releases 工具运行截图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce0630071852e33518a3a3b063344a2c/" rel="bookmark">
			ADO世界之FIRST
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、ADO 简介
二、ADO 数据库连接
1.创建一个 DSN-less 数据库连接
2.创建一个 ODBC 数据库连接
3.到 MS Access 数据库的 ODBC 连接
4.ADO 连接对象（ADO Connection Object）
三、ADO Recordset（记录集）
1.创建一个 ADO 表记录集（ADO Table Recordset）
2.创建一个 ADO SQL 记录集 （ADO SQL Recordset）
3.从记录集中提取数据
4.ADO 记录集对象（ADO Recordset Object）
四、ADO 显示
1.显示字段名称和字段值
2.在一个 HTML 表格中显示字段名称和字段的值
3.向 HTML 表格添加标题
4.向 HTML 表格添加颜色
五、ADO 查询
1.显示选定的数据
2.仅显示 "Customers" 表的 "Companyname" 字段中大于 E 的记录
3.仅显示 "Customers" 表中的西班牙客户
4.让用户根据国别来选择客户
一、ADO 简介 ①ADO自述：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce0630071852e33518a3a3b063344a2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/770d52892afb9693539356926791e11e/" rel="bookmark">
			续第九届泰迪杯【缺失值处理&amp;过采样&amp;baseline训练】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先前的流程图&amp;相关连接 数据预处理-可视化数据预处理-行业划分异常值处理数据标准化 缺失值处理 采用随机森林方法填充缺失值
# 填充缺失值，随机森林填充 import pandas as pd from sklearn.impute import SimpleImputer import numpy as np from sklearn.ensemble import RandomForestRegressor #读取数据的第1到最后-1 #data=data.iloc[:,1:-1] #把缺失值大于20的列挑选出来 T=pd.read_csv(r'C:\Users\44933\Desktop\数据挖掘材料\1\makestd_noflag.csv',encoding='gbk') all_industry = T['所属行业'].value_counts().reset_index() #把所属行业str变为0 T['所属行业'] = T['所属行业'].apply(lambda x: all_industry['index'][x == all_industry['index']].index[0]) T_count=T.isnull().mean() target=T.所属行业 #print(T['所属行业']) #x_full=T.iloc[:,:-1] #y_full=T.loc[:,'是否在当年造假'] #n_samples_num=x_full.shape[0] #n_features_num=x_full.shape[1] x_missing1=T.loc[:,(T_count)&gt;0.2] #用随机森林做一个填充 #print(x_missing1) sortindex = x_missing1.isnull().sum().sort_values().index sortindex = list(sortindex) #print(len(sortindex)) for i in sortindex: ##构建新特征和新标签 df = x_missing1 fillc = df.loc[:,i] #print(fillc.isnull()) #print(fillc) #print(type(fillc)) ##把target标签并到去除掉i的右边 df = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/770d52892afb9693539356926791e11e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e1fe84f6d1e29a5497086d7dbee46f0/" rel="bookmark">
			Hive拉链表设计、实现、总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		水善利万物而不争，处众人之所恶，故几于道💦
文章目录 环境介绍实现1. 初始化拉链表2. 后续拉链表数据的更新 总结彩蛋 - 想清空表的数据：转成内部表，清空数据后，再转成外部表，将分区目录删掉，然后再次跑脚本，其他表都没问题就拉链表新算出过期分区的数据拉不进去，这是啥原因？有高人指点一下吗？ 环境介绍 拉链表可以用来记录数据的声明周期，适合那种数据量大但新增和修改频率不是很高的场景。比如总共100万条数据，每天新增大约1万条，修改1万条，这种变化不是很大的维度数据可以用拉链表来存。
我们这里将拉链表中每日最新的数据放入到9999-12-31分区中，过期的数据放入到前一天的分区中。
比如，2024-01-12日所有新增和修改数据（该拉链表采用增量同步）被采集到数仓的ODS层中，进入DIM层的时候将2024-01-12日修改过的老状态的数据（也就是过期数据）结束时间设置为前一天（标志该条数据生命周期结束），并放入前一天的分区中，而新增的数据和没有修改（没有修改过，那么这条数据的状态目前也是最新数据）过的数据放入到9999-12-31分区中，表示这张表最新状态的数据。
实现 1. 初始化拉链表 第一次向拉链表中导入数据的时候直接将ODS层中所有的数据overwrite到9999-12-31分区中就可以了，因为那天的数据就是最新的数据。
insert overwrite table dim_user_zip partition(dt="9999-12-31") --insert overwrite local directory "ods_user2" select data.id, data.login_name, data.nick_name, data.name, data.phone_num, data.email, data.user_level, data.birthday, data.gender, data.create_time, data.operate_time, date_format(nvl(data.operate_time,data.create_time),"yyyy-MM-dd") start_time, "9999-12-31" end_time from ods_user_info_inc where dt="2024-01-11" and type="bootstrap-insert" 这步完成后就初始化完成了拉链表，也就对应上图中左上角那个 “该表9999-12-31分区原来的数据” 表中的数据。
2. 后续拉链表数据的更新 方式1：
新增数据和原来分区的数据进行 full join 然后判断选择要哪条数据，然后overwrite到表中就行了
with new as ( select *, "2024-01-12" start_date, "9999-12-31" end_date from ods_user_info_inc where dt = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e1fe84f6d1e29a5497086d7dbee46f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8edea449114ee052ebde4f8764beba2e/" rel="bookmark">
			spring boot 使用AOP实现是否已登录检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前后端分离的开发中，用户http请求应用服务的接口时, 如果要求检测该用户是否已登录。可以实现的方法有多种， 本示例是通过aop 的方式实现，简单有效。
约定：前端http的post 请求
export async function request(url,data) { const config = { method: 'POST', headers: {'Content-Type': 'application/json'}, } //每个请求的参数要求附加sessionid, 该sessionid 是登录时生成的 const paramsData = Object.assign(data,{sessionid:globalData.sessionID || ''}) config.body = JSON.stringify(paramsData) try { const res = await window.fetch(url, config) if(res.status!==200){ return { status: res.status, data:{}, headers: res.headers, url: res.url, statusText:res.statusText } } return { status: res.status, data:await res.json(), headers: res.headers, url: res.url, } } catch (err) { return { status: 404, data:{}, headers: res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8edea449114ee052ebde4f8764beba2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a5405ac67f170d3819f52e461d4a87a/" rel="bookmark">
			python爬虫爬取图片 必应&amp;百度（仅供学习）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 分别在 必应 和 百度 中爬取图片的代码，只需要将搜索关键字改成你需要爬取的关键字即可复用
在必应中爬取图片 话不多说，先上代码
import requests from bs4 import BeautifulSoup import os def get_image_urls(query, num_images,j): url = f"https://www.bing.com/images/async?q={query}&amp;first={j}&amp;count={num_images}" response = requests.get(url) soup = BeautifulSoup(response.text, "html.parser") image_tags = soup.find_all("img", class_="mimg") filtered_image_tags = [img for img in image_tags if "vimgld" not in img["class"]] image_urls = [img["src"] for img in filtered_image_tags] return image_urls def download_images(image_urls, save_dir,j): if not os.path.exists(save_dir): os.makedirs(save_dir) for i, url in enumerate(image_urls): response = requests.get(url) with open(f"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a5405ac67f170d3819f52e461d4a87a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a99124607a5b06ec0670b48ecf3af97a/" rel="bookmark">
			[职场] 会计学专业学什么 #其他#知识分享#职场发展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		会计学专业学什么
会计学专业属于工商管理学科下的一个二级学科，本专业培养具备财务、管理、经济、法律等方面的知识和能力，具有分析和解决财务、金融问题的基本能力，能在企、事业单位及政府部门从事会计实务以及教学、科研方面工作的工商管理学科高级专门人才。
会计学专业包含了会计学、管理学、审计学、经济学的课程。
1. 会计学会从基础的会计学原理开始，从初级会计到中等难度的成本会计，再到高级成本会计，不断深化学习。
2. 审计学中会学到如何对企业的经济活动进行审查，分析审计案例。
3. 财务管理则是需要学生学会对未来即将发生的资金活动做预测和管理。
4. 经济学中会学到资金如何使用、投放后的盈利预测、盈利后的利润分配等等，其中还会涉及到一些数学模型的相关知识。
就业前景：
会计一直是被很多人认为好就业的专业。很多人报考会计专业也是为了日后能有一份待遇良好且稳定的工作。会计的就业方向主要分为这3个方面：
1. 企业会计
进入企业中的财务部，从会计做起，审核财务报表，报销发票，是大多数刚毕业的应届生都会选的路。在企业中的财务部，升职空间还是比较不错的，可以从基础会计升职到财务主管、财务经理。但劣势在于，这种岗位是一个萝卜一个坑，一个稳定企业的财务部纳新率不是很高，岗位竞争比较激烈。
2. 会计事务所
进入会计事务所，办理审计业务、资产评估、验资业务等。会计事务所的待遇相对优厚，但门槛高，工作强度大。想要应聘会计事务所，需要有一定年限的从业经验，和能力资格证书，（如注会证书）才能有更大的竞争力。
3. 考公务员
国家财政部、审计署、商务部或者是地方财政局、审计厅等，每年都会有公务员岗位空缺，会计专业的朋友如果考上了这些岗位，未来还是非常可期的。
4. 税务师事务所
和会计事务所一样，待遇好门槛高。需要从事精算、评估这种高级会计的事务。这也需要我们这些会计专业的人员有更高的能力，所以会计学专业的学生考取一些会计资格证书还是很有必要的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30aa6cb9f2ab1e2a74f87d85aa03db32/" rel="bookmark">
			深度学习中的鲁棒性和泛化性有什么区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鲁棒性（Robustness）和泛化性（Generalization）是评估模型性能时常用的两个术语，尤其在机器学习和统计建模领域。虽然这两个概念相关，但它们关注的方面有所不同。
鲁棒性 鲁棒性指的是模型在面对输入数据的小幅变动或存在噪声时仍能保持性能不受显著影响的能力。一个鲁棒的模型能够处理异常值、缺失数据点、或是不完美的输入数据，而不会导致预测结果出现显著偏差。鲁棒性强调的是模型对于输入数据中的不确定性和异常情况的抵抗能力。
泛化性 泛化性描述的是模型在未见过的新数据上的表现能力。一个具有良好泛化能力的模型能够在训练集之外的数据上也能保持较高的准确度和可靠性。泛化能力的强弱直接关系到模型是否过拟合（overfitting）或者欠拟合（underfitting）：过拟合的模型在训练数据上表现出色，但在新数据上性能下降；欠拟合的模型则在训练数据上就没有很好的表现，通常也难以在新数据上表现好。
区别 关注点不同：鲁棒性关注的是模型对于训练数据中的噪声或异常值的抵抗能力；而泛化性关注的是模型对未见过数据的预测能力。评估条件不同：评估鲁棒性时，通常在相同的数据分布中引入噪声或变化来测试模型的稳定性；评估泛化性时，需要将模型应用于独立的测试集，观察其在不同于训练集的数据上的表现。优化方法不同：提高鲁棒性可能需要采用数据清洗、特征工程、异常值处理等方法；提高泛化能力则可能需要模型选择、正则化技术、交叉验证等策略来避免过拟合。 尽管鲁棒性和泛化性各自关注不同的方面，但它们在实际应用中是相辅相成的。一个理想的模型既能够抵抗输入数据的微小变动和噪声，又能够在新的数据集上保持良好的预测性能。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/12/">«</a>
	<span class="pagination__item pagination__item--current">13/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/14/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>