<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40019921c55411ab1f06aebb4812b8eb/" rel="bookmark">
			【CTF】【ctfhub】Mysql流量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【工具】wireshark
【知识储备】流量分析类的题目大多需要用到wireshark进行抓包分析
因为之前接触过wireshark，我直接用kali虚拟机中的wirshark进行此次实验，所以没有wireshark安装过程。
直接利用搜索功能进行流量字节字符串搜索“mysql”（本题就是关于mysql的题，还有一种tips就是ctfhub上面的flag都是以ctfhub开头，直接搜索“ctfhub”也可以）
如果搜索的时候mysql需要在mysql包中一个一个查找，能够找到一个含有flag的数据
复制粘贴flag进行作答就完成答题了。
【小贴士】不要搜索flag！！！每一个抓包里面都有一个flag项，四舍五入等于搜索全部（可能表达不准确，萌新一枚还请大佬多多指教）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c205080253aa41a603ffbb91fb8cb482/" rel="bookmark">
			数据结构实验——多项式加减
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 设计算法实现一元多项式的简单运算。
基本要求 （1） 输入并建立多项式;
（2） 输出多项式;
（3） 多项式加法
（4） 多项式减法。
问题分析 （一）算法设计思路：
建立两个带头结点的单链表储存多项式，每个结点分别有一个系数域（浮点型）、指数域（整型）、指针域（指向下一个结点）。用户输入两个多项式的每一项系数及其对应指数，储存并将其按指数升序排序。若为加法，则直接将两多项式相加，若为减法，则将第二个多项式系数依次取反后相加。输出结果多项式。
（二）使用模块及变量的说明
1、typedef struct xn：定义多项式结点
2、List Creat_List()：建立带头节点的单链表储存多项式
3、List fun(List A)：按指数升序排列单链表
4、List merge(List A)：多项式合并
5、List xnAdd(List A, List B)：两个多项式相加
6、List xnOdd(List B)：多项式系数取反
7、void resPrint(List C)：输出多项式
8、主调函数部分：输入多项式的每一项，创建、排序、合并两个多项式单链表输出多项式，判断加号减号，并进行运算，输出结果多项式
实验代码 C++版
#include&lt;iostream&gt; using namespace std; //定义多项式结点 typedef struct xn { float xi; //系数部分 int zhi; //指数部分 struct xn* next; //指向下一项 }xn, * List; //建立带头结点的单链表储存多项式 List Creat_List() { List L; xn* p, * rear; //p指针用于插入新的结点，rear为尾指针 float x=1; L = new xn; L-&gt;next = NULL; rear = L; while (x!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c205080253aa41a603ffbb91fb8cb482/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efa5464a7b6bd1757fb23a73c679adf8/" rel="bookmark">
			给树莓派配置VNC，设置开机自启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VNC都要先在树莓派上打开VNCserver，要不然就有可能无法正常的使用VNCviewer连接树莓派，这样太麻烦了，可以将VNCserver设置为开机自启
首先编辑vncserver文件
打开终端窗口，输入命令
sudo nano /etc/init.d/vncserver 将如下代码写入到配置信息中
#!/bin/sh ### BEGIN INIT INFO # Provides: vncserver # Required-Start: $local_fs # Required-Stop: $local_fs # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 # Short-Description: Start/stop vncserver ### END INIT INFO export USER='pi' #用户名 pi eval cd ~$USER case "$1" in start) # 启动命令行。此处自定义分辨率、控制台号码或其它参数。 su $USER -c '/usr/bin/vncserver -depth 24 -geometry 1024x768 :1' echo "Starting VNCServer for $USER " ;; stop) su $USER -c '/usr/bin/vncserver -kill :1' echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efa5464a7b6bd1757fb23a73c679adf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f78c88e5cf714503d12424ff737811c2/" rel="bookmark">
			【Life】关于2021的总结我想说说
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开始写之前，我犹豫了很久。本来我21年总结和22年计划已经写完了。但是在阅读他人的总结时候，我忽然觉得自己的总结些许潦草，用词也不够华丽，不能给人读完如沐春风的感觉。我想我是不是应该重新修饰下，多些辞藻。一篇给自己的总结，展现真实的2021。
在年初,去了海南三亚游玩。体验了海岛风光。对于阳光沙滩没人能够抵抗，对于免税店没有一个仙女能够免疫。不同于武汉的冷，三亚的冬天真的让人温暖。国庆时段，自驾游玩了湖北宜昌。不是第一次去宜昌，但是每次去都能让人感觉放松。在元旦，尝试了夜爬武当山，当站在山顶的时刻，内心无比满足。这一年出去玩的次数不多不少，确记忆深刻。
重复平凡的生活，让我感觉很满足。这一年，夫妻和睦，偶有争吵，也都能很快和解。一年四季、一如三餐、有人陪有人等。你说它平凡，却也体现难得可贵。经济上，结束了每月的车贷，房租（搬入新家），住房贷款也顺利转入商转公。可以说一下负担减少。
3月的时候，一场突如其来的大面积口腔溃疡让我痛不欲生。在家足足呆了一个多月。期间反复发烧，备受折磨。也是因为这场病，认识到在医学上，人类连口腔溃疡的特效药都还没有发现。联想到疫情，已经过去几年了，但是至今还在困扰着我们。和专家说的一样，需要和病毒共存。想起之前看的纪录片。埃博拉病毒，是一种极具传染性的疾病，称这种病毒前期并不算聪明，因为它会很快让宿体死亡。导致它自身的生存环境没有。随着时间慢慢发展，它开始进化潜伏，作为一个病毒它也有它的努力。
想起我今年看的纪录片音译七个世界、一个星球。无论是拍摄手法还是视频清晰度，以及英文解说都让人有身临其境的感觉。让人看了可以沉迷。但我却没看完，只看了北美洲亚洲非洲这几篇。期间偶尔跟着我家臭臭看了茉莉和老高、李永乐、以及一些关于科技相关的视频。让我受益匪浅，虽然作为小仙女天生对这些反应迟钝，但是看了以后，也是兴趣满满。在臭臭的影响下，我看了一部美剧The doctor，讲述的自闭症墨菲医生一系列成长故事。无论是情感还是医疗相关剧情，挺先进的，让我感觉国外的医院就是这样的。
相比视频，我也看了一些书籍。《中国历史起源绘画本》《人都是逼出来的》《富爸爸与穷爸爸》《蛤蟆先生的心理医生》《可乐牛奶经济学》《Spring实战第四版》。每当我读完一本书的时候，我总是会写下观后感。读书因为是下半年才开始要求自己，所以只能一个月看一本。培养读书的习惯。因为读书我知道了中国的第一个朝代夏朝。知道了商品的起源，也知道每次改朝换代总会有新帝，总结前朝灭亡的原因，进行社会和制度的改革，科举考试也不是第一个朝代就有的，而是经过了改朝换代，多少人努力换来的。也并不是从一开始皇位就是传递给自己儿子的。这些都是历史起源这本书让我懂的。
我读《人都是逼出来的》的时候，我内心是轻蔑的，我一度怀疑这本书骗我钱的。因为通篇全是大道理，你得坚持得努力得自律得选对方向，这不就是活脱脱的鸡汤文么？我一度对这书好感不高，但是开始读了，我还是选择读完。读这本书我选择的方式是朗读。我才知道朗读才能发挥这本书的力量。当每天下班回家，忙碌完一切的时候，在读这本书，你会发现鸡汤自己给自己说多了，自己的思想都变乐观了，会自己在挫败的时候给自己打气会安慰自己拥抱自己。我想这本书的魔力大致就是这样。给我们本不容易的生活，多点鸡汤，让我们元气满满前进。
《富爸爸与穷爸爸》这本书简直家喻户晓，我确才刚刚开始读第一本。在当今环境的影响，我读书的第一反应就是，主角的穷爸爸属于中产阶级了吧，能住富爸爸附近还能让儿子和富爸爸的儿子一个学校。我的固定思维，第一步就是让我想到这个。我如今的现状，父母辈都在外务工，爷爷辈都在家务农。到我这一辈，成绩不算优异，工作不算稳定。我感觉我和穷爸爸的生活都差了一大截。书让我知道我所处的E象限，也让我知道我已经在老鼠赛跑的现金中。我在为他人的资产拼命工作。我所追求的稳定才是生活最大的陷阱。这个认知很重要，因为在很多人一生中，觉得稳定才是最好的。温水煮青蛙这种往往最可怕，没有任何抵御风险的能力。想起老高说的，中国的教育资本主义的陷阱，培养的都是打工人思维。我们从小就是好好学习才能找到好的工作。为富人服务。看了这书，我感觉我激发了自己想要富的想法。但是我还不知如何下手。
《蛤蟆先生的心理医生》这本书我看了一半，很多人推荐。我很难带入。所以放弃了。打算在重新捡起来读。无论好坏，一本书总有它的优点。
技术上的书，我主要是看的PDF版本的。spring、springboot。建议每位学习者都能结合书，我自己一般是先看视频，在看书可以让人很快掌握知识点。是知识成体系。
除了书籍上，运动上我养成了良好的打卡习惯。随着生活日益提升，女孩子发胖的概率又大。为了能穿好看的衣服。基本10月开始，我养生每周4-5次运动40min。运动带来的快乐真的属于持久性的。饮食上我也开始断晚餐，戒糖。
这一年我有积极向上的一面，学历提升上我报名参加了成人高考已考试通过。也有懒惰为主导的时候，我爱刷抖音小红书，爱追剧爱躺平。我没有非常努力。又菜还爱打游戏，但是打游戏频率低了很多。也混上了王者。其实这一年发生了很多事情，我只是挑部分总结。对于21年，我觉得我没有把自己逼的更紧，所以22年的计划我立的更加严格了。
关于博客，本来之前都是记录在印象笔记和个人博客页的，但是想想还是在CSDN也更新。
愿2022年，平平安安。计划都能完成！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2712037d96701da053ce4a7d2fbbd2b6/" rel="bookmark">
			【算法练习】【输入格式总结】A&#43;B
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 哈工大OJ 1001/牛客网 KY226 A+ B
#include&lt;stdio.h&gt; int main(){ int a,b; while(scanf("%d%d",&amp;a,&amp;b) != EOF){ printf("%d\n",a+b); } return 0; } 输入格式（以A+ B为例）
单组输入：
scanf("%d %d",&amp;a,&amp;b); 多组输入，未知组数
while(scanf("%d %d",&amp;a,&amp;b) != EOF){ } 多组输入，指定组数
while(n--){ //记得设置n值哦~ scanf("%d%d",&amp;a,&amp;b); printf("%d\n",a+ b); } 多组输入，特定跳出
while(scanf("%d%d",&amp;a,&amp;b) != EOF){ if(a == 0 &amp;&amp; b == 0){ break; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7fb499e31311a2bc803fb4a3f079040/" rel="bookmark">
			刷穿力扣 | 437. 路径总和 III（一道很多细节的算法题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		元旦做了一个决定，算法是我必须要深入的一门手艺，所以我会要求自己，坚持刷题，而且难题一定要抽出时间死磕。
题目 原题链接：点击这里
难度：中等
思路 这道题，说老实话，上来我的思路就很明确，dfs就能解，并且在白板上两分钟就截了出来。但是我知道这一定不是最优解，很遗憾，我没能自己想出最优解，看了解题很久才明白过来，这是一道很有技巧的算法题，这里会把两种解法都贴出来，dfs和前缀和。
所谓dfs暴力解法，就是穷举所有节点为路径和的初始节点，然后向下递归，每一个节点作为路径和的初始节点有多少满足情况的，再将其相加就好了。
前缀和的解法，使用力扣一个哥们的截图来解释一下。
我们到每一个节点的时候，记录下来根节点到这个节点的路径和，这个数字减去目标路径和就是前面节点应该的路径和的数字，比如到了节点3，路径和是6，目标路径和是5，我们就看前缀和是1的就好了，正好有，数量为1，那么节点3这就有一条路径和满足目标的路径和。
代码 解法一： dfs class Solution { public int pathSum(TreeNode root, int targetSum) { if (Objects.isNull(root)) { return 0; } int value = dfs(root, targetSum); // 穷举所有节点为根节点的情况 return value + pathSum(root.left, targetSum) + pathSum(root.right, targetSum); } private int dfs(TreeNode root, int targetSum) { if (root == null) { return 0; } int value = targetSum - root.val; return value != 0 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7fb499e31311a2bc803fb4a3f079040/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6d1c36713e4fead9510c82a5ea46440/" rel="bookmark">
			MongoDB获取每个分类最新一条完整记录（会话列表、每个班级成绩最高的一名学生....）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做一个消息中心功能，其中有个私信功能用了MongoDB做分表存储，要解决的问题是“获取与每个人聊天的最后一条消息”，也就是像聊天软件的会话列表一样。
例（集合名：chat_msg_2022_1）：
{send_uid: 1, receive_uid: 2, session_name: 12, msg: {type: "text", body: "第一条", send_time:100, read_status: 0}}, {send_uid: 1, receive_uid: 2, session_name: 12, msg: {type: "text", body: "第二条", send_time:200, read_status: 0}}, {send_uid: 1, receive_uid: 9, session_name: 19, msg: {type: "text", body: "第三条", send_time:300, read_status: 0}} 我的ID是1，我想得和2和9聊天的最新一条记录，也就是“第二条”和“第三条”
尝试搜索“MongoDB获取每个分类最新的一条记录”没有找到答案，通过以下方式已解决！
db.chat_msg_2022_1.aggregate([ {$match: {$or: [{"send_uid": 1}, {"receive_uid": 1}]}}, {$group: {_id: "$session_name", last_msg: {$last: "$$ROOT"}}}, ]) 核心的是group、 l a s t 、 last、 last、$ROOT
如果想要获取每个分组的第一条记录，把last改成first即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6d1c36713e4fead9510c82a5ea46440/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be34c583c8e8c1a4f6ca533f971d9de0/" rel="bookmark">
			python json反序列化类对象嵌套字典
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 { "123456": { "money": 10, "hp": 10, "foods": { "apple": 10, "banana": 20 } } } 将一组如上的json结构转化为类对象时，使用函数：
json.loads(json.dumps(data), object_hook=user_decoder) 会导致object_hook的传入参数变为{“apple”: 10, “banana”: 20}
解决方法：舍弃原有的object_hook参数，自行调用user_decoder函数即可：
user = user_decoder(json.loads(json.dumps(data))) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb20a0e9be32712d27aed833f7fd8c1a/" rel="bookmark">
			C语言如何跳出多重循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、题目示例二、解决方法1.使用goto语句2.使用状态标志 总结 前言 在编写代码的过程中，有时需要用到到多层while循环，当在内层的循环中但是想要跳出所有的while循环之外时，简单的使用break语句仅仅只能跳出一层while，已经不能满足要求，以下总结了最近学到的几种方法。
一、题目示例 如何实现当输入a为15，输入b为-3后，跳出所有while循环，去执行最后的输出结束语句？
二、解决方法 1.使用goto语句 代码如下（示例）：
#include &lt;stdio.h&gt; int main() { int a, b, c; printf("请输入a:"); scanf("%d", &amp;a); while (a &gt; 0) { while (a &gt; 5) { while (a &gt; 10) { printf("请输入b:"); scanf("%d", &amp;b); if (b &lt; 0) { goto end;//结束程序 使用跳转语句 } } } } end:	//跳到这 printf("程序结束！！！\n"); return 0; } 运行结果
2.使用状态标志 代码如下（示例）：
#include &lt;stdio.h&gt; int main() { int a, b, c = 1;	//c为状态标志 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb20a0e9be32712d27aed833f7fd8c1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbc840c18d1defe31bb5c1ffeb345ac4/" rel="bookmark">
			Opencv中Mat类详细解读（学习笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于windows10、vs2015、OpenCv4.1.0。
目录
1、Mat类简介
2、Mat类的构造与赋值
2.1、Mat类的构造
2.2、Mat类的赋值
3、Mat类支持的运算
3.1Mat类的加减乘除运算：
3.2两个Mat类矩阵的乘法运算
4、Mat类元素的读取
4.1多通道数据的存储
4.2Mat类常用属性和成员方法
4.3通过at读取Mat类单通道矩阵的元素
4.4通过at读取Mat类多通道矩阵的元素
4.5通过指针ptr读取Mat矩阵种的元素
4.6通过迭代器访问Mat类矩阵中的元素
1、Mat类简介 OpenCv提供了Mat类用来存储矩阵类型数据，包括向量、矩阵、图像等数据。Mat类分为分为矩阵头和指向存储数据的矩阵指针两部分。矩阵头包含矩阵的尺寸、存储方法、地址和引用次数。矩阵头是一个常数，绝大数情况下，矩阵头的大小远小于矩阵数据量的大小。
#include &lt;opencv2\opencv.hpp&gt; #include &lt;iostream&gt; using namespace std; using namespace cv; int main() { Mat a; a = imread("D:\\lena.jpg"); //向a中赋值图像数据 Mat b = a;//只是复制了矩阵头和指向存储数据的指针（指向的是同一个矩阵数据） waitKey(); return 0; } 声明一个指定类型的Mat类：
Mat b = Mat_&lt;double&gt;(3, 3);//创建一个3*3的矩阵存放double类型数据 通过OpenCv数据类型创建Mat类
Mat a(640, 480, CV_8UC3)//创建一个640*480的3通道矩阵用于存放彩色图像 Mat a(3, 3, CV_8UC1);//创建一个3*3的8位无符号整数的单通道矩阵 Mat a(3, 3, CV_8U);//创建单通道矩阵，C1标识可以省略 2、Mat类的构造与赋值 2.1、Mat类的构造 默认构造函数
cv::Mat::Mat(); 这种构造方式，不需要传递任何参数，在后续给变量赋值的时候会自动判断矩阵的类型与大小，实现灵活的存储，常用于存储读取的图像数据和某个函数运算的输出结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbc840c18d1defe31bb5c1ffeb345ac4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3099c774fe8b87c39defd868da4fffd7/" rel="bookmark">
			dicom worklist、pacs环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dcmtk的安装和使用 OFFIS DICOM 工具包 官网：dicom.offis.de - DICOM Software made by OFFIS - DCMTK - DICOM Toolkit
windows版本下载地址：https://dicom.offis.de/download/dcmtk/dcmtk366/bin/dcmtk-3.6.6-win64-dynamic.zip
部分工具包使用方法记录
wlmscpfs .exe 启动worklist管理的SCP服务工具🔗
相关命令：
wlmscpfs.exe -d -dfr -dfp wlistdb 104 -d 可以查看一些输出信息 -dfr 表示接受字段不完整的 DICOM 文件作为查询内容； -dfp wlistdb 表明 wlmscpfs.exe 搜索的文件夹的路径，可以为绝对路径； 104 为工作列表程序的端口号； wlistdb 文件夹下的 OFFIS 表示 AETITLE （AETITLE作为文件夹命名，文件夹下存放查询的wl文件，在该目录下新建一个lockfile的空文件）。 dump2dcm.exe 将ascii dump文件转换成dicom文件工具🔗
用于测试的dump文件可以拉dcmtk的源码 ：GitHub - DCMTK/dcmtk: Official DCMTK Github Mirror，然后在目录dcmwlm/data/wlistdb/OFFIS中查看，
这里选择wlist1.dump
对于dump文件，用记事本打开，可以看到一部分信息，其中比较重要的：
(0010,0010)（患者姓名）、(0010,0020)（患者编号）、(0010,0030)（出生日期）、(0010,0040)（性别）、(0020,000d)（检查号）、(0008,0060)（设备 Modality）、(0040,0001)（AE Title）、(0040,0002)（检查、预约日期）和 (0040,0003)（检查、预约时间）。
相关命令：
dump2dcm.exe wlist1.dump wlist1.wl --write-xfer-little .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3099c774fe8b87c39defd868da4fffd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85b94fe54b606daae6e3721a6270e72a/" rel="bookmark">
			VMware 虚拟机无法上网，显示“网络电缆被拔出”的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录解决方法。
【1】VMware-&gt;虚拟网络编辑器-&gt;更改设置-&gt;还原默认设置。
【2】卸载VMware Tools，重新安装。
【3】本机控制面板-&gt;管理工具-&gt;服务，查看VMware相关服务是否开启，将未开启的服务手动开启。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa4a884c433b6b8dbbb14b1f2bb4d742/" rel="bookmark">
			3种JavaScript 对象转数组的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源 | https://www.fly63.com
我们在项目开发的时候，有时需要将js对象转换为数组，下面小编给大家具体演示一下怎么转换，主要是介绍一些常用、简洁的转换方法。
比如JavaScript对象如下：
let obj = { 'name': '前端', 'url': 'https://www.webadkf.com', 'des': '专注web前端开发', }; 这里只需要它的值，我们需要转换的数组形式如：
['前端', 'https://www.webqdkf.com', '专注web前端开发'] 方式一：Object.values Object.values()方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。
let arr = Object.values(obj); //对象转化为数组 ps：如果只需要返回键作为数组，可以使用Object.keys()的方式,所以结合Map，也可以实现：
let arr=Object.keys(obj).map(function(i){return obj[i]}); //对象转化为数组 方式二：循环 可以直接利用循环，如for in或者forEach()等：
var arr = []; //定义数组 for (var i in obj) { arr.push(obj[i]); } 方式三：Array.from Array.from() 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。
var arr = Array.from(Object.values(obj),x=&gt;x); 学习更多技能
请点击下方公众号
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f8db3d7ef8e41bc06fbbb29a27a2e06/" rel="bookmark">
			一整套稳定ArcGIS给WebGIS做后端的基于SOE的空间分析服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QQ交流群：607330463 GIS开发技术最强交流群 未经允许 禁止转载 可以参考
一整套稳定ArcGIS给WebGIS做后端的基于SOE的空间分析服务器
RestSOE102 HGXJCOperation: 合规性描述：【identName：标识名（必填）】【inputFeature：输入要素json（属性查询可为空）】【bufferRadius：半径（默认为0，属性查询可为空）】【whereClause：查询条件（默认为空，图形为空，该项不能为空）】
LayerInfoOperation: 图层信息描述（只能一个框有值，要么为all要么为图层名）：【layerInfoAll：all或者为空，all获取所有图层】【layerInfo：图层名或者为空，获取指定图层名的所有字段】
PointQueryOperation: 点查询定位图斑描述：【多图层组合（逗号分割,必填）】【x：坐标x必填】【y：坐标y必填】
GlobalQueryOperation: 全局查询描述：【多图层组合（逗号分割,必填）】【whereClause：查询条件】
QueryStatisticsOperation: 查询统计描述：【identName：标识名（必填）】【inputFeature：输入要素json（属性查询可为空）】【bufferRadius：半径（默认为0，属性查询可为空）】【whereClause：查询条件（默认为空，图形为空，该项不能为空）】
TwoPlanConflictOperation: 两规冲突描述：【identName：标识名（必填）】【多图层组合（逗号分割,必填）】【inputFeature：输入要素json（属性查询可为空）】【whereClause：查询条件（默认为空，图形为空，该项不能为空）】
TempGdbPositionOperation: 临时GDB路径描述：【serverFileName：必填，该功能一般分析得出的结果调用定位的文件夹】【gdbPath：必填，该功能一般用于得出的结果调用】【oid：必填，要素oid调用定位图形】
CompareAnalyseOperation: 对比分析描述：【inputFeature：输入要素json（属性查询可为空）】【多图层组合（逗号分割,必填）】【relation：必填，该功能一般用于图层与图层的判断关系】【whereClause：查询条件（默认为空，图形为空，该项不能为空）】
ConflictCheckOperation: 冲突检测描述：【多图层组合（逗号分割,必填）】【inputFeature：输入要素json（属性查询可为空）】【whereClause：查询条件（默认为空，图形为空，该项不能为空）】
ThreeLineCheckOperation: 三线检测描述：【多图层组合（逗号分割,必填）】【inputFeature：输入要素json（属性查询可为空）】【whereClause：查询条件（默认为空，图形为空，该项不能为空）】
GeoDatabaseManagerOperation: 地理空间库管理：【多图层组合（逗号分割,必填）】【workspaceId：管理数据库表中的id】【operateType：操作类型add/delete】：
DownLoadLayerDataOperation: 下载图层数据：【layerName：图层名称】【inputFeature：输入要素json（属性查询可为空）】
UpLoadLayerDataAnalyseOperation: 上传的Shape图层数据进行分析：【layerName：图层名称】【gdbPath：必填，该功能一般用于得出的结果调用】【whereClause：查询条件】
GetDataFromMinioOperation: 从Minio获取数据到服务器并解压：【minioFileNamePath：Minio文件存储路径】
QualityCheckOperation: 质检：【taskId：任务id】【unZipFolder：zip解压路径】【confId：质检配置id】【number：质检类别】
QualityCheckUnZipOperation: 质检解压缩：【zipFilePath：压缩包路径】
QualityDeleteFolderOperation: 质检删除文档：【unFolderPath：质检文档删除路径】
UpLoadLayerDataToSdeOperation: 上传shape图层进入地理空间库：【workspaceId：管理数据库表中的id】【minioFileNamePath：Minio文件存储路径】【sdeTableName：sde库中的表名】
GetGpResultDataOperation: 获取gp服务的结果：【serverFileName：必填，该功能一般分析得出的结果调用定位的文件夹】【gdbPath：必填，该功能一般用于得出的结果调用】
PlanAnalyseOperation: 规划分析描述：【layerName：图层名称】【fieldName：字段名】【gdbPath：必填，该功能一般用于得出的结果调用】【shapeName：上传的shape图层名】【whereClause：查询条件】
PublishServerOperation: 发布服务：【serverFileName：必填，该功能一般分析得出的结果调用定位的文件夹】【gdbPath：必填，该功能一般用于得出的结果调用】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/559625b07eba4e93d2182facb01c191f/" rel="bookmark">
			迁移docker的Root Dir
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、关闭docker [root@ALiYunOgenes ~]# docker info | grep "Root Dir" Docker Root Dir: /var/lib/docker [root@ALiYunOgenes ~]# systemctl stop docker [root@ALiYunOgenes ~]# 二、新建一个目录， 可以是新磁盘下，保证有足够的空间 [root@ALiYunOgenes ~]# mkdir -p /home/docker/lib 三、迁移/var/lib/docker目录下面的文件到 /home/docker/lib(需要时间较久) [root@ALiYunOgenes ~]# rsync -avz /var/lib/docker /home/docker/lib/ ………… docker/volumes/df2adaea4bc3dcd791c9f8c4481e9bb9d48bae83eb8c6b9ef58e3bbba8e4e961/_data/ sent 772,335,084 bytes received 1,092,522 bytes 4,759,554.50 bytes/sec total size is 1,647,644,020 speedup is 2.13 四、配置docker启动时指定 Root Dir [root@ALiYunOgenes ~]# mkdir -p /etc/systemd/system/docker.service.d/ [root@ALiYunOgenes ~]# vim /etc/systemd/system/docker.service.d/devicemapper.conf [Service] ExecStart= ExecStart=/usr/bin/dockerd --graph=/home/docker/lib/docker 五、重新加载 system，启动docker [root@ALiYunOgenes ~]# systemctl daemon-reload [root@ALiYunOgenes ~]# systemctl start docker [root@ALiYunOgenes ~]# 六、验证 [root@ALiYunOgenes ~]# docker info | grep "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/559625b07eba4e93d2182facb01c191f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f88c28affa9d5eecc8ab4dbe26c85c93/" rel="bookmark">
			【笔记】opencv-python中的腐蚀与膨胀函数：图像的膨胀（Dilation）和腐蚀（Erosion）是两种基本的形态学运算，主要用来寻找图像中的极大区域和极小区域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资料1:
import cv2 import numpy as np img = cv2.imread('j.png',0) kernel = np.ones((5,5),np.uint8) erosion = cv2.erode(img,kernel,iterations = 1) dilation = cv2.dilate(img,kernel,iterations = 1) opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel) closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel) 资料2：
注：运行后会闪退，加上cv2.waitKey（0）
import cv2 import numpy as np ## 测试图片，为反斜杠 pic = 'C:/1.jpg' ## a.图像的二值化 ，这里没有做阈值处理 src = cv2.imread(pic,cv2.IMREAD_UNCHANGED) ## b.设置卷积核5*5 kernel = np.ones((5,5),np.uint8) ## c.图像的腐蚀，默认迭代次数 erosion = cv2.erode(src,kernel) ## 效果展示 cv2.imshow('origin',src) ## 腐蚀后 cv2.imshow('after erosion',erosion) import cv2 import numpy as np ## 测试图片，为反斜杠 pic = 'C:/1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f88c28affa9d5eecc8ab4dbe26c85c93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64b6cddbdf295fd909464cf1cca64806/" rel="bookmark">
			Kubernetes中Pod详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、kubectl命令二、基础命令基础命令部署命令集群管理命令故障和调试命令其它命令 三、YAML文件四、Pod介绍4.1 pod存在的意义4.2 Pod实现机制共享网络同一pod内容器共享网络pod1与pod2不在同一主机同一主机中的pod通讯解决方案 共享存储 4.3 Pod中镜像拉取策略4.4 Pod资源限制4.5 Pod重启策略4.6 Pod健康检查4.7 Pod创建流程4.8 创建Pod的调度策略污点容忍 4.9 Pod标签 一、kubectl命令 kubectl是Kubernetes集群的命令行工具，通过kubectl能够对集群本身进行管理，并能够在集群上进行容器化应用的安装和部署
命令格式如下
kubectl [command] [type] [name] [flags] 参数
command：指定要对资源执行的操作，例如create、get、describe、deletetype：指定资源类型，资源类型是大小写敏感的，开发者能够以单数 、复数 和 缩略的形式 例如：
kubectl get pod pod1 kubectl get pods pod1 kubectl get po pod1 name：指定资源的名称，名称也是大小写敏感的，如果省略名称，则会显示所有的资源flags：指定可选的参数，例如，可用 -s 或者 -server参数指定Kubernetes API server的地址和端口 二、基础命令 基础命令 命令介绍create通过文件名或标准输入创建资源expose将一个资源公开为一个新的Servicerun在集群中运行一个特定的镜像set在对象上设置特定的功能get显示一个或多个资源explain文档参考资料edit使用默认的编辑器编辑一个资源delete通过文件名，标准输入，资源名称或标签来删除资源 部署命令 命令介绍rollout管理资源的发布rolling-update对给定的复制控制器滚动更新scale扩容或缩容Pod数量，Deployment、ReplicaSet、RC或Jobautoscale创建一个自动选择扩容或缩容并设置Pod数量 集群管理命令 命令介绍certificate修改证书资源cluster-info显示集群信息top显示资源(CPU/M)cordon标记节点不可调度uncordon标记节点可被调度drain驱逐节点上的应用，准备下线维护taint修改节点taint标记 故障和调试命令 命令介绍describe显示特定资源或资源组的详细信息logs在一个Pod中打印一个容器日志，如果Pod只有一个容器，容器名称是可选的attach附加到一个运行的容器exec执行命令到容器port-forward转发一个或多个proxy运行一个proxy到Kubernetes API Servercp拷贝文件或目录到容器中auth检查授权 其它命令 命令介绍apply通过文件名或标准输入对资源应用配置patch使用补丁修改、更新资源的字段replace通过文件名或标准输入替换一个资源convert不同的API版本之间转换配置文件label更新资源上的标签annotate更新资源上的注释completion用于实现kubectl工具自动补全api-versions打印受支持的API版本config修改kubeconfig文件（用于访问API，比如配置认证信息）help所有命令帮助plugin运行一个命令行插件version打印客户端和服务版本信息 三、YAML文件 k8s 集群中对资源管理和资源对象编排部署都可以通过声明样式（YAML）文件来解决，也就是可以把需要对资源对象操作编辑到YAML 格式文件中，我们把这种文件叫做资源清单文件，通过kubectl 命令直接使用资源清单文件就可以实现对大量的资源对象进行编排部署了。一般在我们开发的时候，都是通过配置YAML文件来部署集群的。
YAML ：仍是一种标记语言。为了强调这种语言以数据做为中心，而不是以标记语言为重点。YAML文件：就是资源清单文件，用于资源编排YAML 是一个可读性高，用来表达数据序列的格式在这里插入代码片 基本语法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64b6cddbdf295fd909464cf1cca64806/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76706062dd5f4e0b46393727dc0ca5de/" rel="bookmark">
			Java工具类-树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.定义树形结构对象
@Data public class TreeData&lt;T&gt; implements Serializable { private Long id; @TableField(exist = false) private String name; @TableField(exist = false) private Long pId; @TableField(exist = false) private String type; @TableField(exist = false) private String idType; @TableField(exist = false) private List&lt;T&gt; children; } 二.定义树形工具类支持泛型
import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; public class TreeUtil { /** * 将平行的树，转化为一颗有层级关系的树 * * @param list * @param pId * @return */ public static &lt;T extends TreeData&gt; List&lt;T&gt; getTreeList(List&lt;T&gt; list, Long pId) { if (list == null) { return null; } //获取所有头节点 List&lt;T&gt; rootNode = new ArrayList&lt;&gt;(); for (T treeData : list) { if (treeData.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76706062dd5f4e0b46393727dc0ca5de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5bf2d60a47de3da6374f0f1866f180d/" rel="bookmark">
			六种酷炫Python运行进度条效果的实现代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍了目前6种比较常用的进度条，让大家都能直观地看到脚本运行最新的进展情况
1.普通进度条
在代码迭代运行中可以自己进行统计计算，并使用格式化字符串输出代码运行进度
import sys import time def progress_bar(): for i in range(1, 101): print("\r", end="") print("Download progress: {}%: ".format(i), "▋" * (i // 2), end="") sys.stdout.flush() time.sleep(0.05) progress_bar() 进度条1
2.带时间进度条
导入time模块来计算代码运行的时间，加上代码迭代进度使用格式化字符串来输出代码运行进度
import time scale = 50 print("执行开始，祈祷不报错".center(scale // 2,"-")) start = time.perf_counter() for i in range(scale + 1): a = "*" * i b = "." * (scale - i) c = (i / scale) * 100 dur = time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5bf2d60a47de3da6374f0f1866f180d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe27a113e86057113a06d0bfa68be806/" rel="bookmark">
			batchsize、iteration、epoch之间的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		batchsize、iteration、epoch之间的关系 有的时候总是会弄错batchsize、iteration、epoch之间的关系，现在终于明白了。
1、batchsize是批次大小，假如取batchsize=24，则表示每次训练时在训练集中取24个训练样本进行训练。
2、iteration是迭代次数，1个iteration就等于一次使用24（batchsize大小）个样本进行训练。
3、epoch，1个epoch就等于一次使用训练集中全部样本训练一次。
如果训练样本为1000，batchsize=24，则训练一个完整的样本集需要1个epoch，需要迭代50（1000/24=50）次。
如有疑问，欢迎大家一起讨论
主要是记录一下自己平时遇到的问题，和大家分享一下
如有侵犯，请联系我
点个赞支持一下吧
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/70/">«</a>
	<span class="pagination__item pagination__item--current">71/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/72/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>