<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dbd74e1d157b5647acf26ac1bca66b6/" rel="bookmark">
			C&#43;&#43;&amp;Python&amp;C# 三语言OpenCV从零开发(8):图像平滑处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 相关链接前言图像资源图像平滑处理图像学知识补充(重点)什么是卷积什么是图像滤波什么是方框滤波和均值滤波 代码PythonC++Csharp 总结 相关链接 C++&amp;Python&amp;Csharp in OpenCV 专栏
【2022B站最好的OpenCV课程推荐】OpenCV从入门到实战 全套课程（附带课程课件资料+课件笔记）
前言 这次来了解一下图像平滑处理。还是老套路，先写Python，再C++，再Csharp。本篇文章难的不是代码，难的是图像学的知识
图像资源 为什么Lena的那张图会成为数字图像处理的标准图？
图像平滑处理 图像平滑处理就是PS中常用的模糊工具，涂抹工具。算法怎么计算的可以看这个文章
数字图像处理之均值滤波
图像学知识补充(重点) 本章的难点就是图形学的知识了。这里推荐一本书【数字图像处理(中译第三版)[冈萨雷斯]】
目录简单展示
什么是卷积 卷积是一种叠加态的问题的解法。叠加态的问题有：
水池有两个水龙头，一个放水一个抽水。人一天的体重变化，早餐还没彻底消化完，就吃午餐了冰箱里面的食物整体的新鲜度。不新鲜的会被拿走，新鲜的食材会被放进来湖泊的水位，下雨天水位上升，不下雨水位慢慢下降 这个就是卷积的特点：叠加状态。
那么图像的卷积是什么意思？就是考虑到每个像素对应周围像素的影响，卷积后的图像是卷积前的图像像素叠加卷积的结果。通俗点来说，就是黑色像素点周围黑一点，自己白一点。白色像素点周围白一点，自己黑一点。
就像你用墨水写字，然后用水浇上去，字就糊了。这个过程就是卷积。
如何通俗易懂地解释卷积？
瞬时行为的持续性后果，用吃冰淇淋来理解卷积
什么是图像滤波 图标滤波就是对图像的噪点进行抑制，尽量不影响图像的信息量。如果不了解这两个概念，可以近似的看成。
卷积是方法论，是公式图像滤波是具体实现。 数字图像处理——图像滤波概念及方法
什么是方框滤波和均值滤波 我感觉两个差不多。
十分钟带你了解均值滤波和方框滤波
代码 Python # %% import cv2 import matplotlib.pyplot as plt import numpy as np image_src = cv2.imread('d:\workSpace\OpenCV\HellOpenCV\Resources\images\lena.png') image_config = (7,7) # 均值滤波 # 最简单的卷积操作 image_blur = cv2.blur(image_src,image_config) # 方框滤波，基本和均值一样 image_box_t = cv2.boxFilter(image_src,-1,image_config,normalize=True) # 方框滤波，反方向 image_box_f = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dbd74e1d157b5647acf26ac1bca66b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4394780dd8b63c32f93e529a1cdf17c3/" rel="bookmark">
			微信网页授权之使用完整服务解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
微信网页授权能力调整造成的问题
能力调整的内容和理由
原有运行方案
is_snapshotuser字段 改造原有方案
如何复现测试场景
小结
微信网页授权能力调整造成的问题 依附于第三方的开发，做为开发者经常会遇到第三方进行规范和开发的调整，如开发腾讯微信的相关应用。我所经历的如小程序隐私政策调整、信息备案调整、微信授权获取个人信息限制调整等。
最近我们的一些项目因为微信页面授权能力的调整出现了一些问题，对于新用户未经授权前，微信开发团队给出的输出是快照页，该页内所获取的openId等均为虚拟账号数据，并在屏幕下方非常不明显的显示“使用完整服务”，如下图所示：
此图即是微信给出的授权提示，也是我们折中的解决方案，图中所示的提示框源自己于我们通过携带的参数反馈给用户的提示，以引导用户点击下方的“使用完整服务”链接，并进行授权。
能力调整的内容和理由 微信团队给出的解释是当开发者在网页中在不规范使用发起 snsapi_userinfo 网页授权时，微信将默认打开网页快照页模式进行基础浏览。
微信网页授权规范
授权流程需引导清晰、准确：在申请获取用户信息的弹窗出现前，应该清晰、准确地告知用户获取信息的范围及获取信息的目的；必要场景申请：在必须获取用户信息时才申请，而不是用户尚未了解服务前就强制弹窗。如使用医院挂号时才需要获取用户信息；不强制登录：提供游客模式，供用户了解网页提供的基础服务，不强制用户允许网页获取用户信息后才能使用网页服务。 常见的微信网页授权不规范使用案例
强制登录：在用户打开网页时立即要求用户授权，用户拒绝后无法使用网页提供的服务；违规收集个人信息：未在网页提前告知使用个人信息的目的、方式和范围；非必要收集：非必要获取用户信息的网页，如文章、视频等，要求用户在浏览内容前登录；差别对待微信用户：同样的网页在浏览器内可以无需登录直接访问，在微信内却要求用户先登录才可访问。 原有运行方案 微信OA2授权访问地址如下(示例url为C#字符串)：
https://open.weixin.qq.com/connect/oauth2/authorize?appid=wx7964497eb8bad783&amp;amp;redirect_uri=https%3A//www.leadihr.com/weixin/oa2.aspx%3F&amp;amp;response_type=code&amp;amp;scope=snsapi_userinfo&amp;amp;state=1#wechat_redirect&amp;amp;connect_redirect = 1 重定向接收地址 OA2.ASPX程序 （C#版本）
using System; using System.Collections.Generic; using System.IO; using System.Linq; using System.Text; using System.Web; using System.Web.Security; using System.Web.UI; using System.Web.UI.WebControls; using System.Xml; using System.Collections; using System.Net; using System.Text.RegularExpressions; using Newtonsoft.Json; using Newtonsoft.Json.Linq; using LitJson; using System.Data; using System.Data.SqlClient; using CosysJaneCommonAPI; using System.Web.Script.Serialization; using System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4394780dd8b63c32f93e529a1cdf17c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ffa053743d8eddebe1d509f3a9dc0f7/" rel="bookmark">
			快速幂与矩阵快速幂（c&#43;&#43;入门必学算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习矩阵快速幂之前，我们先来做一道题目
题目描述 给你三个整数 a , b , p a,b,p a,b,p，求 a b m o d p a^b \bmod p abmodp。
输入格式 输入只有一行三个整数，分别代表 a , b , p a,b,p a,b,p。
输出格式 输出一行一个数 ，其中 a , b , p a,b,p a,b,p 分别为题目给定的值， s s s 为运算结果。
样例 #1 样例输入 #1 2 10 9 样例输出 #1 7 提示 样例解释
2 10 = 1024 2^{10} = 1024 210=1024， 1024 m o d 9 = 7 1024 \bmod 9 = 7 1024mod9=7。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ffa053743d8eddebe1d509f3a9dc0f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/274211ee1a30b6ed099e26fd8e07b389/" rel="bookmark">
			【数据结构】实现顺序表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是苏貝，本篇博客带大家了解顺序表，如果你觉得我写的还不错的话，可以给我一个赞👍吗，感谢❤️
目录 一.概念及结构二.接口实现2.1 创建顺序表结构体2.2 初始化顺序表2.3 销毁顺序表2.4 打印顺序表2.5 尾插2.6 头插2.7 尾删2.8 头删2.9 任意位置插入2.10 任意位置删除2.11 查找并返回下标 三.模块化代码实现3.1 SeqList.h3.2 SeqList.c3.3 test.c3.4 结果演示 一.概念及结构 顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存储。在数组上完成数据的增删查改。
顺序表一般可以分为：
1.静态顺序表：使用定长数组存储元素。
2.动态顺序表：使用动态开辟的数组存储。
二.接口实现 静态顺序表只适用于确定知道需要存多少数据的场景。静态顺序表的定长数组导致N定大了，空间开多了浪费，开少了不够用。所以现实中基本都是使用动态顺序表，根据需要动态的分配空间大小，所以下面我们实现动态顺序表。
首先在编译器中建立3个文件：SeqList.h文件，即一个头文件，用来声明；SeqList.c文件，用来实现顺序表的增删查改基本功能；test.c文件，用来测试代码
2.1 创建顺序表结构体 因为顺序表信息包括一个动态数组、数据个数和数组容量，后两者都是int型，数组的类型不确定，而且它们所占空间大小不同，所以我们想到创建一个顺序表结构体，为了书写方便，我们将struct SeqList重命名为SL
因为我们不知道多态数组的类型，所以将它的类型定为SLDataType，如果我们后来知道了动态数组的类型，比如是int型，只要将int重命名为SLDataType即可
typedef int SLDataType; typedef struct SeqList { SLDataType* a;//指向动态开辟的数组 int size;//有效数据个数 int capacity;//数组的容量 }SL; 2.2 初始化顺序表 因为初始化顺序表会改变顺序表，所以不能采用传值调用，只能传址，即将顺序表的地址传过来。因为顺序表结构体不能为NULL，所以对它断言，接口都需要使用顺序表结构体，所以每个接口都需要对它断言。
注意：size是最后一个有效数据的下一个索引，因为初始化的时候还没有有效数据，所以size置为0
void SLInit(SL* s) { assert(s); s-&gt;a = NULL; s-&gt;size = 0; s-&gt;capacity = 0; } 2.3 销毁顺序表 因为我们开辟的是动态数组，所以需要在程序结束前将数组所占空间释放，再让指向该数组的指针a置为NULL
void SLDestroy(SL* s) { assert(s); if (s-&gt;a !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/274211ee1a30b6ed099e26fd8e07b389/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80c3a07dcb5330ab828458490be33869/" rel="bookmark">
			c语言笔记 三 变量和常量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上面我们已经学习了c语言当中的基本数据类型，如int short long char等 希望大家可以敲一下代码验证一下每个数据类型的字节大小加深理解。废话不多说 开始今天的笔记
目录
一变量
1.1 概述
1.2运算符
1.2.1概述
1.2.2 算数运算符
1.2.3 关系运算符
1.2.4 逻辑运算符
1.2.5位运算符
1.2.6赋值运算符
1.2.7 三目运算符
1.2.8 逗号运算符
1.2.9sizeof运算符
1.3变量的定义
1.4变量的初始化
1.4.1变量不初始化
1.5变量的声明
1.5.1 概述
1.5.2 声明的类型
二关于本节相关代码验证
2.1 ++i和i++ 2.2 i-- 和--i
2.3&amp;&amp;
2.4 ||
2.5左移和右移
2.6复合运算符
一变量 1.1 概述 ：变量顾名思义是在程序运行期间可能会改变或被赋值这些称为变量 变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。
1.2运算符 1.2.1概述 ：表示数据之间的运算 就相当于数学里面的加减乘除等等
1.2.2 算数运算符 基本的五种：+ ：-
:* (×)
:/ (÷)
: % 取余
补充：c语言当中特色的运算符 ++ ：自增运算符 ，只适用于变量 ：比如 i++（i是变量的名字这里没那么明白没关系 结
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80c3a07dcb5330ab828458490be33869/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96bdc1d643b7005b3383059e20d0787c/" rel="bookmark">
			Vue基础知识七
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 路由 1.1 生活里的路由与路由器 是为了实现多台设备上网
1.2 程序里的路由与路由器 是为了实现导航区与展示区来回切换；
SPA单页面应用：就像前几章节里的项目，整个项目只有一个html文件；
案例
注意，最开始的时候，地址栏后边没有任何后缀
当点击左侧"班级管理"后，地址栏的地址有了变化（但是浏览器左上角的刷新按钮没有刷新，即只有一个页面）
浏览器路径一旦发生变化，就会被vue-router（vue里的路由器）监测到；vue-router拿着地址栏里的后缀class去找我们配置过的路由规则，根据规则最终展示班级组件
其中，class就是路由里的key，班级组件就是路由里的value；
同理，点击左侧"学科管理"时，发生如下过程
1.3 vue-router 的理解 vue 的一个插件库，专门用来实现 SPA 应用
对 SPA 应用的理解
单页 Web 应用（single page web application，SPA）。整个应用只有一个完整的页面（index.html）。点击页面中的导航链接不会刷新页面，只会做页面的局部更新。数据需要通过 ajax 请求获取。 1.4 路由的理解 什么是路由
一个路由就是一组映射关系（key - value）key 为路径, value 可能是 function 或 component 路由分类
后端路由： 理解：value 是 function, 用于处理客户端提交的请求。工作过程：服务器接收到一个请求时, 根据请求路径找到匹配的函数来处理请求, 返回响应数据。 前端路由： 理解：value 是 component，用于展示页面内容。工作过程：当浏览器的路径改变时, 对应的组件就会显示。 二 路由基本使用 安装vue-router
npm -i vue-router main.js里引入vueRouter
此时，vm就会多出来一个新的配置项：router（路由器）；配置前需要先创建出一个路由器
在main.js里配置这个路由器
使用路由后，不能使用原始的a标签实现跳转了，需要使用router-link标签；且不能使用href了，要改为to
指定一下组件内容要出现的位置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96bdc1d643b7005b3383059e20d0787c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05666c5fd4c99586cffeecfacc2ca6b2/" rel="bookmark">
			【ACL 2023】Enhancing Document-level EAE with Contextual Clues and Role Relevance
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【ACL 2023】Enhancing Document-level Event Argument Extraction with Contextual Clues and Role Relevance 论文：https://aclanthology.org/2023.findings-acl.817/
代码：https://github.com/LWL-cpu/SCPRG-master
Abstract 与句子级推理相比，文档级事件论元抽取在长输入和跨句推理方面提出了新的挑战。然而，大多数先前的工作都集中在捕捉每个事件中候选论元和事件触发词之间的关系，忽略了两个关键点：a）非论元上下文线索信息；b） 论元角色之间的相关性。在本文中，我们提出了一个SCPRG（基于跨度触发词的上下文池化和潜在角色引导）模型，该模型包含两个新颖有效的模块来解决上述问题。基于跨度触发的上下文池化（STCP）基于预训练模型中特定论元-触发词对的上下文注意力权重，自适应地选择和聚合非论元线索词的信息。基于角色的潜在信息引导（RLIG）模块构建潜在角色表示，使其通过角色交互编码进行交互，以获取语义相关性，并将其合并为候选论点。与基本模型相比，STCP和RLIG都引入了不超过1%的新参数，并且可以很容易地应用于其他事件抽取模型，这些模型紧凑且可移植。在两个公共数据集上的实验表明，我们的SCPRG优于以前最先进的方法，在RAMS和WikiEvents上分别改进了1.13 F1和2.64 F1。进一步的分析说明了我们模型的可解释性。
Introduction 然而，先前所有SOTA的作品都忽略了两个关键点：（a）非论元的线索信息；（b） 论点角色之间的相关性。
非论元线索是除目标论元外的上下文文本，可以为预测许多复杂的论元角色提供重要的指导信息。例如，在图1中，对于Conflict and Attack事件，非论元线索被detonated, claim responsibility 和 terrorist attack可以为识别论元explosive belts和Islamic State提供重要的线索信息。然而，以前的许多工作只使用了经过预训练的Transformer编码器隐式获取全局上下文信息，忽略了对于事件中出现的不同论元，他们应该关注与实体和目标事件高度相关的上下文信息。因此，在本文中，我们设计了一个基于跨度触发词的上下文池化（STCP）模块，该模块基于预训练模型中的上下文注意力乘积，将每个论元-触发词对的非论元线索的信息合并，用额外的相关上下文信息增强候选论元的表示。
一些论元角色具有密切的语义相关性，这有利于论元抽取。例如，在图1中，角色injurer和victim之间存在密切的语义相关性，这可以为目标事件Conflict and Attack中这两个角色的论点抽取提供重要的信息指导。此外，许多角色共同发生在多个事件中，这可能具有密切的语义相关性。具体而言，我们统计并可视化了图2中RAMS数据集中15个最频繁角色之间的共现频率。例如，attacker, target 和 instrument的角色经常同时出现，这表明它们在语义上比其他角色更相关。在本文中，我们提出了一个基于角色的潜在信息引导（RLIG）模块，该模块由角色交互编码和角色信息融合组成。具体来说，我们设计了一个角色交互编码器，将角色添加到输入序列中，其中角色嵌入不仅可以学习角色的潜在语义信息，还可以捕捉角色之间的语义相关性。然后，通过池化和串联操作将潜在的角色嵌入合并到候选论元中，为文档级EAE提供信息指导。
针对上述两个问题，本文分别提出了一个有效的文档级EAE模型SCPRG（Span-trigger-based Contextual Pooling and Role-based Potential information Guidance），该模型包含STCP模块和RLIG模块。值得注意的是，这两个模块利用了来自预训练的语言模型的学习良好的注意力权重，引入了不超过1%的新参数，并且很容易应用于其他紧凑且可移植的事件抽取模型。此外，我们试图通过排除有争议的不可能跨度来消除噪声信息。我们的贡献总结如下：
我们提出了一个基于跨度触发词的上下文池化模块，该模块自适应地选择和聚合非论元线索的信息，用相关的上下文信息增强候选论元的表示。我们提出了一个基于角色的潜在信息指导模块，该模块提供包含角色之间语义相关性的潜在角色信息指导。大量实验表明，SCPRG的性能优于之前的最新模型，在公共RAMS和WikiEvents数据集上分别提高了1.13 F1和2.64 F1。我们进一步分析了注意力权重和潜在角色表征，这表明了我们模型的可解释性。 Method 文档级时间论元抽取可以作为一个多分类问题。给出一个文档 D D D包含 N N N个单词， D = { w 1 , w 2 , … , w N } D=\{ w_1,w_2,\dots,w_N \} D={w1​,w2​,…,wN​}，预定义的事件类型集合 E \mathcal{E} E，对应的论元角色集合 R e \mathcal{R}_e Re​，触发词 t ∈ D t \in D t∈D，每一个事件 e ∈ E e \in \mathcal{E} e∈E。该任务的目的是预测出文档 D D D中的所有事件对 ( r , s ) (r,s) (r,s)。其中 r ∈ R e r \in \mathcal{R}_e r∈Re​是事件 e ∈ E e \in \mathcal{E} e∈E的论元角色， s ⊆ D s \subseteq D s⊆D。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05666c5fd4c99586cffeecfacc2ca6b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7457ceb247eec7deff550c2b9319e3ee/" rel="bookmark">
			C语言第十二弹--扫雷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨个人主页： 熬夜学编程的小林
💗系列专栏： 【C语言详解】 【数据结构详解】
扫雷
1、扫雷游戏分析和设计
1.1、扫雷游戏的功能说明
1.2 游戏的分析和设计
1.2.1、数据结构的分析
1.2.2、文件结构设计
2、扫雷游戏的结构分析
2.1、用户选择
2.2、初始化棋盘
2.3、设置雷
2.4、排雷
3、扫雷游戏分文件的代码实现
3.1、test.c
3.2、game.c
3.3、game.h
4、扫雷游戏的扩展
总结
1、扫雷游戏分析和设计 1.1、扫雷游戏的功能说明 • 使用控制台实现经典的扫雷游戏
• 游戏可以通过菜单实现继续玩或者退出游戏
• 扫雷的棋盘是9*9的格子
• 默认随机布置10个雷
• 可以排查雷
◦ 如果位置不是雷，就显示周围有几个雷
◦ 如果位置是雷，就炸死游戏结束
◦ 把除10个雷之外的所有非雷都找出来，排雷成功，游戏结束
游戏的界面：
1.2 游戏的分析和设计 1.2.1、数据结构的分析 扫雷的过程中，布置的雷和排查出的雷的信息都需要存储，所以我们需要⼀定的数据结构来存储这些信息。
因为我们需要在9*9的棋盘上布置雷的信息和排查雷，我们首先想到的就是创建⼀个9*9的数组来存放信息。
那如果这个位置布置雷，我们就存放1，没有布置雷就存放0.
假设我们排查(2,5)这个坐标时，我们访问周围的⼀圈8个位置，统计周围雷的个数是1
假设我们排查(8,6)这个坐标时，我们访问周围的⼀圈8个位置，统计周围雷的个数时，最下面的三
个坐标就会越界，为了防止越界，我们在设计的时候，给数组扩大⼀圈，雷还是布置在中间的9*9的坐标上，周围⼀圈不去布置雷就行，这样就解决了越界的问题。所以我们将存放数据的数组创建成11*11是比较合适。
再继续分析，我们在棋盘上布置了雷，棋盘上雷的信息（1）和非雷的信息（0），假设我们排查了某个位置后，这个坐标处不是雷，这个坐标的周围有1个雷，那我们需要将排查出的雷的数量信息记录存储，并打印出来，作为排雷的重要参考信息的。那这个雷的个数信息存放在哪里呢？如果存放在布置雷的数组中，这样雷的信息和雷的个数信息就可能或产生混淆和打印上的困难。
这里我们肯定有办法解决，比如：雷和非雷的信息不要使用数字，使用某些字符就行，这样就避免冲突了，但是这样做棋盘上有雷和非雷的信息，还有排查出的雷的个数信息，就比较混杂，不够方便。
这里我们采用另外⼀种方案，我们专门给⼀个棋盘（对应⼀个数组mine）存放布置好的雷的信息，再给另外⼀个棋盘（对应另外⼀个数组show）存放排查出的雷的信息。这样就互不干扰了，把雷布置到mine数组，在mine数组中排查雷，排查出的数据存放在show数组，并且打印show数组的信息给后期排查参考。
同时为了保持神秘，show数组开始时初始化为字符 '*'，为了保持两个数组的类型⼀致，可以使用同⼀套函数处理，mine数组最开始也初始化为字符'0'，布置雷改成'1'。如下如：
对应的数组应该是：
char mine[11][11] = {0};//用来存放布置好的雷的信息
char show[11][11] = {0};//用来存放排查出的雷的个数信息
1.2.2、文件结构设计 之前学习了多文件的形式对函数的声明和定义，这里我们实践⼀下，我们设计三个⽂件：
test.c //文 件中写游戏的测试逻辑 game.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7457ceb247eec7deff550c2b9319e3ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcd3f67498558a3e231f31e2c9cc067d/" rel="bookmark">
			问题：放松的能力是指在____强度之下的____ #知识分享#笔记#媒体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：放松的能力是指在____强度之下的____
参考答案如图所示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71e7baf676798b0fb5c1e1d768d40219/" rel="bookmark">
			vite&#43;vue3 打包后本地预览（不需要起服务）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、vue.config.js添加下面配置
如果打包报错就安装依赖
pnpm i @vitejs/plugin-vue -D pnpm i @vitejs/plugin-legacy -D import { defineConfig } from 'vite'; import vue from '@vitejs/plugin-vue'; import legacy from '@vitejs/plugin-legacy'; export default defineConfig({ base:"./", plugins:[ vue(), legacy({ targets:["defaults","not IE 11"], }) ] }); 二、路由必须是 createWebHashHistory 模式
import { createRouter, createWebHashHistory } from 'vue-router'; import routes from './routes'; const router: Router = createRouter({ history: createWebHashHistory(), routes: routes, }); 如果代码报错, 根据错误自行安装所需依赖即可
三、以上配置ok, 在打开index.html文件即可本地预览
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1568d45c00f96fa46c4714991196395/" rel="bookmark">
			C#（Csharp）学习这一篇文章就够了！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学唐老狮的课程 顺便ab自己记录一下
C#是面向对象语言，也具备三大特征，ab会从这里开始。
C#——封装： 1.类和对象： 类的声明 和 类对象 声明是两个概念。
类的声明： 相当于自定义一个变量类型。
类对象：是从类里创建出来的，而创建对象的过程称之为实例化对象。
2.成员变量和访问修饰符： 成员变量：要声明在类中，用来描述对象的特征，可以是任意变量类型(可以在一个类中声明别的类)，同时成员变量的数量不做限制，而是否要赋值根据需求决定。
成员变量的默认值： 值类型 数字类型都是0，bool类型为false，引用类型为null。
注意: 如果要在类中声明一个和自己相同类型的成员变量时，不能对它进行实例化。
访问修饰符：
public —公共的：自己（内部）和别人（外部）都能访问和使用。‘
private —私有的： 自己（内部）才能访问和使用；不写的时候默认为private。
protected —保护的： 自己（内部）和子类才能访问和使用。
3.成员方法： 成员方法（函数）用来表现对象行为，并且受到访问修饰符的影响，返回值参数不做限定，成员方法的数量也不做限制。
注意： 成员方法不能加Static关键字，使用时必须实例化出对象，再通过对象使用（可以想成某个对象执行了某个行为）。
练习： 定义一个老师类和学生类，再定义一个实物类，有名字，并让他们联系起来
如：老师吃了什么什么,学生吃了什么什么。
4.构造函数： 在实例化对象（new对象）时，会调用用于初始化的函数，就叫做构造函数。在不写构造函数的时候，会有一个默认的无参构造函数。
构造函数的写法：没有返回值，函数名必须和类名相同，没有特殊需求时都是public，并且构造函数可以被重载。
注意： 如果自己没有写无参构造函数，却写了有参构造函数，默认的无参构造函数会被顶掉。
练习： 5.成员属性： 是用于保护成员变量的，为成员变量的获取和赋值添加逻辑处理，也可以解决public，private，protected的局限性。属性可以让成员变量在外部（可读不可写)，(可读只有本类可写)等等.
上面就是一个属性，相当于把小写的name包裹了一层。
get和set可以只写一个
注意： 1. 当get set前面什么都不写时，会使用声明时的访问权限。
2.加的访问修饰符要低于属性的访问权限。（get和set的访问权限不能比声明变量时的大）
3.不能让get和set的权限都低于属性的权限。（两个都写就让声明的访问修饰符没用了） 6.静态成员： 用Static修饰的成员变量，方法，属性等，都叫做静态成员。
静态成员可以直接通过类名点出来使用
静态成员属于这个类！并不属于这个类的实例对象。
注意： 静态成员在程序运行后就会存在。静态函数中不能使用非静态成员（因为成员变量要将对象实例化出来后,才能点出来使用,不能无中生有），想要使用可以在静态函数中实例化一个。
报错
没报错
说的更细一点就是 静态成员方法在程序一运行就有了，但是你还没有声明别的变量，所以此时不能使用非静态变量（无中生有了就是）， 但是如果你在静态成员方法中实例化了过了，那就能用。
常量和静态变量的区别：
相同点：他们都可以通过类名点出来使用。
不同点：1.const必须初始化 不能修改，而static没有这个限制。
2.const只能修饰变量，static可以修饰很多。
3.const一定是卸载访问修饰符后的，static没有这个要求。
7.静态类和静态构造函数： 静态类：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1568d45c00f96fa46c4714991196395/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/055abadb9e1f206940ace1d6e3e55a9b/" rel="bookmark">
			研究生必备：从0到1使用Zotero
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、初识zotero：文献导入与引用 1.安装地址：https://www.zotero.org/
点击下一步一直安装。
编辑–首选项–高级–选择语言为中文
2.文献导入
（1）在我的文库下面可以新建文件夹，在中间标题部分可以拖进去本地下载的PDF，然后就能自动显示文献的信息。
（2）也可以通过插件来进行管理，插件就是在开头图片中的Zotero Connector。
通过点击谷歌浏览器的插件，然后就能显示出网页上搜索出来的论文，勾选需要导入zotero的论文。在zotero中可以直接打开pdf，使用的是zotero的内置阅读器，这个阅读器还可以进行英文翻译。
（3）可以通过以下截图中的方式导入
3.在word中进行引用
安装完成zotero，word中会自动显示出来。
点击下图红框中的内容可以选择添加的参考文献格式。
没有国标格式，可以进行添加。
点击Add/Edit Citation添加参考文献，会在添加的位置出现上标。
点击第三个按钮，回车一下，就会显示出具体的参考文献(需要将光标放置在需要插入参考文献的地方)。
此处引文文献，等应该换成et al，根据以下参考文献的示例。
二、联动sci-hub实现英文文献批量下载 三、Zotero英文文献翻译必备插件 四、Zotero使用茉莉花插件抓取中文文献 1.github搜索jasminum
点击Releases
进行下载
2.将插件进行安装。选择工具–插件。
点击从文件进行安装。
点击Install Now.
然后Restart now
3.进行插件的设置以及翻译器的更新
（1）点击编辑–首选项–茉莉花–勾选第一项
（2）点击非官方维护中文翻译器，点击刷新–更新全部
然后还需要在浏览器中更新翻译器
如果Google浏览器中没有加载出来Zotero，解决方法见：Zotero 更新 知网Translator 翻译器教程视频3:22 看文件是否生效（没有识别出来）
回答：在zotero的图标上右键，点击zotero connector的选项，然后如下图所示。
也可以把Enable Logging的选项选择上，点更新的时候，会有数字的变动。
这种方法操作完之后，重启浏览器，如果还是没有显示zotero。可以利用浏览器的隐私窗口，让其可以使用。在edge中的操作如下，发现还是没有更新。
如何在浏览器中更新翻译器？
五、Zotero、坚果云、zotfile实现跨平台云同步 1.注册Zotero和坚果云
zotfile：http://zotfile.com/
2.在坚果云中进行授权
点击验证服务器
3.安装zotfile插件
第五部分可参考：【从零开始读研】跨平台文献管理方案，Zotero+坚果云，实现Ipad论文笔记同步存储
借助坚果云来同步Zotero文献数据(有用)
zotero的最佳打开方式和同步策略（针对zotfile的配置详细，有用）
参考链接：
1.文献管理神器Zotero零基础系列教程（参考这个即可，简单搞笑）
2.【小白入门】Zotero安装与配置
文字专栏见：Zotero：科研小白的第一款文献管理软件 - Eleven的文章 - 知乎
https://zhuanlan.zhihu.com/p/347493385
本次使用到的ppt及插件：
https://cowtransfer.com/s/654bf00b5ce14d
六、遇到的问题： 1.Word中没有Zotero加载项 Word中没有Zotero加载项（超有用）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/055abadb9e1f206940ace1d6e3e55a9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08396c6116af57a43fb0c59235799fe4/" rel="bookmark">
			kubernetes基本概念和操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本概念和操作 1.Namespace1.1概述1.2应用示例 2.Pod2.1概述2.2语法及应用示例 3.Label3.1概述3.2语法及应用示例 4.Deployment4.1概述4.2语法及应用示例 5.Service5.1概述5.2语法及应用示例5.2.1创建集群内部可访问的Service5.2.2创建集群外部可访问的Service5.2.3删除服务5.2.4对象配置方式 1.Namespace 1.1概述 Namespace是kubernetes系统中一种非常重要的资源，它的主要作用是用来实现多套系统的资源隔离或者多租户的资源隔离。
默认情况下，kubernetes集群中的所有Pod都是可以相互访问的。但是在实际中，可能不想让两个Pod之间进行互相的访问，那么此时就可以将两个Pod划分到不同的Namespace下。kubernetes通过将集群内部的资源分配到不同的Namespace中，可以形成逻辑上的“组”，以方便不同的组的资源进行隔离使用和管理。
可以通过kubernetes的授权机制，将不同的Namespace交给不同租户进行管理，这样就实现了多租户的资源隔离。此时还能结合kubernetes的资源配额机制，限定不同租户能占用的资源，例如CPU使用量、内存使用量等等，来实现租户可用资源的管理。
kubernetes在集群启动之后，会默认创建几个namespace
kubectl get namespace ● default：所有未指定的Namespace的对象都会被分配在default命名空间。
● kube-node-lease：集群节点之间的心跳维护，v1.13开始引入。
● kube-public：此命名空间的资源可以被所有人访问（包括未认证用户）。
● kube-system：所有由kubernetes系统创建的资源都处于这个命名空间。
1.2应用示例 查看所有名称空间
kubectl get namespace 或 kubectl get ns 查看指定名称空间
kubectl get namespace default 或 kubectl get ns default 指定命名空间的输出格式
kubectl get ns default -o wide kubectl get ns default -o yaml # yaml格式输出 kubectl get ns default -o json # json格式输出 查看命名空间详情
kubectl describe ns default 或 kubectl describe namespace default 创建命名空间
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08396c6116af57a43fb0c59235799fe4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d049e33e547ea8d341af45526dae424/" rel="bookmark">
			ESP32光敏传感
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import pyb # 导入相关模块 from machine import Pin,I2C from ssd1306 import SSD1306_I2C i2c = I2C(sda=Pin("Y8"), scl=Pin("Y6")) # 初始化相关模块 oled = SSD1306_I2C(128, 64, i2c, addr=0x3c) Light = pyb.ADC('Y11') # 初始化 ADC,Pin='Y11' while True: oled.fill(0) # 清屏显示黑色背景 oled.text('Light test:', 0, 15) # 显示实验名称 value=Light.read() # 获取ADC数值 oled.text(str(value)+' (4095)',0,40) # 显示数值 oled.text(str('%.2f'%(value/4095*3.3))+' V',0,55) # 计算电压值，获得的数据 0-4095 相当于 0-3V，（'%.2f'%）表示保留2位小数 判断光照强度，分3档显示。 if 0 &lt; value &lt;=1365: oled.text('Bright', 60, 55) if 1365 &lt; value &lt;= 2730: oled.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d049e33e547ea8d341af45526dae424/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ded77c8bbff6e037225200a09141cfcc/" rel="bookmark">
			ESP32初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DAC
from pyb import DAC,Switch from machine import Pin,I2C from ssd1306 import SSD1306_I2C i2c = I2C(sda=Pin("Y8"), scl=Pin("Y6")) oled = SSD1306_I2C(128, 64, i2c, addr=0x3c) sw =Switch() dac = DAC(1) freq=[1,200,1000,5000] buf = bytearray(2) buf[0]=0 buf[1]=255 key_node = 0 i = 0 def key(): global key_node key_node = 1 sw.callback(key) oled.fill(0) oled.text('DAC-Beep', 0, 15) oled.text('Pls Press USER', 0, 40) oled.show() while True: if key_node==1: i = i+1 if i == 4: i = 0 key_node = 0 dac.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ded77c8bbff6e037225200a09141cfcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe304ffb53733c9036fa8ed53e58f961/" rel="bookmark">
			STM32Cubmax key使用软件延时检查输入状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、key的硬件图 二、软件消抖原理 当按键按下会有些波动干扰，比如PE4被按下的时候，KEY0的电压就会被拉低，变为1，由于抖动，所以在有些时候电平会变为1，因此我们通过软件延时把开始时候的抖动过程给消除。
上代码
/* USER CODE BEGIN Header */ /** ****************************************************************************** * @file : main.c * @brief : Main program body ****************************************************************************** * @attention * * Copyright (c) 2024 STMicroelectronics. * All rights reserved. * * This software is licensed under terms that can be found in the LICENSE file * in the root directory of this software component. * If no LICENSE file comes with this software, it is provided AS-IS.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe304ffb53733c9036fa8ed53e58f961/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c95fe4148a5e32de97fb89317a7d185e/" rel="bookmark">
			esp32 oled初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 # 导入相关模块 from pyb import ExtInt from machine import I2C,Pin from ssd1306 import SSD1306_I2C # 初始化 OLED 模块 i2c = I2C(sda=Pin("Y8"), scl=Pin("Y6")) oled = SSD1306_I2C(128, 64, i2c, addr=0x3c) # OLED 初始信息显示 oled.fill(0) # 清屏背景黑色 oled.text("Human body test:", 0, 15) # 写入第1行内容 oled.show() # OLED 执行显示 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e31b2a64077333a50dc5df3fdfc57b2/" rel="bookmark">
			esp32oled使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 导入相关模块 from pyb import ExtInt from machine import I2C,Pin from ssd1306 import SSD1306_I2C # 初始化 OLED 模块 i2c = I2C(sda=Pin("Y8"), scl=Pin("Y6")) oled = SSD1306_I2C(128, 64, i2c, addr=0x3c) # OLED 初始信息显示 oled.fill(0) # 清屏背景黑色 oled.text("Human body test:", 0, 15) # 写入第1行内容 oled.show() # OLED 执行显示 def Display(): # Get People 闪烁5次效果！ for i in range(5): oled.fill(0) # 清屏背景黑色 oled.text("Human body test:", 0, 15) # 写入第1行内容 oled.text("Get People!!!", 0, 40) # 写入第2行内容 oled.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e31b2a64077333a50dc5df3fdfc57b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f833e28720bc2eb9ffa7050cb21ee012/" rel="bookmark">
			一、计算机视觉-快速搭建开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Anaconda 是什么？二、Anaconda 的特点三、Anaconda 和PIP区别四、 如何安装使用conda五、 conda命令五、 IDE的选择 前言 搭建环境Anaconda 是必不可少的，用Anaconda 我们可以很容易的部署计算机视觉开发环境（包括用到的包、和IDE等）
下面我们看下Anaconda 是什么，为什么要用Anaconda
一、Anaconda 是什么？ Anaconda 是一个流行的开源发行版和包管理器，主要用于数据科学、机器学习和科学计算的 Python 和 R 环境。它提供了一整套数据科学工具和库，包括数据处理、数据可视化、机器学习、深度学习等方面的库和工具。
二、Anaconda 的特点 包管理器: Anaconda 包含了一个名为 conda 的包管理器，可以用来安装、更新、卸载和管理包，以及创建和管理不同的环境。预装的科学计算库: Anaconda 默认安装了大量常用的科学计算库，如 NumPy、SciPy、Pandas、Matplotlib 等，这些库通常在数据科学和科学计算中使用频繁。跨平台: Anaconda 可以在 Windows、Linux 和 macOS 等多个操作系统上运行，并且提供了一致的用户体验。虚拟环境: 使用 Anaconda 可以轻松创建和管理多个独立的 Python 环境，每个环境可以有自己独立的包集合，这有助于避免包之间的冲突，并且使得不同项目的依赖关系更清晰。集成开发环境 (IDE): Anaconda 还包含了一些流行的 Python 集成开发环境，如 Jupyter Notebook、Spyder 等，这些工具对于数据科学和机器学习领域的工作非常有用。 总的来说，Anaconda 提供了一个便捷的数据科学平台，使得用户可以快速搭建数据科学环境并开始进行数据分析、机器学习和科学计算。
三、Anaconda 和PIP区别 主要区别有以下几个方面：
conda 能管理虚拟环境 而PIP不能conda 能解决包依赖的问题，而PIP不能PIP使用的官方包源含的包比conda多conda支持的语言有c、c++python、R等。pip只支持python 我们安装包时可以先用conda安装，conda安装不了在选择PIP安装，因为conda可以解决包依赖的问题，可以减少我们在安装过程中出现问题，所以可以首先考虑用conda安装。
四、 如何安装使用conda 官方下载安装包：https://www.anaconda.com/download/
安装好之后会在开始菜单中找到Anaconda Powershell Prompt (miniconda3) 并打开，这时可以在命令窗口管理环境，打开IDE 执行python程序等
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f833e28720bc2eb9ffa7050cb21ee012/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5ff22d6feba6785922b70df88a42d03/" rel="bookmark">
			ssh 连接远程主机原理解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSH（Secure Shell）连接到远程服务器的整个过程包括多个步骤，这里按顺序解释每一个步骤：
客户端初始化连接：
当你在客户端输入 SSH 命令（如 ssh user@hostname）后，SSH 客户端开始尝试连接到在命令中指定的 IP 地址或主机名上的 SSH 服务器，通常监听在 TCP 端口 22 上，除非指定了其他端口（如使用 -p 选项）。
远程主机响应：
远程主机的 SSH 服务器收到连接请求后，会响应该请求，并且向客户端发送它的公钥信息，公钥信息用于启动安全的连接。
主机身份验证：
客户端收到远程主机的公钥后，会检查该公钥是否已经存在于本地的 .ssh/known_hosts 文件中。如不存在，客户端会提醒用户，询问是否信任该公钥。如存在，则进行下一步。
公钥检查：
如果公钥已经存在于 known_hosts 文件中，客户端会检查收到的公钥是否和文件中记录的相匹配。如匹配，则认为是同一个远程主机，连接继续；如果不匹配，则如上面的错误信息所示，表示主机身份验证失败，连接停止。
用户身份验证：
一旦远程主机被认证，下一步是用户身份验证。客户端会请求用户输入密码，或者尝试使用存储在客户端的私钥进行公钥身份验证，或提供其他类型的用户凭证（如 ssh-agent 提供的，或使用其他更高级的认证方法，比如 Kerberos）。
建立加密通道：
一旦用户身份验证通过，客户端和服务器将协商一个加密的会话密钥用于整个会话通信加密，这通常通过 Diffie-Hellman 密钥交换算法完成。
成功连接：
通过所有验证过程后，客户端与服务器之间就建立了一个安全的加密通道，用户就能通过这个通道远程访问服务器了。
进行远程会话：
用户现在可以通过安全的 SSH 连接执行命令，传输文件（通过 SCP 或 SFTP），或者做其他态势的管理任务。连接可以保持开放，直到用户退出会话或会话因其他原因关闭。
整个过程强调了安全，因为 SSH 提供了加密的网络连接，保障数据在客户端和服务器之间传输的隐私和完整性。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/14/">«</a>
	<span class="pagination__item pagination__item--current">15/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/16/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>