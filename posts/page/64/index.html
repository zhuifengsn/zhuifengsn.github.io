<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60b0e3a2b2627c87cd69046f1938f35c/" rel="bookmark">
			idea怎么打开war包并运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 1.解压war包
2.用idea打开
3.配置jdk
4.添加框架支持和配置tomcat
前言 打开已有的war包案例进行学习可以让我们根据别人已有的经验进行快速学习，那我们该如何用idea打开war包呢？
提示：以下是本篇文章正文内容，下面案例可供参考
一、jar包和war包有什么区别 以我的理解来说，jar包是我们编写的所有java类源代码的打包，这样我们可以将其放在其他合适的框架里进行使用，而war包是一个webapp的打包，里面不仅有写好的java类源代码，还有网页文件和静态资源，我们只需简单配置就能使用编译器运行。
二、使用步骤 1.解压war包 war包与其他压缩文件不同，点击不能直接解压，我在自己的电脑上将文件的后缀名直接改成了.zip（当上是抱着试一试的心态，弄了一个副本，没想到还真的可以），要是你的电脑不能这样，你需要装一个解压软件来进行解压，或者电脑自带的也行，直接解压到压缩文件目录就行。
2.用idea打开 用idea打开比较简单，你只需要点击文件那一栏，然后根据自己解压后的war包存放的目录直接打开就行。
3.配置jdk 首先我们有下载并配置好的jdk，我的是jdk-11.0.12，安装配置详情参考jdk的安装与配置。安装好之后，点开文件栏选择项目结构点击项目栏，出现这个界面
点开无sdk那栏可以选择自己的jdk，如果没有的话就通过文件目录添加就行，下面一栏选择和自己的jdk版本相同的就行，如果不知道就选默认值就行。
4.添加框架支持和配置tomcat 首先要添加框架支持，因为这要在配置服务器的时候才能部署本地工件，我们右键单击最左边的项目名点击添加框架支持出现如下界面
选择web应用程序然后确定，如果war包xml文件有就不要勾选添加xml文件了。
接下来进行tomcat的配置（一般学习过程中都是用的tomcat服务器），点击右上角添加配置
， 点击加号添加tomcat本地服务器
选择安装好的tomcat版本，详情参考tomcat的安装与配置，然后点击部署
点击加号选择本地工件应用然后确定。
最后，把web-inf文件夹和需要的jsp和html页面拖到web里面就能运行了。
总结 完成以上步骤之后就可以在浏览器中运行相应的war包了，基本上是很简单的步骤但是方便第一次的使用，用多了就会熟悉操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8c2531ad82a86240e6d6d2c00899505/" rel="bookmark">
			怎么批量提取文件夹中所有的文件名称及文件路径？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要：将文件夹中所有文件名称或者路径提取到一个 Excel 文件中的的需求在日常办公过程中经常会碰到，我们可以自己手工的一个一个文件进行处理，也可以通过自己写批处理脚本进行处理，但这种门槛都比较高，需要有一定的编程基础。在很多时候，使用工具是解决我们问题的最好方法。今天就给大家介绍一下如何将文件夹下所有的文件名称或者文件路径一次性的导入到一个单独的 Excel 文件中。
在工作中我们经常会碰到需要提取某个文件夹中所有文件名称或者路径的需求！比如公司在对员工做一些调查的时候，每个员工需要上交一个 Word 登记文档，这些 Word 文档都是存储在磁盘文件中的。为了方便统计和查看，我们需要把这些信息导入到一个 Excel 文件或者 Txt 文本文件中。这时候如果是你会会怎么样做呢？人工的一个一个的处理还是写脚本批量处理？
效果预览 今天给大家介绍的是使用「我的ABC软件工具箱」批量提取文件夹中所有文件名称及路径的方法，我们先来看一下将文件夹中文件名称和路径导出到 Excel 或者 Txt 文本文件中的效果！
右侧的便是我们导出的文件名及路径的列表，我们能看到不仅有文件名称、文件路径，还能看到对应的扩展名、所在的根目录等各种信息，这样大家就可以根据自己的需要去使用对应的数据了！
工具准备 我们打开「我的ABC软件工具箱」，按下图所示选择「文件名称」-「生成文件夹路径清单」的功能。
选择文件夹 这里我们可以选择待处理的文件夹，需要导出那个文件夹下的文件名称或路径，就选择哪个文件夹，可以一次选择多个文件夹。
选项设置 选择好待处理文件后，就可以进入到选项设置的界面。
1、输出文件类型
我们可以选择将结果输出到一个 Excel 文件中，也可以选择输出到一个 Txt 文本文件中。
2、清单包含的数据内容
我们可以导出待处理文件夹下的所有文件，也可以选择导出待处理文件夹下的所有文件夹，也可以同时导出待处理文件夹下面所有的文件和文件夹。
处理完成 完成选项设置后，点击下一步，软件就开始进行导出文件夹下所有文件名称、文件路径的操作了。只需要几秒钟，就能得到这个文件夹路径清单的 Excel 文件了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c98177cbdbe17fcbcb6fa2f3d17463c/" rel="bookmark">
			java基本规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		----------------------------------------------- 定义最大(小)值： int i = Interger.MAX_VALUE; int i = Interger.MIN_VALUE; ----------------------------------------------- 数组array： 1、字符数组： 数组： int[] res =int[10]; char[] ch = new char[n];	# 新建长度为n的字符数组 ch.length； 2、字符串数组： String[] st = new String[3]; st[0] = "at"; st[1] = "the"; st[2] = "end"; String[] StringArray = s.split("\\s+"); List&lt;String&gt; wordList = Arrays.asList(StringArray);	# 将字符串数组 → 可变字符串数组 3、可变数组arraylist: ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); ArrayList&lt;Student&gt; student = new ArrayList&lt;&gt;(); List&lt;泛型&gt; List = Arrays.asList(数组名称);	# 将 数组 → 可变数组 ArrayList集合: // 以数组为底层数据结构的集合 ArrayList&lt;Integer&gt; arraylist = new ArrayList&lt;&gt;(); arraylist.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c98177cbdbe17fcbcb6fa2f3d17463c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/174189cc765d83663c4048f742743439/" rel="bookmark">
			Cpp入门小知识一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信大家刚接触c++的时候都会见到这2行代码。
#include&lt;iostream&gt; using namespace std; 在大家的认识中可能是不管三七二十一写上这2行代码就对了，管它是什么呢。那这2行代码是什么意思呢，有什么用呢？ #include&lt;iostream&gt;可以理解为跟c语言中的#include&lt;stdio.h&gt;类似、等价的。是来告诉我们控制台来进行输入输出的，它是IO流。那using namespace std是干嘛的呢？
首先就要先了解一下其他东西。
在c语言中存在一个命名冲突的问题，命名冲突又是什么呢？在c语言中定义一个变量的名称，第一要符合变量名规范，第二不能跟关键字同名，但没有规定不能跟库函数的名字一样。rang在c语言中是用来生成随机数的。用它作为变量名会如何呢？
编译是通过了，要是包上了该函数的头文件呢？就不通过了，出现了重定义。
假如张三跟李四合作写一个项目，张三自己写了个头文件定义了个函数，李四在不知情的情况下定义了个变量跟张三的函数同样的名字，这不就起了命名冲突了吗。在c语言中是没有办法解决这个问题的，c++中引入了namespace用来解决这个问题的。
namespace是什么呢，是c++中的一个关键字，namespace叫命名空间，需要使用到这个关键字时候后面跟命名空间的名字，这个名字可以随便取，然后接一对{}即可，{}中即为命名
空间的成员。
在命名空间里定义rand这时候就编译通过了，但其结果怎么是一串很长的数字呢，其实打印的是它的函数指针，就是它的函数地址，只是以%d的格式打印，没有用%p打印。
如果我们定义一个变量跟函数，名字在同样的情况下是会报错。
同理我们命名空间里定义函数fun就不会报错。
最后如果我们定义了一个局部变量跟全局变量且是同名的情况下，会打印出0，因为局部变量优先于全局变量。
那咱就偏不打印局部变量的，而要让它打印全局变量的呢，这个好办，c++中有一个叫域作用限定符 :: ，只要在a的前面加上::就可以访问全局域。::a : : 前面是空白什么也没有，默认访问全局域里的a。
回到命名空间，如果要访问命名空间里的成员时，是不是也可以用到域作用限定符，答案是可以的。test::rand 意思是访问test命名空间域里面的成员rand。如果也想访问该命名空间里的其他成员也是一样的操作。
看到这里可能大家对命名空间到底是什么都还很懵逼，其实可以这样理解：namespace命名空间相当于是一个隔离空间,把变量、函数、类型关在这个隔离间里，与外界没有联系。我们在电视中可能会看到过这种情节，女方的老公因为做了犯法的事被抓去坐牢子，女方想要探望她老公的话会被带进去一个房间里面，里面有一个玻璃隔层，男方在那一边，女方在另一边，双方隔着一个玻璃层靠着电话在沟通。这种得靠着电话才能说话、互相听到彼此的声音的操作，就相当于可以用域作用限定符来访问命名空间里的成员一样。
namespace命名空间总结： 1、空间成员是可以定义变量、函数，类型的。
2、命名空间是可以嵌套的
3、如有存在多个相同名称的命名空间，编译器最后合并成一个命名空间里。
4、不能在函数内定义命名空间
要是一直得用域作用限定符才能使用命名空间里的东西话，那岂不是很繁琐很占用时间，有没有办法解决？
有的。可以用using namespace test; 这句代码的意思是把关在命名空间里的成员全部释放出来。这样就可以直接用这些成员了。
但要注意的是释放了命名空间的成员会引起冲突反而失去了命名空间的作用了。
换种方法：我们可以把需要经常使用到的成员单独释放出来，比如命名空间里的Add函数是我们要频繁使用的，可以单独释放出来。
using test::Add; 意思是单独释放命名空间里的Add成员。
现在知道C++中的using namespace std;是什么意思了吗，就是释放std库里面的成员。std是C++中标准库的命名空间。比如我们要用到的输入输出cin、cout就是定义在#include&lt;iostream&gt;这个头文件里面，如果没有用using namespace std来释放std命名空间的话，去使用则会出现未声明。
释放std全部成员后虽然可以直接使用了。但会存在风险。
那要是不全部释放std呢也是有办法使用的。可以用域作用限定符。
上面讲过释放命名空间里的全部成员的话会引起冲突，如果我们释放std里的全部成员，定义了一个叫cout的变量使用它就会报错。可以单独释放也可以用域作用限定符，命名空间的优势就体现出来了。
在我们日常练习中是可以全部释放的但会存在命名冲突的风险，所以在项目里我们去指定释放常用的。
输入输出 &gt;&gt; 流提取运算符
&lt;&lt; 流插入运算符
cin 标准输入流
cout 标准输出流
cin是用来输入的，cout是用来输出的。在c语言中的scanf，printf使用的时候需要控制它的格式会很繁琐，而cin、cout不需要控制格式了，自动识别类型，使用更便捷了。
#include&lt;iostream&gt; using namespace std; int main() { int a = 0; int b = 0; cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/174189cc765d83663c4048f742743439/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b15bfb48cdcdac217d2e24e4265a671/" rel="bookmark">
			SYN 包在什么场景下会被丢弃？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是小林。
SYN 报文什么时候情况下会被丢弃？
这个问题跟工作上也是有关系的，因为我就在工作中碰到这么奇怪的时候，客户端向服务端发起了连接，但是连接并没有建立起来，通过抓包分析发现，服务端是收到 SYN 报文了，但是并没有回复 SYN+ACK（TCP 第二次握手），说明 SYN 报文被服务端忽略了，然后客户端就一直在超时重传 SYN 报文，直到达到最大的重传次数。
接下来，我就给出我遇到过 SYN 报文被丢弃的两种场景：
开启 tcp_tw_recycle 参数，并且在 NAT 环境下，造成 SYN 报文被丢弃
TCP 两个队列满了（半连接队列和全连接队列），造成 SYN 报文被丢弃
坑爹的 tcp_tw_recycle TCP 四次挥手过程中，主动断开连接方会有一个 TIME_WAIT 的状态，这个状态会持续 2 MSL 后才会转变为 CLOSED 状态。
在 Linux 操作系统下，TIME_WAIT 状态的持续时间是 60 秒，这意味着这 60 秒内，客户端一直会占用着这个端口。要知道，端口资源也是有限的，一般可以开启的端口为 32768~61000 ，也可以通过如下参数设置指定范围：
net.ipv4.ip_local_port_range 那么，如果如果主动断开连接方的 TIME_WAIT 状态过多，占满了所有端口资源，则会导致无法创建新连接。
但是 TIME_WAIT 状态也不是摆设作用，它的作用有两个：
防止具有相同四元组的旧数据包被收到，也就是防止历史连接中的数据，被后面的连接接受，否则就会导致后面的连接收到一个无效的数据，保证「被动关闭连接」的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭; 不过，Linux 操作系统提供了两个可以系统参数来快速回收处于 TIME_WAIT 状态的连接，这两个参数都是默认关闭的：
net.ipv4.tcp_tw_reuse，如果开启该选项的话，客户端（连接发起方） 在调用 connect() 函数时，内核会随机找一个 time_wait 状态超过 1 秒的连接给新的连接复用，所以该选项只适用于连接发起方。net.ipv4.tcp_tw_recycle，如果开启该选项的话，允许处于 TIME_WAIT 状态的连接被快速回收； 要使得这两个选项生效，有一个前提条件，就是要打开 TCP 时间戳，即 net.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b15bfb48cdcdac217d2e24e4265a671/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f2884f93beb0fe749c959809df6da15/" rel="bookmark">
			详解 c语言中的操作符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、算术操作符号二、移位操作符1. &lt;&lt; 左移操作符2. &gt;&gt; 右移操作符 三、位操作符号补充 原码 补码 反码 的转换1. 按位与 ( &amp; )2.按位或 ( | )3.按位异或 ( ^ )4. 小练习1.不能创造 临时变量，实现两数交换2.编写代码实现：求一个整数存储在内存中的二进制中1的个数 四、赋值操作符1. =2.复合赋值符 五、单目操作符1. 逻辑反操作 ( ! )2. 正值 ( + ) 与 负值 （ - ）3. 取地址操作符 （ &amp; ）4. sizeof5. （ ~ ） 按位取反操作符6. ++ 与 --7. （ * ） 间接访问操作符(解引用操作符)8.（） 强制类型转换 六、关系运算符七、逻辑操作符 （&amp;&amp;） ( || )1. 逻辑与 &amp;&amp; 左边为假，右边就不计算2.逻辑或 || 左边为真，右边就不计算3. 有关逻辑与逻辑或的练习 八、三目操作符 与 逗号表达式1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f2884f93beb0fe749c959809df6da15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd867a9bc4f0aedbc9d4472701ec290a/" rel="bookmark">
			新闻个性化推荐综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MIND: A Large-scale Dataset for News Recommendation ACL 2020 0. 摘要 新闻推荐是实现个性化新闻服务的一项重要技术。与已经被广泛研究的产品推荐和电影推荐相比，新闻推荐的研究非常有限，主要是因为缺乏高质量的基准数据集。本文提出了一个名为MIND的新闻推荐大型数据集。MIND由微软新闻的用户点击日志构建而成，包含100万用户和16万多篇英文新闻文章，每篇文章都有丰富的标题、摘要、正文等文本内容。通过对几种最先进的新闻推荐方法的比较研究，证明了MIND为新闻推荐提供了一个良好的实验平台，这些方法最初是在不同的专有数据集上开发的。研究结果表明，新闻推荐的性能在很大程度上依赖于新闻内容理解和用户兴趣建模的质量。有效的文本表示方法和预先训练好的语言模型等自然语言处理技术可以有效地提高新闻推荐的性能。MIND数据集可以在MIND网站下载。
1. 引言 Google news、Microsoft news等在线新闻服务已经成为广大用户获取新闻信息的重要平台。每天都有大量的新闻生成并发布在网上，使得用户很难快速找到感兴趣的新闻。个性化新闻推荐可以帮助用户缓解信息过载，提高新闻阅读体验。
在传统的推荐系统中，通过协同过滤等方法来学习用户和项目表示。然而，新闻推荐面临着一些特殊的挑战。首先，新闻网站上的新闻文章更新非常快。新的新闻文章不断发布，现有的新闻文章会在短时间内过期。因此，新闻推荐中的冷启动问题非常严重。其次，新闻文章包含标题、正文等丰富的文本信息。简单地用id表示他们是不合适的，从他们的文本中理解他们的内容是很重要的。第三，对用户在新闻平台上发布的新闻文章没有明确的评分。因此在新闻推荐中，用户对新闻的兴趣通常是从用户的点击行为中隐含地推断出来的。
大规模和高质量的数据集可以显著促进某一领域的研究，例如ImageNet用于图像分类(Deng et al.， 2009)和机器阅读理解SQuAD(Rajpurkar et al.， 2016)，Amazon dataset用于产品推荐，MovieLens dataset用于电影推荐。然而，现有的关于新闻推荐的研究较少，很多都是在专有数据集上进行的(Okura et al.， 2017; Wang et al.， 2018;吴等，2019a)。
本文提出一个大规模的微软新闻数据集(MIND)用于新闻推荐研究，该数据集是从Microsoft News的用户行为日志中收集，包含了100万用户以及他们点击超过16万篇英语新闻的行为。在不同的专有数据集上实现了许多最新的新闻推荐方法，并比较它们在思维数据集上的表现，为新闻推荐研究提供基准。实验结果表明，利用NLP技术对新闻文章进行深入理解对新闻推荐具有重要意义。有效的文本表示方法和预先训练好的语言模型都有助于提高新闻推荐的性能。此外，适当地对用户兴趣进行建模也很有用。希望MIND可以作为新闻推荐的基准数据集，促进这一领域的研究。
2. 相关工作 2.1 新闻推荐 新闻推荐旨在从大量候选新闻中寻找用户感兴趣的新闻文章(Das et al.，2007)。新闻推荐中存在两个重要的问题，即如何表示文本内容丰富的新闻文章，以及如何从用户之前的行为中建模用户对新闻的兴趣(Okura et al.， 2017)。传统的新闻推荐方法通常依靠特征工程来代表新闻文章和用户兴趣。例如，Li等人(2010)使用url和类别来表示新闻文章，使用人口统计数据、地理信息和从他们在雅虎上的消费记录推断出的行为类别来表示用户。
近年来，一些基于深度学习的新闻推荐方法被提出，以端到端方式学习新闻文章的表示和用户兴趣(Okura et al., 2017; Wu et al., 2019a; An et al., 2019年)。例如，Okura等人(2017)使用去噪自动编码器模型表示来自新闻内容的新闻文章，使用GRU模型表示来自历史点击新闻文章的用户兴趣。他们在日本雅虎平台的实验显示，通过深度学习模型学习到的新闻和用户表示很有希望用于新闻推荐。Wang et al.(2018)提出通过结合从知识图谱中推导出的词向量和实体向量，利用CNN网络从新闻标题中学习知识感知的新闻表示。Wu et al. (2019a)提出了一种专注的多视角学习框架来表示标题、正文、类别等不同文本的新闻文章。他们使用了一个注意力模型，通过选择信息丰富的文章，从用户点击的新闻文章中推断出用户的兴趣。这些工作通常开发和验证的专有数据集，这是不可公开的，使它为其他研究人员验证这些方法和发展自己的方法困难。
新闻推荐与NLP有着丰富的内在关联。首先，新闻是一种常见的文本形式，文本建模技术CNN和Transformer可以很自然地被用来表示新闻文章(Wu et al., 2019a; Ge et al.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd867a9bc4f0aedbc9d4472701ec290a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dcd98323496289ee650c411813d32a0/" rel="bookmark">
			自然语言处理—RNN循环神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. RNN基本介绍 (参见吴恩达深度学习—RNN篇https://www.bilibili.com/video/BV16r4y1Y7jv?p=152&amp;spm_id_from=pageDriver)
1.1 基本介绍 RNN神经网络可以用来处理时间序列类型的数据，一段文字也可以看成一个时间序列。比如，
The cat ate many food that was delicious was full
其中，上标代表第个样本，代表时间，下面将不再样本的标记进行分析。一般的神经网络处理时间序列时存在两个问题：i) 输入维度不确定，且如果是one-hot编码，则向量维度高；ii) 一般神经网络不能捕捉序列之间的信息。因此，有循环神经网络来处理时间序列数据。
图1. RNN神经网络模型结果
前向传播
在RNN中，每一时刻所使用的参数、、以及、 、都是一致的。模型的forward-propagation如下：
（1）
其中，。
反向传播
每一个时刻，都有损失函数：
总的损失为。其back-propagation如下图所示，
图2. RNN反向传播示意图
上面展示的是的情形，即输入和输出一样多，根据和，有以下多种网络形式。
图3. 多种类型的RNN模型
1.2 解决RNN的梯度消失 和深度神经网络一样，RNN同样存在梯度消失和梯度爆炸的问题（复合函数求导，若每一步梯度&gt;1则容易产生梯度爆炸，梯度&lt;1则容易产生梯度消失，参见https://zhuanlan.zhihu.com/p/68579467），导致更新网络参数无效或者震荡太大。梯度爆炸容易观察，但是梯度消失不易观察，针对RNN，专门有GRU和LSML两种模型解决。
GRU简单理解为，每个时刻引入一个记忆值,记忆值和激活值相等。根据门控（gate）决定是否用新得到的更新当前的c^{t},
图4. GRU示意图
更新公式如下：
（2.1）
（2.2）
（2.3）
（2.4）
（2.5）
与图4中只有一个门控不同的是，在计算的时候有另外一个相关性的门控。
LSMT和GRU不同的是，和并不相等，引入了其他的门控和,其中取代了式（2.4）中的，作为单独的遗忘门控；用以更新激活值，如下：
(3.1)
(3.2)
(3.3)
(3.4)
(3.5)
(3.6)
2. 实例 2.1 pytorch中语法 Torch.nn.RNN为内置的RNN网络。序列的激活值用表示，计算公式如下，
初始化一个RNN网络语法：
rnn=torch.nn.RNN(input_size, hidden_size, num_layers,nonlinearity, bias,batch_first,dropout, bidirectional) 参数
其中，一般用到的参数为input_size, hidden_size, num_layers,nonlinearity, bias,batch_first。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dcd98323496289ee650c411813d32a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af4855acd8d3f387423bdfb75f0f94bf/" rel="bookmark">
			数据结构——栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		栈的概念 栈：是一个种特殊的线性表，只允许在固定的一端进行插入与删除元素的操作。在进行数据插入一端称为栈顶，进行删除操作的另一端成称栈底。栈中不含任何数据元素的时候称为空栈。栈中的元素遵守后进先出的原则。也叫先进后出。
举个例子：栈在我们的生活中的应用是经常见到的。我们大家在小时候应该都会玩过玩具枪，玩具枪里面的弹夹大家都不陌生吧，一颗一颗的子弹压入弹夹中，最后压入的子弹是最先被发射出来的。
在软件应用中，也是非常普遍的。比如我们在用浏览器浏览东西时，不管什么浏览器都会有一个“返回键”，点击后会按照你访问的顺序逆序后退。有时候我们在浏览一些东西的时候会弹出一个弹窗，一不小心点了进去，一看“性感女优，在线发牌”，顿时慌了起来千万不能被看到，粉身碎骨浑不怕，要留清白在人间。赶忙狂点返回键，这才留住了“清白”。
栈是一个特殊的线性表，只能在栈顶进行数据插入以及删除，特殊之处在于它限制了这个线性表的插入和删除位置，它始终只能在栈顶进行。
栈的插入操作叫做进栈，也称压栈、入栈。如同子弹一般一颗一颗压入弹夹中。
栈的删除操作叫做出栈，也称弹栈。如同弹出弹夹中的子弹。 进栈出栈变化形式 想一下，最先进栈的元素是不是就只能最后出栈呢？
是不一定的。要看是什么情况。栈对线性表的插入和删除的位置进行了限制，但没有对出栈入栈的时间进行限制。所以说并不是得所有元素都入栈了才可以出栈，可以进一个出一个也可以进多个再依次都出，但切记不能越级出。
这里有道题大家可以拿来练练手。
若进栈序列为 1,2,3,4 ，进栈过程中可以出栈，则下列不可能的一个出栈序列是（）
A 1,4,3,2
B 2,3,4,1
C 3,1,4,2
D 3,4,2,1
A选项：1入栈就出栈，接着2、3、4依次入栈，4出，3出，2出，出栈次序是：1,4,3,2。
B选项：1、2入栈，2出栈。3入栈再出栈，4入栈再出栈，最后栈中只剩下1出栈，出栈次序是：2,3,4,1。
D选项：1、2、3入栈，3出栈，4入栈再出栈，最后栈中剩下1、2。2出，1出， 出栈次序是：3,4,2,1。
而C选项：1、2、3入栈，3出了但栈中还有1、2。2是在栈顶，应先出的是2，1是在栈底，如果先出1的话就越级了。
因此这道题应该是选 C。通过这道题我们要知道栈中元素的入栈出栈操作只能在栈顶位置执行。
栈的各个接口实现： 栈的实现一般可以使用数组或者链表来实现的，相对而言使用数组的结构来实现的话会更优一点。因为数组在尾上插入删除数据的代价比较小。如果使用链表的话，首先就得遍历找到尾再进行插入或删除的操作。数组是支持下标随机访问的。
typedef int STDataType; //根据要存入的数据类型而修改 typedef struct Stack { STDataType* data;	int top;	//栈顶	int capacity;	//容量 }Stack; 栈的初始化 //初始化 void StackInit(Stack*ps) { assert(ps); ps-&gt;data = (STDataType*)malloc(sizeof(STDataType)* 3);	ps-&gt;capacity = 3; ps-&gt;top = 0; } 入栈 //入栈 void StackPush(Stack*ps,STDataType x) { assert(ps); if (ps-&gt;capacity == ps-&gt;top)	//相等表示容量不足需扩容 { STDataType* newp = (STDataType*)realloc(ps-&gt;data, sizeof(STDataType)*(ps-&gt;capacity + 3)); if (newp == NULL) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af4855acd8d3f387423bdfb75f0f94bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62bcbb29a9f6685df2b0e3d1af53fff5/" rel="bookmark">
			nfs-kernel-server服务启动失败解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有一台nfs服务器连接服务失败。
该服务器系统是ubuntu20.04.3 LTS
登陆服务器，尝试重启服务，失败。
检查nfs服务。输入命令：
systemctl status nfs-kernel-server
结果如下：
如图所示，提示地址已经被使用了。
我们知道nfs服务默认使用端口号2049，输入如下命令：
ss -lntp |grep 2049 或netstat -lntp |grep 2049
发现，2049被一个名为ganesha.nfsd的服务使用了。
nfs-ganesha也是一个nfs服务发行版本。不过我记得每安装过，不知道什么时候谁安装了。
kill掉它。再启动服务，正常了。
事情还没结束，看样子这个ganesha.nfsd会自动启动，还需要处理一下。
输入如下命令：
systemctl |grep ganesha
输出如下结果：
禁止该服务开机启动，然后重启服务器测试一下，一切正常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70e2fe2685d121c6537d7a58dee5af8e/" rel="bookmark">
			makefile和make
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、make的安装 输入命令：sudo apt install make
需要密码，根据提示输入密码即可。
二、makefile和make命令的介绍 makefile文件：Linux上的项目工程管理工具，可以实现自动化编译。
主要用于项目工程里源文件过多，makefile文件可以根据类型，功能，模块，将这些源文件分好到不同目录里,makefile文件里面就可以定义一系列的规则来指定哪一些文件先需要进行编译,文件需要重新编译，甚至更复杂的操作，makefile文件就像一个shell脚本一样，可以一系列命令。|
make：是一个命令，可以解释makefile文件中的指令
eg:现有main.c，add.c，max.c三个文件需要编译
文件内容如下：
若需要编译这三个文件需要：gcc -o main main.c add.c max.c
若只修改了其中一个文件，要想编译，就需将这三个文件都重新编译一遍，文件若很多，就很麻烦。
这时我们可以使用makefile文件，提供编写效率，通过make命令执行makefile文件，这时只会将修改过的文件或依赖修改过的文件的文件重新编译，不受影响的文件不会重新编译。
makefile文件使用如下： makefile文件内容如下：
直接执行make命令自动执行makefile文件中的命令生成对应的可执行文件
若我们只修改main.c 中的文件
使用make命令执行
若觉得文件编译过程中生成的.o文件没有用处，还可以通过编写makefile文件删除
执行命令：make clean
makefile文件最好不要自己改名
三、gdb调试 1） Debug版本和Release版本区别 Debug版本叫做开发版本或者可调试版本，生成的可执行文件里面包含调试需要用到的信息。我们作为开发人员，最常用的就是debug版本产生的可执行文件。
Release版本是发行版本，面向用户的，里面没有调试信息，所以体积会相较于debug版本非常的小.
注意:gcc默认生成的是Release版本。
2)gcc生成Debug版本的可执行文件 Debug版本的生成：因为调试信息是在编译阶段加入到可重定向的目标文件（.o）中的，所以必须在编译阶段就让它添加调试信息。
命令如下：
1、首先gcc -c main.c -g(生成的中间文件main.o这时包含调试信息)
然后再通过gcc -o main main.o(生成了Debug版本的可执行文件)
2、一步生成 gcc -o main main.c -g
-g只能加在编译时或者一步生成时
3）通过gdb进入调试 首先需要将源文件编译，链接生成debug版本的可执行文件，然后通过“gdb debug版本的可执行文件名”，就可以进入到gdb调试模式。
示例：
一个有问题的main.c文件
编译运行时，发现程序存在bug
通过gdb调试，寻找问题(先生成debug版本的可执行文件，再进入gdb模式去查看问题)
gdb命令： l //显示当前文件的源代码(回车显示后面没显示出来的) list filename：num //显示filename文件中第num行附近的源代码 b 行号 // 给指定行下断点 r （run） //启动程序q //退出调试 p buff//临时打印数组所有元素的值p val //临时打印变量val的值p &amp; val //临时 打印变量val的地址p a+b // 临时打印表达式的值p *parr@num //通过指向数组的指针打印数组的元素值n （next）//单步执行，逐过程执 display buff//自动显示监视对象，操作格式和p一致info break //显示所有断点信息info display//自动显示所有监视对象信息undisplay 编号//删除对应的自动显示监视对象delete 断点编号//删除编号断点c （continue）//继续执行，直到执行到下一个断点 s //进去到将要被调用的函数中（逐语句）finish //跳出函数ptype val // 显示变量val的数据类型 前面通过调试，我们发现程序问题在比较这一块，比较的时候将回车\n也比较了，所以导致的bug
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd25384d39edd0d0dca0eb43322b7e7c/" rel="bookmark">
			机器学习（一）协同过滤推荐算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、算法简介
（1）推荐算法常见使用场景：电商产品推荐。基于产品的算法推荐，是分析用户历史行为数据，选择用户的浏览量、点赞数、评论数等数据高的产品，去推荐相似产品给用户。
（2）推荐算法作用：帮助用户发现他们感兴趣的产品。（1）节省用户的搜索时间，提高用户体验，减少流失。（2）延长用户的网站使用时间，提高用户忠诚度。
2、算法原理
（1）计算产品之间的相似度，生成相似度矩阵：
计算产品相似度可用3种方法：夹角余弦、杰卡德（Jaccard)相似系数、相关系数。
注：用户行为为二元选择（0/1）时，建议采用杰卡德相似系数。
相似度矩阵：
（2)基于产品相似度和用户已浏览产品a的数据，根据公式P=SIM*R,计算用户对未浏览产品b的感兴趣程度。
P-用户对b产品的感兴趣程度
SIM-a与b产品之间的相似度
R-用户对a产品感兴趣与否（1/0）
（3）基于产品相似度矩阵，推荐算法会给用户推荐与其数据最高产品最相似的K个产品。也可以基于产品兴趣度，给用户推荐其兴趣度最高的K个产品。
3、算法实现：
基于Python的Numpy库
import numpy as np #计算杰卡德相似系数的函数 #a:喜欢a产品的用户数 #b：喜欢b产品的用户数 def Jaccard(a,b): return 1.0*(a*b).sum()/(a+b-a*b).sum() class Remommendor(): sim =None #相似度矩阵 #计算相似度矩阵的函数 def similarity(self,x,jaccard): y = np.ones((len(x),len(x))) for i in range(len(x)): for j in range(len(x)): y[i,j] = jaccard(x[i],y[j]) return y #训练函数 def fit(self,x,jaccard = Jaccard): self.sim = self.similarity(x.jaccard) #推荐函数 def recommend(self,a): return np.dot(self.sim,a)*(1-a) 4、模型评估：
对于用户可给产品打分的网站，使用预测准确度的评估指标。
对于用户只能选择“喜欢与否\浏览与否”的网站，要用分类准确度的评估指标。
这里重点解释基于分类准确度数据构建的模型的3个评估指标：
(1)准确率precesion：用户对被推荐产品感兴趣的概率；
准确率=用户被推荐产品中喜欢的数目/用户被推荐产品总数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd25384d39edd0d0dca0eb43322b7e7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ebe4bfa73b98e51167869788fcc293f/" rel="bookmark">
			学习日记4.22-4.26
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022.4.22 1、链表刷题： 面试题 02.07. 链表相交142. 环形链表 II（还没刷完） 2、哈希表刷题： 242. 有效的字母异位词 数组349. 两个数组的交集 HashSet202. 快乐数 HashSet1. 两数之和 HashMap454. 四数相加 II HashMap
1和454都是用目标数与某数相减的值代入HashMap中。 理论知识：哈希表理论基础 总结： 一般来说哈希表都是用来快速判断一个元素是否出现集合里。对于哈希表，要知道哈希函数和哈希碰撞在哈希表中的作用.
哈希函数是把传入的key映射到符号表的索引上。
哈希碰撞处理有多个key映射到相同索引上时的情景，处理碰撞的普遍方式是拉链法和线性探测法。三种哈希结构： 数组HashSetHashMap 什么时候使用数组做哈希表？ 数组就是简单的哈希表，但是数组的大小是受限的！题目包含小写字母，那么使用数组来做哈希最合适不过。什么时候使用HashSet做哈希表？ 如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。那就考虑HashSet。什么时候使用HashMap做哈希表？ 同时存放两个元素，且两个元素有对应关系。 3、二叉树刷题： 二叉树的递归遍历三要素：
1、确定递归函数的参数和返回值
2、确定终止条件
3、确定单层递归的逻辑
144. 二叉树的前序遍历94. 二叉树的中序遍历145. 二叉树的后序遍历 理论知识： 二叉树基础篇 ： 二叉树（没有值） 满二叉树完全二叉树 二叉搜索树（有序树） 平衡二叉搜索树（它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。） 二叉树的存储方式（一般用链式存储） 链式存储顺序存储 二叉树的遍历方式 深度优先遍历（先往深走，遇到叶子节点再往回走） 前序遍历（递归法，迭代法）中序遍历（递归法，迭代法）后序遍历（递归法，迭代法）
广度优先遍历 （一层一层的去遍历） 层次遍历（迭代法） 节点定义：（TreeNode） public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ebe4bfa73b98e51167869788fcc293f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b7e4e0278e02814f0d985edf1a1a44c/" rel="bookmark">
			操作链表时加入头结点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		头结点作为哨兵有两点作用: （1）由于链表开始结点的位置被存放在头结点的指针域中，所以在链表的第一个位置上的操作就和在表的其它位置上操作一致，无须进行特殊处理;
（2）无论链表是否为空，其头指针是指向头结点的非空指针（空表中头结点的指针域为空），因此空表和非空表的处理也就统一了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5a6cb750b5d55df7525942e5a8aa46d/" rel="bookmark">
			ssrf总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSRF总结 简介 服务端请求伪造（Server Side Request Forgery, SSRF）指的是攻击者在未能取得服务器所有权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网。SSRF攻击通常针对外部网络无法直接访问的内部系统。SSRF可以对外网、服务器所在内网、本地进行端口扫描，攻击运行在内网或本地的应用，或者利用File协议读取本地文件。
原理 SSRF漏洞形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。例如,黑客操作服务端从指定URL地址获取网页文本内容,加载指定地址的图片等,利用的是服务端的请求伪造,SSRF利用存在缺陷的WEB应用作为代理攻击远程和本地的服务器。
危害 对外网、服务器所在内网、服务器本地进行端口扫描，获取一些服务的banner信息等。对内网Web应用进行指纹识别，识别企业内部的资产信息。攻击运行在内网或服务器本地的其他应用程序，如redis、mysql等。使用特定协议攻击应用（gopher、dict、file、FTP/SFTP等）进行跳板攻击等。 容易出现漏洞的地方 分享 通过url 地址分享文章，例如如下地址：
http://share.xxx.com/index.php?url=http://127.0.0.1 通过url参数的获取来实现点击链接的时候跳到指定的分享文章。如果在此功能中没有对目标地址的范围做过滤与限制则就存在着SSRF漏洞。
图片加载与下载 通过URL地址加载或下载图片
http://image.xxx.com/image.php?image=http://127.0.0.1 图片加载存在于很多的编辑器中，编辑器上传图片处，有的是加载远程图片到服务器内。还有一些采用了加载远程图片的形式，本地文章加载了设定好的远程图片服务器上的图片地址，如果没对加载的参数做限制可能造成SSRF。
图片、文章收藏功能 http://title.xxx.com/title?title=http://title.xxx.com/as52ps63de 例如title参数是文章的标题地址，代表了一个文章的地址链接，请求后返回文章是否保存，收藏的返回信息。如果保存，收藏功能采用了此种形式保存文章，则在没有限制参数的形式下可能存在SSRF。
利用参数中的关键字来查找 sharewapurllinksrcsourcetargetu3gdisplaysourceURlimageURLdomain 产生漏洞的函数 下面是几个可能会存在SSRF的服务器使用的函数：
file_get_contents() 这个函数的作用是将整个文件读入一个字符串。
example:
&lt;?php $url = $_GET['url']; $homepage = file_get_contents($url); echo $homepage; ?&gt; 上述测试代码中，file_get_contents() 函数将整个文件或一个url所指向的文件读入一个字符串中，并展示给用户。我们构造类似 ssrf.php?url=../../../../../etc/passwd 的paylaod即可读取服务器本地的任意文件。
fsockopen() fsockopen($hostname,$port,$errno,$errstr,$timeout); 用于打开一个网络连接或者一个Unix 套接字连接，初始化一个套接字连接到指定主机（hostname），实现对用户指定url数据的获取。该函数会使用socket跟服务器建立tcp连接，进行传输原始数据。fsockopen()将返回一个文件句柄，之后可以被其他文件类函数调用（例如：fgets()，fgetss()，fwrite()，fclose()还有feof()）。如果调用失败，将返回false。
example：
&lt;?php $host=$_GET['url']; $fp = fsockopen($host, 80, $errno, $errstr, 30); if (!$fp) { echo "$errstr ($errno)&lt;br /&gt;\n"; } else { $out = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5a6cb750b5d55df7525942e5a8aa46d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dbe851ac3cdb350e7850b2d8b4bcdba/" rel="bookmark">
			Java的基本程序设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言: 阅读完本章,你将学习到Java的基本类型、变量与常量、运算符及其进阶部分。
注:关于进阶部分将会标注 " * " , 初学者可以跳过。
目录
一, 变量与常量
1.1 声明变量
1.2 变量的命名规则
1.3 变量初始化
1.4 常量
二, Java基本数据类型
2.1 基本数据类型（四类八种）
2.2 强制类型转化
2.3 char类型的特殊字符
2.4 浮点型的精度缺陷*
2.5 包装类*
2.6 十六进制与二进制表示*
2.7 大数类*
三, 运算符
3.1 算术运算符
3.2 关系运算符
3.3 逻辑运算符
3.4 自增与自减
3.5 三目运算符*
3.6 运算符的优先级
3.7 位运算*
首先,我们先来看一段简单的Java代码:
public class Demo { //Demo为类名 public static void main(String[] args) { //Java主函数,固定写法 System.out.println("Holle Java!"); //输出语句,输出结果为:Holle Java! } //"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dbe851ac3cdb350e7850b2d8b4bcdba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4cb769ed4f8ba89c7e941d58d2d3184/" rel="bookmark">
			数据结构c二单链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		理解临摹代码
1.设置单链表
2.初始化
3.打印单链表
4.单链表取值
5.插入
6.删除
7.测试上述操作
8总函数
9测试结果
理解图示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d4e99589d4fd71163591e0963f38f58/" rel="bookmark">
			OpenCV之Mat的详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在opencv中，Mat作为图像的存储容器，是非常基础也是非常重要的知识，本文主要介绍Mat相关的操作。
1 图像复制 再开始将拷贝之前，先给大家分享一下浅拷贝和深拷贝
浅拷贝：拷贝对象和被拷贝对象都指向同一个内存空间，修改任何一个对象的数据都会影响另外一个；
举个例子：小明和小红在沙漠中共用一个水瓶喝水，任何一个人喝了水，另外一个人都会剩下更少的水。
深拷贝：拷贝对象和被拷贝对象指向不同的内容空间，修改数据时互不影响。
举个例子：小明和小红各有一个水瓶，各自喝各自的水对对方不影响。
深拷贝和浅拷贝都各有优缺点：
优点缺点浅拷贝拷贝效率高，空间利用率高，无需重新开辟空间不适用于拷贝和被拷贝对象同时修改的情况深拷贝任何一方的修改都不影响另一个拷贝效率低，占用空间较多，影响性能 1.1 拷贝构造函数进行拷贝 这种拷贝方式属于浅拷贝，下面代码中的img和img2都指向相同的内存空间，修改img或者img2，另外一个中的变量也会跟着变化。
Mat img = imread("test.jpg", CV_LOAD_IMAGE_COLOR); Mat img2(img); // 拷贝构造函数 1.2 赋值运算符进行拷贝 这种拷贝方式属于浅拷贝，下面代码中的img和img2都指向相同的内存空间，修改img或者img2，另外一个中的变量也会跟着变化。
Mat img = imread("test.jpg", CV_LOAD_IMAGE_COLOR); Mat img2 = img; // 赋值运算符 1.3 使用Rect截取拷贝 这种拷贝方式属于浅拷贝，下面代码中的img2指向的内存空间为img的子内存空间。
Mat img = imread("test.jpg", CV_LOAD_IMAGE_COLOR); Mat img2(img, Rect(200,200,300,300)); 1.4 使用clone()函数拷贝 这种拷贝方式属于深拷贝，img和img2分别指向不同的内存空间，修改img或img2 的数据，不影响另一个变量。
Mat img = imread("test.jpg", CV_LOAD_IMAGE_COLOR); Mat img2 = img.clone(); 1.5 使用copyTo()函数拷贝 这种拷贝方式属于深拷贝，img和img2分别指向不同的内存空间，修改img或img2 的数据，不影响另一个变量。
Mat img = imread("test.jpg", CV_LOAD_IMAGE_COLOR); Mat img2; img.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d4e99589d4fd71163591e0963f38f58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b00eda3b280e6bcb9759eeb67afca98/" rel="bookmark">
			NPM软件包发布到Nexus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NPM软件包发布到Nexus
文章目录 1.Linux安装nodejs环境2.创建镜像仓库3.添加nexus权限4.设置镜像仓库地址5.发布单个包6.发布tgz包7.批量发布npm包到私有仓库8.查看nexus的npm仓库9.测试 1.Linux安装nodejs环境 下载地址 https://nodejs.org/en/download/
wget https://nodejs.org/download/release/v14.18.3/node-v14.18.3-linux-x64.tar.gz tar xf node-v14.18.3-linux-x64.tar.gz mkdir -p /usr/software/ mv node-v14.18.3-linux-x64 /usr/software/nodejs ln -s /usr/software/nodejs/bin/npm /usr/local/bin ln -s /usr/software/nodejs/bin/node /usr/local/bin node -v npm -v 2.创建镜像仓库 名称自己定义，这里我定义为npm
3.添加nexus权限 在Realms菜单中，将npm Bearer Token Realm添加到Active中；
不添加执行npm publish 会报错
npm ERR! code ENEEDAUTHnpm ERR! need auth This command requires you to be logged in.npm ERR! need auth You need to authorize this machine using npm adduser 4.设置镜像仓库地址 npm config -g set registry http://x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b00eda3b280e6bcb9759eeb67afca98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf7147da1f8447ed9273fd25434d8bae/" rel="bookmark">
			嵌入式开发使用 GCC编译器警告错误问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用arm-none-eabi-gcc开发STM32也这么长时间了，期初编译过程也遇到过或多或少的问题， 与Keil的ARMCC还是有一些不同的，最近一次为了跑系统节约RAM空间，对以前的代码进行过一些修改， 又发现了一些问题，想着还是记录下来，方便你我他。 写在前面，本文说明的都是使用STM32CubeMX生成的工程，警告等级是生成工程默认的，没有修改：
arm-none-eabi-gcc 编译器的警告 1、加了 const 以后引用的问题2、missing braces around initializer [-Wmissing-braces]3、'xxx' may be used uninitialized in this function [-Wmaybe-uninitialized]4、printf 打印类型不匹配警告5、void* 类型作为函数变量6、enumeration value 'xxx' not handled in switch [-Wswitch] 1、加了 const 以后引用的问题 警告如下：
expected 'uint8 * {aka unsigned char *}' but argument is of type 'const uint8 * {aka const unsigned char *}'
问题的起因：
在源程序中本来定义了几个数组：
在其他地方有调用这数组，其实就是使用串口发送数组：
以上程序没有任何问题，是正常的，只是这几个数组在程序运行的时候会占用 ram 空间（属于 .data 段数据），所以为了优化一下，我加上了 const 修饰。
不明白这段话的可以查看我的其他博文：
STM32的内存管理相关（内存架构，内存管理，map文件分析）
这里的目的为的是将数组 保存至 flash 空间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf7147da1f8447ed9273fd25434d8bae/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/63/">«</a>
	<span class="pagination__item pagination__item--current">64/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/65/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>