<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86428c65d5b171d25f96d7b2ec16c8c4/" rel="bookmark">
			输入前序&#43;中序or中序&#43;后序结合构造二叉树，并实现错误检测机制，最终实现可视化动态逐步建树，前中后序遍历二叉树。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入前序+中序or中序+后序结合构造二叉树，并实现错误检测机制，最终实现可视化动态逐步建树，前中后序遍历二叉树。 首先放一下我的成果：
拿到题目的一瞬间我有点小懵，但完整做下来之后发现just so so。废话不多说，下面开始。
设计理念是：
1，创建一个树的节点结构体，我们采用三叉链表实现。
2，创建一个二叉树类，以节点为数据成员，用它的成员函数实现各个功能（建树，遍历，输出等）
3，直接输入前中后序序列，我采用字符数组加流的实现模式（比较有意思）
4，最后就是各个功能的具体实现。
目录 **输入前序+中序or中序+后序结合构造二叉树，并实现错误检测机制，最终实现可视化动态逐步建树，前中后序遍历二叉树。** 二叉树类数据输入前序+中序建树遍历输出可视化动态建树通过父指针寻找两个节点的公共父亲检错机制 二叉树类 //节点结构体 struct bintreenode { char data;//数据域 int depth;//树的节点高度 int depth1;//树的层数 bintreenode* leftchild, * rightchild, * parent; bintreenode(char x, int a = 0, int b = 0, bintreenode* p = NULL, bintreenode* q = NULL, bintreenode* r = NULL) :data(x),depth(a),depth1(b),leftchild(p), rightchild(q), parent(r) {}; }; //二叉树类的声明 class binarytree { public: bintreenode* root; binarytree(); bintreenode* creattreep(char* arrp, char* arrm, int size, bintreenode* p, double x0, double y0, double x, double y,int n);//前序中序建立二叉树 bintreenode* creattreel(char* arrm, char* arrl, int size, bintreenode* p, double x0, double y0, double x, double y);//中序后序建立二叉树 bintreenode* coparent(bintreenode* p, bintreenode* q); bintreenode* coparent1(char x, char y);//通过父指针获取公共父节点 int getdepth(bintreenode* p ); bintreenode* getdepth1(bintreenode* p);//获取深度 bintreenode* getx(bintreenode* p,char x); bintreenode* gety(bintreenode* p, char x);//获取节点 void preoder(bintreenode* p);//前序遍历 void inoder(bintreenode* p);//中序遍历 void postoder(bintreenode* p);//后序遍历 }; 数据输入 首先呢我们需要输入前中后序的序列，所以介绍一下我采用的流方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86428c65d5b171d25f96d7b2ec16c8c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a663f37fcbc232a3abf8a94073501b8/" rel="bookmark">
			数据结构实验二 单链表的基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单链表的基本操作 背景知识：单链表的插入、删除及应用。
目的要求：
1．掌握单链表的存储特点及其实现。
2．掌握单链表的插入、删除算法及其应用算法的程序实现。
实验内容：
编写一个完整的程序，实现单链表的生成、插入、删除、输出等基本操作。
（1） 随机产生或键盘输入一组元素，建立一个带头结点的单向链表（无序）。
（2） 计算单链表的长度，遍历单链表。
（3） 把单链表中的元素逆置（不允许申请新的结点空间）。
（4） 在单链表中删除所有值为偶数的元素结点。
（5） *编写在非递减有序单链表中插入一个元素使链表元素仍有序的函数，并利用该函数
建立一个非递减有序单链表。
（6） * 利用算法 5 建立两个非递减有序单链表，然后合并成一个非递增有序链表。
（7） * 利用算法 5 建立两个非递减有序单链表，然后合并成一个非递减有序链表。
（8） * 利用算法 1 建立的链表，实现将其分解成两个链表，其中一个全部为奇数，另一个
全部为偶数（尽量利用已知的存储空间）。
（9） * 采用单链表实现一元多项式的存储并实现两个多项式相加并输出结果。
（10） 在主函数中设计一个简单的菜单，分别调试上述算法。
代码如下：
DS.h #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;math.h&gt; #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 typedef int Status; LinkList.h #include "DS.h" typedef int Elemtype; typedef struct Node { Elemtype data; struct Node *next; }Lnode,*LinkList; void menu(); /*菜单*/ Status Init_Linklist(LinkList &amp;L); /*初始化空表*/ Status Creat_Linklist(LinkList &amp;L); /*尾插法建立单链表*/ void Disp_Linklist(LinkList L); /*单链表遍历*/ int length_Linklist(LinkList L); /*计算单链表长度*/ void Reverse_Linklist(LinkList L); /*单链表逆置*/ void DelEven_Linklist(LinkList L); /*删除值为偶数的结点*/ Status Insert_Linklist(LinkList L, int x); /*在有序单链表 L 中插入元素 x，链表仍然有序*/ Status CreatOrder_Linklist(LinkList &amp;L); /*创建非递减有序单链表*/ void MergeDescend_Linklist(LinkList La, LinkList Lb, LinkList &amp;Lc); /*两个非递减有序单链表 La和 Lb 合并成一个非递增有序链表 Lc*/ void MergeAscend_Linklist(LinkList La, LinkList Lb, LinkList &amp;Lc); /*两个非递减有序单链表 La和 Lb 合并成一个非递减有序链表 Lc*/ void Split_Linklist(LinkList La, LinkList &amp;Lb); /*链表 La按值分解成两个链表，La全部为奇数，Lb 全部为偶数*/ LinkList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a663f37fcbc232a3abf8a94073501b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/947500a459e0a9cf7a0337d28b23c863/" rel="bookmark">
			Airtest&#43;Python自动化处理windows窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在做回归测试的时候发现一条用例是查询数据库数据，于是思考如何使用工具自动化的方式解决该问题
首先想到的是jmeter的jdbc request配置大概如下
因为听说airtest也可以进行windows操作，随后开始研究如何使用airtest执行windows操作
打开airtest官网发现有三种方式可以连接windows应用窗口分别对应三个按钮
1-选择游戏画面：通过选择对应的应用窗口将程序嵌入airtestIDE进行操作
选取后会嵌入到IDE中
2-搜索窗口
点击对应应用窗口的名称进行连接即可
3.点击图标使用windows桌面直接操作
断开windows应用窗口的方式也非常简单，点击下图图标选择断开连接即可
整个操作过程中共碰到2个问题
1.airtest操作windwos应用时，对于应用弹出的窗口识别度不高
这种图标虽小，但是色差比较明显的图标可以清晰识别，但是对于弹框或者悬浮菜单无法可靠识别
为了解决问题，同时考虑到windows窗口对于鼠标键盘的可替代性，于是选择使用模拟键盘的方式解决上述问题
这里引出第二个问题，键盘操作底层是基于pywinauto开发的，所以按键略有不同，具体可参考
{SCROLLLOCK}, {VK_SPACE}, {VK_LSHIFT}, {VK_PAUSE}, {VK_MODECHANGE},
{BACK}, {VK_HOME}, {F23}, {F22}, {F21}, {F20}, {VK_HANGEUL}, {VK_KANJI},
{VK_RIGHT}, {BS}, {HOME}, {VK_F4}, {VK_ACCEPT}, {VK_F18}, {VK_SNAPSHOT},
{VK_PA1}, {VK_NONAME}, {VK_LCONTROL}, {ZOOM}, {VK_ATTN}, {VK_F10}, {VK_F22},
{VK_F23}, {VK_F20}, {VK_F21}, {VK_SCROLL}, {TAB}, {VK_F11}, {VK_END},
{LEFT}, {VK_UP}, {NUMLOCK}, {VK_APPS}, {PGUP}, {VK_F8}, {VK_CONTROL},
{VK_LEFT}, {PRTSC}, {VK_NUMPAD4}, {CAPSLOCK}, {VK_CONVERT}, {VK_PROCESSKEY},
{ENTER}, {VK_SEPARATOR}, {VK_RWIN}, {VK_LMENU}, {VK_NEXT}, {F1}, {F2},
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/947500a459e0a9cf7a0337d28b23c863/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cea116395bf800f73799bf8d3471502/" rel="bookmark">
			几行代码轻松实现跨系统传递 traceId，再也不用担心对不上日志了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
新项目查日志太麻烦，多台机器之间查来查去，还不知道是不是同一个请求的。打印日志时使用 MDC 在日志上添加一个 traceId，那这个 traceId 如何跨系统传递呢？
公众号：liuzhihangs，记录工作学习中的技术、开发及源码笔记；时不时分享一些生活中的见闻感悟。欢迎大佬来指导！
背景 同样是新项目开发的笔记，因为使用的是分布式架构，涉及到各个系统之间的交互
这时候就会遇到一个很常见的问题：
单个系统是集群部署，日志分布在多台服务器上；多个系统的日志在多台机器，但是一次请求，查日志更是难上加难。 解决方案 使用 SkyWalking traceid 进行链路追踪；使用 Elastic APM 的 trace.id 进行链路追踪；自己生成 traceId 并 put 到 MDC 里面。 MDC MDC（Mapped Diagnostic Context）是一个映射，用于存储运行上下文的特定线程的上下文数据。因此，如果使用log4j进行日志记录，则每个线程都可以拥有自己的MDC，该MDC对整个线程是全局的。属于该线程的任何代码都可以轻松访问线程的MDC中存在的值。
如何使用 MDC 在 log4j2-spring.xml 的日志格式中添加 %X{traceId} 配置。 &lt;Property name="LOG_PATTERN"&gt; [%d{yyyy-MM-dd HH:mm:ss.SSS}]-[%t]-[%X{traceId}]-[%-5level]-[%c{36}:%L]-[%m]%n &lt;/Property&gt; &lt;Property name="LOG_PATTERN_ERROR"&gt; [%d{yyyy-MM-dd HH:mm:ss.SSS}]-[%t]-[%X{traceId}]-[%-5level]-[%l:%M]-[%m]%n &lt;/Property&gt; &lt;!-- 省略 --&gt; &lt;!--这个输出控制台的配置--&gt; &lt;Console name="Console" target="SYSTEM_OUT" follow="true"&gt; &lt;!--输出日志的格式--&gt; &lt;PatternLayout charset="UTF-8" pattern="${LOG_PATTERN}"/&gt; &lt;/Console&gt; 新增拦截器 拦截所有请求，从 header 中获取 traceId 然后放到 MDC 中，如果没有获取到，则直接用 UUID 生成一个。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cea116395bf800f73799bf8d3471502/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab6a619ff99e6c4ba50ccbd8a1412ff5/" rel="bookmark">
			因子分析（FA）算法简述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、什么是因子分析？1.1 因子分析应用背景1.2 因子分析算法的基本步骤1.3 因子分析算法的数学解释1.3.1 因子模型1.3.2 因子载荷矩阵的求解1.3.3 因子载荷矩阵的旋转1.3.4 因子得分 二、因子分析的应用实例三、主成分分析（PCA）与因子分析（FA）的联系与区别总结 前言 在学习数据降维时，了解到因子分析（FA）算法是其中的一种方式，因此，在这里对因子分析算法做一个简要的归纳、梳理，后续会对数据降维的几种方式做个总结，感兴趣的朋友，可以持续关注。
一、什么是因子分析？ 因子分析法是指： 研究从变量群中提取共性因子的统计技术，这里的共性因子指的是不同变量之间内在的隐藏因子。例如，一个学生的英语、数据、语文成绩都很好，那么潜在的共性因子可能是智力水平高。因此，因子分析的过程其实是寻找共性因子和个性因子并得到最优解释的过程。
其基本思想是： 根据相关性大小把变量分组，使得同组内的变量之间相关性较高，但不同组的变量不相关或相关性较低，每组变量代表一个基本结构一即公共因子。
因子分析有两个核心问题： 一是如何构造因子变量，二是如何对因子变量进行命名解释。
因子分析类型： R型因子分析与Q型因子分析，就像聚类分析分为R型和Q型一样，R型的因子分析是对变量作因子分析，Q型因子分析是对样品作因子分析，本文是以R型因子分析展开。
1.1 因子分析应用背景 因子分析用于处理高斯数据，主要应用于以下两种情形：
假如有 m 个样本，每个样本的维度是 n, 如果 n » m；这时哪怕拟合出一个高斯模型都很困难，更不用说高斯混合, 为什么呢?其实，这和解多元线性方程组是一样的道理，就是自变量的个数多于非线性相关的方程的个数，这必然导致解的不唯一，虽然在解方程的时候可以随便选一个解满足方程组，但是对于某一实际数据集，往往样本对应的概率分布在客观上都是唯一的，只是我们无法简单地用概率论中的几个典型的分布准确表示出来罢了！m 个样本的维度都较低。用高斯分布对数据建模，用最大似然估计去估计均值（期望）和方差：
我们会发现，协方差矩阵 Σ 是奇异的，即 Σ 不可逆，Σ-1 不存在，且有：
但是这两项在计算多元高斯分布时，又都是必不可少的。所以，除非 m 比 n 大一定较合适的数值，否则对方差和均值的最大似然估计将会很难找到正确的值。 1.2 因子分析算法的基本步骤 应用因子分析算法时，常常有如下几个基本步骤：
确定原有若干变量是否适合于因子分析；因子分析的基本逻辑是从原始变量中构造出少数几个具有代表意义的因子变量，这就要求原有变量之间要具有比较强的相关性，否则，因子分析将无法提取变量间的“共性特征”（变量间没有共性还如何提取共性？）。实际应用时，可以使用相关性矩阵进行验证，如果相关系数小于0.3，那么变量间的共性较小，不适合使用因子分析；也可以用KMO 和 Bartlett 的检验来判断是否适合做因子分析，一般来说KMO的值越接近于1越好，大于zhi0.5的话适合做因dao子分析，你的KMO值是0.674大于0.5。Bartlett 的检验主要看Sig.越小越好，你的接近于0.由此可以得出，你的数据适合做因子分析。构造因子变量；因子分析中有多种确定因子变量的方法，如基于主成分模型的主成分分析法和基于因子分析模型的主轴因子法、极大似然法、最小二乘法等。利用旋转使得因子变量更具有可解释性 ；在实际分析工作中，主要是因子分析得到因子和原变量的关系，从而对新的因子能够进行命名和解释，否则其不具有可解释性的前提下对比PCA就没有明显的可解释价值。计算因子变量的得分 。子变量确定以后，对每一样本数据，希望得到它们在不同因子上的具体数据值，这些数值就是因子得分，它和原变量的得分相对应。 具体而言：
(1) 相关性检验，一般采用KMO检验法和Bartlett球形检验法两种方法来对原始变量进行相关性检验；(2) 输入原始数据Xn*p，计算样本均值和方差，对数据样本进行标准化处理；(3) 计算样本的相关矩阵R；(4) 求相关矩阵R的特征根和特征向量；(5) 根据系统要求的累积贡献率确定公共因子的个数；(6) 计算因子载荷矩阵A；(7) 对载荷矩阵进行旋转，以求能更好地解释公共因子；(8) 确定因子模型；(9) 根据上述计算结果，求因子得分，对系统进行分析 1.3 因子分析算法的数学解释 1.3.1 因子模型 因子分析中的公共因子是不可直接观测但又客观存在的共同影响因素，每个变量都可以表示成公共因子的线性函数与特殊因子之和，即：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab6a619ff99e6c4ba50ccbd8a1412ff5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8181d72dd0762c05dec791f5e5d815e5/" rel="bookmark">
			实现cell图片自适应方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UITableView 是 iOS 开发中最常用的控件之一,使用 UITaleView 时最头疼的莫过于 cell 高度的计算,虽说在 iOS8.0 以后引入了自适应方法,但在适配过程中任然会遇到各种难题,尤其是为了满足产品需求进行复杂 cell 自定义时,高度计算可谓是难上加难.这里主要对开发中遇到的自定义 cell 是加载网络图片适配问题进行总结.
在开发中为了用户能有更好体验,对网络请求多采用异步请求的方式,更有甚者对请求数据做了本地缓存.图片作为 app 中最常见的展现形式无疑是最耗流量的,对图片的处理直接影响到用户的体验,好在有大神为我们提供了好的框架(Kingfisher,SDWebImage),大大提高了我们的开发效率.
图片的异步加载提高了用户体验,却在开发中遇到了新的难题,因为图片异步加载你无法提前预知图片的尺寸,在布局时难以控制 UIImageView 的大小,如果将 UIImageView 固定大小势必会造成图片的压缩或拉伸,现在主要针对于自定义 cell 时对图片自适应布局提一些建议.
固定 UIImageView 大小 在开发中我们时常会将 UIImageView 固定大小或者固定宽高比例,通过设置 ImageView 的 contentMode 属性设置图片的显示风格.
该方法简单容易造成图片压缩拉伸或显示不全问题.
contentMode 取值:
public enum UIViewContentMode : Int { case scaleToFill //缩放内容到合适比例大小 case scaleAspectFit //缩放内容到合适的大小，边界多余部分透明 case scaleAspectFill //缩放内容填充到指定大小，边界多余的部分省略 case redraw //重绘视图边界 case center //视图保持等比缩放,居中 case top //视图顶部对齐 case bottom //视图底部对齐 case left //视图左侧对齐 case right //视图右侧对齐 case topLeft //视图左上角对齐 case topRight //视图右上角对齐 case bottomLeft //视图左下角对齐 case bottomRight //视图右下角对齐 } 通过获取服务器存储的图片尺寸布局 在上传图片时可以将图片的大小一起上传服务器保存,在用户加载图片时将图片信息和图片 URL 地址一起返回,根据返回的图片信息计算 UIImageView 的 size 进行布局.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8181d72dd0762c05dec791f5e5d815e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5b0620991d6a5851c2c4d02112bc1a1/" rel="bookmark">
			Keychain的介绍和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是 Keychain? iOS 的 keychain 服务提供了一种安全的保存私密信息（密码，序列号，证书等）的方式，每个ios程序都有一个独立的keychain存储。
用于储存一些私密信息，比如密码、证书等等，Keychain里保存的信息不会因App被删除而丢失，在用户重新安装App后依然有效。
同样也适用于应用之间数据共享。我们可以把KeyChain理解为一个Dictionary，所有数据都以key-value的形式存储，可以对这个Dictionary进行add、update、get、delete这四个操作。
keychain 的四个方法介绍? 存储方法 OSStatus SecItemAdd(CFDictionaryRef attributes, CFTypeRef * __nullable CF_RETURNS_RETAINED result) attributes: 要添加的数据
result: 存储数据后,返回一个指向该数据的引用,不使用该数据传入 nil
条件查询方法 OSStatus SecItemCopyMatching(CFDictionaryRef query, CFTypeRef * __nullable CF_RETURNS_RETAINED result) query: 要查询数据的条件
result: 查询到数据的引用
数据更新方法 OSStatus SecItemUpdate(CFDictionaryRef query, CFDictionaryRef attributesToUpdate) query: 要更新数据的查询条件
attributesToUpdate: 要更新的数据
删除数据方法 OSStatus SecItemDelete(CFDictionaryRef query) query: 要删除数据的查询条件
使用 Keychain 使用 Keychain 首先需要导入安全框架 secutity.framework
创建查询条件 class func createQuaryMutableDictionary(identifier: String)-&gt;NSMutableDictionary{ // 创建一个条件字典 let keychainQuaryMutableDictionary = NSMutableDictionary.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5b0620991d6a5851c2c4d02112bc1a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc41bbc91e59fdfadc24b6b41423673b/" rel="bookmark">
			SpringCloud(12) —— Feign:使用接口方式调用服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.Feign简介2.Feign的作用3.Feign的使用步骤4.小结5.怎么选择使用Ribbon还是Feign 1.Feign简介 Feign是声明式Web Service客户端，它让微服务之间的调用变得更简单，类似controller调用service。SpringCloud集成了Ribbon和Eureka，可以使用Feigin提供负载均衡的http客户端只需要创建一个接口，然后添加注解即可使用FeignFeign，主要是社区版，大家都习惯面向接口编程。这个是很多开发人员的规范。调用微服务访问两种方法 微服务名字 【ribbon，即前面我们使用ribbon实现负载均衡的时候选中哪一个服务集群是依据注册中心的 服务名称/微服务名字 进行选择的，但是我们不应该在客户端中将要调用的服务集群名称写死了，而是应该是一个变量，因为一个客户端在正常情况下不会只消费一个服务者一个的服务，它会消费多个服务者提供的不同的服务，所以将服务名称写死是满足我们使用需求的，所以就出现了Feign，通过接口解决这个问题】接口和注解 【feign】 我们需要注意：Feign是声明式Web Service客户端，说明它和ribbon一样，都是在客户端使用的负载均衡工具，所以在使用Feign的时候，我们还是要在消费者微服务中去进行代码编写 2.Feign的作用 Feign旨在使编写Java Http客户端变得更容易前面在使用Ribbon + RestTemplate时，利用RestTemplate对Http请求的封装处理，形成了一套模板化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一个客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步的封装，由他来帮助我们定义和实现依赖服务接口的定义，在Feign的实现下，我们只需要创建一个接口并使用注解的方式来配置它 (类似以前Dao接口上标注Mapper注解，现在是一个微服务接口上面标注一个Feign注解即可)，即可完成对服务提供方的接口绑定，简化了使用Spring Cloud Ribbon 时，自动封装服务调用客户端的开发量Feign默认集成了Ribbon 利用Ribbon维护了MicroServiceCloud-Dept的服务列表信息，并且通过轮询实现了客户端的负载均衡，而与Ribbon不同的是，通过Feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用 3.Feign的使用步骤 直接在前面我们写的微服务项目中进行改造即可这里为了和使用ribbon的消费者微服务model分别开，我们新创建一个使用Feign实现负载均衡的消费者model：springcould-consumer-dept-Feign
然后回到最开始提供实体类dept的springcould-api模块中，到现在我们应该可以理解这个模块的作用了，它的作用就是将整个服务需要的实体类抽取了出来，抽取出来之后，我们可以在其他model中通过pom.xml将它导入，导入之后就可以实现复用，而不用每一个要使用这个实体类的model中都去定义一遍这个类现在使用Feign，我们需要回到这个model中，首先导入Feign的依赖，否则不能使用Feign的注解(为了等会儿我们新创建的消费者模块也可以使用Feign，在springcould-consumer-dept-Feign的pom.xml中也导入Feign的依赖)&lt;!-- Feign --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;version&gt;1.4.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; Feign实现消费者模块调用服务提供者模块的原理和原来的Dubbo+zookeeper类似，即需要使用注解实现远程注入，所以我们直接在springcould-api模块中添加一个接口DeptClientService，这个接口中的方法定义自己随意，只是方法上面要像controller一样写上@RequestMapping或者它的变体@GetMapping、@PostMapping等，但是这个接口上面不需要使用注解@Controller或@RestController这个接口上面需要使用注解@FeignClient(value = “服务集群在注册中心中的名称”)和注解@Component或者它的变体@Service；其中注解@FeignClient+value属性用于指定注册中心中哪一个服务中的package com.thhh.springcould.service; import com.thhh.springcould.pojo.Dept; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.stereotype.Component; import org.springframework.stereotype.Service; import org.springframework.web.bind.annotation.*; import java.util.List; @Service @Component //@FeignClient:微服务客户端注解,value:指定微服务的名字,这样就可以使Feign客户端直接找到对应的微服务 @FeignClient(value = "SPRINGCOULD-PROVIDER-DEPT") public interface DeptClientService { @GetMapping("/dept/queryById/{id}")/ Dept queryById(@PathVariable("id") Long id); @GetMapping("/dept/queryList") List&lt;Dept&gt; queryAll(); @PostMapping("/dept/add") boolean addDept(Dept dept); } 注意：还需要在这个接口上加上注解@Component/@Service，否则这个接口不会被spring托管/装配到spring容器中，那么我们在消费者model中使用这个类的时候就不能使用注解@Autowired实现对象自动注入到消费者的controller中(注意：我们是在springcould-api模块中定义的这个接口，并在这个接口上面加上了注解@Component，这个注解不是要在springcould-api模块中起作用，而是要在使用springcould-api模块的其他模块中起作用，即哪个模块导入了springcould-api模块，那么在这个model启动的时候，有注解@Component的这个接口就会被装配到spring容器中去，然后我们只需要在当前的这个模块中使用注解@Autowired就可以获取到这个接口在spring容器中的实例，就可以调用它内部的方法实现对应的功能)然后去修改刚刚粘贴到springcould-consumer-dept-Feign中的的controller的代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc41bbc91e59fdfadc24b6b41423673b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d30a8fa0a54f53700b8e9c886ea9d6ac/" rel="bookmark">
			ubuntu linux vnc server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 启动 VNC 服务 vncserver
2 查看服务是否已经启动 ps -ef | grep vnc4
VNC远程桌面到linux，提示connection refused(10061)解决办法 确认server端的VNC服务开启，service vncserver start，检测状态时ok的使用vncserver命令，确认vnc服务已经启动ps -ef | grep vnc，来查看不是已经开启多个vnc连接。如果有多个vnc连接，使用vncserver kill ：x（x为连接的序号）来结束掉已经开启的vnc连接在客户端上重新用客户端连接主机，在ip后面接上端口号 Linux上VNC 启动和关闭 ( 解决 Ubuntu16.04 sncserver连接出现Timed out waiting for a response from the computer） 整体思路：
查看vncserver端口 是否开启 （手动kill vncserver进程有坑~~~，有时再次开启时 需要一些额外操作，解决办法在2中，）
0, 重设密码
root@ubuntu:~# vncpasswd
Password:
Verify:
root@ubuntu:~#
1，启动和kill vncserver
[root@yqrh5u2 ~]# vncserver :1
New 'yqrh5u2:1 (root)' desktop is yqrh5u2:1
Starting applications specified in /root/.vnc/xstartup
Log file is /root/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d30a8fa0a54f53700b8e9c886ea9d6ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dde68741f3bdea2b2c832afc2bc323a6/" rel="bookmark">
			SpringCloud(11) —— Ribbon:自定义负载均衡算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.切换ribbon自带的负载均衡算法2.分析如何实现ribbon的自定义负载均衡算法3.代码实现 1.切换ribbon自带的负载均衡算法 在上一篇博客中我们测试了ribbon的默认负载均衡算法，就是轮询，但是我们还可以自定义它的负载均衡算法，代替它的默认轮询算法在自己实现策略之前，还是按照原来的套路，先去看看ribbon怎么实现的负载均衡算法，我们在客户端集成ribbon实现负载均衡的时候只是导入了ribbon的依赖，并自定义了一个config类，用于编写一个@Bean方法将RestTemplate对象装配到spring容器中，并在该@Bean方法上使用了注解@LoadBalanced用于开启客户端使用ribbon实现负载均衡所以我们需要去注解@LoadBalanced中查询ribbon实现的负载均衡的算法，但是通过查看注解@LoadBalanced的源码我们可以发现，这个注解中并没有什么特别的地方，所以就去百度了一下，通过百度结果我们可以发现ribbon的负载均衡算法实现都是根据接口IRule实现的，所以我们可以看看这个接口的源码public interface IRule { Server choose(Object var1); void setLoadBalancer(ILoadBalancer var1); ILoadBalancer getLoadBalancer(); } 可以发现这个接口中主要的就是设置负载均衡的算法(setLoadBalancer())和设置选中的server(choose())两个方法，所以我们需要参考的实行类来实现自定义负载均衡算法
第一个一般不会使用AvailabilityFilteringRule：用于首先过滤掉已经崩溃的服务者提供的服务(或者说已经跳闸的服务)，即先过滤掉已经故障的服务，然后再在剩下的服务中进行轮询【所以AvailabilityFilteringRule就是优化版的轮询】RoundRobinRule：就是我们说的轮询策略RandomRule：这也是我们前面说过的随机策略WeightedResponseTimeRule：就是按照权重实现负载均衡RetryRule：首先使用轮询获取服务，如果获取的服务跳闸了，就会在指定的时间内进行重连 测试默认轮询效果
使用ribbon自己提供的随机负载均衡算法，只需要在config类中将RandomRule对象注入spring容器中即可@Bean public IRule myRule(){ return new RandomRule(); } 通过上面的测试效果，我们可以发现只要将不同的ribbon的负载均衡策略的实现类通过config类装配到spring容器中，就可以实现ribbon不同的负载均衡算法的切换，上面的例子中就是要了默认算法轮询和指定算法随机，开启消费者model之后都是刷新3次查看结果所以我们自己在实现了自定义负载均衡算法之后，也需要将实现的算法类通过config类装配到spring容器中去 2.分析如何实现ribbon的自定义负载均衡算法 以上就是常用的几种ribbon实现负载均衡的算法，我们可以观察它的的共性，然后照猫画虎实现自定义的负载均衡算法首先上面的这些是实行类都直接或间接的继承了一个IRule接口的实行类AbstractLoadBalancerRule，所以我们自己实现的时候也应该去继承它，除此之外实行类的具体实现还是需要具体的去参考1-2个ribbon的具体实行类，这里我们就参考最经典的轮询算法的实现ribbon中轮询算法实现源码public class RoundRobinRule extends AbstractLoadBalancerRule { private AtomicInteger nextServerCyclicCounter; private static final boolean AVAILABLE_ONLY_SERVERS = true; private static final boolean ALL_SERVERS = false; private static Logger log = LoggerFactory.getLogger(RoundRobinRule.class); public RoundRobinRule() { this.nextServerCyclicCounter = new AtomicInteger(0); } public RoundRobinRule(ILoadBalancer lb) { this(); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dde68741f3bdea2b2c832afc2bc323a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/876421409934d3c493fa8155db19432b/" rel="bookmark">
			2.8 STM32_按键扫描_安富莱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、程序优点 扩展性非常强，功能比较齐全；
bsp_key按键驱动程序用于扫描独立按键，具有软件滤波机制，采用FIFO机制保存键值。可以检测如下事件：
按键按下。
按键弹起。
长按键。
长按时自动连发。
我们将按键驱动分为两个部分来介绍，一部分是FIFO的实现，一部分是按键检测的实现。
bsp_key.c 文件包含按键检测和按键FIFO的实现代码。
bsp.c 文件会调用bsp_InitKey()初始化函数。
bsp.c 文件会调用bsp_KeyScan按键扫描函数。
bsp_timer.c 中的Systick中断服务程序调用 bsp_RunPer10ms。
中断程序和主程序通过FIFO接口函数进行信息传递。
函数调用关系图
按键FIFO的原理
FIFO是First Input First Output的缩写，先入先出队列。我们这里以5个字节的FIFO空间进行说明。Write变量表示写位置，Read变量表示读位置。初始状态时，Read = Write = 0。
我们依次按下按键K1，K2，那么FIFO中的数据变为：
如果Write！= Read，则我们认为有新的按键事件。
我们通过函数bsp_GetKey读取一个按键值进行处理后，Read变量变为1。Write变量不变。
我们继续通过函数bsp_GetKey读取3个按键值进行处理后，Read变量变为4。此时Read = Write = 4。两个变量已经相等，表示已经没有新的按键事件需要处理。
有一点要特别的注意，如果FIFO空间写满了，Write会被重新赋值为0，也就是重新从第一个字节空间填数据进去，如果这个地址空间的数据还没有被及时读取出来，那么会被后来的数据覆盖掉，这点要引起大家的注意。我们的驱动程序开辟了10个字节的FIFO缓冲区，对于一般的应用足够了。
设计按键FIFO主要有三个方面的好处：
可靠地记录每一个按键事件，避免遗漏按键事件。特别是需要实现按键的按下、长按、自动连发、弹起等事件时。
读取按键的函数可以设计为非阻塞的，不需要等待按键抖动滤波处理完毕。
按键FIFO程序在嘀嗒定时器中定期的执行检测，不需要在主程序中一直做检测，这样可以有效地降低系统资源消耗。
详细参考：第19章 STM32H7的GPIO应用之按键FIFO
2、代码 bsp_key.c /* ********************************************************************************************************* * *	模块名称 : 独立按键驱动模块 *	文件名称 : bsp_key.c *	版 本 : V1.0 *	说 明 : 扫描独立按键，具有软件滤波机制，具有按键FIFO。可以检测如下事件： *	(1) 按键按下 *	(2) 按键弹起 *	(3) 长按键 *	(4) 长按时自动连发 * *	修改记录 : *	版本号 日期 作者 说明 *	V1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/876421409934d3c493fa8155db19432b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d861a3f34d3509e48dede5b5a812c52a/" rel="bookmark">
			SpringCloud(5) —— Eureka：什么是Eureka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.什么是Eureka2.Eureka原理理解1.Eureka基本的架构 3.代码实现Eureka注册中心 1.什么是Eureka 读音
Netflix在涉及Eureka时，遵循的就是API原则.Eureka是Netflix的有个子模块，也是核心模块之一。Eureka是基于REST的服务，用于定位服务，以实现云端中间件层服务发现和故障转移，服务注册与发现对于微服务来说是非常重要的，有了服务注册与发现，只需要使用服务的标识符，就可以访问到服务，而不需要修改服务调用的配置文件了，功能类似于Dubbo的注册中心，比如Zookeeper 2.Eureka原理理解 1.Eureka基本的架构 Springcloud 封装了Netflix公司开发的Eureka模块来实现服务注册与发现 (对比Zookeeper)Eureka采用了C-S的架构设计，Eureka Server作为服务注册功能的服务器，它是服务注册中心而系统中的其他微服务，使用Eureka的客户端连接到Eureka Server并维持心跳连接，这样系统的维护人员就可以通过Eureka Server来监控系统中各个微服务是否正常运行，Spring cloud 的一些其他模块 (比如Zuul) 就可以通过Eureka Server来发现系统中的其他微服务，并执行相关的逻辑 在dubbo+zookeeper中我们可以使用dubbo-admin来实现可视化的监控，在spring cloud中我们可以使用Eureka Server实现监控功能 Eureka和Dubbo对比
Eureka 包含两个组件：Eureka Server 和 Eureka ClientEureka Server 提供服务注册，各个节点启动后，会在Eureka Server中进行注册，这样Eureka Server中的服务注册表中将会储存所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到Eureka Client 是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的，使用轮询负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳 (默认周期为30秒) 。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，Eureka Server将会从服务注册表中把这个服务节点移除掉 (默认周期为90s)Eureka 三大角色 Eureka Server：提供服务的注册与发现Service Provider：服务生产方，将自身服务注册到Eureka中，从而使服务消费方能够找到Service Consumer：服务消费方，从Eureka中获取注册服务列表，从而获取可以进行消费的服务 原来的zookeeper的服务端不需要我们进行编写，只需要我们将下载的zookeeper中的服务端启动即可，但是Eureka的服务端需要我们自己进行编写，但是编写的步骤也很简单，只需要使用注解开启即可使用 3.代码实现Eureka注册中心 创建一个新的model，专门用来实现Eureka 注册中心，model名称为：springcould-eureka-7001其实我们只需要导入需要的依赖，配置一些参数就可以实现Eureka注册中心，我们使用的监控页面还是我们导入的依赖自带的，我们只需要按照自己的需求修改一些注册中心的参数，并在spring boot项目的入口程序上添加注解@EnableEurekaServer即完成导入依赖
现在我们先把服务启动了再做后面的，所以应该先导入Spring Cloud Starter Eureka Server&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;version&gt;1.4.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; 还可以导入一个热部署依赖&lt;!--eureka依赖--&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server --&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d861a3f34d3509e48dede5b5a812c52a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af1b8670e069a31b7bffabbd61f4cc91/" rel="bookmark">
			xcode打包iOS教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、申请iOS发布证书和描述文件
1、首先申请一个App IDs（应用身份证）、已申请略过。
APP IDs在后面很多地方用到
首先打开开发者中心https://developer.apple.com/account，进入证书页面。
1.1点击证书、ID及配件文件，进入设置。
1.2选择App IDs –&gt;点击+创建一个新的App ID
其中有两项需要你自己填：
第一项Name，用来描述你的App ID，这个随便填，没有什么限制，最好是项目名称，这样方便自己辨识（不允许中文）
第二项Bundle ID (App ID Suffix)，这是你App ID的后缀，需要仔细填写。用来标示我们的 app，使它有一个固定的身份，和你的程序直接相关。填写 Explicit App ID 的格式为：com.company.appName（要有两个点.）照着格式写，写个方便记的，后面很多地方要用到。
第三项配置服务权限，默认会选择2项，不能修改，其它常用的苹果支付，APP推送通知，根据自己需要的服务选择上，然后点击Continue确认，下一步。
选择苹果支付和推送通知，还需要创建对应的iOS苹果支付证书和iOS推送证书。
一般没什么要求默认就好。
检查下没有错的话直接点击Register后点击Done完成App ID的创建。
2、申请发布证书
这里用Appuploader工具直接申请导出p12文件和描述文件。
如果还没安装Appuploader先安装好
Appuploader安装教程
刚真机测试申请的是开发证书，上架需要申请发布证书，替换下发布证书打包就能上架了（发布版证书打包的不能安装，所以先用开发证书测试好再替换发布证书发布上架包）。
1.1、点击右下角+ADD选择，下拉选择发布证书
证书名称：不要中文、随意设置
邮箱：随意
密码：证书的密码、比如设置123这样，不用很复杂，记好、打包时要用、很重要
应用id：这里不用选
点击ok创建。
注意：iOS发布证书最多能申请3个，如果账号已经有3个发布证书了，将申请报错
一个发布证书可以用于多个APP上架，不是说只能申请3个发布证书就只能上架3个app，完全不用每个app都申请个发布证书p12，发布证书p12是可以公用的，区分开下面步骤申请的的描述文件就行了。一个p12可以对应无数的描述文件。
也可以删掉之前的发布证书，重新创建，不会影响已上架的app。
1.2、创建成功后，找到刚创建的发布证书（iOS Distribution这个类型的就是发布证书，如果之前创建过请看过期时间就知道哪个是新创建的了），点击p12 文件,下载保存.p12证书文件到电脑。
创建iOS发布描述文件（.mobileprovision文件）
2.1、返回Appuploader首页，选择描述文件。
2.2、点击+ ADD，对应选择发布版profile
应用id:选择对应的id（又称套装id，appid，BundleID，包名）
证书：选中全部就行
Devices：设备这里不像选开发版profile时会出现，发布版不用选。
输入名称：不要中文，随意，123之类的就行，注意不要跟之前申请过的名称一样），点击ok创建。
2.3、选择刚创建的发布版描述文件（iOS Distribution这个类型的就是发布描述文件，找刚创建的输入的名称），点击Download下载，保存到电脑
如此就得到了一个.p12证文件和.mobileprovision描述文件
二、导入iOS证书p12到钥匙串
1、打开钥匙串助手，双击p12文件，默认钥匙串是（登录），注意这里一定要选择（系统）
这样后面打包时iOS证书才不会报错。
2、导入后提示此证书是由未知颁发机构签名的，因为不是用本机的钥匙串文件申请的iOS证书
不过没关系，设置一下信任就好了
3、双击证书、点击信任，使用此证书时，设置为始终信任。
三、xcode配置iOS证书和打包环境
1、用xocde打开你的项目，点击进入设置证书界面。
有两个地方都要设置
选择Code Signing下面的release（发布版）Debugs是测试版，如果打包测试就选测试版，导入iOS发布证书。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af1b8670e069a31b7bffabbd61f4cc91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e42d88d309fe9c7380c8737a5fe07fa/" rel="bookmark">
			SpringCloud(3) —— Rest学习环境搭建:服务提供者
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.总体介绍2.SpringCloud版本选择3.创建工程1.创建父工程2.创建子model3.服务提供者编写4.测试 1.总体介绍 我们会使用一个Dept部门模块做一个微服务通用案例Consumer消费者(Client)通过REST调用Provider提供者(Server)提供的服务回顾Spring，SpringMVC，Mybatis等以往学习的知识Maven的分包分模块架构复习一个简单的Maven模块结构是这样的： -- app-parent: 一个父项目(app-parent)聚合了很多子项目(app-util\app-dao\app-web...) |-- pom.xml | |-- app-core ||---- pom.xml | |-- app-web ||---- pom.xml ...... 一个父工程带着多个model子模块MicroServiceCloud父工程(Project)下初次带着3个子模块(Module) microservicecloud-api 【封装的整体entity/接口/公共配置等】microservicecloud-consumer-dept-80 【服务提供者】microservicecloud-provider-dept-8001 【服务消费者】 2.SpringCloud版本选择 大版本说明
实际开发版本关系
使用后两个 3.创建工程 1.创建父工程 创建新项目
首先导入项目依赖，首先当然是导入核心依赖，依赖名称我们可以在官方Doc上面找
&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-dependencies --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Hoxton.SR8&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt;&lt;!--可以直接删除，也可以改成import--&gt; &lt;/dependency&gt; 第二个需要导入的依赖为spring boot的依赖，因为spring could的使用是依赖于spring boot的，所以我们应该导入spring boot的依赖；但是我们需要spring could和spring boot之间的版本对应(版本对应网址，注意：需要使用火狐才能正常的解析查看下图样式，其他的浏览器就是正常的JSON字符串，没有样式我们可以直接搜索也可以找到对应的版本选择)
所以我们使用的最新稳定版sr8对应的spring boot版本需要在2.2.0-2.3.5之间，而我们前面使用的spring boot刚好为2.3.4，所以我们沿用前面的spring boot依赖即可&lt;!--spring boot的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt;&lt;!--可以直接删除，也可以改成import--&gt; &lt;/dependency&gt; 数据库依赖&lt;!--数据库依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!--数据源--&gt; &lt;dependency&gt; &lt;groupId&gt;com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e42d88d309fe9c7380c8737a5fe07fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/686672a1991ac61cad11a61401475ae5/" rel="bookmark">
			太可惜了，Spring中的循环依赖问题，只有10%的人才算“真的懂”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Spring中的循环依赖一直是Spring中一个很重要的话题，一方面是因为源码中为了解决循环依赖做了很多处理，另外一方面是因为面试的时候，如果问到Spring中比较高阶的问题，那么循环依赖必定逃不掉。如果你回答得好，那么这就是你的必杀技，反正，那就是面试官的必杀技，这也是取这个标题的原因，当然，本文的目的是为了让你在之后的所有面试中能多一个必杀技，专门用来绝杀面试官！
本文的核心思想就是，
当面试官问：
“请讲一讲Spring中的循环依赖。”的时候，
我们到底该怎么回答？
主要分下面几点
什么是循环依赖？ 什么情况下循环依赖可以被处理？
Spring是如何解决的循环依赖？
同时本文希望纠正几个目前业界内经常出现的几个关于循环依赖的错误的说法
只有在setter方式注入的情况下，循环依赖才能解决（错）
三级缓存的目的是为了提高效率（错）
OK，铺垫已经做完了，接下来我们开始正文
什么是循环依赖？
从字面上来理解就是A依赖B的同时B也依赖了A，就像下面这样
体现到代码层次就是这个样子
@Component public class A { // A中注入了B @Autowired private B b; } @Component public class B { // B中也注入了A @Autowired private A a; } 当然，这是最常见的一种循环依赖，比较特殊的还有
// 自己依赖自己 @Component public class A { // A中注入了A @Autowired private A a; } 虽然体现形式不一样，但是实际上都是同一个问题-----&gt;循环依赖
什么情况下循环依赖可以被处理？ 在回答这个问题之前首先要明确一点，Spring解决循环依赖是有前置条件的
出现循环依赖的Bean必须要是单例
依赖注入的方式不能全是构造器注入的方式（很多博客上说，只能解决setter方法的循环依赖，这是错误的）
其中第一点应该很好理解，第二点：不能全是构造器注入是什么意思呢？我们还是用代码说话
@Component public class A { // @Autowired // private B b; public A(B b) { } } @Component public class B { // @Autowired // private A a; public B(A a){ } } 在上面的例子中，A中注入B的方式是通过构造器，B中注入A的方式也是通过构造器，这个时候循环依赖是无法被解决，如果你的项目中有两个这样相互依赖的Bean，在启动时就会报出以下错误：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/686672a1991ac61cad11a61401475ae5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da8456ec0586bc661c70ca9500622eb6/" rel="bookmark">
			Linux下的大实验——图书管理系统 代码超级详细
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linus下的大实验——图书管理系统 示例图1图2 main函数实现类用户-People类读者信息-Read_stream类图书总信息-Book类作者索引-Name类书名索引-Bookname类出版社索引-Publishing类 示例 图1 图2 main函数 #include &lt;bits/stdc++.h&gt; #include &lt;termios.h&gt; #include &lt;unistd.h&gt; #include&lt;string.h&gt; #include"People.h" #include"Read_stream.h" #include"Book.h" #include"Bookname.h" #include"Name.h" #include"Publishing.h" #include "Library.h" using namespace std; int getch() { struct termios oldt,newt; int ch; tcgetattr( STDIN_FILENO, &amp;oldt );//获得标准输入的终端参数，将获得的信息保存在oldt变量中 newt = oldt; newt.c_lflag &amp;= ~( ICANON | ECHO ); tcsetattr( STDIN_FILENO, TCSANOW, &amp;newt ); ch = getchar(); tcsetattr( STDIN_FILENO, TCSANOW, &amp;oldt ); return ch; } template&lt;class T&gt; void write_people(T &amp;t,char *filename){ ofstream out(filename,ios::app); out.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da8456ec0586bc661c70ca9500622eb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4919764915a5347117202a7b8430f233/" rel="bookmark">
			SpringCloud(0) —— 为什么要学习SpringCloud
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.回顾前面学习的知识点2.学习SpringCloud的基础3.为什么要学习SpringCloud1.MVC三层架构1.MVC三层架构2.简化MVC三层架构的Spring3.简化Spring的SpringBoot 2.新的架构：微服务架构1.为什么需要新的架构2.什么是微服务架构3.微服务架构的需要解决的问题4.微服务架构问题解决办法/方案1.SpringCloud NetFilx(第一套SpringCloud生态)2.Apache Dubbo zookeeper(第二套SpringCloud生态)3.SpringCloud Alibaba(第三套SpringCloud生态)4.未来的SpringCloud生态(服务网格，Server Mesh)5.小结 5.需要区分的概念集群、分布式和微服务的区别 4.常见面试题 1.回顾前面学习的知识点 JavaSE数据库前端ServletHttpMybatisSpringSpringMVCSpringBootDubbo、Zookeeper、分布式基础Maven、GitAjax、Json… 2.学习SpringCloud的基础 数据库MybatisSpringSpringMVCSpringBootDubbo、Zookeeper、分布式基础Maven、GitAjax、Json 3.为什么要学习SpringCloud 1.MVC三层架构 1.MVC三层架构 首先SpringCloud是一个微服务架构，而我们最早接触的架构为：三层架构 MVC架构的本质：为了解耦，降低功能模块之间的耦合性 2.简化MVC三层架构的Spring 升级三层架构 MVC，就是我们使用的框架，本质还是在使用三层架构MVC，只是简化了开发： 粘合剂Spring：核心 IOC + AOP Spring是一个轻量级的Java开源框架，也是一个容器；用于解决企业开发的复杂性IOC：控制反转，实现方式DI(依赖注入)，将原来要做的准本都丢给容器，要用东西直接去容器中取AOP：切面，本质为动态代理(Proxy)，为了在不影响原来的业务的情况下(不改源码)，实现功能的新增 比如：日志、事务等 目的：解决企业开发的复杂性 3.简化Spring的SpringBoot spring本意是简化开发，但是spring经过多年的发展，集成的东西越来越多，这使得它使用起来并不简单，使用的过程中涉及到了很多的配置文件的配置
这偏离了spring本来简化开发的目的， 简化MVC三层架构开发的作用越来越弱，所以出现了springBoot，用于简化使用spring的时候对配置文件的配置
SpringBoot：新一代的Java EE开发标准，开箱即用(因为自动帮我们配置了很多的东西，所以可以开箱即用)
最大的特点就是"自动配置/装配"，所以SpringBoot的约定大于配置
注意：SpringBoot不是一个全新概念，它是为了简化现在使用起来越来越复杂的spring而诞生的，所以SpringBoot就是Spring的一个升级版
小结：传统的三层架构MVC用于将企业Java开发分层，各层之间子职责清晰，但是代码量庞大且冗余， 所以出现了spring，用于简化企业开发的代码，但是经过多年发展spring需要配置的文件越来越多，所以出现了springBoot，用于简化使用spring的时候对配置文件的配置
2.新的架构：微服务架构 1.为什么需要新的架构 但是SpringBoot本质终归还是在对原来的三层架构MVC的开发做简化，还是使用的传统的开发架构， 因为传统的开发架构本质就是All in one，即一个项目作为一个整体进行开发和部署，整个项目需要作为一个 整体部署在一台服务器上，当这一台服务器支持不了当前用户量的时候我们的解决办法就是"横向"的扩展服务器一台服务器不够就再加一台服务器，但是加上服务器之后就需要考虑负载均衡问题；说白了就是在服务器集群前面加一个程序，程序根据算法实现，用于保证后面的一大堆服务器被雨露均沾，不会出现一台服务器上的资源都要被耗光了，另一台服务器上的资源还没用的情况但是一旦出现了整个服务中的某一个模块需要升级改造，后果就是整个项目的所有服务停机，一般看到的就是"我们需要停机维护XXX的时间"，在这个期间，公司的服务器是停止向用户提供服务的，这对于用户体量很大，或者说国际化的公司来说是不能忍受的，因为停止服务就会出现客户流失的风险；除此之外还有很多其他的原因，比如可能我只需要这个项目中某一个模块的功能，但是为了正常运行我需要部署整个项目等所以为了解决这个问题，提出了新的开发架构 —— 微服务架构 2.什么是微服务架构 微服务架构，一个你没见过的传心版本，它的特点就是"模块化、功能化"微服务架构的本质：将原来的整体项目划分成多个功能模块，一个功能模块就可以独立运行提供服务比如现在我们需要开发一个管理系统，这个系统有用户模块、支付模块、签到模块…， 但是在实际的使用中，我们发现，用户和支付模块使用远高于签到模块；在微服务架构中我们就给用户和支付模块多一些服务器去支撑运行，给签到模块少一些服务器去支持它的运行；而按照原来MVC三层架构，不管你的签到功能使用的频率是多大，只要你部署服务，签到都要占用服务器一部分资源，多台服务器上被占用的资源累加起来可能就是好几台服务器的资源量，而实际用户的使用量一台服务器就能满足，这样看来原来的MCV三层架构不就是对于资源的一种浪费了吗？所有微服务架构势在必行 3.微服务架构的需要解决的问题 但是微服务架构就出现了新的问题，如果要使用复杂功能，那么各个模块/单独的项目之间怎么通信？怎么交互？这个是微服务架构中显而易见的问题，微服务架构中的问题可以分为如下的4类 微服务的四个核心问题？
服务很多，客户端怎么访问？
(怎么获取服务？设置注册中心，用户请求都发送到注册中心，再由注册中心分发用户请求到具体服务器)这么多服务，服务之间如何通信？(服务之间怎么通信？)这么多服务，如何管理？(对于这么多服务怎么统一管理？设置一个统一的服务管理平台，比如zookeeper)服务挂了怎么办？(服务器崩溃、断电之后怎么应对？熔断机制) 4.微服务架构问题解决办法/方案 微服务的四个核心问题的解决方案：
Spring Cloud 是一套生态！专门用于解决微服务的四个核心问题的生态学习SpringCloud的前提是学习SpringBoot，原因就是因为SpringCloud是基于SpringBoot的 1.SpringCloud NetFilx(第一套SpringCloud生态) NetFilx公司推出了一套解决SpringCloud生态，或者说一站式解决微服务架构中问题的方案，我们要使用直接拿来使用即可
问题1：服务很多，客户端怎么访问? API网关，实现统一服务治理，使用zuul组件 问题2：这么多服务，服务之间如何通信？ 网络通信都是基于HTTP的通信，NetFilx推出了一个自己对HTTP的包装版Feign(Feign基于HttpClient，HttpClient基于HTTP)，通信方式：同步并阻塞 问题3：这么多服务，如何管理？ 服务注册与发现，使用插件Eureka解决 问题4：服务挂了怎么办？ 熔断机制，Hystrix 但是2018年12月，NetFilx宣布无限期的停止对于SpringCloud NetFilx的维护，停止维护就会导致解决方案和当前技术的脱节，最大的隐患就是出现了新的安全问题，但是原来的解决方案没有应对机制，而安全是一个公司应该注重的根本，所以现在很多公司又不使用它了 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4919764915a5347117202a7b8430f233/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4caf7d4ab957337ec1bad8f61009e285/" rel="bookmark">
			NFS的安装和启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 网络文件系统（NFS：Network File System）是一种在网络上的机器间共享文件的方法，文件就如同位于客户的本地硬盘驱动器上一样。
二、NFS的安装 Ubuntu上默认是没有安装NFS服务器的，首先需要安装NFS服务程序 sudo apt-get install nfs-kernel-server sudo apt install nfs-common 修改配置文件 sudo vim /etc/exports 添加如下红方框里面的内容 重启NFS服务 sudo /etc/init.d/nfs-kernel-server restart 结果：[ ok ] Restarting nfs-kernel-server (via systemctl): nfs-kernel-server.service. 三、客户端访问服务器 用ifconfig查看服务器的地址
查看服务端的共享目录
将目录挂载到本地
sudo mount 192.168.10.10:/home /mnt 到这里本地的mnt目录就可以和服务端共享文件了。
四、实例 例：在本地mnt目录下创建file1，查看服务器端文件是否存在
普通用户可能对/home是没有写权限的，所以用sudo chmod 777 /home命令来更改权限。
可以看出，文件file1已经挂载到/home目录下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fce59870e05e4cb9d63d4244da1cfacd/" rel="bookmark">
			树莓派接入阿里云IOT平台1（Python模拟数据上传）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树莓派接入阿里云IOT平台1（Python模拟数据上传） 主要是通过Python脚本模拟两个数据（温度和相对湿度）上传到阿里云，非常简单，只要有一个树莓派 即可，不需要其他传感器，学习完本文章，下一章将搭载一些传感器进行实战，非常有趣。
云平台开发 注册阿里云账号 使用个人淘宝账号或手机号，开通阿里云账号，并通过实名认证(可以用支付宝认证)
注册产品与设备 找到物联网平台
1选择设备管理，2选择产品，3 选择快速入门
开始体验
填写产品名和设备名
设备平台选择Linux，设备连接协议选择MQTT，开发工具包这里我选择Node.js
其中三元组我们后面将在树莓派用到，SDK我们直接在树莓派上下载即可，所以这里的“下载Llinux工具包”我们不用管它。
点击完成即可，下面三个步骤我们先不管。
然后再回到产品管理界面，点击查看
点击功能定义，编辑草稿，设置自己产品的具体功能，在这里我们要收到树莓派传来的温度和相对湿度数据，所以我们得定义这两个功能，不然是接收不了的。
点击自定义功能
根据以下表格，添加温度和相对湿度两个功能
添加完后一定要点击发布
然后再回到产品管理界面，点击设备管理。
进入设备管理界面，点击设备查看
进入以下界面，点击右上角的查看，我们就可以查看三元组啦！等一下要用到
树莓派端开发 更改Python的版本 我们选用3.X以上的版本，具体2.X行不行好像官方也没说，他们是推荐使用3.X以上的版本的，这里我们在树莓派上修改一下，因为树莓派是默认使用2.X的版本的。
在终端运行以下命令
sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 100 sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 150 sudo update-alternatives --config python 然后我们就可以看到一个界面
可以输入0，1，2去选择Python的
我输入0，然后回车
然后在终端输入以下命令可查看python的版本
python 退出python的编译环境按下ctrl+d
以python3程序来模拟设备，建立连接，上报数据。 在桌面建立一个文件夹 aliyun-iot-demo-python
通过终端进入该文件夹,然后下载安装SDK
cd cd ./Desktop/aliyun-iot-demo-python pip install paho-mqtt #下载安装SDK 在aliyun-iot-demo-python文件夹内编写一个python脚本，这是官方的一个简单示例，我们需要填入我们的三元组，内容如下：
# -*- coding: utf-8 -*- import paho.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fce59870e05e4cb9d63d4244da1cfacd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/199f53f940ebe7f233b9f3a085a61a1f/" rel="bookmark">
			SpringBoot(36) —— Shiro快速开始
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.什么是Shiro2.Shiro的作用3.Shiro架构(外部)4.Shiro架构(内部)5.Hello World6.小结 1.什么是Shiro Apache Shiro 是 Java 的一个安全（权限）框架Shiro 可以非常容易的开发出足够好的应用，其不仅可以用在 JavaSE 环境，也可以用在 JavaEE 环境Shiro 可以完成：认证、授权、加密、会话管理、与Web 集成、缓存等下载地址 官网github 直接取GitHub上下载压缩包即可
2.Shiro的作用 Authentication:身份认证/登录，验证用户是不是拥有相应的身份Authorization:授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能进行什么操作，如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限Session Management:会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境，也可以是Web 环境的Cryptography:加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储Web Support:Web 支持，可以非常容易的集成到Web 环境Caching:缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率Concurrency:Shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去Testing:提供测试支持“Run As”:允许一个用户假装为另一个用户（如果他们允许）的身份进行访问Remember Me:记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了 3.Shiro架构(外部) 从外部来看Shiro，即从应用程序角度的来观察如何使用Shiro完成工作
Subject：应用代码直接交互的对象是Subject，也就是说Shiro的对外API 核心就是Subject。Subject 代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；与Subject 的所有交互都会委托给SecurityManager；Subject 其实是一个门面，SecurityManager才是实际的执行者
SecurityManager：安全管理器；即所有与安全有关的操作都会与SecurityManager交互；且其管理着所有Subject；可以看出它是Shiro的核心，它负责与Shiro的其他组件进行交互，它相当于SpringMVC中DispatcherServlet的角色
Realm：Shiro从Realm 获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm 得到用户相应的角色/权限进行验证用户是否能进行操作；可以把Realm 看成DataSource
4.Shiro架构(内部) Subject：任何可以与应用交互的“用户”；SecurityManager：相当于SpringMVC中的DispatcherServlet；是Shiro的心脏；所有具体的交互都通过- SecurityManager进行控制；它管理着所有Subject、且负责进行认证、授权、会话及缓存的管理Authenticator：负责Subject 认证，是一个扩展点，可以自定义实现；可以使用认证策略（Authentication Strategy），即什么情况下算用户认证通过了Authorizer：授权器、即访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能Realm：可以有1 个或多个Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是JDBC 实现，也可以是内存实现等等；由用户提供；所以一般在应用中都需要实现自己的RealmSessionManager：管理Session 生命周期的组件；而Shiro并不仅仅可以用在Web 环境，也可以用在如普通的JavaSE环境CacheManager：缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少改变，放到缓存中后可以提高访问的性能Cryptography：密码模块，Shiro提高了一些常见的加密组件用于如密码加密/解密 5.Hello World 按照官方doc只是，下载压缩包之后解压，并进入对应的文件夹
创建一个普通的maven项目：springboot-07-shiro老规矩：删除没有文件夹，把这个项目作为一个父项目，在它内部创建子model创建子model：hello-shiro直接打开例子中的pom.xml，将依赖导入子model，注意：按照使用最新版本原则，直接粘贴对应依赖去maven仓库中搜最新的，下面的都是最新的&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.6.0&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;java&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;classpathScope&gt;test&lt;/classpathScope&gt; &lt;mainClass&gt;Quickstart&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencies&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/199f53f940ebe7f233b9f3a085a61a1f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/92/">«</a>
	<span class="pagination__item pagination__item--current">93/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/94/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>