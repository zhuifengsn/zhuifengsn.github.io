<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bf5528dc696947a2f5bcd18cffe7db6/" rel="bookmark">
			Linux系统编程---进程I/O
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进程I/O C语言下的文件接口使用调用fwrite()函数--写入函数fread()读取文件 Linux 下的文件操作打开文件write函数 文件描述符。如何理解Linux下一切皆文件文件描述符的分配规则文件流指针FILE*与文件描述符的区别 重定向普通重定向追加重定向重定向的本质 缓冲区为什么要引入缓冲区？缓冲区归属常见的缓冲方式 理解文件系统理解目录 软硬链接软链接软链接文件的特性软链接的使用软链接的使用注意 硬链接硬链接的使用理解ll命令 动静态库静态链接与动态链接生成可执行文件为什么推荐使用动态链接动态链接实现本质动态链接与静态链接优缺点 实现动静态库静态库生成静态库静态库的使用 动态库动态库的生成测试动态库 C语言下的文件接口使用 C语言文件描述
示例：
这里实验两个。
调用fwrite()函数–写入函数 1#include&lt;stdio.h&gt; 2 #include&lt;string.h&gt; 3 #include&lt;stdlib.h&gt; 4 int main() 5 { 6 FILE *fp=fopen("1.txt","w"); 7 if(fp==NULL) 8 { 9 perror("create error"); 10 exit(1); 11 } 12 char buf[256]="hello world\n"; 13 fwrite(buf,strlen(buf),1,fp); 14 fclose(fp); 15 return 0; 16 } fwrite(buf,strlen(buf),1,fp); 为什么strlen不加1，
因为’\0’只是字符串中的描述符，与文件无关，加上可能会造成乱码的情况。
fread()读取文件 1 #include&lt;stdio.h&gt; 2 #include&lt;string.h&gt; 3 #include&lt;stdlib.h&gt; 4 int main() 5 { 6 FILE *fp=fopen("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bf5528dc696947a2f5bcd18cffe7db6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/614b0797dd14185387d11fef87e23582/" rel="bookmark">
			九种常用的UML图总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.前言
准备之后写一些设计模式的笔记，在这里先记录一下前置知识。
原文：
https://blog.csdn.net/u012500848/article/details/94490361
UML（Unified Modeling Language）统一建模语言，又称标准建模语言。是用来对软件密集系统进行可视化建模的一种语言。UML的定义包括UML语义和UML表示法两个元素。
UML是在开发阶段，说明、可视化、构建和书写一个面向对象软件密集系统的制品的开放方法。最佳的应用是工程实践，对大规模，复杂系统进行建模方面，特别是在软件架构层次，已经被验证有效。统一建模语言（UML）是一种模型化语言。模型大多以图表的方式表现出来。一份典型的建模图表通常包含几个块或框，连接线和作为模型附加信息之用的文本。这些虽简单却非常重要，在UML规则中相互联系和扩展。
UML图的作用：
UML的目标是以面向对象图的方式来描述任何类型的系统，具有很宽的应用领域。其中最常用的是建立软件系统的模型，但它同样可以用于描述非软件领域的系统，如机械系统、企业机构或业务过程，以及处理复杂数据的信息系统、具有实时要求的工业系统或工业过程等。总之，UML是一个通用的标准建模语言，可以对任何具有静态结构和动态行为的系统进行建模，而且适用于系统开发的不同阶段，从需求规格描述直至系统完成后的测试和维护。
特点：
（1）UML统一了各种方法对不同类型的系统、不同开发阶段以及不同内部概念的不同观点，从而有效的消除了各种建模语言之间不必要的差异。它实际上是一种通用的建模语言，可以为许多面向对象建模方法的用户广泛使用。
（2）UML建模能力比其它面向对象建模方法更强。它不仅适合于一般系统的开发，而且对并行、分布式系统的建模尤为适宜。
（3）UML是一种建模语言，而不是一个开发过程。
——以上引用自百度百科
下面是九种常用的UML图：
1.用例图（UseCase Diagrams）
用例图是从用户（角色）的角度出发，描述角色和用例之间的关系。即：谁要使用系统，一级他们使用系统可以做什么。简单来说就是：谁，可以用此系统做什么。
2.类图（Class Diagram）
类图是描述系统中的类，以及各个类之间的关系的静态视图。是面向对象系统建模中最常用和最重要的图，是定义其他图的基础。
在UML类图中，常见的有以下几种关系: 泛化（Generalization）, 实现（Realization），关联（Association），聚合（Aggregation），组合（Composition），依赖（Dependency）。
各种关系的强弱顺序： 泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖
2.1.泛化（Generalization）
泛化是一种继承关系，表示一般与特殊的关系，它指定了子类如何继承父类的所有特征和行为。
2.2.实现（Realization）
实现是一种类与接口的关系，表示类是接口所有特征和行为的实现。
2.3.关联（Association）
关联是一种拥有的关系，它使一个类知道另一个类的属性和方法；关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。
2.4.聚合（Aggregation）
聚合是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。
聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。
2.5.组合（Composition）
组合是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。
组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。
2.6.依赖（Dependency）
依赖是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖.
3.对象图（Object Diagrams）
对象图和类图一样反映系统的静态过程，但它是从实际的或原型化的情景来表达的。对象图显示某时刻对象和对象之间的关系。一个UML对象图可看成一个类图的特殊用例，实例和类可在其中显示。
4.状态图（Statechart Diagrams）
状态图描述类的对象所有可能的状态，以及事件发生时状态的转移条件。他们可以告知一个对象可以拥有的状态，并且事件会怎么随着时间的推移来影响这些状态。
状态图是对类图的补充。
5.活动图（Activity Diagrams）
活动图描述用例要求所要进行的活动，以及活动间的约束关系，有利于识别并行活动。能够演示出系统中哪些地方存在功能，以及这些功能和系统中其他组件的功能如何共同满足前面使用用例图的业务需求。
活动图是状态图的一种特殊情况，这些状态大都处于活动状态。本质是一种流程图，它描述了活动到活动的控制流。
6.序列图-时序图（Sequence Diagrams）
序列图是用来显示你的参与者如何以一系列顺序的步骤与系统的对象交互的模型。顺序图可以用来展示对象之间是如何进行交互的。序列图将显示的重点放在消息序列上，即强调消息是如何在对象之间被发送和接收的。
序列图展示的是多个系统或者对象之间的交互的顺序，强调时间顺序。
7.协作图（Collaboration Diagrams）
协作图和序列图相似，显示对象间的动态合作关系。可以看成是类图和顺序图的交集，协作图建模对象或者角色，以及它们彼此之间是如何通信的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/614b0797dd14185387d11fef87e23582/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/154c1158e8665093faa4bfe5f4e8069a/" rel="bookmark">
			计算机专业哪些竞赛含金量高,盘点国内五大高含金量的编程赛事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有不少家长询问：孩子已经学编程有段时间，有哪些编程赛事可以参加?哪些编程赛事含金量比较高，能对升学有帮助的?
今天，小编就为大家盘点国内五大高含金量的编程赛事，快收藏起来吧!
一、蓝桥杯青少年编程比赛
赛事介绍
蓝桥杯是目前编程教育领域最具知名度和影响力的竞赛之一。由工业和信息化部人才交流中心举办，主要面向包括清华、北大在内的超过1200所院校的大学生。
但蓝桥杯青少年创意编程组比赛则是蓝桥杯大赛专门面向中小学生设置的组别。为学习编程的孩子们提供考核平台和具有含金量的认定。
蓝桥杯大赛作为全国性考试，标准统一，具有权威性，被诸多优秀中学和大学认可的，最关键的是虽然蓝桥杯青少年创意编程组是面向中小学生的但是获奖证书的学生跟大学生组的证书有同等的权威性和高含金量。
2020年，蓝桥杯大赛被列入中国高等教育学会发布的“全国普通高校学科竞赛排行榜”，是高校教育教学改革和创新人才培养的重要竞赛项目。
含金量：四星
面向群体：6-18岁中小学生
升学帮助
1. 蓝桥杯青少年创意编程组比赛作为全国性考试，标准统一，具有权威性，被诸多优秀中学和大学认可的。
2. 获奖证书具有跟大学生组的证书同等的权威性和高含金量。
二、全国中小学电脑制作大赛
赛事介绍
全国中小学生电脑制作活动是由中央电化教育馆主办的官方比赛，从2000年开始举办，是一个十足的老牌赛事了。
含金量：四星
面向群体：小学、初中、高中在校学生
升学帮助
小升初时编程特长被多所知名学校认可，中考时校内保送推荐排名有加分，高考时可获名校自主招生名额。
(中小学电脑制作大赛的部分鼓励政策)
三、CSP-J/S
赛事介绍
CSP-J/S全称非专业级的软件能力认证，由CCF推出。
CSP-J/S其实是2019年CCF宣布NOIP暂停举办时推出的，可以将他看作是NOIP的替代赛事，而且难度并没有NOIP大，也是分两个级别，分别为CSP-J(入门级，Junior)和CSP-S(提高级，Senior)，认证内容均包括算法设计能力和编程能力。
其中我们可以将CSP-J看做NOIP普及组，CSP-S看做NOIP提高组。
含金量：四星
面向群体：所有人
升学帮助
中考：科技特长生，校内保送推荐排名有加分
高考：自主招生名额
注：CSP-J/S认证成绩优异者，可参加NOI省级选拔，省级选拔成绩优异者可参加NOI。
四、全国青少年信息学奥林匹克联赛
赛事介绍
全国青少年信息学奥林匹克赛作为五大奥赛之一，含金量想必大家都很清楚，是非常高的。在比赛中表现优异，获得奖项的学员们还可以参加全国决赛。
NOIP全国青少年信息学奥林匹克联赛由中国计算机学会统一组织。在同一时间、不同地点以各省市为单位由特派员组织。往期联赛分为普及组和提高组两个组别，难度不同，中小学生可以选择普及组，而高中生可以选择提高组。
这里不得不提一句。2019年8月16日，中国计算机学会(CCF)发布公告，由于某种原因，NOIP从2019年将暂停。而2020年9月11日，官方又发出将恢复NOIP竞赛。
含金量：四星
面向群体：高中生、人数有限(约1万人)
升学帮助
中考：科技特长生，校内保送推荐排名有加分;
高考：强基计划高校降分录取，即获得信息学全国中学生学科奥林匹克竞赛全国决赛二等奖(含)以上成绩的考生，高考成绩达到所在省份本科一批录取最低控制分数线(合并录取批次省份以各省划定分数线为准)可入围相应省份的强基计划考核。
注：NOIP 中成绩优秀的非高三选手，可以作为省代表队成员参加全国决赛(NOI)及夏令营比赛(部分省市代表队人员须经过选拔赛决出)。NOIP 获奖选手同样具有保送资格，并且成绩优秀的选手能够当场获得高校点招，免试进入名牌大学。
五、全国青少年信息学奥林匹克竞赛
赛事介绍
提到“高含金量”的编程类赛事，NOI必须拥有姓名。
同样是全国青少年信息学奥林匹克赛事，NOI相比于NOIP来说要高一级，如果将NOIP比作预赛和复赛，那么NOI就是决赛了。
全国青少年信息学奥林匹克竞赛(NOI)是国内包括港澳在内的高含金量的比赛，由中国计算机学会举办。参赛队伍都是经过各省选拔产生的，并将选手划分为五类。其中前三类可以参加正式比赛，后两类虽不能参加正式比赛但可以将参加同步举办的夏令营。NOI会从正式选手中选出前50名，作为中国国家集训队，而集训队队员都可获得高校报送资格。
NOI竞赛相较于其他的比赛来讲，有一点非常特别，省赛代表队必须有一名女同学，如果没有，只能空着，不能由男孩子顶替，而且特设“最佳女选手奖”。这里小码酱就要说一句：学编程的女孩子们，冲鸭!
而NOI是否获奖，也关乎着亚洲与太平洋地区信息学奥赛(APIO)和国际信息学奥林匹克竞赛(IOI)的参赛资格。
含金量：四星
面向群体：初中-高中
升学帮助
中考：科技特长生，校内保送推荐排名有加分。
高考：进入中国国家集训队，集训队队员将获得清华北大的保送资格。其余获奖选手还可参加79所985、211高校自主招生报名(高考加5-30分)。
以上就是小编为大家整理的五大高含金量的编程赛事了!家长们可以根据年龄段，给孩子选择合适的赛事。
随着编程教育的普及，编程赛事也是越来越多了，含金量也是越来越高了，但是小编还是想强调一下学习编程是为了让孩子在未来拥有更多竞争力。对于中小学生来说，比赛是一个竞技场，但更是展示、交流以及学习的平台，而不是我们学习编程的目的。
参与竞赛，孩子们在获得奖项的同时，更多的是获得参赛的经验和感受，以及依靠自己的思考和学以致用，在压力环境下也依然能够发挥自我的自信和勇气。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98bc0f4f0db0aad7d7aa341b5981ae1b/" rel="bookmark">
			为什么你的“点击”不生效？！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此文章来源于项目官方公众号：“AirtestProject”
版权声明：允许转载，但转载必须保留原链接；请勿用作商业或者非法用途
前言 今天跟同学们来聊一聊点击不生效这个问题，经常听到答疑群里面有同学说：为什么我的代码执行了，但实际上没有发生点击的动作呢？又或是，为什么我用IDE连接上了设备，却不能点击手机画面呢？
下面我们就来看下，当同学们遇到各种“点击不生效”的情况时，究竟该如何排查。
“点击不生效”的排查办法 1. 检查是否使用了最新版本 ① 使用AirtestIDE自带的环境 查看当前IDE的选项–设置里面，是否自定义了python.exe的路径，如未设置，则只需要检查当前的AirtestIDE是否为最新版本即可，不是最新版本的话，先将其更新到最新版本：
② 使用了本地python环境 如自定义了python.exe的路径，则表示当前未使用AirtestIDE自带的环境，而是使用了自定义的本地python环境，则需要检查自定义python环境里面的airtest库是否为最新版本，如不是最新，也请把airtest库更新到最新版。
我们可以在命令行运行 pip list 查看（如本地存在多个python环境，则需要特别注意区分自己使用的是哪个）：
命令行运行或者其它python编辑器运行的情况同理，需要检查当前运行环境里面装的airtest库是否为最新版。
2. 尝试在IDE里面看看能否点击手机画面 ① 能点击 则排除手机设置的问题。
② 不能点击 特别注意部分品牌手机需要开启“允许模拟点击位置”此类的选项，详情可查看官方文档：https://airtest.doc.io.netease.com/IDEdocs/device_connection/2_android_faq/#2 。
3. 单独写一个脚本，只运行点击不生效的那条语句，运行后生成报告 这里是使用最小可复现脚本的办法，排除其它代码的干扰，能更快速定位到问题：
① log查看窗出现了报错 如出现类似 Picture xxx not found in the screen 的报错，则表明截图识别失败了，我们需要重新截图；比如说截取特征更加明显的截图，减少混入多余的背景等等，关于如何提高截图脚本的兼容性，我们也在之前的推文 “写了10000条Airtest截图脚本总结出来的截图经验，赶紧收藏！” 有详细介绍，有需要的同学可以直接前往阅读。
如出现类似 PocoNoSuchNodeException: Cannot find any visible node by xxx 的报错，则表明查找控件失败，需要检查控件的定位方式是否正确，当前页面是否存在此控件等。
② 没报错，但查看报告发现点到了错误的位置 多出现于截图脚本：
一种情况是，当前页面存在多个相同的截图，实际运行时没有点击到你的真实目标上面，此时可以通过局部识图、或者调整截图的 target_pos来辅助你定位到你的真实目标上面。
另外一种情况是，识别到了毫不相干的错误的目标上，有可能是图像阙值比较低，混入了错误的结果，可以尝试调整阙值过滤错误的结果。
③ 没报错，但查看报告发现点击出现了一定的位置偏移 常出现于Poco控件点击脚本中：
首先我们可以借助IDE辅助窗的检索控件功能，把鼠标移动到对应的控件上面，看看锁定控件的框框是否出现了偏移，如出现了偏移，我们可以通过一些偏移修正，或者去掉手机的虚拟按键栏来解决，详见我们的官方教程文档： https://airtest.doc.io.netease.com/IDEdocs/device_connection/2_android_faq/#_9 。
④ 查看报告发现画面未加载完毕就进行了点击 当画面未加载完全或者不够稳定的情况下，我们立即进行了点击操作，很可能出现点击操作确实执行了，但应用没能响应这个点击的情况。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98bc0f4f0db0aad7d7aa341b5981ae1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef9a4524d96cb3ae69abccb1ff8d554b/" rel="bookmark">
			Linux系统编程篇--进程控制篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进程控制篇 了解fork()函数什么是子进程fork()基本用途fork()失败原因 了解写时拷贝概念两种方式 进程退出进程退出情况查看进程退出码进程常见的退出方法回调函数exit()函数和_exit()函数区别 刷新缓冲区进程等待进程等待的必要性进程等待，wait()函数waitpid()根据进程退出码判断进程退出情况？ 进程替换替换函数execlexeclpexelceexecveexecvexecvp 六个替换函数的关系替换原理进程替换的常见使用场景 了解fork()函数 在linux中fork函数时非常重要的函数，它从已存在进程中创建一个新进程。新进程为子进程，而原进程为父进程。
头文件：
#include&lt;unistd.h&gt;
pid_t pd=fork();
返回值类型：
子进程中返回0，父进程返回子进程的pid，失败返回-1；
什么是子进程 子进程是以父进程为“模板”生成的一个新进程
系统调用fork，内核中做了什么？
1.分配新的内存块和内核数据结构给子进程
2.将父进程部分数据结构内容拷贝至子进程
3.添加子进程到系统进程列表当中
4.fork返回，开始调度器调度
fork()基本用途 1.一个父进程希望复制自己，使父子进程同时执行不同的代码段。例如，父进程等待客户端请求，生成子进程来处理请求。
2.一个进程要执行一个不同的程序。例如子进程从fork返回后，调用exec函数。
fork()失败原因 1.系统中有太多的进程
2.实际用户的进程数超过了限制
了解写时拷贝 通俗点来说，就是什么时候修改，什么时候再进行拷贝。
概念 操作系统通过fork创建子进程之后，子进程复制了父进程，一开始父子进程指向同一块物理内存空间，因此数据看起来是一模一样的。但是进程间具有独立性，因此当物理空间的数据发生改变时，子进程就会重新开辟物理空间，将数据拷贝过来。这就是写时拷贝技术。因为代码是只读的，因此父子进程数据独有，代码共享。 (当物理空间数据发生改变时)
两种方式 对数据不做修改的情况下
对数据做出修改
进程退出 进程退出情况 1.代码运行完毕，结果正确
2.代码运行完毕，结果不正确
3.代码异常终止
查看进程退出码 echo $?
进程常见的退出方法 1.main()函数return退出。
1 #include&lt;iostream&gt; 2 using namespace std; 3 int main() 4 { 5 cout&lt;&lt;"hello Linux"&lt;&lt;endl; 6 return 21; 7 } 可以看到我们的退出码 (main函数的return值为退出码)为21。
说一下为什么我们main()函数的退出码为什么是0？
一般在编程中，我们一般认为0是程序正确执行的返回值，通过返回值的不同确定错误的类型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef9a4524d96cb3ae69abccb1ff8d554b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01d993a924c4cb37342889ae31b03fff/" rel="bookmark">
			pywinauto-PC端应用程序自动化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 环境安装 自动化切入点 工具（使用显示的更详细的工具的方式） 用来解析应用程序的控件
打开指定应用程序 连接已打开的应用程序 选择指定的窗口 窗口的操作方法 窗口控件的操作方法 推荐方式二+方式三
窗口控件属性的获取 窗口/控件截图 菜单控件的相关操作 推荐，可以跨层级选择
等待 timings模块 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/231fe636b741229061dd6e6b311311b9/" rel="bookmark">
			Linux地址空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux地址空间 进程地址空间进程地址空间是内存地址吗？ 什么是地址空间地址空间提出的原因？地址空间是怎么工作的？接下来深刻理解一下什么是进程地址空间的三种映射页表映射段表映射段页式内存管理 进程地址空间 进程地址空间是内存地址吗？ #include&lt;iostream&gt; #include&lt;unistd.h&gt; using namespace std; int g_val=100; int main() { cout&lt;&lt;"this is my process"&lt;&lt;endl; pid_t pd=fork(); if(pd&lt;0) { cerr&lt;&lt;"failed"&lt;&lt;endl; } else if(pd==0) { g_val=1000; cout&lt;&lt;"i am son"&lt;&lt;"my val is"&lt;&lt;g_val&lt;&lt;" my address "&lt;&lt;&amp;g_val&lt;&lt;endl; } else { sleep(2); cout&lt;&lt;"i am father"&lt;&lt;"my val is"&lt;&lt;g_val&lt;&lt;" my address "&lt;&lt;&amp;g_val&lt;&lt;endl; } return 0; } 实验结果：
结论：地址空间绝对不是数据存储的真实物理地址。它是一段虚拟地址。最终一定要以某种方式转化为物理地址。
由此可知，我们在任何情况下打印出来的地址都是虚拟地址，而不是其真实物理地址。
什么是地址空间 地址空间就是一个结构体，通过结构体将我们所虚拟化出的栈、堆、数据段、代码段等组织起来的一个结构体
其中进程的PCB中含有该结构体(mm_struct),因为内存的分配是离散分配的，所以我们不得不让该结构体将数据组织起来。
解释一下：为什么两个不一样的数据其地址是相同的？
1.因为子进程要拷贝父进程的PCB，所以它们是相同的。
2.因为子进程在执行时对全局变量g_val进行了修改，此时它们虽然看起来地址是一样的，但在物理内存中，一定存在额外的物理地址去存储子进程的数据。这是进程独立性的特点。
接下来回答一下到底什么是地址空间：
地址空间，是对物理内存的一段虚拟化表示，虚拟地址一定要通过某种映射关系将其转化为物理地址。 通常有页表、段表、段页式结合，来将其变为物理内存的地址，后面阐述。
地址空间提出的原因？ 如果没有地址空间的话，我们访问的永远都是真实的物理地址，会有两个弊端。
1,保护内存。如果直接对物理内存进行操作的话，则有可能会对操作范围之外的数据进行错误的操作，比如野指针等概念。
2.数据在内存中的存储是离散分配的，如果采用直接访存的话，非常的不方便，增加了越界访存的概率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/231fe636b741229061dd6e6b311311b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46eb24066160b85cccfbc990e9070a21/" rel="bookmark">
			9.PyTorch实现MNIST（手写数字识别）（2卷积1全连接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 写在前面 0.1 流程图 0.2 文中代码解释 1、torch.nn.Conv2d(1,10,kernel_size=3,stride=2,bias=False)
1是指输入的Channel，灰色图像是1维的；10是指输出的Channel，也可以说第一个卷积层需要10个卷积核；kernel_size=3,卷积核大小是3x3；stride=2进行卷积运算时的步长，默认为1；bias=False卷积运算是否需要偏置bias，默认为False。padding = 0，卷积操作是否补0。 2、self.fc = torch.nn.Linear(320, 10)
这个320获取的方式，可以通过x = x.view(batch_size, -1)print(x.shape)可得到(64,320),64指的是batch，320就是指要进行全连接操作时，输入的特征维度。 0.3 注意事项 卷积(线性变换)，激活函数(非线性变换)
1 prepare dataset import torch from torchvision import transforms from torchvision import datasets from torch.utils.data import DataLoader import torch.nn.functional as F import torch.optim as optim # prepare dataset batch_size = 64 transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize((0.1307,), (0.3081,))]) train_dataset = datasets.MNIST(root='./资料/data/mnist/', train=True, download=True, transform=transform) train_loader = DataLoader(train_dataset, shuffle=True, batch_size=batch_size) test_dataset = datasets.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46eb24066160b85cccfbc990e9070a21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed3554977e1bace51388d2fd4f5bfbf3/" rel="bookmark">
			AirTest-Selenium脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17bea328da63f1662928a145151d7f0f/" rel="bookmark">
			AirTest-Poco脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06280b193933b3e8167b545f292495a1/" rel="bookmark">
			Linux 系统编程 -进程概念篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux系统编程-进程篇 冯诺依曼体系结构冯诺依曼的两个重要思想当代计算机的三级缓存 操作系统操作系统的概念操作系统的组成操作系统作用Linux下的操作系统体系 进程进程概念进程特性进程的组成进程与程序区别进程控制块 Linux下的底层下的组织明确Linux操作系统底层Linux底层管理进程的结构体(描述)从操作系统内核的结构看进程(组织)查看进程命令进程号通过进程调用获取进程标识符通过系统调用来创建进程fork()命令1.如何理解进程创建2.fork()为什么会有两个返回值？写时拷贝技术 3.fork()父子的执行顺序和代码和数据的复制问题？4.子进程是从fork之前还是fork之后开始运行？*** Linux下查看进程的ps命令Linux环境下的几种状态R状态--运行状态S状态 --睡眠状态，可中断的D状态 ---磁盘休眠状态。T状态--暂停状态X状态 --死亡状态孤儿进程孤儿进程的概念。孤儿进程的产生条件 Z状态，僵尸进程***僵尸进程的危害？为什么要提出僵尸进程的概念解决方案为什么会产生僵尸进程？ 解释一下什么是前台程序和后台程序 环境变量--重点什么是环境变量环境变量的分类系统级的用户级的 使用echo查看环境变量内容常见的环境变量查看所有的环境变量env命令修改环境变量临时修改 使用命令永久修改 --用户级别的（针对当前用户） 环境变量的加载顺序环境变量的组织格式main()函数的几大参数通过第三方变量environ获取获取特定环境变量和修改环境变量getenvputenv()函数 进程优先级区分一下优先级与权限的问题查看系统进程的优先级数PRI与NI修改进程的PRI进程优先级的一些注意 进程状态转换问题结语 冯诺依曼体系结构 这里的存储器是内存，一般情况下内存不直接与外存打交道，而是通过缓存先将输入/输出 输出到寄存器中，再由寄存器与外存做交互。
当代典型的输入设备：键盘、鼠标、扫描仪、写板等
输出设备：显示器、打印机等。
冯诺依曼的两个重要思想 1.所有数据均采用二进制存储（契合电路，高低电平的特点）
2.数据都保存在存储器中(内存中)
当代计算机的三级缓存 三级缓存与高速缓存(cache)
首先必须明确三级缓存均属于高速缓存
一级缓存：一级缓存通常设置在cpu内部，但是比起寄存器来说还是远一点，因为其放在cpu内部，所以它的空间是很小的，通常为8-16k
二级缓存：二级缓存在CPU之外，因为主板上的空间很大，所以二级缓存比一级缓存大得多，大概是256KB-1MB左右，但是它的速度慢，因为它离CPU比较远。二级缓存通常用作一级缓存与内存的交换空间
三级缓存：其空间更大，但是相应的离cpu也越来越远。
所以从远及近看 CPU〈------〉寄存器〈----》缓存《-----》内存。
缓存中的数据是可以提升的？
比如初始情况下，一个数据位于三级缓存中，但是因为经常使用，所以它会被提升到二级缓存甚至一级缓存，这块很好理解，经常用cpu就让该数据离它更近点。
为了保证CPU访问时有较高的命中率，Cache中的内容应该按一定的算法替换。一种较常用的算法是“最近最少使用算法”（LRU算法），它是将最近一段时间内最少被访问过的行淘汰出局。因此需要为每行设置一个计数器，LRU算法是把命中行的计数器清零，其他各行计数器加1。当需要替换时淘汰行计数器计数值最大的数据行出局。这是一种高效、科学的算法，其计数器清零过程可以把一些频繁调用后再不需要的数据淘汰出Cache，提高Cache的利用率。
LRU为操作系统中提供的算法。
操作系统 操作系统的概念 操作系统时配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。其主要作用是管理好这些设备，提高它们的利用率和系统的吞吐量，并为用户和应用程序提供一个简单的接口，便于用户使用。
硬件：冯诺依曼中的所有设备
软件:安装软件、卸载软件、升级软件
在系统层面：文件、进程、驱动等
操作系统的组成 操作系统=操作系统内核+一堆应用
操作系统内核：代表某种操作系统的代码的统称。
操作系统作用 操作系统是管理当前设备的软硬件资源的软件。
管理：先描述，再组织。
这块管理：管理不是像宿管阿姨管理一个宿舍那样，更像是一个leader(校长)，操作系统具有**“决策权”**。
对上：给用户一个稳定高效的执行文件。
对下：管理好软硬件资源，提供稳定的软硬件资源。
这里还是以学校举例：把学生比作硬件的话，那么宿管就相当于是驱动程序，而操作系统位于驱动程序之上，等于说驱动程序只是按照操作系统的命令去做事而已。这便是真正的管理者。作为一个leader，统筹全局。
Linux下的操作系统体系 进程 进程概念 进程：进程是程序的一次执行，是系统进行资源分配和调度的一个独立单位。
进程特性 1.动态性。由创建而产生，由调度而执行，由撤销而消亡。
2.并发性。是指多个进程实体同时存在于内存中，且能在一段时间内使进程实体和其他进程实体同时执行。(在不同的时间点，交给处理及处理。在同一时间点，任务不会同时进行)。
这块解释一下并发与并行区别：
并发性：在一个处理机上，宏观上有多个进程同时执行的效果，但在微观上，并不是同时执行，只是把时间分为若干段，（类似于时间片轮转算法），使多个进程轮流交替的运行。
并行性：指在同一时刻，多个处理机同时处理不同的任务(进程)。
3.独立性：进程是一个能独立运行，独立获得资源和独立接受调度的基本单位。前提：建立PCB情况下。
4.异步性：进程按独立的，不可预知的速度向前推进。
进程的组成 进程=程序段+数据段+进程控制块(PCB)（PCB常驻内存）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06280b193933b3e8167b545f292495a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f9ea8c91879c0c14d58282bcb4d77fa/" rel="bookmark">
			【WPF】绘图--《深入浅出WPF》by刘铁锰
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WPF的基本图形包括以下几类（都是Shape类的派生类）：
Line：直线段，可以设置其笔触（Stroke）Rectangle：矩形，既有笔触，又有填充（Fill）Elippse：椭圆。既有笔触，又有填充Polygon：多边形。既有笔触，又有填充Polyline：折线（不闭合），多条收尾相接的直线段组成Path：路径（闭合区域），可由若干直线、圆弧、贝塞尔曲线等基本元素组成 1、直线 直线是最简单的图形，使用X1，Y1两个属性设置起点坐标，使用X2，Y2两个属性设置终点坐标。Stroke属性的数据类型是Brush，凡是Brush的派生类都可以用于为这个属性赋值。
使用各种画刷填充矩形的综合实例：
&lt;Window x:Class="Demo.MainWindow" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:d="http://schemas.microsoft.com/expression/blend/2008" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:local="clr-namespace:Demo" mc:Ignorable="d" Title="MainWindow" Height="260" Width="280"&gt; &lt;Grid&gt; &lt;!--Stroke:边框绘制方式，默认值为null--&gt; &lt;Line X1="10" Y1="20" X2="260" Y2="20" Stroke="Red" StrokeThickness="10"/&gt; &lt;Line X1="10" Y1="40" X2="260" Y2="40" Stroke="Red" StrokeThickness="5"/&gt; &lt;!--StrokeDashArray：虚线轮廓和间隙的模式--&gt; &lt;Line X1="10" Y1="60" X2="260" Y2="60" Stroke="Yellow" StrokeThickness="5" StrokeDashArray="3"/&gt; &lt;Line X1="10" Y1="80" X2="260" Y2="80" Stroke="Yellow" StrokeThickness="3" StrokeDashArray="5"/&gt; &lt;!--StrokeEndLineCap：获取或设置线的末端，默认值Flat StrokeDashCap：获取或设置线的末端，默认值Flat--&gt; &lt;Line X1="10" Y1="100" X2="260" Y2="100" Stroke="orange" StrokeThickness="10" StrokeEndLineCap="Flat"/&gt; &lt;Line X1="10" Y1="120" X2="260" Y2="120" Stroke="orange" StrokeThickness="10" StrokeEndLineCap="Round"/&gt; &lt;Line X1="10" Y1="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f9ea8c91879c0c14d58282bcb4d77fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a5b667a1279c0aed4cf28814364d199/" rel="bookmark">
			【天池】心跳信号分类预测 最后的一堂课 part4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 依赖安装和导入2. 数据加载与预处理3. 数据探索性分析3.1 基本分析3.2 查看类别分布 4. 辅助函数评估函数5. 模型训练与推理 (TensorFlow 2.2+)5.1 Net 15.2 Net 35.3 Net 8 6. 软投票融合 + 阈值法7. 保存结果用于提交8. 后话 写在前面：
这比赛也跟着各位大佬打了一遍，可惜的是当初使用的是传统的机器学习模型，并没有使用CNN这种深度学习框架，但是在这过程中也学习到好多——列如各样特征技巧、处理技巧！
从结束的那天起，就好像看前几名的关键方案了
碎碎念——》终于出来了
让我们跟着大佬的思路学一波
这也是我对这场比赛最后的一个交代吧！
1. 依赖安装和导入 import os import math import time import random import datetime import numpy as np import pandas as pd import seaborn as sns import matplotlib.pyplot as plt import tensorflow as tf import tensorflow.keras as K from tensorflow.keras import Sequential, utils, regularizers, Model, Input from tensorflow.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a5b667a1279c0aed4cf28814364d199/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4571de71cc39df9b7c8b7a2d07db520a/" rel="bookmark">
			MybatisPlus实现联表分页查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MybatisPlus实现联表分页查询 在开发中遇到了一个问题，需要进行联表查询并进行分页，因为不想自己来写分页，所以还是依靠MybatisPlus来实现想要的功能。
首先我们有一个需求，是想根据产品表sys_product中的factory_id来获取工厂表sys_factory中的工厂信息，而且要实现分页查询。
产品表 sys_product
工厂表sys_facotry
在ProductMapper中我们自定义一个page方法，通过@Select注解来执行联表查询的sql，接受两个参数，一个Page分页参数，一个QueryWrapper查询参数。
@Repository public interface ProductMapper extends BaseMapper&lt;Product&gt; { String wrapperSql = "select p.id,p.product_name,p.product_img_url,p.factory_id,f.factory_name from sys_product p left join sys_factory f on p.factory_id = f.id ${ew.customSqlSegment}"; @Select(wrapperSql) Page&lt;Product&gt; page(Page page, @Param("ew") Wrapper queryWrapper); } 在ProductService接口中定义一个查询的方法，接受查询相关的参数，如当前页，页容量，模糊查询相关的数据等。
public interface ProductService extends IService&lt;Product&gt; { Page&lt;Product&gt; getProductList(ProductPageVo productPageVo); } 在ProductServiceImpl中调用ProductMapper中我们写的page方法，传入Page和QueryWrapper参数
@Service public class ProductServiceImpl extends ServiceImpl&lt;ProductMapper,Product&gt; implements ProductService { public Page&lt;Product&gt; getProductList(ProductPageVo productPageVo){ String productName = productPageVo.getProductName(); QueryWrapper&lt;Product&gt; productQueryWrapper = new QueryWrapper&lt;&gt;(); if (Strings.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4571de71cc39df9b7c8b7a2d07db520a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd257f4a1b549bba6a5778a0c7a63293/" rel="bookmark">
			页面置换算法之CLOCK算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中文名：时钟置换算法
以下是作者对CLOCK算法的肤浅见解，如有错误之处，欢迎指出，十分感谢！
定义 时钟置换算法可以认为是一种最近未使用算法，即逐出的页面都是最近没有使用的那个。它和LRU算法有类似之处，只不过clock算法会有一个用于记录访问次数的数组，然后再根据第一个最小访问次数来进行替换处理，当访问到缓存中的页面时，访问次数有限制的加1，不改变队列顺序，替换是原位替换，如4，5，6，访问到页面2。如果访问次数6比4和5要多1且4和5访问次数相等，那么替换后的队列为4，2，6。
这里想给大家一个实例演示的，不过仔细想想，可能运行结果会更加直观一些。
C语言代码 #include&lt;stdio.h&gt; #define MAX 3//缓存最大页面容量 typedef struct clock{ int clock[MAX];//存放页面号 int sign[MAX];//存放访问次数，初值为0 }CLOCK; int compare( int a[MAX] )//作用是看任意两个页面的访问次数有没有相同，有则返回1；否则，返回0 。 { int s = a[0],d = 0; for(int i = 0; i &lt; MAX; i++) { for(int j = i; j &lt; MAX-1; j++) { if(a[i] == a[j+1]) d=1; } } return d; } int	Min( int a[MAX] )//作用是返回缓存中最小的页面号 { int min; min = a[0]; for(int i = 1; i &lt; MAX; i++) { if(min &gt; a[i]) min = a[i]; } return min; } int	Max( int a[MAX] )//作用是返回缓存中最大的页面号 { int max; max = a[0]; for(int i = 1; i &lt; MAX; i++) { if(max &lt; a[i]) max = a[i]; } return max; } int	i_value( int a[MAX] )//作用是返回缓存中最小的页面号的地址 { int ivalue,temp = 0; ivalue = a[0]; for(int i = 1; i &lt; MAX; i++) { if(ivalue &gt; a[i]) { ivalue = a[i]; temp = i; } } return temp; } int	I_value( int a[MAX] )//作用是返回缓存中最大的页面号的地址 { int Ivalue,temp = 0; Ivalue = a[0]; for(int i = 1; i &lt; MAX; i++) { if(Ivalue &lt; a[i]) { Ivalue = a[i]; temp = i; } } return temp; } int main() { int flag = 0;//0表示访问的这个页面是一个新页面，1表示访问的这个页面已存在于缓存中 int data;//页面号 int mid = 0;//充当中间变量，暂时缓存一个值 clock c; for(int i = 0; i &lt; MAX; i++) { c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd257f4a1b549bba6a5778a0c7a63293/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c55431c3ef09155decc737d7601eb1b/" rel="bookmark">
			关于Linux下的一点补充
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇博客是基于Linux工具的使用所作的一些补充
1.Linux的联想搜索(ctrl+r)在命令行操作
2.vim底下的替换模式(类似于normal模式下的cw操作)
在normal模式下按下shift+r进入替换模式，逐字符进行替换。
3.明确一句话。
Linux下默认生成的可执行程序是动态链接的且以release发布的。
4，readelf命令，一般用于查看ELF格式的文件信息，常见的文件如在Linux上的可执行文件，动态库(.so)或者静态库(.a) 等包含ELF格式的文件。
这里只介绍一个选项。是为了验证debug版本与release区别：
test1为release版本，默认情况下不含有debug文件，而test为debug版本，在它目录底下是含有调试文件的
5.gdb下的监视窗口
在vs底下，我们可以通过调试–打开监视器的方式实现对某一变量值的跟踪，查看，在gdb下，也存在这样的命令，这个命令便是display命令
注：只有在运行到你要查看函数的时候，再按s(逐语句)。要不会出错。
首先看一下我们的源文件与makefile文件
可以看到每步执行完后均可看到result和i的值。
怎么取消监视呢？
undisplay+监视号
6.until+行号(这里的行号是你想要程序走到的行号)，但并不一定是刚行号，因为程序默认执行到有效语句(除过}或者空行会直接跳过)
7.删除断点
d为删除所有断点，d+断点号 Num底下的号 删除单个断点
8、从一个断点到下一个断点(c /continue)
9.finish 命令
目的：结束当前运行的函数，并跳出它。用来从上往下检测函数是否运行正常。（定位问题）
10.利用重定向来清空文件
11. 设置makefile命令不回显
12.伪目标(.PHONY)
1.伪目标后面跟的全是伪目标
2.伪目标是可以被重复执行的
13.Linux下的多文件编程实现（写一个简易的计算器）
vs+文件名(多文件展开)
makefile version1
测试：
makefile version2：
效果图：
makefile version3
总计完这些已经很晚了，其实Linux总结到这里估计刚算入门吧，在写这篇博客之前，还发了许多Linux入门的东西，比如命令，权限，Linux工具的使用。总之，Linux的学习是任重而道远的，愿我们前行路上共勉！下课！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b78d0a9275deb2b8db710628772f7df/" rel="bookmark">
			为什么html中图片显示不出来,网页图片不显示怎么回事？网页图片不显示的解决方法...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在网页上有文字和图片组成一些文章、新闻，如果出现网页图片不显示的情况，就会影响我们的使用感受。可能有些不熟悉电脑的用户不知道怎么处理这种情况，所以今天本文为大家整理的就是网页图片不显示的解决方法。
解决方法如下：
解决方法一：IE设置图片显示
1、先打开IE浏览器然后，点击右上角的设置图标，选择internet选项。
2、高级——显示图片前面打勾，确定就可以了。
第二种原因和解决方法
1、网站网速太慢或是浏览用户过多导致拥挤
2、网页本身的问题图片丢失；
3、浏览器有问题
如果上别的网页正常，那说明这个网页的图片链接有问题。
如果上别的网页所有的都打不开，说明浏览器有问题，进浏览器设置重置下浏览器。或者用瑞星卡卡助手或者360修复下浏览器。或者下载安装一个别的浏览器。
如果你的网速太慢那你就多刷新几次就出来了~
再给你个简单一点的，进入360安全卫士——系统修复(修复一下}——不行的话，电脑门诊——上网异常——网页图片，显示不正常，经常显示不全或根本不显示(倒数第三条)——点此解决
关于网页图片不显示的解决方法就为大家分享到这里啦，有出现同样情况的可以按照上面的方法来解决哦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cd12028331c7b89481dbe3ea58101a2/" rel="bookmark">
			Linux工具的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux工具的使用 软件包管理器(yum)什么是yum，有什么作用？ Linux编辑器，vim的使用安装一个适合程序员的vim代码编辑器vim的配置vim下的三种模式正常模式（Normal mode）下的一些操作末行（底行）模式下的操作 gcc/g++使用什么是gcc/g++？程序编译的四阶段 Linux下的调试Linux下的debug版本与release版本Linux下的gdb命令（调试命令） Linux下makefile文件的书写什么是make，什么是makefilemakefile文件书写makefile的使用规则makefile文件下的伪命令makefile文件的批量化注释makefile文件下的所有依赖对象与目标对象写法 git工具的使用 软件包管理器(yum) 什么是软件包
在Linux下安装软件, 一个通常的办法是下载到程序的源代码, 并进行编译, 得到可执行程序.
但是这样太麻烦了, 于是有些人把一些常用的软件提前编译好, 做成软件包(可以理解成windows上的安装程序)放在一个服务器上, 通过包管理器可以很方便的获取到这个编译好的软件包, 直接进行安装.
软件包和软件包管理器, 就好比 “App” 和 “应用商店” 这样的关系.
yum(Yellow dog Updater, Modified)是Linux下非常常用的一种包管理器. 主要应用在Fedora, RedHat,Centos等发行版上.
什么是yum，有什么作用？ yum是包管理器。yum的作用包括查找、安装、卸载。
yum的查找：
yum list 是获取软件商店中所有的软件 | 管道 grep lrzsz 匹配与关键字相同的软件
软件包名称: 主版本号.次版本号.源程序发行号-软件包的发行号.主机平台.cpu架构.
“x86_64” 后缀表示64位系统的安装包, “i686” 后缀表示32位系统安装包. 选择包时要和系统匹配.
“el7” 表示操作系统发行版的版本. “el7” 表示的是 centos7/redhat7. “el6” 表示 centos6/redhat6.
最后一列, base 表示的是 “软件源” 的名称, 类似于 “小米应用商店”, “华为应用商店” 这样的概念
yum 安装
因为软件的安装需要使用到root权限，所以此时有两种方式，一个是sudo暂时提升用户权限，一种是su ，先进入root ，直接安装
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cd12028331c7b89481dbe3ea58101a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/287a69e33a655db191e519dbd4435c46/" rel="bookmark">
			卡片效果html css3,三种CSS实现的卡片效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.polaroid {
width:250px;
box-shadow:0 4px 8px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);
text-align:center;
display:inline-block;
background-color:#FFF;
}
.container {
padding:10px;
}
/*文字卡片*/
.card {
width:250px;
box-shadow:0 4px 8px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);
text-align:center;
display:inline-block;
background-color:#FFF;
}
.header {
background-color:#4CAF50;
color:white;
padding:10px;
font-size:40px;
}
.container {
padding:10px;
}
/*投影卡片*/
#boxshadow {
position:relative;
-moz-box-shadow:1px 2px 4px rgba(0,0,0,0.5);
-webkit-box-shadow:1px 2px 4px rgba(0,0,0,.5);
box-shadow:1px 2px 4px rgba(0,0,0,.5);
padding:10px;
background:white;
width:400px;
}
/* Make the image fit the box */
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/287a69e33a655db191e519dbd4435c46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85deabe716300ffef8f6be7496a8bf11/" rel="bookmark">
			GameFramework---框架简介与下载(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		特别提示: 本系列基于Unity 2019.4.8,框架版本GameFramework 2021.05.31 本系列博客地址: 传送门
一、框架简介 Game Framework 是一个基于 Unity 引擎的游戏框架，主要对游戏开发过程中常用模块进行了封装，很大程度地规范开发过程、加快开发速度并保证产品质量。
在最新的 Game Framework 版本中，包含以下 19 个内置模块，后续还将开发更多的扩展模块供开发者使用。
1.全局配置 (Config) - 存储一些全局的只读的游戏配置，如玩家初始速度、游戏初始音量等。
2. 数据结点 (Data Node) - 将任意类型的数据以树状结构的形式进行保存，用于管理游戏运行时的各种数据。
3. 数据表 (Data Table) - 可以将游戏数据以表格（如 Microsoft Excel）的形式进行配置后，使用此模块使用这些数据表。数据表的格式是可以自定义的。
4. 调试器 (Debugger) - 当游戏在 Unity 编辑器中运行或者以 Development 方式发布运行时，将出现调试器窗口，便于查看运行时日志、调试信息等。用户还可以方便地将自己的功能注册到调试器窗口上并使用。
5. 下载 (Download) - 提供下载文件的功能，支持断点续传，并可指定允许几个下载器进行同时下载。更新资源时会主动调用此模块。
6. 实体 (Entity) - 我们将游戏场景中，动态创建的一切物体定义为实体。此模块提供管理实体和实体组的功能，如显示隐藏实体、挂接实体（如挂接武器、坐骑，或者抓起另一个实体）等。实体使用结束后可以不立刻销毁，从而等待下一次重新使用。
7. 事件 (Event) - 游戏逻辑监听、抛出事件的机制。Game Framework 中的很多模块在完成操作后都会抛出内置事件，监听这些事件将大大解除游戏逻辑之间的耦合。用户也可以定义自己的游戏逻辑事件。
8. 文件系统 (File System) - 虚拟文件系统使用类似磁盘的概念对零散文件进行集中管理，优化资源加载时产生的内存分配，甚至可以对资源进行局部片段加载，这些都将极大提升资源加载时的性能。
9. 有限状态机 (FSM) - 提供创建、使用和销毁有限状态机的功能，一些适用于有限状态机机制的游戏逻辑，使用此模块将是一个不错的选择。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85deabe716300ffef8f6be7496a8bf11/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/80/">«</a>
	<span class="pagination__item pagination__item--current">81/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/82/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>