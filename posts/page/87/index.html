<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/750a6f73899cd19b85833bbb8c5dd3e4/" rel="bookmark">
			叠瓦盘为什么不推荐_站内值友帮你选，可靠的性价比非叠瓦式机械硬盘推荐清单...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		伴随固态硬盘价格的节节攀升，2020年固态整体涨价已是必然。从18年起就未曾入手过机械硬盘的小编，又把目光转回到机械硬盘这位老朋友身上，而对于现阶段技术极为成熟的机械硬盘而言，品牌、产品线定位与价格也都较为透明，哪还有什么可科普的呢？当然有，引出今天要与大伙探讨的主题——叠瓦式机械硬盘(SMR) 与 传统垂直式硬盘(CMR)。
机械硬盘的工作原理与叠瓦式硬盘详解
机械硬盘是如何读写存储你的数据的？一般说来，无论哪种硬盘，都是由盘片、磁头、盘片主轴、控制电机、磁头控制器、数据转换器、接口、缓存等几个部份组成。
磁盘(盘片)：盘片存储信息的原理和磁带比较相似，在磁盘的表面涂有一层薄薄的磁性材料，磁盘本身主要是铝合金材质(也有其他材质，例如玻璃)，磁头在读取/写入数据时，磁头上的线圈通电，在周围产生磁场。以此磁化盘片表面磁性物质，使它们按照磁场方向排列，通过改变电流方向的形式，切换不同磁场方向，改变排列，就可以用来表示"0"和"1"，达到读写/存取二进制数据的目的。简要一句话来描述：硬盘在工作时,磁头通过感应旋转的盘片上磁场的变化来读取数据;通过改变盘片上的磁场来写入数据。
水平磁记录 LMR VS 垂直磁记录 PMR
水平磁记录 LMR：LMR的全称是Longitudinal magnetic recording，在机械硬盘发展的早期，机械硬盘的磁性颗粒是呈水平排列的，密度较小，单个盘片上放不了太多数据，所以早期的硬盘容量都不大。
垂直磁记录 PMR：PMR的全称是Perpendicular Magnetic Recording，几经发展，为了让硬盘存储更多的数据，硬盘厂商便研发出垂直式排列，大大提高了数据存储容量，PMR逐渐替代了LMR成为主流。
随着技术的发展，现在PMR的磁记录方式里，又细分出了两种形式，也就是今天主要讨论的主题：CMR和SMR (这两者是相互的一对概念)
读磁头的宽度低于写磁头的宽度，因此读写需要的磁道宽度空间并不相同。CMR称为传统磁记录方式，这种方式保留了最早PMR替代LMR时的传统技术，即：磁道间留有保护间距，数据不会被重复叠写。一个磁道与另一个磁道保持间距(磁道为一个圆圈，抽象出来就像下面一样)。
SMR称为叠瓦磁记录方式，这种方式将盘片上的数据磁道部分重叠，把整个磁道的宽度则设计成写磁头的宽度，就像屋顶上的瓦片一样。该技术可以大幅提高磁盘存储密度。同等空间中存入更多数据。
有的值友该说了， "叠瓦式硬盘不挺好的么，技术又发展了呀！"叠瓦式为人唾弃的最大原因来了，叠瓦式硬盘在数据写入过程中会执行一系列复杂操作：因为写磁头要写满整个磁道，而每个磁道都有一部分被相邻磁道覆盖，向磁道中写数据可能会覆盖与其相邻的磁道的数据，导致相邻磁道上的数据被改写；为了保证相邻磁道上数据的完整性，需要在写之前，先将相邻磁道上的数据读出来，和需要新写的数据一起重新组织后再依次写入。但会给硬盘写入带来严重拖累效率下降。业内称之为：写放大。
简单点说，叠瓦式由于磁道更密集，磁头一次会修改两个磁块。所以叠瓦式只能把后面的数据全都复制一份到缓存里，然后对这个磁块进行修改，之后再把缓存里的数据一个一个写上来。提炼总结，简单理解传统、垂直式：读直接读，写直接写、叠瓦式硬盘：读直接读，但要想写，得先读相邻数据处理后再依次写入。因此叠瓦式硬盘的缓存容量也要远高于垂直式硬盘(256MB/64MB)，并不是厂商良心多放了缓存，是技术限制不得不增加缓存容量，鄙视以此做夸张宣传的无良商家。叠瓦式机械硬盘不适合频繁的进行数据修改，系统盘、装程盘、玩游戏等等皆不适宜，当个大容量仓储盘还凑合，就是那种只写一次、几乎不改写的只读数据的存储。
为何老司机对叠瓦式硬盘嗤之以鼻
性能不行：对比固态而言，机械硬盘天生读写慢的弊病被再一次放大可靠性差：数据频繁读取写入，翻车率更高，便宜诚可贵，数据价更高。不够便宜：这也可能是现阶段叠瓦式硬盘最最大的弊病了，在牺牲原有性能与可靠性的情况下，它真的不够廉价，入手价格相较传统垂直式硬盘不足15%，甚至更低，没理由选它。厂商心机：不提示、不明说、增加用户理解成本，与垂直式掺着卖。如何分辨叠瓦式硬盘？
既然垂直式与叠瓦式掺着卖，那我们如何快速判断硬盘类型呢？先看参数：看转速与缓存容量，以京东西数蓝盘为例，转速等级为5400RPM，缓存容量256MB的基本都是叠瓦硬盘。2TB为何如此"良心"？谁是叠瓦式机械硬盘不必多说了吧。此外还可以询问客服，既然厂商捂着不明确标注是否采用SMR技术，那直接询问客服是最最直接的。发送正确的商品链接或产品型号。询问是否采用叠瓦式/SMR技术。
看张大妈，站内值友帮你选
小编自认为还蛮懂数码的，但是值友藏龙卧虎，大神真的超多，还非常热心愿意分享交流经验！比如东芝P300系列，最近莫名儿有些火，2TB以下就不推荐购买了，5G都来了，数据信息爆炸的时代给小姐姐买套大点儿的房子吧。各位值友可以看看下面的文章。
下面是站内生活家大神：川川川川桑整理的市售PMR HDD清单，大家鼓掌！必须要说的是，就算是经过站内值友火眼金睛筛选过的、系列中基本都是非叠瓦式硬盘的HDD系列产品，也会随着版本更替刷新出SMR硬盘出来。感谢川川川川桑的辛苦整理！
1T容量PMR机械硬盘清单
来自川川川川桑的吐槽：1T型号的单T价格那么高，不会真有人去买吧？
1.东芝DT01ACA100(P300)
2. 东芝DT01ABA100V
好价
TOSHIBA 东芝 1TB 5700转32M SATA3 监控级硬盘279元包邮值友爆料原文：京东现售价279元。近期好价。值0评论0收藏0去购买
3.西部数据 WD10PURX
4. 西部数据 WD10EFRX
2T容量PMR机械硬盘清单
1.东芝DT01ACA200 (P300)
2.东芝 DT01ABA200V
3.西部数据WD2003FZEX
4.西部数据WD20PURX
5.希捷 ST2000VX008
6. 希捷 ST2000VN004
3T容量PMR机械硬盘清单
1.东芝 DT01ACA300 (P300)
2.东芝 DT01ABA300V
3.西部数据 WD30EZRZ
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/750a6f73899cd19b85833bbb8c5dd3e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c728daf43e15b229410f57b64c54ced/" rel="bookmark">
			ks检验p值代表什么_假设检验|第五章：解释P值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		•概述•
每个人都知道可以使用P值来确定假设检验中的统计显着性。它是一个很重要的概念，但P值又是一个滑溜的概念，人们通常会错误地解释它。在这篇文章中，我将通过一个具体的例子帮助您理解P值。
一、从样本t检验获得P值
假如现在您希望确定一种新的汽油添加剂对汽油英里数是否有影响。如果此特定级别汽车的已知汽油英里数为 25 英里每加仑 (mpg)，则此研究的假设为 H0：μ = 25 和 HA：μ ≠ 25。
您检验 35 辆车，发现在这些车中每加仑汽油跑的英里数介于 14.4 到 28.8 之间。在将数据放到 MPG 列中之后，执行 Minitab 的 t 检验（菜单命令统计 &gt; 基本统计 &gt; 单样本 t）并获得以下结果：
二、解释P值
结果显示，35 辆汽车样本的均值为 23.657。但是，这种类型的所有汽车的每加仑英里数的均值 (μ) 可能仍为 25。您希望了解是否有充足的样本证据来否定 H0。最常见的方法是比较 p 值与显著性水平 α (alpha)。α 是当 H0 为真时否定 H0 的概率。在此例中，这就是得出总体均值不是 25 mpg（而实际上是）的结论的概率。
p 值用来对照 H0 度量数据证据的强度。通常，p 值越小，否定 H0 的样本证据越强大。更具体地说，p 值是导致否定 H0 的最小 α 值。对于任何大于 p 值的 α 值，将无法否定 H0，而对于任何 小于等于p 值的 α 值，可否定 H0。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c728daf43e15b229410f57b64c54ced/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f94e1c91589297f92014a6c03e6cc764/" rel="bookmark">
			python语言块标记_python语言语句块的标记是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python中没有明显的语句块标记，是通过缩进来识别语句块的。Python是一种跨平台的计算机程序设计语言；是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言；多被用于独立的、大型项目的开发。
python没有明显的语句块标记，是通过缩进来识别语句块的。
这里打开编辑器，新建一个py文件作为示范。
def happy():
print("Very Happy!")
happy()
创建函数的时候，冒号以后需要进行缩进，标记语句块。
x = 1
while x &lt; 5:
print(x)
x += 1
在用while的时候，冒号以后需要进行缩进，标记语句块。
x = 1
if x &lt; 10:
print("ok")
else:
print("not ok")
在用if和else语句的时候，冒号以后需要进行缩进，标记语句块。
如果不用标记语句块，是会报错的。
def hey():
x = 1
while x &lt; 3:
print("hey")
x += 1
if x == 3:
print("ok")
hey()
每一次冒号以后都是需要标记语句块，而且要根据格式一层一层标记。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d37f86e71b7c92b70e0b0bdbccab788/" rel="bookmark">
			python扩展名修改后用不了_在Python中如何在不改变文件扩展名的情况下更改文件名？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如您所知，文件扩展名在*nix系统中并不重要，但我们仍使用它以便于使用。但是在Windows中，它很重要。在
我在linux机器上有一个服务器程序(python)，它向客户机发送文件。有些文件有扩展名，有些文件没有扩展名，有些文件名中有一个或多个点(.)。在
在windows机器(扩展名是否隐藏)中，如何在不更改扩展名的情况下更改文件名。？在
例如：
从我的Linux服务器发送的文件：abc.txt (txt files)
def.doc (doc files)
qwe.qwe.qwe (text files not have extension)
Windows Machine1上所需的输出(不隐藏扩展名)：
^{pr2}$
Windows Machine2上所需的输出(隐藏扩展)：abc_Monday (txt files but extension is not seen)
def_Monday (doc files but extension is not seen)
qwe.qwe.qwe_Monday (text files not have extension)
而且还有很多文件扩展名。因此，我不想用黑名单来确定文件扩展名。如何区分文件是否有扩展名，以及如何在python客户端不更改扩展名的情况下重命名它？在
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84f0056c526cde942c3aee3bef9377ee/" rel="bookmark">
			python unescape函数_Python：unescape特殊字符,不分割数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我已经制作了一个简单的
HTML解析器,它基本上是来自文档的直接复制.我无法在不将数据拆分成多个块的情况下对特殊字符进行转义.
这是我的代码,有一个简单的例子：
from HTMLParser import HTMLParser
class MyHTMLParser(HTMLParser):
def __init__(self):
HTMLParser.__init__(self)
self.data = []
def handle_starttag(self, tag, attrs):
#print (tag,attrs)
pass
def handle_endtag(self, tag):
#print (tag)
pass
def handle_data(self, data):
self.data.append(data)
def handle_charref(self, ref):
self.handle_entityref("#" + ref)
def handle_entityref(self, ref):
self.handle_data(self.unescape("&amp;%s;" % ref))
n = "I &lt;3s U &amp; you luvz me"
parser = MyHTMLParser()
parser.feed(n)
parser.close()
data = parser.data
print(data)
问题是这会返回5个独立的数据位
['I ', u'
我想要的是单个字符串：
['I &lt;3s U &amp; you luvz me']
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84f0056c526cde942c3aee3bef9377ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0c7792a153816c6335edcdc79658cc9/" rel="bookmark">
			关于依赖倒置原则的一次思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念
High level modules should not depend upon low level modules;Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions;
三层含义：
高层模块不应该依赖底层模块，两者都应该依赖其抽象；
底层模块：指的就是系统中的基础模块，换句话就是不可分割的原子模块
高层模块：多个原子模块，组装成了高层模块。
抽象不应该依赖细节；
细节应该依赖抽象
在Java中的表现形式——面向接口编程
模块之间的依赖关系，都是通过抽象方式发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；
接口或抽象类不依赖于实现类
实现类依赖接口或抽象类
接口和抽象类的作用
接口负责定义public的属性和方法，以及声明与其他对象的依赖关系
抽象类负责公共构造部分的实现（将公共部分放到父类来实现）
依赖倒置原则
依赖的实现方式
构造函数传递依赖对象
Setter方法传递依赖对象
接口声明依赖对象——常用
倒置
什么是“倒置”
先说什么是“正置”
与“倒置”对立的就是“正置”了，其实“正置”就是我们生活中正常的顺序
比如：司机开车，必须是先有车，再有司机；而在程序中，我们按道理说也应该是，先有汽车类（Car），然后再有司机类（Driver），因此开发程序是，我们就需要先开发完成汽车类，然后才能开发司机类（因为司机类依赖了汽车类，汽车类的响应结果约束了司机的行为）
倒置的说的不是对象的倒置，而是“约束”的倒置
在当前的项目开发中，绝大多数都是团队协作，所以为了避免开发人员之间相互制约就需要将制约因素提前约定好，这样就可以各自完成各自的任务了。
比如：还是上面的例子，开发Driver对象时，需要依赖Car对象，为了避免因为Car对象没有开发完成，导致Driver对象无法开始，所以Driver对象依赖Car对象时，就需要形成一个约定（即约束），开发Driver对象的时候提供一个接口ICar，把需要Car对象提供什么服务都约定好了（接口参数和返回值），这样Car对象只需要实现接口就可以满足A对象的需求了。
总结
在依赖正置时，对象Car约束着对象Driver的行为
依赖倒置，对象Driver行为，约束着对象Car的行为
思维误区
在此之前，一直觉得接口都是由服务提供者来提供，但是通过此次研究依赖倒置原则，突然觉得，曾经以为正确的，反而蒙蔽了自己——接口应该由服务调用者来提供！或许这才是接口的真正意义所在吧
参考：
https://www.jianshu.com/p/8d7723cd4e24
https://q.cnblogs.com/q/72496/
写在最后
这些都是在阅读《设计模式之禅》时，自己的一些思考，若有不妥的地方，还请指正
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a2d43be693e5d13abc371710235b0b1/" rel="bookmark">
			python中的np.ones_numpy常用函数normal、randn、shape、ones——持续更新中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、np.random.normal(mean,stdev,size)
给出均值为mean，标准差为stdev的高斯随机数(场)，当size赋值时，例如：size=100，表示返回100个高斯随机数。
2、numpy.random.randn(d0, d1, ...,
dn) (出自：http://www.cnblogs.com/sthinker/p/6775675.html)
这个函数的作用就是从标准正态分布中返回一个或多个样本值。什么是标准正态分布，大哥，你别吓我，上过高中吗？标准正态分布俗称高斯分布，正态分布是大自然中最常见的分布，标准正态分布就是期望为0，方差为1的正态分布。
如果没有参数，则返回一个值，如果有参数，则返回(d0,
d1, …, dn)个值，这些值都是从标准正态分布中随机取样得到的。
d0,
d1, …, dn都应该是整数，是浮点数也没关系，系统会自动把浮点数的整数部分截取出来。
参数d0,
d1, …, dn：应该为正整数，表示维度。
返回值
Z：ndarray或者float。
如果想要从非标准正态分布中产生随机样本，咋办？比如下面这个正态分布：
N(\mu,\sigma^2)
其实很简单，就是简单的加减乘除，如下所示：
\sigma
* np.random.randn(...) + \mu
看几个例子吧：
np.random.randn()
返回：
-0.8405297****8702
再比如：
2.5
* np.random.randn(2, 4) + 3
返回：
array([[
4.128****53, 1.764****44 ,
2.732****92,
2.90839231],
[
0.174****86, 4.92026887,
1.574****66, -0.4305991 ]])
这个函数与numpy.random.standard_normal函数非常相似，我都不知道为啥要设置两个功能重叠的函数，但是调用方式不一样：
numpy.random.standard_normal(size=None)
size参数就是一个整数或者一个整数的元组，表示维度，看看下面的例子：
np.random.standard_normal(8000)
或者：np.random.standard_normal(size=(3,
4, 2))
想用哪个自己选吧，不过建议还是使用randn，毕竟常用一些。
3、numpy的ones函数返回的是什么类型
&gt;&gt;&gt;
np.ones(5)
array([
1., 1., 1.,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a2d43be693e5d13abc371710235b0b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca5d02f635efcbd68e88967f274e5e9b/" rel="bookmark">
			Redis为何那么快？/多路I/O复用模型，非阻塞IO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis为什么这么快 1、基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；
2、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
3、使用多路I/O复用模型，非阻塞IO；
4、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；
多路I/O复用模型，非阻塞IO 下面举一个例子，模拟一个tcp服务器处理30个客户socket。 假设你是一个监考老师，让30个学生解答一道竞赛考题，然后负责验收学生答卷，你有下面几个选择：
第一种选择：按顺序逐个验收，先验收A，然后是B，之后是C、D。。。这中间如果有一个学生卡住，全班都会被耽误。 这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。第二种选择：你创建30个分身，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者线程处理连接。第三种选择，你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。。。 这种就是IO复用模型，Linux下的select、poll和epoll就是干这个的。将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。此时的socket应该采用非阻塞模式。 这样，整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的reactor模式。【epoll监听哪些socket上有事件到达，当 accept、read、write 和 close 文件事件产生时，就会回调 FD 绑定的事件处理器】 有30个redis客户端（考生）与redis服务器的网络连接模块（监考老师）保持TCP连接，客户端会不定时的发送请求给服务器，当有一个redis客户端发起请求，会触发unix系统像epoll这样的系统调用，Redis的I/O 多路复用模块封装了底层的epoll这样的 I/O 多路复用函数，然后转发到相应的事件处理器。
文件事件处理器使用 I/O 多路复用模块同时监听多个 FD（文件描述符），当 accept、read、write 和 close 文件事件产生时，文件事件处理器就会回调 FD 绑定的事件处理器。
虽然整个文件事件处理器是在单线程上运行的，但是通过 I/O 多路复用模块的引入，实现了同时对多个 FD 读写的监控，提高了网络通信模型的性能，同时也可以保证整个 Redis 服务实现的简单。
https://juejin.cn/post/6844903814500220936
https://draveness.me/redis-io-multiplexing/ 《Redis 和 I/O 多路复用》
内存数据库的工作模式 多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。
**这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。**采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。
Redis不使用表，他的数据库不会预定义或者强制去要求用户对Redis存储的不同数据进行关联。
数据库的工作模式按存储方式可分为：硬盘数据库和内存数据库。Redis 将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度极快。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca5d02f635efcbd68e88967f274e5e9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e20e54a55b423fd55ccc73a0ee33c845/" rel="bookmark">
			软件测试在不同应用场景中，我们该如何进行测试呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们的日常工作中，我们通常接触到的都是比较复杂的系统。而复杂的系统就意味着比较复杂的测试程序。首先，对于复杂的系统来说，如果想要做功能测试，一般需要考虑到测试数据的问题，还要考虑如何从全局出发，既要把整个业务流程需要测试的内容充分覆盖到。保证即使是多个功能点交叉、存在复杂约束的条件下，也不会出现漏测或者新bug的问题。
其次，即使是单一功能点，也需要足够熟悉，才能确保功能能在操作流程中顺利实现。
因此，作为软件测试工程师，我们需要在日常工作中不断积累经验，精进技术，确保自己能够应对不同场景完成测试任务。那么针对这些复杂的系统，我们应该如何进行测试呢？今天我们就来回顾一下。
如果对软件测试有兴趣，想了解更多的测试知识，解决测试问题,以及入门指导，帮你解决测试中遇到的困惑，我们这里有技术高手。如果你正在找工作或者刚刚学校出来，又或者已经工作但是经常觉得难点很多，觉得自己测试方面学的不够精想要继续学习的，想转行怕学不会的， 都可以加入我们810119819，群内可领取最新软件测试大厂面试资料和Python自动化、接口、框架搭建学习资料！
1、基于场景的测试 为了解决复杂的测试任务，我们提出了基于场景的测试这一概念。这一概念主要以事件流为核心。当然，这一概念，也是为我们后期做高层次的功能测试设计打基础。那么，这一概念的基本思想是什么呢？
它是通过分析不同事件的触发顺序和处理结果，从而构建各个事件流。并且，基于这些事件的触发控制业务流程，形成多个不同场景，最终基于场景设计测试用例。
上图是这一概念的原理。我们不难看出，该图是一条自上而下、贯穿始终的基本事件流（简称基本流）。而其中，每个基本流代表一个被测的典型功能点或主业务。在基本流上，又存在多个触发点，不同触发点又会产生不同事件，从而触发业务流程分流，形成多个备选事件流（简称备选流）。由此，由基本流和备选流形成的不同业务流程（简称场景）诞生了。
2、测试用例设计 由于在不同的场景中，每个场景至少对应一组输入和一个预期输出结果（简称测试用例）。因此，基于场景的测试用例将是一个既庞大，又复杂的工程。那么，对于这样复杂的工程，测试难点有哪些呢？我们又应该如何设置基本流与备选流呢？下面，我们来一一回答。
1）测试难点
主要有以下几个难点：
l 如何根据业务，来构建测试的基本流和备选流；
l 如何基于事件流构建场景，从而满足测试的完整性和无冗余性；
l 如何根据场景，合理设计测试用例。
2）基本流和备选流的设置
针对我们要重点测试的业务，我们需要构建一个基本流和和若干备选流。
（1）基本流
先来回顾一下概念：基本流是指。从系统的某个初始状态开始，经一系列状态变化后，到达终止状态的过程中，最主要的一个业务流程。简言之，就是说整个业务流程中最基本的一个流程。它不需要很复杂，但却是一条高风险的业务流程。
（2）备选流
备选流是以基本流为基础，在经过基本流上每个判定节点（包括条件判定和循环判定），满足不同的触发条件，而导致的其他事件流。
与基本流不同的是，基本流是一条完整的业务流程，而备选流仅是业务流程中的一个执行片段。对比图如下：
对于我们来说，备选流数目决定了我们的工作量有多大。一般情况下，备选流的数目，取决于判定节点的数目与事务分析的颗粒度。简言之，颗粒度越细，考虑得越周全，得到的数目就越多，测试工作量也就越大。
总之，如果你还是记不太清这两者的关系，可以通过下图回忆一下：
3、构建场景 我们都知道，场景是基本流与备选流的有序集合。场景实际用途是用来描述流经用例的路径，即，整个测试过程经历哪些步骤（基本流和备选流）。这也就不难理解，为什么一个测试用例只能对应唯一一个场景了。
那么，我们的场景应该是什么样的呢？下面我们来回忆一下：
l 场景1：基本流；
l 场景2：基本流+备选流1；
l 场景3：基本流+备选流2；
l 场景4：基本流+备选流2+备选流3；
l 场景5：基本流+备选流2+备选流4；
l 场景6：基本流+备选流5；
l 场景7：基本流+备选流1+备选流2+备选流5；
l 场景8：基本流+备选流1+备选流2+备选流3；
l 场景9：基本流+备选流1+备选流2+备选流4。
除了以上的几种场景外，我们还可以通过增加更多备选流，从而构建更多的场景。但是，在这个过程中，我们就会发现，工作量变得异常庞大了。
那么，我们要如何做才能既给自己“减负”，同时又能合理的完成工作呢？我认为，你至少需要考虑这3点：
（1）最少的场景数等于事件流的总数，即基本流与备选流的总数；
（2）有且唯一有一个场景仅包含基本流；
（3）对应某个备选流，至少应有一个场景覆盖该备选流，且在该场景中应尽量避免覆盖其他的备选流。
4、如何设计测试用例呢？ 基于场景，我们可以按照如下步骤，来设计测试用例：
（1）分析被测业务，基于风险的思想找到基本流和所有备选流；
（2）根据基本流和备选流构造适当规模的场景；
（3）根据场景设计测试用例；
（4）对每个测试用例补充测试数据，并实施测试。
不知道看完上述内容，大家有没有回忆起在不同应用场景中，我们该如何进行测试呢？希望印象不太深刻的小伙伴可以去翻翻以前的笔记。后面我们还将为大家提供一个实战案例，希望对大家的工作有所帮助。
加油吧，测试人！路就在脚下，成功就在明天！
最后： 未来的你肯定会感谢现在拼命的自己！
愿你我相遇，皆有所获！ 欢迎关注微信公众号：程序员阿沐
1.免费领取一份216页软件测试工程师面试宝典文档资料。
2.软件测试学习路线以及相对应的视频学习教程免费分享！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b923c0c8404756abb85f5f6bb7f6b6d3/" rel="bookmark">
			win10企业版更新和安全中没有 “恢复”这个选项_通知:微软已强制对Windows 10更新升级...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近，微软发布了Windows10的强制升级。从本月开始，如果您的个人电脑、笔记本电脑和其他设备没有手动升级，微软将强制部分用户升级到Windows10 1909或2004版本。
原因很简单。微软已经停止支持Windows10 1903版（包括家庭版和专业版），强制升级也是一种方式。如果您使用的是win10 1903版本，则必须在本月晚些时候升级到1909版本。如果您当前使用的是Windows10 1909版本，您将被迫在明年春季升级到Windows10 2004版本。
不想强制升级怎么办?
1、首先打开win10系统的搜索功能，在搜索输入框中输入运行。然后点击搜索结果中的运行桌面应用，打开系统指令运行窗口；
2、在系统指令运行窗口中，输入“gpedit.msc”然后按下键盘的回车键，就可以打开系统本地组策略编辑器，我们就可以通过设置系统本地组策略彻底关闭win10系统的自动更新功能；
3、在系统本地组策略编辑器中，根据“计算机配置/管理模板/windows组件/windows更新”的文件夹路径。找到windows更新这个文件夹；
4、打开windows更新文件夹后，找到文件夹中的配置自动更新这个项目。用鼠标邮件点击选中自动更新，然后点击鼠标邮件，点击右键菜单中的编辑，打开配置自动更新功能编辑窗口；
5、打开自动更新功能编辑窗口。我们可以看到此功能是指定此计算机是否通过 Windows 自动更新服务来接收安全更新和其他重要下载。功能的默认状态是未配置；
6、点击已禁用，就可以自动更新功能编辑窗口底部的确定按钮，使禁用设置生效，将系统自动更新这个功能禁用。这样设置完成后电脑系统就不会自动进行更新了；
第二种：
1、设置系统服务。首先用鼠标右键点击win10系统桌面的此电脑，展开右键菜单，点击菜单中的管理，就可以打开计算机管理窗口；
2、打开计算机管理窗口。这时候我们就可以点击计算机管理窗口中的服务，打开系统服务管理界面；
3、在系统服务管理界面中，我们要找到Windows Update这个选项，我们可以看到服务项目的状态是正在启动。用鼠标右键点击选项，然后点击右键菜单中的属性，打开服务属性设置界面；
4、打开Windows Update属性设置界面。我们可以看到服务的启动类型是自动，点击启动类型选择按钮。展开启动类型选择列表，将启动类型选择为禁用，然后点击应用，将禁用服务的设置保存到系统中； 5、接下来我们还要点击打开Windows Update属性设置界面中的恢复选项卡。设置服务失败时计算机的反应。见第一次失败的反应设置为无操作，就可以彻底关闭Windows Update这个系统服务，从而彻底关闭win10系统的自动更新功能。
6、这时候我们重新打开系统的Windows更新页面，就可以看到现在电脑系统不能检查和安装系统更新了。这样我们就彻底关闭了win10系统的自动更新功能了。 win10只要彻底关闭Windows Update后，系统就不会再自动更新了，省去很多麻烦事。一般控制面板没有关闭的自动更新的选项的，要关闭可采取上述方法。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea94129d91cfb4b4e006958cffd24555/" rel="bookmark">
			使用 Trapezoidal Rule（梯形法则）求积分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Trapezoidal Rule 思想原理 为了求解积分值，人们想到一种近似方法。假设要求 f ( x ) f(x) f(x) 在 [ a , b ] [a,b] [a,b] 上的积分，将积分区间等长分成 n n n 段，则每两个分段点之间的距离 h = b − a n h=\frac{b−a}{n} h=nb−a​，然后如下图进行近似
则该区间上的积分值就近似等同于每个小梯形的面积之和。
推导过程 如上图所示， ∫ a b f ( x ) \int_{a}^{b}f(x) ∫ab​f(x) 的结果，就是上图中所有梯形面积总和。
梯形面积 第一个梯形（最左边）的上底 f ( x 0 ) f(x_0) f(x0​)，下底 f ( x 1 ) f(x_1) f(x1​)，高为 h = b − a n h=\frac{b-a}{n} h=nb−a​，因此对应的面积为 S 1 = ( f ( x 0 ) + f ( x 1 ) ) ∗ h / 2 = ( f ( x 0 ) + f ( x 1 ) ) ∗ h 2 S_1=(f(x_0)+f(x_1))*h/2=\frac{(f(x_0)+f(x_1))*h}{2} S1​=(f(x0​)+f(x1​))∗h/2=2(f(x0​)+f(x1​))∗h​。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea94129d91cfb4b4e006958cffd24555/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba1348e155e46598e95b23ab7a47adc6/" rel="bookmark">
			只需5分钟 即可了解如何安全可控的外发核心文件？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通常情况下，为了防止敏感信息泄露，企业是不允许员工将内部数据随意向外部发送的，尤其是研发型企业的代码、制造型企业的设计图纸等核心数据。但是，实际工作中，企业却是越来越多的需要与外部的合作伙伴进行大量文件交换，如何安全可控的外发文件、防止数据泄露，是企业面临的一大挑战。
针对于此，还是有一些办法可以起到作用的：
为每台服务器和计算机定义保护级别，并制定相应保护级别下的保护策略，包括授权和访问方法将场所分为工作区和上网区，工作区不连外网，上网区是员工共享的非专用机封闭所有计算机的外部接口，比如USB口、光驱没有刻录功能、disable蓝牙，不允许计算机和U盘或手机等外设交换数据普通员工不配置笔记本电脑特殊部门不允许进行文件外发，如果需要发送的话，需要经过审批后，由专人进行发送监控电脑的文件外发动作，一旦产生外发动作，就会给管理员发出警报加水印，防止通过拍照、截屏、打印的方式泄露信息办公空间安装摄像头监视异常行为和员工签署保密协议等等 上面的方法的确能起到一定保护作用，但是不能保证绝对不发生问题。因为即使在硬件上做到了上述这些，如果真有居心不良的员工，那么只是增加了作案的难度，只要能上网，想把信息传到外部还是有办法的，比如把想窃取的信息通过编码的方式打包到正常外发的文件里，如果任何日志记录的话，是无从查起的。
所以，为了保障企业的正常数据交换运转流程，需要有一个专业的外发平台，让企业和外部进行安全可控的文件交换，但是功能上需要全面一点，比如至少需要做到以下几点：
要有审批，不管是发给内部同事还是外部合作伙伴，需要经过审批后实现安全合规的发送要有完整的日志记录，所有的操作行为以及文件内容都要能审计追溯除了主动泄密，无意或者不经意的泄密也是很常见的，所以需要通过各种安全策略保护数据，比如传输加密、存储加密等防止二次泄密，需要对发出去的文件进行加密保护，限制打开次数、获取密码、截止日期、禁止的操作等，从而杜绝二次泄密 能实现以上效果的产品是什么样的呢？那就得看看《如何使用Ftrans完成企业内部文件安全外发审批》这个视频了。
本视频详细介绍了基于Ftrans飞驰云联（http://ftrans.cn/）的平台，企业员工可以简单便捷地完成企业内部文件向外部发送过程中的安全审批。从发送、审核到接收的整个流程，只需5分钟即可详细了解。
除了内置审核流程外，Ftrans也可以与企业现有的OA或流程引擎进行对接。目前，Ftrans平台已被多家汽车制造、高新制造业以及科技研发型企业采用。
搜索“飞驰云联”网站，即可观看《如何使用Ftrans完成企业内部文件安全外发审批》完整视频
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d36bbf2d090328e73726e66ab48c995/" rel="bookmark">
			mysql未提交的数据存储在哪_数据库 事务在提交之前数据是存在哪里的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库的物理存储会分成许多个页(Page)，记录都存储在页中，数据每一次IO，操作的最小单位是一个页。数据库运行时，会在内存中维护一个缓冲区(Buffer Pool)。缓冲区缓存部分的页(因为内存有限，所有不能把所有数据都缓存进来)。每次对数据的操作，都需要把磁盘中的页读入缓冲区，然后再进行操作；如果缓冲区中有对应的页，就不需要读磁盘。如果数据库要读入一个页，而此时需要缓冲区已经被用完了，这个时候就要替换出一个页面，腾出一块内存给新读入的页面。如果被换出的页被改过(在内存中每个页会有个Dirty标记，标识当前页面是否被修改过)，就要把内存页写入到磁盘中。
数据库为了实现事务，需要并发控制和恢复机制。
恢复机制，可以用log实现，多采用steal(未提交的数据可以写入磁盘)，no-force(提交的数据可以不写入磁盘)策略。
并发控制，现在的多数数据库用MVCC(MVCC+2PL或MVCC+SSI)，由于steal、no-force策略，这个部分完全就相当于在内存中做，直接更新的是内存页中的元组。只有发生页换出，或是checkpoint(定期的刷脏页)时，才会写磁盘。
所以，不管提交之前还是提交之后，数据在内存中，或是被写入磁盘，都是有可能的。
补充说明下恢复机制。以上是针对存储元组的页面和缓冲区来说的，log还是要在接交时写入磁盘的，以保证已提交的事务是持久化的。
以MySQL为例，MySQL使用REDO和UNDO来实现恢复。其中，REDO 为了重做对数据更改保存的信息，用于恢复；UNDO是与事务相关的， 为了撤销对数据更改保存的信息，用于回滚。每一条REDO日志记录都有一个LSN(Log Sequence NO) 日志号，一个递增的64位整数，一个LSN表示一个redo log结构。
在三个阶段涉及到日志的操作，分别是写入数据时，事务提交时，数据库恢复时。
一)写入数据，以update为例， Insert与之类似
1.计算更新后tuple到原tuple的delta信息，把这个delta复制到rollback segment中的undo
2.写redo log，记录对rollback segment的更改
3.把buffer pool中的对应tuple更新成新值，把新值的rollback pointer指向第1部生成的undo
4.写redo log，记录对数据page的更改
5.将page改成dirty
二)事务提交
force log, flush当前事务的redo log到磁盘
三)数据库恢复
1.启动开始时检测是否发生崩溃
2.定位到最近的一个checkpoint
3.定位在这个checkpoint flush到磁盘的数据，检查checksum。如果不正确，说明这个页在上次写入是不完整的，从doublewrite buffer里把正确的page读出来，更新到buffer中的page
4.分析redo log，标识出未提交事务
5.顺序执行redo
6.rollback未提交的事务
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34bd2971f11e0556971206f92fa3683c/" rel="bookmark">
			mysql 临时列_mysql  – 在SQL中添加一个临时列,其中值取决于另一列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我有这张桌子：
ID | name | result |
--------------------
1 | A | 1 |
--------------------
2 | B | 2 |
--------------------
3 | C | 1 |
--------------------
1 | A | 2 |
--------------------
4 | E | 2 |
--------------------
我想在| result |旁边添加一个新的临时列,其中result = 1的值应该是100,而result = 2的值应该是80,所以它应该如下所示：
ID | name | result | NewColumn|
-------------------------------
1 | A | 1 | 100 |
-------------------------------
2 | B | 2 | 80 |
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34bd2971f11e0556971206f92fa3683c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f6e9fc4d95ced86f108ce20c8da1175/" rel="bookmark">
			华为云电脑和马云无影比_阿里云打造未来电脑&#34;无影&#34;，却因为5G限制，很难达到普及...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在9月17日，在2020阿里巴巴云栖大会上，阿里云发布了第一台云电脑"无影"，极致的简约，一张卡片大小的机器就等于一台电脑了。
看到这款电脑的宣传片，真的是极致的未来感，随随便便一块小透明玻璃就是电脑，到处都能办公、作业，科技感爆棚，但是把宣传片做出这样还是太过夸张了点。当然宣传片是为了让我们更好的去了解这款产品的功能特点。
看过钢铁侠或者其他科幻片的，基本上对于这下场景都不陌生，甚至特别期待那样子的技术，钢铁侠里面托尼斯塔克在家里地下室制造、模拟的时候，往桌子上一点，瞬间就升起几十个3d投影屏幕，然后进行虚空操作。
对的，没错，这就是云端电脑未来的样子，未来云电脑的形态大概率就是这样子，所有的硬件软件啥的都在云端，然后在你要使用的时候，瞬间投到你想要投的屏幕上，而启动这些可能是一张卡片、一个蓝牙耳机、一块手表等等，这些都有可能是未来的开启模式。
而现在阿里云推出了第一台云电脑"无影"，大概率就是这种场景的开端了，根据阿里云的演示，用户将一个工卡大小的终端设备连接显示器后，通过指纹开机登录 5 秒就可以接入云电脑服务，之后的使用就和普通 PC 没什么不同。现在虽然使用的普通的电脑屏幕，但是你想象一下，最近三星研究的透明屏幕，在结合一下现在的云电脑，怎么看怎么有未来感。
相比于普通的电脑，这款云电脑的性能基本上比普通电脑要好数十倍。使用寿命基本上只要更新系统就好，没必要像普通电脑一样有硬件困扰，价格上还比较便宜。不过现在普通人还买不到的，现在只支持企业购买，还不能普及。
为什么不能普及呢？可以肯定的是这项技术肯定还没特别完善，虽然使用它可能只要屏幕和网络就好。但是首先，网络问题就很大，现在虽然已经在普及5G，但是还没有真正的全民使用5G，所以在5G没彻底普及之前，还是没法正式投入到大众使用。其次，5G流量费用太贵，大多数人是不愿意去消费这一笔钱的。
其次就是与它配套的产品都还没有彻底出来，使用这个，你还是得使用鼠标键盘等等外设，总不可能每次出门找屏幕都得带着外设出去吧，那还不如笔记本方便。
所以这款电脑未来前景是好的，但是现在的话其实就是很简陋的一款产品，只是概念而已，现在的体验感觉就像是远超桌面的感觉，延迟可能会低一点，不过大致没差，真正使用起来可能还没华为云鲲鹏手机那个概念要好用。
总体来说，我觉得这款产品的意义大过于实际，可能未来会发展的非常好，但是在当下这个产品还是有很多不足。不过我相信最终它会发展的越来越好，就像是《钢铁侠》里面的效果一样。你觉得呢？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/541a87dd82b334e64efecff7fa9f39bc/" rel="bookmark">
			python idls_Python stat.S_ISUID屬性代碼示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文整理匯總了Python中stat.S_ISUID屬性的典型用法代碼示例。如果您正苦於以下問題：Python stat.S_ISUID屬性的具體用法？Python stat.S_ISUID怎麽用？Python stat.S_ISUID使用的例子？那麽恭喜您, 這裏精選的屬性代碼示例或許可以為您提供幫助。您也可以進一步了解該屬性所在模塊stat的用法示例。
在下文中一共展示了stat.S_ISUID屬性的16個代碼示例，這些例子默認根據受歡迎程度排序。您可以為喜歡或者感覺有用的代碼點讚，您的評價將有助於我們的係統推薦出更棒的Python代碼示例。
示例1: special_to_letter
​點讚 6
​
# 需要導入模塊: import stat [as 別名]
# 或者: from stat import S_ISUID [as 別名]
def special_to_letter(mode):
l = ''
ALL_R = (stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH)
ALL_W = (stat.S_IWUSR | stat.S_IWGRP | stat.S_IWOTH)
if mode &amp; stat.S_ISGID:
l += 'G'
if mode &amp; stat.S_ISUID:
l += 'U'
if mode &amp; stat.S_ISVTX:
l += 'T'
if mode &amp; (stat.S_IXUSR | stat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/541a87dd82b334e64efecff7fa9f39bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4864e97f4010be5c0af62e08cb772a20/" rel="bookmark">
			3分钟即可了解 FHub中转站文件摆渡新技能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说到文件摆渡的方式，有很多种，比较传统一点的，像U盘拷贝、FTP等，自动化一点的，像网闸、网盘等，还有一些企业会通过一些技术手段进行摆渡，比如防火墙技术等，这些方式都能在一定程度上解决跨隔离网文件摆渡的问题，为什么这么说呢，且听下文分析：
1、U盘拷贝：无需多说吧，谁用谁知道，实在是太麻烦了，中毒且不说，而且无法进行管控，毫无安全性可言，只能适合临时的小数量的数据摆渡。
2、FTP：没有审批功能，也没有日志记录，安全可控性较差，大文件传输时不稳定，也是只能适合小规模文件的摆渡。
3、网闸：在审批审计上功能较弱，可拓展性较差，而且不能实现人对人、一对多的数据交换，适合定期的批量数据的摆渡。
4、网盘：在审批审计上功能较弱，大文件支持不友好，而且私有网盘成本较高，适合隔离网较少、数据体量较小的文件摆渡。
5、防火墙技术：采用安全检查的方式，对应用的协议不做更改，比较适合同安全级别的网络隔离环境，但是一般来说，隔离网之间都是有高密级和低密级的区分的。
所以说，这些方式都是只能解决文件摆渡的部分需求，那么，标题所示的中转站文件摆渡是什么呢？它能满足文件摆渡中的所有需求吗？它的名字叫《FHub跨网文件交换中转站》，至于到底能不能满足需求，我们先来看看它有哪些功能特性：
1、丰富的审批流程，全面满足企业各种合规要求
系统内置丰富的审批流程，可根据收发件人所在的部门、用户组、标签、管理角色、业务角色、IP地址等20余种条件，自动触发不同的审批流程，支持以部门主管逐级审批、以汇报人指定级别逐级审批等。
2、完整的日志记录，便于及时的审计追溯
系统提供业内最全面的日志记录，包括用户行为记录、审查审核记录、系统操作记录等，而且能够长期留存和追溯原始文件，也可以根据完整的日志记录，形成报表，便于灵活查询。
3、前置机部署架构，符合等保要求
采用前置机模式，支持多网多站点部署， 支持防火墙、网闸、虚拟桌面、VLAN、 DMZ等多种网络隔离方案。网络边界清晰，符合等保合规要求，未经审核许可，数据绝不越界。
4、大体量文件高速可靠交换，提升业务时效性
系统内置高速传输协议，支持断点续传、错误重传、一致性校验等，即使是TB级的大体量文件，也可以实现快速、稳定、可靠的传输。
5、文件过期自动清理，优化资源占用
文件可设置有效期，过期自动清理归档，减少不必要的空间占用，降低企业运维成本以及IT部门的压力。
6、多重访问安全策略，为平台及账号安全护航
系统可灵活接入组织外部协作方，易于识别、权限受控、实名可信，支持SSO单点登录，可限制登录IP，多重访问安全策略，确保平台及账号的安全。
7、灵活的可扩展性，降低企业综合运维成本
广泛的集成支持，权限组件均提供开放API，全面支持企业级的应用集成。支持ICAP协议，可与第三方杀毒引擎、DLP等集成，加强安全检测能力。
另外，不得不提一下，这种中转站方式尤其适合配备了两台连接不同网络的电脑的研发人员，可以快速的将文件传给自己使用，实现“左手上传、右手下载”的高效传输，审批功能可以按需配置，即使不设置审批，所有的操作也都有详细的日志记录，可以审计追溯，所以不用担心安全合规的问题。
怎么样，现在了解《FHub跨网文件交换中转站》到底是什么了吧，它以软件系统为核心，无需复杂的环境支持，部署简单，大幅减少IT人员日常维护工作量。使用界面一目了然，不改变用户日常使用习惯，操作简单，开箱即用，是解决跨隔离网文件交换的理想方式！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/008a1ee7b4b6941f40ce38207ab5fe53/" rel="bookmark">
			dpo指标详解买入绝技_DPO指标详解：DPO结合MADPO混合使用图解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		区间震荡线(DPO)，是由惠特曼·巴塞特(Walt
Bressert)提出的。是一个排除价格趋势的震荡指标。它试图通过扣除前期移动平均价来消除长期趋势对价格波动的干扰，从而便于发现价格短期的波动和超买超卖水平。
1.DPO由下向上穿越MADPO时，形成金叉，是买入信号;DPO由上向下穿越MADPO时，形成死叉，是卖出信号。(如图所示)
2.股价创新低，而DPO未创新低，属底背离，是买入信号;股价创新高，而DPO未创新高，属顶背离，是卖出信号。(如图所示)
注意事项：
1.DPO在低档出现第二次向上穿越MADPO时，股价上涨幅度会较大;DPO在高档出现第二次向下交叉MADPO时，股价下跌幅度较深;
2.DPO与MADPO都在“0”值以上时，为多头市场;反之，DPO与MADPO都在“0”值以下时，为空头市场;
3.去势价格摆动差指数DPO的时间周期n所取的天数，决定了去势价格摆动差指数DPO所能研判的股价变化周期的长短;也就是说，只能确定n天以下周期的波峰与波谷;
4.去势价格摆动差指数DPO的另一种计算方法是变作差为作商，指数以比率形式表示出来。
(本资料仅供参考，不构成投资建议，投资时应审慎评估)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2ae04c1b450d31b70452a554b458b48/" rel="bookmark">
			解决 Jupyter 不能自动保存问题，问题原因是授权
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 在使用 Jupyter notebook 碰到一个问题，就是点保存或者自动保存的时候，出现 Forbidden，或者 autosave 失败。
问题是由于这个 notebook 没有给 trusted。截图如下
而且这个 trusted 按钮还是灰色的不能点。如下图
点击保存之类，会出现如下界面。
要求输入密码或者 token。
问题原因 Jupyter 权鉴的问题。
解决方法 老师说没有设置过密码。我们可以在 Jupyter 的命令行窗口中，找到对应的 Token。在 Jupyter 的命令窗口，我们可以看到如下的输出。
如上图所示，红色地方就是 Jupyter 的 token。只需要拷贝红色的 token= 后面的字符串即可。也就是说我这个机器的 token 是 b1496ec28617b3ea0e0ca2c4d9ca86fde08c4828ccb6ecc8。在对应的地方粘贴这个 token，再选择 login。
问题解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce732899ab340cf9f03de0c197eaf9af/" rel="bookmark">
			公共变量_FANUC数控系统，宏程序变量的方法，内容简单详细！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FANUC数控系统所提供的宏程序功能的各种应用，供大家参考。
1.2.1变量概述
(1)变量表示
#(I=1, 2, 3, .*或#[]
例: #5, #109, #501, 绑#1+#2-12.]
(2)变量的使用
①地址字后面指定变量号或公式。
格式: #[
#I
[
例: F#103, 设#103-150, 则为F150;
Z #110，设#110-250, 则为z 250;
X [#24+[#18*COS [#1]]].
②变量号可用变量代替。
例: #[#30], 设#30-3, 则为#3.
③程序号、顺序号和任选程序段跳转号不能使用变量。
例:下述方法不允许
O#1;
1H2G0X100.0;
N#3Z200.0;
④变量号所对应的变量，对每个地址来说，都有具体数值范围。
例: #30-1100 时，则M#30是不允许的。
⑤#0为空变量，没有定义变量值的变量也是空变量。
⑥变量值定义:程序定义时可省略小数点，例: #123-149.
(3)变的类型
变量根据变量号可以分为四种类型，功能见表1-1.
(4)变量值的范围
局部变量和公共变量可以为0值或下面范围中的值: -10*7~-102”或 10-29~10*7.
(5)变量的引用
①在地址后指定变量号即可引用其变量值。当用表达式指定变量时，要把表 达式放在括号中。例如: G1X[#1+#2]F#3;.
被引用变量的值会依据地址的最小设定单位自动地进行取舍。
例如:当系统的最小输入增量为1/1000mm单位，指定G0OX#1,并将12.3456 赋值给变量#1,实际指定值为G00X12.346;。
②改变引用变量值的符号，要把负号(-) 放在#的前面。例如: G00X- #1:. ③当引用未定义的变量时，变量及地址字都被忽略。
例如:当变量#1的值是0,并且变量#2的值是空时，GOOX#1Y#2 的执行结果 为G00X0.
以上资源供大家参考，如有问题请留言。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/86/">«</a>
	<span class="pagination__item pagination__item--current">87/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/88/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>