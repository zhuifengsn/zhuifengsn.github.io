<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97f2ee9b9bbf3e7b2639a250c81c72e9/" rel="bookmark">
			6. 可用模型(The caret package )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		6. 可用模型 下列模型在trrain函数中可以使用，代码可以使用getModelInfo获得，或去github repository
共233个。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2f9d7ef1514b6c5ac69991f1beb3cf2/" rel="bookmark">
			git 几款好用的客户端工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虽然git命令非常好用,但客户端UI工具掌握起来、使用起来更加容易。如果你不想用git命令的话,那就用UI工具代替吧。 下面介绍下几款好用的git工具
1、tortoiseGit for Mac （这个也有windows版本的）
2、sourceTree （这个也有windows版本的。撸主使用,觉得不错）
具体使用教程请参考 http://www.jianshu.com/p/be9f0484af9d
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27f7635e6011f28095709f6973928e89/" rel="bookmark">
			android WebView加载淘宝天猫页面报找不到网址的错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近使用webview加载淘宝天猫网址莫名出现找不到网址的问题，根据他的提示，我们可以看到他是以tmall或者taobao开头而不是https。
这是因为他要打开外部的天猫或者淘宝客户端，但webview不支持这样的网址。
所以，我们在下面这个方法里加个判断就ok了
public boolean shouldOverrideUrlLoading(WebView view, String url) { if(!url.contains("http")) return true; web.loadUrl(url); return true; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb5aa059ff0e3b2db373d7ae0790f0e1/" rel="bookmark">
			关于如何进行SQL优化的一些方法和准则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇博文主要讲解关于SQL的优化的一些基础只是，不涉及数据库配置以及其他方面的知识，这些内容主要是结合几年的工作经验和网上内容进行简要的总结说明，不足之处还请大家多多指正。
1、为什么要对SQL进行优化
我们开发的项目上线使用的初期，由于业务数据量相对较少，一些SQL的执行效率对程序运行效率的影响不太明显，而开发和运维人员也无法判断SQL对程序的运行效率有多大，故很少针对SQL进行专门优化。而随着时间的积累，业务数据量的增多，SQL的执行效率对程序运行效率的影响逐渐增大，此时对SQL的优化就很有必要。
2、SQL优化的准则
这个我们可以使用一句话来总结：SQL优化的准则就是尽一切可能提高SQL的执行效率，从而使得我们程序的运行速度很快。
3、SQL优化的一些方法
① 设计数据库表结构时，要对表做数量级和性能影响预测和评估，表的字段尽量都设置default值，尽量避免default为null，主要防止在执行SQL查询时直接将查询条件设置为null或者not null而导致数据库放弃索引，直接全表扫描；
② SQL条件中允许出现库函数和左模糊查询，sql条件中库函数会导致数据库执行时放弃索引，直接全表扫描，而左模糊也是，直接就全表扫描了；
③ 原则上，SQL条件中避免出现&lt;&gt;，in，not in，exists，not exists等操作符；
④ 子查询中的实际查询结果要设置上限要求，且子查询必须要有索引支持，否则子查询也去扫描全表就悲剧了；
⑤ 单个事务的SQL语句数量要有上限要求，不能前台一个提交操作，后台要去插入几十张表的数据，那如果是千万级用户数，基本上就光去插入数据了；
⑥ 同上一条类似，单条SQL语句的数据影响量也要有上限要求，不能一个update操作更新了上千条数据；
⑦ 尽量减少多表关联的SQL，如果必须使用多表关联，也尽量减少关联的表数量，且多表关联时，关联字段必须包含在查询索引中。多表关联SQL中尽量不要使用视图和代理表；
⑧ 充分利用索引，严禁出现表扫描。同时，创建表时也注意索引的字段顺序。
4、其他的话
一般情况下，不同的行业数据量水平相对而言是比较固定的，比如电信行业的数据主要以用户数为基准，按照省级行政单位划分，数量级在千万到亿级之间。而法院的数据主要以案件数为基准，按照市级行政单位划分，数量级在百万到千万之间。（这里只是简要描述一下，实际数据量比这个大得多啊~）一般情况下，系统上线前都会针对不同行业不同地区的数据量做一个估算，然后再通过超大数据量对系统进行性能测试。但是如果遇到技术升级更新或者部署方式发生改变（比如数据集中存放到云上或者分布式部署改为大集中部署），那数据量几乎是十倍百倍的增长，这时候前期SQL执行效率的问题就会暴露出来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9827aa5bdebc12712a4d1b6fa2f8bf91/" rel="bookmark">
			云计算大纲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一阶段linux+搜索+hadoop体系 Linux基础 → shell编程 → 高并发架构 → hadoop体系 → HDFS → mapreduce → hbase → zookeeper → hive → lucene搜索 → solr/solrcloud → elasticsearch分布式搜索 → CM+CDH集群管理 → impala → oozie → flume → sqoop → 项目实战一 第二阶段机器学习 R语言 → mahout → 项目实战二 第三阶段storm流式计算 kafka → storm → redis → 项目实战三 第四阶段spark内存计算 scala编程 → spark core → spark sql → spark streaming → spark mllib → spark graphx → 项目实战四 → python机器学习 → spark python编程 → 项目实战五 → 项目实战六 第五阶段云计算平台 docker → kvm → openstack云计算 → 就业指导 第一阶段：linux+搜索+hadoop体系 Linux大纲 这章是基础课程，帮大家进入大数据领域打好Linux基础，以便更好地学习Hadoop，hbase,NoSQL，Spark，Storm，docker,kvm,openstack等众多课程。因为企业中无一例外的是使用Linux来搭建或部署项目。 1) Linux的介绍，Linux的安装：VMware Workstation虚拟软件安装过程、CentOS虚拟机安装过程 2) 了解机架服务器，采用真实机架服务器部署linux 3) Linux的常用命令：常用命令的介绍、常用命令的使用和练习 4) Linux系统进程管理基本原理及相关管理工具如ps、pkill、top、htop等的使用； 5) Linux启动流程，运行级别详解，chkconfig详解 6) VI、VIM编辑器：VI、VIM编辑器的介绍、VI、VIM扥使用和常用快捷键 7) Linux用户和组账户管理：用户的管理、组管理 8) Linux磁盘管理，lvm逻辑卷，nfs详解 9) Linux系统文件权限管理：文件权限介绍、文件权限的操作 10) Linux的RPM软件包管理：RPM包的介绍、RPM安装、卸载等操作 11) yum命令，yum源搭建 12) Linux网络：Linux网络的介绍、Linux网络的配置和维护 13) Shell编程：Shell的介绍、Shell脚本的编写 14) Linux上常见软件的安装：安装JDK、安装Tomcat、安装mysql,web项目部署 大型网站 高并发处理 通过本章的学习大家将会了解大数据的源头，数据从何而来，继而更好的了解大数据。并且通过学习何果处理大型网站高并发问题反向更深入的学习了Linux，同时站在了更高的角度去触探了架构。 1) 第四层负载均衡 a) Lvs负载均衡 i.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9827aa5bdebc12712a4d1b6fa2f8bf91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ed7b683185b6b64ca41801772189776/" rel="bookmark">
			Linux service network restart重启网络失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		network服务器 重启时报错
情况一：
ifcfg-eth0 查看配置无误，ifconfig eth0查看当前ip 配置也无误，就是ping不同
解决步骤：
1：service network restart 报错
2：ifconfig eth0 查看eth0 配置是否正常
3：mii-tool 检查网卡是否启用
4：ifconfig eth0 up
5：service NetworkManager stop 6：service network restart 重启网络验证是否正常 Linux虚拟机网络配置中，执行重启网络命令：
service network restart
情况二：
报错：
弹出界面 eth0： 错误：激活连接失败：Device not managed by NetworkManager or unavailable
问题现象： VMWare克隆或复制CentOS虚拟机后,ifconfig -a ,eth0不见了,多了一个eth1,但是有/etc/sysconfig/network-scripts/ifcfg-eth0文件，无ifcfg-eth1 在运行#/etc/init.d/network restart, 重启网络连接时出现以下错误： Bringing up interface eth0: Error:Connection activation failed:Device not managed by NetworkManager
原因：克隆或复制CentOS虚拟机后，VMWare为了避免网卡冲突又重新为新的CentOS虚拟机虚拟出来了一个网卡eth1，这就是为什么ifconfig时没有eth0了，虽然VMWare为新的CentOS虚拟机虚拟了一个新的网卡eth1，但它并没有更改/etc/sysconfig/network-scripts/ifcfg-eth0的信息，因此错误就出现了。如果克隆多次还可能会有eth2,eth3等
解决方法： 1、mv /etc/sysconfig/network-scripts/ifcfg-eth0 /etc/sysconfig/network-scripts/ifcfg-eth1 2、修改/etc/sysconfig/network-scripts/ifcfg-eth1中的 DEVICE="eth0"改为DEVICE="eth1" HWADDR="XX:XX:XX:XX:XX:XX"改为eth1的物理地址（用ifconfig -a查看） 并修改IPADDR里的IP地址 3、service network restart还是会报错：Bringing up interface eth0: Error:Connection activation failed:Device not managed by NetworkManager 4、Remove Network Manager from startup Services.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ed7b683185b6b64ca41801772189776/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4485dd44f8ebf461c62748daeefe488/" rel="bookmark">
			大数据学习线路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接触大户数据好多年了，一直没有系统学习过，今天找了个目录如下： 第一阶段：Linux课程 讲解linux基础操作，讲的是在命令行下进行文件系统的操作，这是hadoop学习的基础，后面的所有视频都是基于linux操作的。鉴于很多学员没有linux基础，特增加该内容，保证零linux基础入门。
如果你从没有使用过linux，别担心，本节内容可以让你入门。
Linux 认识linux如何使用vmware安装linux镜像认识linux的桌面环境、shell环境在shell环境下进行文件系统的操作，掌握more、touch、cp、mv、rm等20多个常用命令学习linux的网络管理，掌握ip、hostname等设置学习vmware与linux的通信设置，掌握如何实现host-only、bridge、nat等网络连接方式学习linux的进程管理，掌握如何查看、删除进程学习linux的软件管理，掌握java、mysql等安装学习环境变量配置，掌握如何设置环境变量学习linux的ssh管理，掌握如何实现免密码登录学习linux的防火墙管理，掌握如何关闭防火墙及开放指定端口学习linux的调度管理，掌握crontab的使用 第二阶段：hadoop2课程 搭建伪分布实验环境： 本节是最基本的课程，属于入门级别，主要讲述在linux单机上面安装hadoop的伪分布模式，在linux集群上面安装hadoop集群。对于不熟悉linux的同学，课程中会简单的讲解常用的linux命令。这两种是必须要掌握的。通过现在的教学发现，很多同学并不能正确的配置环境。
搭建伪分布实验环境 Hadoop概念、版本、历史Hadoop和核心组成介绍及hdfs、mapreduce体系结构Hadoop的集群结构Hadoop伪分布的详细安装步骤如何通过命令行和浏览器观察hadoop 介绍HDFS体系结构及shell、java操作方式： 本节是对hadoop核心之一——hdfs的讲解。hdfs是所有hadoop操作的基础，属于基本的内容。对本节内容的理解直接影响以后所有课程的学习。在本节学习中，我们会讲述hdfs的体系结构，以及使用shell、java不同方式对hdfs的操作。在工作中，这两种方式都非常常用。学会了本节内容，就可以自己开发网盘应用了。在本节学习中，我们不仅对理论和操作进行讲解，也会讲解hdfs的源代码，方便部分学员以后对hadoop源码进行修改。最后，还要讲解hadoop的RPC机制，这是hadoop运行的基础，通过该节学习，我们就可以明白hadoop是怎么明白的了，不必糊涂了，本节内容特别重要。
介绍HDFS体系结构及
shell、java操作方式 Hdfs体系结构详述NameNode、DataNode、SecondaryNameNode体系结构如果保证namenode的高可靠Datanode中block的划分原理和存储方式如何修改namenode、datanode数据存储位置如何使用命令行操纵hdfs如何使用java操作hdfs介绍rpc机制通过查看源码，知晓hadoop是建构在rpc之上的通过查看hdfs源码，知晓客户端是如何与Namenode通过rpc通信的 介绍MapReduce体系结构及各种算法(1)： 本节开始对hadoop核心之一——mapreduce的讲解。mapreduce是hadoop的核心，是以后各种框架运行的基础，这是必须掌握的。在本次讲解中，掌握mapreduce执行的详细过程，以单词计数为例，讲解mapreduce的详细执行过程。还讲解hadoop的序列化机制和数据类型，并使用自定义类型实现电信日志信息的统计。
介绍MapReduce体
系结构及各种算法(1) Mapreduce原理Mapreduce执行的八大步骤详细讲述如何使用mapreduce实现单词计数功能详细讲述如何覆盖Mapper功能、如何覆盖Reducer功能。在各种hadoop认证中，这是考察重点详细讲述hadoop的自定义类型Writable接口通过电信上网日志实例讲述如何自定义hadoop类型实例讲述hadoop1的各种输入来源处理器，包括数据库输入、xml文件、多文件输入等，并且讲解如何自定
义输入来源处理器实例讲述hadoop1的各种输出来源，包括数据库输出、文件输出等，并且讲解如何自定义输出来源处理器，
实现自定义输出文件名称通过源码讲述hadoop是如何读取hdfs文件，并且转化为键值对，供map方法调用的 介绍MapReduce体系结构及各种算法(2)： 本节继续讲解mapreduce，会把旧api的用法、计数器、combiner、partitioner、排序算法、分组算法等全部讲解完毕。通过这两次课程学习，学员可以把整个mapreduce的执行细节搞清楚，把各个可扩展点都搞明白。本节内容在目前市面可见的图书、视频中还没有发现如此全面的哪。
介绍MapReduce体
系结构及各种算法(2) 讲解新旧api的区别，如何使用旧api完成操作介绍如何打包成jar，在命令行运行hadoop程序介绍hadoop的内置计数器，以及自定义计数器介绍合并(combiner)概念、为什么使用、如何使用、使用时有什么限制条件介绍了hadoop内置的分区(partitioner)概念、为什么使用、如何使用介绍了hadoop内置的排序算法，以及如何自定义排序规则介绍了hadoop内置的分组算法，以及如何自定义分组规则介绍了mapreduce的常见应用场景，以及如何实现mapreduce算法讲解如何优化mapreduce算法，实现更高的运行效率 第三阶段：zookeeper课程 本节内容与hadoop关系不大，只是在hbase集群安装时才用到。但是，zookeeper在分布式项目中应用较多。
zookeeper Zookeeper是什么搭建zookeeper集群环境如何使用命令行操作zookeeper如何使用java操作zookeeper 第四阶段：HBase课程 hbase是个好东西，在以后工作中会经常遇到，特别是电信、银行、保险等行业。本节讲解hbase的伪分布和集群的安装，讲解基本理论和各种操作。我们通过对hbase原理的讲解，让大家明白为什么hbase会这么适合大数据的实时查询。最后讲解hbase如何设计表结构，这是hbase优化的重点。
HBase hbase的概述hbase的数据模型hbase的表设计hbase的伪分布式和集群安装hbase的shell操作hbase的JavaAPI操作hbase的数据迁移hbase的数据备份及恢复Hbase结合Hive使用hbase的集群管理hbase的性能调优 第五阶段：CM+CDH集群管理课程 由cloudera公司开发的集群web管理工具cloudera manager(简称CM)和CDH目前在企业中使用的比重很大，掌握CM+CDH集群管理和使用 不仅简化了集群安装、配置、调优等工作，而且对任务监控、集群预警、快速定位问题都有很大的帮助。
CM+CDH集群管理 CM + CDH集群的安装基于CM主机及各种服务组件的管理CDH集群的配置和参数调优CDH集群HA配置及集群升级CM的监控管理集群管理的注意事项 第六阶段：Hive课程 在《hadoop1零基础拿高薪》课程中我们涉及了Hive框架内容，不过内容偏少，作为入门讲解可以，但是在工作中还会遇到很多课程中没有的。本课程的目的就是把Hive框架的边边角角都涉猎到，重点讲解Hive的数据库管理、数据表管理、表连接、查询优化、如何设计Hive表结构。这都是工作中最急需的内容，是工作中的重点。
Hive的概述、安装
与基本操作 大家习惯把Hive称为hadoop领域的数据仓库。Hive使用起来非常像MySQL，但是比使用MySQL更有意思。
我们在这里要讲述Hive的体系结构、如何安装Hive。还会讲述Hive的基本操作，目的是为了下面的继续学习。(理论所占比重★★★ 实战所占比重★★) Hive支持的数据类型 Hive的支持的数据类型逐渐增多。其中复合数据类型，可以把关系数据库中的一对多关系挪到Hive的一张表中，
这是一个很神奇的事情，颠覆了我们之前的数据库设计范式。我们会讲解如何使用这种数据类型，如何把关系数
据库的表迁移到Hive表。(理论所占比重★★ 实战所占比重★★★) Hive数据的管理 我们总拿Hive与MySQL做类比。其中，Hive对数据的操作方法是与MySQL最大的不同。我们会学习如何导入数
据、导出数据，会学习如何分区导入、如何增量导入，会学习导入过程中如何优化操作等内容。这部分内容是工
作中使用频率最高的内容之一。(理论所占比重★ 实战所占比重★★★★) Hive的查询 这部分内容讲解Hive查询语句的基本结构，重点讲解表连接。其中，有一些我们原来不知道的语法如left semi-
join、sort by、cluster by等。这部分也在工作中用的是最多的内容之一。(理论所占比重★★ 实战所占比重★★★) Hive的函数 Hive是对查询语法的扩充，Hive运行我们非常方便的使用java来编写函数，特别方便。我们除了简单介绍常见的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4485dd44f8ebf461c62748daeefe488/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/421f85bfc8a43ffeb8781b9a8a98ab71/" rel="bookmark">
			Linux下使用ioctl设置v4l2摄像头参数--------案例二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;sys/types.h&gt; #include&lt;fcntl.h&gt; #include&lt;linux/videodev2.h&gt; /*摄像头开关*/ //#define XXXX_150 /*摄像头参数id列表*/ #define BRIGHTNESS_ID 0x00980900 #define CONTRAST_ID 0x00980901 #define SATURATION_ID 0x00980902 #define HUE_ID 0x00980903 #define WHITE_BALANCE_TEMP_AUTO_ID 0x0098090c #define GAMMA_ID 0x00980910 #define POWER_LINE_FREQUENCY_ID 0x00980918 #define WHITE_BALANCE_TEMP_ID 0x0098091a #define SHARPNESS_ID 0x0098091b #define BACKLIGHT_COMPENSATION_ID 0x0098091c #define EXPOSURE_AUTO_ID 0x009a0901 #define EXPOSURE_ABSOLUTE_ID 0x009a0902 #define EXPOSURE_AUTO_PRIORITY_ID 0x009a0903 struct v4l2_capability cap; struct v4l2_queryctrl qctrl; struct v4l2_control ctrl; struct v4l2_format Format; struct v4l2_streamparm Stream_Parm; void get_v4l2_info(int fd) { printf("************************Get format info********************************\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/421f85bfc8a43ffeb8781b9a8a98ab71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/238d72261b11f3a27d6f5b4afcac2e4d/" rel="bookmark">
			MYSQL 客户端与服务器关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库概念
如果想要知道mysql数据库客户端与服务器之间的关系.首先要明白什么是”数据库”.
从字面意思理解,所谓”数据库”,就是存放数据的库.现实中,大家都知道仓库,粮食库,车库,快递库,它们是放各种实体东西的库.而数据库,放的只有数据.
它是一个软件,它是一个能帮我们管理数据的地方.什么样的东西算数据?一篇文章,一个人的年龄,名字,一件商品的名称,数量,价格等等...把它们放在数据库中稳妥的管理起来,且效率挺高,这就是数据库.
数据库与PHP配合的重要性
我们就拿我最擅长的PHP开发来说,PHP最主要做的就是WEB开发.也就是所谓的网站开发.当然,PHP也能做别的东西,但相比其他语言来说优势并不这么明显.PHP主要得做的就是,怎么样把用户过来的数据写入数据库,又怎么样从数据库取出数据扔给用户. PHP与MYSQL的关系更像炼钢与采钢的关系.学会了PHP只会采钢,但矿石从哪里来?还得会采矿.
PHP工作的大部分过程都是:
PHP--&gt;连接数据库--&gt;写入数据--&gt;查出数据--&gt;格式化数据--&gt;显示出来给用户
WEB网站开发的好,学好数据库的只是非常重要.
安装mysql
这里我们集成环境xampp,不需要我们单独配置安装mysql,安装也非常方便,几乎就是一直下一步就安装好了.这里不做过多的阐述.如果想要知道xampp这种集成环境怎么安装,请关注我的另一篇基础篇文章,常用PHP开发软件安装使用教程.
客户端概念
我们安装完成后,会看到图1,那如何连接呢?
只需要在mysql那个选项后面把Start打开.左侧会有一个绿灯常亮,表示已经开启了.我们在window任务栏的进程中找一个有没有一个mysqld.exe的映像名称.如果有,表示已经开启了mysql服务.那就有个疑问了,这个进程是干嘛的?我们通过这个进程,可以写数据,查数据,所有与数据库写入读取有关的操作,都与这个exe有关.
但目前我们只是开启了这个进行,如何与这个进程”说话”?这个时候就需要客户端.之前我们安装的xampp,是开启mysql进程的客户端,至于开启了以后怎么与mysql 对话,同样需要客户端.
服务器
我们安装在window下的xampp就是服务器的一种环境.因为它简洁易用,所以不需要我们做什么,另一个问题需要重点说一下.虽然我们在自己的电脑上安装了xampp集成环境,但它已经被赋予了另一个角色,就是服务器,那什么是服务器?
服务器:也称伺服器，是提供计算服务的设备。由于服务器需要响应服务请求，并进行处理，因此一般来说服务器应具备承担服务并且保障服务的能力。
举个简单的例子,我们玩的游戏,访问的网站,逛的淘宝等等,你打开浏览器,输入网址,一敲回车,人家凭什么就展示给你一个网站?当然这里面不只是服务器,还有大量的其他网络和计算机知识.这里我们只说服务器.
当键入网址,敲下回车的那一刻,你的那个网址,会顺着网线,去远程寻找对应的服务器,服务器根据你的需要响应给你一个页面,就是你看到的网站.
比如说,我们输入www.taobao.com,远程的淘宝机房,接收到你的请求,会根据你的需要返回给你一个结果,这个结果就是淘宝的首页,那么那个能接受请求并返回给你结果的电脑,就是服务器.
之前我说我们的电脑多了一个功能,就是服务器,我们在自己的电脑上安装xampp集成环境,这个时候我们的电脑就已经具备了接受请求和响应给你结果的能力,这就是服务器.只不过我们没有远程连接,而是在自己电脑上搭建了服务器功能.自己电脑访问自己的电脑上的服务器.
MYSQL 客户端与服务器关系
既然我们的能顺利开启mysql服务了,如何跟这个进程交流通话,这个时候mysql客户端就非常有必要了.
与服务器mysql通话的客户端不止一种,比如说,纯window下或者liunx下的命令行,可以直接通过命令建立与mysql数据库的通话,另外还有像phpmyadmin,它是xampp提供给我们的一种图形化连接方式.还有navcat,mysqlworkbench等等.
建议:初学者使用纯命令行的方式进行操作,多多练习,会起到事倍功半的效果.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93a938c96ed3710f97dfe329d589a80f/" rel="bookmark">
			Golang系列（二）之面向对象编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文个人博客地址：http://www.huweihuang.com/article/golang/golang-object-oriented-programming/
面向对象编程： 把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）[方法的重写，子类不同于父类的特性]／泛化（generalization）[共性，子类都拥有父类的特性]，通过多态（polymorphism）实现基于对象类型的动态分派（dynamic dispatch）。
面对对象思想： 面向对象思想是对现实世界事物的抽象，系统中一切事物皆为对象；对象是属性及其操作的封装体；对象可按其性质划分为类，对象成为类的实例；实例关系和继承关系是对象之间的静态关系；消息传递是对象之间动态联系的唯一形式，也是计算的唯一形式；方法是消息的序列。
（一）类型系统[类的声明] 类型系统：
一组基本类型构成的“基本类型集合”；“基本类型集合”上定义的一系列组合、运算、转换方法。 类型系统包括基础类型（byte、int、bool、float等）；复合类型（数组、结构体、指针等）；可以指向任何对象的类型（Any类型，类似Java的Object类型）；值语义和引用语义；面向对象类型；接口。Go大多数类型为值语义，可以给任何类型添加方法（包括内置类型，不包括指针类型）。Any类型是空接口即interface{}。
1.方法 1、为类型添加方法[类方法声明]，方法即为有接收者的函数
func (对象名 对象类型) 函数名(参数列表) (返回值列表)
可随时为某个对象添加方法即为某个方法添加归属对象（receiver），以方法为中心
在Go语言中没有隐藏的this指针，即显示传递，形参即为this，例如以下的形参为a。
type Integer int func (a Integer) Less(b Integer) bool{ //表示a这个对象定义了Less这个方法，a可以为任意类型 return a&lt;b } //类型基于值传递，如果要修改值需要传递指针 func (a *Integer) Add(b Integer){ *a+=b //通过指针传递来改变值 } 2.值语义和引用语义 值类型：b的修改并不会影响a的值
引用类型：b的修改会影响a的值
Go大多类型为值语义，包括基本类型：byte，int，string等；复合类型：数组，结构体(struct)，指针等
//2、值语义和引用语义 b=a b.Modify() //值类型 var a=[ 3 ] int { 1 , 2 , 3 } b:=a b[ 1 ]++ fmt.Println(a,b) //a=[1,2,3] b=[1,3,3] //引用类型 a:=[ 3 ] int { 1 , 2 , 3 } b:=&amp;a //b指向a,即为a的地址，对b指向的值改变实际上就是对a的改变（数组本身就是一种地址指向） b[ 1 ]++ fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93a938c96ed3710f97dfe329d589a80f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7786d2179e6318c984226312e36fffbf/" rel="bookmark">
			activiti pom
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;maven_web&lt;/groupId&gt; &lt;artifactId&gt;activiti&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;activiti Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;!-- Jar版本管理 --&gt; &lt;properties&gt; &lt;springframework&gt;4.2.0.RELEASE&lt;/springframework&gt; &lt;hibernate&gt;4.3.4.Final&lt;/hibernate&gt; &lt;mysql.connector&gt;5.1.29&lt;/mysql.connector&gt; &lt;c3p0&gt;0.9.1.2&lt;/c3p0&gt; &lt;log4j&gt;1.2.17&lt;/log4j&gt; &lt;activiti.version&gt;5.18.0&lt;/activiti.version&gt; &lt;jstl&gt;1.2&lt;/jstl&gt; &lt;/properties&gt; &lt;!-- Spring web mvc --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${springframework}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;${springframework}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${springframework}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${springframework}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.lucee&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7786d2179e6318c984226312e36fffbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0503508b14e6b0f81a8b7d476acad20e/" rel="bookmark">
			线程异步处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当从一个UI处理model调用另外一个UI处理model时要进行异步线程处理：
1.获取当前UImodel处理线程：
Application.Current.Dispatcher.Invoke(new Action(() =&gt; {
})); 2.在当前线程里进行业务处理：
Application.Current.Dispatcher.Invoke(new Action(() =&gt; {
//处理代码
})); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ebd50cbe9a2ef999f05b34a3ee9b4d4/" rel="bookmark">
			C&#43;&#43;函数返回引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：C++ 有三种传递方式：值传递，指针传递，引用传递
返回“值”和返回“引用”是不同的
函数返回值时会产生一个临时变量作为函数返回值的副本，而返回引用时不会产生值的副本，既然是引用，那引用谁呢？这个问题必须清楚，否则将无法理解返回引用到底是个什么概念。以下是几种引用情况：
一、千万不要返回局部对象的引用 const string &amp;mainip(const string &amp;s) { string ret=s; return ret; } 当函数执行完毕，程序将释放分配给局部对象的存储空间。此时，对局部对象的引用就会指向不确定的内存。
同理，指针也是这样，返回指针的时候，不能指向局部临时变量，否则指针将变为野指针；
二、引用函数的参数，当然该参数也是一个引用 const string &amp;shorterString(const string &amp;s1,const string &amp;s2) { return s1.size()&lt;s2.size()?s1:s2; } 以上函数的返回值是引用类型。无论返回s1或是s2,调用函数和返回结果时，都没有拷贝这些string对象。简单的说，返回的引用是函数的参数s1或s2，并且参数s1、s2也是引用，不是在函数体内产生的。函数体内局部对象是不能被引用的，因为函数调用完局部对象会被释放。
三、返回 this 指向的对象 在类的成员函数中，返回引用的类对象，当然不能是函数内定义的类对象（会释放掉），一般为 this 指向的对象，典型的例子是 string类的赋值函数。
[cpp] view plain copy String&amp; String::operator =(const String &amp;str) //注意与“+”比较，函数为什么要用引用呢？a=b=c，可以做为左值 { if (this == &amp;str) { return *this; } delete [] m_string; int len = strlen(str.m_string); m_string = new char[len+1]; strcpy(m_string,str.m_string); return *this; } 四、引用返回this 的成员变量，或者 引用参数的成员变量 原标题为：引用返回左值（上例的=赋值也是如此，即a=b=c是可以的）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ebd50cbe9a2ef999f05b34a3ee9b4d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/224ddd51198804c06b06f57ee5776b61/" rel="bookmark">
			mysql的主从同步和分库分表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql的主从同步：
mysql主服务器：10.128.199.232
mysql从服务器：10.128.199.233 数据库mycat_test 主服务器my.ini配置，在文件末尾添加： server-id = 1 log-bin = mysql-bin binlog-do-db = mycat_test replicate-do-db = mycat_test 从服务器my.ini配置，在文件末尾添加： server_id = 2 binlog-do-db = mycat_test log_bin = mysql-bin log_slave_updates = 1 read_only = 1 在主服务器执行以下命令： grant replication slave, replication client on *.* to 'repl'@'10.128.199.233' identified by '123'; 输入命令SHOW MASTER STATUS; 记录下file和position(mysql-bin.000027、2698) 在从服务器执行以下命令： CHANGE MASTER TO MASTER_HOST='10.128.199.232',MASTER_USER='repl',MASTER_PASSWORD='123',MASTER_LOG_FILE='mysql-bin.000027',MASTER_LOG_POS=2698; 输入命令start slave开启复制 输入命令show slave status查看slave状态 在master、slave上建立结构相同的table，在主服务器上执行增删改查操作，从服务器也会进行相对应的操作，保持数据的一致性。 mycat的分库分表：
安装完mycat后，首先修改修改config目录下的server.xml文件
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- - - Licensed under the Apache License, Version 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/224ddd51198804c06b06f57ee5776b61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f49501b64116af92da3825e68960393/" rel="bookmark">
			TEST 和 TEST_F 区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;gtest/gtest.h&gt;
int Factorial( int n )
{
if(n==2) return 100; //故意出个错，嘻嘻
return n&lt;=0? 1 : n*Factorial(n - 1);
}
//用TEST做简单测试
TEST(TestFactorial, ZeroInput) //第一个参数是测试用例名，第二个参数是测试名：随后的测试结果将以"测试用例名.测试名"的形式给出
{
EXPECT_EQ(1, Factorial(0)); //EXPECT_EQ稍候再说，现在只要知道它是测试两个数据是否相等的就行了。
}
TEST(TestFactorial, OtherInput)
{
EXPECT_EQ(1, Factorial(1));
EXPECT_EQ(2, Factorial(2));
EXPECT_EQ(6, Factorial(3));
EXPECT_EQ(40320, Factorial(8));
}
int main(int argc, char* argv[])
{
testing::InitGoogleTest(&amp;argc,argv); //用来处理Test相关的命令行开关，如果不关注也可不加
RUN_ALL_TESTS(); //看函数名就知道干啥了
std::cin.get(); //只是让它暂停而已，不然一闪就没了
return 0;
}
2.多个测试场景需要相同数据配置的情况，用 TEST_F
//用TEST_F做同配置的系列测试 typedef std::basic_string&lt;TCHAR&gt; tstring; struct FooTest : testing::Test { //这里定义要测试的东东 tstring strExe; //可以利用构造、析构来初始化一些参数 FooTest() {} virtual ~FooTest() {} //如果构造、析构还不能满足你，还有下面两个虚拟函数 virtual void SetUp() { // 在构造后调用 strExe.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f49501b64116af92da3825e68960393/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ab39a4f1c2518c65eda1443a61e921b/" rel="bookmark">
			常量指针和指针常量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常量指针和指针常量，两个经常弄混淆的名词之一。
常量指针：本质是个指针，常量是用来修饰指针所指向的内容的。例如：const int *p = 5、int const *p = 5
指针常量：本质是一个变量，指针是用来表明这个变量里面存放的是指针。例如：int *const p = 5
那怎么来区分给出的是常量指针还是指针常量呢？简单的方式是*表示指针，const表示常量，就看给出的*和const的先后顺序从左向右读就知道了。
例如：const int *p = 5; const在前，*在后，所以按顺序读就是常量指针。
int const *p = 5; const在前，*在后，所以按顺序读还是常量指针。
int *const p = 5; *在前，const在后，按顺序读就是指针常量。
那么常量指针和指针常量有什么特点呢？
1、常量指针：由于本质是一个指针，而指向的内容是常量。所以可以得到以下几点信息：
a)、这个指针里面放的地址指向的内容是一个常量，也就是通过这个地址不能去修改指向内存单元的内容。
b)、这个指针里面的值是一个变量是可以变化的，变化之后的地址可以是任意合法的地址。
这个就好比是手机的里的SIM卡槽就相当于一个指针，这个SIM卡就相当于放在指针里的地址，而这张SIM的指向内容就是这张卡的号码一样。一个手机可以默认初始化时插入一张SIM卡，我们可以更换SIM来变更手机号码，但是却不能通过不更换SIM卡就变更手机号码一样。同样的道理，可以解释下面代码中的内容：
#include &lt;stdio.h&gt; int main() { const int a = 5; const int *b = &amp;a; //正常初始化 *b = 6; //非法赋值，原因是打算修改常量a的内容 int c = 7; b = &amp;c; //合法的 *b = 9; //非法的，error: assignment of read-only location const int d = 8; b = &amp;d; //合法的 return 0; } 在上面的代码中，可以给b赋值一个常量也可以给它赋值一个变量的地址，但是不管是赋值常量还是变量的地址，都无法通过这个地址去修改变量的内容。也就是可以修改指针的值但却无法通过该指针修改指针所指向的内存单元的内容。 2、指针常量：本质是一个常量，而指向的内容却不一定是常量。通过这句话同样可以得到两点信息：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ab39a4f1c2518c65eda1443a61e921b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cafc034c5441ea3be614c657c01a3270/" rel="bookmark">
			linux应用程序地址分布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习linux时会经常遇到如下概念：代码段、数据段、BBS、堆、栈等，同时也会经常需要知道全局变量、局部变量有是怎么存放。本文的作用就是阐述自己对这些概念的认识。
先来说明linux中内存的分布情况和各个字段的作用，如下图所示是linux中内存中个组成部分示意图：
Text：代码段，这一部分存储的是CPU执行的机器指令，这部分是共享的，也就是在存储中只会存在一份该正文段。同时，该段需要满足可执行和只读性，这样可以防止程序遭到意外的修改。
Data：初始化数据段，这一部分存储全局作用域中明确赋初值的变量。
BBS：未初始化数据段，存放全局作用域中没有明确赋初值的变量，在程序开始执行之前，内核会将这段中数据初始化为0或者空指针。
Heap：堆，用于动态存储的分配，是从低地址到高地址。什么叫动态存储？动态存储就是变量空间大小会随程序变化、创建和消失。这一部分相关操作函数有：malloc/calloc/realloc/free
Stack：栈，用于存放局部变量已经函数执行时所需要保存的信息。每次函数调用都会创建一个新的栈帧，因此每个函数调用的过程都是单独，这也是为什么局部变量的范围只局限该函数或者改代码块的原因。栈的地址是从改地址向低地址方向增长。
代码区所在的地址空间最低，往上依次是Data区和BSS区，并且Data区和BSS区在内存中是紧挨着的。
其中，Text和Data段都是位于可执行的文件中，编译时已经分配了空间，启动程序时会从源文件中读入。而BBS段则不占用可执行文件的大小只包含BBS段的大小，然后链接器根据这个大小在数据段后面分配一块相应大小的内存空间，并在内存进入程序时全部清空为零。
下面通过程序距离来说明一下，程序如下：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int global_init_a = 1; //init global variable int global_uninit_a; //uninit global variable static int static_global_init_a = 1; //static init global variable static int static_global_uninit_a; //static uninit global variable const int const_global_a = 1; //const global variable char *global_p = "abcd"; //global pointer variable int main() { int local_init_a = 1; //init local variable int local_uninit_a; //uninit global variable static int static_local_init_a = 1; //static init local variable static int static_local_uninit_a; //static uninit local variable const int const_local_a = 1; //const local variable char *local_p = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cafc034c5441ea3be614c657c01a3270/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/847249eed3f277467e271b39441d2fed/" rel="bookmark">
			HBuilder从下载到使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		听别人谈论这货，于是决定长长见识，见见世面，便屁颠屁颠到网上下一个，满怀好奇的研究了一下。对用过eclipse这款软件的人来说，上手非常容易。
☆ 准备工作
① 确认自己的电脑连接网络，能下载东西。
② 最好有一款主流浏览器。如谷歌，火狐，IE，Opera等(用这个工具都是做web的，浏览器很重要。)
☆ 下载HBuilder
方式一： 在浏览器的地址栏中输入 http://www.dcloud.io然后回车进入
方式二： 打开浏览器，访问百度搜索，输入HBuilder官网，然后点击进入
上面的两种方式，任选一种。访问官网后如下图所示
选择HBuilder之后，点击下载处弹出提示界面。
点击即可下载。
注：一般都是选择保存在哪，有部分会调用你的下载工具进行下载，如，迅雷，电驴等。
☆使用HBuilder
找到下载HBuilder文件，这文件时绿色解压缩版。就是说不用安装，解压后直接可以使用。因此，我们必须找到自己存放这种绿色版的工具位置，粘贴该文件，然后解压，解压后删除压缩包。
打开如上图所示的HBuilder文件夹，找一个HBuilder.exe文件，如下图所示
选中该文件，右键-弹出菜单中选择“发送到”弹出菜单中选择“桌面快捷方式”，点击他。
然后，我们在桌面就可以看到这样一个图标，将文件的名字改成HBuilder就可以。以后直接双击这个快捷方式，就可以直接打开HBuilder开发工具。
☆ 使用HBuilder
双击HBuilder这个图标，打开软件。然后你会看到这样一个界面
你可以选择注册一个用户来使用，也可以直接使用。点击暂不登录跳过这个界面，直接使用此工具。如果需要注册的可以自己注册,此处省略注册过程。
进入的这个界面是一个欢迎界面，同时下面有该工具的使用的教程。可以先浏览器一遍，然后在来使用这个工具。同时整个软件界面使用的都是简体中文，看起来也相对容易。
使用步骤：
1，建立web项目(工具帮助你构建开发和解析html环境)
2，建立web页面(这是就是我们经常说的网页)
新建页面时，注意选择html5这一项，因为时下流行的就是html，选择这个之后，软件会自动生成html5的代码结构。
注：meta标记的charset属性一般设置为utf-8
这个工具的最大优点就是快捷键使用起来舒服和方便。
☆ HBuilder快捷键
点击”帮助”菜单,在里面找到”快捷键列表”这一项，点击他，然后在整个工具布局的右边看到一个列表，这里面就是对快捷键的描述。
对于快捷键的使用，大家可以自己慢慢体验和琢磨。只有用的时间长了，快捷键就会信手而来，练得次数多了，写起代码才有飞一般的感觉。
技术分享：www.kaige123.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aa8448565cb44374e508a5a180bec3e/" rel="bookmark">
			automake的理解和实践总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		automake的背景和作用：一般情况下我们在做一个项目时需要编写一份Makefile文件来对整个项目的文件进行编译生成可执行文件，但是一般这样编写Makefile文件会相对比较复杂而且会存在不同编译环境时需要对Makefile文件做相应的修改。为了解决这个问题，所以就引入了automake。对于automake，用户只是需要编译和配置一些参数就可以了，其它所有的操作都可以通过automake的一系列命令来实现。 automake生成Makefile文件所需的工具：GUN Automake、GNU Autoconf、GNU m4、PERL、GNU Libtool
automake生成Makefile文件所需的文件：需要编译的源文件、configure.ac或者configure.in、Makefile.am
下图是我对整个automake过程理解整理的一张流程图，详细的描述了整个执行过程、所需要的文件和输出文件。
下面通过来详细说明每一步操作：
1、创建需要编译的源文件hello.c：
#include &lt;stdio.h&gt; int main(void) { printf("Test automake.\n"); return 0; } 2、准备automake所需要的文件configure.ac或者configure.in（两个文件的格式都是一样的知识命名不同），这个过程可以完全手动编写也可以通过aotoscan的帮助生成configure.scan文件，然后在configure.scan的文件基础上更改并命名为configure.ac或者configure.in。 autoscan会扫描源代码以搜寻普通的可移植性问题，比如检查编译器、库、头文件等，生成文件configure.scan，它是configure.ac或者configure.in的雏形。
执行autoscan：
configure.scan内容解释：
3、编辑configure.scan并命名为configure.in：
修改后的文档如下：
4、aclocal 是一个perl 脚本程序。aclocal 根据configure.in 文件的内容，自动生成aclocal.m4 和autom4te.cache文件。但是使用configure.in时会提示一个warning，为避免这个warning可以命名为configure.ac。
下面是以configure.in命令的结果：
下面则是以configure.ac命名的结果：
5、autoheader是创建configure头文件模板的操作，这一步执不执行与在configure.ac/configure.in中是否定义AC_CONFIG_HEADERS([config.h])有关，如果没有定义就不需要执行，如果定义了就一定需要执行。
如果没有定义AC_CONFIG_HEADERS([config.h])而执行的结果：
如果定义了AC_CONFIG_HEADERS([config.h])但是没有执行的则会在automake时提示错误。
6、创建Makefile.am文件：
7、automake根据 configure.in 中和config.h.in中的宏把Makefile.am 转成 Makefile.in 文件。其中config.h.in文件是否需要与是否定义AC_CONFIG_HEADERS([config.h])有关，定义了则需要没定义则不需要。--add-missing选项是让automake自动添加一些必需的脚本文件。
如果定义了AC_CONFIG_HEADERS([config.h])而没有执行autoheader的话就会提示下面的错误：
8、autoconf：是用来产生configure 文件的。configure 是一个脚本，它能设置源程序来适应各种不同的操作系统平台，并且根据不同的系统来产生合适的Makefile ，从而可以使你的源代码能在不同的操作系统平台上被编译出来。configure.in/configure.ac 文件的内容是一些宏，这些宏经过autoconf 处理后会变成检查系统特性、环境变量、软件必须的参数的shell 脚本。configure.in 文件中的宏的顺序并没有规定，但是你必须在所有宏的最前面和最后面分别加上AC_INIT 宏和AC_OUTPUT 宏。具体生成使需要依赖aclocal.m4、configure.ac/configure.in和config.h.in，其中config.h.in文件根据是否定义AC_CONFIG_HEADERS([config.h])有关。
下面是生成文件：
下面是缺少configure.ac的执行错误：
下面是缺少aclocal.m4的执行错误：
9、./configure：执行配置文件会依据Makefile.in和configure文件生成Makefile文件
但是我第一遍执行时出现了下面错误：
进过查找，原因是在AM_INIT_AUTOMAKE(hello, 1.0)前面存在空行导致的。
10、执行make和运行二进制文件
最后生成的Makefile文件支持的命令：
make:根据Makefile编译源代码，链接生成可执行文件
make clean:清除make生成的object文件和可执行文件
make dist：产生发布软件包文件（即distribution package ）。这个命令将会将可执行文件及相关文件打包成一个tar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3aa8448565cb44374e508a5a180bec3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/243a83081e1e32d97958499391cf3b0d/" rel="bookmark">
			详解互联网平台的资金系统方案 自建支付清结算系统优势明显
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景内金融是互联网金融的发展方向。金融生态圈也会逐渐向脱媒化、去银行化演变。我们看到越来越多的平台纷纷涉足和提供金融服务，如BAT、新浪、齐家、海尔等。各家平台通过改变交易场景，优化操作的便捷性、增强用户粘性等互联网的手段来吸引新一代的用户进行金融尝试。互联网金融将从单纯的技术应用转向场景内金融，并最终转向自金融时代。 事实上，场景内金融已经融入各个不同行业，例如家装、旅游、物流、二手车、汽车租赁等，如今越来越多的行业都开始从早期的信息平台转型到了交易平台，甚至是拓展了金融服务。过去信息平台只能提供信息的展示，无法形成闭环。现在随着场景内金融的引入，各个平台不仅实现了信息流的闭环管理，更是有了新的利润点，甚至在原有交易业务的基础之上诞生了金融服务，为形成更完整的生态圈提供了可能。 互联网平台引入了场景金融之后，自然产生了对于资金系统方案的需求，同时平台处在不同发展阶段需求也有所不同。发展初期，业务量可能还比较小，平台会考虑如何快速、方便的接入支付服务，让平台更快的形成交易闭环。当业务量增加之后，对资金进出更加全面的管控需求就会逐渐凸显，等而发展到了一定程度之后，平台希望能开展更多的业务，为用户提供多元化的金融服务。
为了满足平台日常运营甚至是未来发展，一套技术优秀的资金系统方案无疑必须的。目前针对在线平台的资金系统方案可以大致的分为三类，接入第三方支付、自建支付网关以及自建支付清结算系统。虽然自建支付清结算系统有一定的难度，但自建系统在资金沉淀时间、数据所属、用户体验以及管理效率上有很大的优势。
常见的三种资金系统方案 （三种资金系统方案的功能对比） 接入第三方支付
平台在某家第三方支付公司开设账户，通过第三方支付提供的支付服务完成在线支付，一般需要按流量支付手续费给第三方支付公司。
接入第三方支付虽然操作简单，但是会受限于第三方支付公司。无法自行增加支付渠道，还需要定期人工完成清结算，同时用户也没有资金账户，无法通过沉淀资金产生额外的收益。
自建支付网关
自建支付网关之后，可以支持多种资金渠道，并由支付网关统一处理支付请求。通过统一的第三方接入前置对接外部支付渠道系统，包括银行、银联等其它的资金渠道，支持动态扩展资金渠道的接入，而不影响原有的资金渠道。
支付网关最大的优势是能够让平台自行控制接入的支付渠道，为用户提供更加丰富的选择。但和第三方支付相同的是，支付网关同样需要平台定期完成清结算，无法自动实现，而且也没有资金账户。
自建支付清结算系统
平台搭建或采购一套支付清结算系统，能够全面支持平台的账户体系建立和支付清结算业务。支付清结算系统中不仅包含支付渠道的接入，还为平台用户提供虚拟账户。系统提供对整个支付、清算、结算环节的运营管理平台，全面管理平台的资金流转过程。
在拥有自己的支付清结算系统之后，不但保证了用户能便捷的完成线上支付，还能按照既定规则将资金快速、准确结算到不同的业务收款人。同时平台账户的资金放在合作银行中，平台为用户和商户开设的虚拟账户中的资金仍旧在平台大账户中，只有用户提现了之后，资金才真正转移到用户的银行卡中，平台就可以利用资金沉淀实现更多的收益。
三种资金系统方案的特点对比 提供产品的方式
当平台有业务调整或新增业务时，相关的支付清结算也会需要调整，但平台作为第三方支付的一个客户时，很难根据平台的业务做调整。而自建的系统，平台可随时任意的对系统进行修改以配合业务的变化，可以通过产品的调整，带来更好的用户体验。
使用第三方支付的服务，平台的用户数据、交易数据等都存放在第三方支付这里，难以保证平台数据的保密性和安全性。自建网关或系统的话，所有数据都属于平台，但可能由于没有成熟的运营管理工具，很难充分将收集到的数据进行利用。通过成熟的支付清结算系统，则可以有效管理运营数据，并充分进行分析和利用。
系统的可控性
使用第三方支付提供的服务完全受限于单一第三方支付的稳定性和支付规则，当第三方支付出现问题无法支付时，平台将束手无策，另外第三方支付通用的支付限制可能无法满足平台业务的需要。
自建网关或支付清结算系统的话，平台能自主掌控支付过程，给用户更好的支付体验。
自建支付清结算系统不仅能有效保障支付成功率，还能根据用户的支付习惯优化收银台的展示、提供更多的账户增值服务等。
资金沉淀与用户忠诚度
三种资金系统方案资金流有所不同，其中自建平台的沉淀时间以及可控性最强，具体流程以及资金沉淀时间如下图所示： 平台若提供给用户的只是支付功能，用户与平台没有资金的直接联系，无法建立长效的客户关系；平台如果提供给用户一个钱包账户，用户在平台的钱包中有资金沉淀、各类优惠券的整合等，会提高用户在平台的忠诚度和粘度。
清结算方式的便捷性
不管是接入第三方支付还是自建网关，都需要平台清结算人员人工对各个渠道分别进行对账，且只能依托其提供的对账单，其数据的准确性难以完全保障，而自建系统，能够统一的对各个渠道的对账单与平台业务系统进行自动对账，提高效率。
平台在清算给商户货款时，若没有系统支持，只能通过财务人工转账打款给不同的商户，若通过账户清结算系统，则能通过系统自动实时清结算。
产生手续费的多少
一般主流的第三方支付费率都较高，当业务量大时，手续费用也是一笔可观的支出，若通过支付网关，接入多个渠道，某些银企直连渠道费率较低。
当财务每次进行商户结算时需要人工转账，会涉及到大量的跨行转账，若通过支付清结算系统，商户只有在提现的时候才会进行平台出款操作，能减少出款的次数（原来是按结算周期定时结算给商户，有了账户后，商户可能会积累一定的金额才提现一次），也就相应的能减少跨行手续费。
金融业务的拓展
使用第三方支付的服务，只能对接其能提供的金融服务，提供的服务不一定能满足平台的需求；自建网关的话，只提供支付渠道的服务，无法提供其他金融服务；若自建系统，则能够自由对接所需的各种金融业务。
由于自建系统的灵活性和可扩展性，能够方便的拓展金融账户支持金融业务的开展，并实现无缝对接。
资金系统方案的选择 如果平台处于业务拓展初期，交易量少，需要迅速上线支付功能，接入第三方支付是比较好的需求，即使在支付渠道以及可控性方面不具优势，但快速方便的特点可以满足基本需求。
如果平台业务量较大，手续费较高，想增强对支付渠道的可控性，自建支付网关，对接更多支付渠道就能实现。
如果平台业务量已形成一定规模，想增强可控性的同时能带给用户和商户更好的体验，并要拓展其他业务，那就很有必要拥有一套灵活、成熟、强大的支付清结算系统来支撑平台的业务发展。
然而随着企业和平台的发展，从初期较小的业务量，势必会逐渐形成一定的规模，并对场景内金融产生更大的需求。其实所谓场景金融应该是“业务场景”发展到一定阶段的必然衍生，是主动产生的，即使不用去刻意寻求，刻意讨论，等发展到了一定程度之后会自然成为业务生态的一部分。
从平台的发展初期到场景金融的产生、完善，资金系统一直作为整个发展过程中的基础支撑。在早期，可能由于业务量小、服务面较窄等原因，资金系统的重要性没有凸现出来，但发展到了一定阶段之后，资金系统的作用就会逐渐显现，而建设自有支付清结算系统可谓是必然趋势。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/119/">«</a>
	<span class="pagination__item pagination__item--current">120/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/121/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>