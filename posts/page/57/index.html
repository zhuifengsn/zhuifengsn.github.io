<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f75f08d649737ab7bb8a6394b9f3f1f/" rel="bookmark">
			资源管理器占用CPU过高的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时我们在打开资源管理器的时候，发现cpu占用特别的高，这个是怎么回事呢？cpu过高不仅会导致电脑的运行速度变慢，还会加速硬件的使用年限，这种情况一般是后台运行的程序过多，具体的详情下面一起来看看吧。
资源管理器占用CPU过高的解决方法 一、重启Windows资源管理器
1、这个方法治标不治本，只能缓解，可能过一会就又会CPU占用过高，具体方法：同时按住Ctrl+shift+ESC打开任务管理器。
2、因为我的问题已经解决，所以可以看到CPU占用很少，原来占用80%多，现在选中Windows资源管理器，重启Windows资源管理器如下：
3、重启以后会重新加载资源管理器，我们可以看到CPU使用率已经慢慢降下来，上面也说这只是暂时一个解决办法。
4、重要提示：我们可以在CPU这一栏中看到每个软件占用的CPU，如果哪个软件占用较大，选中软件然后结束任务或者直接卸载软件即可，卸载之后重启系统，如果这个解决了那么接下来的步骤可以适当参考，没有解决则继续操作。
二、禁用cotana(小娜) + 禁用问题收集服务
1、禁用cotana(小娜) + 禁用问题收集服务基本上可以解决问题，不会出现反复，但是也不绝对，只能说如果这个都解决不了，那么只有看后面的终极解决方案。
2、首先win + R打开运行框并输出如下打开本地组策略：
3、依次展开。
4、在Windows组件下找到搜索，单击，可以看到右边有三个cotana选择，我们需要将这三个禁用。
5、在右边的选项上双击，弹出选项框，选择禁用，再点击确认。
接下来就是禁用问题收集服务
1、win + R打开运行框并输出services.msc，然后点击确定打开服务。
2、然后在本地服务中找到以下三个服务按照下列方法依次禁用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d289ce6067fd6150708cad308f2391c/" rel="bookmark">
			java操作liunx命令，实现文件内容追加与删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 简略总结一下：
给文件追加一行文本（注意不要忽略空格）
String[] shellMessage = {"/bin/sh", "-c", "echo " + "文本内容 &gt;&gt; 文件路径"}; Runtime.getRuntime().exec(shellMessage); 删除文件中包含某个字符串的行（注意不要忽略空格）
String[] shellMessage = {"/bin/sh", "-c", "sed -i '/字符串/d' 文件路径"}; Runtime.getRuntime().exec(shellMessage); 精确匹配删除该文本所在的行，（shell命令）
sed -i '/\&lt;字符串\&gt;/d' 文件路径 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf2e99b7f7b6db85387641032f8f80a3/" rel="bookmark">
			Spring的@Bean注解原理详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. @Bean注解的作用 这是一个我们很常用的注解，作用是指示一个方法生成一个由Spring管理的Bean。 之前的文章都是使用的xml或者自定义形式的项目研究的，本篇是讲注解的，所以直接使用最简单的SpringBoot项目了，版本号：2.3.12.RELEASE
本篇就已这个例子进行分析@Bean注解的实现方式
二. 先了解BeanFactoryPostProcessor BeanFactoryPostProcessor和BeanPostProcessor是不是一样的，关于BeanPostProcessor可以看这篇：Spring的BeanPostProcessor分析，千万别把两个搞混了。
BeanFactoryPostProcessor源码：
@FunctionalInterface public interface BeanFactoryPostProcessor { /** * 在标准初始化之后修改应用程序上下文的内部 bean 工厂。所有 bean 定义都将被加载，但还没有 bean 被实例化。 * 这允许覆盖或添加属性，甚至是急切初始化的 bean。 */ void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException; } Spring IoC容器允许BeanFactoryPostProcessor在容器实例化任何bean之前读取bean的定义(配置元数据)，并可以修改它或者实现bean动态代理等。同时可以定义多个BeanFactoryPostProcessor，通过设置’order’属性来确定各个BeanFactoryPostProcessor执行顺序。
与BeanFactoryPostProcessor相关的两个很重要的类：
BeanDefinitionRegistryPostProcessor 这个接口是对BeanFactoryPostProcessor的进一步扩展，其中的postProcessBeanDefinitionRegistry方法可以对BeanDefinition做更多的定义ConfigurationClassPostProcessor 这个类实现了BeanDefinitionRegistryPostProcessor，具体的实现了对Bean的扫描和BeanDefinition的修改 三. 源码分析 @Bean注解是在的org.springframework.context.support.AbstractApplicationContext#refresh方法中被加载的，具体是在org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors方法中被扫描到的，关于refresh方法就不再做过多描述了，不了解的同学可以看Spring栏目里面的文章进行了解。
首先来看refresh方法中的invokeBeanFactoryPostProcessors这一步：
// Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); 这个方法主要作用就是根据反射机制从BeanDefinitionRegistry(bean定义注册中心)中找到所有实现了BeanFactoryPostProcessor接口bean，并调用其postProcessBeanFactory（）接口方法， 其实就是对Bean定义的增强/修改，同时也是一个非常有效的扩展点。跟进这个方法：
public static void invokeBeanFactoryPostProcessors( ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) { //一开始进来的时候，beanFactoryPostProcessors中有三个BeanFactoryPostProcessor的实现，这三个与本篇关系不大就不详细说了，感兴趣的同学可以自行断点查看 // Invoke BeanDefinitionRegistryPostProcessors first, if any.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf2e99b7f7b6db85387641032f8f80a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0523d83b33789bc1190d19474c580a1/" rel="bookmark">
			C&#43;&#43;创建型模式-工厂模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简单工厂模式 1.1 简单工厂模式 简单工厂模式（Simple Factory Pattern）专门定义一个类来负责创建其他类的实例，被创建的实例通常具有共同的父类。
简单工厂模式，是一种实例化对象的方式，只要输入需要实例化对象的名字，就可以通过工厂对象的相应工厂函数来制造你需要的对象。
1.2 简单工厂模式的角色 （1）Factory工厂角色（工厂类）：
工厂角色即工厂类，是简单工厂模式的核心，负责创建所有实例的内部逻辑，工厂类可以被外界直接调用，创建所需要的产品对象。
（2）Product（抽象产品角色）：
抽象产品角色是简单工厂模式所创建的所有对象的父类，负责描述所有实例所共有的公告接口。所创建的具体产品对象都是其子类对象。
（3）ConcreteProduct（具体产品角色）：
具体产品角色是简单工厂模式的创建目标。每个具体产品角色都继承了抽象产品角色，需要实现定义在抽象产品中的方法。
ProductA、ProductB和ProductC继承自Product虚拟类，Show方法是不同产品的自描述；Factory依赖于ProductA、ProductB和ProductC，Factory根据不同的条件创建不同的Product对象
依赖关系：箭头指向被依赖的一方
继承关系：
1.3 简单工厂模式的应用 在程序中，需要创建的对象很多，导致对象的new操作多且杂时，需要使用简单工厂模式；
由于对象的创建过程是我们不需要去关心的，而我们注重的是对象的实际操作，所以，我们需要分离对象的创建和操作两部分，如此，方便后期的程序扩展和维护。
1.4 简单工厂模式的优缺点 优点：
本着高内聚低耦合的原则，将系统的逻辑部分和功能分开。
缺点：
简单工厂模式会增加系统类的个数，在一定程度上增加了系统的复杂度和理解难度；系统扩展难，一旦增加新产品，就需要修改工厂逻辑，不利于系统的扩展与维护；简单工厂模式中所有产品的创建都是由同一个工厂创建，工厂类职责较重，业务逻辑较为复杂，具体产品与工厂类之间耦合度高，严重影响了系统的灵活性和扩展性。 1.5 简单工厂模式实现 某电视机厂为各个品牌代工生产电视机，可以使用简单工厂的模式来实现。
#include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; typedef enum ProductTypeTag { Hair, Hisense, }PRODUCTTYPE; //抽象产品类 TV(电视机类) class TV { public: virtual void Show() = 0; virtual ~TV(){};//声明析构函数为虚函数，防止内存泄漏 }; //具体产品类 HairTV(海尔电视类) class HairTV : public TV { public: void Show() { cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0523d83b33789bc1190d19474c580a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2f3717d8660575047e93cc115d7ae25/" rel="bookmark">
			勒索病毒现状和防御勒索病毒最佳实践（云端和线下个人电脑，服务器都可部署）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是勒索病毒? 勒索病毒，是伴随数字货币兴起的一种新型病毒木马，通常以垃圾邮件、服务器入侵、网页挂马、捆绑软件等多种形式进行传播。一旦遭受勒索病毒攻击，将会使绝大多数的关键文件被加密。被加密的关键文件均无法通过技术手段解密，用户将无法读取资产中的文件，仅能通过向黑客缴纳高昂的赎金，换取对应的解密私钥才能将被加密的文件无损的还原。黑客通常要求通过数字货币支付赎金，一般无法溯源。
如果关键文件被加密，企业业务将受到严重影响；黑客索要高额赎金，也会带来直接的经济损失，因此，勒索病毒的入侵危害巨大。不过现在也可以通过专业的解密机构对数据进行解密，但是解密的费用也是很贵的，为了防患未然，防止被勒索，可以提前做好防护，减少损失和不必要的麻烦。
2022年勒索病毒的现状 此数据引用SOPHOS安全公司的调查研究，对31个国家中的中等规模组织的公司的5600名IT专业人员进行了一项独立的调查。
去年66%的组织受到勒索软件的攻击，比前一年增加了78%，65%的攻击导致数据被加密。
99%的攻击者拿到了客户的一些数据，调查发现大部分用于恢复加密数据的方法是备份，46%的公司支付赎金来取回数据，平均只有61%的加密数据支付赎金后被恢复，只有4%的人付了赎金才取回所有数据。
勒索软件对公司的业务的影响，90%的勒索软件攻击影响了他们的核心业务，86%的勒索软件攻击造成业务/收入损失。所以只有备份不是唯一的解决办法，要结合主机安全+备份+防篡改+专用的防勒索软件等一套防护才能真正防御。
防御勒索病毒最佳实践 工作原理
防勒索病毒是一个长期而持久的过程，华为云HSS事前（安全加固）、事中（主动防御+SOPHOS-XDR防病毒勒索软件）、事后（备份恢复）三部曲，为您抵挡勒索病毒入侵，营造主机资产安全运行环境。
XDR(Extended detection and response)扩展检测和响应，主要针对计算机实时访问的internet扫描还有文件，以及勒索病毒专用防护，有很强劲的功能。
事前：安全加固安装HSS软件，云上和线下物理机器都可以安装。
配置安全基线
HSS每日凌晨自动检测系统中关键软件的配置风险并给出详细的加固方法。您可以根据给出的加固建议，正确处理主机内的各种风险配置信息。
HSS支持检测的软件类型：Tomcat、SSH、Nginx、Redis、Apache 2、MySQL 5。
在页面左上角选择“区域”，单击
，选择“安全与合规 &gt; 企业主机安全”，进入企业主机安全平台界面。
在界面左上角单击“体验新版”，进入云工作负载保护平台（主机安全+容器安全）页面。
选择“风险预防 &gt; 基线检查 &gt; 配置检查”页签，查看配置检查详情。
图1 进入配置检查页面
单击基线名称，进入基线检查详情页面，单击目标检查项“操作”列的“检测详情”，您可以根据“审计描述”验证检测结果，根据“修改建议”处理主机中的异常信息，从而加固配置基线。
图2 查看检查详情
完成配置项的修复后，建议您立即执行手动检测，查看配置项修复结果。如果您未进行手动验证，HSS会在次日凌晨执行自动验证。自动验证完成后，您可查看配置项修复结果。
加固弱密码
HSS每日凌晨自动检测主机中使用的经典弱口令和您添加的自定义弱口令。您可以根据检测出的弱口令对应的弹性云服务器名称、账号名、账号类型和弱口令使用时长，加固弱密码。
HSS支持检测MySQL、FTP及系统账号的弱口令。
1.在页面左上角选择“区域”，单击
，选择“安全与合规 &gt; 企业主机安全”，进入企业主机安全平台界面。
2.在界面左上角单击“体验新版”，进入云工作负载保护平台（主机安全+容器安全）页面。
3.选择“风险预防 &gt; 基线检查 &gt; 配置检查”页签，查看经典弱口令检测。
图3 进入经典弱口令检测页
4.自定义弱口令。进入“策略管理”页面，配置指定策略组的“弱口令检测”，添加自定义弱口令。
图4 自定义弱口令
5.完成弱密码加固后，建议您立即执行手动检测，查看弱密码加固结果。
如果您未进行手动验证，HSS会在次日凌晨执行自动验证。自动验证完成后，您可查看弱密码加固结果。
6.进入“告警通知”页面，勾选“告警等级”的所有选项，一旦检测出弱口令，您将会收到告警通知。
图5 设置告警
事中：主动防御
手段一：病毒云查杀+使用智能学习策略防御勒索病毒（旗舰版）
HSS提供隔离查杀功能，将已感染主机迅速采取隔离措施防止病毒扩散蔓延。
在页面左上角选择“区域”，单击左侧菜单栏，选择“安全与合规 &gt; 企业主机安全”，进入企业主机安全平台界面。
在界面左上角单击“体验新版”，进入云工作负载保护平台（主机安全+容器安全）页面。
进入“安全告警事件”页面，查看并处理“恶意程序（云查杀）”告警事件。
图8 进入恶意程序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2f3717d8660575047e93cc115d7ae25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1129d1bcdead9e9f0694005480c86d0e/" rel="bookmark">
			springboot：bean常用初始化方法与销毁执行方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：Bean初始化执行方法 通过在方法名上添加@PostConstruct执行通过实现InitializingBean接口中的afterPropertiesSet()执行 通过@Bean(initMethod = "init3")执行 @Slf4j public class Bean1 implements InitializingBean { @PostConstruct public void init1(){ log.debug("初始化1"); } @Override public void afterPropertiesSet() throws Exception { log.debug("初始化2"); } //通过@Bean(initMethod = "init3") public void init3(){ log.debug("初始化3"); } } @Configuration public class BeanConfig1 { @Bean(initMethod = "init3") public Bean1 bean1(){ return new Bean1(); } } 执行顺序也是如上：
先执行@PostConstruct修饰的方法
第二步执行实现InitializingBean接口中的afterPropertiesSet()
第三步执行@Bean(initMethod = "init3")指定的方法
二：Bean销毁执行的方法 通过在方法名上添加@PreDestroy执行通过实现DisposableBean接口中的destroy()执行 通过@Bean(destroyMethod = "destroy3")执行 @Slf4j public class Bean2 implements DisposableBean { @PreDestroy public void destroy1(){ log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1129d1bcdead9e9f0694005480c86d0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/109f20a97a254e2a26548b533a579261/" rel="bookmark">
			基于状态机的按键扫描程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、简介二、程序代码1.扫描俺键2.获取键值 三、IndependentKey.h程序代码 前言 一开始在执行按键扫描是都会使用延时来进行消抖，使用这种方式的消抖会严重的浪费单片机的性能，这里介绍使用使用有限状态机的方式来扫描按键。
一、简介 按键扫描的消抖一般会延时10ms，按键扫描程序的状态一般分为：
状态一、判断按键是否按下，如果按下则跳转到状态二。
状态二、再次判断按键是否按下，如果有就跳转到状态三，否则跳转到状态一。
状态三、等待按键释放，并累加时间判断是否是长按，如果超过设置的长按的时间，跳转到状态四，否则跳转到状态一，并返回键值。
状态四、继续累加长按时间，连续触发按键并返回键值，否则跳转到状态一。
二、程序代码 1.扫描俺键 /** * @brief 获取IO口的值 * @param * @retval */ static uint8_t IndependentKey_Get(void) { uint8_t key = 0x00; if(HAL_GPIO_Read(&amp;KEY1)) key = 0x01; else if(HAL_GPIO_Read(&amp;KEY2)) key = 0x02; else if(HAL_GPIO_Read(&amp;KEY3)) key = 0x04; else if(HAL_GPIO_Read(&amp;KEY4)) key = 0x08; return key; } 2.获取键值 /** * @brief 扫描按键 * @param * @retval 约定返回的低8位为按键按下的编号，高8位bit0为长按标志 */ uint16_t IndependentKey_Scan(void) { static uint8_t state = 0; static uint16_t clickTime = 0; static uint16_t keyValue;//按键值 uint16_t tempKeyValue = 0;//临时按键 uint16_t reValue = 0;//返回值 tempKeyValue = IndependentKey_Get();//获取键值 switch (state) { case 0://状态0 等待按键按下 if (tempKeyValue !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/109f20a97a254e2a26548b533a579261/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddc66fa5fa4a9f92a0e2eafa687ea101/" rel="bookmark">
			C# 如何使用SunnyUI并且在工具箱中添加SunnyUI控件(VS 2019)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载SunnyUI 这里建议下载源码，源码中有需要的一些图片
SunnyUI码云地址
在我们创建的winform项目中，右键引用-管理NuGet程序包
然后搜索SunnyUI，选择SunnyUI进行安装
然后右键项目生成
在VS中点击视图-工具箱
在工具箱的空白处右键-添加选项卡-命名为SunnyUI，当然你也可以自己命名自己喜欢的名字
右键SunnyUI-选择项
点击浏览，因为我们之前已经提前添加应用并且生成了，所以在bin文件夹中会有一个SunnyUI.dll文件，我们添加这个文件。
点击确定我们即可在工具箱中看到我们添加的SunnyUI组件。
使用SunnyUI 如果你下载了源码，我们可以再源码中选中自己喜欢的控件，比起工具箱更加的直观，选择好控件我们选择复制到我们自己的项目中即可。
例如
我选中源码中的Save按钮，右键复制然后在我们自己的项目中粘贴
当然，第一次是没有前面的图片的，是一个感叹号，是因为我们没有把源码中的资源文件导入到我们自己的项目中，所以我们需要进行一个资源的导入。
右键我们粘贴过来的按钮，选择属性-Image属性-导入源码中的图片文件（在源码中的Resources中）
选择好图片即可，其他的控件操作类似。
如果对你有帮助希望点个赞，谢谢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8c66585d6a17e757a376f2dd22e2925/" rel="bookmark">
			数组元素去重
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过stream流的方式实现数组元素去重 思路 数组元素去重，有很多实现方法，今天在网上找了一些，感觉都不尽人意，很多都是通过遍历去重的方式，感觉不爽哈哈。然后想到个思路，大家应该都知道Set集合的元素不可重复的特性哈，那么就用这个特性搞一下试试呢。把数组转成Set集合，然后再把Set集合转换回数组，这样不就实现去重了吗。然后我就去idea里写demo了，写完发现有个标黄提醒，也没多想，直接让idea给优化转换一下，叮！！出现了个方法：distinct()！！！我怎么把这个给忘了！Stream流中有现成的去重哇，唉，java8的stream流平时用的太少了，后面慢慢充电吧。。。 好了，话不多说，直接上代码，一行搞定！ String[] arrays = {"12","32","2","32","8"}; arrays = Arrays.stream(arrays).distinct().toArray(String[]::new); 最后我列举一下我找到网上其他的去重方法，大家参考选择使用
https://baijiahao.baidu.com/s?id=1718543916733785683&amp;wfr=spider&amp;for=pc
https://blog.csdn.net/weixin_47604272/article/details/108586538
https://blog.csdn.net/java_long_asus/article/details/88315385
…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc71b136013ea96c048ff26e87ca7c99/" rel="bookmark">
			实现validation注解进行校验枚举值工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 编写注解 @Target({ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME) @Constraint(validatedBy = EnumConstraintValidator.class) public @interface Enum { char[] value(); String message() default "对应值非枚举字符属性"; Class&lt;?&gt;[] groups() default { }; Class&lt;? extends Payload&gt;[] payload() default { }; } 说明：
@Target：该注解的作用域，我们仅针对于字段进行使用，所以为：ElementType.FIELD@Retention：整个注解的生命周期，填写整个运行时生命周期RetentionPolicy.RUNTIME，不会吃亏的@Constraint(validatedBy = EnumConstraintValidator.class)：该注解由谁去实现，具体的实现在EnumConstraintValidator类中value()：存放用户自定义的char枚举值 2.编写validatedBy实现类 public class EnumConstraintValidator implements ConstraintValidator&lt;Enum,Character&gt; { private char[] verification; @Override public void initialize(Enum anEnum) { verification = anEnum.value(); } @Override public boolean isValid(Character value, ConstraintValidatorContext constraintValidatorContext) { if(verification==null){ return true; } for(char c:verification){ if(value ==c){ return true; } } return false; } } 说明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc71b136013ea96c048ff26e87ca7c99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/422b3afb5e5ae9f5151fa38921916e60/" rel="bookmark">
			全局异常捕获工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.test.commons.exception; import com.alibaba.fastjson.JSONObject; import com.epro.commons.response.ArgumentCode; import com.epro.commons.response.ResponseResult; import lombok.extern.slf4j.Slf4j; import org.springframework.util.StringUtils; import org.springframework.validation.BindException; import org.springframework.validation.BindingResult; import org.springframework.validation.FieldError; import org.springframework.validation.ObjectError; import org.springframework.web.bind.MethodArgumentNotValidException; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.RestControllerAdvice; import javax.validation.ConstraintViolation; import javax.validation.ConstraintViolationException; import java.util.*; /** * @author * @description: TODO * @date 2021/11/3 10:43 */ @RestControllerAdvice @Slf4j public class RestExceptionHandler { /** * 处理Get请求的验证异常 * * @param result * @return com.flyduck.cms.vo.ApiResult */ @ExceptionHandler(BindException.class) public ResponseResult bindExceptionHandle(BindingResult result) { if (result.hasErrors()) { List&lt;ObjectError&gt; errors = result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/422b3afb5e5ae9f5151fa38921916e60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9180de082d4b12297e8029e73b1c84a/" rel="bookmark">
			LCD1602液晶显示屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍：LCD1602液晶显示屏是一种字符型液晶显示模块，可以显示ASCll码的标准字符和其他一些内置的特殊字符，还可以内置8个自定义字符。
显示容量：16✖2个字符，每个字符为5*7点阵或5*10点阵
一、引脚介绍：
VO：对比度调节电压
RS：数据 / 指令选择，1为数组，0为指令
RW：读 / 写选择，1为读，0为写
E：数据使能，下降沿执行命令
D0~D7:数据的输入 / 输出
A：背光灯电源正极
K：背光灯电源负极
二、存储器结构：D2RAM（数据显示区）和G2RAM、G2ROM（内置字模库）
D2RAM（数据显示区）
G2RAM、G2ROM（内置字模库） 三、LCD1602显示指令集
四、时序结构：
写指令/数据
读指令/数据
五、模块函数化集成使用：
代码：
void LCD_WriteCommand(unsigned char Command) //写指令 { LCD_RS=0; LCD_RW=0; // 指令 写 LCD_DataPort=Command; //并口：可以直接发送8位 LCD_E=1; LCD_Delay1ms(); LCD_E=0; LCD_Delay1ms(); } 代码：
void LCD_WriteData(unsigned char Data) //写数据 { LCD_RS=1; LCD_RW=0; //数据 写 LCD_DataPort=Data; //并口：直接发送8位 LCD_E=1; LCD_Delay1ms(); LCD_E=0; LCD_Delay1ms(); } 代码：
/** * @brief LCD1602初始化 * @param 无 * @retval 无 **/ void LCD_Init() { LCD_WriteCommand(0x01); //清屏 LCD_WriteCommand(0x0C); //显示开，光标关，闪烁开 LCD_WriteCommand(0x06); //数据读，写操作后，AC自动＋1，画面不动 LCD_WriteCommand(0x38); //八位数据接口，两行显示，5✖7点阵 } 代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9180de082d4b12297e8029e73b1c84a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61f7f3abe4ef5b050dbcc4e8133413e8/" rel="bookmark">
			SQL知识梳理（五）常用函数（聚合、条件、窗口）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL常用函数 一、聚合函数1、 用处2、 常用的聚合函数3、注意 二、 条件判断-case when1、用处2、语法3、使用场景 三.条件判断-if函数1、用处2、语法 四、窗口函数1、用处2、语法：3、 常见窗口函数4、MySQL排序窗口函数的区别 一、聚合函数 1、 用处 聚合函数常和分组计算group by语句结合使用，对数据分组后执行计算并为每组返回唯一值。
2、 常用的聚合函数 COUNT()，SUM()，AVG()，MIN()，MAX()。
COUNT()：计数，返回每组的行数,也会返回有NULL值的列，可用于数字和字符列。
SUM()：返回每组数值的总和，忽略NULL值，仅用于数字列。
AVG()：返回每组数值的平均值，忽略NULL值，仅用于数字列。
MIN()：返回每组数据的最小值，忽略NULL值，可用于数字、字符和日期时间列。
MAX()：返回每组数据的最大值，忽略NULL值，可用于数字、字符和日期时间列。
3、注意 聚合函数不能用在where语句中，需要用在having语句中进行过滤。
原因是SQL语句执行顺序为from 、on 、join 、where 、group by(开始使用select中的别名，后面的语句中都可以使用)、 聚合函数… 、having 、select 、distinct 、order by、limit，
聚合函数是在分组之后进行计算，而分组是where语句过滤完数据后才进行分组，因此如果在where语句中使用聚合函数，还未分组无法进行统计计算，程序会报错。
二、 条件判断-case when 1、用处 利用现有字段，根据条件语句，生成新字段。
2、语法 ① case id when 0 then '学生' when 1 then '学生' when2 then '老师' else '其他' end as identification ② Case when id in (0,1) then '学生' When id = 2 then '老师' Else '其他' end as identification 注意：end关键词不可省
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61f7f3abe4ef5b050dbcc4e8133413e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f22bbd3f84217fd61a8185258960b74/" rel="bookmark">
			【计算机网络】计算机网络概述（湖科大教书匠第一章笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.2 因特网概述 网络、互联网和因特网 网络(Network)：网络=结点(Node)+链路(Link)
结点可以是计算机（电脑，服务器），网络互连设备（路由器，交换机），其他具有网络功能的设备（打印机）
链路可以是有线或无线
互联网(Network of networks)：多个网络由路由器相连，构成更大的网络
因特网(Internet)：是世界上最大的互连网络，因特网常用一朵云来表示
主机(host)：连接在因特网的各种通信设备
internet和Internet的区别：
internet是一个通用名词，泛指由多个计算机网络互联而成的网络，它们之间可以使用任意的通信协议作为通信规则Internet是一个专用名词，特指当前全球最大、开放的由众多网络互相连接而成的计算机网络，它们之间必须采用TCP/IP协议作为通信规则 因特网发展的三个阶段 因特网服务提供者ISP(Internet Service Provider)：提供给用户IP地址的角色，每个用户通过ISP提供的IP地址使用互联网，没有IP地址不可以使用互联网。
基于ISP的三个结构互联网
层级名称范围用户说明第一层主干网(Internet backbone)国际性区域范围第二层ISP+少部分大公司拥有告诉链路+交换设备第二层-区域性/国家性范围第三层ISP-第三层本地ISP本地范围校园网/企业网/住宅用户/无线移动用户等- 一个ISP可以在因特网的拓扑上增添新层次，分支。如某个用户接入因特网，那么他也可以成为一个ISP，只需要购买调制解调器/路由器相隔较远的两台主机间的通信经过多个ISP 因特网的标准化工作 因特网的组成 从功能上分为两个部分
边缘部分：由所有连接在因特网上的主机组成。这部分是用户直接使用的，用来进行通信和资源共享。核心部分：由大量异构型网络和连接这些网络的路由器组成。这部分是为边缘部分提供连通性和数据交换服务，确保通信和资源共享功能的实现。
1.3 三种交换方式 电路交换 引入：
如果电话之间两两相连，那么随着电话数量增加电话之间的线也阶乘次增长，线的数量为 n ( n − 1 ) / 2 n(n-1)/2 n(n−1)/2，而设计为电话交换机线的数量为 n n n，大大减少了电话之间的线的数量。
电路交换(Circuit Switching)：电话交换机接通电话的方式
从通信资源的分配角度来看，交换(Switching)就是按照某种方式动态地分配传输线路地资源电路交换的三个步骤： 建立连接：分配通信资源通话：一直占用通信资源释放连接：归还通信资源
分组交换 分组交换(Packet Switching)分组交换的过程（以H6——&gt;H2发送信息为例） 发送：H6主机发送一段报文（把表示信息的整段数据称为报文）给H2主机；分割：较长的报文被划分成更小的等长的数据段；加头：在每个数据段前加上控制信息组成的首部；
这样的信息构成分组/包，其中首部也称为包头暂存+转发：分组交换机收到分组，先暂存，检查首部，查表转发；去头+还原：H2主机收到分组，去掉其首部，将各数据段组合还原出原始的报文 【说明】以上过程只写了两种情况：
① 各分组从源到目的地有不同的路由（不同的路径）
② 分组乱序：分组从源到目的地出发顺序不一定与分组到达目的地接受顺序一致，顺序不一致的情况可能会出现分组丢失/误码/重复等特殊情况
角色作用发送方构造分组、发送分组路由器暂存分组、转发分组接收方接受分组、还原报文 报文交换 报文交换(Message Switching)：与分组交换过程差不多，但是报文的大小不受限制 三种交换的对比 【说明】横坐标为时间
1.4 计网的定义与分类 定义 精确定义：暂无简单定义：相互连接的，自治的计算机的集合
互连：计算机之间通过有线/无线的方式相互连接进行数据通信
自治：计算机有自己的软/硬件，可以独立运行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f22bbd3f84217fd61a8185258960b74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1891f42291bacd876b042764c3cfdcc5/" rel="bookmark">
			Win11老是提示资源管理器已停止工作怎么解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资源管理器是Windows 系统提供的资源管理工具，我们可以用它查看本台电脑的所有资源，还可以对文件进行各种操作，如：打开、复制、移动等。但是近期有部分用户在电脑的使用中老是出现系统提示Windows资源管理器已停止工作，失去响应，对此有没有什么方法解决呢？我们一起来看看下面这篇解决教程吧。
新手小白怎么重装Win11系统
方法一：常规操作，修复或重置系统
sfc命令
命令提示符中，输入并按回车执行【sfc /scannow】 命令，该命令主要是用来修复系统文件的，不管是系统文件缺失，或损坏都可以修复。
dism命令
命令提示符中，输入并按回车执行【DISM /Online /Cleanup-Image /CheckHealth】命令，该命令可以用来修复Windows系统镜像、安装程序、恢复程序和PE系统。
方法二：尝试卸载最近一次的系统更新
只要在开机时强制关闭电脑，连续操作3次，Win11会自动引导至高级启动
1、点击【疑难解答（重置你的电脑或查看高级选项）】；
2、点击【高级选项】；
3、高级选项下，点击【卸载更新（从 Windows 中移除最近安装的质量更新或功能更新）】；
4、选择一个选项，分别有【卸载最新的质量更新（一般是修复BUG、优化方面的小更新）】和【卸载最新的功能更新（版本更新）】；
卸载最新的质量更新，或卸载最新的功能更新后，说不定问题就解决了。
大家有什么问题尽管问。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3026293b9f3416a1510a344366e31141/" rel="bookmark">
			Win10 Word背景默认是绿色的怎么取消？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win10 Word背景豆绿色怎么取消？一些朋友发现自己打开word文档，默认背景是绿色的，虽然有很多用户喜欢，但是也有很多朋友不喜欢这样，大家想知道如何取消豆沙绿背景，下面我教大家win10取消豆绿色背景的具体方法，这其实跟window默认背景颜色设置有关。
Win10稳定装机版系统镜像
解决方法：
1、在桌面的左下角找到开始按钮，用鼠标右键点击它，选择【运行】。
2、输入运行内容【regedit】点确定。
3、依次点击HKEY_CURRENT_USER、Control Panel、Colors文件夹。然后在右边双击【Window】。
4、弹出窗口框，输入数值数据：255 255 255。最后点击确定。
也有可能是使用了360桌面助手的护眼模式导致背景颜色变了，只要关闭护眼模式的相关设置就行。
在桌面点击右键进入个性化设置，也可以重新设置窗口背景颜色。
因为这不是word软件的问题，而是系统设置的原因。
以上就是取消Win10 Word文档默认绿色背景的方法，希望对你有帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67290eb3f13c3438a15083d67d6e9252/" rel="bookmark">
			Java连接MySQL数据库相关操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一部分 JDBC简介 简介 JDBC的全称是Java数据库连接(Java Database connect)
JDBC本质是：接口 Java连接数据库的标准
不同的厂商为各自的数据库做好不同的JDBC驱动器可以实现JDBC访问数据库
例如
想要通过Java程序访问MySQL数据库，MySQL厂商要写好MySQL的JDBC驱动器
访问步骤 JDBC访问的步骤
加载驱动
创建连接
预处理器
执行语句
处理结果
关闭资源
准备工作
IDE
idea Mysql版本
Ver 8.0.27 相关资源 JDBC相关资源jar包
dom4j-2.1.1.jar HikariCP-4.0.3.jar lombok-1.18.24.jar mysql-connector-java-8.0.26.jar slf4j-api-2.0.0-alpha1.jar slf4j-simple-2.0.0-alpha0.jar spring-beans-5.3.22.jar spring-core-5.3.22.jar spring-jcl-5.3.22.jar spring-jdbc-5.3.22.jar spring-tx-5.3.22.jar 数据准备 # 创建数据库 create database test; ​ # 使用数据库 use test; ​ # 创建表 create table user ( id int auto_increment primary key, name varchar(20) null, password varchar(20) null, constraint user_id_uindex unique (id) ); ​ # 插入数据 insert into user (name,password)values('zs','123'); insert into user (name,password)values('ls','456'); 第二部分 连接MySQL数据库 连接MySQL数据库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67290eb3f13c3438a15083d67d6e9252/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e9928b6a790b6c34eb0e9347f55b9fd/" rel="bookmark">
			Windows11快捷键大全 win11常用快捷键介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		尽管Windows 10中支持的几乎所有快捷键在 Windows 11 中都保持不变，但微软古老操作系统的新版本也带来了许多新的快捷组合键。以下是Windows 11键盘快捷键列表，可帮助你快速导航桌面、命令提示符、文件资源管理器、辅助功能等。
Win11系统最新正式版镜像
一、Windows 11中的新键盘快捷键
Win+N 访问通知面板。
Win+A 打开快速设置面板。
Win+W 打开小部件。
Win+Z 打开 Snap 布局/模板。使用箭头键选择捕捉模板。
Win + 向上箭头 将活动窗口捕捉到显示器的上半部分。
Win + 向下箭头 将活动窗口捕捉到下半部分。
Win + 左/右箭头 将活动窗口捕捉到左/右半部分。
Win+C 打开 Microsoft Teams 聊天。
二、Windows 11中的Windows组合快捷键
按Win 键，它会显示开始菜单。但是，你可以使用Windows组合快捷键做很多事情。
Win 打开开始菜单。
Win+A 打开快速设置面板。
Win+E 打开文件资源管理器。
Win+F 打开反馈中心。
Win+J 启动语音输入。
Win+K 打开快速投射设置。
Win + Tab 打开任务视图。
Win + Ctrl + D 创建一个新的虚拟桌面。
Win + Ctrl + F4 关闭活动的虚拟桌面。
Win + Ctrl + 向左/向右箭头 按照创建的时间顺序在上一个和下一个虚拟桌面之间切换。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e9928b6a790b6c34eb0e9347f55b9fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/876b6ccb529d419374248723862bdd3b/" rel="bookmark">
			macOS录制系统声音及麦克风的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 系统自带Quicktime Player2. iShot Pro+驱动录制系统声音使用聚集设备使用软件提示的方法Tips 3. Filmage Screen+驱动录制系统声音总结 1. 系统自带Quicktime Player 首先下载系统声音录制驱动blackhole，2ch/16ch/64ch都可，一般用前两个就行了，具体参考：blackhole下载地址，安装之后前往在“audio midi setup”app中即可看到装好的驱动
创建聚集设备(Aggregate Devices),并勾选刚才下载的录制系统声音的驱动，以及想要录制的麦克风(也可以使用外置麦克风)，这个是在录制的时候软件要捕捉的声音，此处的“聚集”的含义就是聚集多个音频输入设备的音频来源。
创建多输出设备，也就是上一步中的Multi-output device,也就是让系统的声音同时输出到多个设备，即blackhole和系统扬声器（或者外置耳机）,这一步实际上是为上一步做铺垫，也就是说系统的声音先输出到Blackhole，然后再在录屏软件中（录制）聚集在blackhole中的声音，系统扬声器或者外置耳机只是为了让自己能听到系统声音。
“系统偏好设置-声音”中“输入”设置为系统内置麦克风(或者外置麦克风)，“输出”设置为刚才创建的多输出设备
command+shift+5打开系统自带的屏幕录制软件Quicktime player，点击录屏中的“选项”，在“麦克风”选项中选择刚才创建的聚集设备，聚集设备中有Blackhole和系统麦克风，此时录屏软件将来自这两个设备的音频源聚集，也就是录制这两个音频源中的音频信息，在上一步中输入为系统麦克风，因此有来自麦克风的声音；又将系统声音输出到Blackhole，因此此处aggregate device就可以将这两个来源的音频聚集，从而实现系统声音和麦克风同时录制。当然，要是不想录制系统麦克风的声音，可以在麦克风选项处将录制的来源选择为Blackhole 2ch。总结一下macOS录制系统声音的逻辑: 1. 将系统声音输出到多输出设备(驱动Blackhole以及耳机等)；2. 在录屏软件中聚集驱动中收集的系统声音及输入的麦克风声音。 2. iShot Pro+驱动录制系统声音 使用聚集设备 在录制屏幕时软件会提示安装插件，安装好插件之后也会自动生成ishot聚集设备，也就是聚集来自系统麦克风和系统声音录制驱动的音频；
选择ishot聚集设备，可以看见“录制系统声音选项”就不可选了，此时需要在“系统偏好设置-声音”选项中将“输出”设置为ishot聚集设备，这一步非常重要，要是在输出中不包含该聚集设备，就不能录制系统声音了；将“输入”设置为系统麦克风即可录制麦克风声音。注意此时因为系统声音没有输出到系统扬声器,因此听不到系统声音,录制结束之后系统声音和麦克风声音都能听到。这种方法不太推荐。
使用软件提示的方法 即使用界面上“Record System Audio”选项，并且选中使用的麦克风（如系统麦克风），此时其实ishot软件会自动创建一个multi-output device多输出设备,此时的录制原理和方法1相同，在录制的过程中将系统声音同时输出到驱动和系统扬声器，自己也能听到系统声音。注意此时你将输出设置为系统扬声器，而不是多输出设备，也能听到系统声音，因为此时的系统声音是从麦克风传进去的，**所以录制的声音其实是麦克风里面的声音，而不是真正系统的声音。**如果将系统扬声器和麦克风都替换为外置耳机，这种情况就听不到系统的声音了。
Tips 其实在录制视频和音频的过程中，直接使用系统内置的麦克风录制的话，可能会出现录制的系统声音有回音，因为录制过程中系统声音会传入系统麦克风，从而产生一个微小时间差，导致回音的出现。一种解决办法是用外置带有麦克风的耳机进行屏幕及音频录制，这样不仅没有杂音回声，效果还杠杠滴！（我试了好几款录屏软件都有这个问题）
3. Filmage Screen+驱动录制系统声音 其实这个软件和之前的方法几乎一样，只不过它录制系统声音的方法是直接选中“系统声音和麦克风”即可，要想使用外置耳机，就在“系统偏好设置-声音-输出”中选中外置耳机即可，“输入”可以选择外置内置麦克风。它在软件内部自动实现了上述过程，用户操作难度小。
另一种方法和方法2相同，使用聚集设备，也即下图中的Filmage聚集设备。在“系统偏好设置-声音-输出”中将其设置为Filmage Audio device也就是系统声音录制驱动，“输入”设置为麦克风。
总结 其实许多软件都和方法1那种原生的方法差不多，只不过它们集成很多功能，我在使用的过程中感觉做的比较好的录屏软件就是filmage和ishot，两者各有优缺点，前者能录制更高分辨率，而且还支持录制iOS设备屏幕，这个功能有时候还是挺香的；后者则集成了更多的功能，各种截图标注，置顶，OCR，录音录屏（分辨率也能接受，而且体积小），还能录制腾讯会议等，功能也十分强大。
着实是闲的d疼，hhh，竟然研究起了这个玩意儿，做个笔记，以后可能用得到，也为有Mac录屏困扰的小伙伴们提供点思路，上述方法亲测有效！走过路过，请小伙伴们点赞收藏备用哦~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9a72c876e624bbf1cf7c6af66fd20a7/" rel="bookmark">
			SQL语法之SQL UNIQUE 约束
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL学习 学习SQL语法 SQL语法 SQL学习SQL UNIQUE 约束SQL UNIQUE Constraint on CREATE TABLESQL UNIQUE Constraint on ALTER TABLE撤销 UNIQUE 约束 SQL UNIQUE 约束 SQL UNIQUE 约束
UNIQUE 约束唯一标识数据库表中的每条记录。
UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。
PRIMARY KEY 拥有自动定义的 UNIQUE 约束。
请注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。
SQL UNIQUE Constraint on CREATE TABLE 下面的 SQL 在 “Persons” 表创建时在 “Id_P” 列创建 UNIQUE 约束：
MySQL:
CREATE TABLE Persons ( Id_P int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255), UNIQUE (Id_P) ) SQL Server / Oracle / MS Access:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9a72c876e624bbf1cf7c6af66fd20a7/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/56/">«</a>
	<span class="pagination__item pagination__item--current">57/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/58/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>