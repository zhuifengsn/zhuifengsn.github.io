<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8993dc35cac8713af816102eb2ce9b8/" rel="bookmark">
			Linux驱动编程（总线设备驱动模型）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、驱动编写的3种方法 1、传统写法
使用哪个引脚，怎么操作引脚，都写死在代码中。最简单，不考虑扩展性，可以快速实现功能。修改引脚时，需要重新编译。
2、总线设备驱动模型
引入 platform_device/platform_driver，将“资源”与“驱动”分离开来，代码稍微复杂，但是易于扩展。冗余代码太多，修改引脚时设备端的代码需要重新编译，更换引脚时，上图中的 led_drv.c 基本不用改，但是需要修改 led_dev.c。
3、设备树
通过配置文件──设备树来定义“资源”。代码稍微复杂，但是易于扩展。无冗余代码，修改引脚时只需要修改 dts 文件并编译得到 dtb 文件，把它传给内核。无需重新编译内核/驱动。
二、在 Linux 中实现“分离”：Bus/Dev/Drv 模型 三、 匹配规则 1、最先比较
⚫ platform_device.driver_override 和 platform_driver.driver.name
可以设置 platform_device 的 driver_override，强制选择某个 platform_driver。
2、然后比较
⚫ platform_device. name 和 platform_driver.id_table[i].name
3、最后比较
⚫ platform_device.name 和 platform_driver.driver.name
4、函数调用关系
platform_device_register platform_device_add device_add bus_add_device // 放入链表 bus_probe_device // probe 枚举设备，即找到匹配的(dev, drv) device_initial_probe __device_attach bus_for_each_drv(...,__device_attach_driver,...) __device_attach_driver driver_match_device(drv, dev) // 是否匹配 driver_probe_device // 调用 drv 的 probe platform_driver_register __platform_driver_register driver_register bus_add_driver // 放入链表 driver_attach(drv) bus_for_each_dev(drv-&gt;bus, NULL, drv, __driver_attach); __driver_attach driver_match_device(drv, dev) // 是否匹配 driver_probe_device // 调用 drv 的 probe 四、常用函数 1、注册/反注册
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8993dc35cac8713af816102eb2ce9b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dc8398c87f17f0f37106ed54978c383/" rel="bookmark">
			Tomcat部署war包的方法（图文搭配讲解，亲测有效）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境
1、Tomcat：本次测试的版本为Tomcat8.5（Tomcat下载官网：Apache Tomcat® - Welcome!）；
2、war包：本次已在开发工具IDEA或Eclipse生成了war文件（JavaWebTest.war），若还不会在开发工具将项目打成war包的，请另行百度。
二、步骤
1、解压官网下载的Tomcat到任一目录下，然后将其war包JavaWebTest.war复制粘贴到apache-tomcat-8.5\webapps\ROOT\目录下（个人习惯，另外的目录理应也可以），如下图：
2、配置apache-tomcat-8.5\conf\server.xml文件
用记事本打开上述文件，并找到&lt;Host&gt;节点添加下面的代码，如下：
&lt;Context path="/car" docBase="C:\Users\Admin\Desktop\apache-tomcat-8.5.54\webapps\ROOT\JavaWebTest.war" reloadable="true"&gt;&lt;/Context&gt;
path：war包解压后的项目名称，也就是访问路径（例：http://localhost:8080/car/）
docBase：war包的路径（需要把war包的后缀名加上，如上图所示，避免报错）
reloadable：自动加载
3、保存上述修改后，双击apache-tomcat-8.5.54\bin\startup.bat启动Tomcat即可
启动成功，如下图，然后在网页地址栏输入http://localhost:8080/car/即可成功访问。
4、细心的你会发现启动Tomcat后，产生的日志有乱码的情况出现，不要慌，这并不影响你项目的正常运行。这是由于编码不一致引起的，Tomcat启动后默认编码UTF-8，而Windows的默认编码是GBK。因此你想让其不乱码，只需配置apache-tomcat-8.5.54\conf\logging.properties的编码格式即可，如下图：
修改保存后，重新启动Tomcat（即上述的步骤3），你会发现产生的日志是我们所能看懂的了
转载：
https://www.cnblogs.com/dongfangzhaoyue/p/16837497.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6202db0b04f005d6a819f72a25a2fcd2/" rel="bookmark">
			黑盒测试方法详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、等价类
1.关于等价类
2.等价类思想设计测试用例的步骤
二、边界值
1.关于边界点
2.使用边界值分析法设计测试用例步骤
三、因果图
1.关于因果图
2.关于判定表
3.使用因果图设计测试用例的步骤
1.分析所有可能的输入和可能的输出。
2.找出输入和输出之间的对应关系
4.将因果图转化称为判定表
5.把判定表对应到每一个测试用例
四、正交排列
1.什么是正交表
2.如何通过正交表设计测试用例
​五、场景设计法
1.什么是场景
2.如何通过场景设计法设计测试用例
六、错误猜测法
1.设计常见案例测试用例
（1）水杯测试用例设计（实体）
（2）微信发送朋友圈设计测试用例（软件的一个模块）
（3）完成一个登录的测试用例 2.一些测试的方法说明（面试考）
（1）Fiddler测弱网
（2）用postman进行接口测试
黑盒测试又称为功能测试，它是通过测试来检验程序的每个功能是否能正常使用。在测试中，将程序看成一个不能打开的黑盒子，在完全不考虑内部结构的情况下，在程序接口进行测试 ，检查程序是否能适当的接受输入数据从而产生正确的输出信息。
黑盒测试主要有以下测试用例设计方法：
1.等价类
2.边界值法
3.判定表法
4.正交排列法
5.场景设计法
6.错误猜测法
下面针对这几种方法进行介绍❤️❤️❤️。
一、等价类 1.关于等价类 依据需求将输入（特殊情况下会考虑输出）划分为若干个等价类，从等价类中选出一个测试用例，如果这个测试用例测试通过，则认为所代表的等价类测试通过，这样就可以用较少的测试用例达到尽量多的功能覆盖，解决了不能穷举测试的问题（作用）。
等价类分为：
有效等价类：对于程序的规格说明书是合理的、有意义的输入数据构成的集合，利用有效等价类验 证程序是否实现了规格说明中所规定的功能和性能。满足用户需求的输入集合。
无效等价类：根据需求说明书，不满足需求的输入集合。
价类只考虑输入域的分类，没有考虑输入域的组合，需要其他的设计方法和补充。
2.等价类思想设计测试用例的步骤 （1）充分理解需求
（2）设计测试用例：划分有效等价类和无效等价类
（3）从有效等价类中抽取其中一个数据进行设计测试用例；从无效等价类中抽取其中一个进行测试用例设计
比如那用户名长度来举例，设计用例如下图：
二、边界值 边界值分析法就是对输入或输出的边界值进行测试的一种黑盒测试方法。通常边界值分析法是作为对等价类划分法的补充，这种情况下，其测试用例来自等价类的边界。
1.关于边界点 边界值分析法中有一个很重要的概念：边界点
边界点分为：
上点：边界上的点
内点：边界内的点
离点：边界附近的一个点（闭区间：区间外距离上点最近的点，开区间：区间内距离上点最近的点）
针对边界点，通过画图来细说
闭区间上：
这里内点，是6~15中间所有的点，上图只列出一个。
开区间：
左开右闭：
左闭右开：
2.使用边界值分析法设计测试用例步骤 （1）充分理解需求
（2）找边界点（上点，内点，离点）
（3）针对边界点设计测试用例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6202db0b04f005d6a819f72a25a2fcd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b5490eb2c217b3fa097f80445d54b1e/" rel="bookmark">
			DS1302芯片介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		低功耗时钟芯片DS1302可以对年、月、日、时、分、秒进行计时，且具有闰年补偿等多种功能。
DS1302的性能特性：
·实时时钟，可对秒、分、时、日、周、月以及带闰年补偿的年进行计数；
·用于高速数据暂存的31×8位RAM；
·最少引脚的串行I/O；
·2.5～5.5V 电压工作范围；
·2.5V时耗电小于300nA；
·用于时钟或RAM数据读/写的单字节或多字节（脉冲方式）数据传送方式；
·简单的3线接口；
·可选的慢速充电（至VCC1）的能力。
DS1302时钟芯片包括实时时钟/日历和31字节的静态RAM。它经过一个简单的串行接口与微处理器通信。实时时钟/日历提供秒、分、时、日、周、月和年等信息。对于小于31天的月和月末的日期自动进行调整，还包括闰年校正的功能。时钟的运行可以采用24h或带AM（上午）/PM（下午）的12h格式。采用三线接口与CPU进行同步通信，并可采用突发方式一次传送多个字节的时钟信号或RAM数据。DS1302有主电源/后备电源双电源引脚：VCC1 在单电源与电池供电的系统中提供低电源，并提供低功率的电池备份；VCC2在双电源系统中提供主电源，在这种运用方式中，VCC1 连接到备份电源，以便在没有主电源的情况下能保存时间信息以及数据。DS1302由VCC1或VCC2中较大者供电。当VCC2大于VCC1+0.2V时，VCC2给DS1302供电；当VCC2小于VCC1时，DS1302由VCC1供电。
DS1302数据操作原理：
DS1302在任何数据传送时必须先初始化，把RST脚置为高电平，然后把8位地址和命令字装入移位寄存器，数据在SCLK的上升沿被输入。无论是读周期还是写周期，开始8位指定40个寄存器中哪个被访问到。在开始8个时钟周期，把命令字节装入移位寄存器之后，另外的时钟周期在读操作时输出数据，在写操作时写入数据。时钟脉冲的个数在单字节方式下为8加8，在多字节方式下为8加字节数，最大可达248字节数。
DS1302管脚图
如果在传送过程中置RST为低电平，则会终止本次数据传送，并且I/O引脚变为高阻态。上电运行时，在VCC &gt;=2.5V之前，RST脚必须保持低电平。只有在SCLK为低电平时，才能将RST置为高电平。内部结构图如下图所示，下表为各引脚的功能。
DS1302内部结构图
DS1302引脚功能表
DS1302的控制字如下图所示。控制字节的最高有效位（位7）必须是逻辑1；如果它为逻辑0，则不能把数据写入到DS1302中。位6如果为0，则表示存取日历时钟数据；为1表示存取RAM数据。位5～1（A4～A0）指示操作单元的地址。最低有效位（位0）如为0，表示要进行写操作；为1表示进行读操作。控制字节总是从最低位开始输入/输出。
控制字节的含义
为了提高对32个地址的寻址能力（地址/命令位1～5＝逻辑1），可以把时钟/日历或RAM寄存器规定为多字节（burst）方式。位6规定时钟或RAM，而位0规定读或写。在时钟/日历寄存器中的地址9～31或RAM寄存器中的地址31不能存储数据。在多字节方式中，读或写从地址0的位0开始。必须按数据传送的次序写最先的8个寄存器。但是，当以多字节方式写RAM时，为了传送数据不必写所有31字节。不管是否写了全部31字节，所写的每一字节都将传送至RAM。数据读写程序如下图所示。
数据读写程序 DS1302共有12个寄存器，其中有7个寄存器与日历、时钟相关，存放的数据位为BCD码形式，其日历、时间寄存器及其控制字见下表，其中奇数为读操作，偶数为写操作。
DS1302的日历、时钟寄存器及其控制字
时钟暂停：秒寄存器的位7定义位时钟暂停位。当它为1时，DS1302停止振荡，进入低功耗的备份方式。通常在对DS1302进行写操作时（如进入时钟调整程序），停止振荡。当它为0时，时钟将开始启动。
AM-PM/12-24[小]时方式：[小]时寄存器的位7定义为12或24[小]时方式选择位。它为高电平时，选择12[小]时方式。在此方式下，位5是AM/PM位，此位是高电平时表示PM，低电平表示AM，在24[小]时方式下，位5为第二个10[小]时位（20～23h）。
DS1302 的应用
实时时钟芯片DS1302采用串行数据传输，可为掉电保护电源提供可编程的充电功能，也可以关闭充电功能，芯片采用32768Hz晶振。要特别说明的是，备用电源BT1可以用电池或超级电容（10万μF以上）。虽然DS1302在主电源掉电后耗电很小，但如果要长时间保证时钟正常，最好选用小型充电电池。如果断电时间较短（几小时或几天），可以用漏电较小的普通电解电容代替（100μF就可以保证1小时的正常走时）[9]。DS1302在第一次加电后，需进行初始化操作。初始化后就可以按正常方法调整时间及闹铃。DS1302的时钟电路如下图所示。
DS1302时钟电路
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e50bfa190e07d28eb6f39d5e51e44d09/" rel="bookmark">
			一文深度讲解JVM 内存分析工具 MAT及实践（建议收藏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言
熟练掌握 MAT 是 Java 高手的必备能力，但实践时大家往往需面对众多功能，眼花缭乱不知如何下手，小编也没有找到一篇完善的教学素材，所以整理本文帮大家系统掌握 MAT 分析工具。
本文详细讲解 MAT 众多内存分析工具功能，这些功能组合使用异常强大，熟练使用几乎可以解决所有的堆内存离线分析的问题。我们将功能划分为4类：内存分布详情、对象间依赖、对象状态详情、按条件检索。每大类有多个功能点，本文会逐一讲解各功能的场景及用法。此外，添加了原创或引用案例加强理解和掌握。
如图所示：
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
为减少对眼花缭乱的菜单的迷茫，可以通过下图先整体熟悉下各功能使用入口，后续都会讲到。
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
2. 内存分布详解及实战
2.1 全局信息概览
功能：展现堆内存大小、对象数量、class 数量、class loader 数量、GC Root 数量、环境变量、线程概况等全局统计信息。
使用入口：MAT 主界面 → Heap Dump Overview。
举例：下面是对象数量、class loader 数量、GC Root 数量，可以看出 class loader 存在异常。
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
举例：下图是线程概况，可以查看每个线程名、线程的 Retained Heap、daemon 属性等。
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
使用场景 全局概览呈现全局统计信息，重点查看整体是否有异常数据，所以有效信息有限，下面几种场景有一定帮助：
方法区溢出时（Java 8后不使用方法区，对应堆溢出），查看 class 数量异常多，可以考虑是否为动态代理类异常载入过多或类被反复重复加载。
方法区溢出时，查看 class loader 数量过多，可以考虑是否为自定义 class loader 被异常循环使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e50bfa190e07d28eb6f39d5e51e44d09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a19c5cf6180e66e25ca2e8dcd78854b9/" rel="bookmark">
			Oracle19c最新版保姆级别最详细的安装配置教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，感谢博客上的各位大大，花费了三个小时把有关Oracle安装的相关事务都解决了，以下是我对所有步骤的总结：
Oracle19c下载安装和配置教程
windows下的Oracle19c
一、官网下载Oracle19c数据库
二、安装Oracle数据库
1.解压安装包
2.运行setup.exe安装
三、配置
四、安装完Oracle数据库，给scott用户解锁
1.解决Oracle数据库中没有scott账户的问题
2.给scott用户解锁
五、卸载
1.关闭所有Oracle服务
2.运行Universal Installer卸载数据库
3.修改注册表
4.重启计算机
windows下的Oracle19c
一、官网下载Oracle19c数据库
Oracle官方下载链接：
https://www.oracle.com/database/technologies/oracle-database-software-downloads.html
二、安装Oracle数据库
1.解压安装包
在D盘新建文件夹Oracle (文件很大，不建议放到C盘下)
将WINDOWS.X64_193000_db_home.zip解压到此文件夹下
2.运行setup.exe安装
安装方法很多，针对于不同的需求，以下是其中的一种
1.选择 “创建并配置单实例数据库” ，然后点击下一步
2.选择 “桌面类(D)”，点击下一步
3.创建新 Windows 用户（当然其他的也可以，建议选择这一个，我之前创建过了，所以这张没有图😄​）
用户名密码（密码要求 大小写字母数字，不按照要求也可以，点下一步时会有提示，点“是”即可）自己设定，我的用户名设置的是OracleASUS1
点击下一步
4.选择Oracle 基目录，填写全局数据库名和口令(password)
我在D盘新建了一个文件夹Oracle19c，数据库文件位置会跟随上面变化，其他不动
全局数据库名：orcl
口令自己设置，口令务必记住！
取消勾选 【创建为容器库】
然后点击下一步
5.查看概要后，点击【安装】
接下来就是漫长的等待了，它会在42%很长时间，不用管它，等一会儿就行了
到这里就安装完成了，点击关闭
三、配置
Oracle19c不用再额外的安装客户端，刚才解压的文件中已经自带了，然后我们需要做一些配置：
点击【菜单】–&gt; Oracle OraDB19Home1 --&gt; Net Manager 或者
在我的电脑中打开：C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Oracle - OraDB19Home1\配置和移植工具\ Net Manager（ProgramData文件在隐藏的项目中，勾选上才能看到）
然后会打开如下页面：
点击【本地】-&gt;【服务命名】，点击左上角绿色的 +
1.网络服务名自己起，这个没什么要求，下一步
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a19c5cf6180e66e25ca2e8dcd78854b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e119b8ca0e07174da14d82ec2fcb1fe/" rel="bookmark">
			Vmware下安装Linux（CentOS 7)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上篇文章写的是Vmware的下载安装，下面就开始在Vmware上安装CentOS7
所需环境资源 Vmware、CentOS7安装包
一、CentOS7安装包 已上传至百度网盘供大家下载
点击下载
提取码：0316
二、安装前准备 a.在Vmware中创建一个空虚拟机
b.安装报错(没有请忽略)
进入到BIOS，设置虚拟化（不一样的主板，设置的地方不一样；但是里面的选项名字一般都是Intel Virtualization Technology）
给虚拟机安装操作系统CentOS7 点击浏览，选择在百度网盘下下来的映像文件（SentOS7），然后点击确认
enter进去。鼠标用过ctrl+alt进行windows和虚拟机之间的切换
直接点击完成就行
子网掩码：固定255.255.255.0
网关：往下看
地址：与网关前三个字段相同，最后一段往后随便写
网关怎么查？
1.在虚拟机功能栏点击编辑-》虚拟网络编辑器
2.
等待配置完成就可以点击重启
开启登录CentOS7 打开配置好的虚拟机
输入账号：root
然后点击Enter
输入密码，密码不可见，感觉输错了就多按几次Backspace
这是登录成功
关机可以输入
再说一遍鼠标通过ctrl+alt在Windows和虚拟机之间切换
到此为止虚拟机就安装好CentOS7了。
此次博客是一张一张图截出来的，如果觉得不错，多多点赞
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3b94fd2ec055337396ebc9683d37635/" rel="bookmark">
			apt-get下载包及所有依赖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路就是利用apt-get的depend选项，这会列出所给包的依赖，但是只是直接依赖，间接依赖需要递归。
可以手动递归，也可以用--recurse选项来递归。
下面采用--recurse递归，并用awk来过滤出需要的包名 。
同时，通过--no-*系列选项关闭了所有不必要的。
最后，用apt-get download XXX或者apt download XXX来依次下载每个包。
脚本 #!/bin/bash #$1 pkg get_all_depends() { apt-cache depends --no-pre-depends --no-suggests --no-recommends \ --no-conflicts --no-breaks --no-enhances\ --no-replaces --recurse $1 | awk '{print $2}'| tr -d '&lt;&gt;' | sort --unique } ## 遍历命令行参数，参数应为包名。 for pkg in $* do all_depends=$(get_all_depends $pkg) echo -e "所有依赖共计"$(echo $all_depends | wc -w)"个" echo $all_depends i=0 for depend in $all_depends do i=$((i+1)) echo -e "\033[1;32m正在下载第$i个依赖："$depend "\033[0m" apt-get download $depend done done 效果 漏洞 对于一些包，比如wine，依赖中有一些在下载时会提示无候选版本可下载（似乎是架构相关），暂时不知道什么意思，以后弄懂了再改它。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13cafda4a65d129df9c8f3b66edd3fb4/" rel="bookmark">
			SpringCloud详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringCloud是一个基于SpringBoot的分布式系统开发框架，它能够帮助我们快速、稳定地构建分布式系统。本篇博客将对SpringCloud进行详细解析，介绍SpringCloud的主要组件和相关应用场景，同时提供代码示例以帮助读者更好地掌握SpringCloud的实际开发应用。
一、SpringCloud概述 SpringCloud：SpringCloud官网
SpringCloud是一个由Spring公司维护的分布式系统开发框架，它是基于SpringBoot的微服务框架。SpringCloud提供了一系列的组件和开发工具，用于构建分布式系统的各个方面，如服务发现、服务注册、服务调用、负载均衡、分布式配置中心等。
二、Spring Cloud 和 Dubbo 对比 Spring Cloud和Dubbo都是目前比较流行的微服务框架，它们各自有着不同的特点和优势。
Spring Cloud是基于Spring Boot的一套微服务框架，提供了一系列工具和组件来快速构建和部署微服务应用。
Dubbo则是阿里巴巴的开源RPC框架，专门为分布式服务架构设计，提供了高性能和可靠性的服务注册、发现和调用机制。
下面是Spring Cloud和Dubbo的一些比较：
对比项Spring CloudDubbo开发语言JavaJava分布式协调Zookeeper、JenkinsZookeeper服务注册与发现Netflix Eureka、Consul、ZookeeperZookeeper负载均衡Ribbon、Feign自带负载均衡服务调用方式REST、Feign、OpenFeignRPC数据传输格式JSON、XMLJava序列化服务容错机制Hystrix、Resilience4j自带容错机制包括超时、重试等跨端语言调用支持不支持 总的来说，Spring Cloud更注重整个微服务架构的可扩展性和协调性，适合复杂业务场景。Dubbo则更注重性能和可靠性，适合高并发、大规模、分布式的场景。
需要根据具体的业务需求来选择合适的微服务框架。
三、Spring Cloud 优缺点 其主要优点有：
集大成者，Spring Cloud 包含了微服务架构的方方面面。
约定优于配置，基于注解，没有配置文件。轻量级组件，Spring Cloud 整合的组件大多比较轻量级，且都是各自领域的佼佼者。开发简便，Spring Cloud 对各个组件进行了大量的封装，从而简化了开发。开发灵活，Spring Cloud 的组件都是解耦的，开发人员可以灵活按需选择组件。 接下来，我们看下它的缺点：
项目结构复杂，每一个组件或者每一个服务都需要创建一个项目。部署门槛高，项目部署需要配合 Docker 等容器技术进行集群部署，而要想深入了解 Docker，学习成本高。 Spring Cloud 的优势是显而易见的。因此对于想研究微服务架构的同学来说，学习 Spring Cloud 是一个不错的选择。
四、SpringCloud组件 1、Eureka Eureka是SpringCloud提供的服务发现组件，它能够将所有微服务以易于管理的方式注册到一个注册中心，并且能够自动检测失效的服务并从服务列表中剔除。下面是一个简单的Eureka注册中心示例：
@SpringBootApplication @EnableEurekaServer public class EurekaServerApplication { public static void main(String[] args) { SpringApplication.run(EurekaServerApplication.class, args); } } 2、Feign Feign是一个声明式的REST客户端，它能够简化我们的代码开发，Feign会根据我们定义的接口生成实现类，并且自动进行负载均衡和服务发现等操作。下面是一个简单的Feign客户端示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13cafda4a65d129df9c8f3b66edd3fb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f9a3ef4419f6b4db2b5844bd1d41bf1/" rel="bookmark">
			docker离线安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker离线安装 当需要在一台不能联网的linux服务器上部署服务的时候,会发现很多服务都需要安装一些依赖,但是由于不能联网,安装这些东西非常痛苦.这时候用docker就会非常方便,直接线下将镜像打包好,用docker运行就可以了.问题来了.docker怎么离线安装呢.
1.下载docker离线包 docker官方离线包下载地址
2. 准备docker.service 系统配置文件(docker启动关闭都靠它) docker.service [Unit] Description=Docker Application Container Engine Documentation=https://docs.docker.com After=network-online.target firewalld.service Wants=network-online.target [Service] Type=notify ExecStart=/usr/bin/dockerd ExecReload=/bin/kill -s HUP $MAINPID LimitNOFILE=infinity LimitNPROC=infinity TimeoutStartSec=0 Delegate=yes KillMode=process Restart=on-failure StartLimitBurst=3 StartLimitInterval=60s [Install] WantedBy=multi-user.target 4. 装与卸载脚本 安装脚本
install.sh #!/bin/sh echo '解压tar包...' tar -xvf $1 echo '将docker目录移到/usr/bin目录下...' cp docker/* /usr/bin/ echo '将docker.service 移到/etc/systemd/system/ 目录...' cp docker.service /etc/systemd/system/ echo '添加文件权限...' chmod +x /etc/systemd/system/docker.service echo '重新加载配置文件...' systemctl daemon-reload echo '启动docker...' systemctl start docker echo '设置开机自启.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f9a3ef4419f6b4db2b5844bd1d41bf1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e120ae34409a72cd378896b40d60581b/" rel="bookmark">
			ubuntu上opencv3.4.16的安装，看了别人的自己较全面的重新整理了一下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.opencv下https://opencv.org/releases/
2.opencv_contrib下载 它是opencv外部库（需要与opencv版本相同）
https://www.raoyunsoft.com/opencv/opencv_contrib/
两个都下载好以后，把opencv_contrib（也需要解压）放到解压后opencv文件夹里面
解压后的opencv文件夹建议放在主目录下（可以自己改文件名），如下图：
================================================================
3.配置环境：
sudo apt-get install build-essential sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev
sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev
4.安装
在opencv3文件夹下新建build文件夹：鼠标右击opencv文件夹，选择在终端打开E；输入mkdir build命令。
在build路径下cmake：进入build目录，输入cd build命令。
再输入sudo cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local ..命令（命令最后两个点不要忽略）。
编译：命令如下（根据自己计算机cpu核数选择，查看cpu命令：lscpu）
sudo make -j8或者sudo make -j4
开始安装：命令sudo make install
添加路径
（1）打开文件：sudo gedit /etc/ld.so.conf
（2）在文件中添加如下代码：/usr/loacal/lib
（3）保存并关闭，运行代码：sudo ldconfig
配置环境
（1）打开.bashrc文件：输入命令sudo gedit /etc/bash.bashrc
（2）添加下面两行代码，放到最后面即可：
PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig
export PKG_CONFIG_PATH
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e120ae34409a72cd378896b40d60581b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d493e78d605377139fdf5d4e1e1e78f/" rel="bookmark">
			linux交叉编译环境搭建 gcc &#43; openocd &#43; stlink &#43; cubeMX &#43; cortex Debug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 运行环境：1.1 gcc1)下载并解压gcc2)环境配置 2.1 openocd1)下载并解压openocd2)环境配置（没有权限就加sudo） 3.1 stlink1)下载并双击安装stlink 4.1 cubeMX1)下载并解压cubeMX2)生成makefile工程 5.1 cortex Debug1)setting设置2)launch设置3)实物展示 运行环境： ubuntu18.04. melodic
宏基暗影骑士笔记本
1.1 gcc 1)下载并解压gcc 2)环境配置 sudo gedit /etc/profile export PATH=$PATH:/home/duduzai/Documents/RM/stmpack/gcc-arm-none-eabi-10.3-2021.10/bin export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/duduzai/Documents/RM/stmpack/gcc-arm-none-eabi-10.3-2021.10/lib # 应用环境变量 source /etc/profile # 查看是否安装成功 arm-none-eabi-gcc -v 2.1 openocd 1)下载并解压openocd 2)环境配置（没有权限就加sudo） ./bootstrap ./configure # 编译安装 make sudo make install # 验证是否安装成功 openocd -v 3.1 stlink 1)下载并双击安装stlink 4.1 cubeMX 1)下载并解压cubeMX 2)生成makefile工程 5.1 cortex Debug 1)setting设置 { "[python]": { "editor.formatOnType": true }, // "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d493e78d605377139fdf5d4e1e1e78f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18d9189980dbccb9aa95b2990cdb1799/" rel="bookmark">
			macbook百度网盘下载保存的文件在哪❓找不到
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		困扰我好久的问题终于被我解决了！！！
之前在AppStore里下载百度网盘，然后在百度网盘里下载文件，除了能直接打开以后，怎么都找不到文件位置，后来我终于知道了！！
是因为在AppStore里下载的百度网盘根本不是mac版的，
如果你想下载mac版的百度网盘，直接去官网下载就可以了
百度网盘的官方下载地址：
https://pan.baidu.com/download#pan
直接选择macos自己对应的芯片下载，安装好了就可以！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62339cbec2a2652c8f5a7fb28ee37876/" rel="bookmark">
			简简单单设置个树莓派VNCSERVER开机自启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用的系统是官方的树莓派带桌面系统最新版 编辑rc.local
sudo nano /etc/rc.local 在exit 0 前添加一行
su pi -c '/usr/bin/vncserver :1 -geometry 1920x1080' Ctrl + s保存，Ctrl + x退出
用户名、端口、分辨率自己按需求换
:1对应的是5901
在VNC Viewer中输入 树莓派ip::5901就可以了
之后可以设置个根据不同WIFI的SSID更换静态IP的以方便连接。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fa304f4a14083457780f65665f47172/" rel="bookmark">
			二分查找--中间值取值原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数组总长度为奇数时，二分查找的中间值就是数组中间的那个元素。例如，对于长度为5的数组，中间元素的下标为2。
在数组总长度为偶数时，二分查找的中间值有两个，可以取任意一个作为中间值。一种常用的方法是取靠左的那个中间值。例如，对于长度为6的数组，可以取中间元素的下标为2或3作为中间值。
这里需要注意的是，在实际编程中，为了保证代码的简洁性和通用性，我们通常会将中间值向下取整，即取靠左的那个中间值。这样可以保证不管数组长度是奇数还是偶数，都能够正确地找到中间值。
注意一般mid = left + (right-left)/2; 不要用mid = (right - left)/2 中间值的计算需要考虑到整型溢出的问题。如果使用 `mid = (right - left) / 2` 的方式计算中间值，那么在 right 和 left 的值接近极限值的情况下，可能会导致计算出的中间值发生整型溢出，从而得到错误的结果。
为了避免这种情况，我们一般使用 `mid = left + (right - left) / 2` 的方式来计算中间值。这种方式可以保证计算过程中不会出现整型溢出的问题。
具体来说，`right - left` 是要查找区间的长度，而 `(right - left) / 2` 是区间长度的一半。因此，`left + (right - left) / 2` 就是区间的中间位置，这样可以避免整型溢出的问题。
在二分查找中，left 和 right 分别表示查找区间的左右边界。在最开始的时候，left 和 right 分别指向数组的第一个元素和最后一个元素，也就是说，查找区间的长度是 right - left + 1。
以长度为5的数组为例，最开始的时候，left 指向第一个元素，即下标为0的元素，right 指向最后一个元素，即下标为4的元素。此时，查找区间的长度为 4 - 0 + 1 = 5。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fa304f4a14083457780f65665f47172/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a726da8e6034930e3c55dd845bb7d39/" rel="bookmark">
			gtest学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.Gtest介绍
2.Gtest安装
3.Gtest编译
3.1 普通编译
3.2 交叉编译
3.3 example编译
4.使用测试
4.1 测试程序解读
4.2 测试程序编译
5. 测试实例
5.1 基本测试
5.2 测试固件
5.3 异常测试
5.4 值参数化测试
1.Gtest介绍 gtest是一个跨平台的(Liunx、Mac OS X、Windows、Cygwin、Windows CE and Symbian)C++单元测试框架，由google公司发布。gtest是为在不同平台上为编写C++测试而生成的。它提供了丰富的断言、致命和非致命判断、参数化、”死亡测试”等等。
2.Gtest安装 通过github下载gtest
mkdir ~/gtest
cd ~/gtest
git clone https://github.com/google/googletest.git
有可能会有链接git失败的问题，可以采取从github下载压缩包，传到需要的位置解压。
3.Gtest编译 3.1 普通编译 Gtest提供了两种方式编译源码库：automake和cmake，在此我们将以cmake方式进行编译。
编译之前我们先创建一个编译目录gtest-build，这样避免在源码目录进行编译造成污染问题。
（如果需要用到Gtest提供的例子的话，请用下面example编译方法进行编译。）
mkdir ~/gtest/gtest-build-x86
cd gtest-build-x86
cmake ../googletest-main -DCMAKE_INSTALL_PREFIX=./_install
make &amp;&amp; make install
3.2 交叉编译 上述普通编译也就是x86的环境下编译，我们采用的J5的工具链编译（尚未解决）。
mkdir ~/gtest/gtest-build-J5
cd gtest-build-J5
cmake ../googletest-main -DCMAKE_INSTALL_PREFIX=./_install -DCMAKE_CXX_COMPILER=${TOOLCHAIN_PATH}/bin/aarch64-rockchip-linux-gnu-g++
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a726da8e6034930e3c55dd845bb7d39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd8ad76dccde0ac026f6f010216c1a47/" rel="bookmark">
			node常见报错：throw new MongooseError(‘Mongoose.prototype.connect() no longer accepts a callback‘)，（一步搞定）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
1.当你运行nodemon之后控制台显示报错是因为你mongoose版本太高了
2.解决方法：自降mongoose版本，降到7以下就可以了，安装6.8.0安装完毕之后，然后重新运行
1.当你运行nodemon之后控制台显示报错是因为你mongoose版本太高了 2.解决方法自降mongoose版本，降到7以下就可以了，安装6.8.0安装完毕之后，然后重新运行 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e02c59dd54b20af9a264265bcb4e324/" rel="bookmark">
			Leetcode轮转数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
1.题目
1.1 题目分析：
1.2 画图确定下标：
2.代码实现：
1.题目： 1.1 题目分析： 1.2 画图确定下标： 以数组元素个数为7，旋转3次举例。
2.代码实现： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b3d427810dd78b1415485238371496e/" rel="bookmark">
			32.QButtonGroup
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 创建和添加按钮
1.1 创建按钮组
1.2 添加按钮 addButton()
2 查看按钮
2.3 获取当前选中的按钮 CheckedButton()
3 从按钮组中移除按钮 removeButton()
4 ID操作
4.1 设置 setId(QAbstracButton,int)
4.2 根据指定按钮返回其ID id(QAbstracButton)
5 独占设置
5.1 设置 setExclusive(bool)
5.2 获取 exclusive()
6 信号使用
6.1 按钮组中按钮被点击信号 buttonClicked(int/QAbstractionButton)
6.1.1 传递按钮
6.1.2 传递ID
6.2 按钮组中按钮被按下时信号 buttonPressed(int/QAbstractionButton)
6.2.1 传递按钮
6.2.2 传递ID
6.3 按钮组中的按钮被释放时信号 buttonReleased(int/QAbstractionButton)
6.3.1 传递按钮
6.3.2 传递ID
6.4 按钮组中被切换状态时信号 buttonToggled(QAbstractionButton，bool)
1 创建和添加按钮 QButtonGroup名为按钮组，作用为按钮的容器，在其中可以添加按钮，它本身不具备可视化的效果
QButtonGroup的父类为QObject
首先我们创建四个按钮
1.1 创建按钮组 1.2 添加按钮 addButton() 此处注意addButton()方法只能由一个参数，添加按钮时需要一个一个添加
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b3d427810dd78b1415485238371496e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d287a321aa17acf8047706e265781611/" rel="bookmark">
			chmod 777 修改文件权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、简介
chmod：命令是控制用户对文件的权限的命令 2、读写执行权限
r、w、x 分别表示读、写、执行权限
4、2、1 分别表示读、写、执行权限，7表示全部执行可读可写可执行
权限权限数字具体作用可读r4read，读取。当前用户可以读取文件内容，7 表示全部权限，可读、可写、可执行可写w2write，写入。当前用户可以新增或修改文件内容，当前用户可以删除、移动目录或目录内文件。可执行x1execute，执行。当前用户可以执行文件，当前用户可以进入目录。 3、使用
chmod 765 文件名称
Linux/Unix 的文件调用权限分为三级 :
第一个数字的位置 7表示 文件所有者（Owner）拥有可读可写可执行权限 所有者 = rwx = 4+2+1 = 7 第二个数字的位置 6表示 用户组（Group）拥有可读可写权限 所属组 = rw- = 4+2 = 6
第三个数字的位置 5表示 其它用户（Other Users）拥有可读可执行权限 其他人 = r-x = 4+1 = 5
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/37/">«</a>
	<span class="pagination__item pagination__item--current">38/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/39/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>