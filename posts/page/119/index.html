<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47cd3263d34699b843ce0dc5a4e2dc5b/" rel="bookmark">
			动态运行时类型识别与显式转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、typeid 通过运行时类型识别（RTTI），程序能够使用基类的指针或引用来检索这些指针或引用所指对象的实际类型。
c++可以通过下面两个操作提供RTTI 1、typeid操作符，返回指针或引用所指对象的实际类型。 2、dynamic_cast操作符，将基类类型的指针或引用安全的转换为派生类型的指针或引用。
用法：
Base *bp; Derived *dp; if(typeid(*bp)==typeid(*dp)){```}1 if(typeid(*bp)==typeid(Derived)){```}2 1、比较bp所指对象与dp所指对象的实际类型，如果它们指向同一个类型，则测试成功。类似的，如果bp当前指向derived对象，则2测试成功 显式转换 强制类型转换符：static_cast、dynamic_cast、const_cast，reinterpret_cast。 reinterpret_cast 之前是采用圆括号将类型括起来实现
int *p; char *pc=reinterpret_cast&lt;char*&gt;(ip); 效果等同于：
int *ip; char*pc=reinterpret_cast&lt;char*&gt;(ip); const_cast 转换掉const性质
const char *pc_str; char *pc=const_cast&lt;char*&gt;(pc_str); 例如：
const double value=0.0f; double* ptr=NULL; 怎么让ptr指向value？ 强制类型转换，去掉const属性
ptr=const_cast&lt;double*&gt;(&amp;value) static_cast 编译器隐式执行的任何类型转换都可以有static_cast显示完成：
都变了double d= 97.0;int i=static_cast&lt;int&gt;(d); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52f153960794dd83807411063e7ed907/" rel="bookmark">
			PRISM基本知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Prism框架是用于创建低耦合，易维护，易测试的应用的。最初由微软开发，后提交给开源社区由开源社区维护的开源项目。每个平台都有独立的版本。
Prism实现了一系列的设计模式，有助于编写well-structured和可维护的XAML应用程序，包括MVVM，依赖注入，命令，EventAggregator等。Prism的核心功能是方便的在不同平台共享代码。
1.Prism Key Concepts Modules. 模块是可以独立开发/测试/部署的功能包。
Module catalog. 在组合应用程序里(composite application)，模块可能需要在运行时加载。在Prism里，module catalog用于指定哪些模块需要被加载，以及按什么顺序加载。module catalog被ModuleManager和ModuleLoader组件使用。Prism允许使用不同的方式指定module catalog：代码，xaml，或者用配置文件指定。
Shell. shell是应用程序外壳，定义了应用程序的总体布局和结构，但它通常不知道确切的模块，它通常实现通用的服务和基础架构，具体的功能则是在具体的模块里面实现。shell还提供了顶层的窗口和视觉元素，然后它会嵌入由具体modules提供的不同的UI
View. 视图封装了应用程序的特定的功能或者功能区域，用于MVVM模式。MVVM将UI和显示逻辑&amp;数据分离，View用于封装UI，并定义用户交互行为，从而允许view独立于底层应用程序的功能进行更新和替换。view通过数据绑定与view model交互。
View models. 视图模型是封装应用的表现逻辑和状态的类，它是MVVM模式的一部分。View model封装了许多功能，为view中可以绑定的控件定义属性，命令和事件。
Models. 模型封装了应用程序的数据和业务逻辑，它是MVVM模式的一部分。model封装数据，相关的验证和业务规则，以确保数据的一致性和完整性。
Commands. 命令用于封装应用程序的功能，允许它们独立于应用程序的UI进行定义和测试。它们可以被定义成command objects或者view model中的command methods。(They can be defined as command objects or as command methods in the view model. ) Prism提供了DelegateCommand classs和CompositeCommand class，后者用于表示一起触发的命令集合。
Regions. 区域是应用程序UI(在shell上或者view内)上定义的逻辑占位符，用于显示view。Region允许对应用程序UI的布局进行更新，而不需要更改应用程序逻辑。许多通用控件都可以被用作region，运行view被自动的显示在它里面，比如ContentControl, ItemsControl, ListBox, TabControl. View可以自动的或者通过编程被显示在region里。Prism also provides support for implementing navigation with regions. Regions can be located by other components through the RegionManager component, which uses RegionAdapter and RegionBehavior components to coordinate the display of views within specific regions.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52f153960794dd83807411063e7ed907/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64f29be1fd2c7230f1f3786e82b92556/" rel="bookmark">
			关于二维偏序的题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单的逆序对 可以用树状数组搞 就是插入时，找前面比他大的和 插入时弄一个桶，记下有多少个数 然后对后面的进行区间求和，这个可以用树状数组搞 最后求一个总和
#include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;cstdio&gt; using namespace std; int n,a[49999],sum[4999999],max1; int add(int x,int w) { for(int i=x;i&gt;0;i-=i&amp;(-i)) sum[i]+=w; } int chaxun(int x) { int ans=0; for(int i=x;i&lt;=max1;i+=i&amp;(-i)) ans+=sum[i]; return ans; } int main() { int ans=0; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) { scanf("%d",&amp;a[i]); add(a[i],1); max1=max(a[i],max1); ans+=chaxun(a[i]); } printf("%d",ans-n); } 难一点的 三元逆序对 这样的话就可以枚举一个位置，找前面比他大的，和后面比他小的，乘起来，统计和
#include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #include&lt;cstdio&gt; using namespace std; int n,a[49999],sum[4999999],max1,sum2[4419999]; int add(int x,int w) { for(int i=x;i&lt;=max1;i+=i&amp;(-i)) sum[i]+=w; } int chaxun(int x) { int ans=0; for(int i=x-1;i&gt;0;i-=i&amp;(-i)) ans+=sum[i]; return ans; } int add2(int x,int w) {for(int i=x;i&gt;0;i-=i&amp;(-i)) sum2[i]+=w; } int chaxun2(int x) { int ans=0; for(int i=x+1;i&lt;=max1;i+=i&amp;(-i)) ans+=sum2[i]; return ans; } int main() { long long ans=0; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64f29be1fd2c7230f1f3786e82b92556/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c82b3ee20c9b7c736fad068be17f8050/" rel="bookmark">
			2 3 5 7的倍数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给出一个数N，求1至N中，有多少个数不是2 3 5 7的倍数。 例如N = 10，只有1不是2 3 5 7的倍数。 Input 输入1个数N(1 &lt;= N &lt;= 10^18)。 Output 输出不是2 3 5 7的倍数的数共有多少。 Sample Input 10 Sample Output 1 #include&lt;stdio.h&gt; int main(){ long long n; scanf("%lld",&amp;n); long long sum=0; sum+=n/2; sum+=n/3; sum+=n/5; sum+=n/7; sum-=n/6; sum-=n/10; sum-=n/14; sum-=n/15; sum-=n/21; sum-=n/35; sum+=n/105; sum+=n/70; sum+=n/42; sum+=n/30; sum-=n/210; printf("%lld\n",n-sum); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea906763b9de2d438056040c09df6ec4/" rel="bookmark">
			实验楼-高级Bash脚本编程指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验1.Bash介绍与入门
1.简介：Bash是一个为GNU计划编写的Unix shell，它是许多Linux平台默认使用的shell
shell是一个命令解释器，是介于操作系统内核与用户之间的一个绝缘层。所有的UNIX命令和工具再加上公共程序，对于Shell脚本来说，都是可调用的。
2.运行Bash脚本的方式： 1）使用shell来执行：sh hello.sh
2）使用Bash来执行：bash hello.sh
3）还可以让脚本本身就具有可执行权限，通过chmod命令可以修改：chmod u+rx hello.sh 然后运行 ./hello.sh
3.使用重定向：&gt;为重定向符号，例如将输出文件保存在一个txt中， eg: echo "hello world"&gt;my.txt
4.使用脚本清除/var/log下的log文件:
/dev/null 可以理解为一个黑洞，里面是空的，什么东西都可以往里面扔，扔了就没了。
实验2.Bash中的特殊字符（上）
1.注释：#为注释
#！用于指定当前脚本的解释器，这里用bash,应该知名其完整路径，即#!/bin/bash
在echo中转义的#是不能作为注释的，eg:echo The \# here doesn't begin a comment
2.分号：1）使用分号可以在同一行上写两个或两个以上的命令
2）使用双分号可以终止case选项
3.点号：等价于source命令，用于在当前Bash环境下读取并执行filename.sh中的命令
4.引号：1）“ ”：双引号会组织string中大部分特殊字符
2）‘ ’：单引号会组织string中所有特殊字符的解释，这是一种比双引号更强烈的形式
5.斜线和反斜线：1）斜线 /：文件名路径分隔符，分割文件名不同的部分；也可以用作除法算术操作符。注意在Linux中表示路径的时候，许多个/和一个/是一样的效果
2）反斜线：一种对单字符的引用机制，转义表示
6.反引号：命令替换，command结构可以将命令的输出赋值到一个变量中去。反引号中的命令会优先执行
eg: cp `mkdir back` hello.sh back
7.冒号：1）空命令：等价于“NOP”，也可以被认为与shell的内建命令true作用相同，退出码是（0），即while：与while true语义相同
2）变量扩展/子串替换
与&gt;重定向操作符结合使用时，将会把一个文件清空，但不会修改这个文件的权限，如果之前这个文件不存在，就创建这个文件
与&gt;&gt;重定向操作符结合使用时，将不会对预先存在的目标文件产生任何影响，如果这个文件不存在，就创建这个文件
3）注释行（不推荐）
4）用来在/etc/passwd和$PATH变量中做分隔符
8.冒号
1）测试操作符：在一个双括号结构中，？就是c语言的三元操作符
9.美元符号($)
1）变量替换
2）命令替换
实验3-bash中的特殊字符（下）
1.小括号() 1）命令组：在括号中的命令列表，会作为一个子shell来运行。由于是在子shell中，所以脚本剩下的部分是不可用的。父脚本，即脚本本身，将不能够读取在子进程中创建的变量。
2）初始化数组：arr=(1 2 4 5)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea906763b9de2d438056040c09df6ec4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71aaad89fac723d1cb6c322a2e8abdc3/" rel="bookmark">
			狐狸分奶酪（codeforces 371b）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很容易想到的一个思路是暴力，就是对多的蛋糕吃，进行bfs（）； 一旦两种蛋糕相等，就是最小步数的，很容易写。注释掉的代码就是 还有更好的方法，很容易看出，最后的解一定是它们的最大公约数，然后把他们的最大公约数去掉，看看能不能吃成1，记下步骤，也可以看能不能吃成最大公约数，是一样的。
#include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;queue&gt; #define ll long long using namespace std; int a,b; struct date{ int a;int b;int t; }; /*int bfs(int a,int b){ queue &lt;date&gt; q; date w; w.a=a; w.b=b; w.t=0; q.push(w); date p; while(!q.empty()){ p=q.front(); q.pop(); if(p.a==p.b) { printf("%d",p.t); return 0; } else if(p.a&gt;p.b)//找大的蛋糕吃 {//a if(p.a%2==0) //吃1/2 { p.a/=2;p.t++; q.push(p); p.t--;p.a*=2; } if(p.a%3==0) //吃2/3 { p.a/=3;p.t++; q.push(p); p.t--;p.a*=3; } if(p.a%5==0) //吃4/5 { p.a/=5;p.t++; q.push(p); p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71aaad89fac723d1cb6c322a2e8abdc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4de26ecef3444f75de9a7f87c1de4db6/" rel="bookmark">
			晨跑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; const int M=199999; int n,m,s,t;int dis[M];; int nex[M],head[M],cos[M],to[M],tot,pre[M],cap[M],vis[M],flo[M],id[M]; struct st2{ int f,b; }a[M]; int add(int x,int y,int z,int w){ cos[tot]=z; cap[tot]=w; nex[++tot]=head[x]; to[tot]=y; head[x]=tot; } int spfa(int s,int t){ queue &lt;int&gt; q; memset(dis,127,sizeof(dis)); memset(vis,0,sizeof(vis)); memset(pre,-1,sizeof(pre)); int INF=dis[0]; dis[s]=0; vis[s]=1; q.push(s); flo[s]=INF; while(!q.empty()){ int x=q.front(); vis[x]=0; q.pop(); for(int i=head[x];i;i=nex[i]) { int tmp=to[i]; if(dis[tmp]&gt;dis[x]+cos[i-1]&amp;&amp;cap[i-1]){ dis[tmp]=dis[x]+cos[i-1]; pre[tmp]=x; flo[tmp]=min(flo[x],cap[i-1]); id[tmp]=i-1; if(!vis[tmp]){ q.push(tmp); vis[tmp]=1; } } } } if(dis[t]&gt;=INF)return 0; return 1; } struct st{ int cost=0; int flow=0; }; st maxflow(int s,int t){ st a; while(spfa(s,t)){ int k=t; while(k!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4de26ecef3444f75de9a7f87c1de4db6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baab4cf194187e6efd05217e1ab29e91/" rel="bookmark">
			mysql workbench 常用快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; mysql workbench 常用快捷键
· 新建tab(new tab) ctrl+t
· 执行当前语句(execute current statement) ctrl+enter
· 执行全部或选中的语句(execute all or selection) ctrl+shift+enter
· 查看执行计划(explain current statement) ctrl+alt+x
· 注释 - -加空格，如 – select * from t;
以上快捷键，都可以通过query查看
代码美化快捷键(也称"格式化代码")是: ctrl+b.
对应菜单Edit&gt;Format&gt;Beautify Query. 名称后面显示类对应快捷键的名称.
扩展:
自定义快捷键可以通过修改MySQLWorkbench安装目录\data\main_menu.xml文件
注意的几个点:
备份原始文件, 这是好习惯.
要修改的为value标签
value标签中platform属性, 指定当前使用什么系统, 例如Windows就修改platform为windows节点的shortcut;
value标签中shortcut属性, 指定要使用的快捷键, 注意workbench快捷键配置文件中的按键名称和我们通常理解的有很大区别, 比如:enter键叫Return, Modifier为Ctrl.
如果修改后, mysql无法启动, 说明修改不符合workbench规则.
转载于:https://my.oschina.net/iioschina/blog/906599
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d890c661f4f4355746b27ab5e3d66af3/" rel="bookmark">
			树莓派3b&#43;控制舵机、伺服电机的驱动代码。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		舵机的控制一般需要一个20ms的时基脉冲，该脉冲的高电平部分一般为0.5ms~2.5ms范围内的角度控制脉冲部分。以180度角度舵机为例，那么对应的控制关系是这样的：
0.5ms--------------0度；
1.0ms------------45度；
1.5ms------------90度；
2.0ms-----------135度；
2.5ms-----------180度；
请看下形象描述吧:
舵机的工作电压和电流：
每一款舵机都有自己的参数，如TR213舵机的工作电压是4.8-7.2V，TR205舵机的工作电压是4.8-6V，电压不能超过这个范围，否则会很容易烧坏舵机，在不清楚舵机工作电压范围的情况下，建议使用5V给舵机供电。
舵机的工作电流是根据舵机的实际情况而定的，如TR213舵机，在空载的时候电流几乎为0，而在正常负载的情况下，电流在0.5A左右，视实际情况而定。六足机器人需要18个TR213金属舵机，需要提高的电流大概在8A左右，如果电源功率不够会影响舵机的性能，最常见的现象是，当一个舵机负载的时候，其他舵机会出现混乱，无规律的乱摆。
舵机的接线如下图：
市场上90%的舵机中间那根线都是正级。
基础知识介绍的差不多了，具体可以去百度看看舵机手册。
下面我们来说说在树莓派中，如何用wiringPi库去驱动舵机随心所欲的转。为什么要用wiringPi库呢，因为博主不怎么喜欢写Python，博主喜欢写c/c++代码。废话不多说，开始。
第一：首先，我已经知道了舵机的pwm周期为20ms，然后是这样的
0.5ms--------------0度；
1.0ms------------45度；
1.5ms------------90度；
2.0ms-----------135度；
2.5ms-----------180度；
也就是说给它1.5ms的高电平，19.5ms的低电平转向0度位置。这里需要注意，是0度位置，不是舵机转0度，当然如果舵机怎么正好处于0度位置，当然也不转。这里可能就有人要问了，那啥位置算是0度位置呢？根据我对舵机的理解（180度的舵机），就是你向一个方向用手转动舵机，到一个你无法转动的地方，这个位置不是0度位置，就是180度位置。然后你用下面的代码运行一下就知道了。
while(1)//turn to 0 { digitalWrite(15,HIGH); delayMicroseconds(500); digitalWrite(15,LOW); delayMicroseconds(19500); } 我这里就这样来模仿pwm的。这个代码一运行，舵机就自动到了0度位置。
同理，想转到45度位置，90度位置，135度位置，180度位置的代码如下： while(1) //turn to 45 { digitalWrite(15,HIGH); delayMicroseconds(1000); digitalWrite(15,LOW); delayMicroseconds(19000); } while(1) //turn to 90 { digitalWrite(15,HIGH); delayMicroseconds(1500); digitalWrite(15,LOW); delayMicroseconds(18500); } while(1) //turn to 135 { digitalWrite(15,HIGH); delayMicroseconds(2000); digitalWrite(15,LOW); delayMicroseconds(18000); } while(1) //turn to 180 { digitalWrite(15,HIGH); delayMicroseconds(2500); digitalWrite(15,LOW); delayMicroseconds(17500); } 这里可能有人要说为啥不用delay()函数呢，因为delay函数精确到毫秒，当我传1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d890c661f4f4355746b27ab5e3d66af3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d584f6205dfbb19965519bb45c3e2225/" rel="bookmark">
			7-Linux内核配置编译及安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习了一下Linux内核配置、安装及编译，为了防止忘记，写在博客里
1、Linux源代码下载 下载源代码最好去官网下载，地址为：https://www.kernel.org/
如果需要下载历史版本，点击网页上的https://www.kernel.org/pub/，然后选择Linux，kernel即可，比较简单。
2、配置Linux内核 把源代码拷到Linux电脑里，解压，这里我下载的是linux-4.11.tar.xz，解压输入
#tar xvJf linux-4.11.tar.xz
如果是tar.gz结尾的文件用tar xvzf linux-4.11.tar.gz命令解压
解压之后开始配置内核模块，选择自己芯片的硬件架构，选择自己需要哪些驱动模块等等，配置为指令make config或者 make menuconfig,前者是基于问答式的配置，使用不方便，后者是菜单式的配置，较为直观和方便，这里使用后者，输入
#make menuconfig
然后根据自己的需要，用上下左右键移动选择项，用空格选择是否配置该项。另外还可以选择现有的配置文件来达到目的，在源代码下面的arch/$cpu/configs下有许多现成的配置文件，输入
#ls arch/arm/configs
可以查看arm芯片的内核配置，同时还可以使用本机的配置文件，这里使用本机的配置文件，在/boot目录下，复制/boot下的配置文件 config-2.6.32-279.el6.i686 到上述解压后目录里，输入
#cp /boot/config-2.6.32-279.el6.i686 ./
开始配置内核
#make menuconfig
选择后面的load加载配置文件，输入上面文件的名字，点ok，然后再点击保存，保存文件名为.config，输入
#ls -a
可以看到这个文件
3、编译内核 编译内核需要生成映像文件和模块文件，映像文件由配置中的选择为&lt;*&gt;的文件编译链接而成，开机后直接加载在内存中运行
模块文件将选择为&lt;M&gt;的文件编译成.o文件，放在磁盘中，以备后来要用到，先配置映像文件,输入
#make bzImage
开始生成bzImage映像文件，需要10多分钟左右，正常情况下不会有什么问题，编译完成后提示bzImage文件在 arch/x86/boot 目录下
然后编译模块文件，输入
#make modules
大概需要50分钟左右，应该也不会有什么问题，可能会有一些警告，可以忽视，然后把散落在各个文件夹下的.o文件组装起来，输入
#make modules_install
组装完成后，会把文件放在/lib/modules/ 下，文件名为对应的版本号，查看可以输入
#ls /lib/modules
可以看到对应版本的文件夹
然后把存放模块文件的目录打包成一个文件，使用mkinitrd命令，输入(主要后者不要输入成/lib/modules/4.11.0)
#mkinitrd rd-4.11.0 4.11.0
前者为生成文件的名字，后者为模块文件存在的目录，需要几分钟，这样文件包rd-4.11.0就在当前文件目录上产生了。
4、安装内核 安装内核之前需要把生成的bzImage和模块文件包rd-4.11.0拷贝到/boot目录下，这样启动的时候才能够选择这个内核启动
先拷贝bzImage，输入(如#cp arch/$cpu/boot/bzImage /boot/vmlinux-$version )
#cp arch/x86/boot/bzImage /boot/vmlinuz-4.11.0
然后拷贝模块文件包，输入cp rd-$version /boot/，version为对应版本号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d584f6205dfbb19965519bb45c3e2225/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce2bec4ecc170764d23de5c09c0be7cc/" rel="bookmark">
			mysql主从同步分库分表同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、mysql数据库的安装
分别在master 和slave上源码安装mysql数据库
1.1 安装相关包
1.1.1 cmake软件
cd /home/oldboy/tools/
tar xf cmake-2.8.8.tar.gz
cd cmake-2.8.8
./configure
#CMake has bootstrapped. Now run gmake.
gmake
gmake install
cd ../
1.1.2 依赖包
yum install ncurses-devel -y
1.2 开始安装mysql
1.2.1 创建用户和组
groupadd mysql
useradd mysql -s /sbin/nologin -M -g mysql
1.2.2 解压编译MySQL
tar zxf mysql-5.5.32.tar.gz cd mysql-5.5.32
cmake . -DCMAKE_INSTALL_PREFIX=/application/mysql/mysql-5.5.40 \
-DMYSQL_DATADIR=/application/mysql/mysql-5.5.40/data \
-DMYSQL_UNIX_ADDR=/application/mysql/mysql-5.5.40/tmp/mysql.sock \
-DDEFAULT_CHARSET=utf8 \
-DDEFAULT_COLLATION=utf8_general_ci \
-DEXTRA_CHARSETS=gbk,gb2312,utf8,ascii \
-DENABLED_LOCAL_INFILE=ON \
-DWITH_INNOBASE_STORAGE_ENGINE=1 \
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce2bec4ecc170764d23de5c09c0be7cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/296c2f829b2495729f71509cc3594dea/" rel="bookmark">
			C#中继承实现父类方法、重写、重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#中子类重写父类方法的几种情况，关键字：virtual、abstract、override、new。（此处不说abstract，以后补充）
virtual：不是必须被子类重写的方法，父类必须给出实现，子类可以重写（使用override，new，或无特殊标志的普通方法），也可以不重写该方法。
new：重写父类方法时，父类可以使用virtual，override，new之一声明，也可以是没有关键字的普通方法，运行时会根据引用类型选择调用父类还是子类方法，重写父类方法时，使用new关键字与使用没有关键字的普通方法的等效的，但是后者会给出编译警告。
继承： 继承是派生类（子类）去实现（重写&lt;override&gt;、重构&lt;new&gt;）基类（父类）的方法或属性。从而获取在派生类中要实现的功能。
子类调用父类构造方法，在父类中有个实现姓名和年龄的构造方法但是子类中也要实现这样的功能时，子类不用再次去写这个功能，只要去调用父类的功能即可。
#region public class Person { private string _name ; private int _age ; public Person(string name, int age)//父类的构造方法 { this._name = name;//获得参数的值 this._age = age; Console.WriteLine("您的姓名是{0},您的年龄是{1}.",this._name, this._age); } } public class Studnet : Person { private int _id; public Studnet(string name, int age, int IDCard):base(name, age)//子类构造方法继承父类构造方 //把接受到的name、age两个参数交给父类的构造方法去处理 { this._id = IDCard; Console.WriteLine("您的身份证号码为{0}", this._id); } } class Program { static void Main(string[] args)//主函数 { Studnet stu = new Studnet("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/296c2f829b2495729f71509cc3594dea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72762510584e171e4256503145a36723/" rel="bookmark">
			Docker常用命令原理图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker常用命令原理图概览： （一）image layer（镜像层） 镜像可以看成是由多个镜像层叠加起来的一个文件系统，镜像层也可以简单理解为一个基本的镜像，而每个镜像层之间通过指针的形式进行叠加。
根据上图，镜像层的主要组成部分包括镜像层id，镜像层指针【指向父层】，元数据【layer metadata】包含了docker构建和运行的信息还有父层的层次信息。
只读层和读写层【top layer】的组成部分基本一致。同时读写层可以转换成只读层【docker commit操作实现】
（二）image（镜像）---【只读层的集合】 1、镜像是一堆只读层的统一视角，除了最底层没有指向外，每一层都指向它的父层，统一文件系统（union file system）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。而每一层都是不可写的，就是只读层。
（三）container（容器）---【一层读写层+多层只读层】 1、容器和镜像的区别在于容器的最上面一层是读写层【top layer】，而这边并没有区分容器是否在运行。运行状态的容器【running container】即一个可读写的文件系统【静态容器】+隔离的进程空间和其中的进程。
隔离的进程空间中的进程可以对该读写层进行增删改，其运行状态容器的进程操作都作用在该读写层上。每个容器只能有一个进程隔离空间。
（四）docker常用命令说明 1、标识说明 1）image---（统一只读文件系统） 2）静态容器【未运行的容器】---（统一可读写文件系统） 3）动态容器【running container】---（进程空间（包括进程）+统一可读写文件系统） 2、命令说明 a）docker生命周期相关命令: 1）docker create &lt;image-id&gt; 即为只读文件系统添加一层可读写层【top layer】，生成可读写文件系统，该命令状态下容器为静态容器，并没有运行。
2）docker start（restart） &lt;container-id&gt; 【docker stop即为docker start的逆过程】 即为可读写文件系统添加一个进程空间【包括进程】，生成动态容器【running container】
3）docker run &lt;image-id&gt; docker run=docker create+docker start
类似流程如下 ：
4）docker stop &lt;container-id&gt; 向运行的容器中发一个SIGTERM的信号，然后停止所有的进程。即为docker start的逆过程。
5）docker kill &lt;container-id&gt; docker kill向容器发送不友好的SIGKILL的信号，相当于快速强制关闭容器，与docker stop的区别在于docker stop是正常关闭，先发SIGTERM信号，清理进程，再发SIGKILL信号退出。
6）docker pause &lt;container-id&gt; 【docker unpause为逆过程】---比较少使用 暂停容器中的所有进程，使用cgroup的freezer顺序暂停容器里的所有进程，docker unpause为逆过程即恢复所有进程。比较少使用。
7）docker commit &lt;container-id&gt; 把容器的可读写层转化成只读层，即从容器状态【可读写文件系统】变为镜像状态【只读文件系统】，可理解为【固化】。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72762510584e171e4256503145a36723/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a699470e397d741d475cb192c80f3543/" rel="bookmark">
			Oracle Database 12c新特性对企业影响的思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当今的世界，是云的世界。
而关系型数据库管理系统 (RDBMS) 也正在发生一场重大变革 ---- 从固定的服务器和存储转向灵活的云部署，从存储优化的数据库管理转向内存优化的数据库管理。
新一代的数据库环境已经来临。传统数据库中的Oracle也发布了12C的版本，经过一段时间的使用和测试，我们感觉Oracle Database 12C能为我们提供进行创新的基础，并企业以安全、可靠且经济高效的方式进行IT管理。本文主要探讨12C中的几个对新特性带来的影响。
1. 多租户架构（Multitenant）
Oracle12c引入了一种新的多租户架构（Multitenant），该架构有助于轻松部署和管理数据库，并能使用户充分利用云计算所提供的资源共享、管理灵活性和成本节省等优势。
Oracle新的多租户架构（Multitenant）为云而设计，它带来的新架构可以简化整合并提供基于模式的高密度的整合，然而却无需更改现有应用程序。它可带来将多个数据库作为一个管理的所有好处，同时还能保持不同数据库的相互隔离和资源控制。在这个架构中，单个容器数据库可以托管多个“可插拔”数据库。对于应用程序而言，每个整合或“插入”到多租户容器中的数据库感觉就和以前版本的Oracle数据库一样。对可插拔数据库的访问与对现有Oracle数据库的访问一样，并且DBA可以控制所有整合数据库使用资源的优先级。
整合多个数据库意味着DBA需要管理的数据库数量变少，对IT部门来说，即使不是数千个数据库，管理数百个数据库也是相当寻常的情况，这些数据库中的每一个（无论是生产、测试还是开发数据库）都需要进行维护。
将多个可插拔数据库整合到一个多租户容器中，可以大大减少所需升级活动的数量。现在只需要在容器级应用补丁和升级，不需要对每个可插拔数据库应用补丁和升级。同时，我们还可以灵活地创建新的修补和/或升级的容器数据库，可以有选择地将数据库从旧的容器数据库中拔出，然后插入新升级的容器数据库中。
新的可插拔架构只需在多租户容器级执行备份，不必对数据中心的每个独立数据库分别进行备份。这意味着DBA管理的备份减少，因为对容器数据库中每个可插拔数据库的备份都是自动进行的。
将多个可插拔数据库作为一个管理的另一个好处是维护的备用数据库减少。使用12C，将在容器级传输和应用重做日志，因此，可以完全保护每个整合到容器中的可插拔数据库免受站点中断影响，但是这里也带来一个负面的影响，这有可能会带来备份空间的浪费。此外，使用ADG的用户还可以将自己的备用可插拔数据库用于生成报表及其他活动用途。
尽管通过整合多个数据库可获得诸多好处，我们还是应该全面考虑数据库整合各个方面的问题。一个显而易见的问题是，在这种新的多租户架构中如何确保资源使用的优先级？毕竟，如果数据库应用程序不断地争用可用系统资源，那么将多个数据库作为一个管理带来的许多好处将会迅速消失，用户性能服务级别也会开始下降。我们可以使用12C的资源管理特性，在可插拔数据库级方便地定义资源使用优先级，虽然目前Oracle Database 12C在多个可插拔数据库之间的IO资源隔离依然存在不足，但在CPU、内存等资源的隔离依然好于其他数据库，使用可插拔数据库对资源的隔离，依然是一个比较合适的选择。
2. Database In-Memory（IMDB）选件
IMDB是12C的一个新选件，它提供了一个独特的双格式架构。可以使用传统的行格式和新的内存中列格式同时在内存中表示数据库表。12C自动维护行格式和列格式间的完全的事务一致性，优化器自动将分析查询路由到列格式，将OLTP查询路由到行格式，从而以透明的方式提供了两者之最佳性能。
IMDB对内存中扫描、内存中联接和内存中聚合采用最新的算法。这些内存中优化能极大的提升分析类业务的查询速度，在同样的硬件环境下，对于分析类业务的性能提升显著。
IMDB不要求将所有数据库数据都放在内存中。用户可以选择只将性能敏感的表、分区或列填充到内存中。性能不太敏感的数据则可以存放在低成本的闪存或磁盘上。对存放于所有三个层（内存、闪存和磁盘）中的数据透明地执行查询使IMDB可以与任何大小的数据库结合使用。
利用IMDB时无需对现有应用程序进行更改。它与12c的所有功能完全兼容，包括Multitenant、最高可用性架构和数据库安全性特性。
3. 实施纵深防御以实现最高安全性
12C引入了新的预防、检测和管理控制，这些控制可以帮助用户加强其企业数据的保护。
数据编辑：通过在数据库（而非应用程序）中定义和实行数据编辑策略，无需修改应用程序，用户就可以有效地防止在应用程序屏幕和报告上显示诸如身份证号、生日和银行账号等敏感数据。
全面审计：这种审计架构既是基于策略的也是上下文感知的，并设置了新角色来管理审计策略和查看审计数据。这一新架构将现有审计线索统一为单个审计线索，从而简化了对数据库生成的审计数据的管理，同时提高了它们的安全性。
权限分析：能够跟踪连接到数据库的特定会话或所有会话的权限及角色使用。权限分析有效地记录所使用的权限和角色，并允许安全的个人、数据库管理员和审计人员通过设计能准确反应日常业务和管理活动所需权限的最小权限模型来保护其数据库。 4. 简化大数据分析
尽管Hadoop和分布式键值对存储等技术可以帮助企业获取大量低密度数据，但是，如果能结合更多传统企业数据对大数据进行分析，则能实现大数据的真正价值。
12C为提供了一个数据库仓储平台，该平台可存储和管理海量数据，并可使用熟悉的SQL接口和诸如R等统计框架来处理从简单查询到复杂分析的每件事情。与以往不同，用户不再需要不断将数据从数据仓库移动到数据集市和专用处理服务器，而是可以将企业数据和大数据全部整合到同一个数据仓库中以支持其所有用户的业务智能和分析需求。 5. 新特性在实际生产运维中的应用
Oracle Database 12c投产到我们部分生产系统已有两年,确实为我们提供了较多的便利。
首先，它提供的多租户架构，让我们能够快速方便的新增数据库，免去复杂的环境配置、参数配置环节。同时，用户可以登陆一台主机，便可查看各个PDB数据库状态及监听状态，便于日常监控管理。
其次，在12c之前的版本中，Varchar2和nVarchar2数据类型的最大长度是4000 字节，一旦超过4000字节，将以out of line方式存放。12c提供的32K String功能，使得Varchar2和nVarchar2类型最大可以支持到 32K。虽然底层存储方面是采用类似LOB字段的out of line的方式存放，但对于前端开发者来说，可以像使用普通的Varchar2字段一样使用32K Varchar2，而不用像使用LOB字段那样需要写专门的代码来访问LOB字段的内容。
此外，在12C中，多个PDB可以共享process，undo等资源，通过将业务高峰期错开的数据库置于一个CDB中，使系统资源得到了充分的利用。
但是，在日常运维中，我们也发现了12c的一些不足。例如，当收到undo表空间使用率告警时，DBA需要到CDB里查看各PDB UNDO使用率，然后再根据使用率，到PDB去查看其具体会话详情, 且PDB中只能查看自身UNDO使用情况，而无法查看其占总UNDO的百分比，给日常问题管理带来较多不便；在12c中，当一个节点的数据库进程出错时，会导致该节点所有的pdb无法继续提供服务。当该节点恢复正常的时候，为了能够让分节点访问的业务正常访问节点，需要启停更多的业务进程，延迟了故障恢复时间等。
总结 在云化架构到来的时候，我们可以尝试依据自己的业务对Oracle Database 12C的相关新特性进行测试，并选择最合适自己企业的特性进行生产实践。 作者：唐小丹（浙江移动数据库管理员）；王航威（上海新炬数据库管理员）
本文来自云栖社区合作伙伴"DBAplus"，原文发布时间：2016-03-16
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/859924050c468c01496e9611ab1074ff/" rel="bookmark">
			运行的时候报 variables may not be available.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 运行的时候说 YKX1.0（项目名称） was compiled with optimization - stepping may behave oddly; variables may not be available.
运行模式出错，解决办法改为debug模式 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad30594de9fe421abb24f0e9fc0c3a79/" rel="bookmark">
			html escape unescape
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考： https://wiki.python.org/moin/EscapingHtml
Python 3.6.0 (default, Dec 24 2016, 00:01:50) [GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.42.1)] on darwin Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; import html &gt;&gt;&gt; s = html.escape( """&amp; &lt; " ' &gt;""" ) &gt;&gt;&gt; print(s) &amp;amp; &amp;lt; &amp;quot; &amp;#x27; &amp;gt; &gt;&gt;&gt; s = html.escape( '''&amp; &lt; " ' &gt;''' ) &gt;&gt;&gt; print(s) &amp;amp; &amp;lt; &amp;quot; &amp;#x27; &amp;gt; &gt;&gt;&gt; s = html.unescape( '''&amp;amp; &amp;lt; &amp;quot; &amp;#x27; &amp;gt;''' ) &gt;&gt;&gt; print(s) &amp; &lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad30594de9fe421abb24f0e9fc0c3a79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f5dae54e9f6feef9ab11f90b54402df/" rel="bookmark">
			InnoDB---读已提交隔离级别的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于读已提交隔离级别的实现方式，从逻辑上需要明确两个部分，一是加锁部分二是解锁部分。加锁，对应的是获取数据，确保在指定的隔离级别下读取到应该读到的数据。解锁则意味着要在适当的时机释放锁且不影响隔离级别的语义还能提高并发度。
加锁部分，实现分为两个方面：一是加锁的时候，读已提交隔离级别不加间隙锁，这样就能允许并发的其他事务执行插入操作因而产生幻象现象，因为读已提交隔离级别是允许幻象异常存在的。如下代码，加锁的时候，根据隔离级别是否加间隙锁。
row_sel_get_clust_rec[1](...)
{...
if (!node-&gt;read_view) {
...
if (srv_locks_unsafe_for_binlog
|| trx-&gt;isolation_level &lt;= TRX_ISO_READ_COMMITTED) {
lock_type = LOCK_REC_NOT_GAP; //小于等于读已提交，则不加间隙锁，允许其他事务插入，因此可发生幻象
} else {
lock_type = LOCK_ORDINARY; //大于读已提交，则加间隙锁，防止其他事务插入某个范围内的数据，避免幻象
}
...} 其次，要确定可以读取到什么样的元组，即判断是不是没有被提交的元组也可以读到。既然是读已提交级别，则必然是只能读取到已经被提交的元组，这样才能体现“已提交”的含义。这时，就涉及到数据的可见性判断的问题（本节不讨论可见性问题，详情参见12.2节）。
解锁部分，要及时释放锁，这样便于其他事务能够读取到不应当被本事务锁定的记录（InnoDB中“记录”是索引项，通过记录才能真正找到元组）。以索引上的范围扫描为例，查看锁的释放条件。
ha_innopart::read_range_next_in_part(...) //Return next record in index range scan from a partition
{...
error = ha_innobase::index_next(read_record); //获得记录，则会加锁，此时error的值被赋予0
if (error == 0 &amp;&amp; !in_range_check_pushed_down) { //记录被加过了锁
/* compare_key uses table-&gt;record[0], so we need to copy the data if not already there. */
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f5dae54e9f6feef9ab11f90b54402df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7330c72d4d7506e7cb5fdb39addea23b/" rel="bookmark">
			C&#43;&#43;11新特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.auto关键字
C++11中引入auto第一种作用是为了自动类型推导。auto的自动类型推导，用于从初始化表达式中推断出变量的数据类型。通过auto的自动类型推导，可以大大简化我们的编程工作。auto实际上是在编译时对变量进行了类型推导，所以不会对程序的运行效率造成不良影响。另外，似乎auto并不会影响编译速度，因为编译时本来也要右侧推导然后判断与左侧是否匹配。 auto a; // 错误，auto是通过初始化表达式进行类型推导，如果没有初始化表达式，就无法确定a的类型 auto i = 1;//i is an int auto d = 1.0;//d is a double auto str = "Hello World"; auto ch = 'A'; auto func = less&lt;int&gt;(); vector&lt;int&gt; iv; auto iter = iv.begin(); auto p = new foo(); // p is a foo* auto不光有以上的应用，它在模板中也是大显身手，比如下例这个加工产品的例子中，如果不使用auto就必须声明Product这一模板参数： template &lt;typename Product, typename Creator&gt; void processProduct(const Creator&amp; creator) { Product* val = creator.makeObject(); // do somthing with val } 如果使用auto，则可以这样写： template &lt;typename Creator&gt; void processProduct(const Creator&amp; creator) { auto val = creator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7330c72d4d7506e7cb5fdb39addea23b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3191c9d9f7341ad2eac13d6567076b6/" rel="bookmark">
			mysql主从复制与分库分表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、主从复制的概念 1、什么是主从复制？
主从复制，是用来建立若干个和主库完全一样的数据库环境，称为从库；
2、主从复制的好处？
1）做数据的热备：主库发生故障后，可切换到从库提供服务。
2）数据量越来越大，导致单机TPS、内存、I/O访问频率越来越高，单机性能越来越差，此时增加多个从库，可以降低单机磁盘I/O访问的频率，提高单机的I/O性能。
3）读写分离，使数据库能支撑更大的并发。
读写分离对于报表系统中尤其重要，由于部分报表sql语句非常的慢，会导致锁表，影响读请求的速度。
3、主从复制的原理（三个线程）
1）主库的更新事件(update、insert、delete)被写到binlog
2）从库创建一个I/O线程连接到主库
3）主库创建一个binlog dump 线程，把binlog的内容发送到从库
4）从库读取主库传过来的binlog内容并写入到relay log
5）从库创建一个SQL线程，从relay log里面读取内容，更新到从库
由于mysql实现的主从复制是异步复制，所以主从库之间数据有一定差异，在从库上的查询操作需要考虑到这些数据的差异，一般只有更新不频繁的数据或者对实时性要求不高的数据，可以通过从库查询，实时性要求高的数据仍然需要从主库获得。
二、配置主库 假如有两台服务器，172.23.29.111和172.23.21.112，前者为主服务器，后者为从服务器
1、172.23.29.111上创建从服务器的用户changhf（该用户在从服务器上已存在），需要先用root登录，先后执行sql:
mysql&gt;CREATE USER 'changhf'@'172.23.29.112' IDENTIFIED BY '123456'; mysql&gt;GRANT REPLICATION SLAVE ON *.* TO 'changhf'@'172.23.29.112' IDENTIFIED BY '123456'; 不要用其他正在使用着的用户，建立主从关系后，会改变该用户的权限，我在这里掉到坑里了。用的已经存在的用户cms，导致该用户怎么也登录不上了。
2、vi my.cnf 在[mysqld]下面添加
binlog-do-db=zy_mycat1 binlog-do-db=zy_mycat2 binlog-do-db=zy_mycat3 binlog_ignore_db=mysql 3、先在主服务器上锁定所有的表，以免在复制过程中数据发生变化。
mysql&gt;FLUSH TABLES WITH READ LOCK; 4、退出mysql
mysql&gt;quit mysqldump -uroot -p123456 --databases zy_mycat1 zy_mycat2 zy_mycat3 --lock-tables=false -- &gt; /root/mycat_backup.sql 5、从当前服务器传递文件到另一台服务器
scp /root/all.sql root@172.23.21.222:/root 6、再次连接数据库进入mysql命令行查看master状态
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3191c9d9f7341ad2eac13d6567076b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b6587a1e2b0fcafd0eba1880e814275/" rel="bookmark">
			Gauss Laplacian Pyramid
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pyramid Gaussian and laplacian pyramids are applying gaussian and laplacian filter in an image in cascade order with different kernel sizes of gaussian and laplacian filter.
Figure. 1 shows pyramid of image. Full image resolution is taken at level 0.
At each step up level image resolution is down sample by 2. So if starting image size is 256 X 256 at level 0 in level 1 image size will be 128 X 128.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b6587a1e2b0fcafd0eba1880e814275/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/118/">«</a>
	<span class="pagination__item pagination__item--current">119/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/120/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>