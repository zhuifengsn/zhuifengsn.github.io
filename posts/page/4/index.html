<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4eeddc62f23768e4a17105fc8ded36ce/" rel="bookmark">
			Android基础开发-数据存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SharedPreferences-xml 共享参数的用法
SharedPreferences是Android的一个轻量级存储工具，采用的存储结构是Key-Value的
键值对方式。
共享参数的存储介质是符合XML规范的配置文件。保存路径是:/data/data/应用包名/shared_prefs/文件名.xml
类似于java中的*.properties的配置文件
共享参数的使用场景
共享参数主要适用于如下场合:
简单且孤立的数据。若是复杂且相互间有关的数据，则要保存在数据库中。
文本形式的数据。若是二进制数据，则要保存在文件中。
需要持久化存储的数据。在App退出后再次启动时，之前保存的数据仍然有效。
实际开发中，共享参数经常存储的数据有App的个性化配置信息、用户使用App的行为信
息、临时需要保存的片段信息等。
程序闪退，保存到内存中的信息是没有的。
//data目录下，创建一个config.xml的文件 SharedPreferences config = getSharedPreferences("config", Context.MODE_PRIVATE); SharedPreferences.Editor edit = config.edit(); edit.putString("hello","world"); edit.commit(); String hello = config.getString("hello",""); &lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?&gt; &lt;map&gt; &lt;string name="hello"&gt;world&lt;/string&gt; &lt;/map&gt; 数据库SQLite-*.sql sQLiteDatabase是SQLiteH0B法有3类:
管理类，用于数据库层面的操作。
openDatabase:打开指定路径的数据库。
isOpen:判断数据库是否已打开。
close:关闭数据库。
getVersion:获取数据库的版本号。
setVersion:设置数据库的版本号。
SQLiteDatabase sqLiteDatabase = openOrCreateDatabase(getFilesDir() + "/test.db", Context.MODE_PRIVATE, null); String path = sqLiteDatabase.getPath(); Toast.makeText(this,"path的值=="+path, Toast.LENGTH_SHORT).show(); // deleteDatabase(getFilesDir() + "/test.db"); 数据库管理器SQLiteDatabase
事务类,用于事务层面的操作。
beginTransaction:开始事务。
setTransactionSuccessful:设置事务的成功标志。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4eeddc62f23768e4a17105fc8ded36ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8627eb01a4d8b2720233e766faecfda2/" rel="bookmark">
			哪种文件摆渡系统 可以实现跨网文件安全收发？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着网络技术和互联网技术的成熟和高速发展，来自互联网的安全威胁越来越严重。大多数企业为了防止内部核心数据泄露，内部都划分高密网和低密网进行隔离，确保网络间数据安全性。
企业内部不同网络之间，以及企业内部网络和外部合作伙伴之间，数据交换是客观存在的需求，很多企业会采用传统的数据摆渡方式，如使用U盘、FTP等，这些传统方式存在多个缺点，主要包括：
1、安全性低：传统方式缺乏有效的安全策略，例如U盘容易感染病毒，FTP传输过程中数据以明文形式传输，容易被窃取。
2、难以监管：人工拷贝的方式难以监管传输的内容，FTP没有审批功能，难以确保传输数据的合规性。
3、无法收缴外部文件：这些方式最多只能解决文件对外传输的问题，外部合作伙伴的文件无法收缴进来。
4、追溯功能弱：传统方式在追踪文件传输方面功能有限，难以记录详细的传输信息，如发送者、接收者、发送时间等。
5、不可靠：在传输过程中容易出现传输错误、文件丢失，且发送者无法确认收件人是否成功接收文件。
6、大文件传输慢：对于大文件，如设计图纸、软件包、视频文件等，U盘拷贝和FTP传输速度都很慢。
7、操作繁琐：所有流程都需要人工操作，效率低下，特别是在业务量大时，可能需要排队等待，影响业务效率。
8、合规性风险：传统方式可能违反数据保护法规，导致法律风险，尤其是在金融、医疗等受行业监管的领域。
为了克服这些缺点，许多企业开始寻求更安全、可控、高效的数据摆渡系统，比如类似于《Ftrans 跨网文件安全交换系统》这种专业的跨网文件安全交换系统，以满足现代数据交换的需求。
《Ftrans 跨网文件安全交换系统》是飞驰云联（南京）科技有限公司自主研发的一款文件传输软件产品，帮助企业和组织在隔离网络之间（研发网-办公网、生产网-测试网、内网-外网，等等），建立安全合规、高效便捷的统一跨网文件交换通道。该产品具有以下功能特色：
1、内置多重安全策略 有效保护数据安全性
系统可对发送的文件属性和内容进行全方面的检测，包括文件的大小、文件名、文件个数、文件来源、敏感内容、文件类型、是否含有病毒等。可配置多种组合条件对不合规的文件进行阻断，符合安全标准的文件才能发送。
系统内置防病毒管理模块，可进行定时更新。可以对用户发送或上传的文件进行病毒检测，检测到的病毒文件放入隔离区。
同时还支持传输加密、落盘加密等。
2、内置灵活审批流程，实现多维度数据管控
系统提供内置的审批审核功能。管理员按照业务的需要建立传输审核审批流程。系统支持审核审批触发条件配置管理，管理员可预制审核流程，当文件名称、扩展名、单体文件大小、总文件大小、操作人及目标人范围等触发了审核条件时，系统将转向指定的人工审批流程，也可以和 OA、BPM、workflow 等系统进行外部审批集成。
3、实现内外部双向文件收发
该系统支持内部向外部发送文件，同时支持主动从外部收集文件；系统提供类邮件的文件包方式，精确指定外部接收人，同时提供文件收集链接，可主动邀请外部协作方按指定要求提交文件。
4、完整的日志可随时审计追溯
系统提供审核查询功能，对触发审核的相关发送行为进行完整的日志记录，可记录发起人、审核状态、审核内容、时间等多个信息。
系统提供传输动态查询功能，管理员登录后台空间管理界面后，可通过传输动态对全局下的传输行为进行查询，可对业务动作，传输状态等进行定位查询。
5、高性能传输保障，提高业务效率
系统内置高性能传输引擎，不限文件大小和数量，轻松实现TB级超大文件、百万级海量文件传输，支持断点续传、文件校验，提供充分的可靠性，特别适用于图纸、图像、代码、日志等大规模文件收发。
6、操作便捷易上手
仅需通用浏览器即可使用，用户界面清晰明了，功能操作和收发流程简单便捷，极大降低了用户学习成本，提升了终端用户满意度，易于在组织内外部推行。
7、符合等保及相关行业要求
系统部署架构采用前置机模式，即隔离设备两侧分别部署文件交换服务器和文件交换系统，不改变、破坏原有网络隔离架构。用户跨网发出的文件均暂存在本侧网络的服务器上，未经安全检查和审核，数据不会跨越网络，保持网络边界清晰、可控，完全符合等保要求。
对于企业来说，建立完善的跨网文件安全收发体系至关重要，《Ftrans 跨网文件安全交换系统》可以为企业建立统一、便捷、安全的数据摆渡通道。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ea84ac30502fe6e19dbea3f94d9e44d/" rel="bookmark">
			HarmonyOS-配置卡片的配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置卡片的配置文件 卡片相关的配置文件主要包含FormExtensionAbility的配置和卡片的配置两部分：
卡片需要在module.json5配置文件中的extensionAbilities标签下，配置FormExtensionAbility相关信息。FormExtensionAbility需要填写metadata元信息标签，其中键名称为固定字符串“ohos.extension.form”，资源为卡片的具体配置信息的索引。
配置示例如下：
{ "module": { ... "extensionAbilities": [ { "name": "EntryFormAbility", "srcEntrance": "./ets/entryformability/EntryFormAbility.ts", "label": "$string:EntryFormAbility_label", "description": "$string:EntryFormAbility_desc", "type": "form", "metadata": [ { "name": "ohos.extension.form", "resource": "$profile:form_config" } ] } ] } } 卡片的具体配置信息。在上述FormExtensionAbility的元信息（“metadata”配置项）中，可以指定卡片具体配置信息的资源索引。例如当resource指定为$profile:form_config时，会使用开发视图的resources/base/profile/目录下的form_config.json作为卡片profile配置文件。内部字段结构说明如下表所示。
表1 卡片form_config.json配置文件
属性名称含义数据类型是否可缺省name表示卡片的类名，字符串最大长度为127字节。字符串否description表示卡片的描述。取值可以是描述性内容，也可以是对描述性内容的资源索引，以支持多语言。字符串最大长度为255字节。该属性将显示在卡片预览界面上，以便用户识别不同卡片。字符串可缺省，缺省为空。src表示卡片对应的UI代码的完整路径。当为ArkTS卡片时，完整路径需要包含卡片文件的后缀，如：“./ets/widget/pages/WidgetCard.ets”。当为JS卡片时，完整路径无需包含卡片文件的后缀，如：“./js/widget/pages/WidgetCard”字符串否uiSyntax表示该卡片的类型，当前支持如下两种类型：- arkts：当前卡片为ArkTS卡片。- hml：当前卡片为JS卡片。字符串可缺省，缺省值为hmlwindow用于定义与显示窗口相关的配置。对象可缺省isDefault表示该卡片是否为默认卡片，每个UIAbility有且只有一个默认卡片。- true：默认卡片。- false：非默认卡片。布尔值否colorMode表示卡片的主题样式，取值范围如下：- auto：自适应。- dark：深色主题。- light：浅色主题。字符串可缺省，缺省值为“auto”。supportDimensions表示卡片支持的外观规格，取值范围：- 1 * 2：表示1行2列的二宫格。- 2 * 2：表示2行2列的四宫格。- 2 * 4：表示2行4列的八宫格。- 4 * 4：表示4行4列的十六宫格。字符串数组否defaultDimension表示卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。字符串否updateEnabled表示卡片是否支持周期性刷新（包含定时刷新和定点刷新），取值范围：- true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，当两者同时配置时，定时刷新优先生效。- false：表示不支持周期性刷新。布尔类型否scheduledUpdateTime表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。&gt; 说明：&gt; updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。字符串可缺省，缺省时不进行定点刷新。updateDuration表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。当取值为0时，表示该参数不生效。当取值为正整数N时，表示刷新周期为30*N分钟。&gt; 说明：&gt; updateDuration参数优先级高于scheduledUpdateTime，两者同时配置时，以updateDuration配置的刷新时间为准。数值可缺省，缺省值为“0”。formConfigAbility表示卡片的配置跳转链接，采用URI格式。字符串可缺省，缺省值为空。formVisibleNotify标识是否允许卡片使用卡片可见性通知。字符串可缺省，缺省值为空。metadata表示卡片的自定义信息，包含customizeData数组标签。对象可缺省，缺省值为空。配置示例如下：
{ "forms": [ { "name": "widget", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ea84ac30502fe6e19dbea3f94d9e44d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/423ba0d53e0599e89295f06b772ee5b4/" rel="bookmark">
			Python世界之语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、条件语句
二、循环语句
1.While 循环语句
2.for 循环语句
三、循环嵌套
1.for 循环嵌套
2.while 循环嵌套
四、循环控制语句
1.break 语句
2.continue 语句
3.pass 语句
五、del语句
六、return 语句
一、条件语句 条件语句是通过一条或多条语句的执行结果（True或者False）来决定执行的代码块。
if 语句用于控制程序的执行，基本形式为：
if 判断条件：
执行语句……
else：
执行语句……
其中"判断条件"成立时（非零），则执行后面的语句，而执行内容可以多行，以缩进来区分表示同一范围。else 为可选语句，当需要在条件不成立时执行内容则可以执行相关语句。
当判断条件为多个值时，可以使用以下形式：
if 判断条件1:
执行语句1……
elif 判断条件2:
执行语句2……
elif 判断条件3:
执行语句3……
else:
执行语句4……
由于 python 并不支持 switch 语句，所以多个条件判断，只能用 elif 来实现，如果判断需要多个条件需同时判断时，可以使用 or （或），表示两个条件有一个成立时判断条件成功；使用 and （与）时，表示只有两个条件同时成立的情况下，判断条件才成功。
二、循环语句 1.While 循环语句 While 循环语句，其基本形式为：
while 判断条件(condition)：
执行语句(statements)……
执行语句可以是单个语句或语句块。判断条件可以是任何表达式，任何非零、或非空（null）的值均为true。当判断条件假 false 时，循环结束。
while 语句时还有另外两个重要的命令 continue，break 来跳过循环，continue 用于跳过该次循环，break 则是用于退出循环。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/423ba0d53e0599e89295f06b772ee5b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de39c02ea117ad8e0e26cac7c17be807/" rel="bookmark">
			ARMv8-AArch64 的异常处理模型详解之异常处理详解（同步异常和异步异常的分析和处理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 一，同步异常的分析1.1 同步异常分析-异常链接寄存器ELR1.2 同步异常分析-异常综合寄存器ESR，Exception Syndrome Register1.3 同步异常分析-错误地址寄存器FAR,Fault Address Register 二， 同步异常的处理示例 Synchronous exception handling三， 异步异常的处理示例 Asynchronous exception handling 一，同步异常的分析 在文章ARMv8-AArch64 的异常处理模型详解之异常类型 Exception types中提到过，同步异常是处理器在执行指令时产生的异常，是一种精确的，可以具体定位到是哪条指令导致异常的产生。下面笔者将介绍三个用于定位并分析同步异常产生的寄存器。
1.1 同步异常分析-异常链接寄存器ELR 在文章ARMv8-AArch64 的异常处理模型详解之异常向量表vector tables中提到过，同步异常发生时，会将产生同步异常的那条指令的地址写入ELR，所以如果想知道是哪条指令导致异常的产生，软件在处理异常时可以读取ELR中的值进行分析。
1.2 同步异常分析-异常综合寄存器ESR，Exception Syndrome Register ESR寄存器里保存着一些异常的诊断信息，比如异常产生的原因。在进入异常后，我们可以读取对应异常等级的ESR（ESR_EL1,ESR_EL2或者ESR_EL3），通过解析各个字段的数值所表示的含义，来分析出当前异常产生的原因。
拿ESR的EC, bits [31:26]举例，这个EC字段指示了当前异常产生的原因，比如当EC == 0b100010时，按照ARM文档的描述，我们可知当前异常是因为PC未对齐（地址不以0x0 0x4 0x8 0xc结尾）。
除了EC字段，还有IL字段，从该字段可知是32-bit长度还是16bit 长度的指令导致的异常：
1.3 同步异常分析-错误地址寄存器FAR,Fault Address Register FAR寄存器将为一些同步异常保存导致异常发生的地址，包括如下同步异常：
指令中止异常（Instruction Abort exceptions）, 此时ESR寄存器的EC 值为0x20 或者0x21，
数据中止异常，Data Abort exceptions, 此时ESR寄存器的EC 值为0x24 或者 0x25：
PC对齐错误异常，PC alignment fault exceptions，此时ESR寄存器的EC 值为0x22。
调试异常的观察点异常，Watchpoint exceptions，此时ESR寄存器的EC 值0x34 或者0x35：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de39c02ea117ad8e0e26cac7c17be807/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/224bcf6596b5b38c19194dc66bf206da/" rel="bookmark">
			肖志夫：美副防长宣称要以“光速”与中国争夺AI“制高点”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		肖志夫 昆仑策研究院 【点击上方“昆仑策研究院”可关注本号；点击右上角“...”可选用朗读功能，配音为电脑自动合成，难免差错，仅作辅助阅览用。】
【2024年2月21日，美国国防部副部长凯瑟琳·希克斯在华盛顿举行的“优势2024国防数据与人工智能研讨会”上发表讲话。】
据美媒2024年2月22日报道，由五角大楼首席数字和人工智能办公室主办的为期3天的“优势国防部2024：国防数据和人工智能研讨会”在华盛顿结束，国防部副部长凯瑟琳·希克斯发表了主旨演讲。笔者对演讲内容进行整理，分享如下：
1. 发布一项人工智能研究最新成果
希克斯在演讲中正式宣布，国防部已经交付了联合全域指挥控制能力（the Combined Joint All-Domain Command and Control, or CJADC2）的初始版本。初始版本代表了结合软件应用、数据集成和跨领域作战概念的最低可行能力，旨在为作战人员提供决策优势。她说，“CJADC2的最低可行能力是真实的，现在已经准备好了”，它是国防部开发物质和非物质解决方案的方法，为指挥官提供信息和决策优势。其目标是在所有作战领域应用CJADC2方法，使作战人员在威慑和必要时击败全球任何地方的对手具有优势。
当然，CJADC2不是一个平台或单一系统，这是概念、技术、政策、工具和人才的融合，推动了我们与关键盟友和伙伴一起指挥和控制部队的方式。
在2023年9月，美国国防部专门成立了首席数字和人工智能办公室（CDAO），“通过CDAO加速国防部从会议室到战场采用人工智能的任务，我们正在以一种他们从未体验过的方式为国防部领导人和服务成员提供决策优势。”
在过去的一年里，CDAO及其合作伙伴利用一系列全球信息优势实验为这项工作设定了令人欣喜的快节奏：每90天，我们就要迭代一次能力开发和交付。我们将在2024年继续保持这一势头。
希克斯指出，CDAO在完成初始迭代中起到了关键作用，被要求在短短几个月内交付最低可行能力。她说，由于安全原因，她不能透露宣布的初始功能是专门为哪里或为什么开发的。“但我可以告诉你，这不是一项容易的任务，尤其是在6个月内，”她说，“但通过许多团队的大量辛勤工作，将多个司令部的操作员与国防部和工业界的工程师配对，他们按时按目标交付了产品。”
【2023年2月17日，加州马奇空军基地，第492攻击中队的一名飞行员在MQ-9模拟器中指导来自加州大学圣地亚哥分校的学生。】
2. 与中国处于一场持久的代际不对称优势竞争中
希克斯说，不存在“为什么”的争论，“原因毋庸置疑，因为这些技术给了我们比现在更好的决策优势。鉴于我们在遏制和防御侵略方面面临中华人民共和国的快速挑战，这是势在必行的。”
在威慑和防御侵略方面，人工智能系统可以大大提高指挥官决策的速度、质量和准确性——这对于威慑战斗和赢得战斗具有决定性作用。
“中国是世界上唯一一个既有意愿，也越来越有能力以严重损害美国重大利益的方式重塑国际秩序的国家”，国防部已经制定了对抗中国的战略、理论、政策和资源，包括人工智能“武装”军队。
“我们应该看看中国，真正了解他们在哪里，他们在做什么——自二战以来最大规模的军事建设，包括常规力量和战略核力量，我们一直寻求推动整个国防部创新的核心，特别是在这个与中华人民共和国进行战略竞争的持久时代”，“虽然国防部总是迫切需要创新，但毫无疑问，这一迫切需要近年来变得更加紧迫。”
人工智能需要整理所有数据以寻找对手威胁，而不是一名分析师每天阅读数百或数千份报告。“让人工智能识别关键信息，或许还可以做一些基本分析，让分析师专注于难题集，这样他们就不会浪费时间、资源和人力。”我们的对手每天都在试图越过我们的边界和我们的安全，所以我们必须以“光速”前进，“利用人工智能来试图超越这一点将是至关重要的”。
不过，永远不要自满，希克斯说，这是一场旷日持久的战役，技术会不断变化，今天的好习惯和最佳实践总有一天会过时，我们的全球竞争对手也将继续提升他们的能力。因此，我们也必须不断学习、成长、进化和鞭策自己。
这些竞争对手应该知道：我们将长期参与其中。毕竟，中国的节奏挑战是一代人的挑战。
作为一个国家和军队，我们坚定地致力于在今天、明天以及可预见的未来保持领先于我们的竞争对手，不管要花多长时间。
数据和人工智能是增强我们作战人员能力的必要条件，我们必须利用这一点。我们必须迅速行动，因为我们的竞争对手也在迅速行动，所以我们需要速度和安全，我们必须负责任且迅速。
3. 需要人工智能管理国防部全球资产
在管理（国防部）这个世界上最大的“企业”方面，我们的工资单上有近300万人，为900多万军人、退休人员和家庭成员服务的医疗保健系统；资产遍布全球2500万英亩，大致相当于肯塔基州的面积，国防部全球资产的价值远远超过亚马逊、苹果、微软和沃尔玛的总和。在这种规模下，我们必须利用数据和人工智能更智能、更快、更好地管理纳税人的钱。
因此，在2022年，根据商业最佳实践，我们整合了4个不同的数字、人工智能和分析团队，由一名授权的首席数字和人工智能官（CDAO）领导，他直接向国防部长报告。CDAO的核心任务是加速国防部从会议室到战场对数据、分析和人工智能的采用。在短时间内，我们看到了显著的进步。
【2022年9月13日，在阿拉斯加的Noble Defender行动中，来自西海岸的海军特种作战司令部的人员操作R80D SkyRaider无人机。】
4. 一分投资一分战斗力
希克斯说，在过去的十几年里，机器学习的进步带来了新一代的人工智能创新。我们今天在国防部的任务是在任何能够增加最大军事价值的地方采用这些创新。从第一天起，这就是奥斯汀部长和我的首要任务。
我们知道，我们必须迅速和负责任地建设——现在进行迭代和投资，以提供更加现代化的数据驱动和人工智能赋能的军队。
“交付不需要几年或几十年，”希克斯说，“我们在数据、人工智能和计算方面的投资正在增强现代战争战士的能力。”国防部打算在成功的基础上扩大规模，它还需要国会提供可预测和及时的拨款。
希克斯说：“没有资源我们做不到。我们的一名作战指挥官最近找到我，指出如果没有我们2024财年的拨款，他们所依赖的CDAO预付款将付之东流。”她说：“我们需要国会团结起来，早就应该这么做了，拖延是毁灭性的。”
在人工智能“武装”军队方面保持强劲的和持续的投入，是“美国建立持久军事优势战略的关键部分”。希克斯说：国防部2024财年的预算包括1450亿美元的研发费用和1700亿美元的采购费用，这清楚地表明了其保持领先地位的承诺，“这在8420亿美元的预算中占了很大比例（37.4%），我要指出的是，这是这些领域有史以来最大的一笔承诺。”她说，这些对先进技术的投资，以及国防部利用美国盟友的能力，对于遏制和防止未来的冲突至关重要。
5. 数据和AI不是武器
希克斯说，这些努力正在以物质方式推进美国的能力，但它们不是“人工智能军备竞赛”，我们不是这么看的，我们也不寻求这样的军备竞赛。
毕竟，数据和AI不是武器，它们是基本的通用技术，就像电力一样。历史具有教育意义：电最大的军事用途不是电死敌军（笑声）。
相反，电的价值在于几乎无关痛痒的功能：收音机，雷达，半导体，卫星，夜视镜，数据链接，战斗网络，精确制导弹药，使匕首隐形轰炸机能够飞行的航空电子设备，WiFi……所有这些对军队来说如此基础和具有变革性的东西，起初看起来都像是魔法。今天，这些技术继续发展和改进，然而它们变得如此普遍，以至于许多人现在认为它们是理所当然的，它们几乎很无聊。
数据和AI也是如此。事实上，最具变革性的用例可能看起来很无聊，但它们是必不可少的，因为它们为作战人员和所有支持他们的人提供了支持。
这意味着数据和人工智能的优势将落入更好、更快、更智能和更安全地使用它们的国家手中。今天，这就是美利坚合众国。我们有更好的芯片、更好的人才、更好的技术和更好的价值观来指导我们如何使用数据和人工智能。
我们打算保持领先地位。我们的优势来自于谁在构建它们，谁在使用它们，以及我们如何使用它们。在这些舞台上，美国永远是不可战胜的。
6. 发展人工智能人才是关键
希克斯表示，保持领先地位需要持续改善内部流程、投资人才以及与行业建立有效的合作伙伴关系。我们必须不断改进招聘和留住私营部门急需的顶尖人才的方式。
我们很幸运，能够在整个联合部队中培养我们自己的人才，我们的团队中有这么多优秀的数据科学家、软件工程师和分析师——许多人就在这个房间里——他们都是世界级的技术头脑，尽管有许多其他职业选择，他们仍然选择服役。
正如第二次世界大战期间商界领袖离开最高管理层帮助我们超越轴心国一样，今天我们也很幸运，私营部门的顶尖技术人才越来越多地选择为我们工作并与我们合作——离开来福车、苹果、谷歌人工智能等公司的高薪工作岗位。
他们每个人都看到并知道我们与中华人民共和国的这场战略竞争的利害关系，激励他们的不仅仅是爱国主义，这是一种真诚的服务愿望，他们觉得有责任回报给他们如此多机会的国家。因为他们知道，美国如此多的创新成功是由美国的民主制度、政府投资、良好的学校、平等权利和保护我们所有人的全面自由促成的。
爱国主义和对公共服务的呼吁是强大的东西，但他们并不是全能的。至少，不是对每个人都是如此。薪酬很重要，员工文化很重要，团队建设很重要，我们如何待人很重要，培训、职业发展、陪伴家人的时间……这些都很重要。
有工具和信息技术可以让你在工作时不用手忙脚乱，这也很重要（笑声）。
引进人才，利用国会赋予我们的所有灵活权力来缩短招聘时间，给人们带来有意义和目标的工作，确保每个人都可以休假，并每隔一段时间充电……所有这些都很重要。
2月22日，知名旅美教授李毅给笔者留言：关于AI问题，我今年已经做了2期节目，但是我讲了之后并没有起到轰动效应，也没有引起有关方面的重视。现在一两个月过去了，已经发展成这个样子了，2月15日美国人工智能研究公司OpenAI正式发布了人工智能文生视频大模型“世界模拟器”Sora。人工智能这个东西的发展速度太快了，可谓一日千里……
笔者以为，确实应该引起我们的高度重视，因为人工智能可能成为新一轮科技革命和产业变革的重要驱动力量。随着人工智能在美国各个领域的加持、植入、运用，尤其是在军事领域的人工智能化，可能带来军事科技革命的“突变”，进而大幅提升美军的战斗力，并迅速拉大与世界各国军力的差距，甚至引发未来战争形态的改变。毫无疑问，谁最先拥有“人工智能武装”，谁将具备对敌降维打击能力。
（作者系昆仑策研究院特约研究员；来源：昆仑策网【原创】，作者授权首发）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48424ff3269e611d143cdc3da6c75454/" rel="bookmark">
			数学结构和智能结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		集合结构、代数结构、拓扑结构和人工智能结构都是数学中研究的不同的数学结构。它们之间的关系可以从以下几个方面来看：
集合结构是最基本的数学结构，研究的是元素之间的关系。集合可以包含不同的元素，其关系可以通过集合的交、并、差等操作进行描述。代数结构和拓扑结构可以看作是集合结构的一种特定形式。例如，代数结构研究的是集合上定义了特定的操作（如加法、乘法等）的结构，而拓扑结构研究的是集合上定义了特定的拓扑性质（如连续性、开集等）的结构。
代数结构是集合结构的一个扩展，研究的是集合上定义了特定的操作和关系的结构。代数结构包括群、环、域等，这些结构可以通过特定的代数运算进行描述。代数结构的研究可以帮助我们理解和解决各种数学问题，例如线性代数、群论、环论等。
拓扑结构是集合结构的另一种扩展，研究的是集合上定义了特定的拓扑性质的结构。拓扑结构关注的是元素之间的连通性和邻近关系，通过定义了开集、闭集等概念来描述。拓扑结构在几何学、分析学、拓扑学等领域有广泛的应用。
人工智能结构是对集合结构、代数结构和拓扑结构的进一步扩展，研究的是具有智能行为和能力的结构。智能结构可以通过定义智能算法、人工智能模型等来描述。智能结构的研究可以帮助我们理解和模拟人工智能的行为和能力，例如机器学习、深度学习、人工神经网络等。
简而言之，集合结构、代数结构、拓扑结构和智能结构都是数学中研究的不同的数学结构，它们之间存在联系和扩展关系，通过研究和应用这些结构，可以深入理解和解决各种数学和实际问题。
智能的结构指的是人类智慧的组织和运作方式。数学的结构是指数学领域中的逻辑、推理和模式等规律性的结构。智能的结构可能会超越数学的结构：、
数学是人类对自然界规律的抽象和描述，而智能包含了更广泛的认知和情感因素。智能的结构可能涉及到更复杂的脑部网络和心理过程，超越了数学所能描述的范围。
智能的结构可能具有更高级的创造性和灵活性。数学的结构是基于公理和规则的逻辑推理，而智能的结构可以超越这些限制，能够创造新的观念和思维模式。
智能的结构可能涉及到更复杂的因果关系和非线性的关联。数学的结构通常是基于线性和确定性的关系，而智能的结构可能包含更多的不确定性和非线性因素，涉及到更复杂的因果网络。
总之，智能的结构可能会超越数学的结构，因为智能涉及到更广泛和复杂的认知、情感和创造性因素，包含了数学所不能完全描述的特质和能力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c096f04e4b4d57ed6578ed397efb1105/" rel="bookmark">
			HTTP---------状态码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当服务端返回 HTTP 响应时，会带有一个状态码，用于表示特定的请求结果。比如 HTTP/1.1 200 OK，里面的 HTTP/1.1 表示协议版本，200 则是状态码，OK 则是对状态码的描述。
由协议版本、状态码、描述信息组成的行被称为起始行，服务端返回的响应报文中的第一行便是它，然后是响应头和响应体。
首先状态码由三位数字组成，按照第一个数字的不同，可分为五个类别，每个类别的含义如下
1xx（信息响应）：这类状态码表示临时响应，意思是告诉客户端，服务端已收到部分请求，请你继续发送剩余的部分；
2xx（成功）：这类状态码表示客户端的请求已被成功处理；
3xx（重定向）：这类状态码表示为了完成请求，需要进一步的操作，比如跳转到新位置；
4xx（客户端错误）：这类状态码表示请求不合法，比如操作一个没有权限的资源或者不存在的资源等等；
5xx（服务端错误）：这类状态码表示服务端内部在处理请求时出现错误，比如服务端的代码报错；
3xx 系列的状态码属于重定向类别，用于告知客户端资源的获取方式已经改变，需要采取额外动作以完成请求。
比如访问一个已经废弃的链接，服务端就会返回 3xx 状态码，并在响应头的 Location 字段中指定新链接。客户端发现状态码为 3xx 之后，就会自动重定向到 Location 中指定的新链接。
另外在 RFC2068 中，规定客户端重定向次数不应超过 5 次，以防止死循环。
300 Mutiple Choices 当请求的资源有多种表示时，服务端会返回 300，并提供一个资源列表，让客户端自行选择。由于缺乏明确的细节，因此该状态码不常用。
301 Moved Permanently 表示请求的资源已经被永久移动到了一个新的位置，该状态码的使用场景如下。
永久性重定向：当服务端返回 301 Moved Permanently 响应时，它表明请求的资源已经永久地移动到了由 Location 字段指定的 URL，未来所有对该资源的请求都应该使用这个新的URL。
更新书签和链接：301 状态码告诉客户端（如浏览器或搜索引擎）更新其链接或书签。对于搜索引擎优化（SEO）来说，这意味着应将原先页面的权重转移给新的 URL。
搜索引擎优化：在SEO的背景下，使用 301 Moved Permanently 是管理网站结构变化的最佳实践。它有助于维持旧 URL 的搜索排名和信誉，并将其传递给新 URL。
重定向方法：与临时重定向（如 302 Found 或 307 Temporary Redirect）不同，301 是永久性的。这告诉客户端在未来的所有请求中都应使用新的 URL，而不是临时性地查找资源。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c096f04e4b4d57ed6578ed397efb1105/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54d958e5d615f83d08b5988e1f0537dc/" rel="bookmark">
			Linux之部署前后端分离项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx配置安装 1.安装依赖 我们这里安装的依赖是有4个的
[root@localhost opt]# yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel 2.上传解压安装包 [root@localhost opt]# tar -xvf nginx-1.13.7.tar.gz -C /usr/local/java/ 3.安装Nginx （1）进入安装包目录
cd nginx-1.13.7 （2）安装ssl证书
./configure --with-http_stub_status_module --with-http_ssl_module （3）安装编译
make &amp;&amp; make install 启动 nginx 服务 安装好的 nginx 服务在 /usr/local/nginx 下：
进入 /usr/local/nginx/sbin 目录下启动：
启动：./nginx
重启：./nginx -s reload
关闭：./nginx -s stop
下载lsof命令：yum install -y lsof
查看端口：lsof -i:端口号、kill -9 pid
开放端口 （1）开放端口
firewall-cmd --zone=public --add-port=80/tcp --permanent （2）刷新防火墙规则
firewall-cmd --reload （3）查看防火墙列表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54d958e5d615f83d08b5988e1f0537dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d31b5956db1701e8279206b04826beb/" rel="bookmark">
			智能SQL生成：后端技术与LLM的完美结合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引言一、什么是大模型二、为什么选择LLM三、开发技术说明四、系统架构说明五、编码实战1. Maven2. 讯飞大模型配置类3. LLM相关的封装4. 编写LLM的service5. 编写controller6. 运行测试 六、总结 引言 本篇文章主要是关于实现一个类似Chat2DB的根据自然语言生成SQL的简单Demo，根据此Demo可以入门大模型应用开发，结合大模型开发出属于自己的大模型应用，让自己的应用智能化，可以根据用户不同问题做出不同的回答。
一、什么是大模型 如果各位有关注一些技术文章，难免会注意到这几年有一个词非常火，没错这就是“大模型”！
那大模型是什么？有什么用呢？
“大模型”是可以指任何规模较大、参数众多的机器学习模型，不仅限于自然语言处理（NLP），也可以包括计算机视觉、语音识别等其他领域的模型。大模型的特点是它们通常需要大量的数据来训练，以及相对较大的计算资源。
大模型的用途十分广泛，在很多领域都有不错的应用价值：
自然语言的生成和理解：大模型可以根据用户的问题生成连贯的文本回答、或是总结某些文章。ChatGPT就是一个不错的例子。图像的处理：例如OpenAI的DALL·E模型，它可以根据用户问题，生成新的图像。语言的识别和生成：大模型可以将文本信息转化为人类的语言。推荐系统：大模型可以根据用户的行为或某些数据，推测用户的行为爱好，实现个性化推荐。 大模型的应用十分广泛，除了上面举的例子外，还有很多例子，这里就不一一举例了。
下面我会使用大模型的其中一种**大型语言模型（Large Language Model，简称LLM）**开发出一些简单的应用Demo，读者可以根据这样的思路进一步完善。
在此之前，先来介绍一下LLM是何物。LLM是指专门用来处理和理解自然语言的大型机器学习模型，LLM通常通过在大量文本数据上进行预训练来学习语言的结构和语义，从而能够执行各种语言处理任务，如文本生成、翻译、摘要、问答和情感分析等。
二、为什么选择LLM LLM大模型是一款专注于理解和生成自然语言的大模型，那我们系统中无论是Redis还是MySQL的数据，都是文本形式的，将这些文本信息的数据交与大模型处理，能够有针对性地获取到我们想要的数据。
其次，LLM的使用成本较低，国内的大模型无论是讯飞星火大模型还是其他互联网厂商自研的大模型都为开发者提供了不少的免费Token，使得学习成本大大降低。
LLM大模型也是我们大部分人群目前接触最多的大模型，学习成本大幅度降低，只需要知道如何和大模型进行聊天即可懂得如何开发，不需要任何额外的学习成本。
三、开发技术说明 本文使用的大模型为讯飞星火大模型，但是咱们不限于任何厂商的大模型，有能力的ChatGPT也可以，作者只是觉得讯飞星火大模型送的Token比较多，非常适合初学者。
读者需要自行前往讯飞星火认知大模型-AI大语言模型-星火大模型-科大讯飞 (xfyun.cn)进行领取免费Token，领取教程这里就不多讲了，网上大把教程，不懂的可以下面留言。
其次，该教程后端方面需要懂得使用SpringBoot进行开发，也就是简单的一个接口开发，没有任何的前端。
最后，开发出来的Demo只是一个抛砖引玉的作用，开发过程中不会考虑太多的规范和其他一些限制，只是单纯把一个小功能实现，代码量也不多，一千行不到。
如果这些都准备好了，那么下面开始发车。
四、系统架构说明 本篇文章会带大家结合后端技术与讯飞星火大模型实现实现根据用户的自然语言问题生成SQL的工具。
自然语言生成SQL？是不是很熟悉，没错，这里是参考了阿里开源的Chat2DB数据库管理功能，不过这里是作者对这个功能自主实现的Demo，没有翻阅过Chat2DB源码，故这里的实现可能并不是Chat2DB的底层实现原理
有能力的可以自己去看看源码：Chat2DB: Chat2DB 是一款有开源免费的多数据库客户端工具，支持windows、mac本地安装，也支持服务器端部署，web网页访问。和传统的数据库客户端软件Navicat、DBeaver 相比Chat2DB集成了AIGC的能力，能够将自然语言转换为SQL，也可以将SQL转换为自然语言，可以给出研发人员SQL的优化建议，极大的提升人员的效率，是AI时代数据库研发人员的利器，未来即使不懂SQL的运营业务也可 (gitee.com)
怎么根据用户的自然语言描述生成用户想要的SQL呢？下面我们来分析分析
首先，用户发送一个包含数据库host、user、password、table、用户问题的请求给后端后端根据用户提供的数据库信息，连接数据库查询出该表的DDL后端与LLM建立连接，将DDL、用户问题、prompt发送给LLMLLM根据后端提供的数据以及问题，推测分析并生成SQL，将SQL返回给后端后端将SQL返回响应给用户 也就是说，后端需要获取并整理数据，然后与LLM建立连接，将数据发送给LLM，LLM再根据数据做出回答，返回给后端SQL，这样就实现了自然语言生成SQL
五、编码实战 了解了整体架构是如何之后，我们进入了编码实战阶段，编码整体来说比较简单，重要的理解整体的架构
1. Maven 构建SpringBoot项目，引入一些我们需要的Maven依赖
&lt;dependencies&gt; &lt;!-- SpringBoot Web容器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.12.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d31b5956db1701e8279206b04826beb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2751a1a7c9555f0a81ea534979031e39/" rel="bookmark">
			Java/Python/Go不同开发语言基础数据结构和相关操作总结-GC篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java/Python/Go不同开发语言基础数据结构和相关操作总结 1. 常见gc方式1.1 gc判断对象是否存活1.2 引用计数法1.2 标记-清除算法1.3 复制算法1.4 标记-压缩算法1.5 分代收集算法 2. java的gc方式以及垃圾回收器2.1 gc方式2.1 gc回收器2.1.1 Serial收集器2.1.2 ParNew收集器2.1.3 Parallel Scavenge 收集器2.1.4 Parallel Old 收集器2.1.5 CMS收集器2.1.6 G1收集器 3. python的gc方式以及垃圾回收器3.1 gc方式3.2 gc回收器 4. go的gc方式以及垃圾回收器4.1 gc方式4.1.1 三色标记法4.1.2 gc工作原理 4.2 gc回收器 5. 疑问和思考6. 参考文档 由于最近频繁在java、python、go三种开发语言中不断切换，有时候针对基础的数据结构和日常操作搞混了，因此本文进行相关梳理。文中涉及的相关数据结构和日常操作并不复杂，权当增强记忆和理解。通过整理常见的gc方法，进行内存回收，并梳理不同开发语言对于gc的使用方式，以及相关利弊。
1. 常见gc方式 垃圾收集(Garbage Collection) 通常被称为"GC"，它诞生于1960年 MIT 的 Lisp 语言，经过半个多世纪，目前已经十分成熟了。
jvm 中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理。
返回java常见gc方式
1.1 gc判断对象是否存活 gc需要判断对象是否存活，以判断是否能够进行回收。判断对象是否存活一般有两种方式：
引用计数
每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。
可达性分析(Reachability Analysis)
从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，是不可达对象。
1.2 引用计数法 通过对每个对象维护一个引用计数器来判断对象是否可回收。当引用计数器为0时，对象被认为是垃圾，可以被回收。
优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。
缺点：
需要单独的字段存储计数器，这样的做法增加了存储空间的开销。每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。引用计数器还有一个严重的问题，即无法处理循环引用的问题，这是一条致命的缺陷 1.2 标记-清除算法 “标记-清除”(Mark-Sweep)算法，如它的名字一样，算法分为"标记"和"清除"两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2751a1a7c9555f0a81ea534979031e39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3cfd22c6eec4be7f26c40584c7c2296/" rel="bookmark">
			C#高级--设计模式（七个原则）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、单一职责原则 原理：
单一职责原则即：对于一个类而言，应该仅有一个引起他变化的原因。换言之，一个类只负责一个功能领域中的相应职责。
单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则，其难点和重点在于发现职责，并把这些职责相互分离，即区分职责的粒度问题。
总而言之，就是一个类中，只负责一件事，只有一个引起变更的原因。
单一职责的好处是：
好处一：提高代码的可读性，提高系统的可维护性
好处二：降低类的复杂度，一个模块只负责一个职责，提高系统的可拓展性和可维护性。
好处三：降低变更引起的风险。变更是必然的。如果单一职责做的更好，当修改一个功能的时候可以显著降低对另一个功能的影响。
二、开放封闭原则 原理：
1、对扩展开放，对修改关闭。其目的即：提高代码可复用性和可维护性。 尽量少地去改动已有的模块，尤其是底层模块。
2、在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级，可以通过使用接口和抽象类达到这样的效果。
其精神所在即：面向需求，对程序的改动是通过添加新代码进行的而不是更改现有代码。 不更改抽象层而可修改系统实现层。
三、里氏替换原则 原理：
1、任何基类可以出现的地方，子类一定可以出现，即：子类型必须能够替换掉其父类型。
2、LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。
3、LSP是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范
四、依赖倒置原则 原理：
1.高层模块不应该依赖于低层模块，两者都应以来抽象；
2.抽象不应该依赖于细节，细节应该依赖与抽象。
简单的说就是要求对抽象进行编程，不要对实现进行编程，这里的抽象即抽象类和接口。
依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，互不影响，
实现模块间的松耦合。 关于依赖
1、⼀一个优秀的⾯面向对象程序设计，核⼼心的原则之⼀一就是将变化「隔离」/「封装」，
使得变化部分发⽣生变化时，其他部分，不不受影响。
2、为了了实现这个⽬目的，需要使⽤用⾯面向接⼝口编程，使⽤用后，客户类，不不再直接依赖服务类，
⽽而是依赖⼀一个抽象的接⼝口，这样，客户类就不不能在内部直接实例例化服务类。
3、但是客户类在运⾏行行的过程中，⼜又需要具体的服务类来提供服务，因为接⼝口是不不能实例例化的，
就产⽣生了了⼀一个⽭矛盾：客户类不不允许实例例化服务类，但是客户类⼜又需要服务类的服务。
4、为了了解决这个⽭矛盾，我们设计了了⼀一种解决⽅方案，既：客户类定义⼀一个注⼊入点，⽤用于服务类的注⼊入，
⽽而客户类的客户类（Program类）负责根据情况，实例例化服务类，注⼊入到客户类中，从⽽而解决了了这个⽭矛盾。
依赖倒置代码案例如下所示：
namespace Program_依赖倒置原则 { internal class Program { static void Main(string[] args) { //歌手歌唱不同国家的歌曲 Singer singer = new Singer(); singer.SingSongChinese(new ChinenseSong()); singer.SingSongChinese(new JapaneseSong()); Console.ReadKey(); } } interface ISong { string SingSong(); } class ChinenseSong:ISong { public string SingSong() { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3cfd22c6eec4be7f26c40584c7c2296/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29dd32bb8e7c8fc8e042b783713d7edd/" rel="bookmark">
			kubernetes集群搭建(1.26版本)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		集群搭建 1.初始化安装k8s集群的实验1.1修改主机名称1.2关闭防火墙1.3关闭SELINUX1.4配置主机hosts文件，相互之间通过主机名访问1.5配置主机之间无密码登录1.6关闭交换分区swap，提升性能1.7修改机器内核参数1.9配置阿里云的repo源1.10配置安装k8s组件需要的阿里云repo源1.11配置时间同步1.12安装基础软件包 2.安装containerd服务2.1安装containerd 3.安装k8s需要的软件包4.kubeadm初始化k8s网络集群4.1基于kubeadm.yaml初始化k8s集群 5.添加第一次工作节点6.安装kubernetes网络组件-calico6.1calico网络插件配置文件说明 7.测试在k8s创建pod是否可以正常访问网络8.ctr和crictl的区别9.扩容k8s集群，添加第二个工作节点10.扩容k8s集群，添加第二个管理节点 环境准备 角色IP主节点：master1192.168.40.180主节点：master2192.168.40.183工作节点：node1192.168.40.181工作节点：node2192.168.40.182 master2和node2用做k8s集群的扩容
安装需要
链接：https://pan.baidu.com/s/17eFlM6kJN2rdeSvhTTVRFw
提取码：nx09
–来自百度网盘超级会员V3的分享
1.初始化安装k8s集群的实验 1.1修改主机名称 master1
# 修改主机名称 hostnamectl set-hostname master1 &amp;&amp; bash node1
hostnamectl set-hostname node1 &amp;&amp; bash 1.2关闭防火墙 master1
# 关闭防火墙 [root@master1 ~]# systemctl stop firewalld &amp;&amp; systemctl disable firewalld node1
[root@node1 ~]# systemctl stop firewalld &amp;&amp; systemctl disable firewalld 1.3关闭SELINUX master1
#修改配置文件 [root@master1 ~]# sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/co # 重启机器生效 [root@master1 ~]# reboot node1
[root@node1 ~]# sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/co [root@node1 ~]# reboot 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29dd32bb8e7c8fc8e042b783713d7edd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e96344e714cd7535ed4d747fae04b997/" rel="bookmark">
			如何利用EXCEL批量插入图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.excel打开目标表格；
2.点开视图-宏-录制宏，可以改宏的名字或者选择默认；
3.然后点开视图-宏-查看宏
4.点编辑进去
5.修改代码：
（1）打开之后会显示有一堆代码
（2）将这个代码只要改地址直接贴到步骤（1）的模块代码
6.同时将代码放在txt文档，并放在图片所在文件夹；
7.插入图片：在excel修改插入图片的名字，和目标图片名字一致；然后选择目标图片名并点击“查看宏”，再点击“执行”运行；
8.运行完即将图片批量插入；
1.excel打开目标表格； 2.点开视图-宏-录制宏，可以改宏的名字或者选择默认； 3.然后点开视图-宏-查看宏 4.点编辑进去 5.修改代码： （1）打开之后会显示有一堆代码 （2）将这个代码只要改地址直接贴到步骤（1）的模块代码 （3）呈现如图
Sub 批量插图() On Error Resume Next Application.ScreenUpdating = False Dim MR As Range,sPath As String sPath = "D:\临时" '设置图片位置 For Each MR In Selection If Not IsEmpty(MR) And Dir(sPath &amp; "\" &amp; MR.Value &amp; ".jpg") &lt;&gt; "" Then MR.Select ML = MR.Left MT = MR.Top MW = MR.Width MH = MR.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e96344e714cd7535ed4d747fae04b997/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e900558163b355faf0496e134079874e/" rel="bookmark">
			[数据集][目标检测]游泳者溺水数据集VOC&#43;YOLO格式2类别895张
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据集制作单位：未来自主研究中心(FIRC)
数据集格式：Pascal VOC格式+YOLO格式(不包含分割路径的txt文件，仅仅包含jpg图片以及对应的VOC格式xml文件和yolo格式txt文件)
图片数量(jpg文件个数)：895
标注数量(xml文件个数)：895
标注数量(txt文件个数)：895
标注类别数：2
标注类别名称:["swimmer","drowning"]
每个类别标注的框数：
drowning 框数 = 97
swimmer 框数 = 1433
总框数：1530
使用标注工具：labelImg
标注规则：对类别进行画矩形框
重要说明：由于溺水状态难以确认，下载数据集后请务必重新校正为自己认为溺水理想状态，数据集从30段视频截取标注，如果不需要数据集可以直接下载提供的视频文件
特别声明：本数据集不对训练的模型或者权重文件精度作任何保证，数据集只提供准确且合理标注
30段视频下载：
https://download.csdn.net/download/FL1623863129/88875524
数据集下载地址：
https://download.csdn.net/download/FL1623863129/88875527
数据集视频样例演示：
[数据集][目标检测]游泳者溺水数据集VOC+YOLO格式2类别895张_哔哩哔哩_bilibili数据集格式：Pascal VOC格式+YOLO格式(不包含分割路径的txt文件，仅仅包含jpg图片以及对应的VOC格式xml文件和yolo格式txt文件)图片数量(jpg文件个数)：895标注数量(xml文件个数)：895标注数量(txt文件个数)：895标注类别数：2标注类别名称:["swimmer","drowning"]每个类别标注的框数：drowni, 视频播放量 30、弹幕量 0、点赞数 0、投硬币枚数 0、收藏人数 0、转发人数 0, 视频作者 未来自主研究中心, 作者简介 未来自主研究中心，相关视频：ai生成威尔史密斯吃面条，使用C++部署yolov9的tensorrt模型进行目标检测，YOLOv8检测界面-PyQt5实现，基于yolov5-6.0+bytetrack的目标追踪演示，用opencv和onnxruntime去部署yolov5-7-8，基于yolov8+deepsort实现目标追踪视频演示，用C#部署yolov8的tensorrt模型进行目标检测winform最快检测速度，使用C#部署openvino-yolov5s模型，[数据集介绍][目标检测]河道垃圾水面漂浮物数据集VOC格式1304张，使用C#调用libotrch-yolov5模型实现全网最快winform目标检测https://www.bilibili.com/video/BV1qy421q7of/?vd_source=989ae2b903ea1b5acebbe2c4c4a635ee
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a2d595e6ed9a0b24f027f2b63b134d6/" rel="bookmark">
			spring
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1 谈谈你对IOC的理解 当程序运行时，用的是具体的UserService对象、OrderService对象，那这些对象是什么时候创建的？谁创建的？包括对象里的属性是什么时候赋的值？谁赋的？所有这些都是我们程序员做的，以为我们只是写了类而已，所有的这些都是Spring做的，它才是幕后黑手。
这就是控制：
控制对象的创建控制对象内属性的赋值 如果我们不用Spring，那我们得自己来做这两件事，反过来，我们用Spring，这两件事情就不用我们做了，我们要做的仅仅是定义类，以及定义哪些属性需要Spring来赋值（比如某个属性上加@Autowired），而这其实就是第二个问题的答案，这就是反转，表示一种对象控制权的转移。
我们自己来控制比交给Spring来控制，我们的代码量以及代码复杂度是要高很多的，反言之，将对象交给Spring来控制，减轻了程序员的负担。
总结一下，IoC表示控制反转，表示如果用Spring，那么Spring会负责来创建对象，以及给对象内的属性赋值，也就是如果用Spring，那么对象的控制权会转交给Spring。
1.2 Spring事务传播机制 多个事务方法相互调用时，事务如何在这些方法间传播，方法A是一个事务的方法，方法A执行过程中调用了方法B，那么方法B有无事务以及方法B对事务的要求不同都会对方法A的事务具体执行造成影响，同时方法A的事务对方法B的事务执行也有影响，这种影响具体是什么就由两个方法所定义的事务传播类型所决定。
REQUIRED(Spring默认的事务传播类型)：如果当前没有事务，则自己新建一个事务，如果当前存在事务，则加入这个事务SUPPORTS：当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行MANDATORY：当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。REQUIRES_NEW：创建一个新事务，如果存在当前事务，则挂起该事务。NOT_SUPPORTED：以非事务方式执行,如果当前存在事务，则挂起当前事务NEVER：不使用事务，如果当前事务存在，则抛出异常NESTED：如果当前事务存在，则在嵌套事务中执行，否则REQUIRED的操作一样（开启一个事务） 1.3 Spring事务失效的八大场景与原因分析 方法内的自调用：Spring事务是基于AOP的，只要使用代理对象调用某个方法时，Spring事务才能生效，而在一个方法中调用使用this.xxx()调用方法时，this并不是代理对象，所以会导致事务失效。 解放办法1：把调用方法拆分到另外一个Bean中解决办法2：自己注入自己解决办法3：AopContext.currentProxy()+@EnableAspectJAutoProxy(exposeProxy = true) 方法是private的：Spring事务会基于CGLIB来进行AOP，而CGLIB会基于父子类来失效，子类是代理类，父类是被代理类，如果父类中的某个方法是private的，那么子类就没有办法重写它，也就没有办法额外增加Spring事务的逻辑。方法是final的：原因和private是一样的，也是由于子类不能重写父类中的final的方法单独的线程调用方法：当Mybatis或JdbcTemplate执行SQL时，会从ThreadLocal中去获取数据库连接对象，如果开启事务的线程和执行SQL的线程是同一个，那么就能拿到数据库连接对象，如果不是同一个线程，那就拿到不到数据库连接对象，这样，Mybatis或JdbcTemplate就会自己去新建一个数据库连接用来执行SQL，此数据库连接的autocommit为true，那么执行完SQL就会提交，后续再抛异常也就不能再回滚之前已经提交了的SQL了。没加@Configuration注解：如果用SpringBoot基本没有这个问题，但是如果用的Spring，那么可能会有这个问题，这个问题的原因其实也是由于Mybatis或JdbcTemplate会从ThreadLocal中去获取数据库连接，但是ThreadLocal中存储的是一个MAP，MAP的key为DataSource对象，value为连接对象，而如果我们没有在AppConfig上添加@Configuration注解的话，会导致MAP中存的DataSource对象和Mybatis和JdbcTemplate中的DataSource对象不相等，从而也拿不到数据库连接，导致自己去创建数据库连接了。异常被吃掉：如果Spring事务没有捕获到异常，那么也就不会回滚了，默认情况下Spring会捕获RuntimeException和Error。类没有被Spring管理数据库不支持事务 1.4 Spring中的Bean创建的生命周期有哪些步骤 Spring中一个Bean的创建大概分为以下几个步骤：
推断构造方法实例化填充属性，也就是依赖注入处理Aware回调初始化前，处理@PostConstruct注解初始化，处理InitializingBean接口初始化后，进行AOP Spring Bean 生命周期 实例化
实例化一个Bean,也就是我们常说的new。 IOC依赖注入
按照Spring上下文对实例化的Bean进行配置，也就是IOC注入。 setBeanName 实现
如果这个Bean已经实现了 BeanNameAware接口，会调用它实现的setBeanName(String) 方法，此处传递的就是Spring配置文件中Bean的id值 BeanFactoryAware 实现
如果这个Bean已经实现了 BeanFactoryAware接口，会调用它实现的setBeanFactory， setBeanFactory(BeanFactory)传递的是Spring工厂自身(可以用这个方式来获取其它Bean， 只需在Spring配置文件中配置一个普通的Bean就可以)。 ApplicationContextAware 实现
如果这个Bean已经实现了 ApplicationContextAware接口，会调用 setApplicationContext(ApplicationContext)方法，传入 Spring 上下文(同样这个方式也 可以实现步骤4的内容，但比4更好，因为ApplicationContext是BeanFactory的子接 口，有更多的实现方法) postProcessBeforelnitialization 接口实现初始化预处理
如果这个Bean关联了 BeanPostProcessor接口，将会调用 postProcessBeforelnitialization(Object obj, String s)方法,BeanPostProcessor 经常被用 作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用那个的方法，也可以被应 用于内存或缓存技术。 init-method
如果Bean在Spring配置文件中配置了 init-method属性会自动调用其配置的初始化方法。 postProcessAfterlnitialization
如果这个Bean关联了 BeanPostProcessor接口，将会调用 postProcessAfterlnitialization(Object obj, String s)方法。 注：以h工作完成以后就可以应用这个Bean 了，那这个Bean是一个Singleton的，所以一 般情况下我们调用同一个id的Bean会是在内容地址相同的实例，当然在Spring配置文件中 也可以配置非Singleton。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a2d595e6ed9a0b24f027f2b63b134d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb634da863f2932c4dda286e32902ffe/" rel="bookmark">
			【Spring Boot 源码学习】深入 BootstrapContext 及其默认实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《Spring Boot 源码学习系列》
深入 BootstrapContext 及其默认实现 一、引言二、往期内容三、主要内容3.1 BootstrapContext3.1.1 源码初识3.1.2 get 方法3.1.3 getOrElse 方法3.1.4 getOrElseSupply 方法3.1.5 getOrElseThrow 方法3.1.6 isRegistered 方法 3.2 ConfigurableBootstrapContext3.3 DefaultBootstrapContext3.3.1 源码初识3.3.2 实现 BootstrapRegistry 接口中的方法3.3.3 实现 BootstrapContext 接口中的方法3.3.4 close 方法 四、总结 一、引言 书接前文《BootstrapRegistry 详解》，在介绍 BootstrapRegistry 的内部类 InstanceSupplier 的 get 方法时，看到了它的唯一参数 BootstrapContext 接口【即引导上下文】。而这个接口及其默认实现就是本篇要重点介绍的对象，且听我娓娓道来。
二、往期内容 在开始本篇的内容介绍之前，我们先来看看往期的系列文章【有需要的朋友，欢迎关注系列专栏】：
Spring Boot 源码学习 Spring Boot 项目介绍 Spring Boot 核心运行原理介绍 【Spring Boot 源码学习】@EnableAutoConfiguration 注解 【Spring Boot 源码学习】@SpringBootApplication 注解 【Spring Boot 源码学习】走近 AutoConfigurationImportSelector 【Spring Boot 源码学习】自动装配流程源码解析（上） 【Spring Boot 源码学习】自动装配流程源码解析（下） 【Spring Boot 源码学习】深入 FilteringSpringBootCondition 【Spring Boot 源码学习】OnClassCondition 详解 【Spring Boot 源码学习】OnBeanCondition 详解 【Spring Boot 源码学习】OnWebApplicationCondition 详解 【Spring Boot 源码学习】@Conditional 条件注解 【Spring Boot 源码学习】HttpEncodingAutoConfiguration 详解 【Spring Boot 源码学习】RedisAutoConfiguration 详解 【Spring Boot 源码学习】JedisConnectionConfiguration 详解 【Spring Boot 源码学习】初识 SpringApplication 【Spring Boot 源码学习】Banner 信息打印流程 【Spring Boot 源码学习】自定义 Banner 信息打印 【Spring Boot 源码学习】BootstrapRegistryInitializer 详解 【Spring Boot 源码学习】ApplicationContextInitializer 详解 【Spring Boot 源码学习】ApplicationListener 详解 【Spring Boot 源码学习】SpringApplication 的定制化介绍 【Spring Boot 源码学习】BootstrapRegistry 详解 三、主要内容 注意： 以下涉及 Spring Boot 源码 均来自版本 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb634da863f2932c4dda286e32902ffe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0195ef85fefd5c68941119758329a882/" rel="bookmark">
			网页图片批量下载插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c90a9c9cad7370e211f8238b6557f41/" rel="bookmark">
			软件设计师软考题目解析05 --每日五题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想说的话：要准备软考了。0.0，其实我是不想考的，但是吧，由于本人已经学完所有知识了，只是被学校的课程给锁在那里了，不然早找工作去了。寻思着反正也无聊，就考个证玩玩。
本人github地址：nanshaws (cover) (github.com)
各位想学习的，可以在上面联系我。 目录
题一
题二
题三
题四
题五
题一 采用面向对象方式进行软件开发时，将汽车作为一个系统。以下（）之间不属于组成（Composition）关系。
A 汽车和座位
B 汽车和车窗
C 汽车和发动机
D 汽车和音乐系统
答：各位学过java吗？😜，学过java的这道题错了，主动给我点赞，明显选D啊。
题二 以下关于类和对象的叙述中，错误的是（）
A 类是具有相同属性和服务的一组对象的集合
B 类是一个对象模板，用它仅可以产生一个对象
C 在客观世界中实际存在的类的实例，即对象
D 类为属于类的全部对象提供了统一的抽象描述
答：来来来，学过java的，这道题谁错了，主动给我点赞，收藏，成为我粉丝，这道题B，各位看着就没有一点想法吗？明显B是错的。
题三 设散列函数为H（key）=key%11,对于关键码序列（23，40，91，17，19，10，31，65，26），用线性探查法解决冲突构造的哈希表为（）。
A B
C
D
答：来来来，这道题，简单的数据结构题，按照我下面这样算，知道吗？
所以答案选B,自觉交上点赞，别让我催0.0😍
题四 IP地址块222.125.80.128/26包含了（/）个可用主机地址，其中最小地址是（），最大地址是（/）.
A 222.125.80.128
B 222.125.80.129
C 222.125.80.159
D 222.125.80.160
答：B，首先，理解IP地址块222.125.80.128/26中的“/26”表示子网掩码有26位是网络位。因此，32位IPv4地址中有32 - 26 = 6位是主机位。
可用的主机地址数由主机位数决定，计算公式为2主机位数−22主机位数−2。减去2是因为网络地址和广播地址不能用作主机地址。
所以，可用主机地址数为：
26−2=64−2=6226−2=64−2=62
题五 某医院数据库的部分关系模式为：科室（科室号，科室名，负责人，电话）、病患 （病历号，姓名，住址，联系电话）和职工（职工号，职工姓名，科室号，住址，联系电 话）。假设每个科室有一位负责人和一部电话，每个科室有若干名职工，一名职工只属于一个科室；一个医生可以为多个病患看病；一个病患可以由多个医生多次诊治。
科室与职工的所属联系类型为（ ），病患与医生的就诊联系类型为（/） 。对于就诊联系最合理的设计是（/），就诊关系的主键是（/）。
A 1:1
B 1:n
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c90a9c9cad7370e211f8238b6557f41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91cda1423115b3188e85232b97351b3c/" rel="bookmark">
			hashMap知识点梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.HashMap集合简介2.HashMap集合底层的数据结构1.数据结构概念2.HashMap底层的数据结构存储数据的过程3.HashMap继承关系4.HashMap集合类的成员1.成员变量2.初始化容量为什么必须是2的n次幂?(减少碰撞)3.集合容量肯定是2的幂(底层计算)问题：4.为什么Map桶中节点个数超过8才转为红黑树？ 5.构造方法6.成员方法1.增加方法为什么要取hash值的时候要右移16位呢？ 7.putVal()方法1.put原理2.将链表转换为红黑树的treeifyBin方法 8.扩容方法_resize1.扩容机制2.HashMap的扩容是什么3.源码resize方法的解读 9. 删除方法(remove)10.查找元素方法(get)11. 遍历HashMap集合几种方式12.如何设计多个非重复的键值对要存储HashMap的初始化？ 1.HashMap集合简介 ​ HashMap基于哈希表的Map接口实现，是以key-value存储形式存在，即主要用来存放键值对。HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。
​ JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突**(两个对象调用的hashCode方法计算的哈希码值一致导致计算的数组索引值相同)**而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（或者红黑树的边界值，默认为 8）并且当前数组的长度大于64时，此时此索引位置上的所有数据改为使用红黑树存储。
补充：将链表转换成红黑树前会判断，即使阈值大于8，但是数组长度小于64，此时并不会将链表变为红黑树。而是选择进行数组扩容。
这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡 。同时数组长度小于64时，搜索时间相对要快些。所以综上所述为了提高性能和减少搜索时间，底层在阈值大于8并且数组长度大于64时，链表才转换为红黑树。具体可以参考 treeifyBin方法。
当然虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于8并且数组长度大于64时，链表转换为红黑树时，效率也变的更高效。
小结：
特点：
1.存取无序的
2.键和值位置都可以是null，但是键位置只能是一个null
3.键位置是唯一的，底层的数据结构控制键的
4.jdk1.8前数据结构是：链表 + 数组 jdk1.8之后是 ： 链表 + 数组 + 红黑树
5.阈值(边界值) &gt; 8 并且数组长度大于64，才将链表转换为红黑树，变为红黑树的目的是为了高效的查询。
2.HashMap集合底层的数据结构 1.数据结构概念 数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。
数据结构：就是存储数据的一种方式。ArrayList LinkedList
在JDK1.8 之前 HashMap 由 数组+链表 数据结构组成的。
在JDK1.8 之后 HashMap 由 数组+链表 +红黑树数据结构组成的。
2.HashMap底层的数据结构存储数据的过程 说明：
1.面试题：HashMap中hash函数是怎么实现的？还有哪些hash函数的实现方式？
对于key的hashCode做hash操作，无符号右移16位然后做异或运算。 还有平方取中法，伪随机数法和取余数法。这三种效率都比较低。而无符号右移16位异或运算效率是最高的。至于底层是如何计算的我们下面看源码时给大家讲解。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91cda1423115b3188e85232b97351b3c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/3/">«</a>
	<span class="pagination__item pagination__item--current">4/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/5/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>