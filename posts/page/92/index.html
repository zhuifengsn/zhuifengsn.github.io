<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f0e9641795aad7646eef542061fbb19/" rel="bookmark">
			电脑硬盘数据线_血的教训，配电脑选硬盘不看这几个指标，分分钟被坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		硬盘主要用来记录电脑中的各类数据、程序，包括我们安装的操作系统、应用软件等都存储在硬盘中。与内存不同的是，硬盘中的文件在关闭电脑后不会消失。
选购硬盘时需要注意的是硬盘的容量、接口类型、缓存大小以及品牌等。
硬盘的容量 硬盘内部采用的存储介质是金属盘片，而单张盘片的容量有限，很多容量较大的硬盘都由多张盘片组成。通常我们所说的160GB、320GB的硬盘都是指硬盘内所有盘片容量的总和，也就是硬盘的最大容量。目前主流硬盘的最大容量在320GB~1.0TB之间，有些产品更高达2.0TB，而且3.0TB的硬盘已经上市。
提示
1MB=1024KB，1GB=1024MB，1TB=1024GB。硬盘中每个盘片的最大存储容量叫做单碟容量，目前最大单碟容量已经超过500GB。单碟容量越大，硬盘的稳定性也越好。
技巧
硬盘的盘片过多会降低硬盘的性能和稳定性。在容量相同的情况下，应优先选择单碟容量较大的硬盘。
硬盘的接口 硬盘的接口集成在硬盘背面的电路板上，由数据线接口、电源接口和跳线接口等3部分组成。
常见的硬盘数据线接口包括IDE和SATA接口两种，其中IDE接口又称为PATA接口或者并行ATA接口，是过去电脑中普遍使用的硬盘接口，它带有40根针脚。
SATA接口又叫串行ATA接口，是目前主流的硬盘接口类型，它采用串行传输模式，支持热插拔。它采用7根金手指作为连接点，接口更为牢固，安装更方便。
电源接口
电源接口用于连接电源线，为硬盘工作提供足够的动力。IDE硬盘采用的电源接口是一个4针的“D型”接口，它通过电源线连接到主机电源，直接从电源处获取工作时所需的电能。
SATA硬盘采用的电源接口为15针的“L型”扁平接口，它需要专用的主机电源线来进行连接。
跳线接口
目前主流的IDE硬盘都设置了跳线接口，该接口主要用于当电脑连接了多种IDE设备时，设置硬盘的主从盘状态。在硬盘正面的产品标签上会印上跳线设置的相关说明，在设置跳线时，可以参考该说明来进行设置。
硬盘的缓存 硬盘的缓存是硬盘与外部总线交换数据的场所，主要用于加速数据的读写性能。通常在转速相同的情况下，缓存越大，硬盘的读写性能越好。
目前主流硬盘的缓存一般在8～32MB之间，例如容量低于500GB的硬盘一般为8~16MB，而容量在500GB以上的硬盘则一般为16~32MB。
硬盘的品牌 通常情况下，电脑中所有的重要数据都存储在硬盘中，如果硬盘出现故障，即使不会带来巨大的财产损失也会带来许多不必要的麻烦，因此，选择一款质量有保证的硬盘是非常有必要的。
目前市场上的主流硬盘品牌有希捷（Seagate）、西部数据（Western Digital）、日立（Hitachi）、三星（Samsung）、东芝（Toshiba）和迈拓（Maxtor）等。这些品牌的硬盘质量较好，而且售后服务都不错，读者可选择购买。
注意
缓存越大的硬盘价格也越高，用户在实际购买时应根据需要选择，不要盲目追求奢华。
提示
目前市场上的品牌硬盘都采用代理方式来进行销售，主要的代理商有建达蓝德、联|强国际、讯宜、利集、新资源（CMS）科技、金喜来、迪科以及英特利等。
机械硬盘和固态硬盘 组装台式电脑，固态硬盘已经是装机必不可少的配件。它可以让开机速度更快，大大的提升软件打开速度，相比传统的机械硬盘噪音更小，所以深受DIY玩家们的喜爱，现在大家能经常接触的到固态硬盘可以分为SATA和M.2固态硬盘，那么这两款固态硬盘的区别有哪些呢?
SATA和M.2固态硬盘读写速度差别很大。现在主流的SATA 3.0固态硬盘的最大传输速度为6Gbps，实际速度最大为560MB/s。而采用了NVMe协议的M.2固态硬盘三星960 PRO，最大读取速度可以达到3.5GB/s。主流的M.2固态硬盘有两种，一种是M2的接口 ，但是依旧走的SATA总线 ，比较有代表的就是三星850EVO，速度提升并不会太大。另一种，是通过NVME协议，走的PCI-E通道的M.2固态硬盘，三星PM961可以是它的代表，有着超高的速度。
除此之外，选择M.2固态硬盘一颗螺丝就能轻松实现安装，但是有些低端主板是不支持的。科技产品买新不买旧，建立大家都上NVMe协议的M.2固态硬盘，速度快得多。
你学会如何选购硬盘了吗？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/787e0e12d317464840abcfe1770e8099/" rel="bookmark">
			R语言：蒙特卡洛模拟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hello，大家好，今天带给大家的是一种计算机模拟的方法——蒙特卡洛模拟（Monte Carlo）。这是一种基于概率统计模型所衍生的一种计算机模拟的方法，而它的原理就是概率论中所涉及的“大数定律”，也就是在实验次数非常多时，频率会依概率收敛，即频率非常接近概率。
蒙特卡洛模拟的基本思路可以归纳为三步：构造问题的概率模型-&gt;从已知概率分布中抽样-&gt;建立所需的统计量。后面我会用两个例子来做详细的解释。因为本人后续的学习内容要以R语言为主，因此这两个例子我都是基于R语言来实现的。
例1 蒙特卡洛模拟求积分 I = ∫ 0 1 ln ⁡ ( 1 + x ) 1 + x 2 d x I = \int_0^1 \frac {\ln(1+x)}{1+x^2} \mathrm{d} x I=∫01​1+x2ln(1+x)​dx
首先我们可以先画下图，看下这个所要求的积分函数是什么样子的。
f &lt;- function(x){ log(1+x)/(1+x^2) } x &lt;- seq(0,1,length=50) y &lt;- f(x) df &lt;- data.frame(x,y) ggplot(df, mapping = aes(x=x,y=y))+geom_line() 画完后发现，整个函数在[0,1]的区间内都是大于0的，那么我们就可以画一个边长为1含有这个函数的正方形，往该区域内投点，看看落在该函数内的点有多少个（即图中红色区域），这样我们就完成了第一步，构造问题的概率模型。
ggplot(df, mapping = aes(x=x,y=y))+geom_line()+geom_ribbon(aes(ymin=0, ymax=y, x = x), fill="red", alpha=0.2)+geom_hline(yintercept = c(0,1))+geom_vline(xintercept = c(0,1)) 接下来，第二步，从已知概率分布中抽样，往该区域随机投点属于均匀分布，因此我们用runif()函数即可生成n个随机点。每有一个点落在红色区域，便记为一次，记k为落在红色区域内的次数。随着投点的次数增多，我们就可以根据大数定律认为 k n = S r e d S 正 方 形 \frac kn = \frac {S_{red}}{S_{正方形}} nk​=S正方形​Sred​​，那么这个 k n \frac kn nk​就是我们所需要的统计量。又因为这个正方形面积为1，所以 k n \frac kn nk​就是我们要求的定积分。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/787e0e12d317464840abcfe1770e8099/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bb0eff301438daf9f83f1cc88e36e22/" rel="bookmark">
			md5是什么_全民小视频视频修改md5有什么用6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 全民小视频视频修改md5有什么用6
BGM可以算是短视频的灵魂了，有时候，你会发现，BGM比视频还火。 1，批量下载软件 2，批量消重原创软件 自媒体视频搬运全套软件 关注歌乐软件，了解更多视频操作方面干货 在短视频操作中，视频修改的作用显得尤为重要，这里介绍几款常见的工具 视频原创软件 现在有很多的自媒体用户每天会上传二十几个视频，但是被限流的视频有十多个，就是因为内容重复了，所以我们要对视频进行消重。有什么方法能有效规避消重呢？方法就是改，我们要用各种方法来对视频进行再次创作，要把原视频内容的修改至少30%才能通过限流审核后，才会受到推荐。抖音现在玩的年轻人很多，所以只要拍摄的抖音视频，内容有趣，加上平台的推送就会推荐给相对应的用户，所以做好内容对于抖音拍摄也是很重要，拍摄方式技巧是用来辅助内容能更好的呈现，做好抖音内容策划和拍摄制作都很关键，只有把这两点都做好，抖音作品才能受到更多人的关注。 我们具体应该怎么操作呢？分两种情况，种就是单个视频的消重然后直接使用，第二种是多个视频剪接然后再进行组合在一起然后再使用。利用剪辑软件通过修改片头、片尾还有视频长度。比如“奥迪”在抖音企业号中推出了系列剧情式短视频，在情景剧中，围绕卖点来进行了品牌理念渗透。对视频进行二次编辑这是最直接的办法。通过对视频的剪辑不但可以修改视频内容还可以将有水印的内容进行修改或者是覆盖 企业想要在这个领域获得更高的关注，在运营方面就需要掌握很多技巧的，至于有哪些，就跟着卷尾巴继续往下看吧。这更容易吸引更多的用户，以内容多样化的方式吸引用户参与。也可以关注飞瓜数据上的热点内容，里面的热点是经过数据筛选和处理过的，更加全面。对于视频创作方面你也更得心应手，刚开始进行创作的时候，你们最好多练习一下，什么类型的视频都可以尝试，视频完成后，我觉得大部分人都会有一定的成就感，我也有这种感觉，感觉自己的努力终于做出成果了。全民小视频视频修改md5有什么用6
同时随着生活水平的以及人们追求方便的要求，而也自然与陈晓薇邮件中的某公司对应起来。并启动“报网互动”；年收入达28亿元，2007年12月19日，商标局发文驳回“3G门户”商标的注册申请，久邦公司即向商标评审会申请复审，2008年10月20日商评委作出复审决定，驳回了久邦公司的复审请求。因此内容创新和研发能力将成为厂商核心竞争要素。 不同的短视频营销游戏将具有不同的营销效果，品牌需要根据自身需求选择适合自己的形式。卷尾巴短视频企业蓝V该怎么运营结合产品每个企业产品背后都有大量可诉说的技能技术知识，企业在做短视频内容时完全可以围绕产品来做视频，将业务内容视频化，持续产出内容。阅读00条评论，你就会发现一个小秘密绝大部分回复的用户是孩子；他们最想做的事情是如何让爸妈不经意地看到这个视频。又或者你喜欢与朋友分享与爱人之间的点点，与朋友之间的琐琐碎碎，有个喜欢逗她老爸特别疼你让你感到骄傲的长辈，都可以成为日常分享的话题。全民小视频视频修改md5有什么用6
由于环迅支付是目前国内通过此项认证的第三方支付企业，如此的热闹光景给消费者的信息似乎是：一两年内我们就能普及新能源车，新能源车带来的实惠。门户：新浪： ： ：　二，　一切源于服　平板市场充满新变数　据了解，突然发力52英寸液晶，有更深层用意。尤其是2017上半年， 想要了解更多新媒体小技巧，更多创业干货，可私信留言在情绪剪辑过程中可以在关键位置插入近特组镜头，与前后镜头共同组成情绪表达段落，使主体的情绪得以突出和强调。技巧一构图一幅作品的构图也为很多种，如九宫格构图对角线构图十字形构图，三角形构图，黄金分割等。抖音现在玩的年轻人很多，所以只要拍摄的抖音视频，内容有趣，加上平台的推送就会推荐给相对应的用户，所以做好内容对于抖音拍摄也是很重要，拍摄方式技巧是用来辅助内容能更好的呈现，做好抖音内容策划和拍摄制作都很关键，只有把这两点都做好，抖音作品才能受到更多人的关注。全民小视频视频修改md5有什么用6
与此同时，从民间呼声来看，我国综合税费成本居高不下。 StrategyAnalytics的数据显示，苹果已超过微软，成为全球第二大手机厂商。诺基亚将不再继续其在的手机销售和市场推广业务，旷工半天，扣罚一天工资；矿工一天扣罚三天工资，连续旷工三天或者累计一个月旷工五天以上者视为自动离职，自动离职不发薪金。日东电工也在6月决定向广东工厂进行130亿日元的投资，用于生产液晶电视等的高功能零部件。 下一篇：抖音视频修改会改变md5吗
shudenghui 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/113167074d7e48d9bb9282731bfe78a4/" rel="bookmark">
			mysql默认隔离级别为什么是可重复读，业务代码为什么设置为读已提交
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mysql隔离级别为什么默认可重复读 这主要是由于历史原因造成的，mysql的主从复制是基于binlog复制的。
binlog的三种格式 1.statement:记录的是修改SQL语句
2.row：记录的是每行实际数据的变更
3.mixed：statement和row模式的混合
那Mysql在5.0及这个版本以前，binlog只支持STATEMENT这种格式！而这种格式在读已提交(Read Commited)这个隔离级别下主从复制是有bug的（主从不一致问题，就是在master上执行的顺序为先删后插！而此时binlog为STATEMENT格式，它记录的顺序为先插后删！从(slave)同步的是binglog，因此从机执行的顺序和主机不一致！就会出现主从不一致！），因此Mysql将可重复读(Repeatable Read)作为默认的隔离级别！
如何解决主从不一致问题？ 1.隔离级别设为可重复读(Repeatable Read),在该隔离级别下引入间隙锁。当Session 1执行delete语句时，会锁住间隙。那么，Ssession 2执行插入语句就会阻塞住！
2.将binglog的格式修改为row格式，此时是基于行的复制，自然就不会出现sql执行顺序不一样的问题！但是这个格式在mysql5.1版本开始才引入。因此由于历史原因，mysql将默认的隔离级别设为可重复读(Repeatable Read)，保证主从复制不出问题！
选择读已提交的原因 1.repeatable存在间隙锁会使死锁的概率增大；
2.在RR可重复读隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行；
在RR隔离级别下，走聚簇索引，进行全部扫描，最后会将整个表锁上；
在RC隔离级别下，其先走聚簇索引，进行全部扫描，但MySQL做了优化，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录放锁。
3.在RC隔离级别下，引入半一致性读(semi-consistent)特性增加了update操作的性能！
半一致性读就是，一个update语句，如果读到一行已经加锁的记录，此时InnoDB返回记录最近提交的版本，由MySQL上层判断此版本是否满足update的where条件。若满足(需要更新)，则MySQL会重新发起一次读操作，此时会读取行的最新版本(并加锁)！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0711238cdbac4a448833982b8b4242b7/" rel="bookmark">
			python 爬虫URL出现 ‘ascii‘ codec can‘t encode characters in position。。。问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬虫拼接URL时含有中文，出现’ascii’ codec can’t encode characters in position。。。我的解决方法是直接加入代码urllib.parse.quote(keyword)。
例如：
原代码
url = http://api.map.baidu.com/place/v2/search? query=大学&amp;region=北京&amp;page_size=20 &amp;page_num=0&amp;output=json&amp;ak=ak 变为
url = http://api.map.baidu.com/place/v2/search? query=urllib.parse.quote('大学') &amp;region=urllib.parse.quote('北京') &amp;page_size=20&amp;page_num=0&amp;output=json&amp;ak=ak 参考：https://blog.csdn.net/lzyilzy/article/details/83933441
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8007f0c41bbd07ea901c27677d39d71a/" rel="bookmark">
			学习JavaScript之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript学习之路 1、数据类型
(1)数据类型包括：字符串、数字、布尔、数组、对象、Null、Undefined
注意点：
当向变量分配文本值时，应该用双引号或单引号包围这个值。
当向变量赋的值是数值时，不要使用引号。如果用引号包围数值，该值会被作为文本来处理。
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;script&gt; var pi=3.14; var name="Bill Gates"; var answer='Yes I am!'; document.write(pi + "&lt;br&gt;"); document.write(name + "&lt;br&gt;"); document.write(answer + "&lt;br&gt;"); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; （2）数组
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;script&gt; var i; var cars = new Array(); cars[0] = "Audi"; cars[1] = "BMW"; cars[2] = "Volvo"; for (i=0;i&lt;cars.length;i++) { document.write(cars[i] + "&lt;br&gt;"); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; （3）对象
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;script&gt; var person={ firstname : "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8007f0c41bbd07ea901c27677d39d71a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1a668059a4752ef54c434856050f9e3/" rel="bookmark">
			stm32中断源有哪些_USB之STM32基础（六）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇笔记主要介绍 STM32相关的知识点，毕竟之后的 CDC 教程是用 STM32开发的。
为了写这一篇，鱼鹰把 STM32 中文参考手册 USB 相关的从头到尾看了一遍，虽然以前就已经看过了，但这次看，收获又是不同。
不过限于篇幅，鱼鹰不会面面俱到，只介绍和 CDC 相关的一些东西。
要完成 USB 模拟串口(CDC)的实验，STM32 手册是必须细细阅读的，不然代码里面很多操作你是无法看懂的。
其实理解了前面的一些东西，你会发现 STM32 中的 USB 知识和前面的大同小异，毕竟开发芯片的厂家也是按照 USB 标准来实现的，不会差到哪里去。
硬件基础 首先，STM32F103 使用 PA11(USBDM，D-)和 PA12(USBDP，D+)完成数据的收发。但看过前面章节的道友应该知道，全速 USB 在 D+ 引脚是需要有一个上拉电阻的，同时两根数据线需要各自串联一个 22 Ω的电阻。
这就是你需要的硬件基础，如果说你的开发板有 USB 接口，但是没有这些条件，那么你的USB 接口只能用于供电，无法进行数据传输。
当然，STM32F103 的速度为全速 12 Mbit，换算成字节为 1.5 MB，除去 USB 协议的开销(令牌、打包等)，大概能达到 1 MB/s 速度。
鱼鹰在测试给各位道友的 CDC 例程发现只能达到 100 KB 左右，原以为是主机没有及时发送令牌包导致带宽很低，后来发现 USB 设备发出的数据包只有几个字节，而不是最大包 64B，才知道是发送的数据太少了，后来增加发送的数据量(一次往缓冲多写几百个字节)，带宽达到了 400~700KB，但离 1MB 还差了点。
通过逻辑分析仪查看才知道，主机发送 IN 令牌包时，设备有可能还没准备好，浪费了带宽，不过在看 STM32 资料中发现，对于批量传输(CDC 使用批量传输)，可以使用双缓冲提高传输量，估计用了双缓冲，传输速率能达到 1MB/s，比串口的 115200 Bit/s 快的多，也稳定的多，毕竟人家可是自带了 CRC 校验和数据重传功能的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1a668059a4752ef54c434856050f9e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b223d415b3899c9511dff2b2e7cd3705/" rel="bookmark">
			urllib.request.urlretrieve()函数下载文件卡死解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.问题描述
二.解决方法
1.使用requests库代替
2.使用socket模块
一.问题描述 urllib.request.urlretrieve()函数主要用途是下载网络上的文件到本地。
在实际使用过程中，经常会出现卡死的问题，而函数不支持设置超时。下面介绍几种解决办法。
二.解决方法 1.使用requests库代替 #原函数 urlretrieve(url, filename) #替换 ##请求资源 r = requests.get(img_url) ##打开文件并写入 with open(filename,'wb') as f: f.write(r.content) 2.使用socket模块 import socket from urllib.request import urlretrieve #设置超时时间 socket.setdefaulttimeout(10) try: urlretrieve(url,filename) #如果超时 except socket.timeout: count = 1 while count &lt;= 5: try: urlretrieve(url,filename) break except socket.timeout: err_info = 'Reloading for %d time'%count if count == 1 else 'Reloading for %d times'%count print(err_info) count += 1 if count &gt; 5: print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b223d415b3899c9511dff2b2e7cd3705/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c831c057c7846a1491b05ea4e7338b6/" rel="bookmark">
			QT是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt是一个1991年由Qt Company开发的跨平台C++图形用户界面应用程序开发框架。它既可以开发GUI程序，也可用于开发非GUI程序，比如控制台工具和服务器。Qt是面向对象的框架，使用特殊的代码生成扩展（称为元对象编译器(Meta Object Compiler, moc)）以及一些宏，Qt很容易扩展，并且允许真正地组件编程。2008年，Qt Company科技被诺基亚公司收购，Qt也因此成为诺基亚旗下的编程语言工具。2012年，Qt被Digia收购。2014年4月，跨平台集成开发环境Qt Creator 3.1.0正式发布，实现了对于iOS的完全支持，新增WinRT、Beautifier等插件，废弃了无Python接口的GDB调试支持，集成了基于Clang的C/C++代码模块，并对Android支持做出了调整，至此实现了全面支持iOS、Android、WP,它提供给应用程序开发者建立艺术级的图形用户界面所需的所有功能。基本上，Qt 同 X Window 上的 Motif，Openwin，GTK 等图形界面库和 Windows 平台上的 MFC，OWL，VCL，ATL 是同类型的东西。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d63530db8f08b30127ff9ab88697f31e/" rel="bookmark">
			计算机组成原理详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、计算机组成原理1. 什么是计算机？2. 为什么要用计算机？3. 计算机的五大组成部分4. 操作系统概述 二、CPU工作原理CPU工作流程CPU指令集启动计算机 一、计算机组成原理 1. 什么是计算机？ 俗称电脑，即通电的大脑，电脑二字蕴含了人类对计算机的终极期望，希望它能真的像人脑一样去工作，从而解放人力。
2. 为什么要用计算机？ 世界是由聪明的懒人统治的，任何时期，总有一群聪明的懒人想要奴隶别人。在奴隶制社会，聪明的懒人奴役的是真正的人，而人是无法不吃、不喝、不睡觉一直工作的，但是计算机作为一台机器是可以做到的，所以把计算机当奴隶是上上之选。
3. 计算机的五大组成部分 计算机有五大组成部分，既然计算机是人的奴隶，那么计算机设计核心肯定也是在模仿真正的人，所以我们完全可以把计算机的五大组件比喻成人类的各种器官
控制器
控制器是计算机的指挥系统，用来控制计算机其他组件的运行，相当于人类的大脑运算器
运算器是计算机的运算功能，用来做算术运算和逻辑运算，相当于人脑。
ps：控制器+运算器=CPU，cpu相当于人的大脑存储器
存储器是计算机的记忆功能，用来存取数据。
存储器主要分为内存与外存：
​ 内存相当于人的短期记忆。断电数据丢失 ​ 外存(如磁盘),相当于记事的本子，断电数据不会丢失，是用来永久保存数据的
​ ps：内存的存取速度要远远高于外存输入设备input
输入设备是计算接收外界输入数据的工具，如键盘、鼠标，相当于人的眼睛或耳朵。输出设备output
输出设备是计算机向外输出数据的工具，如显示器、打印机，相当于人说的话，写出的文章。
ps：存储器如内存、磁盘等既是输入设备又是输出设备，统称为IO设备
一个非常重要的基础知识:与运行程序相关的三大核心硬件
我们编写的程序一定是要运行于计算机硬件之上，而站在硬件的角度，与运行程序有关的三大核心硬件为CPU、内存、硬盘。
程序最先是存放于硬盘中的，程序的运行是先从硬盘把代码加载到内存中，然后cpu是从内存中读取指令运行。 4. 操作系统概述 操作系统的由来
​ 大前提：我们编程目的就是为了奴役计算机，让计算机硬件自发地运行起来，然而硬件毕竟是”死的“，硬件的运行都是由软件支配。倘若我们要开发一个应用程序，比如暴风音影，该软件的一个核心业务就是播放视频，开发者若要编写程序完成播放视频这个业务逻辑，必先涉及到底层硬件硬盘的基本运作（视频文件都是先存放于硬盘中），这意味着开发者在编写业务逻辑代码之前，必须先编写一个控制硬盘基本运行的控制程序，然而这仅仅只是一个开始，事实上，在编写应用程序的业务逻辑前，需要开发者编写出一套完整的控制程序用来控制所有硬件的基本运行（这要求开发者需要详细了解计算机硬件的各种控制细节，例如我们必须把CPU里面所有指令集都掌握一遍），如此，所有的开发者在开发程序时都必须依次开发两种：
1、编写一套完整的的控制程序，用来控制硬件的基本运行，以及把复杂的硬件的操作封装成简单的接口
2、基于控制程序的接口开发包含一系列业务逻辑的程序，为了与控制程序区分，可以称为应用程序，以ATM这款应用程序为例，业务逻辑有提款、转账、查询余额等
​ 综上，对于不同公司的开发者来说，应用程序的业务逻辑各不相同，但硬件的控制程序都大致相同，为了避免所有程序员做重复劳动，以及不用再耗费精力去了解所有硬件的运行细节，有公司专门跳出来承担起控制程序的开发任务，这里所说的控制程序指的就是操作系统。
​ 操作系统的功能就是帮我们把复杂的硬件的控制封装成简单的接口，对于开发应用程序来说只需要调用操作系统提供给我们的接口即可
系统软件与应用软件
硬件以上运行的都是软件，而软件分为两类：
应用软件（例如qq、word、暴风影音、酷我音乐、pycharm等）操作系统，操作系统应用软件与硬件之间的一个桥梁，是协调、管理、控制计算机硬件与应用软件资源的控制程序。 计算机系统三层结构
综上，我们开发应用程序本质是在控制硬件，但是我们直接打交道的是操作系统，应用程序都是通过操作系统来间接地操作硬件的，所以一套完整的计算机系统分为三层，如下
平台
应用程序都是运行于操作系统之上，而操作系统则是运行于硬件之上的，所以承载应用程序的是一台运行有操作系统的计算机，称之为应用程序的运行平台，即：硬件 + 操作系统 == 平台
常见的平台有：windows系统+某款硬件、linux系统+某款硬件、ubuntu+某款硬件等，我们在开发应用程序时就需要考虑到应用程序的跨平台性，如果能开发出一款可以在任意平台运行的应用程序，那对于开发者来说真是极大的福音。而决定应用软件的跨平台性的关键因素往往是编程语言的选择，python恰好是一款跨平台性语言，这也是我们学习它的原因之一。
二、CPU工作原理 CPU工作流程 CPU的核心工作在于进行运算和判断，那么要被运算与判断的数据是从哪里来的？
CPU读取的数据都是从主存储器（内存）来的，主存储器内的数据则是从输入单元所传输进来！而CPU处理完毕的数据也必须先写回主存储器中，最后数据才从主存储器传输到输出单元。
所以计算机五大组成部分的基本工作流程就是：输入单元=&gt;主存储器=&gt;CPU=&gt;主存储器=&gt;输出单元
而CPU会从内存中取指令-&gt;解码-&gt;执行，然后再取指-&gt;解码-&gt;执行下一条指令，周而复始，直至整个程序被执行完成。
总结CPU的大致工作流程就是：获取指令—&gt;解码—&gt;执行，详细见下图
CPU指令集 cpu是计算机的大脑，大脑里集成了一系列具体控制身体其他器官做事的指令集，所以站在纯硬件角度去看，计算机所有其他组件都由cpu发出的指令控制。
我们程序员编程的目的是为了控制计算机硬件工作，程序员的代码都会转换成cpu的指令集才能去控制其他硬件，所以程序员是通过直接控制cpu来达到间接控制其他硬件的目的，具体流程如下：
内存中存放的是程序员的代码/指令，cpu从内存中取出这些指令后需要翻译成自己的指令去执行，即cpu在出场时内部就集成了一系列的指令集(指令集是cpu的灵魂)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d63530db8f08b30127ff9ab88697f31e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e9b4435d829d1142bc0c0fcdcd686d8/" rel="bookmark">
			jeecg代码阅读-使用shiro的例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在阅读jeecg的shiro权限那块，话说jeecg写的真是棒。
pom依赖：
&lt;!--JWT--&gt; &lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--shiro--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- shiro-redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.crazycake&lt;/groupId&gt; &lt;artifactId&gt;shiro-redis&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; Realm
package org.jeecg.config.shiro; import cn.hutool.crypto.SecureUtil; import lombok.extern.slf4j.Slf4j; import org.apache.shiro.authc.AuthenticationException; import org.apache.shiro.authc.AuthenticationInfo; import org.apache.shiro.authc.AuthenticationToken; import org.apache.shiro.authc.SimpleAuthenticationInfo; import org.apache.shiro.authz.AuthorizationInfo; import org.apache.shiro.authz.SimpleAuthorizationInfo; import org.apache.shiro.realm.AuthorizingRealm; import org.apache.shiro.subject.PrincipalCollection; import org.jeecg.common.api.CommonAPI; import org.jeecg.common.constant.CacheConstant; import org.jeecg.common.constant.CommonConstant; import org.jeecg.common.system.util.JwtUtil; import org.jeecg.common.system.vo.LoginUser; import org.jeecg.common.util.RedisUtil; import org.jeecg.common.util.SpringContextUtils; import org.jeecg.common.util.oConvertUtils; import org.springframework.context.annotation.Lazy; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e9b4435d829d1142bc0c0fcdcd686d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b34fce339701564aa1331ce34e4724c/" rel="bookmark">
			【C#dynamic 类型】常用用法示例。【转载】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源博客地址：https://blog.csdn.net/heyangyi_19940703/article/details/51190645
在通过 dynamic 类型实现的操作中，该类型的作用是绕过编译时类型检查，改为在运行时解析这些操作。dynamic 类型简化了对 COM API（例如 Office Automation API）、动态 API（例如 IronPython 库）和 HTML 文档对象模型 (DOM) 的访问。
在大多数情况下，dynamic 类型与 object 类型的行为是一样的。但是，不会用编译器对包含dynamic 类型表达式的操作进行解析或类型检查。编译器将有关该操作信息打包在一起，并且该信息以后用于计算运行时操作。在此过程中，类型dynamic 的变量会编译到类型 object 的变量中。因此，类型dynamic 只在编译时存在，在运行时则不存在。
运用例子：如果我们在现实开发中遇到参数传递不确定性字段时候，可以通过dynamic创建运行时解析的对象，避免去创建更多的实体类对象！
如：我要计算店铺的租金，每个店铺的衡量标准不一样，计算该商店的算法需求的变量类型，个数不一样，难要为每个算法创建对应的对象进行传递，获取相应的参数进行技术吗？考虑到这样的问题我们可以通过dynamic 类型进行约束。
1.创建算法行为类，构造方法中传递要计算的参数对象。
using System; using System.Collections.Generic; using System.Linq; using System.Text; namespace ConsoleApplication1 { /// &lt;summary&gt; /// 计算行为类 /// &lt;/summary&gt; public class calculate { /// &lt;summary&gt; /// 运行时的参数传递对象 /// &lt;/summary&gt; private dynamic _obj; public calculate(dynamic obj) { this._obj = obj; } /// &lt;summary&gt; /// A类型算法的计算租金=monthnum*monthprice+Commissionpric /// &lt;/summary&gt; public double AtypRental() { Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b34fce339701564aa1331ce34e4724c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d1b399c1ea56561833e38bdddfa89ef/" rel="bookmark">
			h61 nvme硬盘_最值得买的固态移动硬盘推荐-最佳固态移动硬盘排行榜【2020年10月】...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		固态移动硬盘的好处相信大家都知道,除了能让电脑开机快、游戏进图快之外,还能大幅提升系统运行速度,除了空间小一些外基本上全都是有优点。
今天给大家推荐最佳固态移动硬盘排行，希望对大家选购固态移动硬盘有帮助。
第一名 西部数据|P50黑盘
游戏PSSD，完美兼容各类游戏主机 西部数据是机械硬盘行业两巨头之一，并购日立后稳坐机型硬盘行业老大的位置，通过收购闪迪在SSD上也有了产品线，除入门“元素”系列与高端的My Passport两个系列外，还有一个旗舰系列，即西数黑盘。
西数黑盘目前仅有一款P50，西数称之为游戏PSSD，主打高速传输，完美适配PC、PlayStation以及Xbox。黑盘P50采用锻造铝制外壳，内部通过祥硕ASM2364 USB-PCIe桥接芯片转接成Type-C，最快传输速度2000MB/s，这已经和三星X5相近。
不过由于兼容性问题，P50在非USB 3.2 GEN 2×2接口（如雷电3）性能只能达到标称值的一半，即1000MB/s左右，而且它的价格也确实太高，在3元/GB以上，500GB容量就要1500元上下。
第二名 三星|X5雷电3固态移动硬盘
雷电3标准，带密码保护功能 如今的三星是全球半导体领域的霸主，在固态硬盘市场份额远远超过闪迪、英特尔，位居世界第一，在闪存颗粒市场，三星同样将第二远远甩在身后，占全球份额近40%，其移动硬盘虽然只有两款，但全是固态移动硬盘，X5是其旗舰款。
三星X5应该是目前固态移动硬盘中性能最高的一款，雷电3传输标准，雷电3有几项优势，首先自然是快，因此三星X5读写性能均超过了2000MB/S，这差不多已经是主流M.2固态硬盘的水准，远远超过了大多数人的日常使用需求。
当然，三星X5价格很高，单价到了4元/GB左右，而且需要注意的是，X5的雷电接口并不能向下兼容，普通Type-C并不一定支持雷电规范，如果电脑没有雷电3接口，买三星X5就纯属浪费了。
第三名 威刚|SE760超高速系列
1000MB/S传输速度，性价比非常高 威刚初期以内存模块为主要产品线，后进入存储产品市场并逐渐壮大，旗下固态硬盘性价比很高，质量可靠，经常出现在科技媒体的推荐榜单中，在消费者群体中口碑也非常好，SE系列是其固态移动硬盘产品线，现在的旗舰是SE760。
SE760采用可正反插的USB 3.2 Gen 2 Type-C接口，性能提升巨大，传输速度1000MB/S左右，实测也确实能达到标称值，连续写入速度则超过了800MB/s，比SATA固态移动硬盘快多了，这也是目前除三星X5外性能最好的一档。
SE760整体和闪迪超极速系列类似，但价格要更便宜，500GB容量约在700元左右，合1.4元/GB，甚至比闪迪更低一档的至尊急速系列还便宜，性价比相当出色。
第四名 闪迪|至尊超极速NVMe固态移动硬盘
NVMe传输标准，读写1050MB/S 闪迪是全球最大的存储卡供应商，一直是存储行业公认的一线品牌，能自产闪存颗粒，市场占有率全球第二，仅次于三星，所以闪迪和三星比较相似，其移动硬盘也全是固态移动硬盘，划分则和其他存储产品线一样，至尊超极速为旗舰系列。
至尊超极速相比至尊极速性能更进一步，NVMe转USB3.1 Gen2，连续读写速度突破了1000MB/S，大概是至尊极速系列的2倍，一般是用于4K视频、照片等专业数据的编辑、传输，其性能和威刚SE760差不多是一个级别，但价格明显偏高，约2元/GB，500GB容量上千元，相比威刚SE760性价比偏低。
第五名 三星|T5
读写速度超快的移动固态硬盘 如今的三星是全球半导体领域的霸主，在固态硬盘市场份额远远超过闪迪、英特尔，位居世界第一，在闪存颗粒市场，三星同样将第二远远甩在身后，占全球份额近40%，其移动硬盘全是固态移动硬盘，T5就是其入门款。
如果说旗舰X5相当于M2 NVMe固态硬盘，那三星T5就相当于SATA固态硬盘，虽然是入门款，但性能优越，500MB/s的实际读取速度与480MB/s的实际写入速度使得其性能接近入门级SATA固态硬盘。相比其他品牌的SATA固态移动硬盘，三星T5在价格上也略微偏高，还达不到1元/GB，约为1.2元/GB，也就是说500GB容量售价在600元左右。
第六名 希捷|飞翼
USB-C接口，通用性更好 飞翼系列是希捷两大PSSD之一（另一款为颜系列），铝制外壳，采用的是USB-C接口，相比USB-A能够提供更高的传输速率，泛用性也更好，手机USB-C口充电线也可临时用来传输数据，性能为SATA标准，读540MB/s、写500MB/s左右，主控很可能是希捷自家STXZA01EA3B7。
希捷飞翼还附带了两根数据线，分别是USB A-C和USB C-C，性价比不错，500GB常年在600元以下，相比闪迪至尊极速和三星T5都更便宜一些。
第七名 闪迪|极速 固态硬盘
IP55防尘防水，读写速度出色 至尊极速系列在闪迪的定位一直是次旗舰，低于至尊超极速系列，固态硬盘也是如此。至尊极速移动固态硬盘性能相当于SATA固态硬盘，读写速度均可以达到500MB/S以上，外观为深灰主色调+橙色钥匙孔，支持IP55的防尘防水并可承受2米高坠落，更加坚固耐用。
相比至尊超极速，至尊极速的价格要相对友好许多，即便是加上了三防功能，单价也只有1.2元/GB左右，差不多是现在固态移动硬盘的平均水平，500GB售价在600元左右。
第八名 希捷|希捷颜系列SSD移动硬盘
顾名思义，希捷颜系列就是主打外观的款式，该系列中一共拥有5款子型号，除了Expansion SSD之外，还有龙盘款、迷彩款以及纯色编织布艺款，电商中比较常见的就是布艺款。和其他移动硬盘一样，颜系列默认文件系统为exFAT，能够同时兼容Windows和苹果Mac OS，性能则是略差于自家的飞翼系列，最大读取460MB/s，最大写入速度400MB/s左右，也是SATA级别，价格则和飞翼系列相差不大，500GB都在600元以下。
第九名 西部数据|My Passport SSD
500MB/S读写，掉速不明显 在西数移动硬盘产品线中，元素系列是低端入门系列，只有机械硬盘，My Passport则是高端系列，机械硬盘和固态硬盘都有。这款My Passport SSD底部是Type-C接口，支持USB 3.1Gen2，向下兼容USB 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d1b399c1ea56561833e38bdddfa89ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96d5989fdfde4b67550a7bbb27289be6/" rel="bookmark">
			小波变换的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、傅里叶变换的劣势以及小波变换的优势二、连续小波变换（CWT）的理解2.1 什么是小波变换？2.2 为什么小波变换能确定信号频率和其对应的时间区间？2.3 连续小波变换最大的特点是什么？2.4 其它补充 三、离散小波变换（DWT）的理解3.1 离散小波变换（DWT）定义3.2 一维离散小波变换3.3 二维离散小波变换3.4 离散小波变换（DWT）的Mallet算法（离散化实现）3.5 离散小波变换（DWT）的应用 四、总结 前言 小波变换：用于提取信号的局部特征（时域+频域信息）
小波变换是在傅里叶变换的基础上，发展而来，因此，在学习小波变换之前，需要对傅里叶变换有一定的了解。（傅里叶变换的内容在之前的实例中有介绍，这里不作赘述，详见对音频信号作短时傅里叶变换（STFT）/小波变换处理（python + matlab ；傅里叶变换（FT））
一、傅里叶变换的劣势以及小波变换的优势 傅里叶变换的基函数是三角函数，其作用域是信号的整个时间域，无法得到信号的局部特征（即只能获取一段信号总体上包含哪些频率的成分，但是对各成分出现的时刻并无所知）；尽管采用“加窗”的思想，改进得到短时傅里叶变换，可以提取信号得局部特征，但是由于短时傅里叶变换窗口固定，宽度相等，其特征提取效果并不好，无法满足非稳态信号变化的特征需求，故而引入小波变换，使得“窗口宽度”不一致（小波变换的思想不是加窗，而是通过尺度a分别同时与中心频率和基函数支撑区间产生关系，在这里可以形象化的理解为加窗，后续会进一步解释），从而更好的实现局部特征提取。
下面对傅里叶变换与小波变换的优缺点做一个小结，如下：
傅里叶变换的缺点： 不能刻画时间域上信号的局部特征（即无法获取各频率出现的时间信息）；对突变和非平稳信号的效果不好，没有了时域分析。 短时傅里叶变换的缺点： 对于时变的非稳态信号，高频适合小窗口，低频适合大窗口。然而短时傅里叶（STFT）的窗口是固定的，在一次STFT中，宽度不会变化，所以STFT还是无法满足非稳态信号变化的频率需求。 小波变换的优势：
（小波变换的优势就在于它能有效解决傅里叶变换的劣势） 它继承和发展了短时傅里叶变换的局部化思想，同时又克服了窗口大小不随频率变化等缺点，能够提供一个随频率改变的“时间-频率”窗口，是进行信号时频分析和处理的理想工具；它的主要特点是通过变换能够充分突出问题某些方面的特征，能对时间（空间）频率的局部化分析，通过伸缩平移运算对信号（函数)逐步进行多尺度细化，最终达到高频处时间细分，低频处频率细分，能自动适应时频信号分析的要求，从而可聚焦到信号的任意细节，解决了Fourier变换的困难问题，成为继Fourier变换以来在科学方法上的重大突破。 小波变换的劣势： 小波基的选取太难了，并且不同的小波基分析结果不同 二、连续小波变换（CWT）的理解 通过前面的阐述，我们知道了小波变换的优势，它可以对非稳态信号做时频分析。接下来，我们进一步了解，什么是小波变换？为什么小波变换能确定信号的频率和其对应的时间区间？
2.1 什么是小波变换？ 小波变换：
将傅里叶变换中无限长的三角函数基换成了有限长的会衰减的小波基。
小波变换公式：
小波变换的两个变量：
从公式可以看出，不同于傅里叶变换，变量只有频率w，小波变换有两个变量：尺度a（scale）和平移量 ζ（translation）。尺度a控制小波函数的伸缩，平移量 ζ控制小波函数的平移。尺度a就对应于频率（反比），平移量ζ就对应于时间。
当伸缩、平移到这么一种重合情况时，也会相乘得到一个大的值。这时候和傅里叶变换不同的是，这不仅可以知道信号有这样频率的成分，而且知道它在时域上存在的具体位置。而当我们在每个尺度线都平移着和信号乘过一遍后，我们就知道信号在每个位置上都包含哪些频率成分。
举个例子：
假设时域信号如下：
傅里叶变换结果：
小波变换结果：
由此，可进一步说明，傅里叶变换仅能知道信号的频率成分，小波变换不仅能知道信号的频率成分，还能知道各频率成分出现的时刻。
小波变换还有一些好处，比如，我们知道对于突变信号，傅里叶变换存在吉布斯效应，我们用无限长的三角函数怎么也拟合不好突变信号：
衰减的小波时：
以上，就是小波的意义。另外补充几个小波变换与傅里叶变换中的常见问题：
问题一、海森堡不确定性原理： 不确定性原理，或者叫做测不准原理，最早出自量子力学，意为在微观世界，离子的位置与动量不可同时被确定。但是这个原理并不局限于量子力学，有很多物理量都有这样的特征，比如能量和时间、角动量和角度。体现在信号领域就是时域和频域。不过更准确一点的表述应该是：一个信号不能再时空域和频域上同时过于集中；一个函数时域窄，它经过傅里叶变换的频域后就越宽。
问题二、关于正交化 什么是正交化？为什么说小波能实现正交化是优势？
简单说，如果采用正交基，变换域系数会没有冗余信息，变换前后的信号能量相等，等于是用最少的数据表达最大的信息量，利用数值压缩等领域。
问题三、关于瞬时频率，图中时刻点对应一频率值，一个时刻点只有一个信号值，又怎么能得到他的频率呢？ 很好的问题。如文中所说，绝对意义的瞬时频率其实是不存在的，但看一个时刻点的一个信号值，当然得不到他的频率。我们只不过是很短的一段信号的频率作为该时刻表的频率，所以我们得到的只是时间分辨率有限的近似分析结果。这一想法在STFT上体现的很明显，小波用衰减的基函数去测定信号的瞬时频率，思想也类似
小结：
傅里叶变换： 知道一段时间内，信号各个频率分量分别多少；
小波变换： 知道一段时间内，信号的各个频率分量分别是多少，以及他们都是什么时候出现的。
2.2 为什么小波变换能确定信号频率和其对应的时间区间？ 这个问题可以一分为二的来看，即，1. 为什么CWT能辨认出信号的频率成分？2. 为什么CWT能确定频率对应的时间区间？
morlet小波基函数分析： 以一个morlet小波基函数为例进行说明，其表达式如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96d5989fdfde4b67550a7bbb27289be6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14016569f6fb289418d591d711747413/" rel="bookmark">
			Spring的Bean加载和三级缓存解决循环依赖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文对spring bean的加载、循环依赖和三级缓存的关系描述的相当清晰，mark一下。
在使用spring框架的日常开发中，bean之间的循环依赖太频繁了，spring已经帮我们去解决循环依赖问题，对我们开发者来说是无感知的，下面具体分析一下spring是如何解决bean之间循环依赖，为什么要使用到三级缓存，而不是二级缓存。
bean生命周期
首先大家需要了解一下bean在spring中的生命周期，bean在spring的加载流程，才能够更加清晰知道spring是如何解决循环依赖的
我们在spring的BeanFactory工厂列举了很多接口，代表着bean的生命周期，我们主要记住的是我圈红线圈出来的接口, 再结合spring的源码来看这些接口主要是在哪里调用的
AbstractAutowireCapableBeanFactory类的doCreateBean方法是创建bean的开始，我们可以看到首先需要实例化这个bean，也就是在堆中开辟一块内存空间给这个对象，createBeanInstance方法里面逻辑大概就是采用反射生成实例对象，进行到这里表示对象还并未进行属性的填充，也就是@Autowired注解的属性还未得到注入
我们可以看到第二步就是填充bean的成员属性，populateBean方法里面的逻辑大致就是对使用到了注入属性的注解就会进行注入，如果在注入的过程发现注入的对象还没生成，则会跑去生产要注入的对象，第三步就是调用initializeBean方法初始化bean，也就是调用我们上述所提到的接口
可以看到initializeBean方法中，首先调用的是使用的Aware接口的方法，我们具体看一下invokeAwareMethods方法中会调用Aware接口的那些方法
我们可以知道如果我们实现了BeanNameAware，BeanClassLoaderAware，BeanFactoryAware三个Aware接口的话，会依次调用setBeanName(), setBeanClassLoader(), setBeanFactory()方法，再看applyBeanPostProcessorsBeforeInitialization源码
发现会如果有类实现了BeanPostProcessor接口，就会执行postProcessBeforeInitialization方法，这里需要注意的是：如果多个类实现BeanPostProcessor接口，那么多个实现类都会执行postProcessBeforeInitialization方法，可以看到是for循环依次执行的，还有一个注意的点就是如果加载A类到spring容器中，A类也重写了BeanPostProcessor接口的postProcessBeforeInitialization方法，这时要注意A类的postProcessBeforeInitialization方法并不会得到执行，因为A类还未加载完成，还未完全放到spring的singletonObjects一级缓存中。
再看一个注意的点
可以看到ApplicationContextAwareProcessor也实现了BeanPostProcessor接口，重写了postProcessBeforeInitialization方法，方法里面并调用了invokeAwareInterfaces方法，而invokeAwareInterfaces方法也写着如果实现了众多的Aware接口，则会依次执行相应的方法，值得注意的是ApplicationContextAware接口的setApplicationContext方法，再看一下invokeInitMethods源码
发现如果实现了InitializingBean接口，重写了afterPropertiesSet方法，则会调用afterPropertiesSet方法，最后还会调用是否指定了init-method，可以通过&lt;bean init-method&gt;标签，或者@Bean注解的initMethod指定，最后再看一张applyBeanPostProcessorsAfterInitialization源码图
发现跟之前的postProcessBeforeInitialization方法类似，也是循环遍历实现了BeanPostProcessor的接口实现类，执行postProcessAfterInitialization方法。整个bean的生命执行流程就如上面截图所示，哪个接口的方法在哪里被调用，方法的执行流程
最后，对bean的生命流程进行一个流程图的总结
三级缓存解决循环依赖
上一小节对bean的生命周期做了一个整体的流程分析，对spring如何去解决循环依赖的很有帮助。前面我们分析到填充属性时，如果发现属性还未在spring中生成，则会跑去生成属性对象实例
我们可以看到填充属性的时候，spring会提前将已经实例化的bean通过ObjectFactory半成品暴露出去，为什么称为半成品是因为这时候的bean对象实例化，但是未进行属性填充，是一个不完整的bean实例对象
spring利用singletonObjects, earlySingletonObjects, singletonFactories三级缓存去解决的，所说的缓存其实也就是三个Map
可以看到三级缓存各自保存的对象，这里重点关注二级缓存earlySingletonObjects和三级缓存singletonFactory，一级缓存可以进行忽略。前面我们讲过先实例化的bean会通过ObjectFactory半成品提前暴露在三级缓存中
singletonFactory是传入的一个匿名内部类，调用ObjectFactory.getObject()最终会调用getEarlyBeanReference方法。再来看看循环依赖中是怎么拿其它半成品的实例对象的。
我们假设现在有这样的场景AService依赖BService，BService依赖AService
1. AService首先实例化，实例化通过ObjectFactory半成品暴露在三级缓存中
2. 填充属性BService，发现BService还未进行过加载，就会先去加载BService
3. 再加载BService的过程中，实例化，也通过ObjectFactory半成品暴露在三级缓存
4. 填充属性AService的时候，这时候能够从三级缓存中拿到半成品的ObjectFactory
拿到ObjectFactory对象后，调用ObjectFactory.getObject()方法最终会调用getEarlyBeanReference()方法，getEarlyBeanReference这个方法主要逻辑大概描述下如果bean被AOP切面代理则返回的是beanProxy对象，如果未被代理则返回的是原bean实例，这时我们会发现能够拿到bean实例(属性未填充)，然后从三级缓存移除，放到二级缓存earlySingletonObjects中，而此时B注入的是一个半成品的实例A对象，不过随着B初始化完成后，A会继续进行后续的初始化操作，最终B会注入的是一个完整的A实例，因为在内存中它们是同一个对象。下面是重点，我们发现这个二级缓存好像显得有点多余，好像可以去掉，只需要一级和三级缓存也可以做到解决循环依赖的问题？？？
只要两个缓存确实可以做到解决循环依赖的问题，但是有一个前提这个bean没被AOP进行切面代理，如果这个bean被AOP进行了切面代理，那么只使用两个缓存是无法解决问题，下面来看一下bean被AOP进行了切面代理的场景
我们发现AService的testAopProxy被AOP代理了，看看传入的匿名内部类的getEarlyBeanReference返回的是什么对象
发现singletonFactory.getObject()返回的是一个AService的代理对象，还是被CGLIB代理的。再看一张再执行一遍singletonFactory.getObject()返回的是否是同一个AService的代理对象
我们会发现再执行一遍singleFactory.getObject()方法又是一个新的代理对象，这就会有问题了，因为AService是单例的，每次执行singleFactory.getObject()方法又会产生新的代理对象，假设这里只有一级和三级缓存的话，我每次从三级缓存中拿到singleFactory对象，执行getObject()方法又会产生新的代理对象，这是不行的，因为AService是单例的，所有这里我们要借助二级缓存来解决这个问题，将执行了singleFactory.getObject()产生的对象放到二级缓存中去，后面去二级缓存中拿，没必要再执行一遍singletonFactory.getObject()方法再产生一个新的代理对象，保证始终只有一个代理对象。还有一个注意的点
既然singleFactory.getObject()返回的是代理对象，那么注入的也应该是代理对象，我们可以看到注入的确实是经过CGLIB代理的AService对象。所以如果没有AOP的话确实可以两级缓存就可以解决循环依赖的问题，如果加上AOP，两级缓存是无法解决的，不可能每次执行singleFactory.getObject()方法都给我产生一个新的代理对象，所以还要借助另外一个缓存来保存产生的代理对象
总结
前面先讲到bean的加载流程，了解了bean加载流程对spring如何解决循环依赖的问题很有帮助，后面再分析到spring为什么需要利用到三级缓存解决循环依赖问题，而不是二级缓存。网上可以试试AOP的情形，实践一下就能明白二级缓存为什么解决不了AOP代理的场景了
在工作中，一直认为编程代码不是最重要的，重要的是在工作中所养成的编程思维和习惯。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbd0d7d5981ac72d11387c8251b36c20/" rel="bookmark">
			war包部署到Tomcat下运行步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、配置JDK安装路径到环境变量
2、配置Tomcat安装路径到环境变量
3、从Eclipse导出war包
在控制台console中查看war包保存的位置，根据路径找到war包
4、将war包放到$TOMCAT_HOME$ 的webapps目录下
5、进入目录$TOMCAT_HOME$ bin，点击startup.bat, 启动Tomcat服务器。（Linux系统点击startup.sh）
（此处若cmd窗口闪退，需将jdk路径和Tomcat路径配置到环境变量中并重启计算机）
6、Tomcat启动成功后，在浏览器中通过 【http://localhost:端口号/war包名称/】来访问war包对应的项目即可。
例如本次端口号为：8080，war包名称为：epower-web-1.0.war，
则访问路径为：http://localhost:8080/epower-web-1.0/
7、关闭Tomcat：点击$TOMCAT_HOME$ bin目录下的shutdown.bat
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dccbc4b1af0c07e4c3307a60b6a5bc5e/" rel="bookmark">
			springcloud 超详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：石杉的架构笔记（id:shishan100）
博文名：拜托！面试请不要再问我Spring Cloud底层原理！
欢迎关注微信公众号：石杉的架构笔记（id：shishan100）
每周一至周五早八点半！精品技术文章准时送上！
目录
一、业务场景介绍
二、Spring Cloud核心组件：Eureka
三、Spring Cloud核心组件：Feign
四、Spring Cloud核心组件：Ribbon
五、Spring Cloud核心组件：Hystrix
六、Spring Cloud核心组件：Zuul
七、总结
概述
毫无疑问，Spring Cloud是目前微服务架构领域的翘楚，无数的书籍博客都在讲解这个技术。不过大多数讲解还停留在对Spring Cloud功能使用的层面，其底层的很多原理，很多人可能并不知晓。因此本文将通过大量的手绘图，给大家谈谈Spring Cloud微服务架构的底层原理。
实际上，Spring Cloud是一个全家桶式的技术栈，包含了很多组件。本文先从其最核心的几个组件入手，来剖析一下其底层的工作原理。也就是Eureka、Ribbon、Feign、Hystrix、Zuul这几个组件。
一、业务场景介绍 先来给大家说一个业务场景，假设咱们现在开发一个电商网站，要实现支付订单的功能，流程如下：
创建一个订单之后，如果用户立刻支付了这个订单，我们需要将订单状态更新为“已支付”
扣减相应的商品库存
通知仓储中心，进行发货
给用户的这次购物增加相应的积分
针对上述流程，我们需要有订单服务、库存服务、仓储服务、积分服务。整个流程的大体思路如下：
用户针对一个订单完成支付之后，就会去找订单服务，更新订单状态
订单服务调用库存服务，完成相应功能
订单服务调用仓储服务，完成相应功能
订单服务调用积分服务，完成相应功能
至此，整个支付订单的业务流程结束
下图这张图，清晰表明了各服务间的调用过程：
好！有了业务场景之后，咱们就一起来看看Spring Cloud微服务架构中，这几个组件如何相互协作，各自发挥的作用以及其背后的原理。
二、Spring Cloud核心组件：Eureka
咱们来考虑第一个问题：订单服务想要调用库存服务、仓储服务，或者是积分服务，怎么调用？
订单服务压根儿就不知道人家库存服务在哪台机器上啊！他就算想要发起一个请求，都不知道发送给谁，有心无力！
这时候，就轮到Spring Cloud Eureka出场了。Eureka是微服务架构中的注册中心，专门负责服务的注册与发现。
咱们来看看下面的这张图，结合图来仔细剖析一下整个流程： 如上图所示，库存服务、仓储服务、积分服务中都有一个Eureka Client组件，这个组件专门负责将这个服务的信息注册到Eureka Server中。说白了，就是告诉Eureka Server，自己在哪台机器上，监听着哪个端口。而Eureka Server是一个注册中心，里面有一个注册表，保存了各服务所在的机器和端口号
订单服务里也有一个Eureka Client组件，这个Eureka Client组件会找Eureka Server问一下：库存服务在哪台机器啊？监听着哪个端口啊？仓储服务呢？积分服务呢？然后就可以把这些相关信息从Eureka Server的注册表中拉取到自己本地缓存起来。
这时如果订单服务想要调用库存服务，不就可以找自己本地的Eureka Client问一下库存服务在哪台机器？监听哪个端口吗？收到响应后，紧接着就可以发送一个请求过去，调用库存服务扣减库存的那个接口！同理，如果订单服务要调用仓储服务、积分服务，也是如法炮制。
总结一下：
Eureka Client：负责将这个服务的信息注册到Eureka Server中
Eureka Server：注册中心，里面有一个注册表，保存了各个服务所在的机器和端口号
三、Spring Cloud核心组件：Feign 现在订单服务确实知道库存服务、积分服务、仓库服务在哪里了，同时也监听着哪些端口号了。但是新问题又来了：难道订单服务要自己写一大堆代码，跟其他服务建立网络连接，然后构造一个复杂的请求，接着发送请求过去，最后对返回的响应结果再写一大堆代码来处理吗？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dccbc4b1af0c07e4c3307a60b6a5bc5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4421079de75f2d48e7a82399b2481707/" rel="bookmark">
			pycharm 切换 python3.9 报错 ‘HTMLParser‘ object has no attribute ‘unescape‘ 解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有的bug，莫名其妙就好了…
推荐一个好东西：这大概是所有python程序员都会喜欢的惊喜吧！
python3.9 报错 “AttributeError: 'HTMLParser' object has no attribute 'unescape'” 异常分析解决。
一、问题描述 安装 python3.9 版本后，pycharm 中切换 python3.9 版本，创建虚拟环境报错："AttributeError: 'HTMLParser' object has no attribute 'unescape'"。
Executed command: C:\Users\程序员的一天\AppData\Local\Temp\tmp41_yhcxspycharm-management\setuptools-40.8.0\setup.py install Error occurred: AttributeError: 'HTMLParser' object has no attribute 'unescape' Command output: Traceback (most recent call last): File "C:\Users\程序员的一天\AppData\Local\Temp\tmp0mv4mj35pycharm-management\setuptools-40.8.0\setup.py", line 11, in &lt;module&gt; import setuptools File "C:\Users\程序员的一天\AppData\Local\Temp\tmp0mv4mj35pycharm-management\setuptools-40.8.0\setuptools\__init__.py", line 20, in &lt;module&gt; from setuptools.dist import Distribution, Feature File "C:\Users\程序员的一天\AppData\Local\Temp\tmp0mv4mj35pycharm-management\setuptools-40.8.0\setuptools\dist.py", line 35, in &lt;module&gt; from setuptools.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4421079de75f2d48e7a82399b2481707/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3abd6cf74dfc6db6a82e268bc13d91fe/" rel="bookmark">
			mysql主从架构与分库分表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、主从架构形式
一主一从
一主多从
多主一从
一主多级从
双主
2、分库分表
3、数据同步方式
GITD、Bin-log(逻辑重放)
配置：sync-binlog=1
binlog-do-db=数据库
线程-&gt;dump（写入到relay-log）-&gt;relay-log(重放写入)
同步可以同步表也可以同步库
–同步复制：
–异步复制：
–半同步复制：
4、分库分表带来的问题
–分页–
–关联–
–sum–
–DISTINCT–
5、解决redis缓存和mysql强一致问题
可以借助阿里Canal伪装mysql从库读取binlog增量日志数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04151379dca402e53370029a22b98ebb/" rel="bookmark">
			数据降维的几种常见方法（PCA；FA；LDA；ICA等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 数据降维方式简述PCA与ICA、FA、LDA的区别与联系1.PCA与ICA的联系与区别2.PCA与LDA的联系与区别3.PCA与FA的联系与区别 总结 数据降维方式简述 在学习ICA算法的过程中，了解到常常需要对数据进行降维，如PCA，FA等，以达到数据预处理的效果，因此查阅相关资料，在这里对数据降维的几种常见方法进行归纳、梳理。
数据降维就是降低数据的维度，达到增加样本密度以及去噪的目的。降维方式主要有两种方式：
1、一种是特征选择：直接选取原有维度的一部分参与后续的计算和建模过程，用选择的维度替代所有维度，整个过程不产生新的维度（即从现有的特征里选择较小的一些来达到降维的目的）。
方法：
（1）经验法：根据业务经验选择
（2）测算法：通过不断测试多种维度选择参与计算，通过结果来反复验证和调整并最终找到最佳特征方案
（3）统计分析方法：通过相关性分析不同维度间的线性相关性，在相关性高的维度中进行人工去除或筛选；通过计算不同维度间的互信息，找到具有较高互信息的特征集，然后把其中的一个特征去除或留下
（4）机器学习：通过机器学习算法得到不同特征的特征值或权重，然后再根据权重来选择较大的特征，例用决策树得出不同变量的重要程度。
2、另一种是特征提取：按照一定的数学变换方法，将高维空间的数据点映射到低维空间中，然后利用映射后的变量特征来表示原有的总体特征（即通过组合现有特征来达到降维的目的）。
方法：常用算法有独立成分分析（ICA）、主成分分析PCA、因子分析FA、线性判别分析LDA、局部线性嵌入（LLE）、核主成分分析（Kernel PCA）等
PCA与ICA、FA、LDA的区别与联系 PCA也叫主元分析，是一种常用的线性降维方式，比如在人脸识别中的“特征脸”（Eigenfaces）。降维之后的每个“新”特征都被称为主成分。这是一种无监督的降维方法，没有用到样本的标记信息。
1.PCA与ICA的联系与区别 相同点：
都不需要你对源信号的分布做具体的假设； 如果观察到的信号为高斯，那么源信号也为高斯，此时PCA和ICA等价。都可以实现数据得降维； PCA是寻找特征值矩阵，ICA是寻找解混矩阵；从线性代数的角度去理解，PCA和ICA都是要找到一组基，这组基张成一个特征空间，数据的处理就都需要映射到新空间中去。 不同点：
处理数据的类型不同； ICA处理非高斯数据，PCA、FA都是处理高斯数据。处理目的不同： ICA提取相互独立的属性，而且降维；PCA只做数据的降维。ICA的数据预处理中会用到PCA求解过程不同； ICA 认为观测信号是若干个统计独立的分量的线性组合，ICA要做的是一个解混过程；而PCA是一个信息提取的过程，将原始数据降维，现已成为ICA将数据标准化的预处理步骤；PCA和ICA的用途完全不同。 如果只在意数据的能量或方差、假设噪声或不感兴趣的信号都比较微弱，那么用PCA就能把主要信号留下来。在某种意义上，ICA更智能——它不在意信号的能量或方差，只看独立性。所以给定的待分析的混合信号经任意的线性变换都不会影响ICA的输出结果，但会严重影响PCA的结果。简而言之：PCA有助于压缩数据，而ICA有助于分离数据 详见：主成分分析与独立成分分析的区别
2.PCA与LDA的联系与区别 详见：PCA与LDA的联系与区别
3.PCA与FA的联系与区别 总结 本文参考来源：
https://blog.csdn.net/yingwei13mei/article/details/82690357 机器学习中的降维算法汇总归纳
https://blog.csdn.net/qq_34919792/article/details/104042365 特征转换方法比较（PCA、ICA、LDA）
https://www.cnblogs.com/Determined22/p/6357291.html 特征提取之线性方法（PCA、ICA、LDA）
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/91/">«</a>
	<span class="pagination__item pagination__item--current">92/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/93/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>