<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2f877f9f112cf7602fffdc6e636f75e/" rel="bookmark">
			c&#43;&#43; 记忆化搜索_计算广告：竞价广告计价算法、搜索广告系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、竞价广告计价算法 第 5 章中介绍了搜索广告和广告网络这两种最典型的竞价广告产品。在进入这些具体产品的技术之前，我们先来了解一下“竞价”这一核心逻辑的具体实现，顺便引出此核心逻辑的几项主要支持技术。
5.2 节中介绍了位置拍卖市场中一些常用的定价策略，包括 GSP、MRP、价格挤压等，单独理解这些策略都不困难。在实际的系统中，我们需要将这几种策略综合起来执行。以
按 CPC 计价的竞价广告产品中一次广告展示为例，我们将实际的计价算法用下面的代码描
述，可以对照表 5.2 来进一步直观地理解这一完整的定价过程。
1 //In:2 // cands : 候选广告 ID3 // ctrs : 候选广告预估的点击率4 // bids : 候选广告的出价5 // MRP : 市场保留价6 // squash : 价格挤压因子7 // slotNum : 要求的广告条目数8 //Out:9 // results : 排序结果10 // prices : 计价结果11 void auction(vector&lt;int &gt; &amp; cands, Vec &amp; ctrs, Vec &amp; bids, float MRP,12 float squash, int slotNum, vector&lt;int&gt; &amp; results, Vec &amp; prices) {13 int candNum = cands.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2f877f9f112cf7602fffdc6e636f75e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ac75f544126ad80036e055b6b8b8f93/" rel="bookmark">
			自然语言处理_「自然语言处理」使用自然语言处理的智能文档分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是智能文档分析? 智能文档分析(IDA)是指使用自然语言处理(NLP)和机器学习从非结构化数据(文本文档、社交媒体帖子、邮件、图像等)中获得洞察。由于80%的企业数据是非结构化的，因此IDA可以跨行业和业务功能提供切实的好处，例如改善遵从性和风险管理、提高内部运营效率和增强业务流程。
在本博客中，我将描述IDA中使用的主要NLP技术，并提供各种业务用例的示例。我还将讨论启动第一个IDA项目时的一些关键考虑事项。
智能文档分析技术
以下是7种常见的IDA技术。将提供示例用例来解释每种技术。
1. 命名实体识别 命名实体识别识别文本中提到的命名实体，并将它们分类到预定义的类别中，如人名、组织、位置、时间表达式、货币值等。有一系列的方法来执行命名实体识别:
开箱即用的实体识别——大多数NLP包或服务都包括用于识别实体的预先训练好的机器学习模型。这使得识别关键实体类型(如人名、组织和位置)变得非常容易，只需一个简单的API调用，而不需要训练机器学习模型。机器学习的实体识别——开箱即用的实体很方便，但通常是通用的，在许多情况下，需要识别其他的实体类型。例如，在招聘环境中处理文档时，我们想要识别工作头衔和技能。在零售环境中，我们希望识别产品名称。确定性实体识别——如果你想要识别的实体是有限的并且是预定义的，那么确定性方法将比训练一个机器学习模型更容易更准确。在这种方法中，提供了实体的字典;然后，实体识别器将在文本中识别字典条目的任何实例。例如，字典可以包含公司所有产品的列表。将字典方法与机器学习相结合也是可能的。字典用于为机器学习模型注释训练数据，然后机器学习模型学习识别不在字典中的实体实例。确定性实体识别通常不支持开箱即用的NLP包或服务。一些支持这种确定性方法的NLP包使用本体而不是字典。本体为实体定义关系和相关术语，这使实体识别器能够使用文档的上下文来消除模糊实体之间的歧义。基于模式的实体识别——如果实体类型可以由正则表达式定义，那么可以使用正则表达式匹配来识别它们。例如，可以使用正则表达式标识产品代码或引用引用。英国国家保险号码的简化正则表达式为[A- z]{2}[0-9]{6}[A- z](2个大写字母，后面跟着6个数字，后面跟着1个大写字母)。 命名实体识别是本博客中讨论的许多其他rda技术的关键预处理技术。其他命名为实体识别用例的例子包括:
在财务说明书中指明公司和基金的名称。在这个例子中，公司名称可以使用开箱即用的模型来识别，而基金名称可以使用机器学习模型、确定性方法或两者的结合来识别。标识语料库中文档之间的引用。在本例中，可以使用正则表达式(一种基于模式的实体识别方法)标识引用。 2. 情绪分析 情绪分析识别和分类文本中表达的意见，如新闻报道，社交媒体内容，评论等。在最简单的形式下，它可以将情绪分为积极和消极两类;但它也可以量化情绪(如-1到+1)，或将其分类在一个更细粒度的水平(如非常负面、负面、中性、积极、非常积极)。
情感分析，像许多NLP技术一样，需要能够处理语言的复杂性。例如:
否定——像“不”和“决不”这样的词会改变所使用的词的感情。例如，“这部电影没有扣人心弦的情节，也没有可爱的角色。”层次情感可以在不同程度上表达出来。例如，在“我喜欢它”、“我爱它”和“我绝对喜欢它”中，正能量在不断增加，但是“我真的很喜欢它”在这一进程中处于什么位置呢?冲突-文本可能包括积极和消极的情绪。例如，“他们的第一张专辑很棒，但他们的第二张专辑是垃圾”应该被认为是积极的，消极的，或中性的?含蓄——在句子“如果交货晚了，我会生气的”中，负面情绪是建立在一些没有发生，也可能不会发生的事情上的。在“They used to be good”这句话中，表达的是对过去的肯定情绪，但可能隐含的是对现在的否定情绪。俚语——俚语的意思通常与传统意义相反。例如，“sick”这个词会有非常不同的含义，这取决于它使用的语境(“这家餐厅的食物让我恶心”vs.“那个新推出的视频游戏真恶心!”)或者作者的人口结构。实体级——实体级情感分析通过在实体级而不是在文档或语句级考虑情感，提供了对情感更细粒度的理解。这将解决在“冲突”场景中看到的模糊性(“他们的第一张专辑很棒，但他们的第二张专辑是垃圾。”)。它通过给第一个专辑(第一个实体)分配积极的情绪，而给第二个专辑(第二个实体)分配消极的情绪来做到这一点。 情绪分析经常被用来分析与公司或其竞争对手有关的社交媒体帖子。它可以是一种强有力的工具:
跟踪一段时间内的情绪趋势分析事件的影响(例如产品发布或重新设计)识别关键影响者提供危机的早期预警 3.文本相似度 文本相似性计算句子、段落和文档之间的相似性。
为了计算两个条目之间的相似度，必须首先将文本转换为表示文本的n维向量。这个向量可能包含文档中的关键字和实体，或者内容中表示的主题的表示。向量和文档之间的相似性可以通过余弦相似度等技术来测量。
文本相似性可用于检测文档或文档部分中的重复项和近似重复项。这里有两个例子:
通过比较论文内容的相似性来检查学术论文是否抄袭。匹配求职者和工作，反之亦然。但在这种情况下，它关注的是关键特征(职位、技能等)之间的相似性，而不是严格的近似重复检测。对于这种类型的用例，语义相似性是有用的，因为考虑两种技能(如人工智能和机器学习)或职位(如数据科学家和数据架构师)可能是相关的，即使它们不完全相同，这是很重要的。 4. 文本分类 文本分类用于根据文本的内容将文本项分配给一个或多个类别。它有两个维度:
分类的数量——最简单的分类形式是二值分类，即只有两种可能的类别可以将一个项分类到其中。这方面的一个例子是垃圾邮件过滤，其中电子邮件分类为垃圾邮件或非垃圾邮件。多类或多项分类有两个以上的类，其中一个项可被分类到其中。标签数量-单标签分类将一个项目精确地分类为一个类别，而多标签分类可以将一个项目分类为多个类别。将新闻文章分类到多个主题区域就是多标签分类的一个例子。 一般来说，类和标签的数量越少，预期的准确性就越高。
文本分类将使用文档中的单词、实体和短语来预测类。它还可以考虑其他特性，比如文档中包含的任何标题、元数据或图像。
文本分类的一个示例用例是文档(如邮件或电子邮件)的自动路由。文本分类用于确定文档应该发送到的队列，以便由适当的专家团队处理，从而节省时间和资源(例如，法律、市场营销、金融等)。
文本分类也可应用于文件的各部分(例如句子或段落)，例如，用以确定信件的哪些部分提出了投诉，以及投诉的类型。
5. 信息提取 信息抽取从非结构化文本中提取结构化信息。
一个示例用例是标识信件的发送者。识别的主要手段是发送人的参考资料、身份证明或会员编号。如果没有找到，那么回退可能是发件人的姓名、邮政编码和出生日期。每一条信息都可以通过命名实体识别来识别，但是这本身是不够的，因为可能会找到多个实例。信息提取依赖于实体识别。对实体上下文的理解有助于确定哪个是正确的答案。例如，信件可能包含多个日期和邮政编码，因此有必要确定哪个是发件人的出生日期，哪个是发件人的邮政编码。
6. 关系抽取 关系提取提取两个或多个实体之间的语义关系。与信息抽取类似，关系抽取依赖于命名实体识别，但区别在于它特别关注实体之间的关系类型。关系提取可用于执行信息提取。
一些NLP包和服务提供了开箱即用的模型来提取关系，比如“雇员的”、“结婚的”和“出生的地点”。与命名实体识别一样，自定义关系类型可以通过训练特定的机器学习模型来提取。
关系提取可用于处理非结构化文档，以确定具体的关系，然后将这些关系用于填充知识图。
例如，该技术可以通过处理非结构化医学文档来提取疾病、症状、药物等之间的关系。
7. 综述 摘要缩短了文本，以创建一个连贯的主要观点的摘要。文本摘要有两种不同的方法:
基于提取的摘要在不修改原文的情况下提取句子或短语。这种方法生成由文档中最重要的N个句子组成的摘要。基于摘要的摘要使用自然语言生成来改写和压缩文档。与基于提取的方法相比，这种方法更加复杂和实验性。 文本摘要可用于使人们能够快速地消化大量文档的内容，而不需要完全阅读它们。这方面的一个例子是新闻feed或科学出版物，它们经常生成大量的文档。
智能文档分析任务的复杂性 机器学习在非结构化文本上要比在结构化数据上复杂得多，因此在分析文本文档方面要达到或超过人类水平的性能要困难得多。
1. 语言的复杂性 由于语言所包含的变化、歧义、语境和关系，人类要花很多年才能理解语言。我们可以通过许多方法来表达相同的思想。我们根据作者和读者的不同使用不同的风格，并选择使用同义词来增加兴趣和避免重复。rda技术必须能够理解不同的样式、歧义和单词关系，从而获得准确的洞察。
IDA需要理解通用语言和特定领域的术语。处理特定领域术语的一种方法是使用自定义字典或构建用于实体提取、关系提取等的自定义机器学习模型。
解决将通用语言和特定领域术语结合在一起的问题的另一种方法是迁移学习。这需要一个已经训练了大量通用文本的现有神经网络，然后添加额外的层，并使用针对特定问题的少量内容来训练组合的模型。现有的神经网络类似于人类在学校发展的年代。额外的层次类似于当一个人离开学校并开始工作时发生的领域或特定任务学习。
2. 精度 rda技术的准确性取决于所使用的语言的多样性、风格和复杂性。它还可以取决于:
训练数据——机器学习模型的质量取决于训练数据的数量和质量。类的数量——诸如文本分类、情感分析、实体提取和关系提取等技术的准确性将取决于类的数量和实体/关系的类型以及它们之间的重叠。文档大小——对于某些技术，比如文本分类和相似性，大型文档很有帮助，因为它们提供了更多的上下文。情绪分析和总结等其他技术对大型文档的处理难度更大。 NLP-progress是一个网站，它追踪最常见的NLP任务上最先进的模型的准确性。这为可能达到的精确度水平提供了有用的指导。不过，要判断IDA是否会产生准确的结果，最好的指南是问问自己“人类做这件事有多容易?”“如果一个人可以在不经过多年培训的情况下学会准确地完成这项任务，那么IDA就有可能通过加快过程、保持一致性或减少体力劳动来带来好处。”
如何处理智能文档分析项目? IDA项目可以通过以下两种方式之一集成到企业中:
自动化——rda用于自动化现有或新流程，无需任何人工干预人在回路中——IDA用于在人做决策时提供支持，但人负有最终的责任。 所使用的方法应该取决于IDA所达到的准确性和做出错误决策的成本。如果错误决策的成本很高，那么考虑从人工循环开始，直到准确度足够高为止。
IDA项目最好以迭代的方式处理——从概念验证开始，以确定该方法是否可行，如果可行，所达到的精度是否表明使用了自动化或人在循环。然后迭代地增加复杂性，直到估计的工作量不能证明预期的收益。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ac75f544126ad80036e055b6b8b8f93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f6955a9be3e51b705e1dbc556f3142d/" rel="bookmark">
			输入一个字符串并判断英文字母个数、中文字母个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分析：
首先输入的是一个字符串,所以要讲字符串转换成字符数组，遍历数组中所有元素然后在进行判断。 利用String的常用方法toCharArray() 将字符串转换为字符数组 System.out.println("请输入一个字符串"); String a=sc.next(); char[] chars = a.toCharArray(); System.out.println(Arrays.toString(chars)); 结果
判断元素是否为英文、和元素是否为中文，求出中的个数
两种判断方式： 利用Java Character类
-利用JAVA中 Character. isLetter(ch)方法判断字符是否为字母，ch为要测试的字符 //实例： public class Test { public static void main(String args[]) { System.out.println(Character.isLetter('c')); System.out.println(Character.isLetter('5')); } } 以上执行结果：
- 利用Java中 Character.isDigit(ch)方法判断字符是否为数字 public class Test { public static void main(String args[]) { System.out.println(Character.isDigit('c')); System.out.println(Character.isDigit('5')); } } 以上执行结果：
2.利用范围进行判断
判断该元素是否为英文：确定该元素是否是在[a-z]或者[A-Z]中间，判断是否为数字则判断是否在[0-9]。
断实例 public static void main(String[] args) { char a='f'; char b='F'; char c='5'; //判断是否属于英文字母 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f6955a9be3e51b705e1dbc556f3142d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce7ac16550534a9fd9de67f1714ed0f1/" rel="bookmark">
			Pandas 02-基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pandas 02-基础 import numpy as np import pandas as pd pd.__version__ '1.1.5' 在开始学习前，请保证 pandas 的版本号不低于1.1.4，否则请务必升级！
一、文件的读取和写入 1. 文件读取 pandas可以读取的文件格式有很多，这里主要介绍读取csv, excel, txt文件。
df_csv = pd.read_csv('../data/my_csv.csv') df_csv col1col2col3col4col502a1.4apple2020/1/113b3.4banana2020/1/226c2.5orange2020/1/535d3.2lemon2020/1/7 df_txt = pd.read_table('../data/my_table.txt') df_txt col1col2col3col402a1.4apple 2020/1/113b3.4banana 2020/1/226c2.5orange 2020/1/535d3.2lemon 2020/1/7 df_excel = pd.read_excel('../data/my_excel.xlsx') df_excel col1col2col3col4col502a1.4apple2020/1/113b3.4banana2020/1/226c2.5orange2020/1/535d3.2lemon2020/1/7 这里有一些常用的公共参数，header=None表示第一行不作为列名，index_col表示把某一列或几列作为索引，索引的内容将会在第三章进行详述，usecols表示读取列的集合，默认读取所有的列，parse_dates表示需要转化为时间的列，关于时间序列的有关内容在第十章，nrows表示读取的数据行数。上面这些参数在上述的三个函数里都可以使用。
pd.read_table('../data/my_table.txt', header=None) 01230col1col2col3col412a1.4apple 2020/1/123b3.4banana 2020/1/236c2.5orange 2020/1/545d3.2lemon 2020/1/7 pd.read_csv('../data/my_csv.csv', index_col=['col1', 'col2']) col3col4col5col1col22a1.4apple2020/1/13b3.4banana2020/1/26c2.5orange2020/1/55d3.2lemon2020/1/7 pd.read_table('../data/my_table.txt', usecols=['col1', 'col2']) col1col202a13b26c35d pd.read_csv('../data/my_csv.csv', parse_dates=['col5']) col1col2col3col4col502a1.4apple2020-01-0113b3.4banana2020-01-0226c2.5orange2020-01-0535d3.2lemon2020-01-07 pd.read_excel('../data/my_excel.xlsx', nrows=2) col1col2col3col4col502a1.4apple2020/1/113b3.4banana2020/1/2 在读取txt文件时，经常遇到分隔符非空格的情况，read_table有一个分割参数sep，它使得用户可以自定义分割符号，进行txt数据的读取。例如，下面的读取的表以||||为分割：
pd.read_table('../data/my_table_special_sep.txt') col1 |||| col20TS |||| This is an apple.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce7ac16550534a9fd9de67f1714ed0f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5777558c362b75f866f0430ec518a03/" rel="bookmark">
			C# ——【关键字：并发编程】TASK常见用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、普通多线程代码
Task curTask = new Task(() =&gt; { //你的代码 }); curTask.Start(); 二、涉及UI界面的多线程代码
Task curTask = new Task(() =&gt; { //线程操作UI界面需要加上Application.Current.Dispatcher.Invoke部分 Application.Current.Dispatcher.Invoke(new System.Action(() =&gt; { //你的代码 })); }); curTask.Start(); 三、常见报错
1、报错：线程操作UI界面需要STA
解决方法：按照第二部分添加Application部分代码
Task curTask = new Task(() =&gt; { //线程操作UI界面需要加上Application.Current.Dispatcher.Invoke部分 Application.Current.Dispatcher.Invoke(new System.Action(() =&gt; { //你的代码 })); }); curTask.Start(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72d3ca18bb002291af2439c7e8e2e169/" rel="bookmark">
			安卓版火狐浏览器好用插件_热点 | Firefox火狐浏览器重大问题：大量用户反馈插件停止工作...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		铅笔道5月4日讯 今天大量用户报告所有Firefox插件(也称为扩展)被错误禁用，Mozilla已承认其系统存在问题。该错误导致Firefox浏览器在扩展上方显示错误消息“无法验证并已禁用一个或多个已安装的扩展”。
由于Firefox浏览器出现故障，所有流行的扩展程序(如Dark Mode，LastPass，Ghostery等)都会受到影响。Bugzilla帖子表明问题与不正确的扩展证书签名有关。这意味着已签署的Firefox扩展已被标记为不受支持。换句话说，扩展禁用是由于中间签名证书到期。
另一位用户透露，Firefox也不会让用户重新下载任何东西。如果你尝试重新下载受影响的扩展程序，则可能会收到一条通用消息，指出下载失败并检查你的Internet连接。
在Twitter帖子中，Mozilla承认Firefox扩展出现故障，该公司表示证书问题可能会禁用你的插件。Firefox工程师正在积极调查问题并准备解决问题的方法。(IT之家)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d40966ae5ff54f3062860ca06869f55/" rel="bookmark">
			简述raid 0 1 5 10的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、RAID卡概述 1、DELL阵列卡（RAID卡）
RAID是英文Redundant Array of Independent Disks的缩写，中文简称为独立冗余磁盘阵列。简单的说，RAID是一种把多块独立的硬盘（物理硬盘）按不同的方式组合起来形成一个硬盘组（逻辑硬盘），从而提供比单个硬盘更高的存储性能和提供数据备份技术。
组成磁盘阵列的不同方式称为RAID级别（RAID Levels）。
集中管理思想：资源整合，用统一标准进行管理
2、基本作用：
网站数据量很大的时候，单块盘装不下了，购买多块盘，又不想单个存放数据，就需要把所有硬盘整合成一个大磁盘，再在这个大磁盘上在分区（虚拟磁盘）放数据。
另外一个功能，多块磁盘放在一起可以有冗余（备份）。
3、特点（和硬盘做对比）
相同之处：组成的磁盘组就像是一个硬盘，用户可以对它进行分区，格式化等等。总之，对磁盘阵列的操作与单个硬盘一模一样。
不同之处：磁盘阵列的存储速度要比单个硬盘高很多，而且可以提供自动数据备份。数据备份的功能是在用户数据一旦发生损坏后，利用备份信息可以使损坏数据得以恢复，从而保障了用户数据的安全性。
二、RAID有多种整合方式，主要有：RAID 0 1 5 10 有RAID卡后，一般磁盘就会插到RAID卡上，而不是插到主板上了。
优点：读写都很快
1、企业应用
不同RAID级别的企业应用举例：根据数据的存储和访问的需求，去选择RAID
互联网公司服务器一般都会买RAID卡（主板自带，独立RAID卡），RAID卡上也是有缓存的。
1、主要性能排序：
冗余从好到坏：raid 1 raid 10 raid 5 raid 0
性能从好到坏：raid 0 raid 10 raid 5 raid 1
成本从低到高：raid 0 raid 5 raid 1 raid 10
2、RAID类型的选择
单台服务器,很重要，盘不多，系统盘raid1
数据库/存储服务器，主库raid10，从库raid5/raido（为了维护成本，raid10）
web服务器，如果没有太多的数据的话，raid5，raid0（单盘）
有多台监控/应用服务器raid5，raid0
2、RAID 0 1 5 10 简单区别
类型
RAID0
RAID1
RAID5 （raid0 和raid的折中方案）
RAID10 （RAID0+1镜像阵列条带）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d40966ae5ff54f3062860ca06869f55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9516130e0f97457e798bcb3da58c3b21/" rel="bookmark">
			Python爬虫：ZzzFun动漫视频网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提醒：转载请标明作者和原文链接！！！
CSDN个人主页： 高智商白痴
原文地址： https://blog.csdn.net/qq_44700693/article/details/109924262
日常跳转： 前言分析获取m3u8文件链接下载m3u8文件源码及结果最后 前言 我们都知道爬虫分为两类，分别是 通用爬虫 和 聚焦爬虫 ，我在这次的实例说明前给大家简要说明一下：
1、通用爬虫：
通用网络爬虫是捜索引擎抓取系统（Baidu、Google等）的重要组成部分。主要目的是将互联网上的网页下载到本地，形成一个互联网内容的镜像备份。
但是搜索引擎蜘蛛的爬取是被定义了一定的规则的，它需要遵从一些命令或文件的内容，如标注为 nofollow 的链接，或者是 Robots 协议。
2、聚焦爬虫：
聚焦爬虫是 “面向特定主题需求” 的一种网络爬虫程序，它与通用搜索引擎爬虫的区别在于： 聚焦爬虫在实施网页抓取时会对内容进行处理筛选，尽量保证只抓取与需求相关的网页信息。而我们将要学习的，就是聚焦爬虫。
而在编写 聚焦爬虫 时，免不了会遇到一些反扒机制，如：
1、headers and referer 反爬机制2、IP 限制3、UA限制4、验证码反爬虫或者模拟登陆
… 其实到目前为止，我已经写过一些关于一些 反反爬 的案例，大家可以自行去了解：https://blog.csdn.net/qq_44700693/category_9835663.html
分析 而今天呢，我又将会给大家介绍另一种反爬的情况：ZzzFun动漫视频网 - (￣﹃￣)~zZZ
针对这个网站会有一个不同于其他网站的特性：
不知道各位有没有发现什么，没错！那就是该网站某些页面无法调试，否则会 直接跳转到网站首页！这是因为在网页的某一请求资源下含有以下的 JS源码：
//debug调试时跳转页面 var element = new Image(); Object.defineProperty(element,'id',{get:function(){window.location.href="http://www.zzzfun.com"}}); console.log(element); 先不要管这段代码从哪里来，我后面会说明。不光是代码，我甚至就连代码的原注释都复制过来了，应该已经说的够详细了吧~~
针对这样的网站，像以前单纯的用浏览器抓包已经满足不了我们了，所以就需要用一点特殊的手段，使用第三方的工具 Fiddler 来进行抓包。
关于 Fiddler 的内容就在我之前的一篇文章里，我还会持续更新用法的~~
Fiddler：Fiddler新旧版抓包相关总结
说干就干，我这次使用的是最新版的 Fiddler Everywhere ，毕竟界面简洁干净嘛~
我们还是打开某一动漫的详情介绍页面后打开 Fiddler Everywhere 开始抓取请求：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9516130e0f97457e798bcb3da58c3b21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a32688f4c6737303b8ccac63fa141c08/" rel="bookmark">
			如何在python中表示微分_Python实现自动微分(Automatic Differentiation)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是自动微分
自动微分(Automatic Differentiation)是什么？微分是函数在某一处的导数值，自动微分就是使用计算机程序自动求解函数在某一处的导数值。自动微分可用于计算神经网络反向传播的梯度大小，是机器学习训练中不可或缺的一步。
如何计算微分
微分计算离不开数学求导，如果你还对高等数学有些印象，大概记得如下求导公式：常见求导公式
这些公式难免让人头大，好在自动微分就是帮助我们“自动”解决微分问题的。机器学习平台如TensorFlow、PyTorch都实现了自动微分，使用非常的方便，不过有必要理解其原理。要理解“自动微分”，需要先理解常见的求解微分的方式，可分为以下四种：手动求解法(Manual Differentiation)
数值微分法(Numerical Differentiation)
符号微分法(Symbolic Differentiation)
自动微分法(Automatic Differentiation)
手动求解法
所谓手动求解法就是手动算出求导公式，然后将公式编写成计算机代码完成计算。比如对于函数
求微分，首先根据求导公式表找出其导数函数 ，然后将这个公式写成计算机程序，对于任意的输入 都能用这段程序求出其导数，也就是此时的微分。是不是很简单？
这样做虽然直观，但却有两个明显的缺点：每次都要根据手动算出求导公式然后编写代码，导致程序很难复用。
更让人难受的是，复杂的函数普通人很难轻易写出求导公式
于是引出数值微分法。
数值微分法
数值微分法直接根据微分的极限定义形式：
只需要在
附近区一个很小的 (比如 0.00001)，分别计算 和 的值，然后做一个减法和除法就能得到此时的微分了，非常的直观。无论 是多么复杂的函数都可以带入上述公式求得微分。
该方法的缺陷是计算量太大，并且存在roundoff error和truncation error的问题。现实中仅仅常用它来验证其他自动微分程序的正确性，而不用于实际生产。
符号微分法
回顾“手动求解法”能联想到将常见求导公式写成固有函数，直接调用岂不是更方便？在此基础上基于链式求导法则对复杂公式求导，岂不是就解决了全部问题！链式求导法则
来看一下实际效果，下表展示了几个函数的符号微分公式：符号微分公式
上图中第一列是原函数，第二列是符号微分法的计算公式，第三列是第二列的数学简化。即使是简化之后，微分计算公式也还要比原函数要复杂(更大的计算量)！所以这个方法也是理论上可行，实际上并不会采用。
自动微分
自动微分同时结合了“数值微分”和“符号微分”的长处，既对于已知函数直接采用数值微分法求取微分，并作为中间结果保存；对于组合函数采用符号微分法将公示展开，并将上一步数值微分的中间结果代入，二者结合降低了求解和计算的复杂度。
举个栗子，对于下列函数求解微分：
将上述公式转换为计算图：计算图
上图中每个圈圈表示操作产生中间结果，下标顺序表示他们的计算顺序。根据计算图我们一步步来计算函数的值，如下表所示，其中左侧表示数值计算过的过程，右侧表示梯度计算过程：梯度求解过程(Forward mod)
表中计算了函数在
这一点的函数值和 的偏导数，整个计算过程结合者上图很容易理解。最终计算出 在 处的偏导数是5.5。如果要计算 的偏导数，还需要再重新计算一遍。相信你已经发现问题了：有多少个输入参数，这种偏导数计算流程就要执行多少遍。
有没有办法优化呢？答案是肯定的。就是将微分反向计算，把上面计算图的连线反向就得到了反向计算图：计算图
反向求微分流程如下：自动微分(Reverse mode)
反向微分的好处是一次可以算出所有输入参数的偏导数，比如
在 处的偏导数分别是5.5和1.716。
Python代码实现
采用python代码实现自动微分程序。其中有三个关键类：Op表示各种具体的操作，包括操作本身的计算和梯度计算。仅仅表示计算不保存操作的输入和状态，对应上面图中的一条边。
Node用于保存计算的状态，包括计算的输入参数、结果、梯度。每一次Op操作会产生新的Node，对应上面图中的一个圈圈。
Executor表示整个执行链路，用于正向对整个公式(在TensorFlow中叫做graph)求值以及反向自动微分。
为便于演示我们采用了eager执行的模式，既每个Node的值都是立即求得的。实际TensorFlow采用的是lazy模式，既首先构建公式然后再整体求值，这么做可以方便进行剪枝等优化操作，但不方便调试。
lazy模式的执行方式为，首先对计算图进行拓扑排序，然后按照拓扑排序的顺序从前往后依次求值。代码中Executor.run()方法演示了这个过程。其实着整个程序已经不仅仅是“自动微分”的演示了，而是tf图计算流程的演示，包括前向和后向(真实的算法模型中会使用更多种类的Op、模型本身也会更加复杂，但求解流程类似)
# -* encoding:utf-8 *-
import math
class Node(object):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a32688f4c6737303b8ccac63fa141c08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eb05bab95cc0c4722d41d05dde9261e/" rel="bookmark">
			电池供电的电容麦_动圈麦克风和电容麦克风的区别在哪里？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假如您关心这个问题，那么一定是在直播或者短视频录制中遇到了选择的难题。
1、声音的区别：
动圈大多有种闷闷的感觉，电容的声音要好一些，清脆、透亮。
2、电压的不同：
电容麦需要48V幻想供电，而动圈就不需要，别小看这一点区别。电容麦如果没有这个独立供电是没有声音的。
3、声音的灵敏度：
动圈的灵敏度差，电容麦的灵敏度好，所以这也是为什么电容麦基本不会出现在户外的应用场景（合唱除外），动圈都是应用在户外，比如歌手演唱、颁奖典礼。
4、声音的还原度：
电容麦是非常接近原声的，动圈麦就要稍微差一些。
5、价格的不同：
动圈麦基本价格都不会太贵，1000元上下品质就不错了，比如舒尔的。而电容麦能用的话价格在1500元了，比如797的M5。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9551801d94a140356eaf15834c06cd0d/" rel="bookmark">
			短视频搬运二次剪辑伪原创教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体操作从８个点来进行进：
1、 重构画面信息
进行裁剪，移位，放大缩小等动作，来优化修改整个画面信息。
去头、去尾、去上下，视频头尾的水印，视频上下，尽量把视频尺寸都变化一下！
把视频添加成画中画，拆解视频，哪些是我们要的，哪些不是我们要的，要拆开；
剪辑视频，中间截取，比如9:16可以变成4:3再加背景变成16:9的就行；
如果视频可以镜像，那就镜像一下，画面是反转180度的；
修改视频的校正、垂直、水平的立体效果，部分苹果手机自带照片编辑就有这个功能（很好用，去重率可达60%）；
2、 更改帧的位置
对每个视频的帧进行改动，让抽帧对比的画面不同。
如果条件可以，我们可以做混剪，就是多个视频抽取一些自己想要的来剪辑；
抽帧，抽取视频上一些随机帧，抽出来把它删除；
3、 增加一些文字，挂件等信息
增加抽帧对比画面的不同处，达到重复率的降低。
视频的上下部分尽量自己设计，用自己的文字！字重新打；
4、 修改色彩等信息
抽帧对比时，色彩替换会降低重复率。
剪映找到调节：亮度、对比度、饱和度、锐化、高光、阴影、色温、色调、褪色自己尝试调节，尽量与原视频有区别且不影响视觉效果；
5、 BGM移位或者替换等
这点不是很重要，有人声的时候，没办法处理，但是可以进行声音移位。
关闭视频原声音，然后再提取声音加上！背景音乐可以抖音上下载来提取；
6、 参数的适当修改
可以对视频分辨率，帧率，比特率进行微调。增加原创度。如果深度编辑足够的话，可以不用过多修改。增加滤镜看看是不是影响视觉，不影响就加上滤镜；
7、修改视频的MD5，如果修改后画质差，那就不修改；加特效、不影响视觉效果的前提下增加特效，可以规避很大问题；生成字幕，剪映自带文本朗读，也可以读取视频里识别字幕。
8、推荐一款去水印微信小程序，修改视频ＭＤ５去水印小程序，去水印绿色版
随着平台的更新，短视频伪原创的操作也需改进。很多人已经通过这个操作，蹭热门拉高播放，获取粉丝。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7c531b2c24555950a085384bca8f62b/" rel="bookmark">
			JS 类数组转数组的几种方法（四种）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结 for 循环[].slice.call() （calll方法：[].map.call()）ES6语法：Array.from()ES6语法：展开运算符 原生 js 获取 DOM 元素集合是一个类数组对象，所以不能直接利用数组对象（比如：sort、forEach），需要转换为数组后，才可以使用
下述方法使用 arguments 当伪数组
function fn() { var res = toArr(arguments); console.log(res); } fn("A", 3, 5); // 返回 [ 'A', 3, 5 ] 1.for 循环 function toArr(cArr) { var arr = []; for (var i = 0; i &lt; cArr.length; i++) { arr.push(cArr[i]); } return arr; } 2.[].slice.call() call() 方法 function toArr(cArr) { return [].slice.call(cArr); } arr.slice(start, end) ：提取索引 start 复制到索引 end 的部分（不包括 endArray.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7c531b2c24555950a085384bca8f62b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6849636737b4e6fd9ecce4ef070286bb/" rel="bookmark">
			python中escape_Python语言 escape 的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要向大家介绍了Python语言 escape 的使用，通过具体的内容向大家展示，希望对大家学习Python语言有所帮助。
在使用python的过程中，你肯定对转义字符的使用苦恼过，因为有的时候我们需要使用一些特殊符号如”$ * . ^”等的原意，有时候需要被转义后的功能，并且转义字符地使用很繁琐，容易出错，那拯救你的就非re.escape莫属了。
escape(pattern)
Escape all non-alphanumeric characters in pattern.
定义：
re.escape(pattern) 可以对字符串中所有可能被解释为正则运算符的字符进行转义的应用函数。如果字符串很长且包含很多特殊技字符，而你又不想输入一大堆反斜杠，或者字符串来自于用户(比如通过raw_input函数获取输入的内容)，且要用作正则表达式的一部分的时候，可以使用这个函数。
&gt; re.escape('www.python.org')
'www\\.python\\.org'
&gt;re.findall(re.escape('w.py'),"jw.pyji w.py.f")
['w.py', 'w.py']
本文由职坐标整理并发布，希望对同学们学习Python有所帮助，更多内容请关注职坐标编程语言Python频道！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd88aeba491c20266eec83b4287b6821/" rel="bookmark">
			在同一台机器上安装多个MySQL8.0服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要
操作系统为Windows10，当前使用MySQL版本为8.0.21。
在该机器上安装3个MySQL服务，端口分别为：3306,3307,3308。
对于3306端口，按正常流程安装即可，不再赘述。
对于3307/3308端口，流程相同。
3307/3308端口服务安装
以3307端口为例。
准备文件
将3306端口的MySQL安装文件夹复制一份（或直接解压官网下载的压缩文件），改名，路径为：D:\Program Files\mysql_3307。
清理
删除D:\Program Files\mysql_3307\data\文件夹中的所有内容。
修改配置文件
打开mysql_3307文件夹下的my.ini，做如下修改：
port更改为3307。
basedir更改为D:\Program Files\mysql_3307。
示例：
[client] # 设置mysql客户端连接服务端时默认使用的端口 port=3307 default-character-set=utf8mb4 [mysql] # 设置mysql客户端默认字符集 default-character-set=utf8mb4 [mysqld] # 设置端口 port=3307 # 设置mysql的安装目录 basedir=D:\Program Files\mysql_3307 # 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错 # datadir=D:\data # 允许最大连接数 max_connections=200 # 允许连接失败的次数。 max_connect_errors=10 # 服务端使用的字符集默认为utf8mb4 character-set-server=utf8mb4 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB # 默认使用“mysql_native_password”插件认证 #mysql_native_password default_authentication_plugin=mysql_native_password 安装
以管理员身份打开cmd，cd到D:\Program Files\mysql_3307\bin\目录下。
1、执行命令初始化数据库：
mysqld --initialize --console 可以不指定–defaults-file参数。
等待执行完成，会输出root用户的默认初始密码。
2. 输入命令安装服务：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd88aeba491c20266eec83b4287b6821/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3732209c3b4df885defba8a134e5b2da/" rel="bookmark">
			postman使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		postman基础功能介绍
首先，看一下它的基础功能：
collection在postman里面相当于一个文件夹，可以把同一个项目的请求放在一个Collection里方便管理和分享，Collection里面也可以再建文件夹。这里我们做一个普通接口的简单的示例：
该请求是聚合数据提供的一个查询天气的接口，大概还有几百次的次数可以用：
http://v.juhe.cn/weather/index?format=2&amp;cityname=南京&amp;key=64aa04d276d1ed4fd5a147d97e16b87e
点击send，查询成功
这样就完成了一次简单的天气查询接口的请求
请求区域介绍
1 Authorization：身份验证，主要用来填写用户名密码，以及一些验签字段,postman有一个helpers可以帮助我们简化一些重复和复杂的任务。当前的一套helpers可以帮助你解决一些authentication protocols的问题。；
2 Headers：请求的头部信息
3 Body：post请求时必须要带的参数，里面放一些key-value键值对
4 Pre-requerst Script:可以让你在 请求之前自定义请求数据，这个运行在请求之前，语法使用JavaScript语句。
5 tests：tests标签功能比较强大，通常用来写测试，它是运行在请求之后。支持JavaScript语法。postman每次执行request的时候，会执行tests。测试结果会在tests的tab上面显示一个通过的数量以及对错情况。这个后面会进行详解，它也可以用来设计用例，比如要测试返回结果是否含有某一字符串
6 form-data：,它将表单数据处理为一条消息，以标签为单元，用分隔符分开。既可以单独上传键值对，也可以直接上传文件（当上传字段是文件时，会有Content-Type来说明文件类型,但该文件不会作为历史保存，只能在每次需要发送请求的时候，重新添加文件。）；post请求里较常用的一种
7 x-www-form-urlencoded：对应信息头-application/x-www-from-urlencoded，会将表单内的数据转换为键值对；
8 raw：可以上传任意类型的文本，比如text、json、xml等,所有填写的text都会随着请求发送；
9 binary：对应信息头-Content-Type:application/octet-stream，只能上传二进制文件，且没有键值对，一次只能上传一个文件, 也不能保存历史，每次选择文件，提交；
导出和导入接口集：
postman支持非常方便的导入和导出接口集，继续操作如下：
导出
ok，这样就是简单的导入导出collection集合
关于设置环境变量：
Global—全局
Enviroment — 环境变量
Local — 局部
Data ---- 数据
优先级从高到底 Data ---- &gt; Local ---- &gt; Enviroment ---- &gt; Global
postman支持很方便的设置环境变量以及全局变量，并可以一键切换不同环境
1：可以一键切换环境，选择No Environment则不使用环境变量，仅适用全局变量
2：可以查看当前环境中的变量和全局变量（Globals）的值
3.进入设置页面
如新建一套环境dome
选择我们刚才创建的环境，点击眼睛可以看到我们设置的变量值
创建环境变量能够很方便的调取我们所需的数据
将返回值的某个数据设置为环境变量
在某些时候，我们需要获取到一个变量，并保存下来，因为在后面我们会使用到。比如token，sign等信息
这时候就需要用到tests区域了，使用其强大的js语法
下面是一个简单的将返回值的某个数据设置为环境变量或者全局变量的介绍：
定义一个xxx，获取body中返回的所有参数,并转化为JSON格式 var xxx = JSON.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3732209c3b4df885defba8a134e5b2da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56eb7b974cbc557f182933a6d252e48f/" rel="bookmark">
			Sophos防火墙v18版本访问内部服务器或者电脑SNAT地址转换的问题解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 内部电脑互相访问经给防火墙，但是防火墙把源地址给转换成了接口地址，因为有需求，看不到真实的地址，需要对策略进行调整。
现有防火墙策略 新建的NAT规则，原始源是两台内网主机和服务器，SNAT是MASQ是出接口地址。
接口匹配条件，入站接口-任意，出战接口-任意。
通过tcpdump在服务器端抓包测试 在pc端ping服务器地址，然后在服务器端抓包测试看源地址。
pc机的地址是192.168.5.50
但是通过服务器端抓包显示，过来的源地址是192.168.4.1,把pc的地址转换为了防火墙的接口地址。
解决问题配置 为了让服务器端看到真实的pc机地址，需要对策略进行调整。
入站接口：勾选Port3和Port4，出战接口勾选Port2.
再次测试，就发现pc机的地址是真实地址，没有做转换。
结论 正常在v17版本的防火墙中，可以不勾选重写源地址，就不会转换源地址。
但是在v18版本中，只能更改更精确的出接口才能实现这个效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5481db04aaaa5d0e8e13a265655da52b/" rel="bookmark">
			python统计循环次数_Python基础：用Python统计列表中每个单词出现的次数（split 的使用，for双重循环）...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何用Python统计含多个字符串的列表中每个单词出现的次数？
要从多个字符窜中统计次数的话，我们先来看一个简单的例子:
先从一个字符串中统计每个单词出现的次数。
如字符串：
str=“You may be out of my sight, but never out of my mind.”
为了简化逻辑，我在这里将字符串做一些处理，如下：
str=“You may be out of my sight but never out of my mind”
(将所有的标点全都换成了空格,)
1.首先：
在这里首先要向初学者介绍一个Python常用的一个方法：split()
语法：
str.split(str="", num=string.count(str)).
参数：
str -----分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等。
num -----分割次数。默认为 -1, 即分隔所有。(次数不限)
返回值：
返回分割后的字符串列表。
注意：Python 的 split() 方法通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则分隔 num+1 个子字符串
示例：
str = "Whatever is worth doing is worth doing well" #这是一个字符串
print(str.split()) # 以空格为分隔符，分割所有
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5481db04aaaa5d0e8e13a265655da52b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e1d986b5bebff99b55e12f662c7ea8b/" rel="bookmark">
			PowerDesigner概念介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PowerDesigner简介
PowerDesigner是Sybase公司的CASE工具集，使用它可以方便地对管理信息系统进行分析设计，它几乎包括了数据库模型设计的全过程。利用PowerDesigner可以制作数据流程图、概念数据模型、物理数据模型，可以生成多种客户端开发工具的应用程序，还可为数据仓库制作结构模型，也能对团队设计模型进行控制。它可与许多流行的数据库设计软件，例如：PowerBuilder，Delphi，VB等相配合使用来缩短开发时间和使系统设计更优化。
PowerDesigner主要包括以下几个功能部分：
（1） DataArchitect
这是一个强大的数据库设计工具，使用DataArchitect可利用实体-关系图为一个信息系统创建"概念数据模型"－CDM（Conceptual Data Model）。并且可根据CDM产生基于某一特定数据库管理系统（例如：Sybase System 11）的"物理数据模型"-PDM(Physical Data Model)。还可优化PDM，产生为特定DBMS创建数据库的SQL语句并可以文件形式存储以便在其他时刻运行这些SQL语句创建数据库。另外，DataArchitect还可根据已存在的数据库反向生成PDM，CDM及创建数据库的SQL脚本。
（2） ProcessAnalyst
这部分用于创建功能模型和数据流图，创建"处理层次关系"。
（3） AppModeler
为客户/服务器应用程序创建应用模型。
（4） ODBC Administrator
此部分用来管理系统的各种数据源。
PowerDesigner的4种模型文件：
概念数据模型 (CDM)
CDM 表现数据库的全部逻辑的结构,与任何的软件或数据储藏结构无关。 一个概念模型经常包括在物理数据库中仍然不实现的数据对象。
它给运行计划或业务活动的数据一个正式表现方式。
物理数据模型 (PDM)
PDM 叙述数据库的物理实现。
藉由 PDM ，你考虑真实的物理实现的细节。 它进入帐户两个软件或数据储藏结构之内拿。 你能修正 PDM 适合你的表现或物理约束。
面向对象模型 (OOM)
一个OOM包含一系列包，类，接口 , 和他们的关系。 这些对象一起形成所有的 ( 或部份) 一个软件系统的逻辑的设计视图的类结构。
一个OOM本质上是软件系统的一个静态的概念模型。
你使用 PowerDesigner 面向对象模型建立面向对象模型.(OOM) 你能为纯粹地对象- 导向的靠模切目的建立一个OOM, 产生Java文件或者
PowerBuilder文件，或你能使用一个来自OOM的物理数据模型(PDM)对象 , 来表示关系数据库设计分析。
业务程序模型 (BPM)
BPM 描述业务的各种不同内在任务和内在流程，而且客户如何以这些任务和流程互相影响。
BPM 是从业务合伙人的观点来看业务逻辑和规则的概念模型，使用一个图表描述
程序，流程，信息和合作协议之间的交互作用。
使用PowerDesigner环境
对象浏览器
对象浏览器可以用分层结构显示你的工作空间.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e1d986b5bebff99b55e12f662c7ea8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3093b6bd5f0eefc70205aea11d50789/" rel="bookmark">
			极简shiro入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.shiro是什么? Shiro是Apache下的一个开源项目。shiro属于轻量级框架，相对于SpringSecurity简单的多，也没有SpringSecurity那么复杂。以下是我自己学习之后的记录。
官方架构图如下：
2.主要功能 shiro主要有三大功能模块：
Subject：主体，一般指用户。SecurityManager：安全管理器，管理所有Subject，可以配合内部安全组件。(类似于SpringMVC中的DispatcherServlet)Realms：用于进行权限信息的验证，一般需要自己实现。 3.细分功能
Authentication：身份认证/登录(账号密码验证)。Authorization：授权，即角色或者权限验证。Session Manager：会话管理，用户登录后的session相关管理。Cryptography：加密，密码加密等。Web Support：Web支持，集成Web环境。Caching：缓存，用户信息、角色、权限等缓存到如redis等缓存中。Concurrency：多线程并发验证，在一个线程中开启另一个线程，可以把权限自动传播过去。Testing：测试支持；Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问。Remember Me：记住我，登录后，下次再来的话不用登录了。
（更多关于shiro是什么的文字请自行去搜索引擎找，本文主要记录springboot与shiro的集成）
首先先创建springboot项目，此处不过多描述。 上代码：
目录结构：
pom.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;com.wsl&lt;/groupId&gt; &lt;artifactId&gt;spring-shiro-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-shiro-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring.shiro.version&gt;1.6.0&lt;/spring.shiro.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- shiro --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;${spring.shiro.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!--页面模板依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3093b6bd5f0eefc70205aea11d50789/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48c1b166560ea00da758ad32193baec4/" rel="bookmark">
			Spring AOP操作解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先需要使用@EnableAspectJAutoProxy注解，即为开启注解的aop模式
此注解导入了AspectJAutoProxyRegistrar类。
传入配置类，之后注册配置类，调用了refresh方法刷新容器在registerBeanPostProcessors(beanFactory)方法中注册了后置处理器来方便拦截bean的创建过程。创建AnnotationAwareAspectJAutoProxyCreator对象。 AnnotationAwareAspectJAutoProxyCreator在每一个bean创建之前，
判断当前bean是否在advisedBeans中（保存了所有需要增强bean）
判断当前bean是否是基础类型的Advice、Pointcut、Advisor、AopInfrastructureBean，或者是否是切面（@Aspect）
判断是否需要跳过（获取候选的增强器（切面里面的通知方法【List candidateAdvisors】每一个封装的通知方法的增强器是 InstantiationModelAwarePointcutAdvisor；判断每一个增强器是否是 AspectJPointcutAdvisor 类型的；返回true
如果不是，返回false）
postProcessAfterInitialization如果需要的话，进行包装-&gt;
return wrapIfNecessary(bean, beanName, cacheKey);
如果当前bean需要增强，创建当前bean的代理对象；
1）、获取所有增强器（通知方法）
2）、保存到proxyFactory
3）、创建代理对象：Spring自动决定 JdkDynamicAopProxy(config);jdk动态代理或ObjenesisCglibAopProxy(config);cglib的动态代理；
生成代理之后给容器返回代理对象。执行目标方法的时候获取的就是代理对象。
目标方法执行的时候
CglibAopProxy.intercept();拦截目标方法的执行
根据ProxyFactory对象获取将要执行的目标方法拦截器链；
List chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);
1）、List interceptorList保存所有拦截器 5
一个默认的ExposeInvocationInterceptor 和 4个增强器；
2）、遍历所有的增强器，将其转为Interceptor；
registry.getInterceptors(advisor);
3）、将增强器转为List；
如果是MethodInterceptor，直接加入到集合中
如果不是，使用AdvisorAdapter将增强器转为MethodInterceptor；
转换完成返回MethodInterceptor数组；
如果拦截器为空，直接执行目标方法即可，如果不为空把需要执行的目标对象，目标方法，拦截器链等信息传入创建一个 CglibMethodInvocation 对象，并调用 Object retVal = mi.proceed();
链式获取每一个拦截器，拦截器执行invoke方法，每一个拦截器等待下一个拦截器执行完成返回以后再来执行；拦截器链的机制，保证通知方法与目标方法的执行顺序；
正常执行：前置通知-》目标方法-》后置通知-》返回通知
出现异常：前置通知-》目标方法-》后置通知-》异常通知
具体执行方法如图所示。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/88/">«</a>
	<span class="pagination__item pagination__item--current">89/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/90/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>