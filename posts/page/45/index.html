<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97cd8be6e8b39b873a1f37ef0be21224/" rel="bookmark">
			MindRecord数据集格式-Windows下数据集报错Invalid file, DB file can not match
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 MindRecord是MindSpore开发的一种高效数据格式，此模块提供了一些方法帮助用户将不同数据集转换为MindRecord格式， 也提供了一些操作MindRecord数据文件的方法如读取、写入、检索等。 用户可以使用FileWriter API生成MindRecord格式数据集，并使用MindDataset API加载MindRecord格式数据集。
相关的API可以参考：mindspore.mindrecord
在Windows平台上，且MindSpore版本 &lt;= 1.4.0情况下，在生成MindRecord文件并将其移动位置（如MindRecord文件生成在A目录，再搬到B目录），会出现如下错误：
=========================&gt;
=========================&gt;
由于MindSpore的版本差异，相同错误的错误信息可能不同，但一般就是这两种：
RuntimeError: Thread ID 1 Unexpected error. Fail to open ./data/coraRuntimeError: Unexpected error. Invalid file, DB file can not match file 原因分析：
MindSopore在windows下支持不完善，在MindSpore 1.4.0及之前版本，在Windows环境下生成MindRecord格式数据集文件，并且已经移动位置后，是不能被加载到MindSpore中使用的。但是新版本中已经解决了这个bug
解决办法：
Windows环境下生成的MindRecord格式文件不要移动位置。将MindSpore升级到1.5.0以及之后版本，重新生成MindRecord格式数据集。 其他错误相关帖：
华为云论坛_云计算论坛_开发者论坛_技术论坛-华为云华为云论坛_云计算论坛_开发者论坛_技术论坛-华为云Gitee 企业版 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d8d1c5fd68b23881154828a8bd2c4df/" rel="bookmark">
			带参数的main函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初学C语言时我们使用的都是不带形式参数的main()函数，但是其实C语言中的main函数可以有两个形式参数，习惯上我们把第一个形参记作argc，这是一个整型的形参 第二个形式参数记作argv，这是一个字符串数组的名字，形参名字可以由编程者自己编写第一个形式参数是第二个字符数组中字符串的个数，所以main函数的定义头部可以写成：int main(int argc,char *argv[]) 我们知道一个C语言源程序有且只有一个main()函数，它的位置可以任意，但是C语言语句的执行总是从main()函数开始到main()函数结束，C语言规定它不可以被其它函数所调用，所以给main函数传递实参不能在程序中完成，而需要在windows系统的命令行中完成，argv[]字符串数组的第一个元素是本程序的名字，在命令行中给main函数传递实参时不用给第一个参数传递实参，只用给第二个参数传递实参即可，如下是在命令行给买函数传递实参的例子
程序源代码 #include&lt;stdio.h&gt; int main(int argc,int *argv[]) { int i; for (int i = 0; i &lt; argc; i++) printf("argv[%d]=%s\n", i, argv[i]); printf("传入参数的个数为：%d\n", argc); return 0; } 在命令行中给main函数传递参数运行C语言程序 接下来我们学习如何使用命令行来运行C语言程序或者python源程序 首先是关于如何打开Windows命令行的，我们按住快捷键“windows图标+R ”进入运行窗口，在其中输入cmd 然后点击确定
如此便可以进入命令行窗口了
如图，进入命令行以后我们所看到的"C:\Users\南雁&gt;"表示此时是在这个工作目录下执行命令，如果我们此时输入命令"dir"然后按enter键，表示的是查找此工作目录下所包含的文件有那些，如：
若我们想要跳转到其它工作目录去执行操作，我们需要输入“cd +空格+要跳转到的文件路径"，如：
此时命令行就跳转到了”C:\Users\南雁\source\repos\C语言深入学习\C语言深入学习”这个文件夹下执行命令，输人dir查询这个文件夹中所包含的文件，如：
若要跳转到D盘直接输入命令"D:"即可
若要在命令行中运行python源代码只需执行命令"python+所要执行的程序的绝对路径”即可，如果要执行的程序就在命令行执行命令所在的文件夹中那么只需写出文件的名字即可而不用写出其绝对路径，如：
程序源代码
print("人生苦短，我用pyhton") print("欢迎来到python的世界") exit(1) #用了该函数之后，程序到这儿就会停止运行，所以该函数的作用是使程序提前结束 print("如下是一个测试的例子") print("用了该函数之后程序还能执行到这儿吗") 程序在命令行中的运行结果
若要直接在命令行中编写和运行python源程序，只需输入命令"python"然后按下enter键，此时就会会出现python的版本信息，然后就可以编写和运行python源程序了。如：
在学习在命令行中运行C语言源程序之前我们需要了解先了解gcc因为在命令行中运行C语言源程序就是通过gcc命令来完成的，我们知道C语言程序的执行方式是 编译执行，而python是解释执行，所以要运行C语言源程序需要用到编译器，而gcc就是一款编译器，gcc 全称 GNU Compiler Collection 是由GNU开发的编程语言的编译器所以说 gcc就是C语言的翻译器，想要详细了解gcc可以看一下下面这篇文章
http://t.csdn.cn/jBenf
所以如果想要在命令行中执行C语言源程序，我们可以用记事本编写C语言源程序，保存到桌面，然后再进入到桌面这个工作目录下（使用cd命令改变命令行工作目录)，注意文件名以.c作为后缀然后输入语句："gcc 文件名.c -o 文件名"按下enter键，文件名就是你刚刚创建的C语言源程序文件如：
此时接着输入生成的可执行文件的名字就可以运行该程序了，如：
此时就会执行里面的代码，我上面运行的程序源代码如下：
#include&lt;stdio.h&gt; int main() { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d8d1c5fd68b23881154828a8bd2c4df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16cb70434b33400664cc57c0297b75d3/" rel="bookmark">
			【转发】Win系统下如何在某个特定的文件夹内输出所有文件路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行命令：dir /S/B &gt;list.txt
在文件夹导航处，输入cmd然后回车，执行命令：dir /S/B &gt;list.txt
执行命令
便有一个list.txt文件生成，里面便是文件的完整路径
新生成的文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dad2b4f9cb1b524806f32bbe74808dc/" rel="bookmark">
			Linux基础命令-chmod修改文件权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux基础命令-chown修改文件属主
文章目录
前言
一、文件权限有哪些
1.1 文件的普通权限
1.1.1 普通权限案例：
1.2 文件的特殊权限
1.2.1 案例一：特殊权限SUID
1.2.2 案例二：特殊权限SGID
1.2.3 案例三：特殊权限Stickybit
二、chmod命令介绍
三、命令的语法及参数 3.1 先用help或man查看文件语法格式
3.2 常用参数
四、参考实例
4.1 设定文件的权限为775
4.2 设定文件可以让任何人读取
4.3 设定目录及子文件的所有者可以读执行，其他无权限
4.4 让用户临时拥有重启系统的权限
4.5 设定文件无法执行
总结
前言 这个命令是管理linux权限中最重要的一个命令，主要是给文件修改读写执行的权限，学好这个命令就能很好的管理文件的权限，下面先了解什么是文件的权限。
一、文件权限有哪些 在linux系统中，每个文件都有归属的所有者和所有组，并且规定了文件的所有者、以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。对于一般文件来说，权限比较容易理解：“可读”表示能够读取文件的实际内容；“可写”表示能够编辑、新增、修改、删除文件的实际内容；“可执行”则表示能够运行一个脚本程序。。对于目录文件来说，“可读”表示能够读取目录内的文件列表；“可写”表示能够在目录内新增、删除、重命名文件；而“可执行”则表示能够进入该目录。
1.1 文件的普通权限 用ll展开文件的详细信息
左边这一框内显示的就是文件的权限；
第一个字符信息就是文件的类型，这个文件类型有（d）目录文件、（-）普通文件、（p）管道文件、（c）字符设备文件、（b）块设备文件、（l）链接文件等等。
文件的普通权限有r（read 读 ）、w（write 写）、x（execute 执行）权限。
除了第一个文件类型，一共有9个空位是用来显示文件的权限，分成三个，文件所有者（user）、所有组（group）、其他人（other）、还有一个是所有人（all），包括前面三个的意思。
在linux中，系统只认识二进制（0/1）的内容，那么读写执行是怎么转化成我们认识的权限，实际上，我们能看到的读写执行是八进制（0-7）显示的。
权限二进制八进制内容描述---0000没有任何权限--x0011只有执行权限-w-0102只有写入权限-wx0113有写入和执行权限r--1004只有读的权限rwx1117满权限，读写执行都有 1.1.1 普通权限案例： 1）文件所有者拥有读写执行权限，所有者、其他用户无权限
[root@localhost ~]# chmod 700 anaconda-ks.cfg 2）目录拥有满权限
[root@localhost ~]# chmod -R a=rwx test/ [root@localhost ~]# chmod -R 777 test/ 3) 给脚本文件加执行权限
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dad2b4f9cb1b524806f32bbe74808dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/898505b20afb4c8f3f0451bb0241c269/" rel="bookmark">
			idea控制台拖出来了，怎么恢复，解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 idea控制台拖出来了如何恢复成原样
解决方案： 方法一
方法二
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d67fe02fa380df69ce557cc81b4a7909/" rel="bookmark">
			Java 删除文件和文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、删除文件夹及其子文件 /** * 【删除文件夹】 * &lt;p&gt; * 删除文件夹及其子文件 */ public class DelFilesOrFolders { public static void main(String args[]) { String folderPath = "/Users/mac/Desktop/var/"; delFolder(folderPath); } /** * 删除文件夹 * * @param folderPath 文件夹完整绝对路径 */ public static void delFolder(String folderPath) { try { delAllFile(folderPath); //删除里面的所有内容 File myFilePath = new File(folderPath); myFilePath.delete(); //删除空文件夹 } catch (Exception e) { e.printStackTrace(); } } /** * 删除指定文件夹下所有文件 * * @param folderPath 文件夹完整绝对路径 */ public static void delAllFile(String folderPath) { File file = new File(folderPath); if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d67fe02fa380df69ce557cc81b4a7909/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37dcec0809b41f4fc4bc8bdd00a3350f/" rel="bookmark">
			SpringBoot@Autowired自动装配失败解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 今天写SpringBoot项目的时候，使用@Autowired注解idea报错了，那就记录一下怎么解决的吧。
报错： @Autowired报错：无法自动装配，找不到该类型的Bean。 原因：idea有检测的功能，接口是不能够直接创建Bean的，实际上项目运行时SpringBoot底层使用了动态代理创建了这个Bean。 解决方法： 打开idea的setting（设置）然后搜索inspection（检查）
然后找到Spring下的Spring Core的Code（代码）找到Autowired for bean class（ Spring bean 注入点的自动装配问题），然后改成warning就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/240b6058a4e0a3d5d522790a1f0ab65c/" rel="bookmark">
			Git管理工具常用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		适用场景：
通常我们到了新公司或者新的部门，一般会给你一个git的源码路径，如：http://ip:port/xxxx/xxx.git。这个时候我们需要拉取代码开发，则需要用到一些常用的工具！这里分享一下个人的经验。
准备环境：
1、下载两个工具（Git-2.16.2-64-bit.exe和TortoiseGit-1.8.14.0_64bit.1436148947），前者为本地运行的git环境，后者为相关的可视化操作工具，可根据自己的机器下载选择合适的版本进行安装。
2、一般正常安装后，会生成如下的环境变量，如果安装后不可使用，可以检查下环境变量是否存在
常规操作：
一般我们在完成安装后会在系统右键中生成r如下的几个选项！代表安装git和tortoiseGit安装成功。
1、拉取代码
创建合适的文件夹路径，右键--&gt;git clone，弹出对话框，输入源码的路径，勾选Branch，输入你要拉取的分支，点击确定，如下
2、更新代码
右键--&gt;git pull 弹出框，会自动带出你的路径和分支信息，点击OK，会更新修改的代码
以上会更新新文件和git上修改的文件，但是如果本地删除的文件，想要git还原则则pull不可以，需要通过stash save进行还原同最新的git文件
3、提交代码
提交之前一定要确定自己的账号是不是拥有该git仓库的可写权限，如果只有只读权限，则一定不会提交成功。确定有可写权限后，可以先commit，选择提交文件，输入日志，提交到本地的git环境中，之后在push，推到远程的仓库中。
通常在项目中，多个人维护时候会出现代码冲突的问题，造成提交代码（push）的时候提示你更新（pull），但是你进行pull操作了，又提示你先提交（push），很烦心。所以养成好习惯就是写好的代码即使提交，每天早上都更新一次代码是有必要的，但是不要提交错误的代码，把项目搞奔溃了，就是你的错了
常见问题的处理
1、解决冲突的方式：（合并最新的git文件）
一般我们pull的时候，git会提示我们哪些文件冲突不能进行pull操作，我们需要找到这些文件，删除掉不需要的，如.setting等，如果是我们写的代码，则需要把自己写的代码备份出来，在删掉，之后进行revert，使得我们本地的代码就是最新的git服务器上的代码，然后在把我们自己写的代码部分合并到这些文件中
通过上诉的方式解决冲突之后，在pull成功代码之后，就可以提交我们的代码了！
2、设置指定文件文件忽略提交：
一般在.git文件的目录下会存在一个.gitignore文件，这个文件可以配置指定忽略的文件，如target和.iml等
设置规则如下 *代表一个目录，**代表存在多个目录，如下就是忽略了所有target下的文件，下一个目录的.idea文件夹和指定.iml结尾的文件和.gitignore文件
注意如果是文件下需要用//进行前后包裹
3、没有权限的push会报错如下，需要找人开通权限。一般工具提示的forbidden就是没有权限的意思。
4、git做了eslint校验语法，报错不允许提交代码
删除文件：项目\.git\hooks\pre-commit
6、查看本地git的用户名，密码，邮箱，和修改方法
查看:
git config user.name //获取当前登录的用户
git config user.email //获取当前登录用户的邮箱
git config user.password //获取当前登录的密码
修改:
git config --global user.name 'userName' // 修改登陆账号，userName为你的git账号
git config --global user.email 'email' // 修改登陆邮箱，email为你的git邮箱
git config --global user.password 'password' // 修改登陆密码，password为你的git密码
7、查看代码的git地址及分支
右键--setting--remote查看
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/240b6058a4e0a3d5d522790a1f0ab65c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0340d4e5cfe6aef69a901c8cb24eb1bf/" rel="bookmark">
			wpf mvvm框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WPF(Windows Presentation Foundation)是微软推出的一种用于构建 Windows 应用程序的 UI 框架。MVVM(Model-View-ViewModel)是一种设计模式，它将视图(View)和模型(Model)分离开来，并通过视图模型(ViewModel)来连接它们。
在 WPF 中使用 MVVM 框架可以使应用程序的设计更加清晰，并且可以更容易地实现界面和业务逻辑的分离。它还提供了强大的数据绑定功能，可以使视图和视图模型之间的数据双向绑定，使得界面更新更加方便。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ad8a60fd41f1ccb3e997fbcbc5ed694/" rel="bookmark">
			【计组】理解Disruptor--《计算机组成原理》（十五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Disruptor 的开发语言，并不是很多人心目中最容易做到性能极限的 C/C++，而是性能受限于 JVM 的 Java。其实只要通晓硬件层面的原理，即使是像 Java 这样的高级语言，也能够把 CPU 的性能发挥到极限。
一、Padding Cache Line，体验高速缓存的威力 Disruptor 里面一段神奇的代码。这段代码里，Disruptor 在 RingBufferPad 这个类里面定义了 p1，p2 一直到 p7 这样 7 个 long 类型的变量。这些变量没有实际意义，只是帮助我们进行缓存行填充（Padding Cache Line），使得我们能够尽可能地用上 CPU 高速缓存（CPU Cache）。
abstract class RingBufferPad { protected long p1, p2, p3, p4, p5, p6, p7; } CPU Cache 装载内存里面的数据，不是一个一个字段加载的，而是加载一整个缓存行。举个例子，如果我们定义了一个长度为 64 的 long 类型的数组。那么数据从内存加载到 CPU Cache 里面的时候，会一次性加载固定长度的一个缓存行。
我们现在的 64 位 Intel CPU 的计算机，缓存行通常是 64 个字节（Bytes）。一个 long 类型的数据需要 8 个字节，所以一下子会加载 8 个 long 类型的数据。也就是说，一次加载数组里面连续的 8 个数值。这样的加载方式可以加快遍历数组元素时的速度。因为后面连续 7 次的数据访问都会命中缓存，不需要重新从内存里面去读取数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ad8a60fd41f1ccb3e997fbcbc5ed694/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ce7fea9ffe584be48cd008fcc140291/" rel="bookmark">
			Vue教程03-Vue脚手架开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue脚手架开发环境 1.Vue开发环境的安装1.1安装Node JS1.2全局安装Vue脚手架1.3安装HBuilderX1.4强烈推荐安装以下工具软件 2.HBuilderX创建Vue项目3.用脚手架工具新建Vue项目4.Vue项目的目录结构5.Vue项目的主要文件6.运行Vue项目7. 前端项目开发工程化 1.Vue开发环境的安装 需要的安装文件在钉钉群文件的《工具及安装》文件夹下自行下载
1.1安装Node JS 因为Vue是通过 npm（NodeJS包管理工具）安装的，所以先要安装NodeJS。
官网下载地址 https://nodejs.org/zh-cn/。
选择多数用户使用的长期维护版下载即可。
本课程用的版本是12.16.1，建议同学们选用该版本号。
NodeJs安装后，建议继续进行以下配置及安装
配置淘宝镜像
npm是NodeJS自带包管理工具。使用npm 时，如果速度慢的话，建议配置淘宝镜像 npm config set registry http://registry.npm.taobao.org //配置淘宝镜像 全局安装cnpm npm i cnpm@6.1.0 -g //安装cnpm 注意是全局安装 -g 版本要和nodejs、相适应，我的npm版本是6.13.4，nodejs版本是12.16.1。可以通过 node -v npm -v 查看其版本号。
cnpm的使用和npm是一样的，国内使用运行会更快些。
全局安装yarn
Yarn是Facebook新推出一个快速安全可信赖的可以替代npm的依赖管理工具。可以通过npm全局安装 npm install yarn -g yarn的使用和npm是类似的，使用会更快些。
1.2全局安装Vue脚手架 打开命令行终端，执行全局安装命令
npm i -g @vue/cli 安装成功后可以通过以下命令查看Vue脚手架的版本号
vue -V 注意：Vue脚手架的版本 和 Vue的版本完全是两码事。
1.3安装HBuilderX 官网下载地址 https://www.dcloud.io/hbuilderx.html
选择Window | APP开发版下载即可。
1.4强烈推荐安装以下工具软件 安装谷歌Chrome浏览器
安装vue-devtools
安装git工具（推荐Git-2.34.1-64-bit）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ce7fea9ffe584be48cd008fcc140291/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/913412730a5cbabaaa96c0a1184473c6/" rel="bookmark">
			因 子 分 析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 模型简介
2 因子分析与主成分分析的对比
3 原理
3.1 原理
3.2 假设
3.3 因子模型的性质
3.4 因子载荷矩阵的统计意义
4 具体操作
4.1 参数估计
4.2 因子旋转
4.2.1 理论
4.2.2 方法
4.3 因子得分
5 SPSS操作步骤
5.1 第一次运行
5.2 第二次运行
5.3 结果分析
5.3.1 共性方差
5.3.2 总方差解释表
5.3.3 成分矩阵
5.3.4 旋转后的因子载荷散点（组件）图
5.3.4 因子得分
1 模型简介 2 因子分析与主成分分析的对比 例子：
要对原来的数据进行降维，十项得分被降维成四个方面，十五个方面降维成五个因子
3 原理 3.1 原理 3.2 假设 要进行因子分析，那就必须要解出来A这个矩阵，因此我们进行一些假设用来计算A矩阵
3.3 因子模型的性质 既然因子载荷不唯一，我们在实际应用时就可以用这点进行变换（因子旋转），使得新的因子具有更容易解释的意义，这就是为什么因子分析往往比主成分分析更容易解释。
3.4 因子载荷矩阵的统计意义 那么aij究竟是什么东西？
4 具体操作 4.1 参数估计 SPSS提供的七种方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/913412730a5cbabaaa96c0a1184473c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ab9922e838987ce070c1340bf67a902/" rel="bookmark">
			sqlserver去除空格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在 SQL Server 中可以使用函数 RTRIM 和 LTRIM 来去除字符串两端的空格，也可以使用函数 REPLACE 来替换字符串中的空格。
例如：
SELECT RTRIM(LTRIM(' abc ')) 结果为：
abc 另外，也可以使用函数 REPLACE：
SELECT REPLACE(' abc ', ' ', '') 结果为：
abc 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d9a97af09711138496edc61e8908c78/" rel="bookmark">
			OpenCV中的Mat类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Mat类 在OpenCV中，Mat类是用来存放图像的基本类，它是用来保存图像矩阵类型的数据信息，包括向量、矩阵、灰度或彩色图像等数据。
Mat类主要包含有两部分（并不是两个）数据：一部分是矩阵头（matrix header），这部分的大小是固定的，包含矩阵的大小，存储的方式，矩阵存储的地址和引用次数等；另一个部分是一个指向像素矩阵的指针（指针变量）（data）。
在绝大多数情况下矩阵头的大小远小于像素矩阵中数据量的大小，小了好多个数量级，因此图像复制和传递过程中主要的开销是存放矩阵数据。为了解决这个问题，在OpenCV中复制和传递图像时，只是复制了矩阵头和指向存储数据的指针，因此在创建Mat类时可以先创建矩阵头后赋值数据。
总之，是把Mat类中的成员数据分成了两部分：矩阵头和指向像素矩阵的指针变量。很多时候为便于理解，干脆直接把Mat类的对象理解成矩阵头，也即指向像素矩阵的指针在矩阵头中（一句话，Mat类的实例化对象就是矩阵头，矩阵头中包含：矩阵的大小、存储的方式、矩阵存储的地址和引用次数等、指向像素矩阵的指针），看了很多博客，感觉这样是最好理解的，很多时候不必死磕概念，或许概念本身界定都不太清晰！这样理解，矩阵头就是Mat类的实例化对象，看了Mat类定义的源码发现，指向像素矩阵的指针就存在于Mat类中，也即存在于矩阵头中。如图：
Mat类的关键部分定义（以opencv 4.1.0为例，opencv文件夹 -&gt; bulid文件夹 -&gt; include文件夹 -&gt; opencv2文件夹 -&gt; core文件夹 -&gt; mat.hpp中788行），指向像素矩阵的指针（uchar* data）大概在2085行
class CV_EXPORTS Mat { public: // 一系列函数 ... /* flag 参数中包含许多关于矩阵的信息，如： -Mat 的标识 -数据是否连续 -深度 -通道数目 */ int flags; // 矩阵的维数，取值应该大于或等于 2 int dims; // 矩阵的行数和列数，如果矩阵超过 2 维，这两个变量的值都为-1 int rows, cols; // 指向数据的指针:大概在2085行 uchar* data; // 指向引用计数的指针 // 如果数据是由用户分配的，则为 NULL int* refcount; // 其他成员变量和成员函数 ... } 下面我们通过读取一张本地图片返回一个Mat结构:
cv::Mat a; //仅创建了矩阵头a a = cv::imread("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d9a97af09711138496edc61e8908c78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89c810e3056089268883c0f7b29930b1/" rel="bookmark">
			WPF中实现图像的缩放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XAML:
&lt;Window xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" x:Class="MapTest.Window1" x:Name="Window" Title="Window1" Width="1950" Height="1546" xmlns:d="http://schemas.microsoft.com/expression/blend/2008" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:Controls="clr-namespace:WPFExtensions.Controls;assembly=WPFExtensions" mc:Ignorable="d" Background="#FF000000"&gt; &lt;Grid x:Name="LayoutRoot"&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height="52.92"/&gt; &lt;RowDefinition Height="*"/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Border Grid.Row="1" Name="border"&gt; &lt;Image Name="image" Source="map3-2.png" Opacity="1" RenderTransformOrigin="0.5,0.5" /&gt; &lt;/Border&gt; &lt;/Grid&gt; 代码
using System.Linq; using System.Windows; using System.Windows.Input; using System.Windows.Media; namespace MapTest { public partial class Window1 : Window { private Point origin; private Point start; public Window1() { InitializeComponent(); TransformGroup group = new TransformGroup(); ScaleTransform xform = new ScaleTransform(); group.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89c810e3056089268883c0f7b29930b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdd41c94d78eb1299f375c5482a10cec/" rel="bookmark">
			学会Python之后可以从事哪些工作？有哪些岗位可以选择？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习Python可以做什么工作？Python相关岗位：数据分析师、Web开发、量化交易分析、游戏开发者、自动化测试、网站后端程序员、人工智能、网络安全等。Python语言非常受欢迎，随着互联网的快速发展，很多不是计算机专业的人都在学习Python。
Python目前保持火热程度，很多同学进行培训Python进入这一行业，可很多还是担心过多都进入Python这一行业就业上或者未来的出来在哪里，今天小编就介绍一下，学好Python能做的工作：
1、Web开发 我们离不开网络离不开Web前端，利用Python的框架可以做网站，且是一些精美的前端界面，另外需要掌握一些数据的应用。Python可以用来做网站，更快捷和高效。Django和Flask等基于Python的Web框架在web开发中非常流行。
2、网络爬虫 很多初学Python 的人都是使用它编写爬虫程序，通过Python 入门爬虫比较简单易学，不需要在一开始掌握太多太基础太底层的知识就可以很快上手很快可以做出成果，非常适合小白一开始想做出点看得见的东西的成就感。
将网络一切数据作为资源，通过自动化程序进行有针对性的数据采集以及处理。爬虫开发项目包含跨越防爬虫策略、高性能异步IO、分布式爬虫等，并针对Scrapy框架源码进行深入剖析，从而理解其原理并实现自定义爬虫框架。Python较为常用的情况就是网络爬虫，最早使用Python进行网络爬虫的是Google，而Python也因此被带动发展起来。
3、桌面程序 Python中包含很多UI库，可以很方便地完成一个GUI程序。Python实现GUI的实例也不少，如Dropbox，即Python实现的服务器端和客户端程序。
4、人工智能与机器学习 人工智能是现在大火的一个领域，让Python语言的未来充满了无限的潜力。现在非常有影响力的AI框架大多是Python的实现，Python足够动态、具有足够性能，这是AI技术所需要的技术特点。。如基于Python的深度学习库、深度学习方向、机器学习方向、自然语言处理方向的一些网站基本都是通过Python来实现的。机器学习，特别是当前热门的深度学习中的大部分工具框架都提供了Python接口，简洁清晰的语法是深受开发者喜爱的。
5、科学计算 Python 的开发效率很高，可以更高层次的抽象问题，包括scipy、numpy等用于科学计算的第三方库，所以在科学计算领域也非常热门。
6、数据分析 Python所拥有完整的生态环境，十分有利于进行数据分析处理，如“大数据”分析所需要的分布式计算、数据可视化、数据库操作等，都可通过Python中的十分成熟的模块完成。
7、服务器运维 Python在服务器运维部分也占有一席之地。目前几乎所有Linux发行版中都自带了Python解释器，使用Python脚本进行批量化的文件部署和运行调整都成了Linux服务器上不错的选择。Linux运维必须掌握Python语言，Python是一门非常NB的编程语言，满足Linux运维工程师的工作需求提升率。
8、Python自动化测试 Python语言对测试的帮助是非常大，自动化测试中Python语言的用途很广可以提升工作效率，Python太强大掌握和熟悉自动化的流程，方法和我们总使用的各个模板。
Python目前是比较热门的编程语言，物联网的到来离开Python的语言，市场相关岗位空缺比较大，各行需求也是处于供不应求，学习Python时可以选择一个自己比较喜欢的从业方向发展深入学习。
为了解决大家学习Python的困扰，快速帮助文科生构建学习Python的信心!特地收集整理了阿里/腾讯大佬的学习方法与资料，所以，你准备好学Python了吗？
如果是初学python爬虫，觉得自学比较难的，那么我接下来分享的这全套 Python 学习资料一定不要错过，希望能给那些想学习 Python 的小伙伴们带来帮助！需要的直接留言[1]或者扫码即可获取.
👉Python学习路线汇总 Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
👉Python必备开发工具👈 👉精品Python学习书籍👈 当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。
温馨提示：篇幅有限，已打包文件夹，获取方式：点击这里【 Python全套资料】 即可获取。
👉Python学习视频600合集👈 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
👉实战案例👈 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
获取方式：点击这里【 Python全套资料】 即可获取。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aca97bc470788947cde8ecbffc45e05/" rel="bookmark">
			MLX90614红外温度计介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 MLX90614红外温度计简介 MLX90614是一款红外非接触温度计。TO-39金属封装里同时集成了红外感应热电堆探测器芯片和信号处理专用集成芯片。
由于集成了低噪声放大器、17位模数转换器和强大的数字信号处理单元，使得高精度和高分辨度的温度计得以实现。温度计具备出厂校准化，有数字PWM和SMBus（系统管理总线）输出模式。
作为标准，配置为10位的PWM输出格式用于连续传送温度范围为-20…120℃的物体温度，其分辨率为0.14℃。
MLX90614集成了由迈来芯开发和生产的两款芯片：
1、红外热电堆传感器MLX81101 2、信号处理专用集成芯片MLX90302。 由于集成了低噪声放大器、17位模数转换器和强大的数字信号处理芯片MLX90302，使得高精度和高分辨度的温度计得以实现。计算所得物体温度和环境温度存储在MLX90302的RAM单元，温度分辨率为0.01℃，并可通过两线SMBus兼容协议接口 (0.02℃分辨率)或是10位 PWM (脉宽调制) 输出模式输出。 MLX90614出厂校准的温度范围为：环境温度 -40…125 ℃，物体温度 -70…382.2 ℃。 传感器测量的温度为视场里所有物体温度的平均值。MLX90614 室温下的标准精度为±0.5ºC。医疗应用版本的传感器可在人体温度范围内达到±0.1ºC 的精度。
MLX90614红外温度计特性和优点 1、体积小，成本低。 2、易集成。 3、宽温度范围内的出厂校准设置：
传感器温度范围-40…+125 ℃； 物体温度范围-70…+380 ℃。
4、Ta和To由0到+50℃温度范围内，精度可达到0.5℃。
5、(医用) 高精度校准。 6、测量辨析度可达 0.02℃。
7、单个和双重视野版本。 8、兼容SMBus数字接口。 9、客户定制的PWM连续读数输出。 10、3V和5V电源电压。 11、电源电压可从 8…16V调节。
12、节能工作模式。
13、适用于不同应用领域的多种封装方式和测量方式。
14、车用级别标准。
MLX90614红外温度计应用实例 1、高精度无接触测量。
2、用于车用空调控制系统的温度舒适度传感器。
3、用于住宅，商业和工业建筑的空调温度感应元件。
4、挡风玻璃防雾应用。 5、汽车视野死角检测。 6、工业移动元件温度控制。 7、打印机、复印机温度控制。 8、家电温度控制。 9、卫生保健。 10、家畜监控。 11、移动物体探测。
12、多区域温度控制–两线通信可支持多达100个传感器。 13、热动继电器/警报。 14、体温测量。
MLX90614红外温度计最大额定值 MLX90614红外温度计引脚定义和描述 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfc2278124abda508e69861e8d4d479d/" rel="bookmark">
			用microPython写一个ESP32的OLED的程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 好的，我可以给你提供一些有关使用 MicroPython 在 ESP32 上编写 OLED 显示屏程序的指导。
首先，你需要在 ESP32 上安装 MicroPython 固件。你可以使用 esptool 工具将 MicroPython 固件刷入 ESP32。
然后，你需要使用 pyb 库来控制 OLED 显示屏。 pyb 库提供了对 OLED 显示屏的支持，你可以使用它来初始化显示屏、在显示屏上绘图、显示文本等。
下面是一个简单的示例代码，它使用 pyb 库在 OLED 显示屏上显示 "Hello, World!"：
import pyb # 初始化 OLED 显示屏 ol 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/327a80e8dc4635d11f79644075541669/" rel="bookmark">
			psycopg2连接PostgreSQL下的不同模式（SCHEMA）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在PostgreSQL下有很多个不同模式（SCHEMA），psycopg2连接指定默认public的模式。
在正常的情况下，连接PostgreSQL不会爆错，但是在使用sql对数据库进行操作时，会爆出以下错误信息：
current transaction is aborted, commands ignored until end of transaction block 解决方案：
psycopg2.connect(dbname=PostgreSQL的数据库名, user=用户名, password=密码, host=IP地址, port=端口, options="-c search_path=other_schema,public") 注意：
dbname=PostgreSQL的数据库名，并不是模式options=“-c search_path=other_schema,public”)，other_schema是你想要的那个模式 sql示例：
注意：
列名的获取表名“table”还是table 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3093599ee2ae7748e1997a6f31a4f49e/" rel="bookmark">
			C语言 switch语句详细讲解 简单计算器及PTA例题季节判断，今天星期几-1（switch语句实现）， 数据按需处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，switch语句 1，使用格式 2，注意事项 (1)当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 break 语句为止。
(2)不是每一个 case 都需要包含 break。如果 case 语句不包含 break，控制流将会 继续 后续的 case，直到遇到 break 为止。
(3)上面所有 case 都无法判断结果时，可用default代替其他所有情况。
(4)case后的表达式（的结果）必须是一个常量或字面量，不能是字符等。
(5)不管有几个case，switch后面都需要加大括号。
二，例题 接下来来看几个例题就能完全明白
1，"简单计算器" 题目：输入两个整数和一个运算符，输出结果。
输入样例：6+7 输出结果：13
代码如下： #include&lt;stdio.h&gt; int main() { int a,b; char c;//运算符用字符数据类型定义 scanf("%d%c%d",&amp;a,&amp;c,&amp;b); switch(c)//判断的是运算符类型 { case '+':printf("%d",a+b);break; //单引号将字符括起来相当于用一个整数来表达（参考之前文章里的ASCII表讲解） case '-':printf("%d",a-b);break; case '*':printf("%d",a*b);break; case '/':printf("%d",a/b);break; default:printf("error"); } return 0; } 2.季节判断 设计程序，实现季节判断，若输入 1、2、3月，则输出Spring；若输入4、5、6月，则输出Summer；若输入7、8、9月，则输出Autumn；若输入10、11、12月，则输出Winter；若输入其他月份，输出Input Error。
要求：使用switch语句实现。
输入格式: 输入一个整数表示月份。
输出格式: 根据月份输出相应的季节。
代码如下： #include&lt;stdio.h&gt; int main() { int x; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3093599ee2ae7748e1997a6f31a4f49e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/44/">«</a>
	<span class="pagination__item pagination__item--current">45/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/46/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>