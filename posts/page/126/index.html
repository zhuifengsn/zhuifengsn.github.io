<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a3c7ca20ba5025a23638057f702d5f7/" rel="bookmark">
			移植gspcav1-20071224
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		移植gspcav1-20071224 http://weijb0606.blog.163.com/blog/static/131286274201063145521107/ Kernel version :2.6.22.6
Crosstool :arm-linux-gcc-3.4.5
Board :FS2410 System :Fedora 8
Source :gspcav1-20071224、servfox-R1_1_3、spcaview-20061208 Author :http://viviwei.cublog.cn 一、移植gspcav1-20071224 gspcav1-20071224下载地址:http://www.slackware.com/~alien/slackbuilds/gspcav1/build/gspcav1-20071224.tar.gz
FS2410开发板上移植的是Linux-2.6.22.6内核，USB及CS8900A均能工作，由于linux-2.6.22.6/drivers/usb 目录下没有 media 目录，故移植步骤如下：
a) 在 linux-2.6.22.6/drivers/usb 目录下新建 media 目录，将gspcav1-20071224.tar.gz copy 到 media 下并解压。为了使media 编译进内核，需修改linux-2.6.22.6/drivers/usb 目录下的Kconfig、Makefile 文件。
[linux@weijing usb]$ pwd
/work/kernel/linux-2.6.22.6/drivers/usb
[linux@weijing usb]$ vi Kconfig
添加
source "drivers/usb/media/Kconfig"
[linux@weijing usb]$ vi Makefile
添加
obj-$(CONFIG_USB_SPCA5XX) += media/
b) 为添加 gspcav1-20071224 编译选项，在 media 下新建 Kconfig、Makefile 文件。
[linux@weijing media]$ pwd
/work/kernel/linux-2.6.22.6/drivers/usb/media
[linux@weijing media]$ vi Kconfig
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a3c7ca20ba5025a23638057f702d5f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/349aec0b2b7cb884dfee1b514015f62f/" rel="bookmark">
			u-boot在S3C2440上的移植问题及解决方法集锦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http://blog.csdn.net/liuqiqi677/article/details/6292108 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3dbc69ed862ded153ed75966d79b382/" rel="bookmark">
			U_boot 的 bootcmd 和bootargs参数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http://blog.csdn.net/ab198604/article/details/5753532 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aa16e7b89a7305492e1981fc85dde62/" rel="bookmark">
			hl7测试工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 http://gforge.hl7.org/gf/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/730fbb6df95608db37f0ad84a7e94171/" rel="bookmark">
			鼠标下面子窗口响应滚轮消息 WM_MOUSEWHEEL，而不需要焦点，也不改变焦点。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转动滚轮会导致Windows在有输入焦点的窗口（不是鼠标光标下面的窗口）产生WM_MOUSEWHEEL消息。所以当子窗口没有焦点的时候将收不到消息WM_MOUSEWHEEL。但是，当我们把鼠标移到某个子窗口的时候，并转动滚轮，应该是希望这个子窗口响应滚轮，而不管它是否有焦点。最直接的解决方法是调用SetFoucs函数把这个子窗口设为有焦点。
常规来说，滚轮是改变滚动条位置的，而单击鼠标左键才是用来改变焦点的。滚动滚轮的时候焦点改变并不是我们所希望的。
那我们要怎么又使鼠标下面的窗口响应滚轮， 而又不改变焦点呢？ 这就需要重载 PreTranslateMessage 来改变响应WM_MOUSEWHEEL消息的窗口。
下面是例程：
BOOL CXXXApp::PreTranslateMessage(MSG* pMsg) { if (pMsg-&gt;message == WM_MOUSEHWHEEL || pMsg-&gt;message == WM_MOUSEWHEEL) { POINT pos; GetCursorPos (&amp;pos); pMsg-&gt;hwnd = WindowFromPoint (pos); } return CWinAppEx::PreTranslateMessage(pMsg); } 对于没用MFC的程序来说，可以参考下面的代码 int WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) { MSG msg; while (GetMessage (&amp;msg, NULL, 0, 0)) { if (msg.message == WM_MOUSEWHEEL) { POINT pos; GetCursorPos (&amp;pos); msg.hwnd = WindowFromPoint (pos); //要在TranslateMessage 函数前面 } TranslateMessage (&amp;msg); DispatchMessage (&amp;msg); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c036c6c439f18abfe90e710f334e3f09/" rel="bookmark">
			详解 QT 皮肤 QSS编程(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QT 皮肤 QSS编程是本文要介绍的内容，借用css 的灵感，Qt也支持Qt自己的css,简称qss。同css 相似，qss的主要功能与最终目的都是能使界面的表现与界面的元素分离，即质与形的分离，就如同一个人可以在不同的时候穿上不同的衣服一样，css机制的引入，使得设计一种皮肤与界面控件分离的软件成为可能，应用程序也能像web界面那样随意地改变外观。
一、QSS语法
同css一样，他也有由一个selector与一个declaration组成，selector指定了是对哪一个控件产生效果，而declaration才是真正的产生作用的语句。如：
QPushButton { color: red } QPushButton指定了是对所有的QPushButton或是其子类控件（如用户定义的MyPushButton）产生影响，而color:red表明所有的受影响控件的前景色都为red。
除了“类名”，“对象名”，“Qt属性名”这三样东西是大小写敏感的外其他的东西都是大小写不敏感的，如color与Color代表同一属性。
如果有几个selector指定了相同的declaration,可以使用逗号（,）将各个选择器分开，如：
QPushButton, QLineEdit, QComboBox{ color: red } 他相当于：
QPushButton { color: red } QLineEdit { color: red } QComboBox{ color: red } declaration部份是一系列的（属性：值）对，使用分号（;）将各个不同的属性值对分开，使用大括号（{}）将所有declaration包含在一起。
1、一般选择器（selector）
Qt支持所有的CSS2定义的选择器，其祥细内容可以在w3c的网站上查找 http://www.w3.org/TR/CSS2/selector.html ，其中比较常用的selector类型有：
通用类型选择器：*会对所有控件有效果。
类型选择器：QPushButton匹配所有QPushButton的实例和其子类的实例。
属性选择器：QPushButton[flat=”false”]匹配所有QPushButton属性flat为false的实例，属性分为两种，静态的和动态的，静态属性可以通过Q_PROPERTY()来指定，来动态属性可以使用setProperty来指定，如：
QLineEdit *nameEdit = new QLineEdit(this); nameEdit-&gt;setProperty("mandatoryField", true); 如果在设置了qss后Qt属性改变了，需要重新设置qss来使其生效，可以使用先unset再set qss。
类选择器：.QPushButton匹配所有QPushButton的实例，但不包含其子类，这相当于：*[class~="QPushButton"] ~=的意思是测试一个QStringList类型的属性是否包含给定的QString
ID选择器：QPushButton#okButton对应Qt里面的object name设置，使用这条CSS之前要先设置对应控件的object name为okButton，如：Ok-&gt;setObjectName(tr(“okButton”));
后裔选择器：QDialog QPushButton匹配所有为QDialog后裔（包含儿子，与儿子的儿子的递归）为QPushButton的实例
子选择器：QDialog &gt; QPushButton匹配所有的QDialog直接子类QPushButton的实例，不包含儿子的儿子的递归。
2、子控件选择器
对于复杂的控件，可能会在其中包含其他子控件，如一个QComboxBox中有一个drop-down的按钮。那么现在如果要设置QComboxBox的下拉按钮的话，就可以这样访问：
QComboBox::drop-down { image: url(dropdown.png)}其标志是（::）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c036c6c439f18abfe90e710f334e3f09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf0e6782794e1d5006dd6273fe7731f3/" rel="bookmark">
			关于word的随记------怎么让新建的word的作者是自己想显示的名字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新建word----》工具----》选项-----》用户信息-----》在里面将用户名改成自己想要的名字。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ced6921e133c18a2ec95519f4a65111c/" rel="bookmark">
			gcc警告选项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		warning: "/*" within comment 举例： /************************************************/ /* /* save snmp entry data /* add by Tina Lee 2003/7/11 /*************************************************/ 说明：意思是说/* */ 中间又包含了/* 修改：改成这样就好了 /************************************************ * * save snmp entry data * add by Tina Lee 2003/7/11 *************************************************/ warning: no previous prototype for 'get_char_for_sta' 举例：无 说明：函数没有声明，只有定义 修改：在相应的.h文件中添加该函数的声明。 warning: unused parameter 'mcb' 举例： int ifnMenuQuit(MCB_T *mcb) { return QUIT; } 说明：因为函数参数中的mcb,在该函数中没有被使用，所以产生warning 修改：对没使用的参数使用 para=para; int ifnMenuQuit(MCB_T *mcb) { mcb=mcb; &lt;----------添加该行 return QUIT; } warning: comparison between signed and unsigned 举例： INT4 s4UnitID = 0; INT4 s4ChipID = 0; uint32 u0 = 0; PMAP_BUNIT_ITE (s4UnitID, u0, s4ChipID) 说明：类型不一致。 修改：使用相同的类型（视具体情况而定）。 warning: unused variable `iRet' 举例： func() { int iRet=error_none; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ced6921e133c18a2ec95519f4a65111c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/065f42e37df4bd3d0f27f5750f1dd56b/" rel="bookmark">
			备份物理服务器以及vCenter Server上的配置信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		备份物理服务器以及vCenter Server上的配置信息
如果仅仅是一台物理主机或者vCenter服务器故障了，那么你可以很容易的再部署几台，但是同时，其上的配置信息也丢掉了。所以，定期的备份这些配置信息是非常必要的。通常当你备份一台主机的时候，你一般只是备份其上的虚拟机，而从来不会备份management console上的任何配置文件。然而，你需要备份的并不是management console中的配置文件，你需要的是备份对应的配置信息从而可以方便的重建一台物理服务器。
对于ESX主机，你可以使用esxcfg-info这条Service Console命令来将大量的配置信息输出到一份文本文件中。对于ESXi主机，你可以使用vicfg-cfgbackup命令(也是vShpere CLI的一部分)来将配置文件输出到文本文件中。对于ESX主机，你虽然无法使用esxcfg-info的输出来恢复对应的配置，但是至少在需要数据恢复的时候你可以知道你到底需要重新配置哪些参数。对于ESXi主机，你可以使用vicfg-cfgbackup命令来将配置信息恢复到主机上。对于vCenter服务器，则一定要备份其上用来存放这台vCenter服务器上所有配置信息的数据库。数据库中包含了很多配置信息，包括集群信息、资源池、权限信息、报警信息、性能信息以及其他更多配置信息。有了数据库备份，你就可以方便的重装vCenter服务器然后直接让其指向你之前备份好的数据库即可重新上线运行了。同时，也请确保你对vCenter服务器上的SSL认证目录进行了备份，这个目录位于vCenter服务器上的data目录下。这个目录中包含了用于认证ESX或者ESXi主机以及客户端连接的SSL认证信息。
/etc/vmware/esx.conf
这是所有ESX的配置文件，如果你有多台ESX主机，并且配置完全一样，就可以将这个配置文件复制到其他的主机。
./etc/vmware/firewall/services.xml
前面提到的esxcfg-fitewall这个命令，主要开放的服务就在这个文件中定义
./etc/nsswitch.conf
这个是ESX主机的主机名的配置文件。
转载于:https://blog.51cto.com/lysweb/683706
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91e34da2209ce4b6983938bd49d95835/" rel="bookmark">
			Worklist SCP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 var server = new DcmServer&lt;WorklistService&gt;(); public delegate DcmAssociateResult DcmAssociationCallback (WorklistService client, DcmAssociate association); public delegate IEnumerable&lt;CFindResponse&gt; DcmCFindRequest (WorklistService client, DcmDataset query); public DcmAssociationCallback OnAssociationRequest; public DcmCFindRequest OnCFindRequest; Now, to set these delagates for the WorklistServices I'm using the server's OnDicomClientCreated: server.OnDicomClientCreated += new DcmServer&lt;WorklistService&gt;.DicomClientCreatedDelegate((s, c, dst) =&gt; { FooService service = new FooService(..using some local context...); c.OnAssociationRequest = service.Associate; c.OnCFindRequest = service.Query; }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a52466fc39c37eca8b3262b227ca00b/" rel="bookmark">
			was not declared in this scop
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在写一个非常简单的程序的时候，提示：“was not declared in this scope"。然后上网找答案。在下面的几种情况下，会出现这种错误。 1.变量、函数、或者类未声明或者定义。这是最简单的情况。 2.头文件相互#include时，导致了依赖关系错误。比如，头文件形成了一个环形依赖， /***file a ****/ #ifndef FILE_A_ #define FILE_A_ #include &lt;file b&gt; #endif /****file b ***/ #ifndef FILE_B_ #define FILE_B_ #include &lt;file a&gt; #endif 如果在file b中用到了file a中的变量、函数、类，那么由于#ifndef和#define的作用，file b中的#include &lt;file a&gt;语句将失去效果。 3.我遇到的情况：我在给头文件起名字的时候不小心和某个库中的头文件重名了，而在程序中又用来了这个库的这个头文件。这样， #ifndef XXXX 和 #ifndef XXXX中的宏重名了，我自己写的头文件就失去了效果。别的文件自然找不到这个头文件中的声明，就提示 was not decleared in this scope了 今天在Ubuntu10.04下做build oms1.5的时候，报了这么一个错误： frameworks/base/tools/aidl/AST.cpp:10: error: 'fprintf' was not declared in this scope 后来发现本机的gcc g++ 是4.4版，安装4.3， 重新链接，问题解决。 apt-get install gcc-4.3 g++-4.3 进入/usr/bin cd /usr/bin 建个软连接 ln -s gcc-4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a52466fc39c37eca8b3262b227ca00b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c81757c8d0294c4021337788e2b8c695/" rel="bookmark">
			内存的静态分配和动态分配的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内存的静态分配和动态分配的区别主要是两个： 一是时间不同。静态分配发生在程序编译和连接的时候。动态分配则发生在程序调入和执行的时候。
二是空间不同。堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由函数malloc进行分配。不过栈的动态分配和堆不同，他的动态分配是由编译器进行释放，无需我们手工实现。 对于一个进程的内存空间而言，可以在逻辑上分成3个部份：代码区，静态数据区和动态数据区。动态数据区一般就是“堆栈”。“栈(stack)”和“堆(heap)”是两种不同的动态数据区，栈是一种线性结构，堆是一种链式结构。进程的每个线程都有私有的“栈”，所以每个线程虽然代码一样，但本地变量的数据都是互不干扰。一个堆栈可以通过“基地址”和“栈顶”地址来描述。全局变量和静态变量分配在静态数据区，本地变量分配在动态数据区，即堆栈中。程序通过堆栈的基地址和偏移量来访问本地变量。 一般，用static修饰的变量，全局变量位于静态数据区。函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。
所谓动态内存分配就是指在程序执行的过程中动态地分配或者回收存储空间的分配内存的方法。动态内存分配不象数组等静态内存分配方法那样需要预先分配存储空间，而是由系统根据程序的需要即时分配，且分配的大小就是程序要求的大小。 例如我们定义一个float型数组：float score[100]; 但是，在使用数组的时候，总有一个问题困扰着我们：数组应该有多大？在很多的情况下，你并不能确定要使用多大的数组，比如上例，你可能并不知道我们要定义的这个数组到底有多大，那么你就要把数组定义得足够大。这样，你的程序在运行时就申请了固定大小的你认为足够大的内存空间。即使你知道你想利用的空间大小，但是如果因为某种特殊原因空间利用的大小有增加或者减少，你又必须重新去修改程序，扩大数组的存储范围。这种分配固定大小的内存分配方法称之为静态内存分配。但是这种内存分配的方法存在比较严重的缺陷，特别是处理某些问题时：在大多数情况下会浪费大量的内存空间，在少数情况下，当你定义的数组不够大时，可能引起下标越界错误，甚至导致严重后果。 我们用动态内存分配就可以解决上面的问题. 所谓动态内存分配就是指在程序执行的过程中动态地分配或者回收存储空间的分配内存的方法。动态内存分配不象数组等静态内存分配方法那样需要预先分配存储空间，而是由系统根据程序的需要即时分配，且分配的大小就是程序要求的大小。从以上动、静态内存分配比较可以知道动态内存分配相对于景泰内存分配的特点： 1、不需要预先分配存储空间； 2、分配的空间可以根据程序的需要扩大或缩小。 要实现根据程序的需要动态分配存储空间，就必须用到malloc函数. malloc函数的原型为：void *malloc (unsigned int size) 其作用是在内存的动态存储区中分配一个长度为size的连续空间。其参数是一个无符号整形数，返回值是一个指向所分配的连续存储域的起始地址的指针。还有一点必须注意的是，当函数未能成功分配存储空间（如内存不足）就会返回一个NULL指针。 所以在调用该函数时应该检测返回值是否为NULL并执行相应的操作。 静态内存是在程序一开始运行就会分配内存，直到程序结束了，内存才被释放。 动态内存是在程序调用在程序中定义的函数时才被分配，函数调用结束了，动态内存就释放。 static int a;这是定义了一个静态的变量 int a;这是定义了一个动态的变量； 静态内存可以用于求阶层。 例如： jiechen(int i) {static int a=1; for(;a&lt;=i,a++) return a*i; } #include"stdio.h" main() {int a,i; printf("enter number:") scanf("%d",&amp;a); for(i=1;i&lt;=a;i++) printf("i!=%d\n",jiechen(i)); } 运行 输入3 结果为1！=1 2!=2 3!=3 由malloc系统函数分配的内存就是从堆上分配内存。从堆上分配的内存一定要自己释放。用free释放，不然就是术语——“内存泄露”（或是“内存漏洞”）—— Memory Leak。于是，系统的可分配内存会随malloc越来越少，直到系统崩溃。还是来看看“栈内存”和“堆内存”的差别吧。 栈内存分配 ————— char* AllocStrFromStack() { char pstr[100]; return pstr; } 堆内存分配 ————— char* AllocStrFromHeap(int len) { char *pstr; if ( len &lt;= 0 ) return NULL; return ( char* ) malloc( len ); } 对于第一个函数，那块pstr的内存在函数返回时就被系统释放了。于是所返回的char*什么也没有。而对于第二个函数，是从堆上分配内存，所以哪怕是程序退出时，也不释放，所以第二个函数的返回的内存没有问题，可以被使用。但一定要调用free释放，不然就是Memory Leak！ 在堆上分配内存很容易造成内存泄漏，这是C/C++的最大的“克星”，如果你的程序要稳定，那么就不要出现Memory Leak。所以，我还是要在这里千叮咛万嘱付，在使用malloc系统函数（包括calloc，realloc）时千万要小心。 记得有一个UNIX上的服务应用程序，大约有几百的C文件编译而成，运行测试良好，等使用时，每隔三个月系统就是down一次，搞得许多人焦头烂额，查不出问题所在。只好，每隔两个月人工手动重启系统一次。出现这种问题就是Memery Leak在做怪了，在C/C++中这种问题总是会发生，所以你一定要小心。一个Rational的检测工作——Purify，可以帮你测试你的程序有没有内存泄漏。 我保证，做过许多C/C++的工程的程序员，都会对malloc或是new有些感冒。当你什么时候在使用malloc和new时，有一种轻度的紧张和惶恐的感觉时，你就具备了这方面的修养了。 对于malloc和free的操作有以下规则： 1) 配对使用，有一个malloc，就应该有一个free。（C++中对应为new和delete） 2) 尽量在同一层上使用，不要像上面那种，malloc在函数中，而free在函数外。最好在同一调用层上使用这两个函数。 3) malloc分配的内存一定要初始化。free后的指针一定要设置为NULL。 注：虽然现在的操作系统（如：UNIX和Win2k/NT）都有进程内存跟踪机制，也就是如果你有没有释放的内存，操作系统会帮你释放。但操作系统依然不会释放你程序中所有产生了Memory Leak的内存，所以，最好还是你自己来做这个工作。（有的时候不知不觉就出现Memory Leak了，而且在几百万行的代码中找无异于海底捞针，Rational有一个工具叫Purify，可能很好的帮你检查程序中的Memory Leak） 第一个例子也讲得不清楚。所谓系统释放，应该是指系统在自己的表里把这段内存标记为可以使用，以后可以被别的程序使用，所以第一个例子会造成程序能访问到已经释放的内存空间，是越界，会造成不可预测的情况。 系统一般不会自动去清除释放空间内的数据，而是由以后的程序来覆盖。所以很多程序开头都会做MEMSET(.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c81757c8d0294c4021337788e2b8c695/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5549162d9e1b8ed4e4d9c9de2bac67a7/" rel="bookmark">
			比较器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常常遇到数组排序的问题.比如我有一个Person类,它的实例对象存储在ArrayList数组中,现在要把ArrayList数组中的Person对象按照年龄排序. 其实这种情况经常遇到. 下面给出源代码: 1:Person.java文件:------------------------------- public class Person{ String name; int age; public Person(String name,int age){ this.name = name; this.age = age; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } } 2:Mycomparator.java------------------------------- //实现Comparator接口,也就是定义排序规则,你几乎可以定义任何规则 package com.infoearth; import java.util.*; public class Mycomparator implements Comparator{ public int compare(Object o1,Object o2) { Person p1=(Person)o1; Person p2=(Person)o2; if(p1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5549162d9e1b8ed4e4d9c9de2bac67a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e32687056156b0a673acca0cd50e9406/" rel="bookmark">
			VLDR,VSTR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扩展寄存器加载和存储。
语法 VLDR{cond}{.size} Fd, [Rn{, #offset}]VSTR{cond}{.size} Fd, [Rn{, #offset}]VLDR{cond}{.size} Fd, labelVSTR{cond}{.size} Fd, label其中：
cond 是一个可选的条件代码（请参阅条件代码）。
size 是一个可选的数据大小说明符。 如果 Fd 是单精度 VFP 寄存器，则必须为 32；否则必须为 64。
Fd 是要加载或保存的扩展寄存器。 对于 NEON 指令，它必须为 D 寄存器。 对于 VFP 指令，它可以为 D 或 S 寄存器。
Rn 是存放要传送的基址的 ARM 寄存器。
offset 是一个可选的数值表达式。 在汇编时，该表达式的值必须为一个数字常数。 该值必须是 4 的倍数，并在 –1020 到 +1020 的范围内。 该值与基址相加得到用于传送的地址。
label 是一个程序相对的表达式。 有关详细信息，请参阅相对寄存器和程序相对的表达式。
label 必须位于当前指令的 ±1KB 范围之内。
用法 VLDR 指令可从内存中加载一个扩展寄存器。 VSTR 指令可将一个扩展寄存器的内容保存到内存中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e32687056156b0a673acca0cd50e9406/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef1a9f915d57b3da60b10f56870a58c6/" rel="bookmark">
			ARM的BX指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bx的语法格式BX{&lt;cond&gt;} ＜Rm＞＜cond＞为指令执行的条件码。当＜cond＞忽略时指令为无条件执行。＜Rm＞该寄存器中为跳转的目标地址。当&lt;Rm&gt;寄存器的bit[0]为0时，目标地址处的指令为ARM指令；当&lt;Rm&gt;寄存器的bit[0]为1时，目标地址处的指令为Thumb指令。看一段简单程序的片段，不用考虑省略号的内容，看框架就可以了！ EXPORT LEDTEST AREA testasm,CODE,READONLY CODE32LEDTEST 。。。。。。。。。。 。。。。。。。。。 。。。。。。。。 。。。。。。。。。 。。。。。。。。。。。ledon ............... ............... 。。。。。。。。。。。。 。。。。。。。。。。。 adr r4,delay1+1 bx r4ledoff .............. ............... ............. ............. ............. .............. AREA testasm,CODE,READONLY CODE16delay1 ............ ........... ............. ldr r1,＝ledoff bx r1 ........ ............. .............END关于delay1＋1：ARM指令是字对齐（指令的地址后两位为［1:0]=0b00），Thumb是半字对齐（指令的地址后两位为［1:0]=0bx0,x为0或1）。指令的地址的最后一位必为0。因此bx（不管往ARM还是往Thumb跳转）的跳转指令必须保证指令地址的最后一位为0，上例中bx指令能自动地将目标地址值置为r4的值和0xFFFFFFFE的与后的结果，就会使指令地址的最后一位必为0了。那么delay＋1的这个1不就被0与掉了么，就没有什么作用了？其实，在执行bx指令时，它是首先判断指令地址的后一位为0或1（这样就知道要跳转的地方是ARM还是Thumb指令。0跳转arm，1跳转thumb。），然后再PC＝r4 AND 0xFFFFFFFE。这样，当我们需要要跳转到Thumb指令处执行时，必须将指令地址的最后以为置1。而bx再跳转到ARM指令时就无需考虑这些了，就不用像上面的+1处理了。
关于字对齐和半字对齐
什么叫对齐。如果一个数据是从偶地址开始的连续存储，那么它就是半字对齐，否则就是非半字对齐；半字对齐的特征是bit0=0,其他位为任意值。字对齐的特征是bit1=0,bit0=0 其他位为任意值。如果一个数据是以能被4 整除的地址开始的连续存储，那么它就是字对齐，否则就是非字对齐。举例说明四字节对齐： 对内存进行操作时，被访问的地址必须为4的倍数。如果分配到的地址不是4的倍数时，CPU实际访问的地址还是按照字对齐的方式来操作。也就是自动屏蔽bit1和bit0. 什么是对齐，以及为什么要对齐： 现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定变量的时候经常在特定的内存地址访问，这就需要各类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。
对齐的作用和原因：
各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出，而如果存放在奇地址开始的地方，就可能会需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该int数据。显然在读取效率上下降很多。这也是空间和时间的博弈。对齐的实现 通常，写程序的时候，不需要考虑对齐问题。编译器会替我们选择适合目标平台的对齐策略。可以给编译器传递预编译指令而改变对指定数据的对齐方法。
char a char a
short b char c
char c short b
int d int d
ARM体系中对齐的使用:1.__align(num) 这个用于修改最高级别对象的字节边界。在汇编中使用LDRD或者STRD时 就要用到此命令__align(8)进行修饰限制。来保证数据对象是相应对齐。 这个修饰对象的命令最大是8个字节限制,可以让2字节的对象进行4字节 对齐,但是不能让4字节的对象2字节对齐。 __align是存储类修改,他只修饰最高级类型对象不能用于结构或者函数对象。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef1a9f915d57b3da60b10f56870a58c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4df216859181af7d9f34c897203cf7d4/" rel="bookmark">
			笔记--高级Bash脚本编程指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这本电子书在电脑里已经有段时间了,虽然平时写点shell没问题,但是感觉还是不精,就拿这本书查漏补缺吧.
注: 脚本例子大部分引用原书
就从12章开始吧
cat , tac , rev
cat test tac test rev test 123 789 321 456 456 654 789 123 987 expr
通用求值表达式: 通过给定的操作(参数必须以空格分开)连接参数, 并对参数求值. 可以使算术操作, 比较操作, 字符串操作或者是逻辑操作. expr 3 + 5 返回8 expr 5 % 3 返回2 expr 1 / 0 返回错误消息, expr: division by zero 不允许非法的算术操作. expr 5 \* 3 返回15 在算术表达式expr中使用乘法操作时, 乘法符号必须被转义. y=`expr $y + 1` 增加变量的值, 与let y=y+1和y=$(($y+1))的效果相同. 这是使用算术表达式的一个例子. z=`expr substr $string $position $length` 在位置$position上提取$length长度的子串.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4df216859181af7d9f34c897203cf7d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbc9cda08536ef8b3d4dd8503b19a1c8/" rel="bookmark">
			RTTI运行时识别类型信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 RTTI运行时识别类型信息在 JAVA中有4种形式分别为： 1):强制类型转换 House a=(House)b; 2)利用类字面常量 代表对象的类型的Class对象 例如Hose.class 3)利用JAVA关键词instanceof 来判断 语法格式为一个对象 instance 一个类的名字 4)利用Class.isInstanceof(Object t) 其本质还是属于第三种形式 该方法是如下定义的： 当该Class 表示的一个普通的类时 T是它的实例化或者是其子类，则返回True; 如果该Class表示的一个数组对象 如果T也是数组 则返回True 如果该Class 表示一个接口，则如果T也是接口的一种实现 ，则也返回true 如果classs表示一个基本类型，则直接返回false; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5821ae07f8f88c22234932095395b551/" rel="bookmark">
			u-boot在S3C2440上的移植问题及解决方法集锦（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、移植环境 主 机：VMWare6.5--Fedora 9 开发板：自制开发板 CPU：S3C2440； SDRAM：HY57V561620FTP-H； NOR flash：SST_39VF1601（2M）； NAND flash：K9F1G08U0B（128M）； 网卡芯片：DM9000EP
编译器：arm-linux-gcc-4.3.2 u-boot：u-boot-2009.08 linux kernel：linux-2.6.30 busybox：busybox-1.13.3 二、博客地址 http://blog.csdn.net/liuqiqi677 如有错误，欢迎指正。
三、参考资料 主要参考了黄刚的博客http://blogold.chinaunix.net/u3/101649/ ，他的博客写得相当不错，将嵌入式开发各个阶段的知识以边做边学的方式，辅以图片、解释，清晰地呈现给读者，能够让读者把握主线，对嵌入式开发有整体的了解。强烈推荐！！！ 四、问题及解决方法 7、Fedora9的bug，“No network connection” 我的虚拟机采用桥接的方式与Windows连接，并且在Fedora9中能够ping通Windows XP，但是右上角的网络连接图标无论是否手动激活网卡都会一直提示 "No network connection"，如图7所示，显示一把红色小叉。 图7 网络连接图标显示无连接 这个问题之前一直存在，但是没有找到解决方法，就搁置下来了。后来，我想用tftp将linux内核下载到开发板上，但是一直不能成功，我就怀疑是不是网络部分没有配置好，因此又去仔细研究了一下，终于发现问题所在！这实际上是 Fedora 9 的一个bug。（以前的版本没用过不清楚）
造成这个问题的原因是 Network Configuration 图形设置界面的默认选项值与 /etc/sysconfig/network-scripts/ifcfg-eth0 配置文件的默认值不一致。 刚装完系统的情况下：在 Network Configuration 中，编辑 Device 下的 eth0，会发现 "Controlled by NetworkManager" 是不打勾的。不打勾则值为 "no"。 而在 /etc/sysconfig/network-scripts/ifcfg-eth0 中对应上面的选项有一行：“NM_CONTROLLED = ”。 留空意味着取默认值，默认值为 "yes"。同一个选项，一边显示为 no，另一边则默认为 yes，能不出问题吗？解决方法很简单，要么就在图形界面下打勾，要么就把配置文本改成 "yes"。我比较懒，就直接在复选框上打钩了。 重启系统，如图9所示，一切恢复正常。 图8 选中Controlled by NetworkManager 图9 网络连接正常 8、开发板能够ping通主机，但tftp下载失败 我在 Fedora 9 中配置好主机的tftp服务（适合Fedora 9的rpm包我已经上传到http://download.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5821ae07f8f88c22234932095395b551/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5f69309f50ef7c1f7b8f3e908c5fde7/" rel="bookmark">
			MFC线程局部存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MFC占用系统TLS的一个槽口，将它扩展成很多个。
从程序启动说起。
// appmodul.cpp#ifndef _AFXDLLchar _afxInitAppState = (char)(AfxInitialize(FALSE, _MFC_VER), atexit(&amp;_AfxTermAppState));	// goto 10#elsechar _afxInitAppState = (char)(AfxInitialize(FALSE, _MFC_VER));#endif 上面的代码定义了一个全局变量_afxInitAppState，该全局变量初始化时调用函数AfxInitialize()，也就是它初始化了MFC的线程局部存储。
// initialize app state such that it points to this module's core state// appmodul.cppBOOL AFXAPI AfxInitialize(BOOL bDLL, DWORD dwVersion){AFX_MODULE_STATE* pModuleState = AfxGetModuleState();// ...return TRUE;} AfxInitialize函数调用AfxGetModuleState()函数。
// afxstate.cpp AFX_MODULE_STATE* AFXAPI AfxGetModuleState(){_AFX_THREAD_STATE* pState = _afxThreadState;	// ...}// afxtls_.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5f69309f50ef7c1f7b8f3e908c5fde7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/879eab7b1e226d729c4a452fdf657ab2/" rel="bookmark">
			qss
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		借用css 的灵感， Qt也支持Qt自己的css, 简称qss。同css 相似，qss的主要功能与最终目的都是能使界面的表现与界面的元素分离，即质与形的分离，就如同一个人可以在不同的时候穿上不同的衣服一样，css机制的引入，使得设计一种皮肤与界面控件分离的软件成为可能，应用程序也能像web界面那样随意地改变外观。
一、QSS语法
同css一样，他也有由一个selector与一个declaration组成，selector指定了是对哪一个控件产生效果，而declaration才是真正的产生作用的语句。如：
QPushButton { color: red }
QPushButton指定了是对所有的QPushButton或是其子类控件（如用户定义的MyPushButton）产生影响，而color:red表明所有的受影响控件的前景色都为red。
除了“类名”，“对象名”，“Qt属性名”这三样东西是大小写敏感的外其他的东西都是大小写不敏感的，如color与Color代表同一属性。
如果有几个selector指定了相同的declaration, 可以使用逗号（,）将各个选择器分开，如：
QPushButton, QLineEdit, QComboBox { color: red }
他相当于：
QPushButton { color: red }
QLineEdit { color: red }
QComboBox { color: red }
declaration部份是一系列的（属性：值）对，使用分号（;）将各个不同的属性值对分开，使用大括号（{}）将所有declaration包含在一起。
1、 一般选择器（selector）
Qt支持所有的CSS2定义的选择器，其祥细内容可以在w3c的网站上查找http://www.w3.org/TR/CSS2/selector.html ， 其中比较常用的selector类型有：
通用类型选择器：* 会对所有控件有效果。 类型选择器：QPushButton匹配所有QPushButton的实例和其子类的实例。 属性选择器：QPushButton[flat=”false”]匹配所有QPushButton属性flat为false的实例，属性分为两种，静态的和动态的，静态属性可以通过Q_PROPERTY() 来指定，来动态属性可以使用setProperty来指定，如：
QLineEdit *nameEdit = new QLineEdit(this);
nameEdit-&gt;setProperty("mandatoryField", true);
如果在设置了qss后Qt属性改变了，需要重新设置qss来使其生效，可以使用先unset再set qss。 类选择器：.QPushButton匹配所有QPushButton的实例，但不包含其子类，这相当于：*[class~="QPushButton"] ~=的意思是测试一个QStringList类型的属性是否包含给定的QString ID选择器：QPushButton#okButton对应Qt里面的object name设置，使用这条CSS之前要先设置对应控件的object name为okButton，如：Ok-&gt;setObjectName(tr(“okButton”)); 后裔选择器：QDialog QPushButton匹配所有为QDialog后裔（包含儿子，与儿子的儿子的递归）为QPushButton的实例 子选择器：QDialog &gt; QPushButton匹配所有的QDialog直接子类QPushButton的实例，不包含儿子的儿子的递归。 2、子控件选择器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/879eab7b1e226d729c4a452fdf657ab2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/125/">«</a>
	<span class="pagination__item pagination__item--current">126/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/127/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>