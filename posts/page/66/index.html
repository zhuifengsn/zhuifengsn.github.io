<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01320f17cee76136e773e4a385ba0b05/" rel="bookmark">
			Win10电脑开机后黑屏只有鼠标怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win10电脑开机后黑屏只有鼠标怎么解决？这是怎么回事呢？一般出现电脑开机后显示器黑屏只有鼠标很有可能是资源管理器的问题，用户需要结束掉资源管理器的进程再重新运行，下面就教下大家win10电脑开机黑屏有鼠标的解决方法操作步骤。
1、按下Ctrl+Alt+Del组合键，选择打开任务管理器。或者直接尝试按Ctrl+Shlft+Esc看能不能直接调出任务管理器。
2、找一下资源管理器进程，结束它。有的系统会显示explorer.exe，总之点击后结束进程。没有的话直接进行第3步。
3、单击左上角的文件，选择运行新任务，弹出窗口中，输入explorer.exe，并勾选以系统管理权限创建此任务，选择确定。
4、这样Windows资源管理器重新启动应该就可以恢复桌面显示了。
5、紧接着咱们按win+R组合键，打开运行窗口，输入regedit，回车。
6、进入注册表编辑器，依次进入以下路径，HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon。
7、在右侧窗口中双击Shell，若Shell的数值数据为explorer.exe则正确，若不是，则更改为explorer.exe，点击确定即可。
这样一来下次开机就不会有同样的问题出现啦。
如果用户的电脑总是有这种莫名其妙的问题发生，建议重新安装系统。
建议使用【系统之家装机大师】来快速地重装新系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/317d943da3995091bc501cff948d077c/" rel="bookmark">
			点云处理之点云滤波去噪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
点云滤波简介
什么是点云滤波？
为什么要点云滤波？
常用滤波器
直通滤波器
体素滤波器（下采样）
均匀采样滤波器（下采样）
统计滤波器（去噪）
条件滤波
半径滤波（去噪）
投影滤波
模型滤波
高斯滤波（去噪、平滑）
双边滤波（平滑）
总结
点云滤波简介 什么是点云滤波？ 点云滤波作为常见的点云处理算法，一般是点云处理的第一步，对后续处理有很重要作用。滤波
有很多方面也有很多种功能，比如去除噪声点、离群点、点云平滑以及空洞、数据压缩等
为什么要点云滤波？ 原始点云数据往往包含大量散列点、孤立点，在获取点云数据时 ，由于设备精度，操作者经验环
境因素带来的影响，以及电磁波的衍射性，被测物体表面性质变化和数据拼接配准操作过程的影
响，点云数据中讲不可避免的出现一些噪声，而且采样的分辨率也不同。
在点云处理流程中滤波处理作为预处理的第一步，对后续的影响比较大，只有在滤波预处理中将 噪声点，离群点，孔洞，数据压缩等按照后续处理定制，才能够更好的进行配准，特征提取，曲 面重建，可视化等后续应用处理。其类似于信号处理中的滤波。
PCL中点云滤波方案 PCL中总结了几种需要进行点云滤波处理的情况，这几种情况分别如下:
点云数据密度不规则需要平滑。 因为遮挡等问题造成离群点需要去除。 大量数据需要进行下采样(Downsample) 噪声数据需要去除。 对应的方法如下:
按具体给定的规则限制过滤去除点。通过常用滤波算法修改点的部分属性。对数据进行下采样。
常用滤波器 直通滤波器 直通滤波器就是根据点云的属性在点的属性上设置范围，对点进行滤波，保留范围内的或保留范围外的。
指定一个维度以及该维度下的值域 遍历点云中的每个点，判断该点在指定维度上的取值是否在值域内，删除取值不在值域内的点遍历结束，留下的点即构成滤波后的点云。 #include &lt;pcl/filters/passthrough.h&gt; // 原点云获取后进行滤波 pcl::PassThrough&lt;pcl::PointXYZ&gt; pass;// 创建滤波器对象 pass.setInputCloud (cloud);//设置输入点云 pass.setFilterFieldName ("z");//滤波字段名被设置为Z轴方向 pass.setFilterLimits (0.0, 1.0);//可接受的范围为（0.0，1.0） //pass.setFilterLimitsNegative (true);//设置保留范围内 还是 过滤掉范围内 pass.filter (*cloud_filtered); //执行滤波，保存过滤结果在cloud_filter 体素滤波器（下采样） 体素滤波器可以达到向下采样同时不破坏点云本身几何结构的功能，但是会移动点的位置。 此外体素滤波器可以去除一定程度的噪音点及离群点。主要功能是用来进行降采样。
它的原理是根据输入的点云，首先计算一个能够刚好包裹住该点云的立方体，然后根据设定的分辨率，将该大立方体分割成不同的小立方体。对于每一个小立方体内的点，计算他们的质心，并用该质心的坐标来近似该立方体内的若干点。 ApproximateVoxelGrid的不同在于这种方法是利用每一个小立方体的中心来近似该立方体内的若干点。相比于 VoxelGrid，计算速度稍快，但也损失了原始点云局部形态的精细度
#include &lt;pcl/filters/voxel_grid.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/317d943da3995091bc501cff948d077c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/358757ba267e046122fdc18e53fe0f37/" rel="bookmark">
			java资料（附链接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 《王道操作系统》学习笔记总目录+思维导图
第 1 章 计算机系统概述
1.1 操作系统的基本概念1.2 操作系统的发展和分类1.3 操作系统的运行机制和体系结构 第 2 章 进程管理
2.1 进程与线程2.2 处理机的调度2.3 进程的同步与互斥2.4 死锁 第 3 章 内存管理
3.1 内存管理的概念3.2 虚拟内存管理 第 4 章 文件管理
4.1 文件系统4.2 磁盘组织与管理 第 5 章 I/O管理
5.1 I/O管理概述5.2 I/O核心子系统 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf4a04e12aa3029ecf7a848cfbd42297/" rel="bookmark">
			Win11此应用无法在你的电脑上运行怎么解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win11打开软件显示“此应用无法在你的电脑上运行”怎么解决？最近有用户反馈在Win11中打开软件的时候，遇到了这个问题，提示说要找到适用于你的电脑的版本，那么我们有什么方法可以进行解决呢？Win11不忘初心精简版
win11此应用无法在你的电脑上运行的解决方法
一、设置一下兼容模式运行。
1、win11系统比较新，软件可能不兼容，可以右键点击该软件图标，打开“属性”。
2、接着进入兼容性，勾选“以兼容模式运行这个程序”。
3、然后勾选“以管理员身份运行此程序”并“确定”保存即可解决。
二、找到64位版本的软件。
1、因为win11系统是64位的，只能够运行64位软件。
2、可能用户下载的软件不是64位的而是32位的，所以我们需要下载64位的软件进行使用才行。
3、有很多软件都会分32位和64位，大家下载的时候要注意。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7092c5be2326b5d0c31edf8f193be9e7/" rel="bookmark">
			当神经网络遇上GUI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，在这里先构建一个简单的神经网络；```
l%数据集导入选择数据集的前14组用于训练，后3组用于测试
clear all
clc
load sample
data=Data1’;%矩阵转置
result=Data2’;
n=randperm(17);%1-17 随机排列
input_train=data(:,n(1:14));%取14个样本用于训练
output_train=result(:,n(1:14));
input_test=data(:,n(15:17));%取剩余3个样本用于检验
output_test=result(:,n(15:17));
%训练样本归一化
[inputn,inputps]=mapminmax(input_train);
minp=inputps.ymin;
maxp=inputps.ymax;
[outputn,outputps]=mapminmax(output_train);
mint=outputps.ymin;
maxt=outputps.ymax;
load bpdata
%最适隐藏节点确定设置在1~30 个隐层节点数情况下，计算预测结果与实际结果的误差绝对值之和，由此确定隐层节点数。
for i=1:30
net =newff (inputn,outputn,i, {‘tansig’,‘purelin’},‘traingdx’)
net.divideParam.trainRatio = 100/100;
net.divideParam.valRatio = 0/100;
net.divideParam.testRatio = 0/100;
net.trainParam.epochs=2000;
net.trainParam.lr=0.05;
net.trainParam.goal=0.00001;
net=train(net,inputn,outputn);
testn=mapminmax(‘apply’,input_test,inputps);
an=sim(net,testn);
a=mapminmax(‘reverse’,an,outputps);
sse=sum((b-a).^2);
r(i)=norm(sse);
end
load bpdata
inputnum=3;
hiddennum=5;
outputnum=1
net1 =newff (xn,zn,5, {‘tansig’,‘purelin’},‘traingdm’);
net.divideParam.trainRatio = 100/100;
net.divideParam.valRatio = 0/100;
net.divideParam.testRatio = 0/100;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7092c5be2326b5d0c31edf8f193be9e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c71633f174602b07494da9bea0a6f66e/" rel="bookmark">
			警告当当成错误 may be used uninitialized in this function [-Werror=maybe-uninitialized]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果是ubuntu20版本，或者gcc版本太高，可能有些警告会当成错误导致编译出错：
error: ‘’ may be used uninitialized in this function [-Werror=maybe-uninitialized]
cc1plus: some warnings being treated as errors
确认gcc版本
gcc -v gcc version 9.4.0 (Ubuntu 9.4.0-1ubuntu1~20.04.1)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b74438c85882363406a8ebf65edac89f/" rel="bookmark">
			MATLAB定态氢原子波函数可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在知乎看到了
[王欢]的[用 Python+SciPy 可视化定态氢原子波函数（一）]
[王大可]的[利用Mathematica将定态氢原子波函数可视化]
手痒，想用MATLAB也实现一下，David Griffiths 所著的 Introduction to Quantum Mechanics 中:
ψ n , l , m ( r , θ , ϕ ) = R n l ( r ) Y l m ( θ , ϕ ) \psi_{n, l, m}(r,\theta, \phi)=R_{nl}(r)Y_{l}^{m}(\theta, \phi) ψn,l,m​(r,θ,ϕ)=Rnl​(r)Ylm​(θ,ϕ)
即，函数由径向波函数及球形谐函数两部分组成，展开一下径向波函数是这样的：
ψ n , l , m ( r , θ , ϕ ) = ( 2 n a ) 3 ( n − l − 1 ) !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b74438c85882363406a8ebf65edac89f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bfa305dbd4f140306f14147348386e3/" rel="bookmark">
			解决explorer.exe开机占用CPU过高
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows 10 explorer.exe每次开机都占用50%CPU左右，笔记本风扇狂转
解决策略：使用procexp程序（微软自家出品的任务管理器升级版）看explorer.exe的哪个线程这么占
发现是一个叫tpreleasecleanupgroupmembers的东西
谷歌一下发现这玩意是Microsoft Store Installation (MSI)，不知道为啥就开始呼呼往我机子上装
在services.msc里停止掉就可以了，去它的吧
参见：
https://docs.microsoft.com/en-us/answers/questions/341871/every-second-hard-drive-access-by-wmiprvseexe.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ead02d0920b73bccda1aaae09fdeee53/" rel="bookmark">
			笔记本Win11连接WiFi后显示无Internet访问权限怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win11连接WiFi后显示无Internet访问权限怎么办？许多用户在使用笔记本电脑的时候，为了方便，都会连接使用WiFi，而不少用户在使用的时候也会遇到一些问题，下面系统之家就带着大家一起看看如何解决吧！笔记本专用Win11 64位 专业办公版
操作方法：
1、进入设置，找到「网络和Internet」，双击进入。
2、找到「更改适配器选项」，双击进入。
3、双击进入你的WLAN。
4、找到页面下方的「属性」，单击。
（此时图片第一行的「IPv4连接」的状态应该和下一行一样，是「无网络访问权限」的，但由于这照片是答主成功之后回头拍照答题的，所以显示「Internet」其实是已经可以正常上网的状态了。）
5、在项目列表里，找到「Internet协议版本4（TCP/IPv4）」，双击它。
6、出现如图页面，单击下方「高级」按钮。
7、选WINS一栏，看到下方的NetBIOS设置，一开始选中的是「默认」，我们需要把它改为「启用TCP/IP上的NetBIOS」，之后点「确定」。
8、这时回头再看，你就会发现「IPv4连接」那一项的状态变成了「Internet」，此时笔记本已经可以正常上网了。
（注：方法不一定适用于所有人，仅供参考啦～）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a110d850fddfc9172751dd84287760d/" rel="bookmark">
			SpringIOC的三级缓存原理分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 看本篇文章之前需要了解SpringIOC的基本流程，不了解的可以看我的这篇SpringIOC源码详解
一. 什么是SpringIOC的三级缓存 类与类之间的依赖关系形成了闭环，就会导致循环依赖问题的产生。
如下图是三个类之间的循环依赖
Spring 的依赖注入方式有三种：构造方法注入、setter 方法注入、接口注入
setter 方法注入的方式，是在对象实例化完成之后，再通过反射调用对象的 setter 方法完成属性的赋值，能够处理循环依赖的问题，也是本文要讲的构造方法注入的方式，将实例化与初始化并在一起完成，能够快速创建一个可直接使用的对象，但它没法处理循环依赖的问题，类似先有鸡还是先有蛋的问题接口注入的方式太灵活，易用性比较差，所以并未广泛应用起来 二. 跟着栗子看源码 下面这个栗子是两个类的相互依赖，同样能看出来三级缓存的流程
Animal类：
public class Animal { private String name; private Fruits fruits; public Fruits getFruits() { return fruits; } public void setFruits(Fruits fruits) { this.fruits = fruits; } public String getName() { return name; } public void setName(String name) { this.name = name; } } Fruits类：
public class Fruits { private String name; private Animal animal; public Animal getAnimal() { return animal; } public void setAnimal(Animal animal) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a110d850fddfc9172751dd84287760d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b76998b367e3fbd88db99468c3b742b/" rel="bookmark">
			因子分析全流程汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、研究场景 因子分析(探索性因子分析)用于探索分析项(定量数据)应该分成几个因子(变量),比如20个量表题项应该分成几个方面较为合适;用户可自行设置因子个数,如果不设置,系统会以特征根值大于1作为判定标准设定因子个数。
二、数据格式 因子分析时，一列标识1个指标，一行为1个样本；如果为面板数据，比如100家公司每家公司10年，那么就会有100*10=1000个样本，可能需要单独两列分别是公司名和年份来标识面板格式而已，但因子分析并不区分是否面板数据，只针对指标进行分析即可，另一般分析样本量需要超出分析项（指标）的5倍，类似数据格式如下图：
三、SPSSAU操作 1.上传数据 登录账号后进入SPSSAU页面，点击右上角“上传数据”，将处理好的数据进行“点击上传文件”上传即可。
2.拖拽分析项 在“进阶方法”模块中选择“因子”方法，将分析项定量拖拽到右侧分析框内，点击“开始分析”即可。
补充说明：如果有预期想提取的因子个数，可以主动设置输出的因子个数勾选“因子得分”与“综合得分”会在左侧分析框生成新的变量，标题如CompScore*****（综合得分）、FactorScore*****（因子得分）。因子得分可用于进一步分析，比如聚类分析，回归分析使用等；综合得分可用于对比排名等。
因子个数：多数情况下，我们在分析时已经带着主观预期，希望题项如何归类，此时可以直接设置对应的因子个数。
四、调整分析项 当前有一份数据,共涉及A1~A4,B1~B4,C1~C3,D1~D3共14个量表题，希望将此14个量表题使用因子分析浓缩成几个维度。从背景情况上看，预期此14个题目可分为4个维度，分别称作A，B，C和D维度。当然有可能个别项并不合适，因此有可能对其进行删除处理。
1.第一次分析
从上图中可以看出：
A1~A4这4项，它们全部对应着因子3时，因子载荷系数值均高于0.4，说明此4项应该同属于一个维度，即逻辑上A1~A4这4项，并没有出现‘张冠李戴’现象。但是A1和A2这两项出现‘纠缠不清’现象，A1和A2除了可以对应因子3，也可以放在因子1下面。一般出现‘纠缠不清’现象时，暂时保留，先处理清楚‘张冠李戴’问题更好。
B1~B4共4项，B2,B3,B4这3项对应着因子1下面，但是B1却对应着因子2，因此B1这项属于‘张冠李戴’，应该将B1删除。B2同时对应因子1和因子2均可，属于‘纠缠不清’，暂不处理B2。
C1~C3共3项，此3项均对应着因子2，此3项并没有出现‘纠缠不清’或者‘张冠李戴’问题。
D1~D3共3项，D3出现了‘张冠李戴’问题，应该进行删除处理。D2出现了‘纠缠不清问题’（可对应因子1和因子4），应该给予关注。
总结上述分析可知：B1和D3这两项出现‘张冠李戴’，应该首先将此两项删除；而A1，A2，B2，D2共四项有出现‘纠缠不清现象’，暂时不处理（进行关注即可）。将B1和D3这两项删除后，进行第二次分析。
2.第二次分析
总结可知：A1出现“张冠李戴”现象，应该将A1先删除后再次进行第3次分析，另对A2和D2（“纠缠不清”）这两项给予关注。
3.第三次分析
D2可同时出现在因子2和因子4下面，但考虑到D维度当前仅余下2项，因而表示可以接受，最终是将D2归纳到因子4即D维度下面。最终找出A，B，C和D共4个维度，它们分别与项之间的对应关系良好。因子分析结束。 “纠缠不清”：比如A1可归属为A维度，同时也可归属到C维度，这种情况较为正常（称作‘纠缠不清’），需要结合实际情况处理即可，可将A1删除，也可不删除，带有一定主观性。因子分析是一个多次重复的过程，比如删除某个或多个题项后，则需要重新再次分析进行对比选择等。最终目的在于：维度与分析项对应关系，与专业知识情况基本吻合。
“张冠李戴”：比如A1归属为A维度，但是却归属为C维度下，出现这种情况一般进行删除，重新分析。
五、SPSSAU分析 1.KMO 和 Bartlett 的检验 使用因子分析进行信息浓缩研究，首先分析研究数据是否适合进行因子分析，从上表可以看出：KMO为0.876，大于0.6，满足因子分析的前提要求，意味着数据可用于因子分析研究。以及数据通过Bartlett 球形度检验(p&lt;0.05)，说明研究数据适合进行因子分析。
2.方差解释率表格 主要用于判断提取多少个因子合适。以及每个因子的方差解释率和累计方差解释率情况。方差解释率越大说明因子包含原数据信息的越多。因子分析中，主要关注旋转后的数据部分。
从上表可知：累积方差解释率值为78.213%，说明提取出来的4个因子可以提取出总共11项中78.213%的信息量，而且四个因子的方差解释率（信息提取量）分别为：21.407%，21.277%，20.807%和14.723%。信息提取量分布较为均匀，综合说明本次因子分析结果良好。
补充说明：如果研究人员并没有预设维度。而选择默认选项，SPSSAU默认以特征根大于1作为标准。当然因子分析通常需要综合自己的专业知识综合判断，即使是特征根值小于1，也一样可以提取因子。
3.旋转后因子载荷系数表格 从上表可知：所有研究项对应的共同度值均高于0.4，意味着研究项和因子之间有着较强的关联性，因子可以有效的提取出信息。最终对浓缩出来的四个因子进行分别命名为：A，B，C和D维度。
4.碎石图 同时可结合碎石图辅助判断因子提取个数。当折线由陡峭突然变得平稳时，陡峭到平稳对应的因子个数即为参考提取因子个数。实际研究中更多以专业知识，结合因子与研究项对应关系情况，综合权衡判断得出因子个数。
补充说明：因子计算权重 6.成份得分系数矩阵 7.载荷图 载荷图用于展示各因子与载荷值关系情况，建议结合实际情况使用即可。
第一：如果提取1个成分（或因子）时，则无法展示载荷成分图；
第二：如果超过个成分（或因子）时，可自主切换查看对应的载荷图。
其中X轴Y轴可以更改如下：
8.线性组合系数及权重结果 六、其它问题 1.因子分析计算权重？
如果使用因子分析的目的在于计算权重，此时可使用旋转后方差解释率值进行权重计算。比如提取2个因子，旋转后的方差解释率分别是39.759%,24.061%，旋转后累积方差解释率为63.820%。那么归一化（即除累积方差解释率）即得到权重，计算如下表：
2. 无论如何均‘张冠李戴’或‘纠缠不清’？
‘张冠李戴’是需要处理的，如果无论如何都有‘张冠李戴’现象，意味着维度和题项间对应关系有问题。可考虑减少因子个数进行对比分析。
【特别提示：因子分析是一个来回多次重复对比，结合软件输出和自身专业知识情况综合选择对比找出最优结果的过程】‘纠缠不清’这种现象，多数时候并不需要处理。
3. 最大方差旋转问题？
SPSSAU默认使用最大方差旋转法（Varimax）对数据进行旋转。特征根，方差解释率和累积方差解释率这三项均区分旋转前和旋转后；如果让软件自动识别因子个数，是以旋转前特征根大于1作为标准；其余情况下的分析建议以旋转后作为标准。
4.综合得分如何使用？
综合得分可用于对比综合竞争力情况，综合得分值越高，此时综合竞争力越强。此类应用常见于经济、管理类研究，比如上市公司的竞争实力对比。
综合得分需要选中按钮才会生效，且SPSSAU单独生成一列新标题名称类似为：“Comp_score****”,一般情况下用户需要把综合得分的原始数据下载出来使用，通过右上角‘我的数据-&gt;下载’，可将综合得分下载出来使用。
5.‘分析之前是否需要对数据进行标准化处理’？
SPSSAU默认就已经进行过标准化处理，因此不需要再对数据处理。当然标准化后的数据再次标准化依旧还是自身没有任何变化，结果永远均一致。
6. 综合得分如何计算得到的？
SPSSAU默认提供保存综合得分，至于其计算原理，比如说提取得到4个因子，并且此4个因子的旋转后方差解释率分别是21.407%，21.277%，20.807%和14.723%；累积方差解释率值为78.213%。综合得分计算公式为：求和(因子得分*旋转后方差解释率)/累积方差解释率。如下图所示：
七、总结 因子分析往往是预处理步骤，后续还需要结合具体研究目的进行分析，如回归分析、聚类分析等。对于探索性因子分析完成指标权重，计算在实际研究中，通常会结合其他分析方法，比如主观赋权法（AHP层次分析法），或者客观赋权法（熵值法）进行权重计算，亦或是在主观赋权法和客观赋权法基础上，结合组合赋值法完成最终权重计算。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b76998b367e3fbd88db99468c3b742b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b949b5221753bc1283297675779f7c5/" rel="bookmark">
			stm32f1串口发送与接收
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
串口配置
串口发送
1使用SendString函数发送
2使用printf函数发送
​串口接收
串口配置 首先对串口进行初始化
包括使能串口时钟，这里我使用的是usart2，使能GPIO时钟，这里我用的是A口，以及GPIO口的配置，这里我的串口输出是PA2，输入是PA3
然后初始化usart2，再使能usart2，具体代码如下：
/* 串口初始化 */ void STM_EVAL_COMInit(USART_InitTypeDef* USART_InitStruct) { GPIO_InitTypeDef GPIO_InitStructure; /* Enable GPIO clock */ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);//GPIOA使能 RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);USART2时钟使能 /* Configure USART Tx as alternate function push-pull */ GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;//输出PA2 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); /* Configure USART Rx as input floating */ GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//输入PA3 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); /* USART configuration */ USART_Init(USART2, USART_InitStruct);//USART2初始化 /* Enable USART */ USART_Cmd(USART2, ENABLE);//使能USART2 } 之后需要配置串口的参数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b949b5221753bc1283297675779f7c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e73c6d46260863bffe86a393a68fe92e/" rel="bookmark">
			下载NCBI的SRA数据 详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SRA（Sequence ReadArchive）数据库是NCBI(National Center for Biotechnology Information)旗下用于存储高通量测序数据的子库。来自世界各地研究的测序数据在此处都可以免费下载，本文就聊聊如何下载SRA数据库对应的测序数据。
1. SRA基本框架 下载数据之前，咱们可以先聊聊SRA数据库的一些基础知识。
SRA数据库的组织框架是基于 STUDY, SAMPLE, EXPERIMENT, RUN 四个概念构建的。
STUDY ：研究课题/研究项目， 和NCBI的子库[BioProject](https://www.ncbi.nlm.nih.gov/bioproject/)数据库里面的项目相关联 , 检索号(accession number) 通常以前缀 SRP,DRP,ERP 开头(例如SRP000544)SAMPLE ：样本信息， 和NCBI的子库[BioSample](https://www.ncbi.nlm.nih.gov/biosample/)数据库里面的样本相关联，检索号(accession number) 通常以前缀 SRS,DRS,ERS 开头(例如SRS001487)EXPERIMENT : 实验信息, 一次实验包含了一个或多个样本进行一个多多个RUN的测序。检索号(accession number) 通常以前缀 SRX,DRX,ERX 开头RUN：RUN通俗理解就是测序仪运行一次产生的测序数据，是 SRA 里面最小的概念，该编号通常直接链接到对应某一个/对fastq下机的文件。检索号 (accession number) 通常以前缀 SRR,DRR,ERR 开头。 说了这么多是不是依然傻傻分不清SRP,DRP,ERP等，其实编号的含义很简单：
第一个字母：表示样本最初被上传到的源数据库，NCBI会同步EBI和DDBJ的数据，同步后会保留源数据的来源信息。
S – NCBI’s SRA database E – EBI’s database D – DDBJ database 第二个字母：固定为"R"，代表Read
第三个字母：数据的类型，可以是项目、样本、实验或RUN
R – Run X – Experiment S – Sample P – Project / study 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e73c6d46260863bffe86a393a68fe92e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0852c8880252078f5582653214aef1a6/" rel="bookmark">
			设计模式，看这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是设计模式 设计模式，是软件开发过程中所面临问题的一般性解决方案，是众多开发人员在很长一段时间中的试验和错误中总结出来的最佳实践。
合理地使用设计模式可增强代码的可靠性和可重用性，同时也使得代码更容易被他人理解。
总的来说，设计模式可分为三大类：
创建型 (Creation Patterns)：提供一种 “隐藏了具体创建细节” 的对象创建方式。结构型 (Structual Patterns)：聚焦于类和对象的组合。行为型 (Behavioral Patterns)：聚焦于对象之间的通信。 创建型模式 单例模式 简介 单例（Singleton）模式的定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。
​
优点 公共且不变的资源有且只会有一个对外的实例，避免不必要的内存占用。
缺点 相应逻辑都写在一个对象里，很容易违背单一原则。不能扩展，违背开闭原则。 例子 懒汉式单例 当第一次调用 getlnstance 方法时才去创建这个单例。(例子是加了双锁的，但理论上也算是饿汉式)
多线程每次访问时都要同步，会影响性能，且消耗更多的资源，这是懒汉式单例的缺点。
// 加了双锁保证线程安全，单线程环境是可以去除的 public class LazySingleton { private volatile static LazySingleton instance; private LazySingleton (){} public static LazySingleton getInstance() { if (instance == null) { synchronized (LazySingleton.class) { if (instance == null) { instance = new LazySingleton(); } } } return instance; } } ​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0852c8880252078f5582653214aef1a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee815b74759decaa572266f79dd96ed6/" rel="bookmark">
			树莓派连接温度传感器实时监控，并上报服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、项目介绍二、软件架构客户端服务器端 三、代码服务器端代码 四、安装说明五、使用说明六、本项目gitee仓库 一、项目介绍 该项目由客户端和服务器两端程序组成，以树莓派为客户端，远程服务器为服务器端，利用socket通信，将树莓派上采集的ds18b20的温度传感数据发送到服务器端。如果断开连接，客户端将采集的数据存于sqlite3数据库中，同样服务器端也会把每次接收到的数据存于sqlite3数据库中。
二、软件架构 客户端 1.树莓派上运行socket客户端程序， 每隔30秒以字符串“设备号/日期时间/温度”形式上报采样温度，设备号便于服务器端区分是哪个树莓派客户端，如“RPI200/2022.4.4-12:01/28.00”；
2.通过命令行参数指定服务器端IP地址和端口以及间隔采样时间；
3.程序放到后台运行，并通过syslog记录程序的运行出错、调试日志；
4.程序可以捕捉kill信号正常退出；
5.当服务器断开时，将采集的数据存放至本地数据库中，等再次连接上服务器时，将已保存在数据库中的数据重新发送给服务器。
客户端程序流程图如下：
服务器端 1.服务器程序运行啊在Linux服务器上；
2.通过命令行指定监听的端口；
3.程序能够捕捉kill信号正常退出；
4.服务器支持多个客户端并发访问，选择epoll实现多路复用；
5.服务器收到每个客户端的数据都解析后保存到数据库中，接收到的格式为：“设备号/日期时间/温度”，如“RPI200/2022.4.4-12:01/28.00”；
服务器端程序流程图如下：
三、代码 客户端代码：
/********************************************************************************* * Copyright: (C) 2022 Zhang Changxing&lt;ZhangChangxingVIP@163.com&gt; * All rights reserved. * * Filename: client.c * Description: This file Collect the temperature data on the ds18b20 sensor and send it to the server. If the sending fails, it will be stored in the database temperature.db. * * Version: 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee815b74759decaa572266f79dd96ed6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d01b975b3fbab396deca67cbb223d6bf/" rel="bookmark">
			C语言：输入一串字符串，统计字符串中有多少个数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 gets函数会在输入完字符后自动补上一个\0，所以用这个特性可以计算出字符串是否结束。
因为数字在字符中对应的ascii码就是0~9，只要遇到小于9的字符就是数字，所以计数器加一
#include&lt;stdio.h&gt; int c (char *); int main() { char ch[100]; char *p_ch = ch; int i, j = 0; gets(ch); j = c(ch); printf("一共有%d个数字",j); return 0; } int c(char *p_ch) { int i,j; for(i = 0;; i++) { if(p_ch[i] == '\0') { return j; } if(p_ch[i] &lt;= '9') { j++; } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d2a96db9fbd765df837c2ba15414e58/" rel="bookmark">
			Java基础教程-02-运算符与选择循环结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java基础教程-02-运算符与选择循环 1. 关系运算符 1.1 概述 关系运算符就是用来描述两个变量或者常量之间的关系的.主要分为以下6种:
符号说明==a==b，判断a和b的值是否相等，成立为true，不成立为false!=a!=b，判断a和b的值是否不相等，成立为true，不成立为false&gt;a&gt;b，判断a是否大于b，成立为true，不成立为false&gt;=a&gt;=b，判断a是否大于等于b，成立为true，不成立为false&lt;a&lt;b，判断a是否小于b，成立为true，不成立为false&lt;=a&lt;=b，判断a是否小于等于b，成立为true，不成立为false 1.2 注意事项 • 关系运算符的结果都是boolean类型，要么是true，要么是false。
• 千万不要把==写成了=, 否则结果可能不是你想要的.
1.3 案例 需求
定义两个int类型的变量a和b, 分别赋值为10和5.通过关系运算符比较这两个变量之间的关系, 并打印结果.
参考代码 public class OperatorDemo01 { public static void main(String[] args) { //定义两个int类型的变量a和b, 分别赋值为10和5. int a = 10; int b = 5; //通过`关系运算符`比较这两个变量之间的关系, 并打印结果. System.out.println(a &gt; b); System.out.println(5 &gt;= 5); System.out.println(a &lt; b); System.out.println(5 &lt;= 5); System.out.println(a != b); System.out.println(a == b); System.out.println(a = b); //关系运算符的最终结果是boolean类型, 所以我们也可以用boolean类型的变量接收. boolean flag = 10 &lt; 5; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d2a96db9fbd765df837c2ba15414e58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c23d42b222948036de8a937b45566265/" rel="bookmark">
			strstr函数——一个字符串是否是另一个字符串的子串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		头文件： string.h 函数的声明： char *strstr( const char *str1, const char *str2 )
字符串 可能的子串
返回值： 如果str2在str1中出现，返回str2第一次出现在str1的位置的地址
如果str2没有在str1中出现，返回NULL空指针
用法： 给两个字符串，第一个为字符串，第二个为要判断的子串
实例： #include&lt;stdio.h&gt; #include&lt;string.h&gt; int main() { char str1[] = "abcijkghijk";//仅返回第一次出现子串的地址 char str2[] = "ijk"; strstr(str1, str2); char* ret = strstr(str1, str2); if (NULL == ret) { printf("找不到字符串\n"); } else { printf("找到了\n"); printf("%s\n", ret);//并把之后的字符打印 } return 0; } 函数的实现： #include&lt;stdio.h&gt; #include&lt;string.h&gt; char* my_strstr(char* str1, char* str2) { char* s1 = 0; char* s2 = 0; char* p = str1; while (*p !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c23d42b222948036de8a937b45566265/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/682bd7ad241a7e3fee1ea8f75ee43095/" rel="bookmark">
			51单片机矩阵键盘扫描及使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、矩阵键盘简介 矩阵键盘，也称矩阵按键，是为了节约单片机IO口占用所引入的一种外设。
（图片截取至普中A2开发板原理图）
（图片截取至普中A2开发板实物图）
我们知道，一个独立按键需要1个IO口。但是如果我们需要大量的按键，则需要大量的IO口，但是单片机现有的IO口并不能很好的满足，所以引入矩阵键盘。
二、矩阵键盘扫描原理 从独立按键到矩阵按键 1.独立按键回顾
上图的矩阵键盘共16个按键（4行×4列），先回到原来的一个独立按键分析。
首先分析独立按键的原理图连接方式（如上图），以按键K1为例，按键K1一端连接到单片机的P3.1口，另一端接地（GND）。当按键K1被按下时，GND直接就连到P3.1。所以当K1被按下时，P3.1口为低电平。我们只需要判断P3.1口是否为低电平，即可判断K1是否被按下。
2.矩阵按键扫描思路
先分析矩阵按键的IO连线，有以下特征：
P17~P14这四个IO口连接了每一行矩阵键盘P13~P10这四个IO口连接了每一列矩阵键盘 矩阵键盘扫描共有两种扫描方式：
逐行扫描逐列扫描 先分析逐行扫描，根据键盘被按下时,IO口为低电平这个特性。我们可以这样检测第一行：
给除第一行之外的其他行给高电平，防止其影响我们接下来的低电平检测给第一行送低电平0依次检测每一列的IO口电平（P13~P10），当出现低电平时，说明第一行的这一列的这个按键就被按下。 结合下图很好理解：
要检测第一行，给其他行赋值高电平。假设S2被按下了，那么P17的低电平会顺着绿色路线通到S2的另一端IO口（P12），只要检测出P12为低电平，那么就可以得出结论：K2被按下
按照这个思路，继续依次检测其他行即可。
总结：
按行扫描 给第1到第4行要扫描的行置0，其余行置1。然后对每一列进行读取，读出低电平的列则可以判断该行该列的按键被按下。
IO口电平（P17~P14：每行对应IO的口）检测的行若第K列IO口测出低电平0 1 1 1一第一行第K列被按下 1 0 1 1
二第二行第K列被按下1 1 0 1三第三行第K列被按下1 1 1 0四第四行第K列被按下 按列扫描的结果类似：
IO口电平（P13~P10：每行对应IO的口）检测的列若第K行IO口测出低电平0 1 1 1一第K行第一列被按下 1 0 1 1
二第K行第二列被按下1 1 0 1三第K行第三列被按下1 1 1 0四第K行第四列被按下 三、编程验证 1、先给出一些引脚定义
#include &lt;REGX52.H&gt; #define uchar unsigned char #define uint unsigned int #define led P0 //IO口位选 sbit wei1=P2^2; sbit wei2=P2^3; sbit wei3=P2^4; //定义行引脚 sbit hang1=P1^7; sbit hang2=P1^6; sbit hang3=P1^5; sbit hang4=P1^4; //定义列引脚 sbit lie1=P1^3; sbit lie2=P1^2; sbit lie3=P1^1; sbit lie4=P1^0; 2、按行扫描代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/682bd7ad241a7e3fee1ea8f75ee43095/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/625aff1b216a56a8574068e4a89d73c2/" rel="bookmark">
			Oracle种批量导出CVS文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 导出SQL脚本 set linesize 2500 set echo off set term off set heading off set pagesize 0 set trimspool on set trimout on set feedback off spool 【文件物理地址，如c:\temp\test.cvs】
【SQL查询语句：表头 select ‘a,b,c,d’ from dual
数据 union select a||','||b||','||c from tablename】;
spool off
spool c:\temp\test1.cvs
select ‘a,b,c,d’ from dual union select name||','||sex||','||age||','||school from students1;
spool off
spool c:\temp\test2.cvs
select ‘a,b,c,d’ from dual union select name||','||sex||','||age||','||school from students2;
spool off
2. 在PL/SQL种运行脚本 SQL&gt; @ 脚本物理地址;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/625aff1b216a56a8574068e4a89d73c2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/65/">«</a>
	<span class="pagination__item pagination__item--current">66/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/67/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>