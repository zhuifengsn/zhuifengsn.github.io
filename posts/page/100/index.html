<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/809648b1e6acfb35f5e83daa3c5949aa/" rel="bookmark">
			DS1302 原理及操作方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DS1302 原理及操作方法 DS1302 特征典型连接电路和结构简图引脚说明 地址/命令字节读写操作地址读写发送的时序代码阐述 DS1302 特征 实时时钟显示秒、分钟、小时、月、月、日、周、年的秒、分钟、小时，最多可获得2100年的飞跃补偿。31 x 8电池支持通用RAM。最小针数系列I/O。2.0V至5.5V全面运作。2.0V时使用少于300nA。单字节或多字节（突发模式）数据传输，用于读取或写入时钟或RAM数据。8PinDIP或可选的8Pin，所以表面安装。简单的3线接口。TTL兼容(V CC=5V)。可选工业温度范围：-40°C至85°C。DS1202兼容。承销商实验室(UL®认可)
（建议大家去看DS1302的芯片手册。） 典型连接电路和结构简图 可以看到DS132由电源控制，输入移位寄存器，命令和控制逻辑，延时时钟，31×8 RAM和晶振输入模块构成。
引脚说明 值得注意的是当使用有源晶振时，只接X1引脚，而X2引脚悬空。
Vcc2 为主供电。 在没有主电源的情况下，VCC1连接到备份源，以维护时间和日期。 DS1302是从较大的VCC1或VCC2运行的。 当VCC2大于VCC1时 0.2V，VCC2为DS1302供电。 当VCC2小于VCC1时，VCC1为DS1302供电。
地址/命令字节 当对DS1320进行读操作时，需要发送地址字节，而进行写操作时，则需要发送地址和命令字节。
A4 A3 A2 A1 A0 是表示的是DS1320内部地址编号，如 下一部分的读写操作地址。81H — 10000001B 对应上图的地址字节。第1位因为是读操作，所以为1，第1位到第5位表示地址为00000，第六位为RAM/CK，这里我们选择时钟，第七位固定为1。可以对照下一部分的读写操作地址联系一下。
读写操作地址 大家可能疑惑的是10 Seconds 是什么意思？其实就是十位。例如：58 — 十位为 5 各位为 8。
写保护寄存器
WP：0允许写入，1禁止写入。
涓流充电寄存器
慢充电寄存器，用于管理对备用电源的充电
TCS：当4位TCS=1010时，才允许使用涓流充电寄存器，其他任何状态都将禁止使用涓流充电器。
DS：两DS位用于选择连接在VCC2和VCC1间的二极管数目。
读写发送的时序 时序图分析：找开始点，结束点和转折点。
在最下面有参考的 bilibili网址，老师讲的特别好，所以就不再赘述。
代码阐述 我们这里用蓝桥杯竞赛提供的底层驱动参考代码。
.h 文件声明函数
#ifndef __DS1302_H #define __DS1302_H void Write_Ds1302(unsigned char temp); void Write_Ds1302_Byte( unsigned char address,unsigned char dat ); unsigned char Read_Ds1302_Byte( unsigned char address ); #endif #include &lt;reg52.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/809648b1e6acfb35f5e83daa3c5949aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7adca09b9928fa761d7db8a37d44e7e9/" rel="bookmark">
			[Python/C#]C#交互Python(看这篇就够了)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[Python/C#]C#交互Python(看这篇就够了) 文章目录 [Python/C#]C#交互Python(看这篇就够了)· IronPython(不支持第三方库)1.安装2.应用总结 · Pyinstaller1.安装2.打包成exe，你能奈我何？3.交互4.解决乱码 结束语 · IronPython(不支持第三方库) IronPython 是一种在 NET 和 Mono 上实现的 Python 语言，由 Jim Hugunin（同时也是 Jython 创造者）所创造。1.0 版于2006年9月5日发布。
随后，在 2007 年，开发者决定改写构架，使用动态类型系统以让更多脚本语言能很容易地移植到NET Framework上。2008 年，随着微软发布 NET Framework3.0/3.5、Silverlight 之后，IronPython也发布了 2.0 版，最新版本是 2.7，于 2011年3月发布，支持.NET Framework 4.0。
(来自百度百科)
1.安装 右击"引用"，点击"管理 NuGet 程序包"
搜索IronPython，并点击安装。
这样，IronPython就安装完成了。
2.应用 弄点简单的UI，开始码代码。
在"你的项目目录\bin\Debug"里添加.py文件。
编辑py文件:
import time def get_time(): now_time = time.time() return str(now_time) 编辑C#文件:
private void button1_MouseClick(object sender, MouseEventArgs e) { // 创建Python解释器对象 ScriptEngine pyEngine = Python.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7adca09b9928fa761d7db8a37d44e7e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31efc6df3850298649d608634b6ef833/" rel="bookmark">
			Python统计字符串单词出现次数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一种
def str_count(char_str): """统计单词出现次数 利用字典方法，将每个单词出现个数以字典返回 :param char_str:要统计的字符串 :return 字典 """ dict={} for item in char_str.split(): dict[item]=dict.get(item,0)+1 return dict char_str="I am a boy and i am twenty" print(str_count(char_str)) #输出 {'i': 2, 'am': 2, 'a': 1, 'boy': 1, 'and': 1, 'twenty': 1} 第二种
def str_count(char_str): return {word:char_str.split().count(word) for word in char_str.split()} 第二种方法用到了列表表达式，其格式为
[表达式 for 迭代变量 in 可迭代对象 [if 条件表达式] ]
比如选取100以内的奇数
ls_num=[x for x in range(101) if x%2==1] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f75f74c35d487d2bcea1ce81b64c50e/" rel="bookmark">
			自媒体短视频搬运如何伪原创上热门!老司机教你伪原创短视频的做法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		都知道现在短视频市场很火爆，吸粉、变现，容易赚钱等等。但是不是每个人都有自己的团队，也不是每个人都可以去做原创视频，那么怎么去用别人的视频成为我们的原,伪原创视频需要改什么,创视频，这个给大家详细的说一下怎么让别人的视频成为我们的原创视频并且躲过后台的识别。
头条每天的内容几百万，不可能靠小编来干预推荐，都是智能机器人根据网友的互动数据来决定推荐的大小。
视频伪原创消重、剪辑处理
现在平台检测重复的视频的机制很严格，必须学会“加工”，做伪原创视频。所谓处理视频，就是消重处理。消重主要目的就是帮我们骗过平台的检测系统，让它认为这是原创视频，这样才会有推荐和流量。
一般消重的方法有：
1、添加滚动字幕，这样视频的内容就增加了。
2、改变视频时间的长短，比较快的就是剪截，比如把开头或者结尾截掉。
3、添加水印，需要的话可以添加自己的自媒体名称，做为某种宣传。
4、修改帧速率，让整个视频速度变快或者变慢。
5、添加视频特效、去除视频背景音。
6、视频旋转，横竖屏转换等改变视频方法
标题、标签的重要性
辛辛苦苦制作完成了短视频，如果因为标签打的不够准确不被平台推荐，那就白费心血了。
标签打好后，标题一样重要要和视频内容引起共鸣，要多看热门视频多总结，需要长时间去积累实践，一个好标题可提高视频的亮点，吸引人点赞关注，引起共鸣。
视频搬运每天都会产生新的思路想法，要大胆创新，视频爆热门指日可待!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f956bbe76cb9ab4c65285bcac2e8d734/" rel="bookmark">
			洛谷题解——P2392：kkksc03考前临时抱佛脚
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目相关 题目链接 洛谷，https://www.luogu.com.cn/problem/P2392。
题目描述 这次期末考试，kkksc03 需要考 4 科。因此要开始刷习题集，每科都有一个习题集，分别有 s1​,s2​,s3​,s4​ 道题目，完成每道题目需要一些时间，可能不等 A1​,A2​,…,As1​​，B1​,B2​,…,Bs2​​，C1​,C2​,…,Cs3​​，D1​,D2​,…,Ds4​​。
kkksc03 有一个能力，他的左右两个大脑可以同时计算 2 道不同的题目，但是仅限于同一科。因此，kkksc03 必须一科一科的复习。
由于 kkksc03 还急着去处理洛谷的 bug，因此他希望尽快把事情做完，所以他希望知道能够完成复习的最短时间。
输入格式 本题包含 5 行数据：第 1 行，为四个正整数 s1​,s2​,s3​,s4​。
第 2 行，为 A1​,A2​,…,As1​​ 共 s1​ 个数，表示第一科习题集每道题目所消耗的时间。
第 3 行，为 B1​,B2​,…,Bs2​​ 共 s2​ 个数。
第 4 行，为 C1​,C2​,…,Cs3​​ 共 s3​ 个数。
第 5 行，为 D1​,D2​,…,Ds4​​ 共 s4​ 个数，意思均同上。
输出格式 输出一行，为复习完毕最短时间。
输入样例 1 2 1 3	5 4 3 6 2 4 3 输出样例 20 数据范围 1 ≤ s1​, s2​, s3​, s4​ ≤ 20。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f956bbe76cb9ab4c65285bcac2e8d734/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d4ef7e2e2ff648d735b1bb0da09cc22/" rel="bookmark">
			Mysql8.0出现this is incompatible with sql_mode=only_full_group_by
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL的sql_mode模式说明及设置
​ sql_mode是个很容易被忽视的变量,默认值是空值,在这种设置下是可以允许一些非法操作的,比如允许一些非法数据的插入。在生产环境必须将这个值设置为严格模式,所以开发、测试环境的数据库也必须要设置,这样在开发测试阶段就可以发现问题.
​
sql model 常用来解决下面几类问题
(1) 通过设置sql mode, 可以完成不同严格程度的数据校验，有效地保障数据准备性。
(2) 通过设置sql model 为宽松模式，来保证大多数sql符合标准的sql语法，这样应用在不同数据库之间进行迁移时，则不需要对业务sql 进行较大的修改。
(3) 在不同数据库之间进行数据迁移之前，通过设置SQL Mode 可以使MySQL 上的数据更方便地迁移到目标数据库中。
​
sql_mode常用值如下:
​ ONLY_FULL_GROUP_BY:
​ 对于GROUP BY聚合操作,如果在SELECT中的列,没有在GROUP BY中出现,那么这个SQL是不合法的,因为列不在GROUP BY从句中
​ NO_AUTO_VALUE_ON_ZERO:
​ 该值影响自增长列的插入。默认设置下,插入0或NULL代表生成下一个自增长值。如果用户 希望插入的值为0,而该列又是自增长的,那么这个选项就有用了。
​ STRICT_TRANS_TABLES:
​ 在该模式下,如果一个值不能插入到一个事务表中,则中断当前的操作,对非事务表不做限制
​ NO_ZERO_IN_DATE:
​ 在严格模式下,不允许日期和月份为零
​ NO_ZERO_DATE:
​ 设置该值,mysql数据库不允许插入零日期,插入零日期会抛出错误而不是警告。
​ ERROR_FOR_DIVISION_BY_ZERO:
​ 在INSERT或UPDATE过程中,如果数据被零除,则产生错误而非警告。如 果未给出该模式,那么数据被零除时MySQL返回NULL
​ NO_AUTO_CREATE_USER:
​ 禁止GRANT创建密码为空的用户
​ NO_ENGINE_SUBSTITUTION:
​ 如果需要的存储引擎被禁用或未编译,那么抛出错误。不设置此值时,用默认的存储引擎替代,并抛出一个异常
​ PIPES_AS_CONCAT:
​ 将"||"视为字符串的连接操作符而非或运算符,这和Oracle数据库是一样的,也和字符串的拼接函数Concat相类似
​ ANSI_QUOTES:
​ 启用ANSI_QUOTES后,不能用双引号来引用字符串,因为它被解释为识别符
​ ORACLE的sql_mode设置等同:PIPES_AS_CONCAT, ANSI_QUOTES, IGNORE_SPACE, NO_KEY_OPTIONS, NO_TABLE_OPTIONS, NO_FIELD_OPTIONS, NO_AUTO_CREATE_USER.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d4ef7e2e2ff648d735b1bb0da09cc22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/533ce2fb156e06b250d8d404d102b13e/" rel="bookmark">
			python学习笔记（Map,  Filter,   Reduce）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Map
Map 会将一个函数映射到一个输入列表的所有元素上（简言之： 就是将列表的所有元素作为函数的参数传递进去）。它的规范是：
map(function_to_apply, list_of_inputs)
例子如下，分别使用普通方法和map方法
普通方法
items = [1, 2, 3, 4, 5] squared = [] for i in items: squared.append( i ** 2) map方法
items = [1, 2, 3, 4, 5] squared = list(map(lambda x : x**2, items)) 多数时候，我们一般使用lambda函数来配合map。不仅用于列表输入，我们甚至可以用于一列表的函数。
def multiply(x): return (x*x) def add(x): return (x+x) funcs = [multiply, add] for i in range(5): value = map(lambda x : x(i) , funcs) print(list(value)) 运行的结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/533ce2fb156e06b250d8d404d102b13e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/193155e39e80bfff8ab844376b09f7d4/" rel="bookmark">
			数据分析---疫情数据可视化（地图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据分析---疫情数据可视化（地图） 安装pyecharts库爬取所需要的数据（网上直接爬取数据）绘制全国地图绘制省份地图（以湖北省为例）在全国地图上加入湖北省数据 导入数据（本地导入数据）获取代码 安装pyecharts库 pyecharts属于第三方库，需要从https://pypi.org/project/pyecharts/#files 手动下载安装
下载后，打开“Anaconda Command Prompt”
输入：pip install 所在路径+pyecharts-1.7.0-py3-none-any.whl
安装后可再输入：pip list
查看是否安装成功
import requests import json from pyecharts.charts import Map, Geo from pyecharts import options as opts from pyecharts.globals import GeoType, RenderType 网上有很多博主的文章写的是from pyecharts import Map, Geo ；这是因为版本不同，现在需要加“.charts”
爬取所需要的数据（网上直接爬取数据） url = 'https://view.inews.qq.com/g2/getOnsInfo?name=disease_h5' datas = json.loads(requests.get(url=url).json()['data']) china = datas['areaTree'][0]['children'] data = [] for i in range(len(china)): data.append([china[i]['name'], china[i]['total']['confirm']]) 注：今天犯了一个小错误，我在往列表中添加元素时，原来打成了data=data.append()结果报错“AttributeError: ‘NoneType’ object has no attribute ‘append’”，这是因为append会修改data本身，并且返回None。不能把返回值再赋值给data。
print(data) [['湖北', 67786], ['广东', 1356], ['河南', 1273], ['浙江', 1227], ['湖南', 1018], ['安徽', 990], ['江西', 935], ['山东', 760], ['江苏', 631], ['重庆', 576], ['四川', 539], ['黑龙江', 482], ['北京', 437], ['上海', 350], ['河北', 318], ['福建', 296], ['广西', 252], ['陕西', 245], ['云南', 174], ['海南', 168], ['贵州', 146], ['香港', 137], ['天津', 136], ['山西', 133], ['甘肃', 129], ['辽宁', 125], ['吉林', 93], ['新疆', 76], ['宁夏', 75], ['内蒙古', 75], ['台湾', 50], ['青海', 18], ['澳门', 10], ['西藏', 1]] confirm = datas['chinaTotal']['confirm'] suspect = datas['chinaTotal']['suspect'] dead = datas['chinaTotal']['dead'] heal = datas['chinaTotal']['heal'] lastUpdateTime = datas['lastUpdateTime'] print(confirm, suspect, dead, lastUpdateTime) 81017 147 3181 2020-03-14 10:03:41 china_total = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/193155e39e80bfff8ab844376b09f7d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a4c8339487ceab805b4c35f8bbc18c0/" rel="bookmark">
			如何在windows安装NET Framework 3.5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何在windows安装NET Framework 3.5 NET Framework 3.5百度网盘安装包 链接：https://pan.baidu.com/s/1XwcoQiWbyu8a_VavBtLSsA
提取码：5cro
使用方法 1.将【sxs】文件复制到C盘（用完后可以删除的）
2.右键以管理员身份运行【NET Framework 3.5.bat】文件
3.等待，执行完毕退出即可
如何辩解电脑里是否装有Microsoft .NET Framework 3.5？ 第一步： 打开【我的电脑】，在地址栏输入 %systemroot%\Microsoft.NET\Framework
第二步：从列出来的文件夹中，我们可以看到v1.0.3705 v2.0.50727 v3.0 v3.5
而这些目录显示的最高版本号即本机Microsoft .NET Framework 版本号，也就是3.5的。
如果你最高版本的目录只有v2.0.50727 那就是本地只有安装.net framework2.0 的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/231c505bf834f416bf72a91244360f24/" rel="bookmark">
			(K8S实践2)Pod常用操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、创建pod的两种方式 1.命令方式
①创建命令：
#kubectl run kubia --image=luksa/kubia --replicas=3
②查看资源：
#kubectl get pod -o wide
2.文件方式
#vim nginx-master.yaml
apiVersion: extensions/v1beta1 #描述文件遵循extensions/v1beta1版本的Kubernetes API kind: Deployment #创建资源类型为Deployment metadata: #该资源元数据 name: nginx-master #Deployment名称 spec: #Deployment的规格说明 replicas: 3 #指定副本数为3 template: #定义Pod的模板 metadata: #定义Pod的元数据 labels: #定义label（标签） app: nginx #label的key和value分别为app和nginx spec: #Pod的规格说明 containers: - name: nginx #容器的名称 image: nginx:latest #创建容器所使用的镜像 ①执行创建命令
#kubectl create -f nginx-master.yaml
②查看创建的资源
#kubectl get deployments -o wide
#kubectl get pod
二、进入pod 进入pod kubia-66c8b6d4fc-qhsrd(master节点)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/231c505bf834f416bf72a91244360f24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c87b895519eb1d84c11de5157474f393/" rel="bookmark">
			洛谷题解——P1443：马的遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目相关 题目链接 洛谷，https://www.luogu.com.cn/problem/P1443。
题目描述 有一个 n*m 的棋盘 (1 &lt; n, m &lt;= 400)，在某个点上有一个马，要求你计算出马到达棋盘上任意一个点最少要走几步？
输入格式 一行四个数据，棋盘的大小和马的坐标。
输出格式 一个 n*m 的矩阵，代表马到达某个点最少要走几步（左对齐，宽 5 格，不能到达则输出 -1）。
输入样例 3 3 1 1 输出样例 0 3 2 3 -1 1 2 1 4 题目分析 题意分析 告诉我们一个棋盘大小为 n*m，再告诉我们一个起点坐标 x,y。要求我们算出到棋盘所有点最少要走几步。
从最少这个字可以看出，本题可以考虑使用 BFS 来实现。
样例数据分析 根据样例输入，我们知道棋盘大小为 3*3，开始位置为 1,1。注意，本题开始的不是零。下面我们来绘制一下到各个点需要的最少步数。我们知道不管国际象棋还是中国象棋，马都是走“日”字。如下图所示：
也就是说，马的可能走法有 8 种。可以参考如下定义方式：
//坐标定义 typedef struct _POS { int x, y; } POS; //马所有移动方式定义 const POS moves[] = {{1,-2}, {2,-1},{2,1},{1,2},{-1,2},{-2,1},{-2,-1},{-1,-2}}; 1,1 点 就是自己，自然不需要移动已经到了，也就是说输出 0。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c87b895519eb1d84c11de5157474f393/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d10c500c4ff0826306b0d16c08ef5ff/" rel="bookmark">
			Sql Server如何彻底清除字符串里的普通空格以及特殊的空格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sql Server如何彻底清除字符串里的普通空格以及特殊的空格 1. 普通空格 1.1 如果是前后的空格，使用LTrim()函数和RTrim()函数即可，例如：LTrim(RTrim(string))
1.2 中间的空格，使用replace()函数替换，例如：Replace(string,' ','')
2. 一些特殊的空格： 特殊空格看起来跟普通的空格一模一样，但使用LTrim()函数、RTrim()函数和replace()却无法替换掉其空格，这就需要特殊的方法去找出特殊的空格。
2.1 主要思路 我们这时候还是用Replace()函数替换，不过我们先找出这个特殊的空格的ASCII码值。需要用到ascii()函数，通过ascii()函数，找出空格的ascii值，然后用replace()函数+char()函数来替换。 例如通过ascii函数，找到这个特殊空格的ascii值为9，则使用replace(string,char(9),'')来替换 。
按照上面的方式，主要就是怎么找出空格的ascii值。
2.2 方法 如name（字符串类型）字段中有个值是" zhangsan"，前面存在一个特殊的空格 ，这时我们使用：
select ascii(replace(name,'zhangsan','') from tablename where name=' zhangsan' 把“13854016900”的值取出，然后替换掉文本部分，
剩下的就是特殊的那个空格，就能通过ascii函数来获取这个空格ascii值，得到ASCII码值为 9，因此使用replace(name,char(9),'')来替换 。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a9390d34ec1d678cc3f5cf1edf6a421/" rel="bookmark">
			往年四级真题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 近20年四级真题分享：
链接：点击下载
tiquma：lvkn 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b475f2443ce488c613fe63c0fdf38a2a/" rel="bookmark">
			SPSS教程：手把手教你设置哑变量以及解读结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我们将结合SPSS软件，向大家介绍在回归模型中何如实现哑变量的设置，并对引入哑变量后的模型结果进行解读。
Logistic /Cox回归
在SPSS中，Logistic回归和Cox回归设置哑变量的方式是一致的，因此本文以Logistic回归为例进行说明。
一、研究实例
某研究人员拟探讨不同种族人群中某疾病发病风险有无差异，收集了4种不同种族人群的相关数据资料（1=Black美国黑人，2=White美国白人，3=Indian美国印第安人，4=Asian亚裔美国人）。
根据数据类型判断，种族为无序多分类资料，需要将种族转化为哑变量后，进行Logistic回归。
二、SPSS操作
1. Analyze → Regression → Binary Logistic，进入到Logistic回归模块
2. 将Event选入Dependent框中，将Gender、Age、Race选入Covariates框中
3. 点击Categorical进入定义分类变量的对话框，将需要转化的变量Race选入Categorical Covariates框中，点击Contrast旁的下拉框选择Indicator，Reference Category设置为First，即设定第一个分类为参照。
在本次研究中，Race=1为黑人，即我们选择黑人作为参照。最后再点击Change确认更改为Race（Indicator（first））。
在选择哑变量编码方式时，Contrast下拉选项一共提供了7种编码方式：
(1) Indicator（指示对比）：用于指定某一分类为参照，指定的参照取决于Reference Category中选择Last还是First，即只能以该变量的第一类或者最后一类作为参照。Indicator为默认方法，也是我们最常用的设置参照类的方法。
(2) Simple（简单对比）： Simple和Indicator两个方法虽然参数编码不同，但其实质是一样的，均为各分类分别与参照进行相比。
(3) Difference（差异对比）：即该分类变量的某个分类，与前面所有分类的平均值进行比较，此法与Helmert法相反，因此也叫做反Helmert法。此选项常用于有序分类变量。
(4) Helmert（赫尔默特对比）：即该分类变量的某个分类，与其后面所有分类的平均值进行比较，同样也适用于有序分类变量。
(5) Repeated（重复对比）：即该分类变量的各个分类，均与前面相邻的一个分类进行比较，此时前一分类为参照。
(6) Polynomial（多项式对比）：它假设各个分类间隔是等距的，只能用于数值型的变量。（注意：如果此时原始变量为字符型，例如A、B、C、D，在SPSS中使用该方法时它会提示Polynomial contrasts may not be specified for string variables。而对于其他6种方法是允许原始变量是字符型，SPSS可以将其自动转化为0或1形式的哑变量。）
(7) Deviation（偏差对比）：即除参照外，其余每一个分类都与总体水平相比，此时每个分类的回归系数都是相对于总体水平而言的改变量。
4. 点击Continue回到主对话框，再点击OK完成操作。
三、结果解读
1. 结果显示， SPSS将 Race自动转化为3个哑变量，分别为Race(1) (2) (3)，代表白人、印第安人和亚裔人，参照为黑人。在α=0.05的检验水准下，Race(1) (2) (3) 回归系数检验P值均&lt;0.05，提示白人、印第安人和亚裔种族某疾病的发生风险均与黑人种族之间存在统计学差异。
2. 白人、印第安人和亚裔相对于黑人种族，其OR值和95% CI分别为0.247(0.102, 0.598)、0.181(0.070, 0.466)、0.132(0.049, 0.357)，提示白人、印第安人和亚裔人中该疾病的发生风险均显著低于黑人种族。
多重线性回归
针对多重线性回归，我们需要通过重新编码的方式，先将其转换为哑变量，然后再带入到回归模型中。
一、研究实例
仍然以上面的研究实例进行介绍，某研究人员拟探讨不同种族人群中BMI有无差异，收集了4种不同种族人群的相关数据资料（1=Black美国黑人，2=White美国白人，3=Indian美国印第安人，4=Asian亚裔美国人）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b475f2443ce488c613fe63c0fdf38a2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5957719911f53692e19724893bc4262c/" rel="bookmark">
			模型迁移错误常见问题“django.db.utils.InternalError: (1050, “Table ‘django_content_type‘ already exists“)“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		django迁移模型常见错误django.db.utils.InternalError: (1050, “Table ‘django_content_type’ already exists”)" 这个问题经常出现在迁移模型时报错，表示该表已经存在，说明之前进行过模型的迁移操作。
例如：
一般情况下出现这种错误，是因为在迁移过后进行了数据表的修改【字段的修改】，而再次进行数据表的迁移便会报错，因为之前该表已经存在，重复迁移。
解决办法：
1、先删除模块中迁移时生成的文件xxx_.initial.py文件
如： 0001_initial.py文件
注意：只删除该文件
2、然后依次输入以下命令
1、python manage.py makemigrations --fake 2、python manage.py migrate --fake 输入后的结果如下：
3、然后执行迁移命令
1、python manage.py makemigrations 2、python manage.py migrate 结果如下：
即可解决问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2700947647ead79fe8bc9198a1b55e5a/" rel="bookmark">
			raid 0  raid1  raid5  raid10(0&#43;1)的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 RAID概念RAID分类1.raid02.raid13.raid54.raid 10 raid分为 硬raid 和 软raid总结 RAID概念 RAID（Redundant Array of Independent Disks，独立磁盘冗余阵列）可以提供较普通磁盘更高的速度、安全性，所以服务器在安装时都会选择创建RAID。
RAID的创建有两种方式：软RAID（通过操作系统软件来实现）和硬RAID（使用硬件阵列卡）；在企业中用的最多的是：raid1、raid10和raid5。不过随着云的高速发展，供应商一般可以把硬件问题解决掉。
企业用的最多的： RAID0 RAID1 RAID5 RAID10
RAID分类 1.raid0 raid0 就是把多个（最少2个）硬盘合并成1个逻辑盘使用，数据读写时对各硬盘同时操作，不同硬盘写入不同数据，速度快。 2.raid1 raid1就是同时对2个硬盘读写（同样的数据）。强调数据的安全性。比较浪费。
3.raid5 raid5也是把多个（最少3个）硬盘合并成1个逻辑盘使用，数据读写时会建立奇偶校验信息，并且奇偶校验信息和相对应的数据分别存储于不同的磁盘上。当RAID5的一个磁盘数据发生损坏后，利用剩下的数据和相应的奇偶校验信息去恢复被损坏的数据。相当于raid0和raid1的综合。
4.raid 10 raid10就是raid1+raid0，比较适合速度要求高，又要完全容错，当然￥也很多的时候。最少需要4块硬盘（注意：做raid10时要先作RAID1，再把数个RAID1做成RAID0，这样比先做raid0，再做raid1有更高的可靠性）。
另外在raid1或raid5的基础上在加个热备（即在插入块同型号的空硬盘），热备的概念是 平时不参与阵列，就是一块空盘,在阵列中某一块盘坏掉了 ,热备才顶上。
raid分为 硬raid 和 软raid 如果由CPU执行硬盘控制器的驱动程序代码完成，就是软RAID；如果由RAID卡上的主控芯片完成，就是硬RAID。
总结 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d06f17d9855f07c198b943e2606e16d4/" rel="bookmark">
			正弦定理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正弦定理（The Law of Sines）是三角学中的一个基本定理。
定理定义 在任意 中，角A、B、C所对的边长分别为a、b、c，三角形外接园的半径为 R，直径为 D。则有：。即，一个三角形中，各边和所对角的正弦之比相等，且该比值等于该三角形外接园的直径（半径的2倍）长度。
证明 做一个边长为a，b，c的三角形，对应角分别是A，B，C。从角C向c边做垂线，得到一个长度为h的垂线和两个直角三角形。如图所示。
很明显： ，。因此 ，以及 。
同理，也可以得到 。
定理意义 正弦定理指出了任意三角形中三条边与对应角的正弦值之间的一个关系式。由正弦函数在区间上的单调性可知，正弦定理非常好地描述了任意三角形中边与角的一种数量关系。
定理推广 在任意 中，角A、B、C所对的边长分别为a、b、c，三角形外接园的半径为 R，直径为 D。正弦定理进行变形有：
1、a=2*R*sinA，b=2*R*sinB，c=2*R*sinC
2、a*sinB=b*sinA，b*sinC=c*sinB，a*sinC=c*sinA
3、a:b:c=sinA:sinB:sinC
4、，等比，不变
5、S=，三角形面积公式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c39b2b4a249764a06a93434cd35f2d74/" rel="bookmark">
			提升性能，避免伪共享(False Sharing)-缓存行填充7个long
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		技巧: padding long类型 1到7，加x变量，总共 8 * 8 = 64 个字节 等于 64位计算机 一个内存行的大小。
在多线程操作某一变量的时候，这样利用padding声明的x单独读享一个缓存行，而不是与其他变量共享内存行，所以在读取或写入变量时不用每次都因为volatile或其他语义重新load x的内存及取值，所以速度更快。
做一个测试，利用两个线程对一个volatile变量循环赋值，看看分别的耗时差多少：
public class VolatileTest { private static class Padding{ //这句注释掉会发现耗时变成了270 public volatile long p1,p2,p3,p4,p5,p6,p7; } private static class T extends Padding{ public volatile long x = 0L; } public static T[] arr = new T[2]; static { arr[0] = new T(); arr[1] = new T(); } public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(()-&gt;{ for(long a=0;a&lt;1000_0000L;a++){ arr[0].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c39b2b4a249764a06a93434cd35f2d74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad5af3f3cecea08802b0e54d45618907/" rel="bookmark">
			人机融合智能与深度态势感知
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：人机与认知实验室
【“常无欲以观其妙，常有欲以观其徼。”，意思是身处物外可以以旁观者的身份来看待事物，身处事内则要考虑各种极限。】
0 引言 伴随着深度学习[1]、强化学习[2]等新一代人工智能技术的发展，智能化已成为社会发展的重要趋势。人工智能（AI）的概念在1956年的达特蒙斯会议上首次被提出，其理论思想逐渐演变为三大流派，分别是联结主义、行为主义和符号主义。三种理论都已经有了深入的研究并在图像识别[3]、自然语言处理[4]、语音识别[5]等领域有了实际应用，但是每种理论在取得了卓越的成就的同时也均存在不足之处。
自古希腊人将欧几里得几何归纳整理成欧几里得公理体系，到牛顿编撰的鸿篇巨著《自然哲学的数学原理》，人类的现代数学和物理知识被系统化整理成公理体系。符号主义的主要思想便是应用逻辑推理法则，从公理出发推演整个理论体系[6]。但是符号主义思想面临四个主要挑战：1.知识的自动获取；2.多元知识的的自动融合；3.面向知识的表示学习；4.知识推理与运用。符号主义虽通过模拟人的思维过程实现人工智能，但在以上四个问题难以有突破性的结果[7]。联结主义的基本思想则是模拟人类大脑的神经元网络，将人工神经网络设计成多级结构，低级的输出作为高级的输入[6]。但该方法限制于在具有可微分、强监督学习、封闭静态系统任务下才会得到良好的结果，并且训练得到的结果也限制于给定条件的问题上。行为主义思想通过不断模仿人或生物个体的行为超越原有的表现来推进机器的进化，主要依赖具有奖惩控制机制的强化学习方法。然而该方法的缺点在于过于简化人类的行为过程，忽略人类心理的内部活动过程，忽略意识的重要性[7]。
人工智能的优势在于庞大的信息存储量和高速的处理速度，但是无法处理如休谟之问，即从“是”（being）能否推出“应该”（should），也即“事实”命题能否推出“价值”命题；也无法处理情感的表征问题。人工智能尝试通过大数据与逐步升级的算法实现人的情感与意指依旧没有办法实现跨越[7]。
1. 智能的产生 有关智能生成的机理，一直是许多领域关注的焦点问题，涉及面之广、深很是少见，初步梳理可能会与这样几个最基本的问题有关：认知生成的机理、知识生成的机理、意义生成的机理、情感生成的机理、情境生成的机理，甚至还避不开哲学的基本问题：世界的本源是物质的还是意识的？我是谁？从哪里来？到哪里去？认识世界的手段如何？语言是破解人类智能的钥匙吗？心灵与现象的关系如何？等等……
这个问题远不是几位数学家、哲学家、物理学家、计算机专家、自动化专家、社会学者、心理学学者、语言学工作者开几次研讨会所能解决的，历史已经证明，莱布尼兹、维特根斯坦、爱因斯坦、薛定谔、图灵、维纳、香浓、贝塔朗菲、冯诺依曼、西蒙、明斯基、辛顿等先驱大师的智能思想混合在一起并没有发生期待中的化学变化。这个问题有点像爱情生成的机理一样，有一千对罗密欧与朱丽叶、一万双许仙与白娘子的故事就有成千上万的解释和理解。对人类而言，这是一个永恒的话题，是世世代代追求的梦中情人和理想家园。无论如何，“没有人，就没有智能，也就没有人工智能”这个道理依然存在实用。
智能的生成机理，也许就像哲学中“我”的三个问题（谁？哪里来？哪里去？），本质是文化问题，智能也是多种文化交互作用的结果。其中休谟之问（能否从客观事实中推出主观价值来？即如何从“是”/being推出“应该”/should问题）可能是一个切入点，几乎所有的智能生成都将涉及到主观目的和动机（无论有意或无意），都会与情境中的客观事实变化相关。而解答休谟之问的关键则是各种显隐类比机制的破解（如潜意识就是隐类比），对此，侯世达在《表象与本质》一书做了很好的思考，但仍有一些问题值得商榷，譬如事物的表象与本质常常互为嵌套，表里不一，似是而非等。实质上，人类的理解过程就是在事实being中寻找到了价值should的过程。有词典解释为：to know the meaning of……，这个know是主体的，这个meaning也是个性化的。所以，严格意义上讲，理解就是： 自以为是；而智能则是：实事求是。智能是不分领域的，但是可以跨域迁移的，所以军事智能准确地讲应是智能军事，如同智能农业、智能交通、智能医疗等，这些都是智能在不同领域方向的应用，但在许多基本机理方面是相通的，如在输入端的表征方式、在理解融合过程中的推理机制、在输出端的决策辅助手段等。
近来，Bengio说深度学习需要被修正。他认为，只有超越模式识别的范围，更多地了解因果关系，才能实现真正的人工智能革命。换句话说，他说，深度学习需要开始问为什么事情会发生。认知科学实验也表明，认识因果关系是人类发展和智力的基础，尽管目前还不清楚人类是如何形成这种知识的。这些观点也对也不对，对是因为他比机器学习前进了半步——不再仅仅依靠统计的相关性分析机械前行，不对是因为他还没有走出西方科技工作者优良的传统思路：仍把因果关系看成是求科学根问技术底的一副万能良药。实际上，类比、比较、比喻、比方、相似才可能是实现创造性智能的最重要途径（包括拟合生成各种各样的新概念）。
智能，包括人工智能，都是复杂系统，其中的许多事情不是都能用逻辑思维解释清楚的，里面还有大量的非线性、非逻辑成分，可解释性、终身学习、动态表征、强弱推理都需要类比，但类比的机制机理远远不是单纯用科学技术所能解决了的，尤其涉及情感、情境、虚体等，更是如此！试图单纯用数学，尤其是用现代不完备的数学解决智能或人工智能的主要核心问题，无异于缘木求鱼、画饼充饥、水中捞月，如同拿着木棒、石头造飞机和火箭一般，原因很简单：定性的真东西尚都在遥遥无期中探索，定量的只能是自动化。
2. 何谓博弈智能 博弈智能不是博弈+人工智能，而是其中既包括机的自洽性过程计算也包含有人的矛盾性有向算计，博弈智能如生物进化一样不太讲究多强大、多聪明，而更关注任务执行中的恰当变通，它不是包治百病的神药，而是对症下的准药，最高境界是达到不战而屈人的目的[8]。
当前博弈系统的自主化与弱通讯、无通讯条件下的高级自动化等价，而现代的博弈无人化侧重于统计概率下的机械化+自动化。即使科技发展出的装备再先进，其形成的产品或系统也只是机器计算，01的数理基础仍然没有变，就像5G、6G、…NG一样，若没有意向性和价值性出现，系统本质上还是机器。
博弈智能的本质是对抗性角逐，即要摧毁对方的博弈意志；人工智能的本质是服务性智力，满足对象的需求。博弈智能以损人为本，民智以助人为乐。AI作为计算的逻辑实质上是一种“主体转向”，“博弈智能的算计逻辑”是当仁不让地以人类为主体，研究的对象是对手的认知、思维、智能种种，强调应是什么应干什么等问题，博弈智能不但涉及手段还包括意志和随机偶然性；AI计算的逻辑则是将计算机作为信息处理的主体，侧重是什么干什么问题，研究的是计算机的处理方式以及人与计算机的互动关系。
未来的博弈智能不是功能性的工具（锤子）而是能力性的软件+硬件+湿件，它不太讲究事实和形式，多涉及价值和意义。它会不断地超越军种、行业、领域的格局和前瞻的战略视野，是颠覆性技术创新的重要支撑。
在20世纪50年代末，美国军方的共识是，其指挥与控制系统不能满足日益复杂和快速多变的军事环境下快速决策的紧迫需求，1961年肯尼迪总统要求军队改善指挥与控制系统。在该国防安全重大问题提出以后，国防部指派DARPA负责此项目。为此DARPA成立了信息处理技术办公室，并邀请麻省理工学院约瑟夫•利克莱德（J.C.R.教授出任首任主任。虽然是军方的迫切需要和总统钦定的问题，但是DARPA没有陷入军种的眼前需求和具体问题，而是基于利克莱德提出“人机共生”的思想，认为人机交互是指挥与控制问题本质，并就此开展长期、持续的研究工作。此后，IPTO遵循着利克莱德的思想逐渐开辟出计算机科学与信息处理技术方面的很多新领域，培育出ArpaNet等划时代颠覆性技术，产生了深远的影响，直至今天。
博弈智能化不是无人化也不是自主化。自主化指自己作主，不受别人支配程度；无人化是指能在无人操作和辅助的情况下自动完成预定的全部操作任务的程度；而博弈智能主要是实现更高价的觉、察并实施诈和反诈，是人机环境系统融合的深度态势感知，是人机融合的“钢”（装备）+“气”（精神）。
当前，许多人认为博弈智能就是博弈+AI，还有人认为博弈智能就是自主系统或者无人系统，大都是没有认清对抗博弈的实质使然。另外一个需要警惕的博弈智能问题是：单纯机器计算的越精细、越准确、越快速，危险性越大，因为对手可以隐真示假、造势欺骗、以真乱假，有时候系统越强越脆弱，所以有专家参与的人机融合博弈智能相对显得更重要、更迫切、更有效。
3. 人机融合智能 人、机、环境系统之间的相互作用产生了智能，这不仅是一个科学问题，也包含非科学部分的研究（如人文艺术、哲学宗教），其中，人是复杂系统，机是相对简单的系统，环境的涨落变化非常大，所以我们研究的人机环境系统既有“确定性”，又有“随机性”，就成为“复杂的巨系统”。钱学森先生认为针对“复杂的巨系统”人类目前还没有找到解决的一般原理和方法，人机融合系统的深度态势感知理论可能就是一种有益的尝试。
有人说：没有经过人机融合合作训练过的智能系统就是弱智系统。这句话的背后隐含着这样一个事实：当前，人与机是不同的，而且，两者之间是失调、失配的。其实，人机的职责分别在于准度和精度，准度涉及方向，精度关联过程。机器具有功能，产生不了能力，所以处理不了有意义有价值的联系，也没有形成默会的知识和常识。人与人沟通时，不说出的事物常常更重要，人机交互时则不然，主要是机器不了解这些潜在的前提和线索，只好左顾右盼，插浑打科，所聊非所聊，所答非所问，就像现在的聊天、问答机器人一样，没有主体性与客体性之间的理解揣摩，没有博弈性语言学，也没有主体间一对一的语义出现，只能够陈述有限的事实，不能够判断无限的价值。总之，人机中的时空、逻辑机制不一致是引发融合困难的关键，人机融合智能的瓶颈还是如何实现有理、有利、有节的节奏和韵律。
人机融合智能系统是一个资源调度中心，一个供给侧资源调度员，将人的湿件与机器的硬件、软件匹配起来，在任务环境中进行资源的分配和控制。就如同一个单位指挥调度机构，使得人、物、环境发挥更高的工效。即使同一个人在不同阶段的逻辑也不一定完全一致，机器最好能够在人犯糊涂时进行辅助矫正。人机系统要想充分发挥功能，就需要有相应各件的支持与配合。只有进行软硬湿结合，软件硬化，硬件软化，机件人化，人件机化才能最大程度发挥人机系统资源调度的作用，这就是适配性的问题。人的智能在于事前的无数据，机器的智能在于事后的有数据，而数据的价值和意义是由人确定的，所以是可变的，所以有机无人的数据是注定无用的。智能是一种虚实融合的非物质体，有实构，也有虚构，其中“非存在的有”就是虚构的重要组成成分。就像摄影、体育、科研、生活一样……这种“非存在的有”可以或诱发或唤醒出某种某程度理解之外的理解，并通过认知迁移、旋转变异出意料之外，进而形成一系列新的感、觉、受、动、察、知……
如果把人和机的智能都看成若干智能单元构成，那么人机融合则看成智能单元之间的交换，交换通畅无碍趋于稳定，则会形成稳定的融合价。需要强调的是，人、机的智能单元不同，人的是认知智能单元，机的是计算智能单元，认知包括感性和理性，计算主要与理性有关。认知是真实世界的反映表征，计算是符号系统的仿真模拟，而所有的仿真模拟都是近似的。如何把主客观有机统一起来，这就需要更深层次的探索和思考。
主观和意识都是一种心理性存在，而不是常规意义上的物理性存在，尽管它们依托在了动物物理性存在的高级形式——生理性存在平台上存在。但是，它们终究是存在，而不是非存在。人们通过使用它们不仅可以解释说明世界，而且还可以构建改变世界。所有的科学技术、宗教信仰、人文艺术都是通过这种心理性存在与各种物理性存在相互作用而衍生出来的。机器中的软件和硬件本身就是物理性存在，是为了被使用而存在着；而人及其智能永远不会为需要它的东西现存着，它被并入了利用它的系统存在者之中。机器总是具备某种功能，是If…then…do；而人是具有某种能力，是For…then…do。如果智能拥有做什么的能力，首先是因为人拥有能力。机器可用于制造，是being，但机器本身不存在去制造的冲动，机器绝不可能先行把自己置于制造之中。与此不同，能力是“为了……”的能力，是should，能力本身引导它做什么、如何做，能力自己把自身置于自己之所为。故而能力提供了理解人及其智能的新思路。为什么会产生人的智能?因为人的能力只有借助于智能才能实现；人为什么会有能力?因为人在世界中的存在是通过人的智能实现的。机器只能在某一场景环境中执行功能，但永远不能在一个情境世界之内生成能力，而人可以。在情境世界中人们可以感知到一种“内在关系”，该关系存在于图画和一些对象之间，而非概念和概念之间。无论这种“内在关系”存在于语词、对象还是概念之间，它都不能简单地被还原为视觉性质，它超越了视觉等“感觉”的状态空间范畴，形成了联想等“知觉”趋势特征向量空间。
机器只能在某一场景环境中执行功能，但永远不能在一个情境世界之内生成能力，而人可以。在情境世界中人们可以感知到一种“内在关系”，该关系存在于图画和一些对象之间，而非概念和概念之间。无论这种“内在关系”存在于语词、对象还是概念之间，它都不能简单地被还原为视觉性质，它超越了视觉等“感觉”的状态空间范畴，形成了联想等“知觉”趋势特征向量空间。如图1中展示的是“鸭头”或“兔头” ？
图 1
在人机融合过程中，这些问题将会变得很重要：怎样进行人机功能分配？人机何时何处何方式进行何分配？ 当人、机速度不匹配时，以人速为准较好还是以机速为准较好？人机怎样融合学习？人机怎样融合理解？人机怎样融合决策？人机怎样融合推理？人机怎样融合感知？人机怎样融合意图？数据、信息、知识、智能、智慧之间究竟是如何相互作用并转化的？
算法的实质是建立在计算逻辑基础上的理性思维，缺少非事实或反事实想象过程，即面向事实中对象、属性、关系不断变换调整的认知动态过程。显性的（明）态势感知常常是可以计算的，隐性的（暗）态势感知往往很难形成算法，但是可以被认知的，事实上，在许多态势下，认知的价值（角度）可以改变计算的事实。
因果关系，除了有事实上的，应该还有价值上的！当前，语言（包括形式化符号语言）的作用被无限化了，比如人们虚构了所谓的自我意识这一概念，自我就是（个性）经历，意识就是（群体）经验。实际上，真实的知识、概念、意识不是来源于语言，而是人、物、环境之间的交互，语言就是一个工具，就像科学技术、人工智能一样，它们促进了人类的进步，也束缚着文明的进一步发展，所以人类的语言会有不断的突破和发展。
形式化的逻辑与意向性的逻辑不同，一个是being逻辑，一个是should逻辑，类比就是尝试把两张逻辑统一起来，而且should的“逻辑”常常是being的非逻辑。人机融合智能本质上就是处理这两种“逻辑”协同问题。即如何建立形式化计算+意向性算计混合模型。
4. 深度态势感知 深度态势感知在态势感知的概念里，“势”相对比较重要，如何从各种各样的状态变量空间里及时准确地推出“势”来，是众多智能领域研究者们梦寐以求的一件事，“有态无势”的评价结论实在是令人难以接受了! 针对这个跨越，有人用跨越神经科学与神学的界限之难都不为过。其实这与大多数人的学科背景有关：偏理工少人情世故！状态空间常常与客观事实有关，但大势所趋往往与主观价值相连，比如塞翁失马是态，焉知祸福则是势。也许态、势之间的转换不仅涉及归纳与演绎，而且还可能隐藏着主客观之间的类比关系。罗素曾这样来表述类比论证，“抽象的表述看来是这样的：我们由观察我们自己知道一种‘A引起B’形式的因果规律，其中A是一种‘思想’，而B是一个物理事件。我们有时观察到某种B却不能观察到任何A，我们于是推断出一个A”（注：Rosenthal编：《心之性质》，英国牛津大学出版社1991年版，第90页。）。反之呢？如果A是一种‘物理’，而B是一个心理事件……生活中，这些心物理转化的类比比比皆是：刻舟求剑、盲人摸象、望梅止渴、守株待兔等等。哈耶克曾说，“我们的结论必定是，对我们来说心智必然永远停留在物自体王国，在那里我们只能通过直接经验了解它，而永远不能完全解释或‘引申’到其它地方。即使我们可能知道我们经验的那种精神事件能够被运转自然其它部分的同样力量所生成，我们永远不能说，哪种特定的现实事件‘对应于’某一特定的精神事件。”于是，人类不可能完全认识这个宇宙及其各种事物。结论与康德类似，但用的是哈耶克自己的逻辑。他后来的经典概念就是：“理性不及”。司马贺（西蒙）也曾用“有限的理性”去解释正常的经济活动。尤其是用理性化方法去模拟仿真真实的人机环境系统，并且缺乏感性方面的辅助和引导，就像失去了语气和语用后的人类语言只剩下干巴巴的语法一样。
在态势感知中，态就像是符合各种逻辑的语法，而势更符合非逻辑的语义和语用。由态向势的转换，实质上就是由逻辑向非逻辑的转换，就是由客观实际向主观价值的转换。也是西方哲学中讨论的一个热点：他人何在（在我的意识中，还是在之外），亦即英美分析哲学主要关心的是他人之心的认知问题，简称他心问题，也就是我们怎样知道除我们自己之外存在着具有思想、感情和其他心理属性的人的问题。事物以数据、信息、知识方式进入主体，意义是主体基于经验对事、物的关系反应，给人们产生出各种关系模型和非关系框架，并以"情感-&gt;价值+事实-&gt;意义"模式来整合认知世界的过程，其结果表现为通情达理或实事求是，这也是从状态空间（内外）产生出趋势目的的过程。对这种意义关系变化的理解有两个维度。一个维度，凸显的客观的真实性，用“态势”一词。一个维度，强调的主观的意向性，用“势态”一词。
5. 结束语 在西方伦理学界一般认为伦理学的基本问题有两个基准：一个是我们应该如何行动？另一个是我们应该成为什么样的人？前者以行为为中心，属于规范伦理学研究范畴，也是休谟之问的should问题；后者以行为者为中心，属于美德伦理学研究范畴，也是休谟之问的being问题。这与智能生成的基本问题：“事实与价值能否相符”是一致的。
智能的生成将涉及到主观目的与行为动机，并与情境中的客观事实变化密切相关。产生智能不仅需要形式化的计算，更需要意识性的类比。掌握事实性与价值性的因果关系，深研人机融合智能，开展深度态势感知，将是智能研究的重大突破。
参考文献：略
未来智能实验室是人工智能学家与科学院相关机构联合成立的人工智能，互联网和脑科学交叉研究机构。
未来智能实验室的主要工作包括：建立AI智能系统智商评测体系，开展世界人工智能智商评测；开展互联网（城市）云脑研究计划，构建互联网（城市）云脑技术和企业图谱，为提升企业，行业与城市的智能水平服务。
如果您对实验室的研究感兴趣，欢迎加入未来智能实验室线上平台。扫描以下二维码或点击本文左下角“阅读原文”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/987ea68987cb2df4223221a8ed129b53/" rel="bookmark">
			zookeeper-3.7.0源码环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://www.jianshu.com/p/6c0e17f71736
1、去GitHub下载源码 我下载的是目前最新源码 3.7.0 看之前的版本都需要用ant编译，这个没有build.xml 应该不
ps:也下载过之前的版本进行ant编译结果失败了就放弃了
2、导入进行maven编译
遇见错误和添加配置文件详见参考连接
搞了几天终于编译成功了，期间各种依赖找不到的报错
运行期间遇见错误：Caused by: java.lang.ClassNotFoundException: com.codahale.metrics.Reservoir
发现 AppClassLoader里面URl 没有这个jar包，目前尚未解决这个问题
临时解决：把main方法迁到test包就可以 ***
网络通信：
org.apache.zookeeper.server.NIOServerCnxn
org.apache.zookeeper.server.NIOServerCnxnFactory
org.apache.zookeeper.server.NettyServerCnxn
Leader选举：
接口：org.apache.zookeeper.server.quorum.Election
org.apache.zookeeper.server.quorum.FastLeaderElection
通信：org.apache.zookeeper.server.quorum.QuorumCnxManager
watcher机制：
org.apache.zookeeper.proto.WatcherEvent
数据与存储：
请求处理链：
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/99/">«</a>
	<span class="pagination__item pagination__item--current">100/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/101/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>