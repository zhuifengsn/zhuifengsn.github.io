<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="追风少年的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="追风少年的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc787eb254eefba713f35ea0672e921b/" rel="bookmark">
			PAT 两个有序链表序列的合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5-1 两个有序链表序列的合并 (20分)
已知两个非降序链表序列S1与S2，设计函数构造出S1与S2的并集新非降序链表S3。
输入格式: 输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用-1−1表示序列的结尾（-1−1不属于这个序列）。数字用空格间隔。
输出格式: 在一行中输出合并后新的非降序链表，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出NULL。
输入样例: 1 3 5 -1 2 4 6 8 10 -1 输出样例: 1 2 3 4 5 6 8 10 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; typedef struct Node* List; struct Node{ int data; struct Node *Next; }; List InitList(); void print(List l); void read(List l); void combine(List l1,List l2,List l3); int main() { List l1,l2,l3; l1=InitList(); l2=InitList(); l3=InitList(); read(l1); read(l2); combine(l1,l2,l3); print(l3); return 0; } List InitList() { List l; l=(List)malloc(sizeof(struct Node)); if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc787eb254eefba713f35ea0672e921b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a71ffd599fe5bf734aef9aa3a689c393/" rel="bookmark">
			Unix家族版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 从最初的Unics，到Unix，再到后来Unix的各种分支，Unix的发展已经成为了一部历史，仅发行版就有几百多种，放一张Unix发行版的家族族谱，大家感受一下 而在这么多发行版中，有的可能已经在计算机发展的浪潮中被淹没，但它们却真真实实促进了Unix的发展，下面看一下其中主要的家族成员： 完整发展历史戳这里Unix的前世今生biubiubiu~ 纯种Unix家谱 UNIX的历史开始于1969年ken Thompson，Dennis Ritchie（即著名的K&amp;G，C语言的发明人）与一群人在一部PDP-7上进行的一些工作，后来这个系统变成了UNIX。它主要的几个版本为： V1（1971）：第一版的UNIX，以PDP-11/20的汇编语言写成。包括文件 系统，fork、roff、ed等软件。 V4（1973）：以C语言从头写过，这使得UNIX修改容易，可以在几个月 内移植到新的硬件平台上。最初C语言是为UNIX设计的，所以C与UNIX间有紧密的关系。 V6（1975）：第一个在贝尔实验室外（尤其是大学中）广为流传的UNIX 版本。这也是UNIX分支的起点与广受欢迎的开始。1.xBSD （PDP-II）就是由这个版本衍生出来的。 V7（1979）：在许多UNIX玩家的心目中，这是“最后一个真正的UNIX，” 这个版本包括一个完整的K&amp;RC编译器，Bourne shell。V7移植到VAX机器后称为32V。 目前开发UNIX（System V）的公司是Unix System Laboratories (USL)。USL本为AT&amp;T所有，1993年初被Novell收购。Novell于1993年末将UNIX这个注册商标转让给X/Open组织。 现在几种主要的UNIX版本 ： ◆AIX：IBM的UNIX，是根据SVR2（最近已经出到SVR3.2）以及一部分BSD延伸而来，加上各种硬件的支持。具备特有的系统管理（SMIT）。 ◆386BSD：Jolitz从Net/2 software移植过来的。支持Posix，32位。 ◆FreeBSD：1.x从386BSD 0.1而来，FreeBSD 2.x版是用4.4BSD lite改写。 ◆HP-UX（HP）：旧系统是从S III（SVRx）发展面来，现在是由SVR2（4.2BSD）发展而来，目前是10.x版。 ◆Linux(x86)：遵从POSIX，SYSV及BSD的扩展，这一点从上页表中即可看出 ◆SCO UNIX（x86）：SVR3.2，目前影响较大的PC UNIX。 ◆SunOS（680x0，Sparc，i386）：根据4.3BSD，包含许多来自System V的东西。Sun的主要成果在于：NFS，OpenLook GUI标准，后来演变为Solaris 。这也是目前最著名的UNIX版本之一。 ◆Ultrix(DEC)：根据4.2BSD再加上许多4.3BSD的东西。 ◆Xenix(x86)：Intel硬件平台上的UNIX，以SVR2为基础 PS：———————-以下是个人见解，请勿随意效仿，有毒——————————–
上面几种版本其实都是Unix的分支，BSD算是比较纯种的Unix了，是柏克莱大学（Berkeley）的Bill Joy修改的，并命名为Berkeley Software Distribution (BSD)，后来可以安装在x86硬体架构上面FreeBSD即是BSD改版而来！偷偷告诉你，Bill Joy就是Sun公司的创办者！
目前在服务器应用方面，一般基于X86架构的服务器（组要是PC server）主要用Linux和windows（当然啰，说的都是企业版，稳定嘛，如RHEL，CentOS，Windows server 200× ），小型机一般用Unix，且Unix一般都是大公司和行业（如航天，勘测）内才用，一般是定制的，基于特定架构的设备，不过也有可以安装在X86架构上的Unix，如FreeBSD。
Linux系统准确来说，不是Linux分支，只能算是类Unix系统（UNIX LIKE），类Unix系统的引用现在还是很广泛的： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec6cc54ccde9c9799c626bd3d634485d/" rel="bookmark">
			unknown character &#39;0xa1&#39;是什么意思？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 0xa1是全角空格。你查查哪里输入错误了吧 i=n/100;/*分解出百位*/ 你这句话前面就是两个全角的空格，请换为半角的 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74325c6713a6ed4809313b2181690e12/" rel="bookmark">
			DatabaseError:database disk image is malformed的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发生情况：
拷贝某个Django工程代码到本地，本地一运行就报错DatabaseError:database disk image is malformed
原因：
我是用SecureFX 拷贝工程代码的，复制数据库文件db.sqlite3
会询问
当时选的是ASCII，所以拷贝到本地会报错
重新复制，选择二进制就OK了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4663ff2b84a89fff4e90d418fc82534e/" rel="bookmark">
			【按键】短按，长按，按键释放，三种模式的按键扫描程序（软件消抖动）--- 矩阵键盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		请先阅读上篇： 短按，长按，按键释放，三种模式的按键扫描程序（软件消抖动）
上面的程序适用于单个按键，那是不是也可以适用于矩阵键盘呢？ 答案是肯定的。
接下来在这里做一个简单的扩展，具体框架不用改变，所以具体的框架内容和思路在这里不详述了，自行参考上篇文章，这里就说说扩展矩阵键盘的需要改动的地方。
重点： 对于此按键盘函数的框架来说，其实单个按键与矩阵键盘程序的差别仅仅在于读取按键的方式不同。所以这里的程序只需要更改读取按键值的部分即可。
1.单个按键的读取按键值程序
CurrReadKey = P0 &amp; 0x00ff; //获取当前的键值 2.矩阵键盘的读取按键值程序 这里以4*4键盘为例 原理图如下：
将原理图中的P1看成是P0（由于赖所以直接从度娘那里盗的图），下面程序是以P0为例。
//读取按键的行数 P0 = 0xf0; KeyRow = P0; //读取按键的列数 P0 = 0x0f; KeyColumn = P0; //读取行列数，就是当前键值了 CurrReadKey = Key_Row|Key_Column; 3.只需要将单个按键的读取键值程序改为矩阵键盘的读取键值的程序即可，程序如下：
KeyScan.c文件如下：
//====================================================== //KeyScan.c //====================================================== //注意：该宏定义，定义在keyscan.h文件中 //#define KEYDEBOUNCE 0x05 //消抖动，按键扫描次数。如果连续5次都是扫描的都是相同键值，则认为是有效键值，否则是误触发 unsigned int g_uiCurrKey; //当前按键值 unsigned int g_uiLastKey; //上次按键值 unsigned int g_uiKeyScanCount; //按键扫描计数，作用：消抖动 unsigned int g_uiKeyDown; //键被按下，返回的键值。 作用：单次按键，单次返回有效键值；按住不放，也只返回被按下的一个键值 unsigned int g_uiKeyRelease; //键被释放后，返回的键值。 作用：只有按下的按键被释放后，才返回按下的键值 unsigned int g_uiKeyContinue; //键连续按键，重复返回的键值。 作用：只要按住不放，就会重复地返回相同键值 //P0口的低八位作为按键 //没有按键时，返回的是0xff， void Int_Key_Scan(void) { static unsigned short LastReadKey; //上次从IO口读取的键值 ,注意是静态变量 unsigned short CurrReadKey; //当前从IO口读取的键值 //---------------------- 需要修改的地方 --------------------------------------// unsigned short KeyRow,KeyColumn; //读取按键的行数 P0 = 0xf0; KeyRow = P0; //读取按键的列数 P0 = 0x0f; KeyColumn = P0; //读取行列数，就是当前键值了 CurrReadKey = Key_Row|Key_Column; //获取当前的键值 //-----------------------------------------------------------------------// if(CurrReadKey == LastReadKey) //如果当前读取的键值与上次从IO口读取的键值相同 { if(g_uiKeyScanCount &gt;= KEYDEBOUNCE) //首先判断是否大于等于debounce的设定值(即是，是否大于等于设定的采样次数) { //按住不放,多次响应 g_uiCurrKey = CurrReadKey; //如果是,将当前的读取值判定为有效按键值(如果是，在采样周期中，都是这个值，则判定为有效按键值) //按住不放只响应一次 if(g_uiPreKeyValue == g_uiCurrKey) { g_uiKeyDown = 0xff; //没有键值 } else { g_uiKeyDown = g_uiCurrKey; //如果不同，按键有效,(就是第一次有效值时) } //按键释放时，按键值才有效 if(g_uiCurrKey == 0xff) //当有效按键值从非0到0的状态时(即是，从有按键到无按键，表示已经释放了)，表示之前按键已经释放了 { g_uiKeyRelease = g_uiPreKeyValue; } g_uiLastKey = g_uiCurrKey; //记录上次有效按键值 } else //如果否，则debounce加一(如果否，则继续采样键值) { g_uiKeyScanCount++; } } else //如果当前读取的键值与上次从IO口读取的键值不同，说明按键已经变化 { g_uiKeyDown = 0xff; //放开按键后第一次进入扫描程序，清零g_uiKeyDown.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4663ff2b84a89fff4e90d418fc82534e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8f9bd1a9125b211f323aaf574c4ddd1/" rel="bookmark">
			Linux内核配置和编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言： 本文档的内容大部份内容都是从网上收集而来，然后配合一些新的截 图（内核版本：V2.4.19）。在每一配置项后会有一个选择指南的部份，用来指导大家怎么样 根据自己的情况来做相应的选择；还有在每一个大项和文档的最后会有一个经验谈，它是一些高手们在应对问题和处理特有硬件时的一些经验（这个还得靠各位）。 文档最后会发到网上，到时会根据网友们的回复随时进行更新。 我们的目的是让我们有一个全面的、简单明了内核编译帮手。
#make mrproper -----删除不必要的文件和目录. #make config（基于文本的最为传统的配置界面，不推荐使用） #make menuconfig（基于文本选单的 配置界面，字符终端下推荐使用） #make xconfig（基于图形窗口模式的配置界面，Xwindow下推荐使用） #make oldconfig（如果只想在原来内核配置的基础上修改一些小地方，会省去不少麻 烦） 目的都是生成一个.config文件,这三个命令中，make xconfig的界面最为友好，如果你可以使用Xwindow，你就用这个好了，这个比较方便，也好设置。如果你不能使用Xwindow，那么就使用make menuconfig好了。界面虽然比上面一个差点，总比make config的要好多了。 选择相应的配置时，有三种选择，它们分别代表的含义如下： Y－-将该功能编译进内核 N－-不将该功能编译进内核 M－-将该功能编译成可以在需要时动态插入到内核中的模块 [注：] 请大家能够发表自己的经验和想法，使本文能够不断充实！但是最好 不要发一些从网cp过来的 没有经过自己实践的文章！ 二、配置内核
有了要编译配置的内核，先来介绍怎么样配置内核。具体的步骤分为一下几 步：
1.在开始配置内核之前，首先需要通过下面的命令清除所有的临时文件、中间件和配置文件。对于一个刚从网 上下载的内核来说，它肯定是干净的，这么做只会多此一举。但是这是一个良好习惯，而且不会有坏结果。
#make mrproper
2. 然后 要了解自己系统的硬件配置情况，比如CPU的类型、主办芯片、显卡和声卡的型号等。
3. 配置 内核选项，用到的命令是：
#make &lt;config_opt&gt;
用到的配置工具有：
◆ config 基于交互式的文本配置界面。每个问题以线形格式出现,并被一个一个地回答,而且一旦作出了回答就不能再修改 了。
◆ oldconfig 同config相似，但是使用原有的配置文件， 而且只会提问有关新内核特性的问题，对于内核升级很方便。
◆ menuconfig 一个文本模式、选单驱动的配置界面。
◆ xconfig 基于Tcl/Tk的X图形配置界面。
现在开始配置内核，使用的工具为menuconfig。在命令行模式下执行下面的命 令：
#make menuconfig
在闪过几行字之后就出现内核配置界面。
使用方向键在各选项间移动；使用“Enter”键进入下一层选单；每个选项上的 高亮字母是键盘快捷方式，使用它可以快速地到达想要设置的选单项。在括号中按“y”将这个项目编译进内核中，按“m”编译为模块，按“n”为不选择（按空格键也可在编译进 内核、编译为模块和不编译三者间进行切换），按“h”将显示这个选项的帮助信息，按“Esc”键将返回到上层选单。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8f9bd1a9125b211f323aaf574c4ddd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/931b6c25573903776e41be6028733a48/" rel="bookmark">
			WPF中修改DataGrid单元格值并保存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编辑DataGrid中的单元格的内容然后保存是非常常用的功能。主要涉及到的方法就是DataGrid的CellEditEnding 和BeginningEdit 。其中BeginningEdit 是当单元格选中后，状态为可编辑状态时触发。CellEditEnding 是在单元格失去焦点后触发的事件。 对于编辑DataGrid中单元格内容的实现逻辑比较简单：
1.保存旧的单元格内容。
2.判断修改后的内容是否符合规范。
3.保存到数据库。
以下就是简单的实现逻辑，仅供参考：
前台代码：
&lt;DataGrid Grid.Row="1" x:Name="dgData" CellEditEnding="CellEditEnding" BeginningEdit="BeginningEdit"&gt; &lt;!--需要完善,除了序号，基本完善--&gt; &lt;DataGrid.Columns&gt; &lt;DataGridTemplateColumn Header=" 序号" Width="50" MinWidth="10" IsReadOnly="True"&gt; &lt;DataGridTemplateColumn.CellTemplate&gt; &lt;DataTemplate&gt; &lt;TextBlock Text="{Binding RelativeSource={RelativeSource Mode=FindAncestor,AncestorType={x:Type DataGridRow}}, Path=Header}" HorizontalAlignment="Left" VerticalAlignment="Center" Margin="10,0,0,0"&gt;&lt;/TextBlock&gt; &lt;/DataTemplate&gt; &lt;/DataGridTemplateColumn.CellTemplate&gt; &lt;/DataGridTemplateColumn&gt; &lt;DataGridTextColumn Binding="{Binding Name}" Width="*" Header="账套名称" IsReadOnly="False"/&gt; &lt;/DataGrid.Columns&gt; &lt;/DataGrid&gt; 后台代码： private void CellEditEnding(object sender, DataGridCellEditEndingEventArgs e) { string newValue = (e.EditingElement as TextBox).Text; //判断新名称和就名称是否一样 if (ZTName!=newValue) { DataAccess.IAccountDAL iaccount = DALResolver.Instance.Resolve&lt;IAccountDAL&gt;(); int count = iaccount.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/931b6c25573903776e41be6028733a48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc1246b498db0f61c9c8f0f54915d82f/" rel="bookmark">
			C语言告警warning: missing braces around initializer详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿ warning: missing braces around initializer 警告的意思是初始化缺少了大括号，也就是没有用大括号明确的区分出初始化数据的归类。
那什么时候会使用到大括号初始化呢？一般情况下初始化使用到大括号的情况是初始化结构体struct或者数组时。
首先说明一下多维数组和结构体的初始化，下面以二维数组的初始化为例（使用默认值为0）：
1、分行初始化：int a[2][3] = {{1,2,3},{4,5,6}}
在{ }内部再用{ }把各行分开，第一对{ }中的初值1，2，3是0行的3个元素的初值。第二对{ }中的初值4，5，6是1行的3个元素的初值。初始化的结果是：
a[0][0]=1；a[0][1]=2；a[0][2]=3；a[1][0]=4；a[1][1]=5；a[1][2]=6；
2、不分行以一个大括号初始化： int a[2][3]={ 1,2，3，4，5，6}
这种初始化时会将{ }中的数据依次赋给a数组各元素（按行赋值）。初始化的结果是：
a[0][0]=1；a[0][1]=2；a[0][2]=3；a[1][0]=4；a[1][1]=5；a[1][2]=6；
3、对部分元素初始化：这里分为两种情况：
a)、使用花括号的分行部分初始化：int a[2 ][3]={{1,2},{4}};这时的初始化结果就是a[0][0]=1;a[0][1]=2;a[0][2]=0;a[1][0]=4;a[1][1]=0;a[1][2]=0;
b)、只使用一个大括号进行部分初始化：int a[2][3] = {1,2,3,5},这时的初始化结果就是a[0][0]=1;a[0][1]=2;a[0][2]=3;a[1][0]=5;a[1][1]=0;a[1][2]=0;
下面说明一下结构体的初始化：
结构体的初始化方式和数组的初始化很类似。一个位于一对大括号内部、由逗号分隔的初始化值列表可用于结构体各成员的初始化。这些值根据结构成员列表的顺序写出。如果初始化列表的值不够，剩余的结构成员将使用默认的值进行初始化。
那这样下来，怎么会出现warning呢？
我们先来回顾一下结构体的定义：结构体时一种将不同类型的数据组合成一个有机整体的聚合数据类型。那么如果结构体中的成员的类型是数组或者结构体时呢？那么这个时候你再仅仅只是用一个大括号来对结构体进行初始化时，就会出现定义不明确的问题了，此外如果对一个多维数组你也只使用一个大括号来进行初始化时，同样也会出现定义不明确的问题。虽说一般编译器会自动将结构中的值按空间顺序依次进行赋值，但是编译器依旧会报一个warning，当然前提是你已经设置了-Wall或者-Wmissing-braces。例如：
struct point {
​int x;
​int y; }; struct line { ​struct point start;
​struct point end; }; typedef struct line line; int main() { ​int array1[2][2] = {11, 12, 13, 14}; ​int array2[2][2] = {{11, 12}, {13, 14}}; // ok
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc1246b498db0f61c9c8f0f54915d82f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9170e79d70f6d9b3f3ff1b6595cf959/" rel="bookmark">
			C语言结构体中的冒号用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿ 结构体中的冒号表示位域。
位域出现的原因是由于某些信息的存储表示只需要几个bit位就可以表示而不需要一个完整的字节，同时也是为了节省存储空间和方便处理。
其表示形式为：
struct 位域结构名
{
类型说明符 位域名：位域长度
}
例如：
struct bit_struct
{
int bit1:3;
int bit2:5;
int bit3:7;
}data;
其中bit_struct表示位域结构体，bit1、bit2、bit3表示对应的位域，data表示位域结构体定义的变量。整个位域结构体占用2个字节，bit1占3位，bit2占5位，bit1和bit2共用一个字节，bit3占7位，独占一个字节。
说明：
1、位域必须存储在同一个类型中，不能跨类型，同时也说明位域的长度不会超过所定义类型的长度。如果一个定义类型单元里所剩空间无法存放下一个域，则下一个域应该从下一单元开始存放。例如：所定义的类型是int类型，一共32为，目前用掉了25位还剩下7位，这时要存储一个8位的位域元素，那么这个元素就只能从下一个int类型的单元开始而不会在前面一个int类型中占7为后面的int类型中占1位。
2、如果位域的位域长度为0表示是个空域，同时下一个域应当从下一个字节单元开始存放。
3、使用无名的位域来作为填充和调整位置，切记该位域是不能被使用的。
4、位域的本质上就是一种结构体类型，不同的是其成员是按二进制位来分配的。
​
好，说到这里可能理解起来有点抽象，那下面通过一个例子来说明说有问题吧（注意：int是分正负的）！
1 /***********************************************************
2 * Function : 验证位域
3 *
4 * Result : a = 1, b = -2, c = 3, d = -2, e = -4
5 * a = 3, b = 0, c = 7, d = -1, e = -3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9170e79d70f6d9b3f3ff1b6595cf959/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18b7cec8787d4d04ad89669b44436873/" rel="bookmark">
			关于java中的各种关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java中的关键字总结：
1、Static：
由Static修饰的关键字与方法，是在编译时期已经确定其内存分配的，可以直接用 类名.static修饰的关键字或者方法直接调即可，并不用new一个对象，然后通过对象.变量或者方法来对其进行引用。
2、Final：
由Final修饰的变量值只能在初始化时对其进行一次赋值，其值在后面不能进行更改；
由Final修饰的方法，不能被重写
由Final修饰的类，不能被继承（比如String类以及常见的包装类Integer、Float、Double等）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e0273a5c03394345dcc85eaddb368bd/" rel="bookmark">
			求职感悟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		恩~ 这两天终于有找工作的感觉了、
从昨天早上开始到现在，去哪儿笔试，nice宣讲及笔试，下午学校又有个海颐的笔试以及面试。
从昨晚开始，看着Nice签到表上那一个个西交大、西工大、西电而且还都是研究生~~
今天下午的海颐也都是师大、西科大研究生，，压力大大的~~竞争太激烈~~
等找到工作再来补充。。
未完待续。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfe59c51f76035a1725ad81ef138cdfe/" rel="bookmark">
			SSL协议到底工作在OSI模型中的那一层？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、SSL是啥？ SSL（Secure Socket Layer安全套接层）以及其继承者TSL（Transport Layer Security 传输层安全）是为了网络通信安全 提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。 二、SSL具体有啥内容？ SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。 那么SSL的记录协议层和握手协议层到底是工作在什么地方，如果我们单纯的在TCP/IP模型上找的话很难找到，因为TCP/IP模型分四层：应用层，传输层，网络互联层，网络接口层，我们看到SSL协议的底层也就是记录协议层已经工作在了传输层之上了，而握手协议是建立在记录协议层上的，所以，在四层模型中，我们很难找到他们具体对应的位置，我们要到OSI七层模型中找，我们具体看看7层模型。 OSI七个层次的功能： 物理层 为数据链路层提供物理连接，在其上串行传送比特流，即所传送数据的单位是比特。此外，该层中还具有确定连接设备的电气特性和物理特性等功能。 数据链路层 负责在网络节点间的线路上通过检测、流量控制和重发等手段，无差错地传送以帧为单位的数据。为做到这一点，在每一帧中必须同时带有同步、地址、差错控制及流量控制等控制信息。 网络层 为了将数据分组从源（源端系统）送到目的地（目标端系统），网络层的任务就是选择合适的路由和交换节点，使源的传输层传下来的分组信息能够正确无误地按照地址找到目的地，并交付给相应的传输层，即完成网络的寻址功能。 传输层 传输层是高低层之间衔接的接口层。数据传输的单位是报文，当报文较长时将它分割成若干分组,然后交给网络层进行传输。传输层是计算机网络协议分层中的最关键一层，该层以上各层将不再管理信息传输问题。 会话层 该层对传输的报文提供同步管理服务。在两个不同系统的互相通信的应用进程之间建立、组织和协调交互。例如，确定是双工还是半双工工作。 表示层 该层的主要任务是把所传送的数据的抽象语法变换为传送语法，即把不同计算机内部的不同表示形式转换成网络通信中的标准表示形式。此外，对传送的数据加密（或解密）、正文压缩（或还原）也是表示层的任务。 应用层 该层直接面向用户，是OSI中的最高层。它的主要任务是为用户提供应用的接口，即提供不同计算机间的文件传送、访问与管理，电子邮件的内容处理，不同计算机通过网络交互访问的虚拟终端功能等。 这么一看大家就一目了然了，会话层的功能和表示层的功能正好和SSL记录协议和握手协议的功能一样，我想这两层协议就应该分别工作在这上面！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4906de32c6e9f3720bd739af4a971a63/" rel="bookmark">
			windows7 cpu占用过多的解决办法：关闭win7无用的服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿ win7 msdn版cpu占用很大 很容易就达到百分之百。简单优化后 可以关闭其无用服务 减少cpu占用。
win7中，可以安全关掉的服务，vista也适合，点开始，运行中输入services.msc回车，即可打开，按照里面的提示，自己来禁用自己没用的服务，注意，以下服务不是所有都对你没用，所以看仔细再关上它们，祝大家使用win7，一切顺利。 Adaptivebrightness
监视周围的光线状况来调节屏幕明暗，如果该服务被禁用，屏幕亮度将不会自动适应周围光线状况。该服务的默认运行方式是手动，如果你没有使用触摸屏一类的智能调节屏幕亮度的设备，该功能就可以放心禁用。
Application Layer Gateway Service
WindowsXP/Vista中也有该服务，作用也差不多，是系统自带防火墙和开启ICS共享上网的依赖服务，如果装有第三方防火墙且不需要用ICS方式共享上网，完全可以禁用掉。
ApplicationManagement
该服务默认的运行方式为手动，该功能主要适用于大型企业环境下的集中管理，因此家庭用户可以放心禁用该服务。
BackgroundIntelligent Transfer Service
在后台传输客户端和服务器之间的数据。如果禁用了BITS，一些功能，如 Windows Update，就无法正常运行。该服务的默认运行方式是自动，这个服务的主要用途还是用于进行Windows Update或者自动更新，最好不要更改这个服务。
BaseFiltering Engine
同样为系统防火墙，VPN以及IPsec提供依赖服务，同时也是系统安全方面的服务，如果使用第三方VPN拨号软件并且不用系统的防火墙以及ICS共享上网，为了系统资源，关闭它吧，否则就别动它。
BitLockerDrive EncryptionService
向用户接口提供BitLocker客户端服务并且自动对数据卷解锁。该服务的默认运行方式是手动，如果你没有使用BitLocker设备，该功能就可以放心禁用。
BlockLevel Backup Engine Service
估计是和备份恢复方面用的服务，无任何依赖关系，默认是手动，也从来没有看他启动过。就放那吧，不用管了。
BluetoothSupportService
如果你没有使用蓝牙设备，该功能就可以放心禁用。
CertificatePropagation
为智能卡提供证书。该服务的默认运行方式是手动。如果你没有使用智能卡，那么可以放心禁用该服务。
CNGKey Isolation
那么这个服务将被使用，建议不使用自动有线网络配置和无线网络的可以关掉。
Computer Browser
不过如果你没有使用局域网或者你根本就不想使用局域网，该功能就可以放心禁用，禁用后任然可以使用
DiagnosticPolicyService
DiagnosticPolicy服务为Windows组件提供诊断支持。如果该服务停止了，系统诊断工具将无法正常运行。如果该服务被禁用了，那么任何依赖该服务的其他服务 都将无法正常运行。该服务的默认运行方式是自动，Vista或IE7有时会弹出对话框问你是否需要让它帮忙找到故障的原因，只有1%的情况下它会帮忙修复 Internet断线的问题，可以关掉。
DiagnosticService Host
这就是帮上面DiagnosticPolicy Service做具体事情的服务，会随着上面的服务启动，可以一起关掉。
DiagnosticSystem Host
基本和DiagnosticPolicy Service/Diagnostic Service Host是同类，可以一起关掉。
DistributedLink TrackingClient:
这个功能一般都用不上，完全可以放心禁用。
DistributedTransactionCoordinator
很多应用以及SQL，Exchange Biztalk等服务器软件都依赖这个服务，可以不启动它，但不要Disabled 它。
ExtensibleAuthenticationProtocol
不用802.1x认证、无线网络或VPN 可以不启动它，不要Disabled 它。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4906de32c6e9f3720bd739af4a971a63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c48ef6ee138a98269c968f732da0e45f/" rel="bookmark">
			C&#43;&#43;类中特殊成员函数总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++中自动提供的成员函数：
●默认构造函数，如果没有定义构造函数
●默认析构函数，如果没有定义
●复制构造函数，如果没有定义
●赋值运算符，如果没有定义
●地址运算符，如果没有定义
1、默认构造函数
如果没有提供任何构造函数，C++将创建默认构造函数。
如果定义了构造函数，C++将不会定义默认构造函数，可以显示定义默认构造函数，这种构造函数没有任何参数，但可以使用它来设置特定的值。
所有参数都带有默认值的构造函数也可以作为默认构造函数，但是类只能有一个默认构造函数。
2、复制构造函数
原型：
Class_name(const Class_name &amp;)
新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用。
当函数按值传递对象或者函数返回对象时，都将使用复制构造函数。
void callme1(Student &amp;) //pass by reference
void callme2(Student ) //pass by value
由于按值传递对象将调用复制构造函数，因此应该按引用传递对象，这样可以节省调用构造函数的时间以及存储新对象的空间。
功能：
默认的复制构造函数逐个复制非静态成员（浅复制），复制的是成员的值。
警告：如果类中包含了使用new初始化的指针成员，应当定义一个复制构造函数，以复制指向的数据，而不是指针，这被称为深度复制。
3、赋值运算符
原型：
Class_name &amp; Class_name::operator=(const Class_name &amp;)
将已有对象赋给另一个对象时，将使用复制运算符
Stduent kid0("Johnson");
........
Student kid1;
kid1 = kid0;
初始化总是会调用复制构造函数，而使用=运算符也允许调用赋值运算符
由于默认赋值运算符不合适而导致的问题，解决的方法是提供赋值运算符（进行深度复制）定义。
其实现与复制构造函数相似，但是也有一些差别
1）由于目标对象可能引用了以前分配的数据，所以函数应使用delete[ ] 来释放这些数据
2）函数应当避免将对象赋给自身（判断）
3）函数通过返回一个指向调用对象的引用
Student &amp; Student::operator=(const Student &amp;st) { if(this == &amp;st) return *this; delete[] strName; len = st.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c48ef6ee138a98269c968f732da0e45f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e15d46b77bceb7ecadae9866b17c8401/" rel="bookmark">
			C&#43;&#43;运行时类型识别——RTTI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RTTI 通过运行时类型识别——RTTI，程序能够使用基类的指针或引用来检索这些指针或引用所指对象的实际派生类类型：
其主要通过两个操作符来实现：
1.typeid——返回指针或引用所指对象的实际类型；
2.dynamic_cast——将基类类型的指针或引用安全地转换为派生类型的指针或引用；
dynamic_cast 当无法为基类增加虚函数，又要使用基类的指针或引用调用派生类的函数时，可以使用该操作符代替虚函数。
与dynamic_cast一起使用的指针必须是有效的——它必须为0或者指向一个对象。
与其他强制类型转换不同，dynamic_cast涉及运行时类型检查，，它一次执行两个操作：1.它首先验证被请求的转换是否有效，即绑定到引用或者指针的对象必须为目标类型的对象（或其派生的对象），若不是，则绑定失败，当绑定失败时，如果转换到的是指针类型，则返回的结果是0，如果转换到的是引用类型，则抛出一个bad_cast类型的异常。该异常在typeinfo头文件中定义；2.只有验证转换有效时，才实际进行转化，且转换实在运行阶段而不是编译阶段；
typeid typeid操作符能够问一个表达式得出其类型。
其表达形式如：typeid(e)
e可以是仍以表达式或者类型名，如果是类类型且该类包含一个或多个函数，则表达式的动态类型可能不同于其静态类型，该操作符会在运行时计算其类型，如果是表达式（内置类型或常量），则该操作符将指出e的静态类型。
typeid操作符的结果是名为type_info的标注库类型的对象引用，它包含在头文件typeinfo中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebf9f07d7a4cfb7419dde87cd1fa8138/" rel="bookmark">
			关于FileItem
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿ FileItem类用来封装单个表单字段元素的数据，一个表单字段元素对应一个FileItem对象，通过调用FileItem对象的方法可以获得相关表单字段元素的数据。FileItem是一个接口，在应用程序中使用的实际上是该接口一个实现类，该实现类的名称并不重要，程序可以采用FileItem接口类型来对它进行引用和访问，为了便于讲解，这里将FileItem实现类称之为FileItem类。FileItem类还实现了Serializable接口，以支持序列化操作。
对于“multipart/form-data”类型的FORM表单，浏览器上传的实体内容中的每个表单字段元素的数据之间用字段分隔界线进行分割，两个分隔界线间的内容称为一个分区，每个分区中的内容可以被看作两部分，一部分是对表单字段元素进行描述的描述头，另外一部是表单字段元素的主体内容，如图1.3所示。 图 1.3
主体部分有两种可能性，要么是用户填写的表单内容，要么是文件内容。FileItem类对象实际上就是对图1.3中的一个分区的数据进行封装的对象，它内部用了两个成员变量来分别存储描述头和主体内容，其中保存主体内容的变量是一个输出流类型的对象。当主体内容的大小小于
DiskFileUpload.setSizeThreshold方法设置的临界值大小时，这个流对象关联到一片内存，主体内容将会被保存在内存中。当主体内容的数据超过
DiskFileUpload.setSizeThreshold方法设置的临界值大小时，这个流对象关联到硬盘上的一个临时文件，主体内容将被保存到该临时文件中。临时文件的存储目录由DiskFileUpload.setRepositoryPath方法设置，临时文件名的格式为“upload_00000005（八位或八位以上的数字）.tmp”这种形式，FileItem类内部提供了维护临时文件名中的数值不重复的机制，以保证了临时文件名的唯一性。当应用程序将主体内容保存到一个指定的文件中时，或者在FileItem对象被垃圾回收器回收时，或者Java虚拟机结束时，Apache文件上传组件都会尝试删除临时文件，以尽量保证临时文件能被及时清除。
下面介绍FileItem类中的几个常用的方法：
① isFormField方法 isFormField方法用于判断FileItem类对象封装的数据是否属于一个普通表单字段，还是属于一个文件表单字段，如果是普通表单字段则返回true，否则返回false。该方法的完整语法定义如下：
public boolean isFormField()
②. getName方法 getName方法用于获得文件上传字段中的文件名，对于图1.3中的第三个分区所示的描述头，getName方法返回的结果为字符串“C:\bg.gif”。如果FileItem类对象对应的是普通表单字段，getName方法将返回null。即使用户没有通过网页表单中的文件字段传递任何文件，但只要设置了文件表单字段的name属性，浏览器也会将文件字段的信息传递给服务器，只是文件名和文件内容部分都为空，但这个表单字段仍然对应一个FileItem对象，此时，getName方法返回结
第3/5页 果为空字符串""，读者在调用Apache文件上传组件时要注意考虑这个情况。getName方法的完整语法定义如下：
public String getName()
注意：如果用户使用Windows系统上传文件，浏览器将传递该文件的完整路径，如果用户使用Linux或者Unix系统上传文件，浏览器将只传递该文件的名称部分。
③．getFieldName方法
getFieldName方法用于返回表单字段元素的name属性值，也就是返回图1.3中的各个描述头部分中的name属性值，例如“name=p1”中的“p1”。getFieldName方法的完整语法定义如下：
public String getFieldName()
④. write方法
write方法用于将FileItem对象中保存的主体内容保存到某个指定的文件中。如果FileItem对象中的主体内容是保存在某个临时文件中，该方法顺利完成后，临时文件有可能会被清除。该方法也可将普通表单字段内容写入到一个文件中，但它主要用途是将上传的文件内容保存在本地文件系统中。其完整语法定义如下：
public void write(File file)
⑤．getString方法
getString方法用于将FileItem对象中保存的主体内容作为一个字符串返回，它有两个重载的定义形式：
public java.lang.String getString()
public java.lang.String getString(java.lang.String encoding) throws java.io.UnsupportedEncodingException
前者使用缺省的字符集编码将主体内容转换成字符串，后者使用参数指定的字符集编码将主体内容转换成字符串。如果在读取普通表单字段元素的内容时出现了中文乱码现象，请调用第二个getString方法，并为之传递正确的字符集编码名称。
⑥. getContentType方法
getContentType 方法用于获得上传文件的类型，对于图1.3中的第三个分区所示的描述头，getContentType方法返回的结果为字符串“image/gif”，即
“Content-Type”字段的值部分。如果FileItem类对象对应的是普通表单字段，该方法将返回null。getContentType 方法的完整语法定义如下：
public String getContentType()
⑦. isInMemory方法
isInMemory方法用来判断FileItem类对象封装的主体内容是存储在内存中，还是存储在临时文件中，如果存储在内存中则返回true，否则返回false。其完整语法定义如下：
public boolean isInMemory()
⑧. delete方法
delete方法用来清空FileItem类对象中存放的主体内容，如果主体内容被保存在临时文件中，delete方法将删除该临时文件。尽管Apache组件使用了多种方式来尽量及时清理临时文件，但系统出现异常时，仍有可能造成有的临时文件被永久保存在了硬盘中。在有些情况下，可以调用这个方法来及时删除临时文件。 其完整语法定义如下：
public void delete()
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/093e5986ada03ebbd416b8dcd569db38/" rel="bookmark">
			warning: ‘p’ may be used uninitialized in this function
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 warning: ‘p’ may be used uninitialized inthis function
原因：你定义了一个指针变量，只能用来保存地址，如果这个地址所指向的空间不是系统分配给它的，那么你对这块内存的赋值是非法的
正确定义：int *p = new int; //动态的在堆上分配一块内存(手动分配) :
:
delete p; //释放内存 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dca220b25e3c676f41de3bfa2c6decec/" rel="bookmark">
			C/C&#43;&#43;中char **p1赋值给const char **p2产生错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在看《C专家编程》，书中提到：
1、实参 char *s与形参 const char *p相容；
2、实参char **argv 与形参 const char **p 不相容；（why ?）
代码如下：
&lt;span style="font-size:14px;"&gt;#include "stdafx.h" int foo(const char **p) { printf("just for test"); return 0; } int main(int argc,char*argv[]) { foo(argv); return 0; }&lt;/span&gt; 编译报错：error C2664: 'foo' : cannot convert parameter 1 from 'char *[]' to 'const char **'
ANSI C11 第6.5.2.2节（ANSI C89第6.3.2.2节）提到：
“ If the expression that denotes the called function has a type that includes a prototype, the number of arguments shall agree with the number of parameters.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dca220b25e3c676f41de3bfa2c6decec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adb3a5c5115ac9be30849087a11c048b/" rel="bookmark">
			ADO.NET——DataAdapter对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DataAdapter对象
来源以及作用：前面我所介绍的ADO.NET对象中，例如Connection对象，Command对象以及DataReader对象，这些对象均属于Data Provider的一部分，而且都是基于连接的。如果，每次我们检索数据库中的表或者行都需要连接一次数据库，那么性能和效率是十分低下的。实际上，ADO.NET提供了基于非连接的核心组件：DataSet。那么存储的数据集合是从哪里来呢？ADO.NET就为DataSet提供了中介：DataApdater数据适配器。
描述：DataAdapter对象提供连接 DataSet对象和数据源的桥梁，DataAdapter 使用 Command 对象在数据源中执行SQL命令以向DataSet中加载数据，并将对DataSet中数据的更改协调回数据源。
工作原理：DataApapter本质上就是一个数据调配器。当我们需要查询数据时，它从数据库检索数据，并填充要本地的DataSet或者DataTable中；当我需要更新数据库时，它将本地内存的数据填充到数据库，并执行更新命令。
功能：DataAdapter是最复杂的ADO.NET组件，是因为它是架构在所有其他DataProvider对象之上的。Connection对象、DataReader对象，Paramter对象以及Command对象，都尽可能的为它服务。总体来说，DataAdapter主要有三大功能：
1、数据检索：尽可能用最简单的方法填充数据源到本地DataSet或者DataTable中。细致的说，DataAdapter用一个DataReader实例来检索数据，因此你必须提供一个Select查询语句以及一个连接字符串。
2、数据更新：将本地修改的数据返回给外部的数据源，从数据库查询数据时，我们仅仅只需要一条基本的Select语句，而更新数据库则需要区分Insert,Update,Delete语句。
3、表或列名映射：维护本地DataSet表名和列名与外部数据源表名与列名的映射关系。
属性：
1、SelectCommand对象：引用从数据源中检索的Command对象。
2、UpdateCommand：引用将修改的行从DataSet写入数据源的Command对象。
3、InsertCommand：引用将插入的行从DataSet写入数据源的Command对象
4、DeleteCommand：引用从数据源中删除行的Command对象。
方法：
1、Fill：使用DataAdapter的这个方法，从数据源增加或刷新行，并将这些行放到DataSet表中。Fill方法调用SelectCommand属性所指定的SELECT语句。
2、Update：使用DataAdapter对象的这个方法，将DataSet表的更改传送到相应的数据源中。该方法为DataSet的DataTable中每一指定的行调用相应的INSERT、UPDATE或DELETE命令。
应用举例
public void SqlAdapterDemo(string connStr) { SqlConnection conn = new SqlConnection(connStr); //创建连接对象 SqlCommand cmd = conn.CreateCommand(); //创建sql命令对象 cmd.CommandType = CommandType.Text; cmd.CommandText = "select * from products = @ID"; //sql语句 cmd.Parameters.Add("@ID", SqlDbType.Int); &lt;span style="font-family:KaiTi_GB2312;"&gt;//添加参数&lt;/span&gt; cmd.Parameters["@ID"].Value = 1; //给参数sql语句的参数赋值 SqlDataAdapter adapter = new SqlDataAdapter(); //构造SqlDataAdapter adapter.SelectCommand = cmd; &lt;span style="color:#FF0000;"&gt;//与sql命令对象绑定，这个必不可少&lt;/span&gt; DataSet ds = new DataSet(); adapter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adb3a5c5115ac9be30849087a11c048b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/932740c409ccd1e587ff6d81e12766f9/" rel="bookmark">
			Cisco交换机ACL的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		访问控制列表（Access Control List ACL）的含义和作用就不讲了，自行百度
一 .ACL讲解
ACL分标准访问控制列表（Standard ACL）和拓展访问控制列表（Extended ACL），如下
① 标准ACL(访问控制列表号1—99或1300—1999)
只过滤源地址，允许或禁止整个TCP/IP协议族
一般配置在靠近流量目的地的接口
配置方法如下：
router（config）#access-list 1 permit 172.16.0.0 0.0.255.255
router（config）#access list 1 deny any //系统隐含条件（implicit deny any）
router（config）#interface F0/0
router（config-if）#ip access-group 1 in
router（config-if）#exit
router（config）#interface F0/1
router（config-if）#ip access-group 1 out
router（config-if）#no ip access-group 1 out //在端口上卸除ACL绑定
值得注意的是要改变ACL列表条件只能删除整个表：
router（config）#no access-list 1
②拓展ACL（访问控制列表标号100-199或2000-2600）
过滤源或目的地址，允许或拒绝一个具体的协议和端口号
一般放在靠近流量源头处
用到端口号时常用的英文缩写 it gt eq neq(＜、＞、＝、≠)
常见熟知端口号：
20 文件传输协议（FTP）数据通道
21 文件传输协议（FTP）控制通道
23 远程登录（Telnet）
25 简单邮件传输协议（SMTP）
53 域名服务系统（DNS）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/932740c409ccd1e587ff6d81e12766f9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/121/">«</a>
	<span class="pagination__item pagination__item--current">122/128</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/123/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>