<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>学习日记4.22-4.26 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="学习日记4.22-4.26" />
<meta property="og:description" content="2022.4.22 1、链表刷题： 面试题 02.07. 链表相交142. 环形链表 II（还没刷完） 2、哈希表刷题： 242. 有效的字母异位词 数组349. 两个数组的交集 HashSet202. 快乐数 HashSet1. 两数之和 HashMap454. 四数相加 II HashMap
1和454都是用目标数与某数相减的值代入HashMap中。 理论知识：哈希表理论基础 总结： 一般来说哈希表都是用来快速判断一个元素是否出现集合里。对于哈希表，要知道哈希函数和哈希碰撞在哈希表中的作用.
哈希函数是把传入的key映射到符号表的索引上。
哈希碰撞处理有多个key映射到相同索引上时的情景，处理碰撞的普遍方式是拉链法和线性探测法。三种哈希结构： 数组HashSetHashMap 什么时候使用数组做哈希表？ 数组就是简单的哈希表，但是数组的大小是受限的！题目包含小写字母，那么使用数组来做哈希最合适不过。什么时候使用HashSet做哈希表？ 如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。那就考虑HashSet。什么时候使用HashMap做哈希表？ 同时存放两个元素，且两个元素有对应关系。 3、二叉树刷题： 二叉树的递归遍历三要素：
1、确定递归函数的参数和返回值
2、确定终止条件
3、确定单层递归的逻辑
144. 二叉树的前序遍历94. 二叉树的中序遍历145. 二叉树的后序遍历 理论知识： 二叉树基础篇 ： 二叉树（没有值） 满二叉树完全二叉树 二叉搜索树（有序树） 平衡二叉搜索树（它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。） 二叉树的存储方式（一般用链式存储） 链式存储顺序存储 二叉树的遍历方式 深度优先遍历（先往深走，遇到叶子节点再往回走） 前序遍历（递归法，迭代法）中序遍历（递归法，迭代法）后序遍历（递归法，迭代法）
广度优先遍历 （一层一层的去遍历） 层次遍历（迭代法） 节点定义：（TreeNode） public class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/0ebe4bfa73b98e51167869788fcc293f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-03T22:42:04+08:00" />
<meta property="article:modified_time" content="2022-05-03T22:42:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">学习日记4.22-4.26</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="2022422_0"></a>2022.4.22</h2> 
<h4><a id="1_1"></a>1、链表刷题：</h4> 
<ul><li><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/submissions/" rel="nofollow">面试题 02.07. 链表相交</a></li><li><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" rel="nofollow">142. 环形链表 II</a>（还没刷完）</li></ul> 
<h4><a id="2_5"></a>2、哈希表刷题：</h4> 
<ul><li><a href="https://leetcode-cn.com/problems/valid-anagram/" rel="nofollow">242. 有效的字母异位词</a> 数组</li><li><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" rel="nofollow">349. 两个数组的交集</a> HashSet</li><li><a href="https://leetcode-cn.com/problems/happy-number/" rel="nofollow">202. 快乐数</a> HashSet</li><li><a href="https://leetcode-cn.com/problems/two-sum/" rel="nofollow">1. 两数之和</a> HashMap</li><li><a href="https://leetcode-cn.com/problems/4sum-ii/" rel="nofollow">454. 四数相加 II</a> HashMap<br> 1和454都是用目标数与某数相减的值代入HashMap中。</li></ul> 
<h5><a id="httpswwwprogrammercarlcomE59388E5B88CE8A1A8E79086E8AEBAE59FBAE7A180htmlE59388E5B88CE8A1A8_13"></a>理论知识：<a href="https://www.programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%93%88%E5%B8%8C%E8%A1%A8" rel="nofollow">哈希表理论基础</a></h5> 
<h5><a id="_14"></a>总结：</h5> 
<ul><li>一般来说哈希表都是用来<strong>快速判断一个元素是否出现集合里</strong>。</li><li>对于哈希表，要知道<strong>哈希函数</strong>和<strong>哈希碰撞</strong>在哈希表中的作用.<br> <strong>哈希函数</strong>是把传入的key映射到符号表的索引上。<br> <strong>哈希碰撞</strong>处理有多个key映射到相同索引上时的情景，处理碰撞的普遍方式是拉链法和线性探测法。</li><li>三种哈希结构： 
  <ul><li>数组</li><li>HashSet</li><li>HashMap</li></ul> </li><li><strong>什么时候使用数组做哈希表？</strong> 数组就是简单的哈希表，但是数组的大小是受限的！题目包含<strong>小写字母</strong>，那么使用数组来做哈希最合适不过。</li><li><strong>什么时候使用HashSet做哈希表？</strong> 如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。那就考虑HashSet。</li><li><strong>什么时候使用HashMap做哈希表？</strong> 同时存放两个元素，且两个元素有对应关系。</li></ul> 
<h4><a id="3_28"></a>3、二叉树刷题：</h4> 
<p><a href="https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html" rel="nofollow">二叉树的递归遍历</a>三要素：<br> 1、确定递归函数的参数和返回值<br> 2、确定终止条件<br> 3、确定单层递归的逻辑</p> 
<ul><li><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" rel="nofollow">144. 二叉树的前序遍历</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/submissions/" rel="nofollow">94. 二叉树的中序遍历</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/submissions/" rel="nofollow">145. 二叉树的后序遍历</a></li></ul> 
<h5><a id="_httpswwwprogrammercarlcomE4BA8CE58F89E6A091E79086E8AEBAE59FBAE7A180html__37"></a>理论知识： <a href="https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html" rel="nofollow">二叉树基础篇</a> ：</h5> 
<ul><li>二叉树（没有值） 
  <ul><li>满二叉树</li><li>完全二叉树</li></ul> </li><li>二叉搜索树（有序树） 
  <ul><li>平衡二叉搜索树（它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。）</li></ul> </li><li>二叉树的存储方式（一般用链式存储） 
  <ul><li>链式存储</li><li>顺序存储</li></ul> </li><li>二叉树的遍历方式 
  <ul><li>深度优先遍历（先往深走，遇到叶子节点再往回走） 
    <ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）<br> <img src="https://images2.imgbox.com/be/71/3O6IHDYx_o.png" alt="在这里插入图片描述"></li></ul> </li><li>广度优先遍历 （一层一层的去遍历） 
    <ul><li>层次遍历（迭代法）</li></ul> </li></ul> </li><li>节点定义：（TreeNode）</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> val<span class="token punctuation">;</span>
	<span class="token class-name">TreeNode</span> left<span class="token punctuation">;</span>
	<span class="token class-name">TreeNode</span> right<span class="token punctuation">;</span>
	<span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span> <span class="token punctuation">}</span>
	<span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> left<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="2022424__70"></a>2022.4.24 星期天</h2> 
<h4><a id="1_71"></a>1、字符串刷题：</h4> 
<p><a href="https://leetcode-cn.com/problems/reverse-string/" rel="nofollow">344. 反转字符串</a><br> <a href="https://leetcode-cn.com/problems/reverse-string-ii/" rel="nofollow">541. 反转字符串 II</a><br> 1、法1：用StringBuffer方法 (可以直接用类中的reverse方法)<br> 2、法2：用数组方法 （将字符串转char数组、s.toCharArray()）<br> <a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" rel="nofollow">剑指 Offer 05. 替换空格</a><br> 1、法1：使用辅助数组（对于很多数组填充问题）<br> 2、法2：扩容，大小为带填充后的大小，然后在从后向前进行操作。（good！）<br> 总结：要么变字符串数组，要么用StringBuilder。</p> 
<h2><a id="2022425__81"></a>2022.4.25 星期一</h2> 
<h4><a id="1_82"></a>1、字符串刷题：</h4> 
<p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" rel="nofollow">151. 颠倒字符串中的单词</a><br> <a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/" rel="nofollow">剑指 Offer 58 - II. 左旋转字符串</a><br> <a href="https://www.bilibili.com/video/BV1PD4y1o7nd?spm_id_from=333.337.search-card.all.click" rel="nofollow">28. 实现 strStr()</a>（不会代码，只看懂了理论，KMP算法）</p> 
<h5><a id="KMP_87"></a>KMP算法：</h5> 
<ul><li>要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf。</li><li><strong>KMP有什么用？</strong><br> KMP主要应用在字符串匹配上。<br> KMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</li><li><strong>next数组里的数字表示的是什么，如何计算？有什么作用？</strong><br> next数组就是一个前缀表，记录下标i之前（包括i）的字符串中，相同前缀后缀的最大长度。<br> 前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。</li><li><strong>前缀表与next数组的关系？</strong><br> 这并不涉及到KMP的原理，而是具体实现，<strong>next数组即可以就是前缀表，也可以是前缀表统一减一</strong>（右移一位，初始位置为-1）。</li></ul> 
<p>如何得到前缀表？前缀和后缀相等的数量。<br> next数组（prefix数组）</p> 
<h5><a id="_101"></a>总结：</h5> 
<ul><li>字符串方法很多，可以转数组toCharArray，可以转StringBuilder（StringBuffer），可以用自带很多函数substring、split、trim、charAt等等。</li><li>双指针法是字符串处理的常客。</li><li>KMP算法是字符串查找最重要的算法。（难）</li></ul> 
<h2><a id="2022426_55_106"></a>2022.4.26 星期二/5.5</h2> 
<h4><a id="1_107"></a>1、栈与队列刷题：</h4> 
<p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/submissions/" rel="nofollow">232. 用栈实现队列</a>（出栈和返回头元素代码很像，可以抽出来变成一个函数或工具类，记得代码复用！不要复制粘贴！）<br> <a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" rel="nofollow">225. 用队列实现栈</a>(可以使用queue（linkedlist）、deque（arraydeque）)<br> 方法1：<br> （使用两个 Queue 实现）<br> 入队列的时候利用辅助队列，让队头永远是新进元素，<br> 出队列的直接出队头<br> 可以实现栈的先进先出</p> 
<p>方法2：<br> （使用两个 Deque 实现）<br> 出队列的时候利用辅助队列，除了队尾的最后一个元素，其他元素入辅助队列，再出最后一个元素<br> 入队列的直接入队尾<br> 可以实现栈的先进先出</p> 
<p>方法3：<br> （优化，使用一个 Deque 实现）<br> 出队列的时候，除了队尾的最后一个元素，其他元素入重新入该队列，将队头元素出出去，可以实现栈的先进先出<br> 入队列的直接入队尾<br> 可以实现栈的先进先出<br> <a href="https://leetcode-cn.com/problems/valid-parentheses/" rel="nofollow">20. 有效的括号</a>（栈）<br> <a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/" rel="nofollow">1047. 删除字符串中的所有相邻重复项</a>（栈）<br> <a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/submissions/" rel="nofollow">150. 逆波兰表达式求值</a>（栈）与前面两做运算</p> 
<h5><a id="_httpswwwprogrammercarlcomE6A088E4B88EE9989FE58897E79086E8AEBAE59FBAE7A180html_131"></a>理论知识： <a href="https://www.programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html" rel="nofollow">（栈与队列理论知识）</a></h5> 
<ul><li>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。</li><li><strong>栈和队列</strong>往往不被归类为容器，而被归类为container adapter（<strong>容器适配器</strong>）</li><li>栈的底层实现主要就是<strong>数组和链表</strong>的底层实现。</li></ul> 
<h5><a id="_136"></a>总结：</h5> 
<ul><li> <p>queue队列是简单的FIFO队列，Deque队列是double ended queue，双端队列，可以在首尾插入或删除元素。</p> </li><li> <p><img src="https://images2.imgbox.com/89/d8/XqN7GS9z_o.png" alt="在这里插入图片描述"></p> </li><li> <p>其实ArrayDeque和LinkedList都可以作为栈以及队列使用，但是从执行效率来说，ArrayDeque作为队列以及LinkedList作为栈使用会是更好的选择。</p> </li><li> <p>在java中，Queue被定义成单端队列使用，Deque被定义成双端队列使用。<br> 而由于双端队列的定义，Deque可以作为栈或者队列使用，而Queue只能作为队列或者依赖于子类的实现作为堆使用。</p> </li><li> <p><strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，</strong> 然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p> </li><li> <p><strong>在企业项目开发中，尽量不要使用递归！</strong> 在项目比较大的时候，由于参数多，全局变量等等，使用递归很容易判断不充分return的条件，非常容易无限递归（或者递归层级过深），<strong>造成栈溢出错误（这种问题还不好排查！）</strong></p> </li><li> <p>栈与递归之间在某种程度上是可以转换的！</p> </li><li> <p>逆波兰表达式相当于是二叉树中的后序遍历。</p> </li><li> <p>单调队列</p> </li><li> <p>优先队列</p> </li><li> <p>对频率进行排序，这里我们可以使用一种 容器适配器就是<strong>优先级队列</strong>。</p> </li><li> <p>什么是优先级队列呢？<br> 其实就是一个披着队列外衣的堆，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。（看起来像队列，实际上是堆）</p> </li><li> <p>什么是堆？<br> 堆(Heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵完全二叉树的数组对象。<br> 1、堆是一棵完全二叉树<br> 2、树中每个结点的值都不小于（或不大于）其左右孩子的值。</p> </li><li> <p>最大堆（大根堆）：如果父亲结点是大于等于左右孩子就是大顶堆，<br> 最小堆（小根堆）：小于等于左右孩子就是小顶堆。<br> 缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，</p> </li><li> <p>优先队列PriorityQueue是Queue接口的实现，</p> </li></ul> 
<h2><a id="2022428_162"></a>2022.4.28</h2> 
<h4><a id="1_163"></a>1、栈与队列表刷题：</h4> 
<p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" rel="nofollow">239.滑动窗口最大值</a></p> 
<h4><a id="2_166"></a>2、二叉树刷题：</h4> 
<p><a href="https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-%E8%BF%AD%E4%BB%A3%E6%B3%95" rel="nofollow">二叉树的迭代遍历</a></p> 
<ul><li><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" rel="nofollow">144. 二叉树的前序遍历</a>（循环条件：栈不为空；先出栈，再右左）</li><li><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/submissions/" rel="nofollow">94. 二叉树的中序遍历</a>（加一个节点，一直加左节点；弹出一个元素，加右孩子；循环条件：不为空节点或栈不为空）</li><li><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/submissions/" rel="nofollow">145. 二叉树的后序遍历</a></li><li>// 前序遍历顺序：中-左-右，入栈顺序：中-右-左</li><li>// 中序遍历顺序: 左-中-右 入栈顺序： 左-右</li><li>// 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果<br> <a href="https://www.programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html" rel="nofollow">二叉树的层序遍历</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/submissions/" rel="nofollow">102. 二叉树的层序遍历</a>（需要定义len）<br> <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/submissions/" rel="nofollow">107. 二叉树的层序遍历 II</a>（在102题的基础上，将所得二维数组进行反过来）</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
    	<span class="token class-name">Res</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_184"></a>总结：</h5> 
<ul><li>此时我们写出了统一风格的迭代法，不用在纠结于前序写出来了，中序写不出来的情况了。<br> 但是统一风格的迭代法并不好理解，而且想在面试直接写出来还有难度的。<br> 所以大家根据自己的个人喜好，对于二叉树的前中后序遍历，选择一种自己容易理解的递归和迭代法。</li><li>队列先进先出，符合一层一层遍历的逻辑，<br> 而是用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。<br> 队列 - 层次遍历， 栈 - 深度优先遍历</li><li>二叉树遍历：<br> 1、递归（前中后序）<br> 2、迭代（前中后序）DFS<br> 3、层次遍历 BFS</li><li>做完102层次遍历，可以做5道类似题型！</li></ul> 
<h2><a id="2022429_198"></a>2022.4.29</h2> 
<h4><a id="1_199"></a>1、二叉树刷题：</h4> 
<ul><li><a href="https://leetcode-cn.com/problems/invert-binary-tree/submissions/" rel="nofollow">226.翻转二叉树</a></li></ul> 
<h5><a id="_202"></a>总结：</h5> 
<ul><li>红黑树其实是一种二叉平衡搜索树</li><li>递归与迭代究竟谁优谁劣呢？<br> 从时间复杂度上其实迭代法和递归法差不多，但是空间复杂度上，递归开销会大一些，因为递归需要系统堆栈存参数返回值等等。<br> 递归更容易让程序员理解，但收敛不好，容易栈溢出。<br> 这么说吧，递归是方便了程序员，难为了机器（各种保存参数，各种进栈出栈）。<br> <strong>在实际项目开发的过程中我们是要尽量避免递归！因为项目代码参数、调用关系都比较复杂，不容易控制递归深度，甚至会栈溢出。</strong></li><li><strong>一定要掌握前中后序一种迭代的写法，并不因为某种场景的题目一定要用迭代，而是现场面试的时候，面试官看你顺畅的写出了递归，一般会进一步考察能不能写出相应的迭代。</strong></li><li><strong>层序遍历遍历相对容易一些，只要掌握基本写法（也就是框架模板），剩下的就是在二叉树每一行遍历的时候做做逻辑修改。</strong></li><li><strong>本周总结：本周我们都是讲解了二叉树，从理论基础到遍历方式，从递归到迭代，从深度遍历到广度遍历，最后再用了一个翻转二叉树的题目把我们之前讲过的遍历方式都串了起来。</strong></li></ul> 
<h4><a id="2_213"></a>2、回溯刷题：</h4> 
<ul><li><a href="https://leetcode-cn.com/problems/assign-cookies/submissions/" rel="nofollow">455. 分发饼干</a></li></ul> 
<h5><a id="httpswwwprogrammercarlcomE59B9EE6BAAFE7AE97E6B395E79086E8AEBAE59FBAE7A180html_217"></a>理论知识：<a href="https://www.programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html" rel="nofollow">回溯算法理论基础</a></h5> 
<h5><a id="_218"></a>总结：</h5> 
<ul><li>本篇我们讲解了，什么是回溯算法，知道了回溯和递归是相辅相成的。<br> 接着提到了回溯法的效率，回溯法其实就是暴力查找，并不是什么高效的算法。<br> 然后列出了回溯法可以解决几类问题，可以看出每一类问题都不简单。<br> 最后我们讲到回溯法解决的问题都可以抽象为树形结构（N叉树），并给出了回溯法的模板。</li><li>回溯函数也就是递归函数，指的都是一个函数。</li><li>虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法。因为<strong>回溯的本质是穷举</strong>，穷举所有可能，然后选出我们想要的答案。</li><li>回溯法，一般可以解决如下几种问题：<br> 组合问题：N个数里面按一定规则找出k个数的集合<br> 切割问题：一个字符串按一定规则有几种切割方式<br> 子集问题：一个N个数的集合里有多少符合条件的子集<br> 排列问题：N个数按一定规则全排列，有几种排列方式<br> 棋盘问题：N皇后，解数独等等</li><li>组合是不强调元素顺序的，排列是强调元素顺序</li><li><strong>回溯法解决的问题都可以抽象为树形结构</strong>，是的，我指的是所有回溯法的问题都可以抽象为树形结构！</li><li>因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度，都构成的树的深度</strong>。</li><li>回溯三部曲：<br> 1、回溯函数模板返回值以及参数<br> 2、回溯函数终止条件<br> 3、回溯搜索的遍历过程<br> <img src="https://images2.imgbox.com/4d/89/ljsKRpUu_o.png" alt="在这里插入图片描述"></li><li>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历</li><li>回溯算法模板框架：</li></ul> 
<pre><code class="prism language-java"><span class="token keyword">void</span> <span class="token function">backtracking</span><span class="token punctuation">(</span>参数<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>终止条件<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        存放结果<span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>选择：本层集合中元素（树中节点孩子的数量就是集合的大小）<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        处理节点<span class="token punctuation">;</span>
        <span class="token function">backtracking</span><span class="token punctuation">(</span>路径，选择列表<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归</span>
        回溯，撤销处理结果
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="3_256"></a>3、贪心算法刷题：</h4> 
<h5><a id="httpswwwprogrammercarlcomE8B4AAE5BF83E7AE97E6B395E79086E8AEBAE59FBAE7A180html_257"></a>理论知识：<a href="https://www.programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html" rel="nofollow">贪心算法理论基础</a></h5> 
<h5><a id="_259"></a>总结：</h5> 
<ul><li>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</li><li>什么时候用贪心？<br> 说实话贪心算法并没有固定的套路。<br> 有没有什么固定策略或者套路呢？<br> 不好意思，也没有！</li><li>如何验证可不可以用贪心算法呢？<br> 最好用的策略就是<strong>举反例，如果想不到反例，那么就试一试贪心吧。</strong></li><li>贪心算法一般分为如下四步：<br> 1、将问题分解为若干个子问题<br> 2、找出适合的贪心策略<br> 3、求解每一个子问题的最优解<br> 4、将局部最优解堆叠成全局最优解<br> 其实这个分的有点细了，真正做题的时候很难分出这么详细的解题步骤，可能就是因为贪心的题目往往还和其他方面的知识混在一起。</li><li>所以这也是为什么很多同学通过（accept）了贪心的题目，但都不知道自己用了贪心算法，<strong>因为贪心有时候就是常识性的推导</strong>，所以会认为本应该就这么做！</li><li><strong>贪心没有套路，说白了就是常识性推导加上举反例</strong></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2b7e4e0278e02814f0d985edf1a1a44c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">操作链表时加入头结点</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cd25384d39edd0d0dca0eb43322b7e7c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">机器学习（一）协同过滤推荐算法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>