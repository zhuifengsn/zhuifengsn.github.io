<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>树-王道-复试 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="树-王道-复试" />
<meta property="og:description" content="树 1.度： 树中孩子节点个数，所有结点的度最大值为 树的度
2.有序树： 逻辑上看，树中结点的各子树从左至右是有次序的，不能互换。
**3.**树的根节点没有前驱，其他节点只有一个前驱
**4.**所有节点可有零个或者多个后继
常考性质 1. 节点数 = 总度数（总边数）&#43;1
2.度为 m 的树、m 叉树的区别：
** 3. 度为m的数第 i 层 至多有m(i-1)个结点，m叉树第i层至多有m(i-1)个节点 **
**4.高度为 h 的 m 叉树至多:**有（m^h-1）/m-1个节点
5.高度为 h 的 m 叉树至少: h个节点
6.高度为 h、度为 m 的树至少: h&#43;m-1个节点
7.最小高度为： logmn
最小高度的计算：
2.完全二叉树 就是右叶子节点为缺，左边都是连起来的
特点：
1.只有最后两层可能有叶子结点。
2最多只有一个度为 1 的结点。(屁股节点，也就是度为1的节点只有1个)
3若按层序从 1 开始编号，结点 i 的左孩子为 2i，右孩子为 2i&#43;1；结点 i 的父节点为 ⌊ i / 2 ⌋ \lfloor i/2\rfloor⌊i/2⌋。
4 i ≤ ⌊ n / 2 ⌋ 为分支结点，i &gt; ⌊ n / 2 ⌋ 为叶子结点。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/f7872b3293d251f1fb10054428a726ec/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-23T19:10:01+08:00" />
<meta property="article:modified_time" content="2024-02-23T19:10:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">树-王道-复试</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="_0"></a>树</h4> 
<p><strong>1.度：</strong> 树中<code>孩子节点</code>个数，所有结点的度最大值为 树的度<br> <strong>2.有序树：</strong> 逻辑上看，树中结点的各子树从<code>左至右</code>是有次序的，<code>不能互换</code>。<br> **3.**树的根节点没有前驱，其他节点只有一个前驱<br> **4.**所有节点可有零个或者多个后继</p> 
<h5><a id="_5"></a>常考性质</h5> 
<p><strong>1.</strong> 节点数 = 总度数（总边数）+1<br> <strong>2.度为 m 的树、m 叉树的区别：</strong><br> <img src="https://images2.imgbox.com/7a/0e/FrRBOKz3_o.png" alt="在这里插入图片描述"><br> ** 3. 度为m的数第 i 层 至多有m<sup>(i-1)个结点，m叉树第i层至多有m</sup>(i-1)个节点 **<br> **4.高度为 h 的 m 叉树至多:**有（m^h-1）/m-1个节点<br> <strong>5.高度为 h 的 m 叉树至少:</strong> h个节点<br> <strong>6.高度为 h、度为 m 的树至少:</strong> h+m-1个节点<br> <strong>7.最小高度为：</strong> logmn<br> <img src="https://images2.imgbox.com/f7/38/UvMWnJTS_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/09/e1/3kFAcRyq_o.png" alt="在这里插入图片描述"><br> <strong>最小高度的计算：</strong><br> <img src="https://images2.imgbox.com/6f/23/IZOOxGOt_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_19"></a>2.完全二叉树</h4> 
<p>就是右叶子节点为缺，左边都是连起来的<br> <img src="https://images2.imgbox.com/f4/1a/g1xe2qSt_o.png" alt="在这里插入图片描述"><br> <strong>特点：</strong></p> 
<p><code>1.</code>只有<strong>最后两层</strong>可能有叶子结点。<br> <code>2</code>最多只有<strong>一个</strong>度为 1 的结点。(屁股节点，也就是度为1的节点只有1个)<br> <code>3</code>若按层序从 1 开始编号，结点 i 的左孩子为 2i，右孩子为 2i+1；结点 i 的父节点为 ⌊ i / 2 ⌋ \lfloor i/2\rfloor⌊i/2⌋。<br> <code>4</code> i ≤ ⌊ n / 2 ⌋ 为分支结点，i &gt; ⌊ n / 2 ⌋ 为叶子结点。</p> 
<h4><a id="3_29"></a>3.平衡二叉树与二叉搜索树的区别：</h4> 
<p><code>平衡：</code>树上任一结点的左子树和右子树的深度之差不超过 1。<br> <code>搜索：</code>左小于根，右大于根<br> <a href="https://blog.csdn.net/weixin_57128596/article/details/127216542?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170853038416800185813532%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=170853038416800185813532&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-127216542-null-null.nonecase&amp;utm_term=BST&amp;spm=1018.2226.3001.4450">https://blog.csdn.net/weixin_57128596/article/details/127216542?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170853038416800185813532%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=170853038416800185813532&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<sub>blog</sub>first_rank_ecpm_v1~rank_v31_ecpm-1-127216542-null-null.nonecase&amp;utm_term=BST&amp;spm=1018.2226.3001.4450</a></p> 
<h4><a id="4_33"></a>4.度合节点数的区别：</h4> 
<p>1.节点总数n=n0+n1+n2（度为0的节点数+度为1的节点数+度为2的节点数）<br> n0=n2+1（度为0的节点数=度为2的节点数+1）<br> 2.二叉树的第i层至多有<code>2的i-1次方</code>个节点<br> 3.高度为h的二叉树至多有<code>2的h次方-1</code>个节点<br> 4.如果完全二叉树有2K个节点（偶数），则n1=1，n0=k，n2=k-1<br> 5.如果完全二叉树有2K-1个节点（奇数），则n1=0，n0=k，n2=k-1</p> 
<h4><a id="5_40"></a>5.二叉树的左右孩子</h4> 
<p><code>1</code>:节点i的左孩子为 2i<br> <code>2</code>:节点i的右孩子为 2i+1<br> <code>3</code>:节点i的父节点为【i/2】<br> <code>4</code>:节点i的层次为 【log2(i+1)】</p> 
<h4><a id="6_45"></a>6.前中后序遍历</h4> 
<p><code>前序：</code><br> 根左右<br> <code>中序：</code><br> 左根右<br> <code>后序：</code><br> 左右根</p> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BiNode</span><span class="token punctuation">{<!-- --></span>
   ElemType data<span class="token punctuation">;</span>
   <span class="token keyword">struct</span> <span class="token class-name">BiNode</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span><span class="token operator">*</span>rchild<span class="token punctuation">;</span>
<span class="token punctuation">}</span>BiNode<span class="token punctuation">,</span><span class="token operator">*</span>BiTree<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">PreOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">visit</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//访问根节点</span>
    <span class="token function">PreOrder</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>lChild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归左子树</span>
    <span class="token function">PreOrder</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>rChild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归右子树</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">InOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">InOrder</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归左子树</span>
    <span class="token function">visit</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//访问当前节点</span>
    <span class="token function">InOrder</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归右子树</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">PostOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">PostOrder</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归左子树</span>
    <span class="token function">PostOrder</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>lright<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//递归右子树</span>
    <span class="token function">visit</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_83"></a>求树的最大深度</h5> 
<pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> lDepth<span class="token operator">=</span><span class="token function">maxDepth</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//当前节点的左子树深度</span>
  <span class="token keyword">int</span> rDepth<span class="token operator">=</span><span class="token function">maxDepth</span><span class="token punctuation">(</span>T<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//当前节点的右子树深度</span>
  <span class="token keyword">return</span> lDepth<span class="token operator">&gt;</span>rDepth<span class="token operator">?</span>lDepth<span class="token operator">+</span><span class="token number">1</span><span class="token operator">:</span>rDepth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_93"></a>二叉树的层序遍历</h5> 
<pre><code class="prism language-c"><span class="token comment">//二叉树节点</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BiNode</span><span class="token punctuation">{<!-- --></span>
   ElemeType data<span class="token punctuation">;</span>
   <span class="token keyword">struct</span> <span class="token class-name">BiNode</span><span class="token operator">*</span> lchild<span class="token punctuation">,</span><span class="token operator">*</span>rchild<span class="token punctuation">;</span>
<span class="token punctuation">}</span>BiNode<span class="token punctuation">,</span><span class="token operator">*</span>BiTree<span class="token punctuation">;</span>
<span class="token comment">//链式队列节点，作层序</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LinkNode</span><span class="token punctuation">{<!-- --></span>
  BiNode<span class="token operator">*</span> data<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">LinkNode</span><span class="token operator">*</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>LinkNode<span class="token punctuation">;</span>

<span class="token comment">//层序集合，类似List&lt;List&lt;TreeNode&gt;&gt;</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{<!-- --></span>
  LinkNode <span class="token operator">*</span>front<span class="token punctuation">,</span><span class="token operator">*</span>rear<span class="token punctuation">;</span>
<span class="token punctuation">}</span>LinkQueue<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">LevelOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
  LinkQueue Q<span class="token punctuation">;</span> <span class="token comment">//类似List&lt;List&lt;TreeNode&gt;&gt;</span>
  <span class="token function">InitQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span>
  BiTree p<span class="token punctuation">;</span><span class="token comment">//二叉树节点</span>
  <span class="token function">EnQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将T入到我们的队列Q中</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IsEmpth</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">DeQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将队列中的队首元素出队，并将其赋值给 p，这样就可以访问当前节点 p</span>
    <span class="token function">visit</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//将节点的子节点入队</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>lchild<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
      <span class="token function">EnQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>p<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>rchild<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
      <span class="token function">EnQueue</span><span class="token punctuation">(</span>Q<span class="token punctuation">,</span>p<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="7_130"></a>7.中序前序后序的节点变换</h4> 
<h4><a id="8_132"></a>8.树和森林题目</h4> 
<p><strong>1.</strong><br> <code>1.</code>：讨论二叉树高度，<strong>必须</strong>要说他是<strong>完全二叉树</strong>，高度为<strong>log2(n)+1</strong><br> <code>2.</code>：树-一般我们阐述的是<strong>左孩子右兄弟树</strong>，左侧图，叶子节点树为1，对应二叉树-因为右兄弟，所以转为二叉树，有两个叶子节点<br> <img src="https://images2.imgbox.com/16/5d/19rAJIRa_o.png" alt="在这里插入图片描述"><br> <strong>2.</strong><br> M2+M3相加即为右子树的节点个数</p> 
<p><img src="https://images2.imgbox.com/2b/12/4ABc290B_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/eb/41/QJOS75J1_o.png" alt="在这里插入图片描述"></p> 
<p><strong>3.</strong><br> 1.F是一个森林，有n个非终端节点，说明有n颗树，B为二叉树<br> 2.右指针为空的节点为（n+1）<br> <img src="https://images2.imgbox.com/72/f6/jdd4sPcX_o.png" alt="在这里插入图片描述"><br> <strong>4.</strong><br> 利用中序和后序遍历得二叉树，然后根据二叉树画出森林，得到树 C</p> 
<p><img src="https://images2.imgbox.com/54/00/U7bcKYmh_o.png" alt="在这里插入图片描述"><br> <strong>5.</strong><br> 1.X是某节点的右孩子，说明他在左边一定有自己的兄弟节点，故D<br> <img src="https://images2.imgbox.com/92/57/QWza4o22_o.png" alt="在这里插入图片描述"><br> <strong>6.</strong><br> 1.n=n0+n1+n2<br> 2.n2=n0-1;<br> 3.n1=2012-116=1896</p> 
<p><img src="https://images2.imgbox.com/56/ce/IPLyxCVD_o.png" alt="在这里插入图片描述"></p> 
<p><strong>7.</strong><br> 直接上公式logm(n(m-1))+1，向上取整</p> 
<p><img src="https://images2.imgbox.com/fb/af/Ltz7c7Gj_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_184"></a>树转二叉树的规则：</h5> 
<p>左孩子右兄弟，BCD三个节点彼此就是兄弟，B是A的孩子，CD是B的兄弟，<br> 但是有个从左到右的顺序，最左的是长兄，<br> **画法：**从左开始搜，平层为兄弟节点</p> 
<p><img src="https://images2.imgbox.com/9c/ef/jQAncKqR_o.png" alt="在这里插入图片描述"><br> 森林应该保持平层；注重左右带来的关系<br> <img src="https://images2.imgbox.com/50/2d/MfesIMHE_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_192"></a>树和森林和二叉树的遍历关系：</h5> 
<p>森林和二叉树是一种遍历关系<br> <img src="https://images2.imgbox.com/59/5f/nZ8IvLod_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="9_197"></a>9.题目</h4> 
<p><strong>1.</strong><br> <img src="https://images2.imgbox.com/27/93/5nkyE1m8_o.png" alt="在这里插入图片描述"><br> <strong>2.</strong><br> 节点数=所有节点度数之和+1；<br> <img src="https://images2.imgbox.com/4a/5f/QYvzaoAp_o.png" alt="在这里插入图片描述"><br> <strong>3.</strong><br> 最大值是高度<br> <img src="https://images2.imgbox.com/94/d8/H9wH13xW_o.png" alt="在这里插入图片描述"><br> <strong>4.</strong><br> 1.节点数=至多高度+度-1<br> 2. 度为n，第i层至多有n的i-1次方<br> <img src="https://images2.imgbox.com/9e/a1/B5Rur0SH_o.png" alt="在这里插入图片描述"><br> <strong>5.</strong><br> <img src="https://images2.imgbox.com/45/a1/K3oazKQI_o.png" alt="在这里插入图片描述"><br> 度为4，高度为h，至少节点数=h+4-1<br> 度为4，高度为h，最多节点数：(4^h-1)/(度-1)</p> 
<p><strong>6</strong><br> logm(n(m-1)+1)<br> <img src="https://images2.imgbox.com/5e/21/tUitc9Y9_o.png" alt="在这里插入图片描述"><br> <strong>7.</strong></p> 
<p>n节点总数=对应度数<em>对应的节点个数+…<br> n0=n-n1-n2-n3-n4…<br> n节点总数=叶子节点个数n0+其余度数节点的累加<br> <img src="https://images2.imgbox.com/15/e9/eMCFCXYb_o.png" alt="在这里插入图片描述"><br> <strong>8.</strong><br> <code>1.</code>完全二叉树的高度为：(log2n)+1，n为节点个数**（注意一定要是完全二叉树）**<br> 否则链式情况需要考虑，可能有4个节点高度为4<br> <code>2.</code>如果一个完全二叉树没有左孩子，那么该节点一定是叶子节点<br> <img src="https://images2.imgbox.com/e8/c6/hEM8rxLP_o.png" alt="在这里插入图片描述"><br> <strong>9.</strong><br> 需要注意i是否是&gt;0，如果i从0开始，那么第i个节点的左孩子为2</em>i+1，否则为2i</p> 
<p><img src="https://images2.imgbox.com/03/d6/4njM3gEz_o.png" alt="在这里插入图片描述"></p> 
<p><strong>10</strong></p> 
<p>度为0说明该节点为叶子节点，所以在具象化的时候，我们只需要重点在度为2上，所含节点数至少为：<em><em>2</em>(h-1)+1</em>*<br> 高度为<strong>h</strong>，所包含节点数至少为<strong>2h-1</strong></p> 
<p><img src="https://images2.imgbox.com/6c/3a/uzMQPrRd_o.png" alt="在这里插入图片描述"><br> <strong>11.</strong><br> <strong>最小高度</strong>，马上想到<strong>完全二叉树</strong>，完全二叉树的<strong>高度为</strong>：（log2n）+1，2为叉树，n为节点数</p> 
<p><img src="https://images2.imgbox.com/e8/aa/27IX0s9F_o.png" alt="在这里插入图片描述"></p> 
<p><strong>12.</strong><br> 公式一：节点总数2n=n0+n1+n2（各度数节点之和 ）<br> 公式二：节点总数2n=非叶子节点n1数量<em>1+n2</em>2（度数）+1</p> 
<p><img src="https://images2.imgbox.com/05/80/8b3UwG5O_o.png" alt="在这里插入图片描述"><br> <strong>13.</strong><br> 二叉树最大深度，每层节点数最少即可，每层最少为2，所以<strong>2*h- 1=节点数n</strong><br> <img src="https://images2.imgbox.com/83/64/RqBB7gnb_o.png" alt="在这里插入图片描述"></p> 
<p><strong>14.</strong></p> 
<p>完全二叉树，已知高为h，最少节点——&gt;(log2^n)+1=h)<br> <strong>由于高度h</strong>的<strong>满二叉树</strong>共有2^h-1个结点<br> <strong>高度为h-1</strong>的<strong>满二叉树</strong>有2^(h-1)-1个结点<br> 可得<strong>2^(h-1)-1 &lt; n &lt;=2^h-1</strong><br> 不等式同时+1：2h-1 &lt; n+1 &lt;=2h<br> 不等式同时取对数：<br> h-1 &lt; log2n+1 &lt;= h<br> <img src="https://images2.imgbox.com/39/69/BAoaq3Ps_o.png" alt="在这里插入图片描述"><br> <strong>15.</strong><br> 计算<code>满二叉树</code>的节点个数：<code>2^n-1</code>，比如这里的五层，就是2的5次方-1<br> 如果是计算<code>某i层</code>的节点个数：<code>2^(i-1)</code><br> <img src="https://images2.imgbox.com/af/6b/OqEGKoiU_o.png" alt="在这里插入图片描述"></p> 
<p><strong>16.</strong><br> 方法一：必然大于n/2，所以D<br> 方法二：1.n0=n2+1 ；2.n=n0个数+n1+n2；3.然后完全二叉树的n1不是0就是1，再往里代入，只有D满足<br> <img src="https://images2.imgbox.com/9f/d3/Km5TLQFK_o.png" alt="在这里插入图片描述"></p> 
<p><strong>17.</strong><br> 完全二叉树前n层至多节点数：2^n-1——&gt;前6层最多有 2 ^6-1<br> 完全二叉树前n层至少节点数：2^(n-1)<br> 满二叉树某层节点数：2^(i-1)<br> 满二叉树所有节点数：2^n-1<br> <img src="https://images2.imgbox.com/8a/57/ztHP66yd_o.png" alt="在这里插入图片描述"><br> <strong>18.</strong><br> 1.124个叶子节点，说明这是n0的数量<br> 2.n0=n2+1；n2=n0-1；<br> 3.n=n0+n1+n2——&gt;n=2n0+n1-1<br> 带入n0=124,n1=0/1求解</p> 
<p><img src="https://images2.imgbox.com/ea/1c/edzhc1LZ_o.png" alt="在这里插入图片描述"><br> <strong>19.</strong><br> 1.空指针数量=n+1<br> 2.结点数=度+1<br> <img src="https://images2.imgbox.com/1a/de/44NbwkI7_o.png" alt="在这里插入图片描述"><br> <strong>20</strong><br> 判断节点所在层数的公式：[log2(n)]+1，向下取整<br> <img src="https://images2.imgbox.com/2e/94/6k0oYccc_o.png" alt="在这里插入图片描述"><br> <strong>21.</strong><br> m叉树拥有n个节点，最小高度为：[logm(n(m-1))]向上取整</p> 
<p><img src="https://images2.imgbox.com/16/09/2uuWNlbu_o.png" alt="在这里插入图片描述"><br> <strong>21.</strong><br> 1.首先计算前5层，节点数为：2^5-1（相当于满二叉树）=31<br> 2.第6层有8个叶子节点，有两种情况：倒数第一层或者倒数第二层，因为考虑最多节点数，所以为倒数第二层<br> 第i层节点数为最大：2^(i-1)=32，所以第6层非叶子节点个数为32-8=24个，所以第7层有48个<br> 3.总数为：31+32+48=111</p> 
<p><img src="https://images2.imgbox.com/07/94/bAuWDSe0_o.png" alt="在这里插入图片描述"><br> <strong>22.</strong><br> 1.每个非叶子节点有2个子节点，说明n1=0,所以我们只需要关注n0和n2即可<br> 2.n0=n2+1<br> 3.n=2n0-1；<br> 所以为2K-1</p> 
<p><img src="https://images2.imgbox.com/06/a8/fLAGSVV0_o.png" alt="在这里插入图片描述"><br> <strong>23.</strong><br> 答案：31，存储单元数量跟树的高度相关，比如高度为5，直接算满二叉树所需空间为：2^5-1=31<br> <img src="https://images2.imgbox.com/5d/c2/hegxhp2w_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="10_316"></a>10.二叉树应用，哈夫曼树</h4> 
<h5><a id="101_318"></a>10.1定义</h5> 
<p>哈夫曼树的路径长度为：从树的<strong>根节点</strong>-&gt;<strong>任意节点</strong>的路径长度**(边数)<strong>与该节点上</strong>权值的乘积<strong>之</strong>和**</p> 
<p><img src="https://images2.imgbox.com/0f/91/x6itkY1E_o.png" alt="在这里插入图片描述"><br> <strong>最小二叉树，最优二叉树</strong>：俗称哈夫曼树（作压缩）</p> 
<p><img src="https://images2.imgbox.com/71/31/bmxDfE4E_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="102_325"></a>10.2哈夫曼树的构造</h5> 
<p><img src="https://images2.imgbox.com/00/2b/B395gUJT_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="103_327"></a>10.3哈夫曼树的编码</h5> 
<p>1.方法：0，1从左至右构造<br> 2.WPL（WPL也是哈夫曼树二进制编码的长度）只算我们的哈夫曼树的叶子节点<br> 比如说以下：<br> 二进制编码长度为224，但是若采用3为固定长度编码，那么二进制编码长度为300位，效率提高，压缩数据<br> <img src="https://images2.imgbox.com/69/32/aQAuqQsr_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="104_333"></a>10.4题目</h5> 
<p><strong>1.</strong><br> 哈夫曼树的构造，最小的两个节点构造一个新节点<br> <img src="https://images2.imgbox.com/e8/50/whJih0rR_o.png" alt="在这里插入图片描述"><br> <strong>2.</strong><br> 哈夫曼编码：1.首先画出哈夫曼树，然后标上其编码 2.不要忘记相反方向，左子树和右子树之间可以换个位置<br> <img src="https://images2.imgbox.com/a2/0f/g9anpLU9_o.png" alt="在这里插入图片描述"><br> <strong>如图所示：</strong><br> <img src="https://images2.imgbox.com/72/ca/EeAnyG1X_o.png" alt="在这里插入图片描述"><br> <strong>3.</strong><br> <strong>不同频次</strong>的<strong>节点字符</strong>处于<strong>相同的层</strong>，（因为我要挑选的是<strong>最小的两个节点</strong>组成一个<strong>新的节点</strong>）<br> 比如：1和2节点，是属于定层编码，同一层</p> 
<p><img src="https://images2.imgbox.com/d7/ee/GteG4xDU_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a6cd6fa2c1dbd53f1610c2cc9fee2b69/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2.23数据结构</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7ea647d9817b688450589af90c8c5dae/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Jenkins使用遇到的一些问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>