<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Cpp 基础知识 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Cpp 基础知识" />
<meta property="og:description" content="1.说一下 static 关键字的作用
参考回答：
全局静态变量 ： 在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。
静态存储区，在整个程序运行期间一直存在。
初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；
作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。
局部静态变量 在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。
内存中的位置：静态存储区
初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；
作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；
静态函数 在函数返回类型前加 static，函数就定义为静态函数。函数的定义和声明在默认情况下都是 extern 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。
函数的实现使用 static 修饰，那么这个函数只可在本 cpp 内使用，不会同其他 cpp 中的同名函数引起冲突；
warning：不要在头文件中声明 static 的全局函数，不要在 cpp 内声明非 static 的全局函数，如果你要在多个 cpp 中复用该函数，就把它的声明提到头文件里去，否则 cpp 内部声明需加上 static 修饰；
类的静态成员 在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用 类的静态函数 静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。
在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);
2.说一下 C&#43;&#43; 和 C 的区别
参考回答：
1）设计思想上：
C&#43;&#43; 是面向对象的语言，而 C 是面向过程的结构化编程语言。
2）语法上：
C&#43;&#43; 具有封装、继承和多态三种特性；
C&#43;&#43; 相比 C，增加多许多类型安全的功能，比如强制类型转换；
C&#43;&#43; 支持范式编程，比如模板类、函数模板等。
3.说一说 C&#43;&#43; 中四种 cast 转换" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/6c04c31e3d786af1fb0c3af49252da3c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-02-10T14:58:19+08:00" />
<meta property="article:modified_time" content="2020-02-10T14:58:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Cpp 基础知识</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>1.说一下 static 关键字的作用</strong></p> 
<p><strong>参考回答：</strong></p> 
<ol><li>全局静态变量 ：</li></ol> 
<ul><li> <p>在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。</p> </li><li> <p>静态存储区，在整个程序运行期间一直存在。</p> </li><li> <p>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；</p> </li><li> <p>作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p> </li></ul> 
<ol start="2"><li>局部静态变量</li></ol> 
<ul><li> <p>在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。</p> </li><li> <p>内存中的位置：静态存储区</p> </li><li> <p>初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；</p> </li><li> <p>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</p> </li></ul> 
<ol start="3"><li>静态函数</li></ol> 
<ul><li> <p>在函数返回类型前加 static，函数就定义为静态函数。函数的定义和声明在默认情况下都是 extern 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。</p> </li><li> <p>函数的实现使用 static 修饰，那么这个函数只可在本 cpp 内使用，不会同其他 cpp 中的同名函数引起冲突；</p> </li><li> <p>warning：不要在头文件中声明 static 的全局函数，不要在 cpp 内声明非 static 的全局函数，如果你要在多个 cpp 中复用该函数，就把它的声明提到头文件里去，否则 cpp 内部声明需加上 static 修饰；</p> </li></ul> 
<ol start="4"><li>类的静态成员</li></ol> 
<ul><li>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用</li></ul> 
<ol start="5"><li>类的静态函数</li></ol> 
<ul><li> <p>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。</p> </li><li> <p>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</p> </li></ul> 
<hr> 
<p><strong>2.说一下 C++ 和 C 的区别</strong></p> 
<p><strong>参考回答：</strong></p> 
<p><strong>1）设计思想上：</strong></p> 
<p>C++ 是面向对象的语言，而 C 是面向过程的结构化编程语言。</p> 
<p><strong>2）语法上：</strong></p> 
<p>C++ 具有封装、继承和多态三种特性；</p> 
<p>C++ 相比 C，增加多许多类型安全的功能，比如强制类型转换；</p> 
<p>C++ 支持范式编程，比如模板类、函数模板等。</p> 
<hr> 
<p><strong>3.说一说 C++ 中四种 cast 转换</strong></p> 
<p><strong>参考回答：</strong></p> 
<p>C++ 中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast。</p> 
<p><strong>1）const_cast</strong></p> 
<p>用于将 const 变量转为非 const。</p> 
<p><strong>2）static_cast</strong></p> 
<p>用于各种隐式转换，比如非 const 转 const，void* 转指针等, static_cast 能用于多态向上转化，如果向下转能成功但是不安全，结果未知。</p> 
<p><strong>3）dynamic_cast</strong></p> 
<p>用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回 NULL，对于引用抛异常。要深入了解内部转换的原理。</p> 
<p>向上转换：指的是子类向基类的转换</p> 
<p>向下转换：指的是基类向子类的转换</p> 
<p>它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。</p> 
<p><strong>4）reinterpret_cast</strong></p> 
<p>几乎什么都可以转，比如将 int 转指针，可能会出问题，尽量少用。</p> 
<hr> 
<p><strong>4.为什么不使用 C 的强制转换？</strong></p> 
<p>C 的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</p> 
<hr> 
<p><strong>5.请说一下 C/C++ 中指针和引用的区别？</strong></p> 
<p><strong>参考回答：</strong></p> 
<ul><li> <p>指针有自己的一块空间，而引用只是一个别名；</p> </li><li> <p>使用 sizeof 看一个指针的大小是 4，而引用则是被引用对象的大小；</p> </li><li> <p>指针可以被初始化为 NULL，而引用必须被初始化且必须是一个已有对象的引用；</p> </li><li> <p>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；</p> </li><li> <p>可以有 const 指针，但是没有 const 引用；</p> </li><li> <p>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；</p> </li><li> <p>指针可以有多级指针（**p），而引用只有一级；</p> </li><li> <p>指针和引用使用 ++ 运算符的意义不一样；</p> </li><li> <p>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</p> </li></ul> 
<hr> 
<p><strong>6.给定三角形 ABC 和一点 P(x,y,z)，判断点 P 是否在 ABC 内，给出思路并手写代码</strong></p> 
<p><strong>参考回答：</strong></p> 
<p>根据面积法，如果 P 在三角形 ABC 内，那么三角形 ABP 的面积 + 三角形 BCP 的面积 + 三角形 ACP 的面积应该等于三角形 ABC 的面积。</p> 
<p><strong>算法如下：</strong></p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;math.h&gt;
using namespace std;
#define ABS_FLOAT_0 0.0001
struct point_float {
	float x;
	float y;
};

/**
* @brief 计算三角形面积
*/
float GetTriangleSquar(const point_float pt0, const point_float pt1, 
const point_float pt2) {
	point_float AB, BC;
	AB.x = pt1.x - pt0.x;
	AB.y = pt1.y - pt0.y;
	BC.x = pt2.x - pt1.x;
	BC.y = pt2.y - pt1.y;
	return fabs((AB.x * BC.y - AB.y * BC.x)) / 2.0f;
}

/**
* @brief 判断给定一点是否在三角形内或边上
*/
bool IsInTriangle(const point_float A, const point_float B, 
const point_float C, const point_float D) {
	float SABC, SADB, SBDC, SADC;
	SABC = GetTriangleSquar(A, B, C);
	SADB = GetTriangleSquar(A, D, B);
	SBDC = GetTriangleSquar(B, D, C);
	SADC = GetTriangleSquar(A, D, C);
	float SumSuqar = SADB + SBDC + SADC;
	if ((-ABS_FLOAT_0 &lt; (SABC - SumSuqar)) &amp;&amp;
	 ((SABC - SumSuqar) &lt; ABS_FLOAT_0)) {
		return true;
	} else {
		return false;
		}
}
</code></pre> 
<hr> 
<p><strong>7.请你说一下你理解的 C++ 中的 Smart pointer 四个智能指针 : shared_ptr, unique_ptr, weak_ptr, auto_ptr.</strong></p> 
<p><strong>参考回答：</strong></p> 
<p>C++ 里面的四个智能指针 : auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。</p> 
<p><strong>为什么要使用智能指针：</strong></p> 
<p>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</p> 
<p><strong>1) auto_ptr（c++98的方案，cpp11已经抛弃）</strong></p> 
<p>采用所有权模式。</p> 
<pre><code class="prism language-c++">auto_ptr&lt; string&gt; p1 (new string ("I reigned lonely as a cloud.”));
auto_ptr&lt;string&gt; p2;
p2 = p1; //auto_ptr不会报错.
</code></pre> 
<p>此时不会报错，p2 剥夺了 p1 的所有权，但是当程序运行时访问 p1 将会报错。所以auto_ptr 的缺点是：存在潜在的内存崩溃问题！</p> 
<p><strong>2) unique_ptr（替换auto_ptr）</strong></p> 
<p>unique_ptr 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。</p> 
<p>采用所有权模式，还是上面那个例子</p> 
<pre><code class="prism language-c++">unique_ptr&lt;string&gt; p3 (new string ("auto"));   //#4
unique_ptr&lt;string&gt; p4；                       //#5
p4 = p3;//此时会报错！！
</code></pre> 
<p>编译器认为 p4=p3 非法，避免了 p3 不再指向有效数据的问题。因此，unique_ptr 比auto_ptr 更安全。</p> 
<p>另外 unique_ptr 还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</p> 
<pre><code class="prism language-c++">unique_ptr&lt;string&gt; pu1(new string ("hello world"));
unique_ptr&lt;string&gt; pu2;
pu2 = pu1;  // #1 not allowed
unique_ptr&lt;string&gt; pu3;
pu3 = unique_ptr&lt;string&gt;(new string ("You"));   // #2 allowed
</code></pre> 
<p>其中 #1 留下悬挂的 unique_ptr(pu1)，这可能导致危害。而 #2 不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。</p> 
<p>注：如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如：</p> 
<pre><code class="prism language-c++">unique_ptr&lt;string&gt; ps1, ps2;
ps1 = demo("hello");
ps2 = move(ps1);
ps1 = demo("alexia");
cout &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; endl;
</code></pre> 
<p><strong>3) shared_ptr</strong></p> 
<p>shared_ptr 实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字 share 就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数 use_count() 来查看资源的所有者个数。除了可以通过 new 来构造，还可以通过传入 auto_ptr, unique_ptr, weak_ptr 来构造。当我们调用 release() 时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。</p> 
<p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p> 
<p>成员函数：</p> 
<p>use_count 返回引用计数的个数</p> 
<p>unique 返回是否是独占所有权( use_count 为 1)</p> 
<p>swap 交换两个 shared_ptr 对象(即交换所拥有的对象)</p> 
<p>reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</p> 
<p>get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr sp(new int(1)); sp 与 sp.get()是等价的</p> 
<p><strong>4) weak_ptr</strong></p> 
<p>weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</p> 
<pre><code class="prism language-c++">class B;
class A {
	public:
		shared_ptr&lt;B&gt; pb_;
		~A() {
			cout&lt;&lt;"A delete\n";
		}
};
class B {
public:
	shared_ptr&lt;A&gt; pa_;
	~B() {
		cout&lt;&lt;"B delete\n";
	}
};
void fun() {
	shared_ptr&lt;B&gt; pb(new B());
	shared_ptr&lt;A&gt; pa(new A());
	pb-&gt;pa_ = pa;
	pa-&gt;pb_ = pb;
	cout&lt;&lt;pb.use_count()&lt;&lt;endl;
	cout&lt;&lt;pa.use_count()&lt;&lt;endl;
}
int main() {
	fun();
	return 0;
}
</code></pre> 
<p>可以看到 fun 函数中 pa ，pb 之间互相引用，两个资源的引用计数为 2，当要跳出函数时，智能指针 pa，pb 析构时两个资源引用计数会减一，但是两者引用计数还是为 1，导致跳出函数时资源没有被释放（A B 的析构函数没有被调用），如果把其中一个改为weak_ptr 就可以了，我们把类 A 里面的 shared_ptr pb_; 改为 weak_ptr pb_; 运行结果如下，这样的话，资源B的引用开始就只有 1，当 pb 析构时，B 的计数变为 0，B 得到释放，B 释放的同时也会使 A 的计数减一，同时 pa 析构时使 A 的计数减一，那么 A 的计数为 0，A 得到释放。</p> 
<p>注意的是我们不能通过 weak_ptr 直接访问对象的方法，比如 B 对象中有一个方法 print(),我们不能这样访问，pa-&gt;pb_-&gt;print(); 英文 pb_ 是一个 weak_ptr，应该先把它转化为shared_ptr, 如：shared_ptr p = pa-&gt;pb_.lock(); p-&gt;print();</p> 
<hr> 
<p><strong>8.怎么判断一个数是二的倍数，怎么求一个数中有几个1，说一下你的思路并手写代码</strong></p> 
<p><strong>参考回答：</strong></p> 
<ol><li>判断一个数是不是二的倍数，即判断该数二进制末位是不是0：</li></ol> 
<pre><code class="prism language-c++">a % 2 == 0 或者a &amp; 0x0001 == 0。
</code></pre> 
<ol start="2"><li>求一个数中 1 的位数，可以直接逐位除十取余判断：</li></ol> 
<pre><code class="prism language-c++">int fun(long x) {
int _count = 0;
while(x) {
	if(x % 10 == 1)
	++_count;
	x /= 10;
}
	return _count;
}
int main() {
	cout &lt;&lt; fun(123321) &lt;&lt; endl;
	return 0;
}
</code></pre> 
<hr> 
<p><strong>9. 请回答一下数组和指针的区别</strong></p> 
<p><strong>参考回答：</strong></p> 
<p>指针和数组的主要区别如下：</p> 
<table><thead><tr><th align="center">区别</th><th align="center">指针</th><th align="center">数组</th></tr></thead><tbody><tr><td align="center"></td><td align="center">保存数据的地址</td><td align="center">保存数据</td></tr><tr><td align="center"></td><td align="center">间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据</td><td align="center">直接访问数据，</td></tr><tr><td align="center"></td><td align="center">通常用于动态的数据结构</td><td align="center">通常用于固定数目且数据类型相同的元素</td></tr><tr><td align="center"></td><td align="center">通过Malloc分配内存，free释放内存</td><td align="center">隐式的分配和删除</td></tr><tr><td align="center"></td><td align="center">通常指向匿名数据，操作匿名函数</td><td align="center">自身即为数据名</td></tr></tbody></table> 
<hr> 
<p><strong>10.请你回答一下野指针是什么？</strong></p> 
<p><strong>参考回答：</strong></p> 
<p>野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针。</p> 
<hr> 
<p><strong>11. 请你介绍一下 C++ 中的智能指针</strong></p> 
<p><strong>参考回答：</strong></p> 
<p>智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。C++ 11 中最常用的智能指针类型为 shared_ptr,它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配。当新增一个时引用计数加 1，当过期时引用计数减一。只有引用计数为 0 时，智能指针才会自动释放引用的内存资源。对shared_ptr 进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过 make_shared 函数或者通过构造函数传入普通指针。并可以通过 get 函数获得普通指针。</p> 
<hr> 
<p><strong>12.请你回答一下智能指针有没有内存泄露的情况</strong></p> 
<p><strong>参考回答：</strong></p> 
<p>当两个对象相互使用一个 shared_ptr 成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。例如：</p> 
<p><img src="https://images2.imgbox.com/47/98/vn37osny_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/07/a2/9joxOHpa_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e1/db/1MeFDIjG_o.png" alt="在这里插入图片描述"><br> 上述代码中，parent 有一个 shared_ptr 类型的成员指向孩子，而 child 也有一个shared_ptr 类型的成员指向父亲。然后在创建孩子和父亲对象时也使用了智能指针 c 和 p，随后将 c 和 p 分别又赋值给 child 的智能指针成员 parent 和 parent 的智能指针成员 child 。从而形成了一个循环引用：</p> 
<hr> 
<p><strong>13.请你来说一下智能指针的内存泄漏如何解决</strong></p> 
<p><strong>参考回答：</strong></p> 
<p>为了解决循环引用导致的内存泄漏，引入了 weak_ptr 弱指针，weak_ptr 的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。</p> 
<hr> 
<p><strong>14.请你理解 C++ 中的引用和指针</strong></p> 
<p><strong>参考回答：</strong></p> 
<p><strong>定义：</strong></p> 
<p>1、引用：</p> 
<p>C++是C语言的继承，它可进行过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。引用就是C++对C语言的重要扩充。引用就是某一变量的一个别名，对引用的操作与对变量直接操作完全一样。引用的声明方法：类型标识符 &amp;引用名=目标变量名；引用引入了对象的一个同义词。定义引用的表示方法与定义指针相似，只是用&amp;代替了*。</p> 
<p>2、指针：</p> 
<p>指针利用地址，它的值直接指向存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址的内存单元。</p> 
<p><strong>区别：</strong></p> 
<p>1、指针有自己的一块空间，而引用只是一个别名；</p> 
<p>2、使用 sizeof 看一个指针的大小是 4，而引用则是被引用对象的大小；</p> 
<p>3、指针可以被初始化为 NULL，而引用必须被初始化且必须是一个已有对象的引用；</p> 
<p>4、作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；</p> 
<p>5、可以有 const 指针，但是没有 const 引用；</p> 
<p>6、指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</p> 
<p>7、指针可以有多级指针（**p），而引用至于一级；</p> 
<p>8、指针和引用使用 ++ 运算符的意义不一样；</p> 
<p>9、如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</p> 
<hr>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6124f3038740dca7b99db5be72bfe159/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">排序——归并排序（Merge sort）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b0cb429f12022ee3f52dd382b94329bc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用shell脚本实现自动SSH互信功能（免密登录）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>