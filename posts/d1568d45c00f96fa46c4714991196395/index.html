<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C#（Csharp）学习这一篇文章就够了！！ - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C#（Csharp）学习这一篇文章就够了！！" />
<meta property="og:description" content="在学唐老狮的课程 顺便ab自己记录一下
C#是面向对象语言，也具备三大特征，ab会从这里开始。
C#——封装： 1.类和对象： 类的声明 和 类对象 声明是两个概念。
类的声明： 相当于自定义一个变量类型。
类对象：是从类里创建出来的，而创建对象的过程称之为实例化对象。
2.成员变量和访问修饰符： 成员变量：要声明在类中，用来描述对象的特征，可以是任意变量类型(可以在一个类中声明别的类)，同时成员变量的数量不做限制，而是否要赋值根据需求决定。
成员变量的默认值： 值类型 数字类型都是0，bool类型为false，引用类型为null。
注意: 如果要在类中声明一个和自己相同类型的成员变量时，不能对它进行实例化。
访问修饰符：
public —公共的：自己（内部）和别人（外部）都能访问和使用。‘
private —私有的： 自己（内部）才能访问和使用；不写的时候默认为private。
protected —保护的： 自己（内部）和子类才能访问和使用。
3.成员方法： 成员方法（函数）用来表现对象行为，并且受到访问修饰符的影响，返回值参数不做限定，成员方法的数量也不做限制。
注意： 成员方法不能加Static关键字，使用时必须实例化出对象，再通过对象使用（可以想成某个对象执行了某个行为）。
练习： 定义一个老师类和学生类，再定义一个实物类，有名字，并让他们联系起来
如：老师吃了什么什么,学生吃了什么什么。
4.构造函数： 在实例化对象（new对象）时，会调用用于初始化的函数，就叫做构造函数。在不写构造函数的时候，会有一个默认的无参构造函数。
构造函数的写法：没有返回值，函数名必须和类名相同，没有特殊需求时都是public，并且构造函数可以被重载。
注意： 如果自己没有写无参构造函数，却写了有参构造函数，默认的无参构造函数会被顶掉。
练习： 5.成员属性： 是用于保护成员变量的，为成员变量的获取和赋值添加逻辑处理，也可以解决public，private，protected的局限性。属性可以让成员变量在外部（可读不可写)，(可读只有本类可写)等等.
上面就是一个属性，相当于把小写的name包裹了一层。
get和set可以只写一个
注意： 1. 当get set前面什么都不写时，会使用声明时的访问权限。
2.加的访问修饰符要低于属性的访问权限。（get和set的访问权限不能比声明变量时的大）
3.不能让get和set的权限都低于属性的权限。（两个都写就让声明的访问修饰符没用了） 6.静态成员： 用Static修饰的成员变量，方法，属性等，都叫做静态成员。
静态成员可以直接通过类名点出来使用
静态成员属于这个类！并不属于这个类的实例对象。
注意： 静态成员在程序运行后就会存在。静态函数中不能使用非静态成员（因为成员变量要将对象实例化出来后,才能点出来使用,不能无中生有），想要使用可以在静态函数中实例化一个。
报错
没报错
说的更细一点就是 静态成员方法在程序一运行就有了，但是你还没有声明别的变量，所以此时不能使用非静态变量（无中生有了就是）， 但是如果你在静态成员方法中实例化了过了，那就能用。
常量和静态变量的区别：
相同点：他们都可以通过类名点出来使用。
不同点：1.const必须初始化 不能修改，而static没有这个限制。
2.const只能修饰变量，static可以修饰很多。
3.const一定是卸载访问修饰符后的，static没有这个要求。
7.静态类和静态构造函数： 静态类：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/d1568d45c00f96fa46c4714991196395/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-02T21:19:05+08:00" />
<meta property="article:modified_time" content="2024-02-02T21:19:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C#（Csharp）学习这一篇文章就够了！！</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在学唐老狮的课程 顺便ab自己记录一下</p> 
<p>C#是面向对象语言，也具备三大特征，ab会从这里开始。</p> 
<h2><span style="color:#fe2c24;">C#——封装：</span></h2> 
<h4><span style="background-color:#38d8f0;">1.类和对象：</span></h4> 
<p><strong>类的声明</strong> 和 <strong>类对象</strong> 声明是两个概念。</p> 
<p><strong>类的声明：</strong> 相当于自定义一个变量类型。</p> 
<p><img alt="" height="87" src="https://images2.imgbox.com/1d/ab/70qFWXfS_o.png" width="135"></p> 
<p><strong>类对象：</strong>是从类里创建出来的，而创建对象的过程称之为实例化对象。</p> 
<p><img alt="" height="47" src="https://images2.imgbox.com/93/70/HUG9nihd_o.png" width="232"></p> 
<p></p> 
<h4></h4> 
<h4><span style="background-color:#38d8f0;">2.成员变量和访问修饰符：</span></h4> 
<p><strong>成员变量：</strong>要声明在类中，用来描述对象的特征，可以是任意变量类型(可以在一个类中声明别的类)，同时成员变量的数量不做限制，而是否要赋值根据需求决定。</p> 
<p>成员变量的<strong>默认值：</strong> 值类型 数字类型都是0，bool类型为false，引用类型为null。</p> 
<h6><span style="color:#0d0016;"><strong>注意: </strong></span></h6> 
<p>如果要在类中声明一个和自己相同类型的成员变量时，不能对它进行实例化。</p> 
<p></p> 
<p><strong>访问修饰符：</strong></p> 
<p>public —公共的：自己（内部）和别人（外部）都能访问和使用。‘</p> 
<p>private —私有的： 自己（内部）才能访问和使用；不写的时候默认为private。</p> 
<p>protected —保护的： 自己（内部）和子类才能访问和使用。</p> 
<h4></h4> 
<h4><span style="background-color:#38d8f0;">3.成员方法：</span></h4> 
<p>成员方法（函数）用来表现<strong>对象</strong>行为，并且受到访问修饰符的影响，返回值参数不做限定，成员方法的数量也不做限制。</p> 
<h6><span style="color:#0d0016;"><strong>注意：</strong></span></h6> 
<p>成员方法不能加Static关键字，使用时必须实例化出对象，再通过对象使用（可以想成某个对象执行了某个行为）。</p> 
<h6>练习：</h6> 
<p>定义一个老师类和学生类，再定义一个实物类，有名字，并让他们联系起来</p> 
<p>如：老师吃了什么什么,学生吃了什么什么。</p> 
<p><img alt="" height="217" src="https://images2.imgbox.com/d1/82/vfKWQLyM_o.png" width="505"></p> 
<p></p> 
<h4></h4> 
<h4><span style="background-color:#38d8f0;">4.构造函数：</span></h4> 
<p>在实例化对象（new对象）时，会调用用于初始化的函数，就叫做构造函数。在不写构造函数的时候，会有一个默认的无参构造函数。</p> 
<p><strong>构造函数的写法：</strong>没有返回值，函数名必须和类名相同，没有特殊需求时都是public，并且构造函数可以被重载。</p> 
<h6><span style="color:#0d0016;"><strong>注意：</strong></span></h6> 
<p>如果自己没有写无参构造函数，却写了有参构造函数，默认的无参构造函数会被<strong>顶掉</strong>。</p> 
<p></p> 
<p></p> 
<h6>练习：</h6> 
<p><img alt="" height="171" src="https://images2.imgbox.com/cb/cf/tSyzkqrS_o.png" width="443"></p> 
<p></p> 
<p><img alt="" height="593" src="https://images2.imgbox.com/4c/36/WI9KwNFW_o.png" width="365"></p> 
<p></p> 
<p></p> 
<h4 style="background-color:transparent;"><span style="background-color:#38d8f0;">5.成员属性：</span></h4> 
<p>是用于<strong>保护成员变量的</strong>，为成员变量的获取和赋值添加逻辑处理，也可以解决public，private，protected的局限性。属性可以让成员变量在外部（可读不可写)，(可读只有本类可写)等等.</p> 
<p><img alt="" height="340" src="https://images2.imgbox.com/25/d0/Yf7y74H6_o.png" width="405"></p> 
<p>上面就是一个属性，相当于把小写的name包裹了一层。</p> 
<p>get和set可以只写一个</p> 
<h6><strong>注意：</strong></h6> 
<p>1. 当get set前面什么都不写时，会使用声明时的访问权限。</p> 
<p>2.加的访问修饰符要低于属性的访问权限。（get和set的访问权限不能比声明变量时的大）</p> 
<p> <img alt="" height="270" src="https://images2.imgbox.com/e5/e0/0kVWK7IB_o.png" width="269"></p> 
<p>3.不能让get和set的权限都低于属性的权限。（两个都写就让声明的访问修饰符没用了） </p> 
<p><img alt="" height="264" src="https://images2.imgbox.com/a7/74/NO4DcjDZ_o.png" width="263"></p> 
<p></p> 
<h4><span style="background-color:#38d8f0;">6.静态成员：</span></h4> 
<p>用Static修饰的成员变量，方法，属性等，都叫做静态成员。</p> 
<p>静态成员可以直接通过类名点出来使用</p> 
<p>静态成员属于这个类！并不属于这个类的实例对象。</p> 
<p></p> 
<h6><span style="color:#0d0016;"><strong>注意：</strong></span></h6> 
<p>静态成员在程序运行后就会存在。静态函数中不能使用非静态成员（因为成员变量要将对象实例化出来后,才能点出来使用,不能无中生有），想要使用可以在静态函数中实例化一个。</p> 
<p><img alt="" height="313" src="https://images2.imgbox.com/23/0a/YfGi9a6z_o.png" width="494">报错</p> 
<p><img alt="" height="254" src="https://images2.imgbox.com/3e/29/29h9bSgM_o.png" width="528">没报错</p> 
<p></p> 
<p>说的更细一点就是 静态成员方法在程序一运行就有了，但是你还没有声明别的变量，所以此时不能使用非静态变量（无中生有了就是）， 但是如果你在静态成员方法中实例化了过了，那就能用。</p> 
<p></p> 
<p><strong>常量和静态变量的区别：</strong></p> 
<p>相同点：他们都可以通过类名点出来使用。</p> 
<p>不同点：1.const必须初始化 不能修改，而static没有这个限制。</p> 
<p>                2.const只能修饰变量，static可以修饰很多。</p> 
<p>                3.const一定是卸载访问修饰符后的，static没有这个要求。</p> 
<p></p> 
<h4><span style="background-color:#38d8f0;">7.静态类和静态构造函数：</span></h4> 
<p><strong>静态类：</strong></p> 
<p>就是class前面加了static，静态类只能包含静态成员，不能被实例化。</p> 
<p>作用：工具类，拓展方法用。</p> 
<p></p> 
<p><strong>静态构造函数：</strong></p> 
<p>就是在构造函数上加static。可以在静态构造函数中初始化静态变量。</p> 
<h6>注意：</h6> 
<p>1.静态类和非静态类都可以有。</p> 
<p>2.不能使用访问修饰符。</p> 
<p>3.不能有参数</p> 
<p>4.只会自动调用一次。<strong>（静态构造函数只会在第一次使用这个类时调用一次）</strong></p> 
<p>作用：初始化<strong>静态成员</strong>。</p> 
<p></p> 
<p></p> 
<h4><span style="background-color:#38d8f0;">8.拓展方法：</span></h4> 
<p>为现有 <strong>非静态 变量类型</strong> 添加新方法。</p> 
<p><img alt="" height="41" src="https://images2.imgbox.com/42/53/YTK6affk_o.png" width="574"></p> 
<p>为非静态变量类型 添加方法，也就是说要从<span style="color:#0d0016;"><strong>实例</strong></span>点出来用。</p> 
<h6>注意：</h6> 
<p>1.一定是写在静态类中。</p> 
<p>2.一定是个静态函数</p> 
<p>3.第一个参数为拓展目标（类）</p> 
<p>4.第一个参数用this修饰</p> 
<p></p> 
<h6>练习：</h6> 
<p>为整形拓展一个求平方的方法：</p> 
<p><img alt="" height="316" src="https://images2.imgbox.com/0d/d5/gAXOXkgc_o.png" width="321"></p> 
<h4><br><span style="background-color:#38d8f0;">9.内部类和分布类（partial）：</span></h4> 
<p><span style="color:#0d0016;"><strong>内部类：</strong></span></p> 
<p>在类的内部声明的类，使用时要用包裹的类点出自己，访问修饰符的作用很大。</p> 
<p>如：</p> 
<p><img alt="" height="472" src="https://images2.imgbox.com/4d/74/iwfQoW6U_o.png" width="406"></p> 
<p><img alt="" height="88" src="https://images2.imgbox.com/fd/6c/Xew9aE4F_o.png" width="420"></p> 
<p></p> 
<p><span style="color:#0d0016;"><strong>分布类（partial）：</strong></span></p> 
<p>把一个类分成几部分声明，增加拓展性。</p> 
<p><img alt="" height="489" src="https://images2.imgbox.com/b0/bb/i4OGyy32_o.png" width="284"></p> 
<h6>注意：</h6> 
<p>分布类可以写在多个脚本中，并且他们的访问修饰符要一致，最后不能有重复的成员。</p> 
<p></p> 
<p></p> 
<p></p> 
<h2><span style="color:#fe2c24;">C#——继承：</span></h2> 
<h4><span style="background-color:#38d8f0;">1.继承的基本原则：</span></h4> 
<p>一个类A继承一个类B，类A将会继承类B的所有成员，A类将拥有B类的所有特征行为。</p> 
<p>被继承的类：叫做<strong>父类</strong>或<strong>基类</strong>。</p> 
<p>继承的类：叫做<strong>子类</strong>或<strong>派生类</strong>。</p> 
<p><span style="color:#0d0016;"><strong>子类</strong></span>将<span style="color:#0d0016;"><strong>拥有父类</strong></span>所有特征和行为，并且子类可以有自己的特征和行为，也受到访问修饰符的影响。</p> 
<p>public—公共，内外部访问。</p> 
<p>private—私有，内部访问。</p> 
<p>protected—保护，内部和子类访问。</p> 
<p>internal—内部，只有在同一个程序集的文件中，内部类型或者是成员才能访问。</p> 
<p></p> 
<p>特点：</p> 
<p>1.单根性：子类只能由一个父类。</p> 
<p>2.传递性：子类可以间接继承父类的父类。</p> 
<p></p> 
<p></p> 
<h4><span style="background-color:#38d8f0;">2.里氏替换原则：</span></h4> 
<p>里氏替换原则是面向对象七大原则中最重要的原则。</p> 
<p>即：任何父类出现的地方，子类都可以代替（因为子类对象包含了父类所有内容），<span style="color:#0d0016;"><strong>父类容器装子类对象</strong></span>。</p> 
<p><img alt="" height="474" src="https://images2.imgbox.com/90/a0/jF0XMu1l_o.png" width="398"></p> 
<p>这里用父类装载了子类（Player）那他可以用Player类的成员方法吗？</p> 
<p><img alt="" height="494" src="https://images2.imgbox.com/7c/79/recELBIr_o.png" width="398"></p> 
<p>显然是不行的，<strong>方法是在子类里的，而你声明的是父类对象。</strong></p> 
<p>父类 对象名 = new 子类（）;</p> 
<p>        这时就要用到 ↓ 下面的知识点 ↓</p> 
<p></p> 
<h6>is和as：</h6> 
<p>is：<strong>用于判断</strong>，判断一个对象是否是指定类对象。        <strong>返回值：bool，是为true，不是false。</strong></p> 
<p>as：<strong>用于转换</strong>，将一个对象转换为指定类对象。           <strong>返回值：指定类型对象（转换成功时），失败则返回null。</strong></p> 
<p></p> 
<p><img alt="" height="300" src="https://images2.imgbox.com/7b/d0/y4wpct7S_o.png" width="448"></p> 
<p></p> 
<h6>练习：</h6> 
<p>写一个Monster类，派生出Boss和Goblin两个类，Boss有技能；小怪有攻击；随机生成十个怪，装载到数组中，最后遍历这个数组调用他们的攻击方法。</p> 
<p></p> 
<p><img alt="" height="597" src="https://images2.imgbox.com/7d/d4/vFvXfDii_o.png" width="495"></p> 
<p></p> 
<p></p> 
<h4><span style="background-color:#38d8f0;">3.继承中的构造函数：</span></h4> 
<p>当声明一个子类对象时，会先执行父类的构造函数，再执行子类的构造函数。</p> 
<p>父类的父类的构造函数—→ 父类构造函数—→子类构造函数。（执行顺序） </p> 
<p>如图：</p> 
<p><img alt="" height="595" src="https://images2.imgbox.com/c3/7e/iQhLLJFW_o.png" width="400"></p> 
<p><img alt="" height="64" src="https://images2.imgbox.com/30/66/MAbQFjTw_o.png" width="200"></p> 
<p>这个类还是Grandpa但是 new的是son所以会调用上面的构造函数。</p> 
<p></p> 
<p>通过<span style="color:#0d0016;"><strong>base</strong></span>可以调用父类的构造函数（类型要一样吗，如下图）</p> 
<p><img alt="" height="654" src="https://images2.imgbox.com/76/72/8IK17bjb_o.png" width="363"></p> 
<p>输出结果会打印出ab</p> 
<p></p> 
<h6>注意：</h6> 
<p>1.父类的无参构造函数很重要（被顶掉的话）</p> 
<p>2.子类可以通过base代表父类 调用父类构造函数。</p> 
<p></p> 
<h6>练习：</h6> 
<p>有一个打工人基类，有工种、工作内容两个特征，一个工作方法，</p> 
<p>程序员、策划、美术分别继承打工人，用继承中的构造函数知识点</p> 
<p>实例化三个对象，分别是程序员、策划、美术。</p> 
<p></p> 
<p><img alt="" height="634" src="https://images2.imgbox.com/ac/f0/o2eO6dLh_o.png" width="546"></p> 
<p><img alt="" height="507" src="https://images2.imgbox.com/3d/56/w5UQzZ3l_o.png" width="469"></p> 
<p>可以想象成 子类的无参构造函数 调用了父类的有参构造函数 而传递的参数就是自己后面定的。</p> 
<p></p> 
<h4><span style="background-color:#38d8f0;">4.万物之父object和装箱拆箱：</span></h4> 
<p><span style="color:#0d0016;"><strong>万物之父object：</strong></span></p> 
<p>关键字是object，它是<strong>所有类型</strong>的基类，是<strong>引用类型。</strong></p> 
<p>可以利用里氏替换原则，用object容器装所有对象。也可以用来表示不确定类型，作为函数参数类型。</p> 
<p>当用<strong>object储存值类型</strong>时：（用强转）</p> 
<p><img alt="" height="86" src="https://images2.imgbox.com/52/d5/yp4fWfdv_o.png" width="282"></p> 
<p>当用<strong>object储存引用类型</strong>时：（用is和as来判断和转换）</p> 
<p><img alt="" height="161" src="https://images2.imgbox.com/75/e5/8YJPKcRQ_o.png" width="426"></p> 
<p></p> 
<p><span style="color:#0d0016;"><strong>装箱和拆箱：</strong></span></p> 
<p>发生条件：</p> 
<p><strong>装箱：</strong>用object存值类型</p> 
<p>把<span style="color:#0d0016;">值类型</span>用<span style="color:#0d0016;">引用类型</span>存储，栈内存会迁移到堆内存中。</p> 
<p><strong>拆箱：</strong>再把object转为值类型</p> 
<p>把引用类型存储的值取出来，堆内存会迁移到栈内存中。</p> 
<p><img alt="" height="133" src="https://images2.imgbox.com/fe/70/OW67nTGz_o.png" width="184"></p> 
<p>好处：不确定类型时可以方便参数的存储和传递。</p> 
<p>坏处：存在内存迁移，层架性能消耗。</p> 
<p></p> 
<h4><span style="background-color:#38d8f0;">5.密封类sealed：</span></h4> 
<p>密封类：使用关键字sealed修饰的<strong>类</strong>，会让该类无法再被继承。（可以理解为让类 结扎）</p> 
<p>在面向对象程序设计中，密封类主要作用就是不允许最底层子类被继承，可以保证程序的规范性，安全性。</p> 
<p><img alt="" height="279" src="https://images2.imgbox.com/7f/88/Xp4vCbde_o.png" width="380"></p> 
<h2><span style="color:#fe2c24;">C#——多态：</span></h2> 
<h4><span style="background-color:#38d8f0;">1.多态概念：</span></h4> 
<p>字面意思就是“多种状态”。</p> 
<p>让<span style="color:#0d0016;">继承同一个父类的子类们</span>，在<span style="color:#0d0016;">执行相同方法的时有不同的表现。</span></p> 
<p><span style="color:#0d0016;">（同一父类的对象 </span><span style="color:#0d0016;">        </span><span style="color:#0d0016;"> 执行相同行为（方法）</span><span style="color:#0d0016;">      有不同的表现</span><span style="color:#0d0016;">）</span></p> 
<p><span style="color:#0d0016;">让同一个对象有唯一行为的特征。</span></p> 
<p></p> 
<p><span style="color:#fe2c24;">多态的实现：</span></p> 
<p>运行时多态（vob，抽象函数，接口）。</p> 
<p><strong>vob中：</strong></p> 
<p><strong>v:virtual(虚函数)：用来给子类重写的。</strong></p> 
<p><strong>o:override(重写)：跟virtual配套出现的，用来重写方法。</strong></p> 
<p><strong>b:base(父类)：代表父类，通过base来保留父类行为。</strong></p> 
<p></p> 
<h6>练习：</h6> 
<p>创建一个图形类，有求周长和求面积两个方法。</p> 
<p>创建矩形类和圆形类继承图形类。</p> 
<p>实例化矩形，圆形对象求面积周长。</p> 
<p></p> 
<p><img alt="" height="618" src="https://images2.imgbox.com/6e/d2/RNMvlUEH_o.png" width="481"></p> 
<p><img alt="" height="569" src="https://images2.imgbox.com/18/9a/S32xngTZ_o.png" width="487"></p> 
<p><img alt="" height="175" src="https://images2.imgbox.com/a9/09/vjG0Sz0w_o.png" width="962"></p> 
<p></p> 
<h4><span style="background-color:#38d8f0;">2.抽象类和抽象方法(abstract)：</span></h4> 
<p><strong><span style="color:#0d0016;">抽象类：</span></strong></p> 
<p>被关键字abstract修饰的类，就叫抽象类。</p> 
<p><strong>不能被实例化</strong>、可以包含抽象方法、继承抽象必须重写其抽象方法。</p> 
<p><strong>抽象类中，封装所有的知识都可以写在其中（包括里氏替换原则）！！</strong></p> 
<p><img alt="" height="262" src="https://images2.imgbox.com/c4/39/qW7e4M2Y_o.png" width="426"></p> 
<p><img alt="" height="576" src="https://images2.imgbox.com/59/9d/tPCh5Py7_o.png" width="399"></p> 
<p></p> 
<p><span style="color:#fe2c24;"><strong>抽象函数：</strong></span></p> 
<p>抽象方法又叫纯虚方法，即用abstract关键字 修饰的方法。</p> 
<p><strong>只能在抽象类中声明、没有方法体、不能是私有的、继承后必须用override重写。</strong></p> 
<p><img alt="" height="394" src="https://images2.imgbox.com/e0/69/lzcwe5jS_o.png" width="434"></p> 
<p></p> 
<h6>抽象方法(abstract)和虚方法(virtual)的区别：</h6> 
<p> <img alt="" height="628" src="https://images2.imgbox.com/65/d3/Um46CyNY_o.png" width="476"></p> 
<p>抽象方法（abstra）：</p> 
<p>1.不能有方法体，而且必须被子类重写。</p> 
<p>2.只能声明在抽象类中。</p> 
<p>虚方法（virtual）：</p> 
<p>1.虚方法是有方法体的，也可以调用，可以被子类选择性重写。</p> 
<p>2.虚方法可以在任何非密封类中声明。</p> 
<p></p> 
<p><strong>共同点：</strong></p> 
<p>1.都可以无限被子类重写。</p> 
<p>2.都可以base重用。</p> 
<p></p> 
<h6>注意：</h6> 
<p>如何选择使用普通类还是抽象类呢？</p> 
<p>不希望被实例化的对象，相对于比较抽象的类可以用抽象类。</p> 
<p>父类中的行为不太需要被实现的，只希望子类定义具体规则的 可以选择使用抽象类。</p> 
<p>（用于整体框架设计 会使用）</p> 
<p></p> 
<p></p> 
<h4><span style="background-color:#38d8f0;">3.接口（interface）：</span></h4> 
<p>接口是<strong>行为的抽象规范</strong>！！！！</p> 
<p>是一种自定义类型，关键字为：interface。</p> 
<p></p> 
<p><span style="color:#fe2c24;">接口声明规范：</span></p> 
<p>1.不包含成员变量。</p> 
<p>2.只包含方法、属性、索引器、事件。</p> 
<p>3.成员不能被实现。（不能写方法体）</p> 
<p>4.成员可以不用写访问修饰符，不能是私有的。（此处不写默认是public）</p> 
<p>5.接口不能继承类，但是可以继承另一个接口。</p> 
<p></p> 
<p><span style="color:#fe2c24;">接口使用规范：</span></p> 
<p>1.类可以继承多个接口。（类只能继承一个类）</p> 
<p>2.类继承接口后，必须实现接口中所有成员。</p> 
<p></p> 
<p><img alt="" height="634" src="https://images2.imgbox.com/a2/d5/L39556SD_o.png" width="658"></p> 
<p>特点：</p> 
<p>1.和类的声明类似。</p> 
<p>2.接口是用来继承的。</p> 
<p>3.接口不能被实例化，但是可以作为容器存储对象。</p> 
<p></p> 
<p><img alt="" height="445" src="https://images2.imgbox.com/78/54/YJi1y0qn_o.png" width="970"></p> 
<p></p> 
<p>通过接口 飞机 跟鸟类建立起了联系（让不同种类的子类有联系），就可以用里氏转换原则，用一个接口父类，存储不同类型的对象。</p> 
<p>IFly f =  new （飞机）;     or   IFly f =  new （鸟）;   </p> 
<p>里氏转换原则 用IFly来存储<strong>不同种类</strong> 又有<strong>相同行为</strong>的对象。</p> 
<p></p> 
<p></p> 
<p><span style="color:#fe2c24;">当接口继承接口时：</span></p> 
<p>接口继承接口时 不需要实现。</p> 
<p>等待 类继承接口后  类自己去实现所有内容。</p> 
<p><img alt="" height="813" src="https://images2.imgbox.com/00/b1/G1qRSxFL_o.png" width="637"></p> 
<p></p> 
<p>接口总结：</p> 
<p><img alt="" height="324" src="https://images2.imgbox.com/40/c4/ODRsSzxh_o.png" width="667"></p> 
<p></p> 
<p></p> 
<h4><span style="background-color:#38d8f0;">4.密封方法：</span></h4> 
<p>用密封关键字sealed修饰的重写函数，让<strong>虚方法</strong>（virtual）或者<strong>抽象方法</strong>（abstract）之后不能再被重写。（会和override一起出现）</p> 
<p></p> 
<p></p> 
<h2><span style="color:#fe2c24;">C#——面向对象关联的一些知识点：</span></h2> 
<p></p> 
<h4><span style="background-color:#38d8f0;">1.命名空间：</span></h4> 
<p>命名空间是用来组织和重用代码的，用来包裹类的。就像是一个工具包，类就像是一件一件的工具，都是声明在命名空间中的。</p> 
<p></p> 
<p>语法：</p> 
<p>namespace  命名空间名</p> 
<p>{<!-- --></p> 
<p>        class 类名</p> 
<p>        class 类名</p> 
<p>}</p> 
<p></p> 
<h6>注意：</h6> 
<p>1.命名空间是可以分开声明的（和分布类一样），但是里面的类名不能有重复的。</p> 
<p>2.不同命名空间中相互使用 需要引用命名空间或指明出处（即使是写在同一个脚本中）</p> 
<p>3.不同命名空间中 允许有同名类。</p> 
<p>4.命名空间可以包裹命名空间。（using 包裹的命名空间名.被包裹的）</p> 
<p></p> 
<p></p> 
<h4><span style="background-color:#38d8f0;">2.万物之父（objcet）中的方法：</span></h4> 
<p>万物之父 object。是所有类型的基类（引用类型）</p> 
<p>可以利用里氏替换原则装载一切对象。存在装箱拆箱。</p> 
<p></p> 
<p><strong>1.object中的静态方法：</strong></p> 
<p><span style="color:#956fe7;">Equals：</span>判断两个对象是否相等。 返回bool</p> 
<p>最终判断权交给左侧对象的Equals方法，不管值类型or引用类型都会按照左侧对象的Equals方法的规则来进行比较。<strong>（引用类型判断相等，是看有没有指向同一个内存地址，并不是字面上的同一个类）。</strong></p> 
<p></p> 
<p><span style="color:#956fe7;">ReferenceEquals：</span>比较两个对象是否是相同的引用。</p> 
<p>主要用来比较引用类型的对象。值类型对象的返回值始终是false。</p> 
<p></p> 
<p>Equals是比值类型的，ReferenceEquals是比引用类型的。</p> 
<p></p> 
<p><strong>2.objcet中的成员方法：</strong></p> 
<p><span style="color:#956fe7;">GetType：</span>用于获取对象运行时的类型Type，通过Type结合反射相关知识可以做很多关于对象的操作。</p> 
<p><img alt="" height="44" src="https://images2.imgbox.com/07/5f/A2cOxHKC_o.png" width="246"></p> 
<p></p> 
<p><span style="color:#956fe7;">MemberwiseClone：</span>用于获取对象的浅拷贝对象。（理解为克隆的不干净，克隆了一个引用类型对象和老的一样，值类型是可以改的）</p> 
<p>说白了就是会返回一个新的对象，但是新的对象中的引用类型会和老对象中一致（也就是指向同一个内存地址）。</p> 
<p>        不能通过 对象.出来用 是因为他是保护（propted）类型。</p> 
<p></p> 
<p><strong>3.object中的虚方法：</strong></p> 
<p><span style="color:#956fe7;">虚方法Equals：</span></p> 
<p>我们可以重写该方法，定义自己比较相等的规则。</p> 
<p></p> 
<p><span style="color:#956fe7;">虚方法GetHashCode：</span></p> 
<p>该方法是获取对象的哈希码。通过重写该函数来自己定义对象的哈希码算法。</p> 
<p></p> 
<p><span style="color:#956fe7;">虚方法ToString：</span></p> 
<p>用于返回当前对象代表的字符串。通过重写该函数来自己定义对象转字符的规则。</p> 
<p>在打印方法时，默认使用的就是对象的Tostring方法打印出来的内容。</p> 
<p></p> 
<h6>练习：</h6> 
<p>一个Monster的类的引用对象a，Monster类有攻击力，防御力，技能名，血量等属性。</p> 
<p>我想复制一个和a对象一模一样的b对象，并且改变b的属性a不会受到影响怎么办？</p> 
<p><img alt="" height="577" src="https://images2.imgbox.com/2c/3e/SYVhrQx1_o.png" width="539"></p> 
<p></p> 
<h4><span style="background-color:#38d8f0;">3.结构体和类的区别：</span></h4> 
<p>结构体和类的最大区别是在存储空间上的，因为<strong>结构体是值</strong>类型，<strong>类是引用</strong>类型。因此他们的存储位置一个是在栈上，一个是在堆上。</p> 
<p>两者在使用上很相似，结构体甚至可以用面向对象的思想来形容一类对象。</p> 
<p>但是 <strong>结构体只具备封装的特性，并不具备继承和多态的特性</strong>，因此大大减少了它的使用频率。</p> 
<p>由于结构体不具备继承和多态，所以他不能够使用protected访问修饰符。</p> 
<p></p> 
<p></p> 
<p><span style="color:#fe2c24;">细节区分：</span></p> 
<p>1.结构体是值类型所以在栈中。类是引用类型所以在堆中。</p> 
<p>2.结构体不具备继承和多态的特性，不能用protected访问修饰符。类则全具备三大特征。</p> 
<p>3.结构体成员变量声明不能指定初始值。类可以。</p> 
<p>4.结构体不能声明无参的构造函数。类可以。</p> 
<p>5.结构体声明有参构造函数后，无参构造函数不会被顶掉。而类的会被顶掉。</p> 
<p>6.结构体需要在构造函数中初始化所有变量成员，而类随意。</p> 
<p>7.结构体不能被继承。类可以。</p> 
<p>8.结构体不能声明析构函数。类可以。</p> 
<p>9.结构体不能被Static修饰。类可以。</p> 
<p>10.结构体不能在自己内部声明和自己一样的结构体变量。类可以。</p> 
<p>注意：结构体可以继承接口。</p> 
<p></p> 
<p>在什么时候使用结构体和类呢？</p> 
<p>1.想要用继承和多态时，直接淘汰结构体 用类，比如玩家，怪物等等。</p> 
<p>2.对象是数据集合时 优先考虑结构体，比如位置、坐标等等。</p> 
<p>3.从值类型和引用类型赋值时的区别上去考虑，比如经常被赋值传递的对象，并且改变赋值对象，原对象不想跟着变化时，就用结构体，比如坐标、向量、旋转等等。</p> 
<p></p> 
<h4><img alt="" height="672" src="https://images2.imgbox.com/ec/d4/bNlI5ygP_o.png" width="1004"></h4> 
<h4></h4> 
<h4></h4> 
<h4><br><br><span style="background-color:#38d8f0;">4.抽象类和接口的区别和相同点：</span></h4> 
<p>抽象类（abstract）：</p> 
<p>abstract修饰的类和方法。</p> 
<p>抽象类<strong>不能被实例化</strong>。</p> 
<p>抽象方法只能在抽象类中声明 是个<strong>纯虚方法</strong>，必须在子类中实现。</p> 
<p></p> 
<p></p> 
<p>接口（interface）：</p> 
<p>interface 自定义类型。</p> 
<p>是行为的抽象。</p> 
<p><strong>不包含成员变量，仅包含方法，属性，索引器，事件。成员都不能实现</strong>，不写访问修饰符时默认为public。</p> 
<p></p> 
<p><span style="color:#fe2c24;">抽象类和接口的相同点：</span></p> 
<p>1.都可以被继承。</p> 
<p>2.都不能直接实例化。</p> 
<p>3.都可以包含方法声明。</p> 
<p>4.子类必须实现未实现的方法。</p> 
<p>5.都遵循里氏替换原则。</p> 
<p><img alt="" height="559" src="https://images2.imgbox.com/a6/ad/kGJ5tPq9_o.png" width="455"></p> 
<p></p> 
<p></p> 
<p><img alt="" height="538" src="https://images2.imgbox.com/ed/3d/usj85QWD_o.png" width="920"></p> 
<p></p> 
<p></p> 
<p><span style="color:#fe2c24;">抽象类和接口的不同点：</span></p> 
<p>1.抽象类中可以有构造函数；接口则不能。</p> 
<p>2.抽象类只能被单一继承，接口则可以被继承多个。</p> 
<p>3.抽象类中可以有成员变量；接口则不能。</p> 
<p>4.抽象类方法可以使用访问修饰符；接口则建议不写 ，因为默认public。</p> 
<p>5.抽象类中可以声明成员方法、虚方法、抽象方法 静态方法；接口则只能声明没有实现的抽象方法。</p> 
<p><img alt="" height="600" src="https://images2.imgbox.com/57/4c/VwEoJHsS_o.png" width="990"></p> 
<p></p> 
<p><span style="color:#0d0016;">什么时候用抽象类：</span>表示对象的用抽象类。</p> 
<p><span style="color:#0d0016;">什么时候用接口：</span>表示行为拓展的用接口。不同对象拥有的共同行为，可以使用接口来实现。</p> 
<p>比如：动物是一类对象，可以选择抽象类；而飞翔是一个行为，并不是所有动物都会飞翔，就可以用接口。</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h4><span style="background-color:#38d8f0;">5.UML类图：</span></h4> 
<p>使用一些UML可视化软件，不用写代码，通过一些图标相关内容就可以直接生成代码，在其基础上进行开发。（最终目的就是能通过图形就把业务逻辑就完成了）</p> 
<p>但是本文中的UML类图是uml其中很小的一部分，学习它的目的是为了帮助我们在进行面向对象程序开发时，更好的理清对象关系，养成面向对象编程的习惯。</p> 
<p>就用VISIO。</p> 
<p><img alt="" height="775" src="https://images2.imgbox.com/54/b5/Y2g4eacu_o.png" width="1200"></p> 
<p>(设置方法)</p> 
<p>如：</p> 
<p><img alt="" height="576" src="https://images2.imgbox.com/32/d1/zX5VNhSC_o.png" width="857"></p> 
<p></p> 
<h4><span style="background-color:#38d8f0;">6.面向对象七大原则：</span></h4> 
<p><span style="color:#fe2c24;">一：单一职责原则(SRP) </span>Single Responsibility Principle</p> 
<p><span style="color:#0d0016;">类被修改的几率很大，因此应该专注于单一功能。如果把多个功能放在同一个类里，功能之间就形成了关联，改变其中一个功能时有可能会终止另一个功能。</span></p> 
<p><strong>如：</strong>策划、程序、美术是三个类，他们应该各司其职，在程序语言的世界中只做自己应该做的。</p> 
<p></p> 
<p><span style="color:#fe2c24;">二：开闭原则（OOP）</span>Open Closed Principle</p> 
<p><span style="color:#0d0016;">对拓展开发，对修改关闭。</span></p> 
<p>拓展开发：模块的行为可以被拓展从而满足新的需求。</p> 
<p>修改关闭：不允许修改模块的源代码（或尽量使修改最小化）。</p> 
<p><strong>如：</strong>继承就是最经典的开闭原则的体现，可以通过添加新的子类和重写父类的方法来实现。</p> 
<p></p> 
<p><span style="color:#fe2c24;">三：里氏替换原则（LSP）</span>Liskov Substitution Principle</p> 
<p><span style="color:#0d0016;">任何父类出现的地方，子类都可以代替</span>（用父类容器装载子类对象）</p> 
<p><img alt="" height="96" src="https://images2.imgbox.com/23/02/cZRQMYjV_o.png" width="333"></p> 
<p></p> 
<p><span style="color:#fe2c24;">四：依赖倒转原则（DIP）</span>Dependence Inversion Principle</p> 
<p><span style="color:#0d0016;">要依赖于抽象，不要依赖于具体的实现。</span></p> 
<p><strong>如</strong>：</p> 
<p><img alt="" height="424" src="https://images2.imgbox.com/a0/b5/I8KHS9na_o.png" width="795"></p> 
<p></p> 
<p>人要开枪，是依赖于枪械，但是我并没有直接去依赖这些枪械，利用里氏替换原则，倒转去依赖了这个开枪接口。</p> 
<p></p> 
<p><span style="color:#fe2c24;">五：迪米特原则（LoP）</span>Law of Demeter</p> 
<p><span style="color:#0d0016;">又称最少知识原则，一个对象应该对其他对象尽可能的少了解。</span></p> 
<p><strong>如</strong>：一个对象中的成员，要尽可能少的直接和其它类建立关系，目的是降低耦合性。</p> 
<p></p> 
<p></p> 
<p><span style="color:#fe2c24;">六：接口分离原则（LSP）</span> Interface Segregation Principle</p> 
<p>不应该强迫别人依赖他们不需要使用的方法。</p> 
<p><span style="color:#0d0016;">一个接口不需要提供太多的行为，应该尽量只提供一个对外的功能，让别人去选择需要实现什么样的行为，而不是把所有的行为都封装到一个接口中。</span></p> 
<p><strong>如</strong>：飞机接口、走路接口、跑步接口等等虽然他们都是移动的行为，但是我们应该把他们分为一个一个单独的接口，让别人去选择使用。</p> 
<p></p> 
<p></p> 
<p><span style="color:#fe2c24;">七：合成复用原则（CRP）</span>Composite Reuse Principle</p> 
<p><span style="color:#0d0016;">尽量使用对象组合，而不是继承来达到复用的目的，继承关系是强耦合，组合关系是低耦合。</span></p> 
<p><strong>如</strong>：脸应该是嘴巴、鼻子、眼睛、耳朵的组合，而不是依次继承。角色和装备也应该是组合，而不是继承。</p> 
<p>注意：不能盲目使用合成复用原则，要在遵循迪米特原则的前提下。</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p>okk本文到这里可能（我也不确定？）就结束了，后面还会有C#进阶的课程我再接着做笔记。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/055abadb9e1f206940ace1d6e3e55a9b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">研究生必备：从0到1使用Zotero</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/71e7baf676798b0fb5c1e1d768d40219/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vite&#43;vue3 打包后本地预览（不需要起服务）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>