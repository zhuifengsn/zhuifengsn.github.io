<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】入门基础 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【C&#43;&#43;】入门基础" />
<meta property="og:description" content="文章目录 1、命名空间1.1、命名空间的概念1.2、命名空间的定义1.3、命名空间的使用 2、初识cout和cin2.1、标准输入输出对象简介2.2、缓冲区2.3、cout2.4、cin 3、缺省参数3.1、全缺省参数3.2、半缺省参数3.3、注意事项 4、函数重载4.1、函数重载的概念4.2、函数重载的定义4.3、函数重载的原理 5、内联函数5.1、内联函数的概念5.2、内联函数的特性 6、引用6.1、引用的概念6.2、引用的定义6.3、引用的特性6.4、常引用6.5、使用场景6.6、值和引用的比较6.6.1、值和引用做参数类型的效率比较6.6.2、值和引用做返回值类型的性能比较 6.7、引用和指针的区别 1、命名空间 1.1、命名空间的概念 在C/C&#43;&#43;中，变量、函数和类都是大量存在的，而这些变量、函数和类的名称大多数都存在于全局作用域中，这就很容易导致出现相同的名称。而命名空间的目的是对标识符的名称进行本地化，以避免命名冲突或名字污染，namespace关键字就可以很好的解决这一问题。
如下问题：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int scanf = 10; int main() { printf(&#34;%d\n&#34;, scanf); return 0; }// 编译后后报错：error C2365: “scanf”: 重定义；以前的定义是“函数 C语言没办法解决类似这样的命名冲突问题，所以C&#43;&#43;就提出了用namespace来解决。
1.2、命名空间的定义 定义命名空间，需要使用到namespace关键字，后面在写上命名空间的名字，然后接一对{ }即可，{ }中即为命名空间的成员。
说明：
（1）命名空间里面可以定义变量，函数，类。模板，和其他命名空间，即可以出现在全局作用域中的声明就可以置在命名空间中！
（2）命名空间分割了全局作用域，每个命名空间都是不同的作用域，我们可以在命名空间里面定义我们需要的变量，函数，类，模板或其他命名空间。
如下：
namespace ikun { int a = 10;//定义变量 int add(int a,int b)//定义函数 { return a&#43;b; } class cxk//定义类 { public: int test() { return 5; } private: int n; char ch; }; } 上面的 “ikun” 是命名空间的名字，命名空间里面我们定义了变量a、函数add，类cxk。当我们定义完命名空间后，就产生了一个新的作用域，即该作用域的名称为ikun，该作用域里有变量a、函数add、类cxk。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/41870fdb886ef7972abc1e237b83b7a3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-29T20:08:01+08:00" />
<meta property="article:modified_time" content="2023-08-29T20:08:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】入门基础</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1_1" rel="nofollow">1、命名空间</a></li><li><ul><li><a href="#11_2" rel="nofollow">1.1、命名空间的概念</a></li><li><a href="#12_18" rel="nofollow">1.2、命名空间的定义</a></li><li><a href="#13_54" rel="nofollow">1.3、命名空间的使用</a></li></ul> 
  </li><li><a href="#2coutcin_94" rel="nofollow">2、初识cout和cin</a></li><li><ul><li><a href="#21_96" rel="nofollow">2.1、标准输入输出对象简介</a></li><li><a href="#22_101" rel="nofollow">2.2、缓冲区</a></li><li><a href="#23cout_106" rel="nofollow">2.3、cout</a></li><li><a href="#24cin_135" rel="nofollow">2.4、cin</a></li></ul> 
  </li><li><a href="#3_163" rel="nofollow">3、缺省参数</a></li><li><ul><li><a href="#31_165" rel="nofollow">3.1、全缺省参数</a></li><li><a href="#32_182" rel="nofollow">3.2、半缺省参数</a></li><li><a href="#33_198" rel="nofollow">3.3、注意事项</a></li></ul> 
  </li><li><a href="#4_245" rel="nofollow">4、函数重载</a></li><li><ul><li><a href="#41_246" rel="nofollow">4.1、函数重载的概念</a></li><li><a href="#42_249" rel="nofollow">4.2、函数重载的定义</a></li><li><a href="#43_321" rel="nofollow">4.3、函数重载的原理</a></li></ul> 
  </li><li><a href="#5_349" rel="nofollow">5、内联函数</a></li><li><ul><li><a href="#51_350" rel="nofollow">5.1、内联函数的概念</a></li><li><a href="#52_396" rel="nofollow">5.2、内联函数的特性</a></li></ul> 
  </li><li><a href="#6_402" rel="nofollow">6、引用</a></li><li><ul><li><a href="#61_403" rel="nofollow">6.1、引用的概念</a></li><li><a href="#62_406" rel="nofollow">6.2、引用的定义</a></li><li><a href="#63_420" rel="nofollow">6.3、引用的特性</a></li><li><a href="#64_454" rel="nofollow">6.4、常引用</a></li><li><a href="#65_527" rel="nofollow">6.5、使用场景</a></li><li><a href="#66_570" rel="nofollow">6.6、值和引用的比较</a></li><li><ul><li><a href="#661_571" rel="nofollow">6.6.1、值和引用做参数类型的效率比较</a></li><li><a href="#662_613" rel="nofollow">6.6.2、值和引用做返回值类型的性能比较</a></li></ul> 
   </li><li><a href="#67_660" rel="nofollow">6.7、引用和指针的区别</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1_1"></a>1、命名空间</h2> 
<h3><a id="11_2"></a>1.1、命名空间的概念</h3> 
<p>在C/C++中，变量、函数和类都是大量存在的，而这些变量、函数和类的名称大多数都存在于全局作用域中，这就很容易导致出现相同的名称。而命名空间的目的是对标识符的名称进行本地化，以避免命名冲突或名字污染，namespace关键字就可以很好的解决这一问题。<br> 如下问题：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
	 <span class="token keyword">int</span> scanf <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	 <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> scanf<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token comment">// 编译后后报错：error C2365: “scanf”: 重定义；以前的定义是“函数</span>
</code></pre> 
<p>C语言没办法解决类似这样的命名冲突问题，所以C++就提出了用namespace来解决。</p> 
<h3><a id="12_18"></a>1.2、命名空间的定义</h3> 
<p>定义命名空间，需要使用到namespace关键字，后面在写上命名空间的名字，然后接一对{ }即可，{ }中即为命名空间的成员。</p> 
<blockquote> 
 <p>说明：<br> （1）命名空间里面可以定义变量，函数，类。模板，和其他命名空间，即可以出现在全局作用域中的声明就可以置在命名空间中！<br> （2）命名空间分割了全局作用域，每个命名空间都是不同的作用域，我们可以在命名空间里面定义我们需要的变量，函数，类，模板或其他命名空间。</p> 
</blockquote> 
<p>如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">namespace</span> ikun
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">//定义变量</span>
	
	
	<span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token comment">//定义函数</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	
	<span class="token keyword">class</span> <span class="token class-name">cxk</span><span class="token comment">//定义类</span>
	<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		<span class="token keyword">int</span> n<span class="token punctuation">;</span>
		<span class="token keyword">char</span> ch<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>上面的 “ikun” 是命名空间的名字，命名空间里面我们定义了变量a、函数add，类cxk。当我们定义完命名空间后，就产生了一个新的作用域，即该作用域的名称为ikun，该作用域里有变量a、函数add、类cxk。</p> 
<h3><a id="13_54"></a>1.3、命名空间的使用</h3> 
<p>使用命名空间里的成员有三种方式：<br> <em><strong>（1）语法：命名空间的名称 + 作用域限定符 + 成员。</strong></em> C++中的 : : 就是作用域限定符。如我们需要使用ikun命名空间里的成员时，我们就可以这样访问：</p> 
<pre><code class="prism language-cpp"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>ikun<span class="token double-colon punctuation">::</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用命名空间里的变量。--输出10</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>ikun<span class="token double-colon punctuation">::</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">39</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用命名空间里的函数。--输出43</span>
</code></pre> 
<p>而上面的ikun : : 我们也称为前缀，当我们不想写前缀时，我们就可以使用第二种方式。</p> 
<p><em><strong>（2）语法：using + 命名空间的名称 + 作用域限定符 + 成员。</strong></em> 使用using声明将命名空间中某个成员引入。引入之后在使用该成员时就不用在写前缀。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">using</span> ikun<span class="token double-colon punctuation">::</span>a<span class="token punctuation">;</span><span class="token comment">// 使用using声明将ikun命名空间里的a变量引入</span>
<span class="token keyword">using</span> ikun<span class="token double-colon punctuation">::</span>add<span class="token punctuation">;</span><span class="token comment">//使用using声明将ikun命名空间里的add函数引入</span>
</code></pre> 
<p>引入之后我们不加前缀就可以使用该命名空间里的成员，如下：</p> 
<pre><code class="prism language-cpp">	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">44</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><em><strong>（3）语法：using + namespace + 命名空间的名称。</strong></em> 使用using namespace 将命名空间名称引入，引入之后我们在使用命名空间里的成员时，全部都不用加前缀。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> ikun<span class="token punctuation">;</span><span class="token comment">//将命名空间ikun引入</span>
</code></pre> 
<p>引入命名空间ikun后，它的全部成员我们使用其时就可以不用加前缀了，如下：</p> 
<pre><code class="prism language-cpp"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">36</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p><em><strong>注意：</strong></em> 第三种方法虽然方便了很多，但是也充满风险。<br> （1）只使用一条语句就突然将命名空间中的所有成员变得可见了，如果程序中存在多个不同的库，而这些库都通过using指示使得全部成员变得可见，那么全局命名空间污染的问题将重现。<br> （2）引发的二义性错误只有在使用了冲突名字的地方才能被发现这种延后的检测意味着可能在特定的库引入很久之后才爆发冲突。直到程序使用到该库的新部分后，之前一直未被检测到的错误才被发现。<br> （3）相比于使用第三种方式，在程序中使用第二种方式对命名空间中的成员分别使用using声明效果会更好，因为第二种方式可以减少注入到命名空间中的名字数量。以及using声明引起的二义性问题在声明处就能发现，不用等到使用名字的地方，这显然对检测和修改错误大大的提高了效率！</p> 
</blockquote> 
<h2><a id="2coutcin_94"></a>2、初识cout和cin</h2> 
<p>C++并未定义任何输入输出语句，取而代之的是一个更全面的标准库（standard library）来提供IO机制。<strong>iostream</strong> 库包含了两个基础类型<strong>istream和ostream</strong>，分别表示输入流和输出流。一个流就是一个字符序列，即从IO读出或写入IO设备的过程。</p> 
<h3><a id="21_96"></a>2.1、标准输入输出对象简介</h3> 
<p>（1）处理输入时，我们使用一个名为 cin 的 istream类型的对象，该对象也称为标准输入流。<br> （2）处理输出时，我们使用一个名为 cout 的ostream类型的对象，该对象也称为标准输出流。<br> （3）cin和cout是全局的流对象，他们都包含在包含 <strong>&lt; iostream &gt;</strong> 头文件中。cout和cin都是C++标准库里的std命名空间，C++将标准库的定义实现都放到这个命名空间中。<br> （4）cout和cin自动识别数据的类型，无需像printf/scanf输入输出那样，需要手动控制格式。</p> 
<h3><a id="22_101"></a>2.2、缓冲区</h3> 
<p>缓冲区是内存空间的一部分,也就是说在内存空间中预留了一定大小的存储空间，这些存储空间用来缓冲输入或输出的数据，这部分预留的空间就叫做缓冲区,根据其对应的是输入设备还是输出设备，分为<strong>输入缓冲区和输出缓冲区。</strong><br> <img src="https://images2.imgbox.com/bb/8e/1ALq2DsI_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="23cout_106"></a>2.3、cout</h3> 
<p>当执行cout语句时，会先把插入的数据按顺序存放在<strong>输出缓冲区</strong>中，当输出缓冲区满或遇到cout语句中的endl(或’\n’，ends，flush)时，在将缓冲区中的数据一起输出，并清空缓冲区。输出流中的数据在系统默认的设备(一般为显示器)输出。</p> 
<p>cout语句的一般格式为：</p> 
<p>cout&lt;&lt;表达式1&lt;&lt;表达式2&lt;&lt;表达式3…&lt;&lt;表达式n;</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//输出变量a</span>
	cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>a<span class="token operator">+</span><span class="token number">7</span><span class="token operator">&lt;&lt;</span>a<span class="token operator">+</span><span class="token number">5</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//可以输出多个表达式</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>说明：<br> （1）<strong>&lt;&lt;是流插入运算符</strong>，它把右测的信息插入到左边的cout输出流中，即把数据写到标准输出流对象cout中。<br> （2）cout默认不换行。而endl是特殊的C++符号，表示结束当前行并将与设备关联的缓冲区中的内容刷新到设备中。<br> （3）cout输出字符串时可以使用转义字符。</p> 
</blockquote> 
<p>下图是cout将数据输出到显示器的过程：<br> <img src="https://images2.imgbox.com/32/70/g8tR0pLB_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="24cin_135"></a>2.4、cin</h3> 
<p>我们知道从设备(键盘)上输入数据时，数据会先在输入缓冲区存放着。而当使用cin时，我们从键盘输入数据时需要敲一下回车键才能够将数据送入到输入缓冲区中，其中回车键(\r)会被转换为\n换行符，该换行符\n也会被存储在cin的输入缓冲区中并且被当成一个字符来计算！例如我们在键盘上输入abc这些字符串，再敲回车键，那么此时输入缓冲区中的字节个数是4 ，而不是3。</p> 
<p>cin语句的一般格式为：</p> 
<p>cin&gt;&gt;变量1&gt;&gt;变量2&gt;&gt;变量3&gt;&gt;…&gt;&gt;变量n;</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> n<span class="token punctuation">;</span>
	<span class="token keyword">char</span> c<span class="token punctuation">;</span>
	cin<span class="token operator">&gt;&gt;</span>n<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>说明：<br> （1）<strong>&gt;&gt;是流提取运算符</strong>，即将输入流里的数据提取出来赋值给内存中的变量。<br> （2）cin输入时,系统会根据变量的类型从输入流中提取相应长度的字节。<br> （3）把空格字符和回车换行符作为字符输入给字符变量时，它们将被跳过。<br> （4）cin可以连续从键盘读取想要的数据，以空格、enter或换行作为分隔符。</p> 
</blockquote> 
<p>下图是cin如何将数据存放到内存的过程：<br> <img src="https://images2.imgbox.com/60/8c/152g75wZ_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="3_163"></a>3、缺省参数</h2> 
<p>缺省参数是声明或定义函数时为函数的参数指定一个缺省值。当在调用该函数时，如果没有指定实参，则采用该形参的缺省值，否则使用指定的实参。</p> 
<h3><a id="31_165"></a>3.1、全缺省参数</h3> 
<p>全缺省参数，就是给函数的全部参数都指定缺省值。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token comment">//指定缺省值</span>
 <span class="token punctuation">{<!-- --></span>
     cout <span class="token operator">&lt;&lt;</span><span class="token string">"a = "</span><span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//输出3</span>
     cout <span class="token operator">&lt;&lt;</span><span class="token string">"b = "</span><span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//输出9</span>
     cout <span class="token operator">&lt;&lt;</span><span class="token string">"c = "</span><span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//输出7</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
 	 <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//未传入实参</span>
 	 <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre> 
<p>在上面的例子中，我们在定义func函数时，给函数的参数指定了三个缺省值，而当我们在调用该函数时并没有给该函数指定实参，此时该函数的参数就采用我们刚刚所给的缺省值。</p> 
<h3><a id="32_182"></a>3.2、半缺省参数</h3> 
<p>半缺省参数其实也就是在函数的全部的参数中只指定一些参数的缺省值。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">6</span> <span class="token punctuation">,</span> <span class="token keyword">int</span> z <span class="token operator">=</span> <span class="token number">71</span><span class="token punctuation">)</span><span class="token comment">//指定两个缺省值</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x = "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"y = "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"z = "</span> <span class="token operator">&lt;&lt;</span> z <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">func2</span><span class="token punctuation">(</span><span class="token number">34</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="33_198"></a>3.3、注意事项</h3> 
<p><strong>因为实参传给形参的时候是从左边开始依次传入的，所以半缺省参数必须 “ 从右往左依次 ” 来指定，不能间隔着指定。</strong></p> 
<p>错误示例：<br> 例1：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token comment">//error，间隔着指定缺省值</span>
<span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>	
	<span class="token function">test1</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//error，</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>实参的8从左边的参数开始传入，但a有缺省值了，如果传给a，那b就没有参数。如果传给b，那就不符合我们刚刚所说的，从左边开始依次传入，所以这会引起歧义。</p> 
<p>例2：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">9.</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token comment">//error，并未从右往左依次指定缺省值</span>
<span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">test2</span><span class="token punctuation">(</span><span class="token number">45</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//error</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>该问题与与例1的问题一样，这里就不在赘述。</p> 
<p><em><strong>注意：<br> （1）缺省参数不能在函数声明和定义中同时出现。</strong></em></p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//声明在test.h文件中</span>

<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token comment">//定义在test.cpp文件中</span>
<span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>
</code></pre> 
<p>缺省参数同时在声明和定义中出现，编译器就会报错。</p> 
<p><img src="https://images2.imgbox.com/0a/2d/IKBFI75w_o.png" alt="在这里插入图片描述"></p> 
<p><em><strong>（2）缺省值必须是常量或者全局变量。</strong></em></p> 
<h2><a id="4_245"></a>4、函数重载</h2> 
<h3><a id="41_246"></a>4.1、函数重载的概念</h3> 
<p>函数重载是函数的一种特殊情况，C++允许在同一作用域中声明几个功能类似的<strong>同名函数</strong>，这些同名函数的形参列表(<strong>参数个数 或 类型 或 类型顺序</strong>)不同，常用来理实现功能类似数据类型不同的问题。</p> 
<h3><a id="42_249"></a>4.2、函数重载的定义</h3> 
<p>（1）参数个数不同</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"void test1(int a,int b)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"int test1(int a)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//根据参数个数不同</span>
	<span class="token function">test1</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用 void test1(int a,int b)函数</span>
	<span class="token function">test1</span><span class="token punctuation">(</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用 int test1(int a)函数</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>（2）参数类型不同</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">double</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"void test2(int a,double b)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">4.1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">float</span> f<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"int test2(int a, float f)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">6</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//根据参数类型不同</span>
	<span class="token function">test2</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">2.2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用 double test2(int a,double b)函数</span>
	<span class="token function">test2</span><span class="token punctuation">(</span><span class="token number">24</span><span class="token punctuation">,</span> <span class="token number">29.4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用 int test2(int a, float f)函数</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>（3）类型顺序不同</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"void test3(int a,double b)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token keyword">double</span> b，<span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"void test3(double b，int a)"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//根据参数类型不同</span>
	<span class="token function">test3</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">2.2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用 void test3(int a, double b)函数</span>
	<span class="token function">test3</span><span class="token punctuation">(</span><span class="token number">6.4</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用 void test3(double b，int a)函数</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="43_321"></a>4.3、函数重载的原理</h3> 
<p>要运行一个程序时，需要经过【翻译环境】和【运行环境】，我们主要讨论的是【编译环境】。【翻译环境】分为【编译(编译器)】+ 【链接(链接器)】这两个过程，【编译(编译器)】又分为（预处理、编译、汇编）三个过程。<br> <img src="https://images2.imgbox.com/04/75/3tNR1d52_o.png" alt="在这里插入图片描述"><br> 当一个或多个 .cpp源文件经过编译(编译器)后就会生成 一个或多个.obj目标文件。然后链接器将.obj目标文件进行链接，若.obj目标文件中使用到了库中的函数，那么链接器就会到库中去寻找对应的库函数，一起进行链接。最后生成 .exe可执行程序(在Linux下是a.out)。</p> 
<p><img src="https://images2.imgbox.com/22/bd/GCnd0IkJ_o.png" alt="在这里插入图片描述"><br> 上面这些都还好理解，那假如test1.cpp中使用到了test2.cpp中的Fun函数，这个Fun函数还进行了函数重载，那编译器又是如何去teste2.cpp中寻找这个重载函数的?<br> 函数重载的关键点是【链接】，这一阶段。当链接器进行链接的时候，看到test1.obj中调用到了Fun函数，但是没有Fun的地址，就会到test2.obj的符号表中去找Fun的地址，然后将两个.obj目标文件的符号表进行合并就生成了最后的.exe可执行文件。<img src="https://images2.imgbox.com/4b/c6/RTKWJebs_o.png" alt="在这里插入图片描述"><br> 下图是【翻译坏境】的具体过程：<br> <img src="https://images2.imgbox.com/ea/ba/7t5an2Do_o.png" alt="在这里插入图片描述"><br> 那链接时，面对Fun函数，链接接器会使用哪个名字去找呢？其实每个编译器都有自己的<br> 函数名修饰规则。由于Windows下vs的修饰规则过于复杂，而Linux下g++的修饰规则简单易懂，所以下面我们就使用Linux下的g++来演示这个修饰后的名字。</p> 
<p><strong>（1）采用C++编译器编译后：</strong><br> <img src="https://images2.imgbox.com/9a/29/6hI67x3G_o.png" alt="在这里插入图片描述"></p> 
<p><em><strong>结论：在Linux下，采用g++编译完成后，函数名字的修饰发生改变，编译器将函数参数类型信息添加到修改后的名字中。</strong></em></p> 
<p><strong>（2）采用C语言编译器编译后：</strong><br> <img src="https://images2.imgbox.com/eb/6a/33WvXZU4_o.png" alt="在这里插入图片描述"><br> <strong>结论：在Linux下，采用gcc编译完成后，函数名字的修饰没有发生改变（即还是原名）。</strong></p> 
<blockquote> 
 <p>说明：<br> （1） 通过上面我们可以看出gcc的函数修饰后名字不变。而g++的函数修饰后变成【_Z+函数长度+函数名+类型首字母】。<br> （2）到这里就理解了C语言为什么不支持重载，因为同名函数没办法区分。而C++是通过函数修饰规则来区分，只要参数不同，修饰出来的名字就不一样，就支持了重载。<br> （3）需要注意：如果两个函数的函数名和参数都是一样，而返回值不同是不构成重载的，因为调用时编译器修饰名字时，并没有将返回值的类型加入到修饰规则中，所以这是没法构成重载的。</p> 
</blockquote> 
<h2><a id="5_349"></a>5、内联函数</h2> 
<h3><a id="51_350"></a>5.1、内联函数的概念</h3> 
<p>以inline修饰的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数调用建立栈帧的开销，内联函数可以提升程序运行的效率。即函数的压栈开销会被省去，直接执行函数体的代码。如下面的例子：<br> 一般的函数：函数前面无任何修饰。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token comment">//无任何修饰</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>内联函数：在函数最前面加上 inline 关键字。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token comment">//inline修饰</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> a<span class="token operator">+</span>b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的例子中，当函数被 inline 所修饰后，此时该函数就是一个内联函数。并且该函数的内容十分简单。</p> 
<blockquote> 
 <p>注意： inline不建议声明和定义分离，在函数声明处添加 inline关键字虽然没有错，但这种做法是无效的，编译器会忽略函数声明处的 inline 关键字。所以建议在定义处添加 inline 。</p> 
</blockquote> 
<p><em><strong>当成为内联函数后在编译期间编译器会用 “函数体” 替换函数的调用</strong></em>。函数体就是{ }里面的内容。即使用内联后，调用函数时不会建立栈帧，而是在调用的地方直接展开。<br> 我们在vs（以2019为例）中通过调试反汇编来查看是否真的如此。因为代码在release模式会被优化，这里就以Debug模式来做对比。因为在Debug模式下，编译器默认不会对代码进行优化，所以需要对编译器进行设置，否则不会展开，下面给出vs2019的设置方式：<br> 第一步：<br> <img src="https://images2.imgbox.com/53/5c/B3gWLm8P_o.png" alt="在这里插入图片描述"><br> 第二步：<br> <img src="https://images2.imgbox.com/06/6e/966mJD7C_o.png" alt="在这里插入图片描述"><br> 第三步：<br> <img src="https://images2.imgbox.com/e6/b8/7S6mJAO7_o.png" alt="在这里插入图片描述"></p> 
<p>设置完成后我们在Debug下进入反汇编。<br> 当函数不是内联函数时：<br> <img src="https://images2.imgbox.com/2a/c5/oyfjwQjG_o.png" alt="在这里插入图片描述"><br> 当是内联函数时：<br> <img src="https://images2.imgbox.com/a5/d3/hxpDfgjr_o.png" alt="在这里插入图片描述"><br> 可以看出，当一个函数是内联函数时，在编译期间会省去调用函数的开销。即使用内联以后，调用函数时不会建立栈帧，而是在调用的地方直接展开。</p> 
<h3><a id="52_396"></a>5.2、内联函数的特性</h3> 
<blockquote> 
 <p>说明：<br> （1）inline是一种以空间换时间的做法，内联函数在编译阶段，会用函数体替换函数调用，缺陷就是可能会使目标文件变大，而优势则是少了调用开销，提高程序运行效率。<br> （2） inline只是向编译器发出一个请求，编译器可以选择忽略这个请求，不同编译器关于inline实现机制可能不同。一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器都不支持内联递归函数，而且一个70多行的函数也不大可能在调用点内联地展开。</p> 
</blockquote> 
<h2><a id="6_402"></a>6、引用</h2> 
<h3><a id="61_403"></a>6.1、引用的概念</h3> 
<p>引用不是定义一个新的对象，相反的，它只是给已存在的对象另起一个名字，即起别名。编译器不会为引用开辟内存空间，它和它引用的对象共用同一块内存空间。如：李明在家被叫明儿，在江湖上被叫小明，原名叫李明，而这些名字都是另起的名字，尽管名字不同，但他们都是同一个人。<strong>相当于所谓的，已存在的对象就是李明，起别名就是被叫明儿或小明，共用同一块内存空间就是同一个人。</strong> 所以当我们操作引用的时候其实就是在操作原来的对象。</p> 
<h3><a id="62_406"></a>6.2、引用的定义</h3> 
<p>语法：类型&amp; 别名 = 引用的对象</p> 
<pre><code class="prism language-cpp">
 <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">//一个整型变量，名字为a，该变量可理解为就是对象！</span>
 <span class="token keyword">int</span><span class="token operator">&amp;</span> k <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token comment">//定义一个引用</span>
</code></pre> 
<p>引用的对象是a，我们给a起了个别名叫k，我们今后对k的操作就是对a操作。我们需要注意：引用类型必须和引用的对象是同种类型的。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
<span class="token keyword">char</span><span class="token operator">&amp;</span> c <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token comment">//error，类型不一致</span>
</code></pre> 
<h3><a id="63_420"></a>6.3、引用的特性</h3> 
<p>（1） 引用在定义时必须初始化。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> m <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token comment">//OK，定义引用时初始化</span>

<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> n<span class="token punctuation">;</span><span class="token comment">//error，定义引用时未初始化</span>
</code></pre> 
<p>（2）一个变量可以有多个引用。</p> 
<pre><code class="prism language-cpp">	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token comment">//OK</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span> x <span class="token operator">=</span> a<span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span> y <span class="token operator">=</span> a<span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span> z <span class="token operator">=</span> a<span class="token punctuation">;</span>
	<span class="token comment">//相当于给a起了三个不同的别名</span>
</code></pre> 
<p>（3）引用一旦引用一个对象，就不能再引用其他对象。</p> 
<pre><code class="prism language-cpp">	<span class="token comment">//定义了两个变量</span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>

	<span class="token keyword">int</span><span class="token operator">&amp;</span> e <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token comment">// 这里e引用了一个对象a</span>
	e <span class="token operator">=</span> b<span class="token punctuation">;</span><span class="token comment">//这里并非e再引用b，这里只是把b赋值给e。</span>
</code></pre> 
<p>当我们打印e和a的时候就会发现都等于20，这是因为b赋值给了e，而对e的改变就是对a的改变。这一点需要注意。</p> 
<h3><a id="64_454"></a>6.4、常引用</h3> 
<p>const关键字修饰符。所谓“修饰符”，就是在进行编译的过程中，给编译器一些“要求”或“提示”，而被const修饰的对象，具有“只读”的特点。一旦我们试图去改变这些东西，编译器就应该给出错误提示。如下：</p> 
<p><strong>未被const修饰的对象：具有“可读可修改”权限。</strong></p> 
<pre><code class="prism language-cpp">	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token comment">//OK，可修改</span>
	a <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token comment">//OK，可修改</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token comment">//OK，可读</span>
</code></pre> 
<p><strong>被const修饰的对象：具有“只读”权限。</strong></p> 
<pre><code class="prism language-cpp">	<span class="token keyword">const</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token comment">//error，不具有可修改权限</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token comment">//OK，具有可读权限</span>
</code></pre> 
<p>当我们用const来修饰引用后，原理也是如上面的两个例子一样的。</p> 
<p><em><strong>例1：权限对等</strong></em></p> 
<pre><code class="prism language-cpp">	<span class="token comment">//两者具有同样的权限</span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span><span class="token comment">//a具有可读可修改权限</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span> reta <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token comment">//要引用的对象a具有可读可修改权限，</span>
				  <span class="token comment">//reta也具有可读可修改权限，所以可以引用成功</span>
	
	<span class="token comment">//两者具有同样的权限</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment">//b只具有只读权限</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> retb <span class="token operator">=</span> b<span class="token punctuation">;</span><span class="token comment">//要引用的对象b只具有只读权限，</span>
						<span class="token comment">//retb也只有只读权限所以可以引用成功</span>
						
	b <span class="token operator">=</span> <span class="token number">33</span><span class="token punctuation">;</span><span class="token comment">//error，不具有修改权限</span>
	retb <span class="token operator">=</span> <span class="token number">333</span><span class="token punctuation">;</span><span class="token comment">//error，不具有修改权限			</span>
</code></pre> 
<p>例子1中可得出结论：<strong>当引用和被引用的对象具有同等权限时，可以进行引用。</strong></p> 
<p><em><strong>例2：权限缩小</strong></em></p> 
<pre><code class="prism language-cpp">	<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//a具有可读可修改权限</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> ret <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token comment">//ret只具有可读权限，而a仍然具有可读可修改权限。</span>
					   <span class="token comment">//因为我们const修饰的是ret，并不影响a。</span>
				   
	ret <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token comment">//error，不具有可修改权限</span>
	a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token comment">//OK</span>
	
</code></pre> 
<p>例子2中可得出结论：<strong>当引用后的权限比被引用的对象权限小时，可以进行引用。</strong></p> 
<p><em><strong>例3：权限放大</strong></em></p> 
<pre><code class="prism language-cpp">	<span class="token keyword">const</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//只具有可读权限，不可修改</span>
	
	<span class="token keyword">int</span><span class="token operator">&amp;</span> ret <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token comment">//error，因为a只有只读权限，而这里的 ret 想引用a，</span>
				 <span class="token comment">//如果引用成功那么相当于是修改a了，所以像这样的权限放大是不允许的。</span>
</code></pre> 
<p>例子3中可得出结论：<strong>当引用后的权限比被引用的对象权限大时，不可以进行引用。</strong></p> 
<p><em><strong>例4：字面常量的引用</strong></em></p> 
<pre><code class="prism language-cpp">	<span class="token keyword">int</span><span class="token operator">&amp;</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">//error，10是字面常量，只有可读权限，</span>
				<span class="token comment">//当我们未加上const修饰并试图引用一个常量时就会报错，相当于例3中的权限放大。</span>
	
	<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token comment">//OK，20是字面常量，只有可读权限，</span>
					  <span class="token comment">//当我们加上const修饰后就可以进行引用，相当于例1中的权限对等。</span>
</code></pre> 
<blockquote> 
 <p>通过上面几个例子可以总结出一句话：<em><strong>引用的原则：对原对象的引用不能权限放大，只能对等或者缩小。</strong></em></p> 
</blockquote> 
<h3><a id="65_527"></a>6.5、使用场景</h3> 
<p><strong>（1）做函数参数</strong></p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token comment">//a和b分别是x和y的别名</span>
<span class="token punctuation">{<!-- --></span>
   <span class="token keyword">int</span> temp <span class="token operator">=</span> a<span class="token punctuation">;</span>
   a <span class="token operator">=</span> b<span class="token punctuation">;</span>
   b <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>
	<span class="token function">Swap</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在C语言中我们需要交换两个数时需要传指针，而这里通过用引用做参数，也可以实现两个数交换的效果，如此一来便无需在传指针。这样用引用做参数比指针方便、简洁、好理解多了。<br> <strong>（2）做返回值</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
    <span class="token keyword">return</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span><span class="token operator">&amp;</span> ret <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Add(6,1) is :"</span><span class="token operator">&lt;&lt;</span> ret <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>当我们打印时，结果是13。这是因为：</p> 
<blockquote> 
 <p>（1）第一次add函数运行结束后，该函数对应的栈空间就被回收了，即c变量没有使用权了，而在main函数中ret却引用着add函数的返回值，实际上是引用着一块已经被释放的空间。<br> （2）第二次add函数运行结束后，同样的函数的栈空间被回收，即c变量也没有使用权了，注意空间被回收不是空间不存在了，而是我们没有使用权了，而ret引用c的位置被改成了13，因此ret的值也就跟着改成了13。</p> 
</blockquote> 
<p>引用的是一块已被回收的空间，当该空间的内容被修改时我们的引用也跟着改变，这是极其危险的，所以我们需要注意：<strong>如果函数返回时，出了函数作用域，如果返回对象还在(还没还给系统)，则可以使用引用返回，如果已经还给系统了，则必须使用传值返回。</strong></p> 
<h3><a id="66_570"></a>6.6、值和引用的比较</h3> 
<h4><a id="661_571"></a>6.6.1、值和引用做参数类型的效率比较</h4> 
<p>（1）以值作为参数或者返回值类型，在传参和返回期间，函数不会直接传递实参或者将变量本身直接返回，而是传递实参或者返回变量的一份临时的拷贝，因此用值作为参数或者返回值类型，效<br> 率是非常低下的，尤其是当参数或者返回值类型非常大时，效率就更低。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span>
<span class="token keyword">struct</span> <span class="token class-name">s</span> 
<span class="token punctuation">{<!-- --></span> 
	<span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">100000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">Func1</span><span class="token punctuation">(</span>s a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">Func2</span><span class="token punctuation">(</span>s<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	s a<span class="token punctuation">;</span>
	<span class="token comment">// 以值作为函数参数</span>
	size_t begin1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token function">Func1</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>

	size_t end1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 以引用作为函数参数</span>

	size_t begin2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token function">Func2</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>

	size_t end2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 分别计算两个函数运行结束后的时间</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Func1(A)-time:"</span> <span class="token operator">&lt;&lt;</span> end1 <span class="token operator">-</span> begin1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Func2(A&amp;)-time:"</span> <span class="token operator">&lt;&lt;</span> end2 <span class="token operator">-</span> begin2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/c0/ae/k1irjJWd_o.png" alt="在这里插入图片描述"><br> 从结果可以看出，以引用做函数参数时函数结束的运行时间比以值做参数的效率高上很多。</p> 
<h4><a id="662_613"></a>6.6.2、值和引用做返回值类型的性能比较</h4> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostrean&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span>
<span class="token keyword">struct</span> <span class="token class-name">s</span> 
<span class="token punctuation">{<!-- --></span> 
<span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>
s a<span class="token punctuation">;</span>

s <span class="token function">F1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 值返回</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> a<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

s<span class="token operator">&amp;</span> <span class="token function">F2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 引用做返回</span>
<span class="token punctuation">{<!-- --></span> 
	<span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 以值作为函数的返回值类型</span>
	size_t begin1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token function">F1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	size_t end1 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 以引用作为函数的返回值类型</span>
	size_t begin2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
		<span class="token function">F2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	size_t end2 <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 计算两个函数运算完成之后的时间</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"F1 time:"</span> <span class="token operator">&lt;&lt;</span> end1 <span class="token operator">-</span> begin1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"F2 time:"</span> <span class="token operator">&lt;&lt;</span> end2 <span class="token operator">-</span> begin2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/d0/63/n5jOBFmv_o.png" alt="在这里插入图片描述"><br> 通过上述代码的比较，发现传值和引用在作为传参以及返回值类型上效率相差是很大的，所以我们应该尽可能的多使用引用来提高我们的运行效率，当然我们也别忘了注意引用使用场景的注意点。</p> 
<h3><a id="67_660"></a>6.7、引用和指针的区别</h3> 
<p>（1）在语法概念层面上引用其实就是个别名，没有开辟独立的空间，和其引用的对象共用同一块空间。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span><span class="token operator">&amp;</span> rn <span class="token operator">=</span> n<span class="token punctuation">;</span>
	cout<span class="token operator">&lt;&lt;</span><span class="token string">"&amp;n = "</span><span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>n<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	cout<span class="token operator">&lt;&lt;</span><span class="token string">"&amp;rn = "</span><span class="token operator">&lt;&lt;</span><span class="token operator">&amp;</span>rn<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/82/a6/fVKOTYNI_o.png" alt="在这里插入图片描述"><br> （2）在引用的底层实现实际是有空间的，因为引用是按照指针方式来实现的。<br> 我们来看引用和指针的汇编代码对比：<br> <img src="https://images2.imgbox.com/0b/40/kqzDAhZ2_o.png" alt="在这里插入图片描述"><br> <strong>（3）引用和指针的不同点:</strong></p> 
<p>1.没有NULL引用，但有NULL指针.<br> 2. 访问对象方式不同，指针需要解引用，引用编译器自己处理。<br> 3. 引用在定义时必须初始化，指针没有要求。<br> 4. 有多级指针，但是没有多级引用。<br> 5. 引用在初始化时引用一个对象后，就不能再引用其他对象，而指针可以在任何时候指向任何<br> 一个同类型对象。<br> 6. 引用概念上定义一个变量的别名，指针存储一个变量地址。<br> 7. 在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32<br> 位平台下占4个字节)。<br> 8. 用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小。<br> 9. 引用比指针使用起来相对更安全。</p> 
<blockquote> 
 <p>本篇关于C++入门基础文章到这里就结束了，文中有不足的地方欢迎各位补充！后续我还会更新更多关于C++的文章，你的三连，是我最大的动力，感谢！</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5d5b16334e5084e2c6048ee95fdc92cd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">nginx配置https</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/51bb10165b47cd32cbc7a0ad507eeeee/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c&#43;&#43;入门——变量</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>