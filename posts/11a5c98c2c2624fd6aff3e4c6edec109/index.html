<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C语言】操作符大全万字详解 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【C语言】操作符大全万字详解" />
<meta property="og:description" content="昨天已成为历史，明天是未知的，而今天是上天赐予我们的礼物，这就是为什么我们把它叫做现在！——《功夫熊猫》
目录
1、操作符的分类
2、算术操作符
2.1&#43;、-、*（加减除）
2.2 /、%（除取余）
3、移位操作符
3.1原码反码补码
3.2&lt;&lt;（左移操作符）
3.3&gt;&gt;（右移操作符）
4、位操作符
4.1&amp; （按位与）
4.2 |（按位或）
4.3 ^ （按位异或）
5、赋值操作符
6、单目操作符
6.1！（逻辑反操作）
6.2-（负值）、&#43;（正值）
6.3&amp;（取地址）
6.4sizeof（取字节操作符）
6.5~（二进制位取反）
6.6--、&#43;&#43;（前后置--、&#43;&#43;）
6.7*（间接访问操作符、解引用操作符）
6.8sizeof和数组
7、关系操作符
8、逻辑操作符
8.1&amp;&amp;、||（逻辑与逻辑或）
9、条件操作符
9.1？：三目操作符
10、逗号表达式
11、下标引用、函数调用和结构成员
11.1[]下标引用操作符
11.2()函数调用操作符
11.3.、-&gt;结构体访问操作符
12、表达式求值
12.1一些有问题的表达式
12.2操作符优先级表格
前言： 大家好我是拳击哥，今天我给大家展现是C语言中各种各样的操作符。操作符是说明特定操作的符号，它是构造C语言表达式的工具，下面我就来介绍它们的详细用法，并且目录12.2中有从高到低的操作符优先级表格供大家参考。
1、操作符的分类 操作符分为：
算术操作符移位操作符位操作符赋值操作符单目操作符关系操作符逻辑操作符条件操作符逗号表达式下标引用、函数调用和结构成员 2、算术操作符 算术操作符有：&#43;（加）、-（减）、*（乘）、/（除）、%（取余、取模）
2.1&#43;、-、*（加减除） &#43;、-、*（加减除）跟我们数学中的意思是一致的，我们来看一组代码:
#include&lt;stdio.h&gt; int main() { int a = 5; int b = 5; int c = 0; c = a &#43; b; printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/11a5c98c2c2624fd6aff3e4c6edec109/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-15T16:02:48+08:00" />
<meta property="article:modified_time" content="2022-11-15T16:02:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C语言】操作符大全万字详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" height="204" src="https://images2.imgbox.com/07/9c/ZuaZV8dM_o.png" width="300"></p> 
<p></p> 
<p style="text-align:center;"><span style="color:#494949;"><strong>昨天已成为历史，明天是未知的，而今天是上天赐予我们的礼物，这就是为什么我们把它叫做现在！——《功夫熊猫》</strong></span></p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%88%86%E7%B1%BB-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%88%86%E7%B1%BB" rel="nofollow">1、操作符的分类</a></p> 
<p id="2%E3%80%81%E7%AE%97%E6%9C%AF%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E7%AE%97%E6%9C%AF%E6%93%8D%E4%BD%9C%E7%AC%A6" rel="nofollow">2、算术操作符</a></p> 
<p id="2.1%2B%E3%80%81-%E3%80%81*%EF%BC%88%E5%8A%A0%E5%87%8F%E9%99%A4%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.1%2B%E3%80%81-%E3%80%81*%EF%BC%88%E5%8A%A0%E5%87%8F%E9%99%A4%EF%BC%89" rel="nofollow">2.1+、-、*（加减除）</a></p> 
<p id="2.2%C2%A0%2F%E3%80%81%25%EF%BC%88%E9%99%A4%E5%8F%96%E4%BD%99%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.2%C2%A0%2F%E3%80%81%25%EF%BC%88%E9%99%A4%E5%8F%96%E4%BD%99%EF%BC%89" rel="nofollow">2.2 /、%（除取余）</a></p> 
<p id="3%E3%80%81%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:0px;"><a href="#3%E3%80%81%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6" rel="nofollow">3、移位操作符</a></p> 
<p id="3.1%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81-toc" style="margin-left:40px;"><a href="#3.1%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81" rel="nofollow">3.1原码反码补码</a></p> 
<p id="3.2%E5%B7%A6%E7%A7%BB%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:40px;"><a href="#3.2%E5%B7%A6%E7%A7%BB%E6%93%8D%E4%BD%9C%E7%AC%A6" rel="nofollow">3.2&lt;&lt;（左移操作符）</a></p> 
<p id="3.3%E5%8F%B3%E7%A7%BB%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:40px;"><a href="#3.3%E5%8F%B3%E7%A7%BB%E6%93%8D%E4%BD%9C%E7%AC%A6" rel="nofollow">3.3&gt;&gt;（右移操作符）</a></p> 
<p id="4%E3%80%81%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:0px;"><a href="#4%E3%80%81%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6" rel="nofollow">4、位操作符</a></p> 
<p id="4.1%26%20%EF%BC%88%E6%8C%89%E4%BD%8D%E4%B8%8E%EF%BC%89-toc" style="margin-left:40px;"><a href="#4.1%26%20%EF%BC%88%E6%8C%89%E4%BD%8D%E4%B8%8E%EF%BC%89" rel="nofollow">4.1&amp; （按位与）</a></p> 
<p id="%C2%A04.2%C2%A0%7C%EF%BC%88%E6%8C%89%E4%BD%8D%E6%88%96%EF%BC%89-toc" style="margin-left:40px;"><a href="#%C2%A04.2%C2%A0%7C%EF%BC%88%E6%8C%89%E4%BD%8D%E6%88%96%EF%BC%89" rel="nofollow">4.2 |（按位或）</a></p> 
<p id="4.3%C2%A0%5E%20%EF%BC%88%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96%EF%BC%89-toc" style="margin-left:40px;"><a href="#4.3%C2%A0%5E%20%EF%BC%88%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96%EF%BC%89" rel="nofollow">4.3 ^ （按位异或）</a></p> 
<p id="5%E3%80%81%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:0px;"><a href="#5%E3%80%81%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6" rel="nofollow">5、赋值操作符</a></p> 
<p id="6%E3%80%81%E5%8D%95%E7%9B%AE%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:0px;"><a href="#6%E3%80%81%E5%8D%95%E7%9B%AE%E6%93%8D%E4%BD%9C%E7%AC%A6" rel="nofollow">6、单目操作符</a></p> 
<p id="6.1%EF%BC%81%EF%BC%88%E9%80%BB%E8%BE%91%E5%8F%8D%E6%93%8D%E4%BD%9C%EF%BC%89-toc" style="margin-left:40px;"><a href="#6.1%EF%BC%81%EF%BC%88%E9%80%BB%E8%BE%91%E5%8F%8D%E6%93%8D%E4%BD%9C%EF%BC%89" rel="nofollow">6.1！（逻辑反操作）</a></p> 
<p id="6.2-%EF%BC%88%E8%B4%9F%E5%80%BC%EF%BC%89%E3%80%81%2B%EF%BC%88%E6%AD%A3%E5%80%BC%EF%BC%89-toc" style="margin-left:40px;"><a href="#6.2-%EF%BC%88%E8%B4%9F%E5%80%BC%EF%BC%89%E3%80%81%2B%EF%BC%88%E6%AD%A3%E5%80%BC%EF%BC%89" rel="nofollow">6.2-（负值）、+（正值）</a></p> 
<p id="6.3%26%EF%BC%88%E5%8F%96%E5%9C%B0%E5%9D%80%EF%BC%89-toc" style="margin-left:40px;"><a href="#6.3%26%EF%BC%88%E5%8F%96%E5%9C%B0%E5%9D%80%EF%BC%89" rel="nofollow">6.3&amp;（取地址）</a></p> 
<p id="6.4sizeof%EF%BC%88%E5%8F%96%E5%AD%97%E8%8A%82%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%89-toc" style="margin-left:40px;"><a href="#6.4sizeof%EF%BC%88%E5%8F%96%E5%AD%97%E8%8A%82%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%89" rel="nofollow">6.4sizeof（取字节操作符）</a></p> 
<p id="6.5~%EF%BC%88%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D%E5%8F%96%E5%8F%8D%EF%BC%89-toc" style="margin-left:40px;"><a href="#6.5~%EF%BC%88%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D%E5%8F%96%E5%8F%8D%EF%BC%89" rel="nofollow">6.5~（二进制位取反）</a></p> 
<p id="6.6--%E3%80%81%2B%2B%EF%BC%88%E5%89%8D%E5%90%8E%E7%BD%AE--%E3%80%81%2B%2B%EF%BC%89-toc" style="margin-left:40px;"><a href="#6.6--%E3%80%81%2B%2B%EF%BC%88%E5%89%8D%E5%90%8E%E7%BD%AE--%E3%80%81%2B%2B%EF%BC%89" rel="nofollow">6.6--、++（前后置--、++）</a></p> 
<p id="6.7*%EF%BC%88%E9%97%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C%E7%AC%A6%E3%80%81%E8%A7%A3%E5%BC%95%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%89-toc" style="margin-left:40px;"><a href="#6.7*%EF%BC%88%E9%97%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C%E7%AC%A6%E3%80%81%E8%A7%A3%E5%BC%95%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%89" rel="nofollow">6.7*（间接访问操作符、解引用操作符）</a></p> 
<p id="6.8sizeof%E5%92%8C%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#6.8sizeof%E5%92%8C%E6%95%B0%E7%BB%84" rel="nofollow">6.8sizeof和数组</a></p> 
<p id="7%E3%80%81%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:0px;"><a href="#7%E3%80%81%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6" rel="nofollow">7、关系操作符</a></p> 
<p id="8%E3%80%81%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:0px;"><a href="#8%E3%80%81%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6" rel="nofollow">8、逻辑操作符</a></p> 
<p id="8.1%26%26%E3%80%81%7C%7C-toc" style="margin-left:40px;"><a href="#8.1%26%26%E3%80%81%7C%7C" rel="nofollow">8.1&amp;&amp;、||（逻辑与逻辑或）</a></p> 
<p id="9%E3%80%81%E6%9D%A1%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:0px;"><a href="#9%E3%80%81%E6%9D%A1%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%AC%A6" rel="nofollow">9、条件操作符</a></p> 
<p id="9.1%EF%BC%9F%E3%80%81%EF%BC%9A-toc" style="margin-left:40px;"><a href="#9.1%EF%BC%9F%E3%80%81%EF%BC%9A" rel="nofollow">9.1？：三目操作符</a></p> 
<p id="10%E3%80%81%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:0px;"><a href="#10%E3%80%81%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow">10、逗号表达式</a></p> 
<p id="11%E3%80%81%E4%B8%8B%E6%A0%87%E5%BC%95%E7%94%A8%E3%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%92%8C%E7%BB%93%E6%9E%84%E6%88%90%E5%91%98-toc" style="margin-left:0px;"><a href="#11%E3%80%81%E4%B8%8B%E6%A0%87%E5%BC%95%E7%94%A8%E3%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%92%8C%E7%BB%93%E6%9E%84%E6%88%90%E5%91%98" rel="nofollow">11、下标引用、函数调用和结构成员</a></p> 
<p id="11.1%5B%5D%E4%B8%8B%E6%A0%87%E5%BC%95%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:40px;"><a href="#11.1%5B%5D%E4%B8%8B%E6%A0%87%E5%BC%95%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6" rel="nofollow">11.1[]下标引用操作符</a></p> 
<p id="11.2()%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:40px;"><a href="#11.2%28%29%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6" rel="nofollow">11.2()函数调用操作符</a></p> 
<p id="11.3.%E3%80%81-%3E%E7%BB%93%E6%9E%84%E4%BD%93%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:40px;"><a href="#11.3.%E3%80%81-%3E%E7%BB%93%E6%9E%84%E4%BD%93%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C%E7%AC%A6" rel="nofollow">11.3.、-&gt;结构体访问操作符</a></p> 
<p id="12%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC-toc" style="margin-left:0px;"><a href="#12%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC" rel="nofollow">12、表达式求值</a></p> 
<p id="12.1%E4%B8%80%E4%BA%9B%E6%9C%89%E9%97%AE%E9%A2%98%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:40px;"><a href="#12.1%E4%B8%80%E4%BA%9B%E6%9C%89%E9%97%AE%E9%A2%98%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow">12.1一些有问题的表达式</a></p> 
<p id="12.2%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E8%A1%A8%E6%A0%BC-toc" style="margin-left:40px;"><a href="#12.2%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E8%A1%A8%E6%A0%BC" rel="nofollow">12.2操作符优先级表格</a></p> 
<hr id="hr-toc"> 
<h2><strong><span style="color:#ad720d;">前言：</span></strong></h2> 
<blockquote> 
 <p><strong>大家好我是拳击哥，今天我给大家展现是C语言中各种各样的操作符。操作符是说明特定操作的符号，它是构造C语言表达式的工具，下面我就来介绍它们的详细用法，并且目录12.2中有从高到低的操作符优先级表格供大家参考。</strong></p> 
</blockquote> 
<hr> 
<h2 id="1%E3%80%81%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%88%86%E7%B1%BB"><span style="color:#0d0016;"><strong>1、操作符的分类</strong></span></h2> 
<p><span style="color:#494949;"><strong>操作符分为：</strong></span></p> 
<ul><li>算术操作符</li><li>移位操作符</li><li>位操作符</li><li>赋值操作符</li><li>单目操作符</li><li>关系操作符</li><li>逻辑操作符</li><li>条件操作符</li><li>逗号表达式</li><li>下标引用、函数调用和结构成员</li></ul> 
<hr> 
<h2 id="2%E3%80%81%E7%AE%97%E6%9C%AF%E6%93%8D%E4%BD%9C%E7%AC%A6"><span style="color:#0d0016;"><strong>2、算术操作符</strong></span></h2> 
<p><strong>算术操作符有：</strong>+（加）、-（减）、*（乘）、/（除）、%（取余、取模）</p> 
<h3 id="2.1%2B%E3%80%81-%E3%80%81*%EF%BC%88%E5%8A%A0%E5%87%8F%E9%99%A4%EF%BC%89"><span style="color:#0d0016;"><strong>2.1+、-、*（加减除）</strong></span></h3> 
<p><strong>+、-、*（加减除</strong>）跟我们数学中的意思是一致的，我们来看一组代码:</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int a = 5;
	int b = 5;
	int c = 0;
	c = a + b;
	printf("%d\n", c);
	c = a - b;
	printf("%d\n", c);
	c = a * b;
	printf("%d\n", c);
	return 0;
}</code></pre> 
<blockquote> 
 <p><strong>输出结果：</strong></p> 
 <p>10</p> 
 <p>0</p> 
 <p>25</p> 
</blockquote> 
<hr> 
<h3 id="2.2%C2%A0%2F%E3%80%81%25%EF%BC%88%E9%99%A4%E5%8F%96%E4%BD%99%EF%BC%89"><span style="color:#0d0016;"><strong>2.2 /、%（除取余）</strong></span></h3> 
<p><strong> /、%（除、取余）</strong>跟我们数学中的除法和取余有较大差别，我们先来看一组程序：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int a = 10;
	int b = 3;
	printf("%d\n", a/b);//除法
	printf("%d\n", a%b);//取余
    printf("%f\n", a / 2.0);//除法可以有小数，%不允许有小数
	return 0;
}</code></pre> 
<blockquote> 
 <p><strong>输出结果：</strong></p> 
 <p>3</p> 
 <p>1</p> 
 <p>5.000000</p> 
</blockquote> 
<hr> 
<p>可以看到C语言中的除法返回值是<strong><span style="color:#fe2c24;">除数</span></strong>，取余返回的是<span style="color:#fe2c24;"><strong>余数</strong></span>。并不像数学那般得到小数。并且C语言中只有除法/两边能有小数，取余%则不能。5.0000000因为浮点数编译器默认打印六位0，您可以在f前面加.n代表你要保留几位小数。如：%.3f保留三位小数。</p> 
<blockquote> 
 <ul><li>除了 % 操作符之外，其他的几个操作符<strong>（+、-、*、/）</strong>可以作用于整数和浮点数。</li><li>对于 / 操作符如果两个操作数都为整数，执行整数除法。而只要有浮点数执行的就是浮点数除法。</li><li>% 操作符的两个操作数必须为整数。返回的是整除之后的余数。</li></ul> 
</blockquote> 
<hr> 
<h2 id="3%E3%80%81%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6"><span style="color:#0d0016;"><strong>3、移位操作符</strong></span></h2> 
<p><span style="color:#494949;"><strong>&lt;&lt;（左移）、&gt;&gt;（右移）</strong></span></p> 
<h3 id="3.1%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81"><span style="color:#0d0016;"><strong>3.1原码反码补码</strong></span></h3> 
<p>在计算机中数据是按二进制存储的，二进制有三种形式分为原码、反码、补码。数字是用原码表示的，但在内存中的存储是以补码的形式存储的。</p> 
<pre><code class="language-cpp">int main()
{
	int a = 10;
	int b = -10;
	return 0;
}</code></pre> 
<p>以上定义了整形a和b两个变量，整数分为正数负数。正数负数补码的形式也是不同的。正数的原码、反码、补码都是一样的，且符号位为0。负数的反码是原码的符号位不变其余位按位与，补码则是反码加1。因为是32位操作系统，a和b是整形，整形占4个字节，所以有32个bit位。</p> 
<p><strong>首先我们看a的原码、反码、补码：</strong></p> 
<blockquote> 
 <p>10的原码：00000000 00000000 00000000 00001010</p> 
 <p>10的反码：00000000 00000000 00000000 00001010</p> 
 <p>10的补码：00000000 00000000 00000000 00001010</p> 
</blockquote> 
<p>我们可以看到<span style="color:#fe2c24;"><strong>正数</strong></span>的原码、反码、补码都是一样的，且符号位为0。符号位就是第一位数</p> 
<p class="img-center"><img alt="" height="66" src="https://images2.imgbox.com/df/1c/Bn5WSErm_o.png" width="300"></p> 
<hr> 
<p> <strong>我们再来看b的原码、反码、补码：</strong></p> 
<blockquote> 
 <p>-10的原码：10000000 00000000 00000000 00001010</p> 
 <p>-10的反码：111111111 111111111 111111111 111110101</p> 
 <p>-10的补码：111111111 111111111 111111111 111110110</p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>负数</strong></span>的原码、反码、补码。负数的原码符号位是1，反码是原码的符号位不变其余位按位与，补码则是反码+1。</p> 
<p class="img-center"><img alt="" height="91" src="https://images2.imgbox.com/db/d3/G4TCBapQ_o.png" width="300"></p> 
<p>符号位不变就是这一串二进制的第一位1不变，其余位按位与的意思是其余的所有位的1变为0，0变为1。</p> 
<hr> 
<h3 id="3.2%E5%B7%A6%E7%A7%BB%E6%93%8D%E4%BD%9C%E7%AC%A6"><span style="color:#0d0016;"><strong>3.2&lt;&lt;（左移操作符）</strong></span></h3> 
<p><span style="color:#494949;">有了原码、反码、补码的理解后，我们来了解左移操作符（&lt;&lt;）。移位规则：<strong>左边抛弃、右边补0</strong>。</span></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int a = 10;
	int b = -10;
	int c = a &lt;&lt; 1;
	int d = b &lt;&lt; 1;
	printf("%d ", c);
	printf("%d\n", d);
	return 0;
}</code></pre> 
<blockquote> 
 <p><strong> 输出结果</strong>：20 -20</p> 
</blockquote> 
<p>左移操作符具体怎么移呢，左移时。这个数的补码往左移动一位，移动后的补码最左边的那一位丢弃最右边空着的位补0。我们来看一个图理解：</p> 
<p><img alt="" height="297" src="https://images2.imgbox.com/38/cc/AJCqihYV_o.png" width="1200"></p> 
<p>从侧面说明了左移一位也就代表着这个数乘以2，这个数可以是正数或负数。 </p> 
<hr> 
<h3 id="3.3%E5%8F%B3%E7%A7%BB%E6%93%8D%E4%BD%9C%E7%AC%A6"><span style="color:#0d0016;"><strong>3.3&gt;&gt;（右移操作符）</strong></span></h3> 
<p><span style="color:#494949;"><strong>（&gt;&gt;）右移操作符与左移操作符有些许不同分为两种；</strong></span></p> 
<ul><li><span style="color:#0d0016;">算术移位，左边用原该值的符号位填充，右边丢弃。</span></li><li><span style="color:#0d0016;">逻辑移位，左边用0填充，右边丢弃。</span></li></ul> 
<hr> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int a = 10;
	int b = -10;
	int c = a &gt;&gt; 1;
	int d = b &gt;&gt; 1;
	printf("%d ", a);
	printf("%d ", b);
	printf("%d ", c);
	printf("%d\n", d);
	return 0;
}</code></pre> 
<blockquote> 
 <p><strong>输出结果</strong>：10 -10 5 -5 </p> 
</blockquote> 
<hr> 
<p>右移分为算术移位和逻辑移位，我们首先来看算术移位，算术右移就是整个补码往右边移动一位，移动完后，最左边的空着的位数补符号位，最右边的多出的一位丢弃。我们来看一个图理解：</p> 
<p><img alt="" height="259" src="https://images2.imgbox.com/41/be/pgRS1u9U_o.png" width="1200"></p> 
<p>从侧面说明了，这个数右移一位就是这个数除以2。以上程序就是算术右移。 </p> 
<hr> 
<p>我们再来看逻辑移位，逻辑右移就是整个补码往右边移动一位，移动完后，最左边的空位补0，最右边多的一位丢弃。我们也来看一个图理解：</p> 
<p><img alt="" height="303" src="https://images2.imgbox.com/1f/cd/ET4ReMLw_o.png" width="1200"></p> 
<hr> 
<p>注意：一个数值在内存中存放的是补码，但是补码的二进制转换成的十进制数并不是我们实际的数值。当我们知道一个数值的补码时，正数的原反补码都是一样的我们直接化成十进制就好了。而负数的补码我们可以通过原码变成补码这个过程逆序求出原码。也就是补码-1然后符号位不变其余位取反得到的就是原码。</p> 
<p><span style="color:#fe2c24;">警告</span><span style="color:#be191c;">⚠</span> ：对于移位运算符，不要移动负数位。</p> 
<hr> 
<h2 id="4%E3%80%81%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6"><span style="color:#0d0016;"><strong>4、位操作符</strong></span></h2> 
<p>位操作符有：<strong>&amp; （按位与）、| （按位或）、^ （按位异或）</strong>。他们的操作数必须是<span style="color:#fe2c24;">整数</span>，我们来看一组代码：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int a = 10;
	int b = -10;
	printf("%d ", a &amp; b);
	printf("%d ", a | b);
	printf("%d\n", a ^ b);
}</code></pre> 
<blockquote> 
 <p><strong>输出</strong>： 2 -2 -4</p> 
</blockquote> 
<hr> 
<p> 位操作符也是按照补码来进行运算的，首先我们得到a的补码</p> 
<blockquote> 
 <p><strong>原码、反码、补码</strong>：00000000 00000000 00000000 00001010</p> 
</blockquote> 
<p>我们再来求b的补码</p> 
<blockquote> 
 <p><strong>原码</strong>：10000000 00000000 00000000 00001010</p> 
 <p><strong>反码</strong>：11111111 11111111 11111111 11110101</p> 
 <p><strong>补码</strong>：11111111 11111111 11111111 11110110</p> 
</blockquote> 
<p>知道了a和b的补码，我们来讲解&amp; （按位与）、| （按位或）、^ （按位异或）。</p> 
<hr> 
<h3 id="4.1%26%20%EF%BC%88%E6%8C%89%E4%BD%8D%E4%B8%8E%EF%BC%89"><span style="color:#0d0016;"><strong>4.1&amp; （按位与）</strong></span></h3> 
<p><strong>&amp; （按位与</strong>）就是两个数的补码相与时只要有一个数为0则整个表达式的结果为0，我们来看一个图理解：</p> 
<p><img alt="" class="left" height="151" src="https://images2.imgbox.com/e5/26/ORMqpEhI_o.png" width="600"></p> 
<hr> 
<h3 id="%C2%A04.2%C2%A0%7C%EF%BC%88%E6%8C%89%E4%BD%8D%E6%88%96%EF%BC%89"><span style="color:#0d0016;"><strong>4.2 |（按位或）</strong></span></h3> 
<p><strong> |（按位或）</strong>就是两数补码相或时只要有一个数为1，则整个表达式结果为1，我们也来看一个图理解：</p> 
<p><img alt="" class="left" height="154" src="https://images2.imgbox.com/d4/6c/h7xs5WmU_o.png" width="600"></p> 
<hr> 
<h3 id="4.3%C2%A0%5E%20%EF%BC%88%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96%EF%BC%89"><span style="color:#0d0016;"><strong>4.3 ^ （按位异或）</strong></span></h3> 
<p><strong>^ （按位异或）</strong>就是两数补码异或时，两数不同时为1相同时为0，我们来看图理解：</p> 
<p><img alt="" class="left" height="262" src="https://images2.imgbox.com/be/ce/5aN3SEEa_o.png" width="600"></p> 
<hr> 
<p><strong><span style="color:#be191c;">🤼‍♀️ 练习：不创建临时变量，实现两个数的交换。</span></strong></p> 
<pre><code class="language-cpp">//方法1
#include&lt;stdio.h&gt;

int main()
{
	int a = 5;
	int b = 2;
	a = a + b;
	b = a - b;
	a = a - b;
	printf("a=%d b=%d\n", a, b);
	return 0;
}
//方法2
#include&lt;stdio.h&gt;

int main()
{
	int a = 5;
	int b = 2;
	a = a ^ b;
	b = a ^ b;
	a = a ^ b;
	printf("a=%d b=%d\n", a, b);
	return 0;
}</code></pre> 
<blockquote> 
 <p><strong>输出的都是</strong>：a=2 b=5 </p> 
</blockquote> 
<p>方法2中用到了异或，异或在二进制是相同为0不相同为1，那么此题中是什么样呢：</p> 
<p>第一步，a=a^b；把a，b化为二进制，a：101，b：010。异或后111，此时a=7</p> 
<p>第二步，b=a^b；把此时的a，b化为二进制，a：111，b：010。异或后101，此时b=5</p> 
<p>第三步，a=a^b；把此时的a，b化为二进制，a：111，b：101。异或后010，此时a=2</p> 
<hr> 
<h2 id="5%E3%80%81%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6"><span style="color:#0d0016;"><strong>5、赋值操作符</strong></span></h2> 
<p><strong>=（赋值操作符）</strong>是一个很友好的操作符，当你初始化一个数后，你想更改这个变量。这时候赋值操作符就排上用场了，我们来看一组代码：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int a = 520;
	a = 1314;
    printf("%d\n",a);
	return 0;
}</code></pre> 
<blockquote> 
 <p> <strong>输出</strong>：1314</p> 
</blockquote> 
<hr> 
<p>符合赋值操作符：<strong>+=、-=、*=、/=、%=、&gt;&gt;=、&lt;&lt;=、&amp;=、|=、^=</strong>。可见符合赋值操作符有多种多样，我们拿+=、-=、*=、/=、%=来举例，先看一组代码：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int a = 10;
	int b = 3;
	a += b;
	printf("%d ", a);
	a -= b;
	printf("%d ", a);
	a *= b;
	printf("%d ", a);
	a /= b;
	printf("%d ", a);
	a %= b;
	printf("%d\n", a);
	return 0;
}</code></pre> 
<blockquote> 
 <p><strong> 输出结果</strong>：13 10 30 10 1</p> 
</blockquote> 
<p>a += b<span style="color:#fe2c24;">&lt;=&gt;</span>a = a+b，a -= b<span style="color:#fe2c24;">&lt;=&gt;</span>a = a-b，a *= b<span style="color:#fe2c24;">&lt;=&gt;</span>a = a*b，a /= b<span style="color:#fe2c24;">&lt;=&gt;</span>a = a/b，a %= b<span style="color:#fe2c24;">&lt;=&gt;</span>a = a%b。 （&lt;=&gt;是相等的意思）</p> 
<hr> 
<h2 id="6%E3%80%81%E5%8D%95%E7%9B%AE%E6%93%8D%E4%BD%9C%E7%AC%A6"><span style="color:#0d0016;"><strong>6、单目操作符</strong></span></h2> 
<p>单目操作符有：<strong>！（逻辑反操作）、-（负值）、+（正值）、&amp;（取地址）、sizeof（取字节数）、~（二进制位取反）、--（前置、后置--）、++（前后置++）、*（解引用操作符）、强制类型转换</strong>，下面我就来一一介绍。</p> 
<h3 id="6.1%EF%BC%81%EF%BC%88%E9%80%BB%E8%BE%91%E5%8F%8D%E6%93%8D%E4%BD%9C%EF%BC%89"><span style="color:#0d0016;"><strong>6.1！（逻辑反操作）</strong></span></h3> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int a = 0;
	if (!a)
	{
		printf("happy\n");
	}
	return 0;
}</code></pre> 
<blockquote> 
 <p> <strong>输出结果</strong>：happy</p> 
</blockquote> 
<p>C语言中0表示假（false）非0表示真（true），所以上述程序a=0，!a就是非0。所以在任意一个表达前面加!号就是把这个表达式取反的意思。</p> 
<hr> 
<h3 id="6.2-%EF%BC%88%E8%B4%9F%E5%80%BC%EF%BC%89%E3%80%81%2B%EF%BC%88%E6%AD%A3%E5%80%BC%EF%BC%89"><span style="color:#0d0016;"><strong>6.2-（负值）、+（正值）</strong></span></h3> 
<p><span style="color:#494949;"><strong>-（负值）、+（加值）</strong>很容易理解，我们来看一组程序：</span></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int a = 10;
	int b = -10;
	printf("%d ", +a);
	printf("%d ", +b);
	printf("%d ", -a);
	printf("%d\n",-b);
	return 0;
}</code></pre> 
<blockquote> 
 <p><strong> 输出结果</strong>：10 -10 -10 10</p> 
</blockquote> 
<p>我们可以看到+（正值）对各个数字没有影响。-（负值）就是把各个数字取反了。</p> 
<hr> 
<h3 id="6.3%26%EF%BC%88%E5%8F%96%E5%9C%B0%E5%9D%80%EF%BC%89"><span style="color:#0d0016;"><strong>6.3&amp;（取地址）</strong></span></h3> 
<p><span style="color:#494949;"><strong>&amp;（取地址</strong>）见名知意，就是取出这个变量在内存中的地址，如定义一个整形变量，我想知道这个变量的地址这时候就可以用到&amp;操作符。</span></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int a = 10;
	printf("%p\n", &amp;a);
	return 0;
}</code></pre> 
<blockquote> 
 <p><strong>输出结果</strong>：001BF724</p> 
</blockquote> 
<p><span style="color:#0d0016;">注意</span>，定义一个变量，这个变量会在内存中随机找一个地址存储。因此每次输出的地址值都不是一样的。当然我们也可以取一个数组的地址，有以下程序：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int arry[3] = { 1,2,5 };
	printf("%p\n", &amp;arry);
	printf("%p\n", &amp;arry[0]);
	return 0;
}</code></pre> 
<blockquote> 
 <p><strong>输出结果</strong>：</p> 
 <p>001FF8E8<br> 001FF8E8</p> 
</blockquote> 
<p>可见取数组名的地址就是取整个数组的地址，也可以认为取数组名的地址就是取该数组第一个元素的地址。</p> 
<hr> 
<h3 id="6.4sizeof%EF%BC%88%E5%8F%96%E5%AD%97%E8%8A%82%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%89"><span style="color:#0d0016;"><strong>6.4sizeof（取字节操作符）</strong></span></h3> 
<p>当我们想要知道数据的类型占多少字节时可以用sizeof来求，当我们想知道数组的长度的时候也可以用sizeof来求。</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int arry[] = { 1,2,3,4,5,6,7,8,9,10 };
	printf("%d  ",sizeof(int));
	printf("%d\n",sizeof(arry)/sizeof(arry[0]));
	return 0;
}</code></pre> 
<blockquote> 
 <p><strong>输出结果</strong>：4  10 </p> 
</blockquote> 
<p>整形int在内存中占4个字节可以用sizeof求得，数组大小可以由sizeof数组名/sizeof数组第一个元素如：sizeof(arry)/sizeof(arry[0])。</p> 
<p>练习，以下程序的结果是什么：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int a = 10;
	short s = 3;
	printf("%d ", sizeof(s = a + 3));
	printf("%d\n", s);
	return 0;
}</code></pre> 
<blockquote> 
 <p><strong>输出</strong>：2 3 </p> 
</blockquote> 
<p>sizeof里面的表达式的最终结果返回给了s，而sizeof求的就是s的数据类型大小。也就是short的占字节数 。并且最终的s还是不变的，s只是在sizeof的()里面改变，实质上的s还是原来的s。</p> 
<hr> 
<h3 id="6.5~%EF%BC%88%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D%E5%8F%96%E5%8F%8D%EF%BC%89"><span style="color:#0d0016;"><strong>6.5~（二进制位取反）</strong></span></h3> 
<p>来看一组代码：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int a = 3;
	printf("%d", ~a);
	return 0;
}</code></pre> 
<blockquote> 
 <p><strong>输出结果</strong>：-4 </p> 
</blockquote> 
<p>我们知道原、反、补码的运算后，很容易求出3的补码是00000000 00000000 00000000 00000011</p> 
<p>对3的补码取反得到11111111 11111111 11111111 11111100，可以看出这是一个负数因为符号位为<span style="color:#fe2c24;">1</span>。</p> 
<p>把这一串二进制化为原码为：10000000 00000000 00000000 00000100，所以最后结果为-4。</p> 
<p>所以~波浪号是把一个数值的补码全部取反。因此一个正数或负数可能因为这个操作改变原来的值。</p> 
<hr> 
<h3 id="6.6--%E3%80%81%2B%2B%EF%BC%88%E5%89%8D%E5%90%8E%E7%BD%AE--%E3%80%81%2B%2B%EF%BC%89"><span style="color:#0d0016;"><strong>6.6--、++（前后置--、++）</strong></span></h3> 
<p>我们经常用到的循环语句中常遇到这两种操作符，来看组代码：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int a = 10;
	int b = 0;
	b = ++a;
	printf("a=%d b=%d\n",a,b);
	b = a++;
	printf("a=%d b=%d\n", a, b);
	b = --a;
	printf("a=%d b=%d\n", a, b);
	b = a--;
	printf("a=%d b=%d\n", a, b);
	return 0;
}</code></pre> 
<blockquote> 
 <p><strong>输出结果：</strong></p> 
 <p>a=11 b=11<br> a=12 b=11<br> a=11 b=11<br> a=10 b=11</p> 
</blockquote> 
<p><strong>b=++a时</strong>，a先自加了然后再把自加后的值赋值给b，此时运算顺序为先a=11，b=11；</p> 
<p><strong>b=a++时</strong>，a先把自己赋值给b然后再自增，此时运算顺序为先b=11，a=12；</p> 
<p><strong>b=--a时</strong>，a先自减然后再把自减后的值赋值给b，此时运算顺序为a=11，b=11；</p> 
<p><strong>b=a--时</strong>，a先把自己赋值给b然后再自增，此时运算顺序为b=11，a=10；</p> 
<p>也就是当--或++在前面时，先进行自减或自增并且把自减或自增的值赋值给前者变量。当--或++在后面时，先不自减或自增把自身赋值给前者后，再进行自减或自增。以上就是位置导致的赋值优先级。</p> 
<hr> 
<h3 id="6.7*%EF%BC%88%E9%97%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C%E7%AC%A6%E3%80%81%E8%A7%A3%E5%BC%95%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%89"><span style="color:#0d0016;"><strong>6.7*（间接访问操作符、解引用操作符）</strong></span></h3> 
<p>这里的<strong>*号</strong>并不是乘号而是，间接访问的一个符号。通常在指针中我们用到这个符号，我们来看一组代码：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int arry[3] = { 1,2,3 };
	int* p1 = arry;
	int* p2 = &amp;arry[2];
	printf("%d ", *p1);
	printf("%d ", *p2);
	int a = 10;
	int* p3 = &amp;a;
	*p3 = 20;
	printf("%d\n", a);
	return 0;
}</code></pre> 
<blockquote> 
 <p><strong>输出结果</strong>：1 3 20 </p> 
</blockquote> 
<p>int* p1=arry，实际上p1指向的是arry数组的首地址，再对p1解引用也就是*p1得到的值就是p1指向的arry数组首地址的值</p> 
<p>int* p2=arry[2]，实际上p2指向的是arry数组的第三个地址因为数组下标从0开始的，再对p2解引用也就是*p2得到值就是p2指向的arry数组第三个元素的值 </p> 
<p>int* p3=&amp;a，就是p3指向a的地址，再把20赋值给解引用后的p3也就是*p3。因此原来a的地址里面的值被指针p3改变了。</p> 
<p>以上就是*（解引用）的基本操作</p> 
<hr> 
<h3 id="6.8sizeof%E5%92%8C%E6%95%B0%E7%BB%84"><span style="color:#0d0016;"><strong>6.8sizeof和数组</strong></span></h3> 
<p>我们来看一组代码：</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
void test1(int arr[])
{
	printf("%d ", sizeof(arr));//(3)
}
void test2(char ch[])
{
	printf("%d\n", sizeof(ch));//(4)
}
int main()
{
	int arr[10] = { 0 };
	char ch[10] = { 0 };
	printf("%d ", sizeof(arr));//(1)
	printf("%d ", sizeof(ch));//(2)
	test1(arr);
	test2(ch);
	return 0;
}</code></pre> 
<blockquote> 
 <p><strong> 输出结果</strong>：40 10 4 4 </p> 
</blockquote> 
<p>我们很容易看到（1）、（2）输出的是两个数组的总字节数。（1）中10个int类型就是40个字节，（2）中10个char类型就是10个字节。那为啥（3）、（4）输出的各是4呢，原因是数组在传参的时候传给形参的是数组的首地址 。并且数组在传参的时候可以是数组名也可以是指针，但有一点无论你传过去的是数组名亦或者是指针，形参都认为这是一个<strong><span style="color:#fe2c24;">指针类型</span></strong>。指针类型占<span style="color:#fe2c24;"><strong>4个字节</strong></span>，无论是指针的char类型或者int类型甚至是double类型我们都按照4个字节来算，因此（3）、（4）输出4。</p> 
<hr> 
<h2 id="7%E3%80%81%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6"><span style="color:#0d0016;"><strong>7、关系操作符</strong></span></h2> 
<p>关系操作符有这些：<strong>&gt;（大于）、&gt;=（大于等于）、&lt;（小于）、&lt;=（小于等于）、!=（不等于）  、==  （等于）</strong>，相信大家都已经见过这些操作符了，我们来看一组代码：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int a = 5;
	int b = 9;
	if (a &gt; b)
		printf("a大于b\n");
	if (a &lt; b)
		printf("a小于b\n");
	return 0;
}</code></pre> 
<blockquote> 
 <p><strong>输出结果</strong>：a小于b </p> 
</blockquote> 
<p>关系操作符常用在if判断语句中，它与数学表达的意思一样，只是写法不同。关系操作符判断的关系成立时返回是真，否则返回假。这与布尔类型（true和false）保持一致。注意，<strong>C语言中的等于是==而不是=，C语言中的=号是赋值的意思，==是等于的意思。</strong></p> 
<hr> 
<h2 id="8%E3%80%81%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6"><span style="color:#0d0016;"><strong>8、逻辑操作符</strong></span></h2> 
<h3 id="8.1%26%26%E3%80%81%7C%7C"><span style="color:#0d0016;"><strong>8.1&amp;&amp;、||（逻辑与逻辑或）</strong></span></h3> 
<p>逻辑操作符有：<strong>&amp;&amp;、||</strong>。&amp;&amp;表示的是并且的意思，||表示的是或者的意思。我们就拿求闰年来做讲解：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int year = 2400;
	if (((year % 4 == 0) &amp;&amp; (year % 100 != 0)) || (year % 400 == 0))
	{
		printf("这是一个闰年\n");
	}
	return 0;
}</code></pre> 
<blockquote> 
 <p><strong>输出结果</strong>：这是一个闰年 </p> 
</blockquote> 
<p>闰年的满足条件是能被4整数但不能被100整除或者能被400整除，这样的类型就可以用到逻辑操作符，并且&amp;&amp;和或者||。注意，&amp;&amp;是两边表达式都成立时才为真，||是两边表达式只要有一方成立时就为真。</p> 
<hr> 
<p>一道笔试题，程序的输出结果是什么：</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
int main()
{
  int i = 0,a=0,b=2,c =3,d=4;
  i = a++ &amp;&amp; ++b &amp;&amp; d++;
  printf("a = %d\n b = %d\n c = %d\nd = %d\n", a, b, c, d);
  i = a++||++b||d++;
  printf("a = %d\n b = %d\n c = %d\nd = %d\n", a, b, c, d);
  return 0;
}</code></pre> 
<blockquote> 
 <p><strong>输出结果</strong>：</p> 
 <p>a=1 b=2 c=3 d=4<br> a=2 b=2 c=3 d=4 </p> 
</blockquote> 
<p>i=a++ &amp;&amp; ++b &amp;&amp; d++; 先拿a&amp;&amp;++b，此时（a&amp;&amp;++b）表达式已经为0因此++b不用执行，（a++&amp;&amp;++b）也为0，因此d++也不执行了。所以最后只有a自增了一次，其余的bcd都保持不变。</p> 
<p>i=a++||++b||d++;先拿a与++b做||或运算，因为a非0因此a++为1因此（a++||++b）整个表达式为1，所以++b也不用运算，随之后面的d++也不用运算。</p> 
<p>以上的题目就体现出了，&amp;&amp;是两边表达式都成立时才为真，||是两边表达式只要有一方成立时就为真。从侧面可以这样理解，&amp;&amp;两边表达式只要有一边为假整个表达式返回假另一个表达式不用判断了，||两边表达式只要有一边为真整个表达式返回真另一个表达式也不用判断了。</p> 
<hr> 
<h2 id="9%E3%80%81%E6%9D%A1%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%AC%A6"><span style="color:#0d0016;"><strong>9、条件操作符</strong></span></h2> 
<h3 id="9.1%EF%BC%9F%E3%80%81%EF%BC%9A"><span style="color:#0d0016;"><strong>9.1？：三目操作符</strong></span></h3> 
<p>条件操作符：<strong>exp1 ? exp2 : exp3</strong>。三个表达式组成的操作，因此我们称为的三目运算符。</p> 
<p class="img-center"><img alt="" height="153" src="https://images2.imgbox.com/76/19/a0jrYMOA_o.png" width="400"></p> 
<p>我们来看一个程序，求两数之间的较大值：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int a = 5;
	int b = 3;
	int max = 0;
	max = a &gt; b ? a : b;
	printf("%d ", max);
	max = a &lt; b ? b : a;
	printf("%d\n", max);
	return 0;
}</code></pre> 
<blockquote> 
 <p><strong>输出结果</strong>：5 5 </p> 
</blockquote> 
<p>可见?号操作符是做一个判断作用的跟if语句一样返回的是真或假。：号操作符是做一个选择作用，当？号返回的是真就执行：号前面的表达式，否则就执行：号后的表达式。以上程序我们也可以写成这个样子：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int a = 5;
	int b = 3;
	int max = 0;
	if (a &gt; b)
	{
		max = a;
	}
	else
	{
		max = b;
	}
	return 0;
}</code></pre> 
<hr> 
<h2 id="10%E3%80%81%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span style="color:#0d0016;"><strong>10、逗号表达式</strong></span></h2> 
<p>逗号表达式：<strong>ex1，ex2，ex3，.....exn</strong>。逗号表达式，就是用逗号隔开的多个表达式。它从左向右依次执行。整个表达式的结果是<span style="color:#fe2c24;">最后一个表达式</span>的结果。</p> 
<pre><code class="language-cpp">//代码1
int a = 1;
int b = 2;
int c = (a &gt; b, a = b + 10, a, b = a + 1);
//代码2
if (a = b + 1, c = a / 2, d &gt; 0)

</code></pre> 
<blockquote> 
 <p>代码1输出的结果是13，尽管c = (a &gt; b, a = b + 10, a, b = a + 1)的结果是最后一个表达式b=a+1的值，但在此之前的所有表达式都进行了运算。</p> 
 <p>代码2，if语句里面判断是最后一个逗号后面的表达式d&gt;0。在此之前的表达式没有起到任何作用。</p> 
</blockquote> 
<hr> 
<h2 id="11%E3%80%81%E4%B8%8B%E6%A0%87%E5%BC%95%E7%94%A8%E3%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%92%8C%E7%BB%93%E6%9E%84%E6%88%90%E5%91%98"><span style="color:#0d0016;"><strong>11、下标引用、函数调用和结构成员</strong></span></h2> 
<h3 id="11.1%5B%5D%E4%B8%8B%E6%A0%87%E5%BC%95%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6"><span style="color:#0d0016;"><strong>11.1[]下标引用操作符</strong></span></h3> 
<p><span style="color:#494949;"><strong>[]下标引用操作符</strong>就是我们数组中的[]，那么[]的两边是有操作数的。分别是数组名和一个索引值，索引值是一个常量。我们来看一组代码：</span></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int arry[3] = { 1,2,3 };
    arry[2];
	return 0;
}</code></pre> 
<blockquote> 
 <p>首先定义了一个整形数组arry有三个元素。那么arry[3]中的arry和3就是[]下标引用操作符前后的两个<strong>操作数</strong>。arry[2]也是如此，arry和2是[]的两个<strong>操作数</strong>。通过这一个操作可以找到该数组下标为几的地址里面存在的元素。 </p> 
</blockquote> 
<p>最常见的应该就是定义一个数组，然后打印这个数组，我们用for循环来遍历这个数组，有以下程序：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int arry[] = { 1,2,3,4,5,6,7,8,9 };
	int n = sizeof(arry) / sizeof(arry[0]);
	for (int i = 0; i &lt;n; i++)
	{
		printf("%d ", arry[i]);
	}
	return 0;
}</code></pre> 
<blockquote> 
 <p><strong>输出结果</strong>：1 2 3 4 5 6 7 8 9 </p> 
</blockquote> 
<p>我们遍历是从0到n-1结束，正好对应了数组的下标。这就是[]下标访问符的作用。 </p> 
<hr> 
<h3 id="11.2()%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6"><span style="color:#0d0016;"><strong>11.2()函数调用操作符</strong></span></h3> 
<p><span style="color:#494949;">函数调用操作符就是()，当我们创建一个函数的时候通过()来运算，我们来看一组代码：</span></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

#include&lt;string.h&gt;

int main()
{
	int len = strlen("abcdef");
	printf("%d\n", len);
	return 0;
}</code></pre> 
<blockquote> 
 <p><strong>输出结果</strong>：6 </p> 
</blockquote> 
<p>函数调用操作符()的操作数是什么呢，拿上述程序来说。()左边的strlen是一个操作数，右边的"abcdef"也是操作数，只不过我们称"abcdef"为参数。当()的操作数只有一个的时候，代表这个函数没有任何的参数如strlen();也就是()里面没有参数；</p> 
<hr> 
<h3 id="11.3.%E3%80%81-%3E%E7%BB%93%E6%9E%84%E4%BD%93%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C%E7%AC%A6"><span style="color:#0d0016;"><strong>11.3.、-&gt;结构体访问操作符</strong></span></h3> 
<p>结构体访问操作符有两个一个是.(点号)，-&gt;(箭头)，点号是用来访问成员，-&gt;也是用来访问成员的。</p> 
<ul><li>.为结构体.成员名</li><li>-&gt;为结构体指针-&gt;成员名</li></ul> 
<p>我们来看一组程序：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

struct student
{
	char name[20];
	int age;
	char sex[5];
	int score;
};
int main()
{
	struct student stu1= { "张三",33,"男",66};
	printf("%s %d %s %d\n", stu1.name, stu1.age, stu1.sex, stu1.score);
	struct student* p = &amp;stu1;
	printf("%s %d %s %d\n", (*p).name, (*p).age, (*p).sex, (*p).score);
	printf("%s %d %s %d\n", p-&gt;name, p-&gt;age, p-&gt;sex, p-&gt;score);
	return 0;
}</code></pre> 
<blockquote> 
 <p><strong>输出结果</strong>：</p> 
 <p>张三 33 男 66 </p> 
 <p>张三 33 男 66 </p> 
 <p>张三 33 男 66 </p> 
</blockquote> 
<p>上述程序中，自定义了一个结构体变量student里面成员变量有四个，和结构体student变量stu1。那么我们可以通过stu1来.号成员变量 ，或者把stu1的地址给一个结构体student指针变量p。p来.号成员变量也可以得到该成员变量，前提是对p进行解引用。</p> 
<p>我们也可以用p-&gt;箭头来访问成员变量，既然p指向了stu1的地址。那么p指向stu1里面的成员的地址也可以得到该成员的值。</p> 
<hr> 
<h2 id="12%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span style="color:#0d0016;"><strong>12、表达式求值</strong></span></h2> 
<p><span style="color:#494949;">表达式的求值的顺序一部分是按照操作符的<strong>优先级</strong>和结合性决定的，同样，有些表达式的操作数在求值的过程中可能需要转换为其他类型我们称为<strong>强制转换</strong>。我们来看一组程序：</span></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int a = 3;
	int b = 4;
	int c = a + a * b + b;
	int d = (int)3.14;
	printf("%d ", c);
	printf("%d\n", d);
	return 0;
}
</code></pre> 
<blockquote> 
 <p><strong>输出结果</strong>：19 3</p> 
</blockquote> 
<p>以上代码中<strong>c=a+a*b+b；</strong>中*号表达式优先级大于+号，所以是先a*b得到12然后再进行+号运算最终得到19。</p> 
<p><strong>int d=(int)3.14;</strong>中我希望d是一个整形的值，但是我赋值给d的是一个浮点型3.14。那么这时候我们就可以用强制类型转换把3.14强转为整形，如下图所示： </p> 
<p><img alt="" height="243" src="https://images2.imgbox.com/b8/e9/fCAuAmCw_o.png" width="1200"></p> 
<hr> 
<p>上述代码中<strong>c=a+a*b+b；</strong>是先乘后加，那么我们想要先加后乘怎么做呢。我们可以把两个加法用()号括起来，()号的优先级是大于*号的，我们来看代码：</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;

int main()
{
	int a = 3;
	int b = 4;
	int c = (a + a) * (b + b);
	printf("%d\n", c);
	return 0;
}
</code></pre> 
<blockquote> 
 <p> <strong>输出结果</strong>：48</p> 
</blockquote> 
<p>因此，我们想要表达式的顺序改变，可以将某一块代码用优先级高的操作符引起来，比如说()号。它是所有表达式中优先级最高的。</p> 
<hr> 
<h3 id="12.1%E4%B8%80%E4%BA%9B%E6%9C%89%E9%97%AE%E9%A2%98%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span style="color:#0d0016;"><strong>12.1一些有问题的表达式</strong></span></h3> 
<pre><code class="language-cpp">//代码1
a* b + c * d + e * f;
//代码2
c++ --c;
//代码3
int main()
{
   int i = 10;
   i = i-- - --i*(i=-3)*i++ + ++i;
   printf("i=%d\n",i);
   return 0;
}</code></pre> 
<blockquote> 
 <p>代码1在计算的时候，由于*比+的优先级高，只能保证，*的计算是比+早，但是优先级并不<br> 能决定第三个*比第一个+早执行。</p> 
 <p>所以计算机认为的顺序可能是：a*b,c*d,a*b+c*d,e*f,a*b+c*d+e*f或者:a*b,c*d,e*f,a*b+c*d,a*b+c*d+e*f</p> 
 <hr> 
 <p>代码2同上，操作符的优先级只能决定自减--的运算在+的运算的前面，但是我们并没有办法得知，+操作符的左操作数的获取在右操作数之前还是之后求值，所以结果是不可预测的，是有歧义的。</p> 
 <hr> 
 <p>代码3在不同的编译器中测试的结果是不同的，如下表所示：</p> 
 <table align="left" border="1" cellpadding="1" cellspacing="1" style="width:500px;"><thead><tr><th style="text-align:center;">值</th><th style="text-align:center;">编译器</th></tr></thead><tbody><tr><td style="text-align:center;">-128</td><td style="text-align:center;">Tandy 6000 Xenix 3.2</td></tr><tr><td style="text-align:center;">-95</td><td style="text-align:center;">Tink C 5.02(Macintosh)</td></tr><tr><td style="text-align:center;">-86</td><td style="text-align:center;">IBM PowerPC AIX 3.2.5</td></tr><tr><td style="text-align:center;">-85</td><td style="text-align:center;">Sun Sparc cc(K&amp;C编译器)</td></tr><tr><td style="text-align:center;">-63</td><td style="text-align:center;">gcc,HP_UX9.0,Power C 2.0.0</td></tr></tbody></table> 
 <p></p> 
</blockquote> 
<h3 id="12.2%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E8%A1%A8%E6%A0%BC"><span style="color:#0d0016;"><strong>12.2操作符优先级表格</strong></span></h3> 
<p><span style="color:#494949;">下表中从上到下优先级是</span><span style="color:#fe2c24;"><strong>由高到低的</strong></span><span style="color:#494949;">，结合性中的<strong>N/A是没有结合性，L-R是从左往右，R-L是从右往左</strong>。是否控制求值顺序意思什么呢，比如&amp;&amp;只要两边表达式有一个为假。整个表达式为假，那么&amp;&amp;它就是控制求值顺序的。</span></p> 
<table border="1" cellpadding="1" cellspacing="1"><thead><tr><th style="text-align:center;">操作符</th><th style="text-align:center;">描述       </th><th style="text-align:center;">用法示例</th><th style="text-align:center;">结果类型</th><th style="text-align:center;width:78px;">结合性</th><th style="text-align:center;width:181px;">是否控制求值顺序</th></tr></thead><tbody><tr><td style="text-align:center;">()</td><td style="text-align:center;">聚组</td><td style="text-align:center;">（表达式）</td><td style="text-align:center;">与表达式相同</td><td style="text-align:center;width:78px;">N/A</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">()</td><td style="text-align:center;">函数调用</td><td style="text-align:center;">rexp(rexp,...,rexp)</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">L-R</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">[]</td><td style="text-align:center;">下标引用</td><td style="text-align:center;">rexp[rexp]</td><td style="text-align:center;">lexp</td><td style="text-align:center;width:78px;">L-R</td><td style="text-align:center;width:181px;">否</td></tr><tr><td> <p style="text-align:center;">.</p> </td><td style="text-align:center;">访问结构成员</td><td style="text-align:center;">lexp.member_name</td><td style="text-align:center;">lexp</td><td style="text-align:center;width:78px;">L-R</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">-&gt;</td><td style="text-align:center;">访问结构体成员</td><td style="text-align:center;">rexp-&gt;member_name</td><td style="text-align:center;">lexp</td><td style="text-align:center;width:78px;">L-R</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">++</td><td style="text-align:center;">后缀自增</td><td style="text-align:center;">lexp++</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">L-R</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">--</td><td style="text-align:center;">后缀自减</td><td style="text-align:center;">lexp--</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">L-R</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">！</td><td style="text-align:center;">逻辑反</td><td style="text-align:center;">!rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">R-L</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">~</td><td style="text-align:center;">按位取反</td><td style="text-align:center;">~rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">R-L</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">+</td><td style="text-align:center;">单目，正值</td><td style="text-align:center;">+rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">R-L</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">-</td><td style="text-align:center;">单目，负值</td><td style="text-align:center;">-rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">R-L</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">++</td><td style="text-align:center;">前缀自增</td><td style="text-align:center;">++lexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">R-L</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">--</td><td style="text-align:center;">前缀自减</td><td style="text-align:center;">--lexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">R-L</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">*</td><td style="text-align:center;">间接访问</td><td style="text-align:center;">*rexp</td><td style="text-align:center;">lexp</td><td style="text-align:center;width:78px;">R-L</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">&amp;</td><td style="text-align:center;">取地址</td><td style="text-align:center;">&amp;rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">R-L</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">sizeof</td><td style="text-align:center;">取字节数</td><td style="text-align:center;">sizeof（类型或rexp）</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">R-L</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">(强转)</td><td style="text-align:center;">类型转换</td><td style="text-align:center;">（类型）rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">R-L</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">*</td><td style="text-align:center;">乘法</td><td style="text-align:center;">rexp*rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">L-R</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">/</td><td style="text-align:center;">除法</td><td style="text-align:center;">rexp/rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">L-R</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">%</td><td style="text-align:center;">整数取余</td><td style="text-align:center;">rexp%rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">L-R</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">+</td><td style="text-align:center;">加法</td><td style="text-align:center;">rexp+rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">L-R</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">-</td><td style="text-align:center;">减法</td><td style="text-align:center;">rexp-rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">L-R</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">&lt;&lt;</td><td style="text-align:center;">左移</td><td style="text-align:center;">rexp&lt;&lt;rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">L-R</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">&gt;&gt;</td><td style="text-align:center;">右移</td><td style="text-align:center;">rexp&gt;&gt;rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">L-R</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">&gt;</td><td style="text-align:center;">大于</td><td style="text-align:center;">rexp&gt;rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">L-R</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">&gt;=</td><td style="text-align:center;">大于等于</td><td style="text-align:center;">rexp&gt;=rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">L-R</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">&lt;</td><td style="text-align:center;">小于</td><td style="text-align:center;">rexp&lt;rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">L-R</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">&lt;=</td><td style="text-align:center;">小于等于</td><td style="text-align:center;">rexp&lt;=rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">L-R</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">==</td><td style="text-align:center;">等于</td><td style="text-align:center;">rexp==rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">L-R</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">!=</td><td style="text-align:center;">不等于</td><td style="text-align:center;">rexp!=rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">L-R</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">&amp;</td><td style="text-align:center;">按位与</td><td style="text-align:center;">rexp&amp;rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">L-R</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">|</td><td style="text-align:center;">按位或</td><td style="text-align:center;">rexp|rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">L-R</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">^</td><td style="text-align:center;">按位异或</td><td style="text-align:center;">rexp^rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">L-R</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">&amp;&amp;</td><td style="text-align:center;">逻辑与</td><td style="text-align:center;">rexp&amp;&amp;rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">L-R</td><td style="text-align:center;width:181px;">是</td></tr><tr><td style="text-align:center;">||</td><td style="text-align:center;">逻辑或</td><td style="text-align:center;">rexp||rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">L-R</td><td style="text-align:center;width:181px;">是</td></tr><tr><td style="text-align:center;">?:</td><td style="text-align:center;">条件操作符</td><td style="text-align:center;">rexp?rexp:rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">N/A</td><td style="text-align:center;width:181px;">是</td></tr><tr><td style="text-align:center;">=</td><td style="text-align:center;">赋值</td><td style="text-align:center;">rexp=rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">R-L</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">+=</td><td style="text-align:center;">以..加</td><td style="text-align:center;">lexp+=rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">R-L</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">-=</td><td style="text-align:center;">以..减</td><td style="text-align:center;">lexp-=rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">R-L</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">*=</td><td style="text-align:center;">以..乘</td><td style="text-align:center;">lexp*=rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">R-L</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">/=</td><td style="text-align:center;">以..除</td><td style="text-align:center;">lexp/=rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">R-L</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">%=</td><td style="text-align:center;">以..取余</td><td style="text-align:center;">lexp%=rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">R-L</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">&lt;&lt;=</td><td style="text-align:center;">以..左移</td><td style="text-align:center;">lexp&lt;&lt;=rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">R-L</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">&gt;&gt;=</td><td style="text-align:center;">以..右移</td><td style="text-align:center;">lexp&gt;&gt;=rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">R-L</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">&amp;=</td><td style="text-align:center;">以..与</td><td style="text-align:center;">lexp&amp;=rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">R-L</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">|=</td><td style="text-align:center;">以..或</td><td style="text-align:center;">lexp|=rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">R-L</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">^=</td><td style="text-align:center;">以..异或</td><td style="text-align:center;">lexp^=rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">R-L</td><td style="text-align:center;width:181px;">否</td></tr><tr><td style="text-align:center;">,</td><td style="text-align:center;">逗号</td><td style="text-align:center;">rexp,rexp，...，rexp</td><td style="text-align:center;">rexp</td><td style="text-align:center;width:78px;">L-R</td><td style="text-align:center;width:181px;">是</td></tr></tbody></table> 
<hr> 
<p style="text-align:center;"><span style="color:#0d0016;"><strong>本期博文到这里就结束，感谢各位的耐心观看</strong></span></p> 
<p class="img-center"><img alt="" height="232" src="https://images2.imgbox.com/1b/2d/caO0bUJH_o.jpg" width="250"></p> 
<p style="text-align:center;"><span style="color:#494949;"><strong> Never Give Up</strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/850f1fa31e7ec52c3b0cdeeae012249d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何使用Python读取超大文本文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9008745754b4d85d41edb58536c55009/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【测试用例设计】黑盒测试方法论-场景法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>