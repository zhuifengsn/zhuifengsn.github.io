<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>运行时类型信息（RTTI &#43; 反射） - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="运行时类型信息（RTTI &#43; 反射）" />
<meta property="og:description" content="运行时类型信息使得你可以在程序运行时发现和使用类型信息。
Java是如何让我们在运行时识别对象和类的信息的，主要有3种方式
“传统的”RTTI，它假定我们在编译时已经知道了所有的类型，比如Shape s = (Shape)s1；
“反射”机制，它运行我们在运行时发现和使用类的信息，即使用Class.forName()。
关键字instanceof，它返回一个bool值，它保持了类型的概念，它指的是“你是这个类吗？或者你是这个类的派生类吗？”。而如果用==或equals比较实际的Class对象，就没有考虑继承—它或者是这个确切的类型，或者不是。
RTTI：Run-Time Type Identification，即运行时类型识别，是指在运行时识别一个对象的类型，其对应的类是Class对象，每个java里面的类都对应一个Class对象(在编写并且编译后)，这个对象被保存在这个类的同名class文件里。
要理解RTTI在Java中的工作原理，首先必须知道类型信息在运行时是如何表示的，这项工作是由称为Class对象的特殊对象完成的，它包含了与类有关的信息。Java送Class对象来执行其RTTI，使用类加载器的子系统实现。
无论何时，只要你想在运行时使用类型信息，就必须首先获得对恰当的Class对象的引用，获取方式有三种：
a.如果你没有持有该类型的对象，则Class.forName()就是实现此功能的便捷途，因为它不需要对象信息。
b.如果你已经拥有了一个感兴趣的类型的对象，那就可以通过调用getClass()方法来获取Class引用了，它将返回表示该对象的实际类型的Class引用。
c.使用类字面常量。比如这样：String.class;来引用。
这样做不仅更简单，而且更安全，因为它在编译时就会受到检查（因此不需要置于try语句块中），并且它根除了对forName方法的引用，所以也更高效。类字面常量不仅可以应用于普通的类，也可以应用于接口、数组以及基本数据类型。
注意：
当使用“.class”来创建对Class对象的引用时，不会自动地初始化该Class对象，初始化被延迟到了对静态方法（构造器隐式的是静态的）或者非final静态域（注意final静态域不会触发初始化操作）进行首次引用时才执行。
而使用Class.forName时会自动的初始化。
为了使用类而做的准备工作实际包含三个步骤：
- 加载：由类加载器执行。查找字节码，并从这些字节码中创建一个Class对象
- 链接：验证类中的字节码，为静态域分配存储空间，并且如果必需的话，将解析这个类创建的对其他类的所有引用。
- 初始化：如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。
如果不知道某个对象的确切类型，RTTI可以告诉你，但是有一个限制：这个类型在编译时必须已知，这样才能使用RTTI识别它，也就是在编译时，编译器必须知道所有要通过RTTI来处理的类。如果要突破这个限制就需要使用反射机制。
反射的原理：
Class类与java.lang.reflect类库一起对反射的概念进行了支持，该类库包含了Field、Method以及Constructor类（每个类都实现了Member接口）。这些类型的对象是由JVM在运行时创建的，用以表示未知类里对应的成员。这样你就可以使用Constructor创建新的对象，用get()/set()方法读取和修改与Field对象关联的字段，用invoke()方法调用与Method对象关联的方法。另外，还可以调用getFields()、getMethods()和getConstructors()等很便利的方法，以返回表示字段、方法以及构造器的对象的数组。这样，匿名对象的类信息就能在运行时被完全确定下来，而在编译时不需要知道任何事情。
反射与RTTI的区别
当通过反射与一个未知类型的对象打交道时，JVM只是简单地检查这个对象，看它属于哪个特定的类（就像RTTI那样），在用它做其他事情之前必须先加载那个类的Class对象，因此，那个类的.class文件对于JVM来说必须是可获取的：要么在本地机器上，要么可以通过网络取得。所以RTTI与反射之间真正的区别只在于：对RTTI来说，编译器在编译时打开和检查.class文件（也就是可以用普通方法调用对象的所有方法）；而对于反射机制来说，.class文件在编译时是不可获取的，所以是在运行时打开和检查.class文件。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/b4b97e18a10c3c545d20e60ddc78dec6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-10-05T08:48:39+08:00" />
<meta property="article:modified_time" content="2018-10-05T08:48:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">运行时类型信息（RTTI &#43; 反射）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>运行时类型信息使得你可以在程序运行时发现和使用类型信息。</p> 
<p>Java是如何让我们在运行时识别对象和类的信息的，主要有3种方式</p> 
<p>“传统的”RTTI，它假定我们在编译时已经知道了所有的类型，比如Shape s = (Shape)s1；</p> 
<p>“反射”机制，它运行我们在运行时发现和使用类的信息，即使用Class.forName()。</p> 
<p>关键字instanceof，它返回一个bool值，它保持了类型的概念，它指的是“你是这个类吗？或者你是这个类的派生类吗？”。而如果用==或equals比较实际的Class对象，就没有考虑继承—它或者是这个确切的类型，或者不是。</p> 
<p>RTTI：Run-Time Type Identification，即运行时类型识别，是指在运行时识别一个对象的类型，其对应的类是Class对象，每个java里面的类都对应一个Class对象(在编写并且编译后)，这个对象被保存在这个类的同名class文件里。</p> 
<p>要理解RTTI在Java中的工作原理，首先必须知道类型信息在运行时是如何表示的，这项工作是由称为Class对象的特殊对象完成的，它包含了与类有关的信息。Java送Class对象来执行其RTTI，使用类加载器的子系统实现。</p> 
<p>无论何时，只要你想在运行时使用类型信息，就必须首先获得对恰当的Class对象的引用，获取方式有三种：</p> 
<p>a.如果你没有持有该类型的对象，则Class.forName()就是实现此功能的便捷途，因为它不需要对象信息。</p> 
<p>b.如果你已经拥有了一个感兴趣的类型的对象，那就可以通过调用getClass()方法来获取Class引用了，它将返回表示该对象的实际类型的Class引用。</p> 
<p>c.使用类字面常量。比如这样：String.class;来引用。</p> 
<p>这样做不仅更简单，而且更安全，因为它在编译时就会受到检查（因此不需要置于try语句块中），并且它根除了对forName方法的引用，所以也更高效。类字面常量不仅可以应用于普通的类，也可以应用于接口、数组以及基本数据类型。</p> 
<p>注意：</p> 
<p>当使用“.class”来创建对Class对象的引用时，不会自动地初始化该Class对象，初始化被延迟到了对静态方法（构造器隐式的是静态的）或者非final静态域（注意final静态域不会触发初始化操作）进行首次引用时才执行。</p> 
<p>而使用Class.forName时会自动的初始化。</p> 
<p>为了使用类而做的准备工作实际包含三个步骤：</p> 
<p>- 加载：由类加载器执行。查找字节码，并从这些字节码中创建一个Class对象</p> 
<p>- 链接：验证类中的字节码，为静态域分配存储空间，并且如果必需的话，将解析这个类创建的对其他类的所有引用。</p> 
<p>- 初始化：如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。</p> 
<p>如果不知道某个对象的确切类型，RTTI可以告诉你，但是有一个限制：这个类型在编译时必须已知，这样才能使用RTTI识别它，也就是在编译时，编译器必须知道所有要通过RTTI来处理的类。如果要突破这个限制就需要使用反射机制。</p> 
<p>反射的原理：</p> 
<p>Class类与java.lang.reflect类库一起对反射的概念进行了支持，该类库包含了Field、Method以及Constructor类（每个类都实现了Member接口）。这些类型的对象是由JVM在运行时创建的，用以表示未知类里对应的成员。这样你就可以使用Constructor创建新的对象，用get()/set()方法读取和修改与Field对象关联的字段，用invoke()方法调用与Method对象关联的方法。另外，还可以调用getFields()、getMethods()和getConstructors()等很便利的方法，以返回表示字段、方法以及构造器的对象的数组。这样，匿名对象的类信息就能在运行时被完全确定下来，而在编译时不需要知道任何事情。</p> 
<p>反射与RTTI的区别</p> 
<p>当通过反射与一个未知类型的对象打交道时，JVM只是简单地检查这个对象，看它属于哪个特定的类（就像RTTI那样），在用它做其他事情之前必须先加载那个类的Class对象，因此，那个类的.class文件对于JVM来说必须是可获取的：要么在本地机器上，要么可以通过网络取得。所以RTTI与反射之间真正的区别只在于：对RTTI来说，编译器在编译时打开和检查.class文件（也就是可以用普通方法调用对象的所有方法）；而对于反射机制来说，.class文件在编译时是不可获取的，所以是在运行时打开和检查.class文件。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/07354de6a6586faee529572203c4b368/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux中 2&gt;&amp;1 的用法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ad6ea161aa653b91f56cd1014a8395f4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">组合和继承之间的选择</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>