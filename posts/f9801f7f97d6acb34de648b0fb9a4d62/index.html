<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>源码级别讲解 redis 底层数据结构 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="源码级别讲解 redis 底层数据结构" />
<meta property="og:description" content="redis 底层数据结构 Redis作为Key-Value存储系统，数据结构如下：
Redis没有表的概念，Redis实例所对应的db以编号区分，db本身就是key的命名空间。
比如：user:1000作为key值，表示在user这个命名空间下id为1000的元素，类似于user表的id=1000的 行。
1. RedisDB结构 Redis中存在“数据库”的概念，该结构由redis.h中的redisDb定义。 当redis 服务器初始化时，会预先分配 16 个数据库 所有数据库保存到结构 redisServer 的一个成员 redisServer.db 数组中 redisClient中存在一个名叫db的指针指向当前使用的数据库。
RedisDB结构体源码：
typedef struct redisDb { int id; //id是数据库序号，为0-15（默认Redis有16个数据库） long avg_ttl; //存储的数据库对象的平均ttl（time to live），用于统计 dict *dict; //存储数据库所有的key-value dict *expires; //存储key的过期时间 dict *blocking_keys;//blpop 存储阻塞key和客户端对象 dict *ready_keys;//阻塞后push 响应阻塞客户端 存储阻塞后push的key和客户端对象 dict *watched_keys;//存储watch监控的的key和客户端对象 } redisDb; id
id是数据库序号，为0-15（默认Redis有16个数据库）
dict
存储数据库所有的key-value，后面要详细讲解
expires
存储key的过期时间，后面要详细讲解
2. RedisObject结构 Value是一个对象。RedisObject 有五种对象：字符串对象(String)、列表对象(List)、哈希对象(Hash)、集合对象(Set)和有序集合对象(ZSet)。
2.1 结构信息概览 typedef struct redisObject { unsigned type:4;//类型 五种对象类型 unsigned encoding:4;//编码 void *ptr;//指向底层实现数据结构的指针 //." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/f9801f7f97d6acb34de648b0fb9a4d62/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-10T17:15:57+08:00" />
<meta property="article:modified_time" content="2023-05-10T17:15:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">源码级别讲解 redis 底层数据结构</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/58/26/5jNcGWVW_o.png" alt="redis数据类型和底层数据结构有如下对应关系:"></p> 
<h2><a id="redis__1"></a>redis 底层数据结构</h2> 
<p>Redis作为Key-Value存储系统，数据结构如下：</p> 
<p><img src="https://images2.imgbox.com/73/3a/LXayHf4s_o.png" alt="image-20230508160801880"></p> 
<p>Redis没有表的概念，Redis实例所对应的db以编号区分，db本身就是key的命名空间。</p> 
<p>比如：user:1000作为key值，表示在user这个命名空间下id为1000的元素，类似于user表的id=1000的 行。</p> 
<h2><a id="1_RedisDB_11"></a>1. RedisDB结构</h2> 
<p>Redis中存在“数据库”的概念，该结构由redis.h中的redisDb定义。 当redis 服务器初始化时，会预先分配 16 个数据库 所有数据库保存到结构 redisServer 的一个成员 redisServer.db 数组中 redisClient中存在一个名叫db的指针指向当前使用的数据库。</p> 
<p>RedisDB结构体源码：</p> 
<pre><code>typedef struct redisDb {
    int id; //id是数据库序号，为0-15（默认Redis有16个数据库）
    long avg_ttl; //存储的数据库对象的平均ttl（time to live），用于统计
    dict *dict; //存储数据库所有的key-value
    dict *expires; //存储key的过期时间
    dict *blocking_keys;//blpop 存储阻塞key和客户端对象
    dict *ready_keys;//阻塞后push 响应阻塞客户端 存储阻塞后push的key和客户端对象
    dict *watched_keys;//存储watch监控的的key和客户端对象
} redisDb;

</code></pre> 
<ul><li> <p>id<br> id是数据库序号，为0-15（默认Redis有16个数据库）</p> </li><li> <p>dict<br> 存储数据库所有的key-value，后面要详细讲解</p> </li><li> <p>expires</p> <p>存储key的过期时间，后面要详细讲解</p> </li></ul> 
<h2><a id="2_RedisObject_40"></a>2. RedisObject结构</h2> 
<p>Value是一个对象。RedisObject 有五种对象：字符串对象(String)、列表对象(List)、哈希对象(Hash)、集合对象(Set)和有序集合对象(ZSet)。</p> 
<h3><a id="21__44"></a>2.1 结构信息概览</h3> 
<pre><code>typedef struct redisObject {
    unsigned type:4;//类型 五种对象类型
    unsigned encoding:4;//编码
    void *ptr;//指向底层实现数据结构的指针
    //...
    int refcount;//引用计数
    //...
    unsigned lru:LRU_BITS; //LRU_BITS为24bit 记录最后一次被命令程序访问的时间
    //...
}robj;
</code></pre> 
<h4><a id="211_4type_59"></a>2.1.1 4位type</h4> 
<p>type 字段表示对象的类型，占 4 位；REDIS_STRING(字符串)、REDIS_LIST (列表)、REDIS_HASH(哈希)、REDIS_SET(集合)、REDIS_ZSET(有 序集合)。</p> 
<p>当我们执行 type 命令时，便是通过读取 RedisObject 的 type 字段获得对象的类型</p> 
<pre><code>127.0.0.1:6379&gt; type a1
string
</code></pre> 
<h4><a id="212_4encoding_70"></a>2.1.2 4位encoding</h4> 
<p>encoding 表示对象的内部编码，占 4 位。每个对象有不同的实现编码。Redis 可以根据不同的使用场景来为对象设置不同的编码，大大提高了 Redis 的灵活性和效率。 通过 object encoding 命令，可以查看对象采用的编码方式。</p> 
<pre><code>127.0.0.1:6379&gt; object encoding a1
"int"
</code></pre> 
<h4><a id="213_24LRU_79"></a>2.1.3 24位LRU</h4> 
<p>lru 记录的是对象最后一次被命令程序访问的时间，（ 4.0 版本占 24 位，2.6 版本占 22 位）。</p> 
<p>高16位存储一个分钟数级别的时间戳，低8位存储访问计数（lfu ： 最近访问次数）</p> 
<p>lru----&gt; 高16位: 最后被访问的时间</p> 
<p>lfu-----&gt;低8位：最近访问次数</p> 
<h4><a id="214_refcount_89"></a>2.1.4 refcount</h4> 
<p>refcount 记录的是该对象被引用的次数，类型为整型。 refcount 的作用，主要在于对象的引用计数和内存回收。 当对象的refcount&gt;1时，称为共享对象 Redis 为了节省内存，当有一些对象重复出现时，新的程序不会创建新的对象，而是仍然使用原来的对 象。</p> 
<h4><a id="215_ptr_93"></a>2.1.5 ptr</h4> 
<p>ptr 指针指向具体的数据，比如：set hello world，ptr 指向包含字符串 world 的 SDS。</p> 
<h3><a id="22_7type_99"></a>2.2 7种type</h3> 
<h4><a id="221__101"></a>2.2.1 字符串对象</h4> 
<p>C语言： 字符数组 “\0” Redis 使用了 SDS(Simple Dynamic String)。用于存储字符串和整型数据。</p> 
<p><img src="https://images2.imgbox.com/f0/23/CnuQ7SWw_o.png" alt="image-20230508161933789"></p> 
<pre><code>struct sdshdr{
    //记录buf数组中已使用字节的数量
    int len;
    //记录 buf 数组中未使用字节的数量
    int free;
    //字符数组，用于保存字符串
    char buf[];
}
</code></pre> 
<p>buf[] 的长度=len+free+1</p> 
<p><strong>SDS的优势：</strong></p> 
<p>1、SDS 在 C 字符串的基础上加入了 free 和 len 字段，获取字符串长度：SDS 是 O(1)，C 字符串是 O(n)。 buf数组的长度=free+len+1</p> 
<p>2、 SDS 由于记录了长度，在可能造成缓冲区溢出时会自动重新分配内存，杜绝了缓冲区溢出。</p> 
<p>3、可以存取二进制数据，以字符串长度len来作为结束标识</p> 
<p><strong>使用场景：</strong></p> 
<p>SDS的主要应用在：存储字符串和整型数据、存储key、AOF缓冲区和用户输入缓冲。</p> 
<h4><a id="222__134"></a>2.2.2 跳跃表（重点）</h4> 
<p>跳跃表是有序集合（sorted-set）的底层实现，效率高，实现简单。跳跃表的基本思想： 将有序链表中的部分节点分层，每一层都是一个有序链表。</p> 
<h5><a id="2221__138"></a>2.2.2.1 查找</h5> 
<p>在查找时优先从最高层开始向后查找，当到达某个节点时，如果next节点值大于要查找的值或next指针 指向null，则从当前节点下降一层继续向后查找。</p> 
<p>举例：</p> 
<p><img src="https://images2.imgbox.com/78/82/aRxgN3MJ_o.png" alt="image-20230508162357883"></p> 
<p>查找元素9，按道理我们需要从头结点开始遍历，一共遍历8个结点才能找到元素9。</p> 
<p>第一次分层： 遍历5次找到元素9（红色的线为查找路径）</p> 
<p><img src="https://images2.imgbox.com/ca/e1/nchpJUzH_o.png" alt="image-20230508162419956"></p> 
<p>第二次分层： 遍历4次找到元素9</p> 
<p><img src="https://images2.imgbox.com/ce/5e/QwaCkiA7_o.png" alt="image-20230508162435967"></p> 
<p>第三层分层: 遍历4次找到元素9</p> 
<p><img src="https://images2.imgbox.com/34/7e/Ny6s2WRq_o.png" alt="image-20230508162540628"></p> 
<p>这种数据结构，就是跳跃表，它具有二分查找的功能。</p> 
<h5><a id="2222__162"></a>2.2.2.2 插入与删除</h5> 
<p>上面例子中，9个结点，一共4层，是理想的跳跃表。</p> 
<p>通过抛硬币（概率1/2）的方式来决定新插入结点跨越的层数：</p> 
<p>正面:插入上层</p> 
<p>背面：不插入</p> 
<p>达到1/2概率（计算次数）</p> 
<h5><a id="2223__174"></a>2.2.2.3 删除</h5> 
<p>找到指定元素并删除每层的该元素即可</p> 
<h5><a id="2224__178"></a>2.2.2.4 跳跃表特点：</h5> 
<ul><li>每层都是一个有序链表</li><li>查找次数近似于层数（1/2）</li><li>底层包含所有元素</li><li>空间复杂度 O(n) 扩充了一倍</li></ul> 
<pre><code>//跳跃表节点
typedef struct zskiplistNode {
    sds ele;
    /* 存储字符串类型数据 redis3.0版本中使用robj类型表示，
        但是在redis4.0.1中直接使用sds类型表示 */
    double score; //存储排序的分值
    struct zskiplistNode * backward; //后退指针，指向当前节点最底层的前一个节点
    /*
    层，柔性数组，随机生成1-64的值
    */
    struct zskiplistLevel {
        struct zskiplistNode * forward; //指向本层下一个节点
        unsigned int span; //本层下个节点到本节点的元素个数
    }
    level[];
}
zskiplistNode;
//链表
typedef struct zskiplist {
    //表头节点和表尾节点
    structz skiplistNode * header, * tail;
    //表中节点的数量
    unsigned long length;
    //表中层数最大的节点的层数
    int level;
}
zskiplist;
</code></pre> 
<p>完整的跳跃表结构体：</p> 
<p><img src="https://images2.imgbox.com/ff/1d/1QEDuVUS_o.png" alt="image-20230508162943926"></p> 
<p>跳跃表的优势：</p> 
<p>1、可以快速查找到需要的节点<br> 2、可以在O(1)的时间复杂度下，快速获得跳跃表的头节点、尾结点、长度和高度。</p> 
<p>应用场景：有序集合的实现</p> 
<h4><a id="223__226"></a>2.2.3 字典（重点+难点）</h4> 
<p>字典dict又称散列表（hash），是用来存储键值对的一种数据结构。<br> Redis整个数据库是用字典来存储的。（K-V结构）<br> 对Redis进行CURD操作其实就是对字典中的数据进行CURD操作。</p> 
<h5><a id="2231__232"></a>2.2.3.1 数组</h5> 
<p>数组：用来存储数据的容器，采用头指针+偏移量的方式能够以O(1)的时间复杂度定位到数据所在的内存地址。<br> Redis 海量存储 快</p> 
<h5><a id="2232_Hash_237"></a>2.2.3.2 Hash函数</h5> 
<p>Hash（散列），作用是把任意长度的输入通过散列算法转换成固定类型、固定长度的散列值。<br> hash函数可以把Redis里的key：包括字符串、整数、浮点数统一转换成整数。<br> key=100.1 String “100.1” 5位长度的字符串<br> Redis-cli :times 33<br> Redis-Server : siphash<br> 数组下标=hash(key)%数组容量(hash值%数组容量得到的余数)</p> 
<h5><a id="2233_Hash_246"></a>2.2.3.3 Hash冲突</h5> 
<p>不同的key经过计算后出现数组下标一致，称为Hash冲突。<br> 采用单链表在相同的下标位置处存储原始key和value<br> 当根据key找Value时，找到数组下标，遍历单链表可以找出key相同的value</p> 
<p><img src="https://images2.imgbox.com/a7/ca/Znmh3X9d_o.png" alt="image-20230508164011042"></p> 
<h5><a id="2234_Redis_254"></a>2.2.3.4 Redis字典的实现</h5> 
<p>Redis字典实现包括：字典(dict)、Hash表(dictht)、Hash表节点(dictEntry)。</p> 
<p><img src="https://images2.imgbox.com/8a/7d/dyFkAbbr_o.png" alt="image-20230508164121250"></p> 
<h6><a id="Hash_260"></a>Hash表</h6> 
<pre><code>typedef struct dictht {
    dictEntry **table; // 哈希表数组
    unsigned long size; // 哈希表数组的大小
    unsigned long sizemask; // 用于映射位置的掩码，值永远等于(size-1)
    unsigned long used; // 哈希表已有节点的数量,包含next单链表数据
} dictht;
</code></pre> 
<p>1、hash表的数组初始容量为4，随着k-v存储量的增加需要对hash表数组进行扩容，新扩容量为当前量<br> 的一倍，即4,8,16,32<br> 2、索引值=Hash值&amp;掩码值（Hash值与Hash表容量取余）</p> 
<h6><a id="Hash_275"></a>Hash表节点</h6> 
<pre><code>typedef struct dictEntry {
    void * key; // 键
    union { // 值v的类型可以是以下4种类型
        void * val;
        uint64_t u64;
        int64_t s64;
        double d;
    }
    v;
    struct dictEntry * next; // 指向下一个哈希表节点，形成单向链表 解决hash冲突
}dictEntry;
</code></pre> 
<p>key字段存储的是键值对中的键<br> v字段是个联合体，存储的是键值对中的值。<br> next指向下一个哈希表节点，用于解决hash冲突</p> 
<p><img src="https://images2.imgbox.com/9b/70/GCgsUArQ_o.png" alt="image-20230508164246078"></p> 
<h6><a id="dict_297"></a>dict字典</h6> 
<pre><code>typedef struct dict {
    dictType * type; // 该字典对应的特定操作函数
    void * privdata; // 上述类型函数对应的可选参数
    dictht ht[2];
    /* 两张哈希表，存储键值对数据，ht[0]为原生
    哈希表，
    ht[1]为 rehash 哈希表 */
    long rehashidx;
    /*rehash标识 当等于-1时表示没有在
    rehash，
    否则表示正在进行rehash操作，存储的值表示
    hash表 ht[0]的rehash进行到哪个索引值
    (数组下标)*/
    int iterators; // 当前运行的迭代器数量
}dict;
</code></pre> 
<p>type字段，指向dictType结构体，里边包括了对该字典操作的函数指针</p> 
<p>Redis字典除了主数据库的K-V数据存储以外，还可以用于：散列表对象、哨兵模式中的主从节点管理等<br> 在不同的应用中，字典的形态都可能不同，dictType是为了实现各种形态的字典而抽象出来的操作函数<br> （多态）。<br> 完整的Redis字典数据结构：</p> 
<p><img src="https://images2.imgbox.com/2d/27/2ID1zyP4_o.png" alt="image-20230508164401179"></p> 
<h5><a id="2235__326"></a>2.2.3.5 字典扩容</h5> 
<p>字典达到存储上限，需要rehash（扩容）</p> 
<p>扩容流程：</p> 
<p><img src="https://images2.imgbox.com/f3/4d/tSCDdTTC_o.png" alt="image-20230508164435460"></p> 
<p>说明：</p> 
<ol><li>初次申请默认容量为4个dictEntry，非初次申请为当前hash表容量的一倍。</li><li>rehashidx=0表示要进行rehash操作。</li><li>新增加的数据在新的hash表h[1]</li><li>修改、删除、查询在老hash表h[0]、新hash表h[1]中（rehash中）</li><li>将老的hash表h[0]的数据重新计算索引值后全部迁移到新的hash表h[1]中，这个过程称为<br> rehash。</li></ol> 
<h6><a id="2236_rehash_343"></a>2.2.3.6 渐进式rehash</h6> 
<p>当数据量巨大时rehash的过程是非常缓慢的，所以需要进行优化。服务器忙，则只对一个节点进行rehash 服务器闲，可批量rehash(100节点)<br> 应用场景：<br> 1、主数据库的K-V数据存储<br> 2、散列表对象（hash）<br> 3、哨兵模式中的主从节点管理</p> 
<h4><a id="224__351"></a>2.2.4 压缩列表</h4> 
<p>压缩列表（ziplist）是由一系列特殊编码的连续内存块组成的顺序型数据结构,节省内存。是一个字节数组，可以包含多个节点（entry）。每个节点可以保存一个字节数组或一个整数。压缩列表的数据结构如下：</p> 
<p><img src="https://images2.imgbox.com/47/04/fUx17Y9w_o.png" alt="image-20230508164634547"></p> 
<p><strong>zlbytes：</strong> 压缩列表的字节长度<br> <strong>zltail：</strong> 压缩列表尾元素相对于压缩列表起始地址的偏移量<br> <strong>zllen：</strong> 压缩列表的元素个数<br> <strong>entry1…entryX :</strong> 压缩列表的各个节点<br> <strong>zlend：</strong> 压缩列表的结尾，占一个字节，恒为0xFF（255）<br> <strong>entryX</strong> 元素的编码结构：</p> 
<p><img src="https://images2.imgbox.com/10/00/JJsP6NwM_o.png" alt="image-20230508164649973"></p> 
<p><strong>previous_entry_length：</strong> 前一个元素的字节长度<br> <strong>encoding:</strong> 表示当前元素的编码<br> <strong>content:</strong> 数据内容<br> ziplist结构体如下：</p> 
<pre><code>typedef struct zlentry {
    unsigned int prevrawlensize; //previous_entry_length字段的长度
    unsigned int prevrawlen; //previous_entry_length字段存储的内容
    unsigned int lensize; //encoding字段的长度
    unsigned int len; //数据内容长度
    unsigned int headersize; //当前元素的首部长度，即previous_entry_length字段长度与 encoding字段长度之和。
    unsigned char encoding; //数据类型
    unsigned char * p; //当前元素首地址
}
zlentry;
</code></pre> 
<h5><a id="_384"></a>应用场景：</h5> 
<p>sorted-set和hash元素<strong>个数少且是小整数或短字符串</strong>（直接使用）<br> list用快速链表(quicklist)数据结构存储，而快速链表是双向列表与压缩列表的组合。（间接使用）</p> 
<h4><a id="225__389"></a>2.2.5 整数集合</h4> 
<p>整数集合(intset)是一个有序的（整数升序）、存储整数的连续存储结构。</p> 
<p>当Redis集合类型的元素都是整数并且都处在64位有符号整数范围内（2^64），使用该结构体存储。</p> 
<pre><code>127.0.0.1:6379&gt; sadd set:001 1 3 5 6 2
(integer) 5
127.0.0.1:6379&gt; object encoding set:001
"intset"
127.0.0.1:6379&gt; sadd set:004 1 100000000000000000000000000 9999999999
(integer) 3
127.0.0.1:6379&gt; object encoding set:004
"hashtable"
</code></pre> 
<p>intset的结构图如下：</p> 
<p><img src="https://images2.imgbox.com/25/b5/M3ec3zua_o.png" alt="image-20230508164945228"></p> 
<pre><code>typedef struct intset{
    //编码方式
    uint32_t encoding;
    //集合包含的元素数量
    uint32_t length;
    //保存元素的数组
    int8_t contents[];
}intset;
</code></pre> 
<h5><a id="_421"></a>应用场景：</h5> 
<p>可以保存类型为int16_t、int32_t 或者int64_t 的整数值，并且保证集合中不会出现重复元素。</p> 
<h4><a id="226__425"></a>2.2.6 快速列表（重要）</h4> 
<p>快速列表（quicklist）是Redis底层重要的数据结构。是列表的底层实现。（在Redis3.2之前，Redis采用双向链表（adlist）和压缩列表（ziplist）实现。）在Redis3.2以后结合adlist和ziplist的优势Redis设计出了quicklist。</p> 
<pre><code>127.0.0.1:6379&gt; lpush list:001 1 2 5 4 3
(integer) 5
127.0.0.1:6379&gt; object encoding list:001
"quicklist"
</code></pre> 
<h5><a id="adlist_436"></a>双向列表（adlist）</h5> 
<p><img src="https://images2.imgbox.com/fb/09/cCAQ6gSi_o.png" alt="image-20230508170255159"></p> 
<p>双向链表优势：</p> 
<ol><li>双向：链表具有前置节点和后置节点的引用，获取这两个节点时间复杂度都为O(1)。</li><li>普通链表（单链表）：节点类保留下一节点的引用。链表类只保留头节点的引用，只能从头节点插入删除</li><li>无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL,对链表的访问都是以 NULL 结束。环状：头的前一个节点指向尾节点</li><li>带链表长度计数器：通过 len 属性获取链表长度的时间复杂度为 O(1)。</li><li>多态：链表节点使用 void* 指针来保存节点值，可以保存各种不同类型的值。</li></ol> 
<h5><a id="_448"></a>快速列表</h5> 
<p>quicklist是一个双向链表，链表中的每个节点时一个ziplist结构。quicklist中的每个节点ziplist都能够存储多个数据元素。</p> 
<p><img src="https://images2.imgbox.com/bf/98/9BagTlOX_o.png" alt="image-20230508170435527"></p> 
<p>quicklist的结构定义如下：</p> 
<pre><code>typedef struct quicklist {
    quicklistNode * head; // 指向quicklist的头部
    quicklistNode * tail; // 指向quicklist的尾部
    unsigned long count; // 列表中所有数据项的个数总和
    unsigned int len; // quicklist节点的个数，即ziplist的个数
    int fill: 16; // ziplist大小限定，由list-max-ziplist-size给定(Redis设定)
    unsigned int compress: 16; // 节点压缩深度设置，由list-compress-depth给定(Redis设定)
} quicklist;
</code></pre> 
<p>quicklistNode的结构定义如下：</p> 
<pre><code>typedef struct quicklistNode {
    struct quicklistNode * prev; // 指向上一个ziplist节点
    struct quicklistNode * next; // 指向下一个ziplist节点
    unsigned char * zl; // 数据指针，如果没有被压缩，就指向ziplist结构，反之指向 quicklistLZF结构
    unsigned int sz; // 表示指向ziplist结构的总长度(内存占用长度)
    unsigned int count: 16; // 表示ziplist中的数据项个数
    unsigned int encoding: 2; // 编码方式，1--ziplist，2--quicklistLZF
    unsigned int container: 2; // 预留字段，存放数据的方式，1--NONE，2--ziplist
    unsigned int recompress: 1; // 解压标记，当查看一个被压缩的数据时，需要暂时解压，标记此参数为 1， 之后再重新进行压缩
    unsigned int attempted_compress: 1; // 测试相关
    unsigned int extra: 10; // 扩展字段，暂时没用
}quicklistNode;
</code></pre> 
<h5><a id="_484"></a>数据压缩</h5> 
<p>quicklist每个节点的实际数据存储结构为ziplist，这种结构的优势在于节省存储空间。为了进一步降低ziplist的存储空间，还可以对ziplist进行压缩。Redis采用的压缩算法是LZF。其基本思想是：数据与前面重复的记录重复位置及长度，不重复的记录原始数据。<br> 压缩过后的数据可以分成多个片段，每个片段有两个部分：解释字段和数据字段。quicklistLZF的结构体如下：</p> 
<pre><code>typedef struct quicklistLZF {
    unsigned int sz; // LZF压缩后占用的字节数
    char compressed[]; // 柔性数组，指向数据部分
} quicklistLZF;
</code></pre> 
<h5><a id="_496"></a>应用场景</h5> 
<p>列表(List)的底层实现、发布与订阅、慢查询、监视器等功能。</p> 
<h2><a id="3_10encoding__500"></a>3 10种encoding 编码</h2> 
<p>encoding 表示对象的内部编码，占 4 位。Redis通过 encoding 属性为对象设置不同的编码对于少的和小的数据，Redis采用小的和压缩的存储方式，体现Redis的灵活性。大大提高了 Redis 的存储量和执行效率。</p> 
<p>比如Set对象：</p> 
<p>intset ： 元素是64位以内的整数<br> hashtable：元素是64位以外的整数</p> 
<p>如下所示：</p> 
<pre><code>127.0.0.1:6379&gt; sadd set:001 1 3 5 6 2
(integer) 5
127.0.0.1:6379&gt; object encoding set:001
"intset"
127.0.0.1:6379&gt; sadd set:004 1 100000000000000000000000000 9999999999
(integer) 3
127.0.0.1:6379&gt; object encoding set:004
"hashtable"
</code></pre> 
<h3><a id="31_String_522"></a>3.1 String</h3> 
<p>int、raw、embstr</p> 
<h5><a id="int_526"></a>int</h5> 
<p>REDIS_ENCODING_INT（int类型的整数）</p> 
<pre><code>127.0.0.1:6379&gt; set n1 123
OK
127.0.0.1:6379&gt; object encoding n1
"int"
</code></pre> 
<h5><a id="embstr_537"></a>embstr</h5> 
<p>REDIS_ENCODING_EMBSTR(编码的简单动态字符串)</p> 
<p>小字符串 长度小于44个字节</p> 
<pre><code>127.0.0.1:6379&gt; set name:001 zhangfei
OK
127.0.0.1:6379&gt; object encoding name:001
"embstr"
</code></pre> 
<h5><a id="raw_550"></a>raw</h5> 
<p>REDIS_ENCODING_RAW （简单动态字符串）</p> 
<p>大字符串 长度大于44个字节</p> 
<pre><code>127.0.0.1:6379&gt; set address:001
asdasdasdasdasdasdsadasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdas
dasdasdas
OK
127.0.0.1:6379&gt; object encoding address:001
"raw"
</code></pre> 
<h3><a id="32_list_565"></a>3.2 list</h3> 
<p>列表的编码是quicklist。<br> REDIS_ENCODING_QUICKLIST（快速列表）</p> 
<pre><code>127.0.0.1:6379&gt; lpush list:001 1 2 5 4 3
(integer) 5
127.0.0.1:6379&gt; object encoding list:001
"quicklist"
</code></pre> 
<h3><a id="33_hash_577"></a>3.3 hash</h3> 
<p>散列的编码是<strong>字典</strong>和<strong>压缩列表</strong></p> 
<h5><a id="dict_581"></a>dict</h5> 
<p>REDIS_ENCODING_HT（字典）</p> 
<p>当散列表元素的个数比较多或元素不是小整数或短字符串时。</p> 
<pre><code>127.0.0.1:6379&gt; hmset user:003
username111111111111111111111111111111111111111111111111111111111111111111111111
11111111111111111111111111111111 zhangfei password 111 num
2300000000000000000000000000000000000000000000000000
OK
127.0.0.1:6379&gt; object encoding user:003
"hashtable"
</code></pre> 
<h5><a id="ziplist_597"></a>ziplist</h5> 
<p>REDIS_ENCODING_ZIPLIST（压缩列表）<br> 当散列表元素的个数比较少，且元素都是小整数或短字符串时。</p> 
<pre><code>127.0.0.1:6379&gt; hmset user:001 username zhangfei password 111 age 23 sex M
OK
127.0.0.1:6379&gt; object encoding user:001
"ziplist"
</code></pre> 
<h3><a id="34_set_609"></a>3.4 set</h3> 
<p>集合的编码是<strong>整形集合</strong>和<strong>字典</strong></p> 
<h5><a id="intset_613"></a>intset</h5> 
<p>REDIS_ENCODING_INTSET（整数集合）<br> 当Redis集合类型的元素都是整数并且都处在64位有符号整数范围内（&lt;18446744073709551616）</p> 
<pre><code>127.0.0.1:6379&gt; sadd set:001 1 3 5 6 2
(integer) 5
127.0.0.1:6379&gt; object encoding set:001
"intset"
</code></pre> 
<h5><a id="dict_625"></a>dict</h5> 
<p>REDIS_ENCODING_HT（字典）</p> 
<p>当Redis集合类型的元素都是整数并且都处在64位有符号整数范围外（&gt;18446744073709551616）</p> 
<pre><code>127.0.0.1:6379&gt; sadd set:004 1 100000000000000000000000000 9999999999
(integer) 3
127.0.0.1:6379&gt; object encoding set:004
"hashtable"
</code></pre> 
<h3><a id="35_zset_638"></a>3.5 zset</h3> 
<p>有序集合的编码是<strong>压缩列表和跳跃表+字典</strong></p> 
<h5><a id="ziplist_642"></a>ziplist</h5> 
<p>REDIS_ENCODING_ZIPLIST（压缩列表）<br> 当元素的个数比较少，且元素都是小整数或短字符串时。</p> 
<pre><code>127.0.0.1:6379&gt; zadd hit:1 100 item1 20 item2 45 item3
(integer) 3
127.0.0.1:6379&gt; object encoding hit:1
"ziplist"
</code></pre> 
<h5><a id="skiplist__dict_654"></a>skiplist + dict</h5> 
<p>REDIS_ENCODING_SKIPLIST（跳跃表+字典）<br> 当元素的个数比较多或元素不是小整数或短字符串时。</p> 
<pre><code>127.0.0.1:6379&gt; zadd hit:2 100
item1111111111111111111111111111111111111111111111111111111111111111111111111111
1111111111111111111111111111111111 20 item2 45 item3
(integer) 3
127.0.0.1:6379&gt; object encoding hit:2
"skiplist"
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a4517020e78cd2ee33ccf5a0af7c7703/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于单片机的数字频率计设计</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a6e0739e6bdc9cc6748ef2eeea3bb9f4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">WB_BF项目问题说明以及探究</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>