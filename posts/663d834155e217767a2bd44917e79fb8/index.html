<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C#面向对象程序设计学习笔记（三） - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C#面向对象程序设计学习笔记（三）" />
<meta property="og:description" content="继承
在程序设计中实现继承，表示这个类拥有他继承的类的所有共有成员或者受保护成员，在面向对象的编程中被继承的类称为父类或基类，实现继承的类成为子类或派生类。继承的基本思想是基于某个基类的扩展，制定一个新的派生类，派生类可以继承基类原有的属性和方法，也可以增加原来基类所不具备的属性和方法，或者重写基类中的某些方法。C#中使用“：”来标识两个类的继承关系。子类不能访问基类的私有成员。子类的访问不能高于父类的可访问性，例如下面子类继承父类
子类重写
子类重写父类的方法，如果想要调用父类的方法，就要使用base关键字
base.Property; //调用父类的属性 base.method(); //调用父类的方法 如果要在子类中使用base关键字调用父类的属性或者方法，父类的属性和方法必须定义为public或者protected类型
class Computer //父类：电脑 { public string sayHello() { return &#34;欢迎使用&#34;; } } class Pad : Computer //继承computer类 子类：平板电脑 { public new string sayHello() //子类重写父类方法 { return base.sayHello() &#43; &#34;平板电脑&#34;; //调用父类方法，在结果后添加字符串 } } 在子类中定义构造函数时，即可使用base关键字来调用基类的构造函数
多态
它使得子类的实例可以直接赋予基类的对象，然后直接就可以通过这个对象调用派生类的方法，在C#中，类的多态性是通过在派生类中重写基类的虚方法来实现。
在C#中，方法在默认情况下不是虚拟的，但（除了构造函数以外）可以显示地声明为virtual，在方法前面加上关键字virtual，则称该方法为虚拟方法，定义虚方法后，可以在子类重写虚方法，重写虚方法使用override关键字。
类中的成员字段和静态方法不能声明为virtual，因为virtual只对类中的实例方法和属性有意义。
可以创建类名的数组，例如Vehicle[ ] vehicles={vehicle,train,car}
抽象类和抽象方法
如果一个类不与具体的事物相联系，仅仅是作为其派生类的一个基类，这样的类就可以声明为抽象类，C#中声明抽象类时需要使用abstract关键字，抽象类不能直接实例化，其中可以包含抽象成员，但非抽象类中不可以，抽象类中不能被密封，抽象方法必须声明在抽象类中，声明抽象方法时，不能使用virtual、static、private修饰符。例子如下：
当从一个派生类中生成一个非抽象类时，需要在非抽象类中重写抽象方法，以提供具体的实现，在重写抽象方法时需要使用override关键字.。
public abstract class Market //创建抽象类 { public string Name { get; set; } //商场名称属性 public string Goods { get; set; } //商品名称属性 public abstract void Shop(); //抽象方法 } public class WallMarket : Market //继承抽象类 { public override void Shop() //重写抽象方法 { Console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/663d834155e217767a2bd44917e79fb8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-09-19T08:47:50+08:00" />
<meta property="article:modified_time" content="2019-09-19T08:47:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C#面向对象程序设计学习笔记（三）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>继承</strong></p> 
<p>在程序设计中实现继承，表示这个类拥有他继承的类的所有共有成员或者受保护成员，在面向对象的编程中被继承的类称为父类或基类，实现继承的类成为子类或派生类。继承的基本思想是基于某个基类的扩展，制定一个新的派生类，派生类可以继承基类原有的属性和方法，也可以增加原来基类所不具备的属性和方法，或者重写基类中的某些方法。C#中使用“：”来标识两个类的继承关系。子类不能访问基类的私有成员。子类的访问不能高于父类的可访问性，例如下面子类继承父类</p> 
<p><img alt="" class="has" height="324" src="https://images2.imgbox.com/73/a9/65rSbSgG_o.png" width="827"></p> 
<p>子类重写</p> 
<p>子类重写父类的方法，如果想要调用父类的方法，就要使用base关键字</p> 
<pre class="has"><code>base.Property;              //调用父类的属性
base.method();              //调用父类的方法</code></pre> 
<p>如果要在子类中使用base关键字调用父类的属性或者方法，父类的属性和方法必须定义为public或者protected类型</p> 
<pre class="has"><code class="language-cs">class Computer                             //父类：电脑
    {
       public string sayHello()
        {
            return "欢迎使用";
        }
    }
    class Pad : Computer                //继承computer类    子类：平板电脑
    {
       public new string sayHello()                          //子类重写父类方法
        { 
            return base.sayHello() + "平板电脑";             //调用父类方法，在结果后添加字符串

        }
    }</code></pre> 
<p> 在子类中定义构造函数时，即可使用base关键字来调用基类的构造函数</p> 
<p><strong>多态</strong></p> 
<p>它使得子类的实例可以直接赋予基类的对象，然后直接就可以通过这个对象调用派生类的方法，在C#中，类的多态性是通过在派生类中重写基类的虚方法来实现。</p> 
<p>在C#中，方法在默认情况下不是虚拟的，但（除了构造函数以外）可以显示地声明为virtual，在方法前面加上关键字<strong>virtual</strong>，则称该方法为虚拟方法，定义虚方法后，可以在子类重写虚方法，重写虚方法使用<strong>override</strong>关键字。</p> 
<p>类中的成员字段和静态方法不能声明为virtual，因为virtual只对类中的实例方法和属性有意义。</p> 
<p>可以创建类名的数组，例如Vehicle[ ] vehicles={vehicle,train,car}</p> 
<p>抽象类和抽象方法</p> 
<p>如果一个类不与具体的事物相联系，仅仅是作为其派生类的一个基类，这样的类就可以声明为抽象类，C#中声明抽象类时需要使用abstract关键字，抽象类不能直接实例化，其中可以包含抽象成员，但非抽象类中不可以，抽象类中不能被密封，抽象方法必须声明在抽象类中，声明抽象方法时，不能使用virtual、static、private修饰符。例子如下：</p> 
<p><img alt="" class="has" height="92" src="https://images2.imgbox.com/fd/86/q3B82TJv_o.png" width="636"></p> 
<p>当从一个派生类中生成一个非抽象类时，需要在非抽象类中重写抽象方法，以提供具体的实现，在重写抽象方法时需要使用override关键字.。</p> 
<pre class="has"><code class="language-cs">public abstract class Market                    //创建抽象类
    {
        public string Name { get; set; }       //商场名称属性
        public string Goods { get; set; }         //商品名称属性

        public abstract void Shop();           //抽象方法
    }
    public class WallMarket : Market                 //继承抽象类
    {
        public override void Shop()                    //重写抽象方法
        {
            Console.WriteLine(Name + "购买" + Goods);
        }
    }
   class Program
   {
        static void Main(string[] args)
        {
            Market market = new WallMarket();          //使用子类对象创建抽象类对象
            market.Name = "沃尔玛";
            market.Goods = "衣服";     
            market.Shop();
            Console.ReadLine();
         
        }
    }

</code></pre> 
<p>接口</p> 
<p>C#中的类不支持多重继承，但现实生活中有很多多重继承的问题，为了解决这个问题，通过接口可以实现多重继承的功能，对于声明接口时，使用interface关键字，接口可以继承其他接口，类可以通过其继承的基类（或接口）多次继承同一个接口。</p> 
<p>接口的特征：接口类似于抽象基类,继承接口的任何类型都必须实现接口的所有成员；接口中不能包括构造函数，因此不能直接实例化接口；接口只能定义成员，不能实现成员；接口中定义的成员不允许加访问修饰符，因为接口成员永远是公共的；接口中的成员不能声明为虚拟或者静态。</p> 
<pre class="has"><code class="language-cs">interface Information                  //定义接口
{ 
     string Code{get;set;}               //编号属性及实现
     string Name{get;set;}               //名称属性及实现
     void ShowInfo();                   //用来输出信息
}</code></pre> 
<p>接口实现通过类继承来实现，一个类虽然只能继承一个基类，但可以继承任意多个接口。声明实现接口的类时，需要在继承列表中包含所实现的接口的名称，多个接口之间用逗号（，）分割。</p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c942dec3143ffee8c2699927f9d895bb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spss乱码问题的解决方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/588c5123920398ecadb9a0edc22ed1f4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数字图像处理（频域、空域处理基础）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>