<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C/C&#43;&#43;中char **p1赋值给const char **p2产生错误 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C/C&#43;&#43;中char **p1赋值给const char **p2产生错误" />
<meta property="og:description" content="最近在看《C专家编程》，书中提到：
1、实参 char *s与形参 const char *p相容；
2、实参char **argv 与形参 const char **p 不相容；（why ?）
代码如下：
&lt;span style=&#34;font-size:14px;&#34;&gt;#include &#34;stdafx.h&#34; int foo(const char **p) { printf(&#34;just for test&#34;); return 0; } int main(int argc,char*argv[]) { foo(argv); return 0; }&lt;/span&gt; 编译报错：error C2664: &#39;foo&#39; : cannot convert parameter 1 from &#39;char *[]&#39; to &#39;const char **&#39;
ANSI C11 第6.5.2.2节（ANSI C89第6.3.2.2节）提到：
“ If the expression that denotes the called function has a type that includes a prototype, the number of arguments shall agree with the number of parameters." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/dca220b25e3c676f41de3bfa2c6decec/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-05-20T21:49:06+08:00" />
<meta property="article:modified_time" content="2015-05-20T21:49:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C/C&#43;&#43;中char **p1赋值给const char **p2产生错误</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-size:14px">最近在看《C专家编程》，书中提到：</span></p> 
<p><span style="font-size:14px">       1、实参 char *s与形参 const char *p相容；</span></p> 
<p><span style="font-size:14px">       2、实参char **argv 与形参 const char **p 不相容；（why ?）</span></p> 
<p><span style="font-size:14px"><br> </span></p> 
<p><span style="font-size:14px">代码如下：</span></p> 
<pre><code class="language-cpp">&lt;span style="font-size:14px;"&gt;#include "stdafx.h"
int foo(const char **p)
{
	printf("just for test");
	return 0;
}
int main(int argc,char*argv[])
{
	foo(argv);
	return 0;
}&lt;/span&gt;</code></pre> 
<span style="font-size:14px"><br> </span> 
<p><span style="font-size:14px">编译报错：error C2664: 'foo' : cannot convert parameter 1 from 'char *[]' to 'const char **'</span></p> 
<p><span style="font-size:14px"><br> </span></p> 
<p><span style="font-size:14px">ANSI C11 第6.5.2.2节（ANSI C89第6.3.2.2节）提到：</span></p> 
<p><span style="font-size:14px">      <span style="color:#CC0000"> “ If the expression that denotes the called function has a type that includes a prototype, the number of arguments shall agree with the number of parameters. Each argument shall have a type such that its value may be assigned to an object with the unqualified version of the type of its corresponding parameter.”</span></span></p> 
<p><span style="font-size:14px">        如果表示被调函数的表达式其类型包含原型，则实参数必须和形参相匹配。每个实参的类型必须保证其实参值可以赋值给一个对象，而该对象的类型是相应的形参类型的非限定版本。</span></p> 
<p><span style="font-size:14px"><br> </span></p> 
<p><span style="font-size:14px">       接着，ANSI C11 第6.5.16.1节（ANSI C89 第6.3.16.1节）描述了合法的赋值条件：</span></p> 
<p><span style="font-size:14px">       One of the following shall hold: <br>                — the left operand has atomic, qualified, or unqualified arithmetic type, and the right has arithmetic type;<br>                — the left operand has an atomic, qualified, or unqualified version of a structure or union type compatible</span></p> 
<p><span style="font-size:14px">                    with the type of  the right;<br>               — <span style="color:#FF0000">the left operand has atomic, qualified, or unqualified pointer type, and (considering the type the left operand<br> </span></span></p> 
<p><span style="font-size:14px; color:#FF0000">                   would have after lvalue conversion) both operands are pointers to qualified or unqualified versions of</span></p> 
<p><span style="font-size:14px"><span style="color:#FF0000">                   compatible types, and the type pointed to by the left has all the qualifiers of the type pointed to by the right;</span><br>               — the left operand has atomic, qualified, or unqualified pointer type, and (considering the type the left operand<br> </span></p> 
<p><span style="font-size:14px">                    would have after lvalue conversion) one operand is a pointer to an object type, and the other is a pointer to<br> </span></p> 
<p><span style="font-size:14px">                    a qualified or unqualified version of void, and the type pointed to by the left has all the qualifiers of the type<br> </span></p> 
<p><span style="font-size:14px">                    pointed to by the right;<br>                — the left operand is an atomic, qualified, or unqualified pointer, and the right is a null pointer constant; or<br>               — the left operand has type atomic, qualified, or unqualified _Bool, and the right is a pointer.</span></p> 
<p><span style="font-size:14px">       其第三条描述：“两个操作数都是指向有限定符或无限定符的相容类型的指针，左边指针所指向的类型必须具有右边指针所指向类型的全部限定符”。</span></p> 
<p><br> </p> 
<p><span style="font-size:14px">        以上，解释了：在函数调用中，实参char *能够与形参const char *匹配。反之，<span style="font-size:14px">const char *</span>不能对<span style="font-size:14px"><span style="font-size:14px">char *</span></span>进行赋值。</span></p> 
<p><span style="font-size:14px">   <br> </span></p> 
<p><span style="font-size:14px">        在ANSI C11 第6.2.5节（<span style="font-size:14px">ANSI C89 第6.1.2.5节</span>）描述：<br> </span></p> 
<p><span style="font-size:14px">        The type designated as ‘‘float *’’ has type ‘‘pointer to float’’. Its type category is pointer, not a floating type. The const-qualified version of this type is designated as ‘‘float * const’’ whereas the type designated as ‘‘const float *’’ is not a qualified type — its type is ‘‘pointer to const-qualified float’’ and is a pointer to a qualified type.</span></p> 
<p><span style="font-size:14px">         由“ float * ”指示的类型是“ 指向float的指针 ”，它的类型类别是指针，而不是浮点类型。该类型的const限定形式由“ float * const ”指示。而由“ const float * ”指示的类型不是限定类型——该类型是“ 指向const限定的float的指针”，是一个指向限定类型的指针。</span></p> 
<p><span style="font-size:14px"><br> </span></p> 
<p><span style="font-size:14px">       <span style="color:#CC0000">  以此类推，const char ** 也是一个没有限定符的指针类型。它的类型是：“指向有const限定符的char类型的指针的指针”。由于char ** 和const char **都是没有限定符的指针类型，但是它们所指向的类型是不一样的（前者指向char *,后者指向const char *）,因此它们是不相容的。</span></span></p> 
<p><span style="font-size:14px"><br> </span></p> 
<p><span style="font-size:14px">以上参考 ANSI C11及ANSI C89，及《C专家编程》。</span></p> 
<p><span style="font-size:14px">编译环境：32位Windows 7+VS2008</span></p> 
<p><br> </p> 
<p><br> <span style="font-size:14px"></span></p> 
<p><span style="font-size:14px"><strong>         ZhaiPillary</strong></span></p> 
<span style="font-size:14px"><strong>    2015/05/20于上海</strong></span> 
<p><span style="font-size:14px"><span style="font-size:14px"><strong>    博客地址：<a target="_blank" href="http://blog.csdn.net/pillary" rel="noopener noreferrer">http://blog.csdn.net/pillary</a><br> </strong></span></span></p> 
<p><span style="font-size:14px"><br> </span></p> 
<p><span style="font-size:14px"><br> </span></p> 
<p><span style="font-size:14px"><br> </span></p> 
<p><span style="font-size:14px"><br> </span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/adb3a5c5115ac9be30849087a11c048b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ADO.NET——DataAdapter对象</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/093e5986ada03ebbd416b8dcd569db38/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">warning: ‘p’ may be used uninitialized in this function</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>