<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>使用EFCore连接SQLite - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="使用EFCore连接SQLite" />
<meta property="og:description" content="简介 在使用EFCore连接SQLite之前我们先来了解一下SQLite
SQLite是一个轻量级、自包含、无服务器、零配置的事务性SQL数据库引擎，它支持SQL92标准的大多数查询语言并兼容ACID事务。具体如下：
轻量级：SQLite非常轻巧，它的库体积小，资源占用低，特别适合于嵌入式设备和移动应用，有时仅需几百KB的内存即可运行。自包含：作为一个自给自足的数据库，SQLite不需要单独的服务器进程或操作系统进行管理。它通过直接访问磁盘文件进行数据存储。无服务器：由于SQLite不需要运行服务器，因此简化了安装和管理过程，也降低了系统开销。零配置：SQLite无需任何配置文件即可运行，使得它在简单性和易用性方面具有很大优势。事务性：它支持事务（Transaction），即一系列操作要么完全成功，要么完全失败，这保证了数据的完整性。兼容性：SQLite支持大部分SQL92标准，这意味着许多基于标准的SQL查询和命令都可以在SQLite上无缝运行。跨平台：它可以在多种操作系统和平台上运行，包括Windows、Linux、Mac OS等。多语言接口：SQLite提供了多种编程语言的API，如C、C&#43;&#43;、Python、Java等，方便不同语言开发者使用。开源：SQLite是开源软件，可以免费用于任何目的，包括商业用途。 安装Nuget包 新建一个.netCore的控制台项目
我们在项目的Nuget包管理器控制台中安装Microsoft.EntityFrameworkCore.Sqlite
NuGet\Install-Package Microsoft.EntityFrameworkCore.Sqlite -Version 8.0.2 创建数据库 打开我们的数据库可视化管理工具Navicat，新建连接，选择SQLite
连接名随便取一个，类型选SQLite3，数据库文件选择放在我们刚刚创建的控制台项目下
创建一个Users表，待会测试用
数据库上下文 在项目中创建一个Users表的实体类和上下文类MyContext，如下图，刚刚创建的数据库文件与program类处于同一级
Users类 public class users { public int Id { get; set; } public string Name { get; set; } } 上下文 MyContext 数据库连接字符串：Data Source=data.db 定义一个名为 Users 的公共虚拟属性，它的类型是 DbSet&lt;users&gt;。DbSet&lt;TEntity&gt; 是 EF Core 中的一个泛型类，表示数据库中的一个表。在这里，它表示 users 表。
virtual 关键字允许 EF Core 在内部使用延迟加载来加载相关数据。
public class MyContext : DbContext { protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { optionsBuilder." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/91518add9b46e78e53ff2bcc24666597/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-26T22:35:59+08:00" />
<meta property="article:modified_time" content="2024-02-26T22:35:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">使用EFCore连接SQLite</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>简介</h2> 
<p>在使用EFCore连接SQLite之前我们先来了解一下SQLite</p> 
<p>SQLite是一个<strong>轻量级、自包含、无服务器、零配置的事务性SQL数据库引擎</strong>，它支持SQL92标准的大多数查询语言并兼容ACID事务。具体如下：</p> 
<ol><li><strong>轻量级</strong>：SQLite非常轻巧，它的库体积小，资源占用低，特别适合于嵌入式设备和移动应用，有时仅需几百KB的内存即可运行。</li><li><strong>自包含</strong>：作为一个自给自足的数据库，SQLite不需要单独的服务器进程或操作系统进行管理。它通过直接访问磁盘文件进行数据存储。</li><li><strong>无服务器</strong>：由于SQLite不需要运行服务器，因此简化了安装和管理过程，也降低了系统开销。</li><li><strong>零配置</strong>：SQLite无需任何配置文件即可运行，使得它在简单性和易用性方面具有很大优势。</li><li><strong>事务性</strong>：它支持事务（Transaction），即一系列操作要么完全成功，要么完全失败，这保证了数据的完整性。</li><li><strong>兼容性</strong>：SQLite支持大部分SQL92标准，这意味着许多基于标准的SQL查询和命令都可以在SQLite上无缝运行。</li><li><strong>跨平台</strong>：它可以在多种操作系统和平台上运行，包括Windows、Linux、Mac OS等。</li><li><strong>多语言接口</strong>：SQLite提供了多种编程语言的API，如C、C++、Python、Java等，方便不同语言开发者使用。</li><li><strong>开源</strong>：SQLite是开源软件，可以免费用于任何目的，包括商业用途。</li></ol> 
<h2>安装Nuget包</h2> 
<p>新建一个.netCore的控制台项目</p> 
<p>我们在项目的Nuget包管理器控制台中安装Microsoft.EntityFrameworkCore.Sqlite</p> 
<pre><code class="hljs">NuGet\Install-Package Microsoft.EntityFrameworkCore.Sqlite -Version 8.0.2</code></pre> 
<h2> 创建数据库</h2> 
<p>打开我们的数据库可视化管理工具Navicat，新建连接，选择SQLite</p> 
<p><img alt="" height="394" src="https://images2.imgbox.com/4d/ab/P9DWpNJj_o.png" width="556"></p> 
<p>连接名随便取一个，类型选SQLite3，数据库文件选择放在我们刚刚创建的控制台项目下</p> 
<p><img alt="" height="379" src="https://images2.imgbox.com/74/f0/qojIjxZ4_o.png" width="599"></p> 
<p>创建一个Users表，待会测试用</p> 
<p><img alt="" height="767" src="https://images2.imgbox.com/68/c7/hfvXEOsn_o.png" width="1200"></p> 
<h2>数据库上下文</h2> 
<p>在项目中创建一个Users表的实体类和上下文类MyContext，如下图，刚刚创建的数据库文件与program类处于同一级</p> 
<p><img alt="" height="315" src="https://images2.imgbox.com/9b/83/RngvsCVT_o.png" width="589"></p> 
<h3>Users类</h3> 
<pre><code class="language-cs">public class users
{
    public int Id { get; set; }
    public string Name { get; set; }
}</code></pre> 
<h3>上下文 MyContext</h3> 
<p>数据库连接字符串：Data Source=data.db </p> 
<p>定义一个名为 <code>Users</code> 的公共虚拟属性，它的类型是 <code>DbSet&lt;users&gt;</code>。<code>DbSet&lt;TEntity&gt;</code> 是 EF Core 中的一个泛型类，表示数据库中的一个表。在这里，它表示 <code>users</code> 表。</p> 
<p><code>virtual</code> 关键字允许 EF Core 在内部使用延迟加载来加载相关数据。</p> 
<pre><code class="language-cs">public class MyContext : DbContext
{
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlite("Data Source=data.db");
    }

    public virtual DbSet&lt;users&gt; Users { get; set; } = null!;
}</code></pre> 
<h2>Program</h2> 
<p>我们测试往数据库中添加一条数据，保存后再查询这条数据</p> 
<pre><code class="language-cs">class Program
{
    public static void Main(string[] args)
    {
        using (var db = new MyContext())
        {
            var user = new users() { Id = 1, Name = "张三" };
            db.Users.Add(user);
            db.SaveChanges();

            var users = db.Users.ToList();
        }
    }
}</code></pre> 
<p>可以看到，在下面代码中的Users中，已经查出刚刚添加的数据了</p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/ac/0b/3cUGvUoa_o.png" width="562"></p> 
<p>刷新一下我们的Navicate，发现还是空的</p> 
<p><img alt="" height="237" src="https://images2.imgbox.com/d7/79/Sp3fAcya_o.png" width="676"></p> 
<p>这是因为此时我们是调试状态，因此此时修改的数据库文件是Debug目录下的这个，并且每次调试这里的data.db都会被我们的程序目录下的data.db给替换掉</p> 
<p><img alt="" height="583" src="https://images2.imgbox.com/e3/4b/h4Q10BZi_o.png" width="953"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9fb2a336c50bcb600935e12479804f67/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android java基础_异常</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/70c48c2b41b950c3f5633b7eb5aa4287/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Vue】组件通信组件通信</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>