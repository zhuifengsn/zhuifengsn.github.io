<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c&#43;&#43;之继承 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c&#43;&#43;之继承" />
<meta property="og:description" content="目录
1、继承的概念
2、使用场景
3、继承定义
3.1、如何继承：
3.2、继承方式
3.3、继承父类成员访问方式的变化
4、基类和派生类对象的赋值转换
5、继承中的作用域
6、派生类的构造函数原则：
7、多继承与菱形继承
1、继承的概念 继承：继承就是在原有的类的基础之上进行扩展、增加一些功能。
可以这样理解：在古代的时候，皇帝驾崩了之后，就会有一个集运气于一身的幸运之子登上皇位。这位幸运之子继承了老皇帝留下来的江山，可以在这个江山已有的基础之上实施一些新政策、新措施、最终走上富国强兵……
看到这里应该不难理解继承是什么了吧，每一位新生的皇帝都是继承了上一任老皇帝的江山，颁布新政策。而类的继承，就是继承了已有的类，并可以在其基础之上进行扩展。
2、使用场景 在实际的应用中，要实现一个图书管理系统，有学生、老师、各色各样的人……，难道要一一实现每个角色的类吗？那不得烦死了。这时就可以使用继承的方式。学生、老师……都具有姓名，身份证，年龄，住址等共同信息，那就可以定义一个具有共同特征的person类。然后去定义一个学生、老师等等的类就可以来继承这个person类，并且可以在其基础之上进行扩展，增加独有的信息。
//具有共同特征的人类 class Person { protected: string name; int age; string id; string address; }; //学生类继承了Person类 class student:public Person { protected: //可以在原有的基础之上增加独有的信息：宿舍号 int dormitory_id; }; int main() { Person p; student st; return 0; } 3、继承定义 3.1、如何继承： Person是要被继承的类，叫父类，也叫基类。student继承了Person类，是子类，也叫派生类。 3.2、继承方式 3.3、继承父类成员访问方式的变化 总结：
1、父类的private成员，不管以什么方式被继承都是private、且不可见的：父类的私有成员被继承到了子类，子类不能访问到父类的private成员，因为语法的限制所以不能去访问，但确实有被继承下来。
2、父类的成员在基类的访问方式变化其实很好记。两个访问方式进行比较取小的那个（public &gt; protected &gt; private ），比如父类的public成员以public继承到子类，相等就以public访问方式。如果是以protected继承，public &gt; protected，protected比public小所以继承到子类的访问权限就会变成protected。如果是以private继承，public &gt; private，private比public小所以继承到子类的访问权限就会变成private。
3、父类的protected、private成员：两个的权限都是一样的，在类外不能访问，但在类里面可以访问。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/32f9ab755f8ae2cb468e34b1d7fcd9ab/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-06T12:22:42+08:00" />
<meta property="article:modified_time" content="2022-10-06T12:22:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c&#43;&#43;之继承</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#1%E3%80%81%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">1、继承的概念</a></p> 
<p id="2%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:0px;"><a href="#2%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">2、使用场景</a></p> 
<p id="%C2%A03%E3%80%81%E7%BB%A7%E6%89%BF%E5%AE%9A%E4%B9%89-toc" style="margin-left:0px;"><a href="#%C2%A03%E3%80%81%E7%BB%A7%E6%89%BF%E5%AE%9A%E4%B9%89" rel="nofollow"> 3、继承定义</a></p> 
<p id="%C2%A03.1%E3%80%81%E5%A6%82%E4%BD%95%E7%BB%A7%E6%89%BF%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A03.1%E3%80%81%E5%A6%82%E4%BD%95%E7%BB%A7%E6%89%BF%EF%BC%9A" rel="nofollow"> 3.1、如何继承：</a></p> 
<p id="3.2%E3%80%81%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#3.2%E3%80%81%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F" rel="nofollow">3.2、继承方式</a></p> 
<p id="%C2%A03.3%E3%80%81%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8F%98%E5%8C%96-toc" style="margin-left:40px;"><a href="#%C2%A03.3%E3%80%81%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8F%98%E5%8C%96" rel="nofollow"> 3.3、继承父类成员访问方式的变化</a></p> 
<p id="4%E3%80%81%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%B5%8B%E5%80%BC%E8%BD%AC%E6%8D%A2-toc" style="margin-left:0px;"><a href="#4%E3%80%81%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%B5%8B%E5%80%BC%E8%BD%AC%E6%8D%A2" rel="nofollow">4、基类和派生类对象的赋值转换</a></p> 
<p id="5%E3%80%81%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F-toc" style="margin-left:0px;"><a href="#5%E3%80%81%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F" rel="nofollow">5、继承中的作用域</a></p> 
<p id="6%E3%80%81%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8E%9F%E5%88%99%EF%BC%9A-toc" style="margin-left:0px;"><a href="#6%E3%80%81%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8E%9F%E5%88%99%EF%BC%9A" rel="nofollow">6、派生类的构造函数原则：</a></p> 
<p id="%C2%A07%E3%80%81%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF-toc" style="margin-left:0px;"><a href="#%C2%A07%E3%80%81%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF" rel="nofollow"> 7、多继承与菱形继承</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1%E3%80%81%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5">1、继承的概念</h2> 
<p>        继承：继承就是在原有的类的基础之上进行扩展、增加一些功能。</p> 
<p>        可以这样理解：在古代的时候，皇帝驾崩了之后，就会有一个集运气于一身的幸运之子登上皇位。这位幸运之子继承了老皇帝留下来的江山，可以在这个江山已有的基础之上实施一些新政策、新措施、最终走上富国强兵……</p> 
<p>        看到这里应该不难理解继承是什么了吧，每一位新生的皇帝都是继承了上一任老皇帝的江山，颁布新政策。而类的继承，就是继承了已有的类，并可以在其基础之上进行扩展。</p> 
<h2 id="2%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">2、使用场景</h2> 
<p>        在实际的应用中，要实现一个图书管理系统，有学生、老师、各色各样的人……，难道要一一实现每个角色的类吗？那不得烦死了。这时就可以使用继承的方式。学生、老师……都具有姓名，身份证，年龄，住址等共同信息，那就可以定义一个具有共同特征的person类。然后去定义一个学生、老师等等的类就可以来继承这个person类，并且可以在其基础之上进行扩展，增加独有的信息。</p> 
<pre><code class="language-cpp">//具有共同特征的人类
class Person
{
protected:
	string name;
	int age;
	string id;
	string address;
};

//学生类继承了Person类
class student:public Person
{
protected:
	//可以在原有的基础之上增加独有的信息：宿舍号
	int dormitory_id;
};

int main()
{
	Person p;
	student st;

	return 0;
}</code></pre> 
<p><img alt="" height="313" src="https://images2.imgbox.com/c2/c5/mDF5Uwnf_o.png" width="719"></p> 
<h2 id="%C2%A03%E3%80%81%E7%BB%A7%E6%89%BF%E5%AE%9A%E4%B9%89"> 3、继承定义</h2> 
<h3 id="%C2%A03.1%E3%80%81%E5%A6%82%E4%BD%95%E7%BB%A7%E6%89%BF%EF%BC%9A"> 3.1、如何继承：</h3> 
<p>        Person是要被继承的类，叫父类，也叫基类。student继承了Person类，是子类，也叫派生类。 </p> 
<p>        <img alt="" height="225" src="https://images2.imgbox.com/1d/62/j5A1R660_o.png" width="393"></p> 
<h3 id="3.2%E3%80%81%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F">3.2、继承方式</h3> 
<p class="img-center"><img alt="" height="236" src="https://images2.imgbox.com/8c/75/YJb7vdGH_o.png" width="429"></p> 
<h3 id="%C2%A03.3%E3%80%81%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8F%98%E5%8C%96"> 3.3、继承父类成员访问方式的变化</h3> 
<p><img alt="" height="312" src="https://images2.imgbox.com/64/ed/wfW0aBwc_o.png" width="877"></p> 
<p> 总结：</p> 
<p>        1、父类的private成员，不管以什么方式被继承都是private、且不可见的：父类的私有成员被继承到了子类，子类不能访问到父类的private成员，因为语法的限制所以不能去访问，<span style="color:#fe2c24;">但确实有被继承下来</span>。</p> 
<p>        2、父类的成员在基类的访问方式变化其实很好记。<span style="color:#fe2c24;">两个访问方式进行比较取小的那个（public &gt; protected &gt; private ）</span><span style="color:#0d0016;">，比如父类的public成员以public继承到子类，相等就以public访问方式。</span><span style="color:#fe2c24;">如果是以protected继承</span><span style="color:#0d0016;">，public &gt; protected，protected比public小所以继承到子类的访问权限就会变成protected。</span><span style="color:#fe2c24;">如果是以private继承</span><span style="color:#0d0016;">，public &gt; private，private比public小所以继承到子类的访问权限就会变成private。</span></p> 
<p><span style="color:#0d0016;">        3、</span><span style="color:#fe2c24;">父类的</span><span style="color:#0d0016;">protected、private成员：两个的权限都是一样的，在类外不能访问，但在类里面可以访问。</span></p> 
<p><span style="color:#0d0016;">            </span><span style="color:#fe2c24;">子类继承了父类的</span><span style="color:#0d0016;">protected、private成员：private成员不能访问，protected可以访问。</span></p> 
<p><span style="color:#0d0016;">        4、一般都是使用public继承，很少会用到protected、private继承。也不提倡使用protected、private继承。</span></p> 
<p><span style="color:#0d0016;">        5、继承方式如果没有写，</span><span style="color:#fe2c24;">class</span><span style="color:#0d0016;">的默认继承方式是private，</span><span style="color:#fe2c24;">struct</span><span style="color:#0d0016;">的默认继承方式是public。</span><span style="color:#fe2c24;">最好要显示的写出继承方式</span><span style="color:#0d0016;">。</span></p> 
<h2 id="4%E3%80%81%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%B5%8B%E5%80%BC%E8%BD%AC%E6%8D%A2">4、基类和派生类对象的赋值转换</h2> 
<p>        子类的对象可以赋值给父类的对象、指针、引用。称为切片或切割。</p> 
<p>        为什么叫切片呢？请看下图就不难理解了。<img alt="" height="316" src="https://images2.imgbox.com/35/95/d3SCuk1I_o.png" width="726"></p> 
<pre><code class="language-cpp">class Person
{
protected:
	string name;
	string _sex;
	int _age;
};

class student:public Person
{
protected:
	int _id;
};

int main()
{
	Person p;
	student st;
    
    //会把子类中的父类成员切割出来
	p = st;
	Person* ptr = &amp;st;
	Person&amp; rp = st;

	return 0;
}</code></pre> 
<p><img alt="" height="479" src="https://images2.imgbox.com/10/f5/0me71o1E_o.png" width="1064"><br>         </p> 
<p><span style="color:#fe2c24;"> 注：父类对象不能赋值给子类对象，只能子类的对象赋值给父类的对象、指针、引用</span><span style="color:#fe2c24;">。</span></p> 
<h2 id="5%E3%80%81%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span style="color:#0d0016;">5、继承中的作用域</span></h2> 
<p><span style="color:#0d0016;">1、在继承体系中，子类和父类都有独立的作用域。</span><br> 2.、子类和父类中如果都有同名成员的话，子类将会屏蔽对父类同名成员的直接访问，这种情况叫隐藏，也叫重定义。如果想要在子类中访问父类的同名成员，可以使用 作用域限定符<span style="color:#fe2c24;"> <strong>:: </strong></span>来显示访问。<br> 3. 需要注意的是：只要子类中有与父类的成员同名就会构成隐藏。<br> 4. 切记在继承体系里面最好不要定义同名的成员。</p> 
<pre><code class="language-cpp">class Person
{
protected:
	string _name="老王";
	int _age=28;
};

class student:public Person
{
public:
	void printf()
	{
		cout &lt;&lt; "姓名：" &lt;&lt; _name &lt;&lt; endl;
		cout &lt;&lt; "没有显示访问，直接访问的是子类中的年龄：" &lt;&lt; _age &lt;&lt; endl;	//因此这里访问到的是子类的_age成员，不会访问到父类的_age成员
		cout &lt;&lt; "有显示访问的是父类中的年龄：" &lt;&lt; Person::_age &lt;&lt; endl;
	}
protected:
	int _age=33;	//子类中存在于父类同名的成员
};

int main()
{
	student st;
	st.printf();

	return 0;
}</code></pre> 
<p><img alt="" height="506" src="https://images2.imgbox.com/2c/5d/DtJ55McQ_o.png" width="1200"></p> 
<h2 id="6%E3%80%81%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8E%9F%E5%88%99%EF%BC%9A">6、派生类的构造函数原则：</h2> 
<p><strong>子类的构造原则：先父后子</strong></p> 
<p>1、先调用父类的构造函数来初始化继承的父类成员。        </p> 
<p>2、接着调用自己子类的构造函数来初始化自己的成员。</p> 
<p><strong>子类的析构原则：先子后父</strong></p> 
<p>1、先调用自己子类的析构函数来析构</p> 
<p>2、接着再调用父类的析构函数来析构</p> 
<pre><code class="language-cpp">class Person
{
public:
	Person()
	{
		cout &lt;&lt; "Person" &lt;&lt; endl;
	}

	~Person()
	{
		cout &lt;&lt; "~Person" &lt;&lt; endl;
	}
};

class Student :public Person
{
public:
	Student()
	{
		cout &lt;&lt; "Student" &lt;&lt; endl;
	}

	~Student()
	{
		cout &lt;&lt; "~Student" &lt;&lt; endl;
	}
};

int main()
{
	//子类的构造先调用父类的构造函数接着再调用自己的构造函数：先父后子
	//子类的析构先调用自己的析构函数接着再调用父类的析构函数：先子后父
	Student st;

	return 0;
}</code></pre> 
<p><img alt="" height="221" src="https://images2.imgbox.com/91/a1/Dy9tOuZc_o.png" width="1064"></p> 
<p>         如想显示调用子类中的父类构造函数,请看下面的代码。</p> 
<pre><code class="language-cpp">class Person
{
public:
	Person(string name="")
	{
		_name = name;
		cout &lt;&lt; "Person" &lt;&lt; endl;
	}

	~Person()
	{
		cout &lt;&lt; "~Person" &lt;&lt; endl;
	}

protected:
	string _name;
};

class Student :public Person
{
public:
	Student(string name="")
		:Person(name)	//显示调用父类的构造函数
	{
		cout &lt;&lt; "Student" &lt;&lt; endl;
	}

	~Student()
	{
		cout &lt;&lt; "~Student" &lt;&lt; endl;
	}
};

int main()
{
	Student st;

	return 0;
}</code></pre> 
<p>        虽然可以显示的调用父类的构造函数，但是不能显示的调用子类中的父类析构函数，这样的话会出问题：为了保证析构的顺序是先子后父，但是如果在子类的析构函数中去显示调用了父类的析构函数，就会先调用父类的析构函数，接着又析构了自己。这一系列操作完后，编译器又会自动去调用父类的析构函数，就出现多次析构同一块内存的问题了。</p> 
<p>       <span style="color:#fe2c24;"> 因此不需要去显示调用子类中的父类析构函数，等子类析构完，编译器会自动去调用父类的析构函数。</span></p> 
<pre><code class="language-cpp">class Person
{
public:
	Person(string name)
	{
		_name = name;
		cout &lt;&lt; "Person" &lt;&lt; endl;
	}

	~Person()
	{
		cout &lt;&lt; "~Person" &lt;&lt; endl;
	}

protected:
	string _name;
};

class Student :public Person
{
public:
	Student(string name = "")
		:Person(name)	
	{
		cout &lt;&lt; "Student" &lt;&lt; endl;
	}

	~Student()
	{
		//显示的去调用子类中的父类析构函数，会出现问题
		Person::~Person();

		cout &lt;&lt; "~Student" &lt;&lt; endl;
	}
};

int main()
{
	Student st;

	return 0;
}</code></pre> 
<p><img alt="" height="397" src="https://images2.imgbox.com/c5/74/whNfXpVI_o.png" width="792"></p> 
<h2 id="%C2%A07%E3%80%81%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF"> 7、多继承与菱形继承</h2> 
<p>单继承：一个子类只有一个父类时称这个继承关系为单继承</p> 
<p><img alt="" height="454" src="https://images2.imgbox.com/f3/5c/P7UrcG0h_o.png" width="641"></p> 
<p> 多继承：一个子类有两个或以上父类时称这个继承关系为多继承</p> 
<p><img alt="" height="284" src="https://images2.imgbox.com/3e/80/g68KZDPF_o.png" width="646"></p> 
<p> 菱形继承：菱形继承是多继承的一种特殊情况</p> 
<p><img alt="" height="465" src="https://images2.imgbox.com/88/7b/Kw9n5T9e_o.png" width="884"></p> 
<p>         有了多继承就会有菱形继承，而菱形继承会造成数据冗余和二义性。</p> 
<p>        1、什么是二义性呢？</p> 
<p>              菱形继承后，类中就会有多份同样的成员，当想要去访问的时候就会出现二义性，不知道该访问的是哪个父类的成员。虽然可以显示的去调用哪个父类的成员来解决二义性。但是数据冗余依然无法解决。</p> 
<pre><code class="language-cpp">class Person
{
public:
	string _name;
	int _age;
};

class student:public Person
{};

class teacher:public Person
{};

class postman :public student, public teacher
{
public:
	
};

int main()
{
	postman pm;

	//pm._name = "老王";	//子类中存在多份相同的成员，访问_name的时候不知道要访问哪个父类的成员，因此会报错
	
	//需要指定访问哪个父类的成员，方可解决二义性
	pm.student::_name="小王";
	pm.teacher::_name="大王";

	return 0;
}</code></pre> 
<p>        2、数据冗余？</p> 
<p>        看到二义性是什么后，想必也已经知道数据冗余是什么了吧，就是子类中有多份相同的成员，从而造成数据冗余了。</p> 
<p>        那如何解决数据冗余呢？在腰部的位置加虚继承就可以解决了。</p> 
<p><img alt="" height="486" src="https://images2.imgbox.com/7e/da/SbGT7yUX_o.png" width="1136"></p> 
<pre><code class="language-cpp">class Person
{
public:
	string _name;
	int _age;
};

//腰部位置虚继承
class student: virtual public Person
{};
class teacher: virtual public Person
{};

class postman :public student, public teacher
{
public:
	
};

int main()
{
	postman pm;
	cout &lt;&lt; sizeof(pm) &lt;&lt; endl;

	return 0;
}</code></pre> 
<p><img alt="" height="508" src="https://images2.imgbox.com/c5/f6/y4nGnkjQ_o.png" width="849"></p> 
<p><img alt="" height="538" src="https://images2.imgbox.com/70/64/rSGDEC88_o.png" width="762"></p> 
<p> <span style="color:#fe2c24;">       因此不要设计出菱形继承。否则会很复杂。</span></p> 
<p></p> 
<p><br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b44e9ee9c19d9671b4bbe358d46902e7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">简述&amp;&amp;和&amp;的区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/365926455111b87af93a1443b4098dc1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SQL学习七、聚合函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>