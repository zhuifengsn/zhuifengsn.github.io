<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>专业课错题记录（王道的操作系统） - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="专业课错题记录（王道的操作系统）" />
<meta property="og:description" content="文章目录 第1章 计算机系统概述1.1 操作系统的基本概念1.2 操作系统的发展与分类1.3操作系统的运行环境 第2章 进程管理2.1进程与线程2.2 处理机调度2.2.1一些易错点2.2.2 错题记录 2.3 进程同步2.3.1反思和总结2.3.2错难题 2.4 死锁 第3章 内存管理3.1内存管理概念3.1.2覆盖与交换错难题记录 3.2 虚拟内存管理 第4章 文件管理4.1 文件系统基础4.2 文件系统实现4.3 磁盘组织与管理 第5章 输入输出管理5.1 IO管理概述5.2 IO核心子系统 第1章 计算机系统概述 1.1 操作系统的基本概念 3和4选的都是D。先来看3，源程序是一种代码，编译器解释后会形成距有一定功能的可执行文件；我们用水杯和水来类比一下文件和文件内容，水杯就是文件，水就是文件内容，而操作系统关心的是文件的逻辑结构、物理结构和水杯之间的组织方式，而不关心水杯里的是水还是饮料。编译器则是一种建立在操作系统之上的软件，操作系统管不了它
1.2 操作系统的发展与分类 1.
解析：选C。首先要明确一点，一个CPU是可以有多个核心的，这样就可以单CPU同时运行多道程序了，从而在单CPU机子上实现并行
1.3操作系统的运行环境 解析：DAA
第7题解析：地址映射中的重定位离不开硬件支持
解析：BCD
解析：BC
24题解析：外中断处理时，PC值由中断隐指令自动保存
第2章 进程管理 2.1进程与线程 解析：D。这个题相当于是在问运行态在什么情况下会转到其它状态。你一开始犯的错误是，以为进程只有在进入阻塞态或者就绪态时才会放弃CPU，而实际上只要脱离了运行态，就会放弃CPU，然后CPU就会被其它进程使用
解析：B。这个题的意思是，同一个线程被不同进程调用后还是不是同一个线程。线程的调用是这样的：系统只会在内存中建立一份DLL映像（这是多进程共享的），不同进程调用线程时，都会通过系统调用跳到这个DLL映像上运行
解析：C。处理器的效率=忙的时间/（忙的时间&#43;闲的时间）。就算就绪进程多了，CPU也会一直处于忙的状态，这与就绪进程的数量无关
解析：C。整个系统只有1个键盘，由人输入，速度很慢，完全可以用单独一个线程来处理整个键盘输入
解析：C。不选D是因为一个管道可以有多个缓冲区，这样就可以有多个读写进程了。管道的容量大小通常为内存上的一页，它的大小不受磁盘容量大小的影响
2.2 处理机调度 2.2.1一些易错点 1.计算周转时间
1）把作业到达时间和作业到达内存的时间弄混
2）计算平均周转时间时代入了错误的作业数，即比如只有4道作业，你却把总周转时间除了5
3）计算某一个作业的周转时间的时候，你容易看错某一个进程的结束时间、弄混两个进程的运行时间
4）时间片轮转算法中，你要注意的是作业A在完成了某个时间片后，如果有些作业还没有到达，比如作业B；那么作业A的下一次运行是不会排在作业B后面的
5）你容易把各作业的到达时间默认为0，解决办法是求周转时间时把到达时间和完成时间都列出来
6）看错作业的运行时间，比如0.4看成1.4，这也是01混淆的问题
2.2.2 错题记录 解析：B。作业也可以并发提交，比如mapdeduce作业提交。或者说，选最佳选项
解析：A。记住就行
解析：A。III错在中断向量本身就是中断服务例程的入口地址，因此中断向量地址便是中断服务例程入口地址的地址；IV，主要目的是快速进入中断处理程序并正确返回被中断的程序
解析：D。这道题你错在以为P2运行时，是不需要进行进程调度和切换的，这你犯了两个错误：
1）没看题，没注意到3个进程都在就绪队列里
2）不知道进程调度和切换就是对于就绪队列里的进程而言的
2.3 进程同步 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/88219086e0aa6f78939ea41c807522fb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-15T12:43:32+08:00" />
<meta property="article:modified_time" content="2020-09-15T12:43:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">专业课错题记录（王道的操作系统）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1__1" rel="nofollow">第1章 计算机系统概述</a></li><li><ul><li><a href="#11__2" rel="nofollow">1.1 操作系统的基本概念</a></li><li><a href="#12__7" rel="nofollow">1.2 操作系统的发展与分类</a></li><li><a href="#13_12" rel="nofollow">1.3操作系统的运行环境</a></li></ul> 
  </li><li><a href="#2__27" rel="nofollow">第2章 进程管理</a></li><li><ul><li><a href="#21_28" rel="nofollow">2.1进程与线程</a></li><li><a href="#22__49" rel="nofollow">2.2 处理机调度</a></li><li><ul><li><a href="#221_50" rel="nofollow">2.2.1一些易错点</a></li><li><a href="#222__59" rel="nofollow">2.2.2 错题记录</a></li></ul> 
   </li><li><a href="#23__80" rel="nofollow">2.3 进程同步</a></li><li><ul><li><a href="#231_81" rel="nofollow">2.3.1反思和总结</a></li><li><a href="#232_87" rel="nofollow">2.3.2错难题</a></li></ul> 
   </li><li><a href="#24__120" rel="nofollow">2.4 死锁</a></li></ul> 
  </li><li><a href="#3__138" rel="nofollow">第3章 内存管理</a></li><li><ul><li><a href="#31_141" rel="nofollow">3.1内存管理概念</a></li><li><ul><li><a href="#312_142" rel="nofollow">3.1.2覆盖与交换</a></li><li><a href="#_145" rel="nofollow">错难题记录</a></li></ul> 
   </li><li><a href="#32__206" rel="nofollow">3.2 虚拟内存管理</a></li></ul> 
  </li><li><a href="#4__254" rel="nofollow">第4章 文件管理</a></li><li><ul><li><a href="#41__255" rel="nofollow">4.1 文件系统基础</a></li><li><a href="#42__303" rel="nofollow">4.2 文件系统实现</a></li><li><a href="#43__335" rel="nofollow">4.3 磁盘组织与管理</a></li></ul> 
  </li><li><a href="#5__367" rel="nofollow">第5章 输入输出管理</a></li><li><ul><li><a href="#51_IO_368" rel="nofollow">5.1 IO管理概述</a></li><li><a href="#52_IO_398" rel="nofollow">5.2 IO核心子系统</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1__1"></a>第1章 计算机系统概述</h2> 
<h3><a id="11__2"></a>1.1 操作系统的基本概念</h3> 
<ol><li></ol> 
<p><img src="https://images2.imgbox.com/01/bc/GDmEZq27_o.png" alt="在这里插入图片描述"><br> 3和4选的都是D。先来看3，源程序是一种代码，编译器解释后会形成距有一定功能的可执行文件；我们用水杯和水来类比一下文件和文件内容，水杯就是文件，水就是文件内容，而操作系统关心的是文件的逻辑结构、物理结构和水杯之间的组织方式，而不关心水杯里的是水还是饮料。编译器则是一种建立在操作系统之上的软件，操作系统管不了它</p> 
<h3><a id="12__7"></a>1.2 操作系统的发展与分类</h3> 
<p>1.<img src="https://images2.imgbox.com/b8/bb/5l6xdfef_o.png" alt="在这里插入图片描述"><br> 解析：选C。首先要明确一点，一个CPU是可以有多个核心的，这样就可以单CPU同时运行多道程序了，从而在单CPU机子上实现并行</p> 
<h3><a id="13_12"></a>1.3操作系统的运行环境</h3> 
<ol><li></ol> 
<p><img src="https://images2.imgbox.com/63/8a/YjMtddeI_o.png" alt="在这里插入图片描述"><br> 解析：DAA<br> 第7题解析：地址映射中的重定位离不开硬件支持</p> 
<ol start="2"><li></ol> 
<p><img src="https://images2.imgbox.com/14/3b/WkMdNOhB_o.png" alt="在这里插入图片描述"><br> 解析：BCD</p> 
<ol start="3"><li></ol> 
<p><img src="https://images2.imgbox.com/b9/14/N2K5Ekxe_o.png" alt="在这里插入图片描述"><br> 解析：BC<br> 24题解析：外中断处理时，PC值由中断隐指令自动保存</p> 
<h2><a id="2__27"></a>第2章 进程管理</h2> 
<h3><a id="21_28"></a>2.1进程与线程</h3> 
<ol><li></ol> 
<p><img src="https://images2.imgbox.com/aa/86/Bl0Rhdxx_o.png" alt="在这里插入图片描述"><br> 解析：D。这个题相当于是在问运行态在什么情况下会转到其它状态。你一开始犯的错误是，以为进程只有在进入阻塞态或者就绪态时才会放弃CPU，而实际上只要脱离了运行态，就会放弃CPU，然后CPU就会被其它进程使用</p> 
<ol start="2"><li></ol> 
<p><img src="https://images2.imgbox.com/54/1b/iiaIkdGI_o.png" alt="在这里插入图片描述"><br> 解析：B。这个题的意思是，同一个线程被不同进程调用后还是不是同一个线程。线程的调用是这样的：系统只会在内存中建立一份DLL映像（这是多进程共享的），不同进程调用线程时，都会通过系统调用跳到这个DLL映像上运行</p> 
<ol start="3"><li></ol> 
<p><img src="https://images2.imgbox.com/af/de/ug61jvQq_o.png" alt="在这里插入图片描述"><br> 解析：C。处理器的效率=忙的时间/（忙的时间+闲的时间）。就算就绪进程多了，CPU也会一直处于忙的状态，这与就绪进程的数量无关</p> 
<ol start="4"><li></ol> 
<p><img src="https://images2.imgbox.com/60/c7/Pe9Jnnar_o.png" alt="在这里插入图片描述"><br> 解析：C。整个系统只有1个键盘，由人输入，速度很慢，完全可以用单独一个线程来处理整个键盘输入</p> 
<ol start="5"><li></ol> 
<p><img src="https://images2.imgbox.com/90/8e/bwh8xNIa_o.png" alt="在这里插入图片描述"><br> 解析：C。不选D是因为一个管道可以有多个缓冲区，这样就可以有多个读写进程了。管道的容量大小通常为内存上的一页，它的大小不受磁盘容量大小的影响</p> 
<h3><a id="22__49"></a>2.2 处理机调度</h3> 
<h4><a id="221_50"></a>2.2.1一些易错点</h4> 
<p>1.计算周转时间<br> 1）把作业到达时间和作业到达内存的时间弄混<br> 2）计算平均周转时间时代入了错误的作业数，即比如只有4道作业，你却把总周转时间除了5<br> 3）计算某一个作业的周转时间的时候，你容易看错某一个进程的结束时间、弄混两个进程的运行时间<br> 4）时间片轮转算法中，你要注意的是作业A在完成了某个时间片后，如果有些作业还没有到达，比如作业B；那么作业A的下一次运行是不会排在作业B后面的<br> 5）你容易把各作业的到达时间默认为0，解决办法是求周转时间时把到达时间和完成时间都列出来<br> 6）看错作业的运行时间，比如0.4看成1.4，这也是01混淆的问题</p> 
<h4><a id="222__59"></a>2.2.2 错题记录</h4> 
<ol><li></ol> 
<p><img src="https://images2.imgbox.com/c1/a7/d4N2p88s_o.png" alt="在这里插入图片描述"><br> 解析：B。作业也可以并发提交，比如mapdeduce作业提交。或者说，选最佳选项</p> 
<ol start="2"><li></ol> 
<p><img src="https://images2.imgbox.com/02/02/5LquLtVn_o.png" alt="在这里插入图片描述"><br> 解析：A。记住就行</p> 
<ol start="3"><li></ol> 
<p><img src="https://images2.imgbox.com/a3/d3/Zyb1DhW9_o.png" alt="在这里插入图片描述"><br> 解析：A。III错在中断向量本身就是中断服务例程的入口地址，因此中断向量地址便是中断服务例程入口地址的地址；IV，主要目的是快速进入中断处理程序并正确返回被中断的程序</p> 
<ol start="4"><li></ol> 
<p><img src="https://images2.imgbox.com/61/1d/W5a83WkT_o.png" alt="在这里插入图片描述"><br> 解析：D。这道题你错在以为P2运行时，是不需要进行进程调度和切换的，这你犯了两个错误：<br> 1）没看题，没注意到3个进程都在就绪队列里<br> 2）不知道进程调度和切换就是对于就绪队列里的进程而言的</p> 
<h3><a id="23__80"></a>2.3 进程同步</h3> 
<h4><a id="231_81"></a>2.3.1反思和总结</h4> 
<p>首先是指令序列的问题，需要注意的就是共享变量的初值；<br> 设计同步与互斥的题目里，主要就是需要看有哪些临界资源、同步关系。比较难的题目就是：<br> 1.那种几种进程需要使用同一种临界资源，而且要对同种类的进程进行计数，比如P106T13、P108T18.这种就是要把所有可能的进程（如不同爱好的观众、不同行驶方向的车辆）分类，每种类型的进程设置一个种类互斥锁+计数量，如果当前计数量为0，则等待临界资源的互斥锁；进程结束后（比如车辆开出小路、观众离开），如果离开后当前计数量为0，则释放临界资源的互斥锁<br> 2.等候区有若干位置，有若干顾客和1个服务窗口，比如P105T12、P107T17。这种题目也是设置一个信号量用于计算来了多少位顾客，顾客进程的主要任务就是修改count值、通过V操作向服务进程发信号，服务进程主要就是等待顾客进程发过来的信号（P操作）以及互斥修改count值<br> 3.最后就是，计数量都是要互斥访问的</p> 
<h4><a id="232_87"></a>2.3.2错难题</h4> 
<ol><li></ol> 
<p><img src="https://images2.imgbox.com/b8/5e/ZkWnbPEz_o.png" alt="在这里插入图片描述"><br> 解析：D。可重入编码指的是允许多个进程同时访问的代码。为了使各个进程执行的代码完全一样，不允许任何进程修改这段代码。而共享代码段正是可以被多个进程使用的，所以必须用可重入编码，否则无法实现共享的功能</p> 
<ol start="2"><li></ol> 
<p><img src="https://images2.imgbox.com/c1/0c/5MSNlwrl_o.png" alt="在这里插入图片描述"><br> 解析：C。临界区和临界资源不是同一个概念，临界区是代码，临界资源是资源</p> 
<ol start="3"><li></ol> 
<p><img src="https://images2.imgbox.com/e9/67/NP1W72Fa_o.png" alt="在这里插入图片描述"><br> 解析：C。信号量机制中，V操作一定会导致信号量的值加一；而管程中的signal操作是针对某条件变量而言的，若不存在因该条件变量而阻塞的进程，则signal操作不会产生任何影响</p> 
<ol start="4"><li></ol> 
<p><img src="https://images2.imgbox.com/65/b2/9QF6UpAJ_o.png" alt="在这里插入图片描述"><br> 解析：B。选项A错在唤醒的不是阻塞态，唤醒的是就绪态</p> 
<ol start="5"><li></ol> 
<p><img src="https://images2.imgbox.com/3b/4a/VmhBfpnB_o.png" alt="在这里插入图片描述"><br> 这个题，和普通的信号量题目不一样的地方是如果没有位置了，进程就离开，即结束运行，其它大部分题目都是要用一个<code>while(true)</code>，然后卡在等待资源的那个P操作那里，所以顾客进程的行为为：<br> <img src="https://images2.imgbox.com/9c/18/yzoWxqqY_o.png" alt="在这里插入图片描述"><br> 完整答案：<br> <img src="https://images2.imgbox.com/70/09/knnlS0v1_o.png" alt="在这里插入图片描述"></p> 
<ol start="6"><li></ol> 
<p><img src="https://images2.imgbox.com/22/5f/quQnM68N_o.png" alt="在这里插入图片描述"><br> 解析：选B。你做错的原因是，没看到初值是0，惯性地以为初值是1</p> 
<ol start="7"><li></ol> 
<p><img src="https://images2.imgbox.com/5c/0d/VUB9artg_o.png" alt="在这里插入图片描述"><br> 解析：选A。这里问的是互斥信号量的初值。所谓互斥使用，是指在同一时间段内只允许一个进程使用该资源，所以互斥信号量的初值都为1.你一开始选的是C，应该是把互斥信号量和整型信号量的概念混淆了</p> 
<h3><a id="24__120"></a>2.4 死锁</h3> 
<ol><li></ol> 
<p><img src="https://images2.imgbox.com/c9/4c/RfWreiCj_o.png" alt="在这里插入图片描述"><br> 解析：BBC。一个类型的题目。用第7题来分析一下这类题目：考虑这种情况：3个进程都持有3个资源，如果此时再往系统中添加一个资源，那么此时系统就一共有10个资源，而且必定有一个进程会获得4个资源，可以正常运行，然后释放资源，接着就是剩下的进程接着运行，所以不发生死锁的最少资源数为10。<br> 总之，假设有m个资源，n个进程，每个进程需要k个资源才能正常运行，那么如果满足m≥n×(k-1)+1，此时可以保证至少一个进程可以得到所需的全部资源并执行完毕</p> 
<ol start="2"><li></ol> 
<p><img src="https://images2.imgbox.com/1a/21/oaJBXypi_o.png" alt="在这里插入图片描述"><br> 解析：B。你本来选的是A，因为你以为两个进程的运行速度是一样的，即P1运行完一次后，就是P2来运行了；实际上不同进程的运行速度是不一样的，P1可能会在运行完一次后，紧接着不给P2机会，接着运行，一直运行，这样P2就会一直卡在P(y)那里，导致饥饿</p> 
<ol start="3"><li></ol> 
<p><img src="https://images2.imgbox.com/63/60/WOS0YdCZ_o.png" alt="在这里插入图片描述"><br> 解析：C。这里有两个点你需要注意以下，一是程序能不能正确运行，应该指的就是结果唯不唯一；而所谓的结果，应该指的是x,y,z,u,t这5个变量的最终值的组合有多少种，比如这道题中z,y,x,u,t的值的组合有3种，那么可能的结果就是3种</p> 
<ol start="4"><li></ol> 
<p><img src="https://images2.imgbox.com/ee/50/x3a6yhPX_o.png" alt="在这里插入图片描述"><br> 解析：B。你一开始选了I和III。先来说说I为什么错：死锁避免会限制分配顺序，但是不会限制申请资源的顺序，限制申请顺序的是死锁预防中的顺序资源分配法</p> 
<h2><a id="3__138"></a>第3章 内存管理</h2> 
<p><img src="https://images2.imgbox.com/ca/9b/tj0zseif_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="31_141"></a>3.1内存管理概念</h3> 
<h4><a id="312_142"></a>3.1.2覆盖与交换</h4> 
<p>思维导图<br> <img src="https://images2.imgbox.com/32/48/lPNl0m1L_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_145"></a>错难题记录</h4> 
<ol><li></ol> 
<p><img src="https://images2.imgbox.com/c8/14/jxt48Doi_o.png" alt="在这里插入图片描述"><br> 解析：C。你审错题了，题目问的是形成逻辑地址的阶段，而不是逻辑地址到物理地址转换的阶段，如果问的是逻辑地址到物理地址的转换，才是选D。结局办法是圈出选择题的问题，比如这道题就应该圈出“形成逻辑地址的阶段是”</p> 
<ol start="2"><li></ol> 
<p><img src="https://images2.imgbox.com/49/9e/d0oKAQf2_o.png" alt="在这里插入图片描述"><br> 解析：D。C选项：编址空间的大小主要取决于硬件的访存能力，一般由地址总线宽度决定。虚拟内存的管理需要相关的硬件和软件支持，有请求分页页表机制、缺页中断机构、地址变换机构等</p> 
<ol start="3"><li></ol> 
<p><img src="https://images2.imgbox.com/c5/8e/MCoRFvVI_o.png" alt="在这里插入图片描述"><br> 解析：B。进程正在进行IO操作时不能换出主存，否则其IO数据区将被新换入的进程占用。而处于临界区的进程，如果是时间片用完了，那么也必定会进入就绪态，然后就可以被换出了</p> 
<ol start="4"><li></ol> 
<p><img src="https://images2.imgbox.com/7f/ab/Ge7n0lAy_o.png" alt="在这里插入图片描述"><br> 解析：A。虽然这俩的确是用来扩充主存的，但是只是将暂时不用的部分换出主存，节省空间，从而在逻辑上扩充主存。要从物理上扩充，只能是像计组说的那样，用字扩展或者位扩展法</p> 
<ol start="5"><li></ol> 
<p><img src="https://images2.imgbox.com/0d/b7/jap9wfbO_o.png" alt="在这里插入图片描述"><br> 解析：这道题有两个点要注意一下：用户编程空间和主存空间的区别、物理块号是什么、“用户编程空间为32个页面”和“用户程序为10页长”中这两个概念中的页长有什么关系、下面来逐个解释：<br> 1）用户编程空间和主存空间：就是虚拟地址空间，这里是32K，说明逻辑地址是15位；主存空间，就是内存空间，没说外存时它就是全部的物理地址空间。综上，逻辑地址的位数由用户编址空间决定；实际地址的位数由主存的大小决定<br> 2）“用户编程空间为32个页面”和“用户程序为10页长”中这两个概念中的页长有什么关系：用户编程空间有32个页面，指的是用户总共可用的空间为32个页；用户程序为10页长，意思是这个用户写了个程序，这个程序占了32个页空间中的10个页空间，所以这时候那个地址<code>3AC5H</code>的逻辑页号为14&gt;10，会导致越界<br> 3）物理块号：块号、页号、页框号、物理块号都是页式存储的概念，段式存储中的概念只有“段”这个名词</p> 
<ol start="6"><li></ol> 
<p><img src="https://images2.imgbox.com/de/ff/n9SeV2k3_o.png" alt="在这里插入图片描述"><br> 解析：D。tmd.动态重定位是在程序执行的时候再决定要把哪些段装入到内存中，它虽然是装入的一种方式，但并不是在装入阶段发生的，或者说，是在程序执行时才装入的</p> 
<ol start="7"><li></ol> 
<p><img src="https://images2.imgbox.com/25/a9/aYHJjl6o_o.png" alt="在这里插入图片描述"><br> 解析：A。拼接技术指的就是把相邻的空闲分区拼在一起</p> 
<ol start="8"><li></ol> 
<p><img src="https://images2.imgbox.com/83/bc/FPjqfoqs_o.png" alt="在这里插入图片描述"><br> 解析：B。你会选A，是因为把它和连续存储分配里的动态存储分配混淆了。存储分配有两大类，两大类下面又一共分为6种分配方式：<br> <img src="https://images2.imgbox.com/0f/a4/3poWAcoN_o.png" alt="在这里插入图片描述"></p> 
<ol start="9"><li></ol> 
<p><img src="https://images2.imgbox.com/25/ef/n2lSYysW_o.png" alt="在这里插入图片描述"><br> 解析：C。页表和段表都存储在内存中，系统提供给用户的物理地址空间为总空间大小减去页表或段表的长度。由于页表和段表的长度不能确定，所以提供给用户的物理地址空间大小也不能确定</p> 
<ol start="10"><li></ol> 
<p><img src="https://images2.imgbox.com/49/82/ikX2PwKq_o.png" alt="在这里插入图片描述"><br> 解析：A。首先，寄存器是很贵的，为每道程序设置一个寄存器成本太高；而且程序的道数无法确定，因此为每个程序设置一个重定位寄存器不现实；不过最关键的还是CPU同一时刻只能执行一道程序中的一道指令。重定位寄存器的作用是：在系统中增设一个重定位寄存器，用他来存放程序/数据在内存中的始址，在执行程序或访问数据时，真正访问的内存地址由相对地址与重定位寄存器中的地址相加而成。如果需要并发运行多道程序，那么就保存当前重定位寄存器的值，然后给它赋新的值就可以了。下面是重定位寄存器的作用的详细说明<br> <img src="https://images2.imgbox.com/8c/78/MUDC1MhZ_o.png" alt="在这里插入图片描述"><br> 11.<br> <img src="https://images2.imgbox.com/28/97/rbm87DBN_o.png" alt="在这里插入图片描述"><br> 解析：A。分页操作更方便。分段由于段的大小不一致，所以操作起来会比较麻烦</p> 
<ol start="12"><li></ol> 
<p><img src="https://images2.imgbox.com/45/de/NCO711wn_o.png" alt="在这里插入图片描述"><br> 解析：B。这里问的是主存访问，不是主存的分配</p> 
<ol start="13"><li></ol> 
<p><img src="https://images2.imgbox.com/ea/0a/Bl7uXg59_o.png" alt="在这里插入图片描述"><br> 解析：B。你一开始选的是A，错因是受了王道书的影响，王道书上原话是“指向被共享的段的同一个物理<font color="red">副本</font>”，我已经根据这个答案把书给改了；为什么没选B呢？主要是你不清楚共享段表的结构，以为共享段表表项和普通的段表表项意义，只有一个段号；刚刚查了下也没找到满意的答案，我估计是可以同时标示两个进程各自的段号；为什么段号会不一样呢？还得从分段的原因出发：段是根据程序的逻辑功能来分的，而不同程序中，同一个段可能在不同位置被使用，所以段号自然就不同了</p> 
<h3><a id="32__206"></a>3.2 虚拟内存管理</h3> 
<ol><li></ol> 
<p><img src="https://images2.imgbox.com/82/37/uKOXfNzF_o.png" alt="在这里插入图片描述"><br> 解析：401.22μs。主要是看缺页时的耗时。首先你要知道，页表保存的是逻辑地址到主存中的映射关系，那么如果页表中找不到某个逻辑地址的映射，那么就可以认为逻辑地址访问了个不在主存中的地址，所以就会产生缺页中断；也就是说，产生缺页中断前，只访问了一次内存（访问页表），会不会产生缺页中断是在访问完页表后就知道了的，所以如果某一次访存产生了缺页中断，那么总的过程如下：<br> 访问页表（<font color="red">1μs</font>）-&gt;产生缺页中断，开始从磁盘总调取页面（<font color="red">20ms</font>）-&gt;缺页中断完成后，回到缺页中断发生前的状态，将程序指令器重新指向引起缺页中断的指令，重新执行-&gt;访问页表（<font color="red">1μs</font>）-&gt;根据主存地址访问相应地址（<font color="red">1μs</font>）<br> 所以总共是20ms+3μs</p> 
<p>2.⭐⭐（星星的个数表示自己错了多少次）<br> <img src="https://images2.imgbox.com/85/54/bExYtLd5_o.png" alt="在这里插入图片描述"><br> 解析：主要是看1565H的耗时。这里题目说了，处理缺页的时间包括更新TLB和页表，说明，处理缺页后会更新TLB，那么中断返回后就只需要访问快表，不需要访问页表了，所以1565H的耗时为：访问TLB-&gt;访问页表-&gt;中断处理-&gt;访问TLB-&gt;访问内存，一共是(10<sup>8</sup>+220)ns<br> 二刷的时候，又犯了个错误，就是缺页中断处理完成后，重新执行这条指令，你没落下访问快表的时间，但是落了获取地址后访问内存的那100ns</p> 
<ol start="3"><li></ol> 
<p><img src="https://images2.imgbox.com/d1/86/81nkCX10_o.png" alt="在这里插入图片描述"><br> 解析：B。现在好像有点懂了，估计它的意思就是在同一个访问序列中，扩展页面尺寸前后，缺页次数是增多了还是减少了。有了这个前提后，觉得答案就很自然了</p> 
<ol start="4"><li></ol> 
<p><img src="https://images2.imgbox.com/a3/06/9oVdULEi_o.png" alt="在这里插入图片描述"><br> 解析：B。问的是最大容量，那么就应该是理论容量</p> 
<ol start="5"><li></ol> 
<p><img src="https://images2.imgbox.com/53/b9/tUALtYKm_o.png" alt="在这里插入图片描述"><br> 解析：B。虽然覆盖、交换的实际含义和虚拟存储有区别，但思想还是一样的，所以技术上的实现也差不多</p> 
<ol start="6"><li></ol> 
<p><img src="https://images2.imgbox.com/46/c5/f7cgldIW_o.png" alt="在这里插入图片描述"><br> 解析：D。最大容量由计算机的地址结构决定</p> 
<ol start="7"><li></ol> 
<p><img src="https://images2.imgbox.com/6c/46/JlK0V07n_o.png" alt="在这里插入图片描述"></p> 
<p>解析：D。需要记录时间，并按时间排序；而A为什么不选呢？因为很多调度算法都需要用到硬件支持，而LRU也只是一个栈就行，算不上多特殊<br> <img src="https://images2.imgbox.com/f3/ba/ny43vRYy_o.png" alt="在这里插入图片描述"><br> 8.<br> <img src="https://images2.imgbox.com/05/5c/mSmFDnLi_o.png" alt="在这里插入图片描述"><br> 主要是看FIFO和NRU：<br> FIFO：先把0号虚拟页给换出去。主要是对装入时间的早晚衡量错了，装入时间越小，说明越早装入</p> 
<ol start="9"><li></ol> 
<p><img src="https://images2.imgbox.com/4b/71/Ln9KaWBv_o.png" alt="在这里插入图片描述"><br> 解析：5。你本来写的是缺页中断。这个题提了你的一个不清晰的点：在虚拟页式存储系统中，程序分块后，这个块的块号在逻辑地址中叫<font color="red">页号</font>，在物理地址中叫<font color="red">页框号</font></p> 
<ol start="10"><li></ol> 
<p><img src="https://images2.imgbox.com/43/2f/OU7T2uCK_o.png" alt="在这里插入图片描述"><br> 1）4KB和2<sup>20</sup>页。这里直接问地址空间为多少页，你理解成了存放这2<sup>32</sup>个32位地址需要多少页的空间。这里就体现了你对页的理解不深刻：页是对程序进行分块，每一页中会存放一段连续地址中的内容，地址号是不需要存储的，地址是控制器产生相关的电信号，然后相应的地址线导通，接着从相应的存储单元中读出它存储的信息（信息由存储元件存储，存储元件可以是栅极电容或双稳态触发器）<br> 3）访问了同一个二级页表。这个题你又犯了个低级错误：20位二进制要切分成10+10位二进制时，你切成了11+9。emmm，这个我真不知道怎么解决了，只能说切分的时候小心一点</p> 
<h2><a id="4__254"></a>第4章 文件管理</h2> 
<h3><a id="41__255"></a>4.1 文件系统基础</h3> 
<ol><li></ol> 
<p><img src="https://images2.imgbox.com/fb/49/vj0WvHWa_o.png" alt="在这里插入图片描述"><br> 解析：A。你选的是C，这是打开文件之前的操作。打开文件操作是将该文件的FCB存入内存的活跃文件目录表</p> 
<ol start="2"><li></ol> 
<p><img src="https://images2.imgbox.com/2f/a3/QO3nGeyt_o.png" alt="在这里插入图片描述"><br> 解析：A。你选的是D。首先需要明确一点，对文件操作前，需要用系统调用open，然后open会返回一共指向该文件在打开文件表中对应的一个条目的指针。后续的各种操作都是通过该指针来完成的，所以read操作同样不需要文件名，open和read的描述如下：<br> <img src="https://images2.imgbox.com/76/66/LvNPNhJi_o.png" alt="在这里插入图片描述"><br> 3.<br> <img src="https://images2.imgbox.com/80/12/P4244SLg_o.png" alt="在这里插入图片描述"><br> 解析：B。<br> <img src="https://images2.imgbox.com/fd/eb/jebCBKob_o.png" alt="在这里插入图片描述"><br> 4.<br> <img src="https://images2.imgbox.com/c4/5d/usS8c6sd_o.png" alt="在这里插入图片描述"><br> 解析：A。这个题你本来选的是B，优先级和能不能访问是两回事，优先级只是你可以早点获得机会，但是你可能没有权限使用，就跟借书一样，你可能来的早，但是却可能没有这本书的借阅权限；文件的属性也包括FCB中对文件访问的控制信息，而不是你想象中的大小、位置、修改时间之类的，文件的属性通常包含如下：<br> <img src="https://images2.imgbox.com/64/eb/O4bmj06N_o.png" alt="在这里插入图片描述"></p> 
<ol start="5"><li></ol> 
<p><img src="https://images2.imgbox.com/c8/6b/2kIS9eOo_o.png" alt="在这里插入图片描述"><br> 解析：D。在灵活性和安全性方面：访问控制机制由于级别和保护力度比较小，而且通过chmod命令就可以修改权限，所以灵活性更高。在是不是由系统实现方面：如果加密保护由系统实现，那么加密方法将无法扩展；如果访问控制不是由系统实现，那么系统本身的安全性就无法保证</p> 
<ol start="6"><li></ol> 
<p><img src="https://images2.imgbox.com/32/cb/xK9dFqwa_o.png" alt="在这里插入图片描述"><br> 解析：A。我是通过那个“进入系统”来判断的。下面是4种级别的安全管理及常用措施：<br> <strong>系统级</strong>：不允许未授权的用户进入系统，从而防止他人非法使用系统中各类资源。系统级管理的主要措施有注册与登录<br> <strong>用户级</strong>：通过对所有用户分类和对指定用户分配访问权。不同的用户对不同文件设置不同的存取权限。例如，Unix系统将用户分为文件主、组用户和其它用户<br> <strong>目录级</strong>：为了保护系统中各种目录而设计的，与用户权限无关。为了保护目录的安全规定只有系统内核才具有写目录的权力<br> <strong>文件级</strong>：通过管理员或者文件主对文件的访问控制信息的修改，来控制用户对文件的访问</p> 
<p>7.要形成一个共识，所谓的删除某某文件，其实删除的是指向这个物理内存内容的指针<br> <img src="https://images2.imgbox.com/c4/c4/RF8Xb7cO_o.png" alt="在这里插入图片描述"><br> 解析：B。这里讲一下硬链接和软连接的计数值：<br> 删除文件F1：其实是F1这个进程/用户从自己的目录中删除相应的目录项，实际上那一块物理空间不一定真的被清空了，直到没有进程链接到这块物理空间，才会真正释放这块物理空间<br> 硬链接的计数值：这道题中，F3和F1链接到同一块物理空间，所以计数++，即count=2；删除F1后，这块物理空间的引用减少了一，所以count–，即count=1<br> 软连接的计数值：软链接其实是建立了一个新的特殊文件，在这里这个文件是F2；F2和F1的联系就是F2存的是F1的路径，需要访问时操作系统通过F2的内容去寻找F1，并没有链接到F1指向的那块物理空间，所以count并不会增加；删除F1后，和F2这个文件本身没有任何关系，所以F2的count值并不会变；只有在需要通过F2访问F1时，发现F1没了，会报错</p> 
<ol start="8"><li></ol> 
<p><img src="https://images2.imgbox.com/75/8d/Iy7fYfZj_o.png" alt="在这里插入图片描述"><br> 解析：D。这个题你本来选的A，是以为共有5×4=20种组合，然后需要5位二进制来表示这20种组合。其实不是这样子的，如果是用5位二进制来表示20种组合，那么每种组合就都是互斥的，比如一类用户只能拥有一类权限，这明显不正确。正确的思路应该是这样子：<br> <img src="https://images2.imgbox.com/50/67/16V1jPfB_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="42__303"></a>4.2 文件系统实现</h3> 
<ol><li></ol> 
<p><img src="https://images2.imgbox.com/26/30/8KCCEP6U_o.png" alt="在这里插入图片描述"><br> 解析：A。这里你把索引结点和索引结点内的地址项搞混了，索引结点就是存放文件其它描述信息的数据结构，而文件块内容的地址项也是存在索引结点里的</p> 
<ol start="2"><li></ol> 
<p><img src="https://images2.imgbox.com/66/e0/QDmAePR6_o.png" alt="在这里插入图片描述"><br> 2）解析：连续文件支持直接访问，所以经过5次IO查找找到文件A后，直接通过计算便可以获得A的第487条记录的地址</p> 
<ol start="3"><li></ol> 
<p><img src="https://images2.imgbox.com/14/64/fBuAE2S1_o.png" alt="在这里插入图片描述"><br> 2）解析：像这种看起来好像有点多余的题目，正确的做法是两种方案都算一下，然后取较小值。这里有两种方案：<br> <strong>方案一</strong>：用簇来存放索引结点，然后一个索引结点代表一个文件，所以这种方案一共可以存2<sup>20</sup>*4KB/64B=64M个索引结点，可以存64个文件；<br> <strong>方案二</strong>：用512M个簇直接存储文件，5600B的文件需要两个簇，故这种方案可以存512M/2=256M个文件<br> 两种方案取较小值，所以是64M个图像文件<br> 另外，这里说一下文件存储的方式。磁盘是按块来管理的，所以文件也是以块为单位来存储的，在这道题中就是以簇为单位存放的。所以求一个容量为Y的文件系统能存多少个大小为X的文件，应该统一把Y和X转成包含多少个块（簇）</p> 
<ol start="4"><li></ol> 
<p><img src="https://images2.imgbox.com/e2/d4/ZiUPv2I4_o.png" alt="在这里插入图片描述"><br> 1）解析：2×29+1=59。访问磁盘的话，就要看读了多少次磁盘、写了多少次磁盘，而不能仅仅是访问了同一块磁盘，就都统一算是1次访问。<br> 2）解析：主要是那个文件最大长度。链接指针存的就是地址，4B的地址，说明地址有32位，所以最大文件长度为2<sup>32</sup>KB=4TB，像这种把地址位数隐藏在簇号的长度、指针的长度里的还有下面这道题：<br> <img src="https://images2.imgbox.com/ab/00/PfZI1bqp_o.png" alt="在这里插入图片描述"><br> 又是统考题，命题组老爱考这玩意了。这道题的两个答案分别是128KB和256MB</p> 
<ol start="6"><li></ol> 
<p><img src="https://images2.imgbox.com/55/e2/mrJD8YFN_o.png" alt="在这里插入图片描述"><br> 解析：D。分析读和写的次数各是多少，加起来就是启动磁盘的次数</p> 
<h3><a id="43__335"></a>4.3 磁盘组织与管理</h3> 
<ol><li></ol> 
<p><img src="https://images2.imgbox.com/55/a5/DfohRIxS_o.png" alt="在这里插入图片描述"><br> 解析：可以给你几个中间结论：<br> 1）一共需要跨越170个磁道<br> 2）不用考虑磁头启动时间<br> 3）但是传输时间和延迟时间都是要考虑的<br> 传输时间：题目中说了，请求中在每个磁道中需要读取1个随机分布的扇区，即每次请求的传输时间只需要考虑扫过1个扇区的用时，单次传输的时间为1/r×1/100=0.1ms<br> 延迟时间：6000转/分=100转/s=0.1转/ms，最后化成ms的时候你又写成了10转/ms，所以导致延迟时间计算出错。正确的单次请求延迟时间为1/2×1/0.1=5ms<br> 最后答案是190.4ms</p> 
<ol start="2"><li></ol> 
<p><img src="https://images2.imgbox.com/1d/3f/9CU9M6XT_o.png" alt="在这里插入图片描述"><br> 解析：<br> 1）计算数据传输率时，传输的数据量用的K，M，G和速率中的k，M，G是不一致的<br> 2）这道题中的传输时间是题干中的“<strong>在数据从控制器传送至内存的这段时间内，从磁头下通过的扇区数为2</strong>”<br> 3）然后就是，你审题审错了，问的是<strong>读出一个磁道上所有扇区的用时</strong>，你就没看完题目，就直接用倒数第二行的那个“扇区数为2”来计算了，以为求的是读出两个扇区的耗时<br> <img src="https://images2.imgbox.com/4d/b9/xD1kFdGd_o.png" alt="在这里插入图片描述"><br> 3.<br> <img src="https://images2.imgbox.com/43/a1/sW9YluE2_o.png" alt="在这里插入图片描述"><br> 解析：<br> 如果系统中总是持续出现某个磁道的访问请求时，均持续满足最短寻道时间优先、扫描算法和循环扫描算法的访问条件时（比如对于SCAN而言，起始方向为从左到右，后面一直会有满足这个方向的访问请求，甚至就是一直要求访问同一个磁道，那么SCAN和C-SCAN就会一直在这个磁道上，而对于其它先于这个请求到达的请求，则不予理睬），会一直服务该访问请求，而先来先服务按照请求次序进行调度，即使后面一直有访问同一个磁道号的请求，FCFS也会严格按照时间顺序来移动磁头（不过也只能说是相对公平）</p> 
<p><br><br></p> 
<h2><a id="5__367"></a>第5章 输入输出管理</h2> 
<h3><a id="51_IO_368"></a>5.1 IO管理概述</h3> 
<ol><li></ol> 
<p><img src="https://images2.imgbox.com/4d/eb/zz1bzuSE_o.png" alt="在这里插入图片描述"><br> 解析：共享设备指的是一个时间段内允许多个进程同时访问的设备，即<strong>并发访问</strong>，所以C错。正确答案是B，共享设备一定得是可寻址和可随机访问的，但是我不知道为什么，所以现在记住就行</p> 
<ol start="2"><li></ol> 
<p><img src="https://images2.imgbox.com/6b/b6/ag8E3ZzO_o.png" alt="在这里插入图片描述"><br> 解析：不会做，记住答案就行：字节多路通道用作连接大量的低速或中速IO设备<br> <img src="https://images2.imgbox.com/93/a4/uHgkbSGV_o.png" alt="在这里插入图片描述"><br> 3.<br> <img src="https://images2.imgbox.com/da/ff/OHrXWX2N_o.png" alt="在这里插入图片描述"><br> 解析：也不会做，记住就行：计算机系统为每台设备确定一个编号以便区分和识别设备，这个确定的编号称为设备的绝对号</p> 
<p>4.统考题还真的不按套路出牌啊<br> <img src="https://images2.imgbox.com/a8/a6/ct1UINnv_o.png" alt="在这里插入图片描述"><br> 解析：键盘是典型的通过中断IO方式工作的外设，当用户输入信息时，计算机响应中断并通过中断处理程序获得输入信息，所以选B。<br> 通过这道题，还可以看出键盘设备的考点就是要知道，它和中断密不可分</p> 
<ol start="5"><li></ol> 
<p><img src="https://images2.imgbox.com/8b/85/aSVXRtSv_o.png" alt="在这里插入图片描述"></p> 
<p>解析：每一类设备只需要一个设备驱动程序。绘图机和打印机属于两种不同类型的设备，系统只要按设备类型配置设备驱动程序即可。所以选C。</p> 
<ol start="6"><li></ol> 
<p><img src="https://images2.imgbox.com/c5/3d/4STrXZ2u_o.png" alt="在这里插入图片描述"><br> 解析：不同磁盘的柱面、磁头、扇区划分都是不一样的，因此应该通过商家提供的硬件驱动程序完成计算，所以选C</p> 
<h3><a id="52_IO_398"></a>5.2 IO核心子系统</h3> 
<ol><li></ol> 
<p><img src="https://images2.imgbox.com/01/2d/6RxmoCqx_o.png" alt="在这里插入图片描述"><br> 驱动程序和硬件设备都是面向硬件的，具体区别是前者是硬件的主宰，负责将从设备独立性软件传过来的命令转成具体的要求，然后发送给设备控制器，控制IO设备工作；后者仅仅是能够控制进行IO操作，控制的是IO寄存器；而前者能够控制设备寄存器（设备寄存器指的是在设备中可供读写访问的单元）<br> 说了那么多，还是直接记住吧：1和2都是驱动层的，3是独立层的，4是用户层的</p> 
<ol start="2"><li></ol> 
<p><img src="https://images2.imgbox.com/53/a1/5VwJbnGz_o.png" alt="在这里插入图片描述"><br> 解析：就是问一个字节可以存放多长时间。记一个字节可以存放的时间为t，加上轮询处理的时间3μs，那么一个字节从输入到被处理完成，总共耗时就是t+3μs；而由于最大传输速度为50000B/s，故传输一个字节的最短时间是20μs，也就是说，传完这一个字节A后，下一个字节B可能在20微秒后到达，所以字节A的处理时间最长只能是20微秒，所以最大轮询时间间隔是20-3=17微秒</p> 
<ol start="3"><li></ol> 
<p><img src="https://images2.imgbox.com/55/48/Bh8VUlWr_o.png" alt="在这里插入图片描述"><br> 解析：<br> <img src="https://images2.imgbox.com/70/e0/tGYIsA3v_o.png" alt="在这里插入图片描述"><br> 4.<br> <img src="https://images2.imgbox.com/c8/1a/WGtFMvNf_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/72/02/nQufIrUU_o.png" alt="在这里插入图片描述"><br> 5.<br> <img src="https://images2.imgbox.com/0f/c0/eJFEujqd_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/8c/fb/4FxM23nA_o.png" alt="在这里插入图片描述"><br> 6.<br> <img src="https://images2.imgbox.com/9a/54/ixJvhcZe_o.png" alt="在这里插入图片描述"><br> 解析：SPOOLing技术的基本条件是要有大容量、高速度的外存作为输入井和输出井，所以AB错误。正确选项是D</p> 
<ol start="7"><li></ol> 
<p><img src="https://images2.imgbox.com/56/86/XM2Vx8OO_o.png" alt="在这里插入图片描述"><br> 解析：可以把经常要访问的文件调入缓冲区，从而减少磁盘IO次数。所以选A（这是个知识点，记住就好）</p> 
<p><font color="grey" size="1">现在是2020/11/9，距离2021考研只剩下40余天，现在才跑完OS的第一轮复习，👴笑了</font></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ce05328d204004e539c253b762f80bd8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C# 委托调用带参的方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/26baad0cb25467ef3e890d55aa996631/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">人机交互基础教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>