<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Camera -- takePicture流程 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Camera -- takePicture流程" />
<meta property="og:description" content="一、framework frameworks/base/core/java/android/hardware/Camera.java
/** * Equivalent to takePicture(shutter, raw, null, jpeg). * * @see #takePicture(ShutterCallback, PictureCallback, PictureCallback, PictureCallback) */ public final void takePicture(ShutterCallback shutter, PictureCallback raw, PictureCallback jpeg) { takePicture(shutter, raw, null, jpeg); } private native final void native_takePicture(int msgType); /** * Triggers an asynchronous image capture. The camera service will initiate * a series of callbacks to the application as the image capture progresses. * The shutter callback occurs after the image is captured." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/8eb44259a0ffd064819973c6c6359e37/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-06-05T16:43:00+08:00" />
<meta property="article:modified_time" content="2013-06-05T16:43:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Camera -- takePicture流程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <h2>一、framework</h2> 
 <p>frameworks/base/core/java/android/hardware/Camera.java</p> 
 <div class="cnblogs_code"> 
  <pre>    <span style="color:#008000;">/**</span><span style="color:#008000;">
     * Equivalent to takePicture(shutter, raw, null, jpeg).
     *
     * </span><span style="color:#808080;">@see</span><span style="color:#008000;"> #takePicture(ShutterCallback, PictureCallback, PictureCallback, PictureCallback)
     </span><span style="color:#008000;">*/</span>
    <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">final</span> <span style="color:#0000ff;">void</span><span style="color:#000000;"> takePicture(ShutterCallback shutter, PictureCallback raw,
            PictureCallback jpeg) {
        takePicture(shutter, raw, </span><span style="color:#0000ff;">null</span><span style="color:#000000;">, jpeg);
    }
    </span><span style="color:#0000ff;">private</span> <span style="color:#0000ff;">native</span> <span style="color:#0000ff;">final</span> <span style="color:#0000ff;">void</span> native_takePicture(<span style="color:#0000ff;">int</span><span style="color:#000000;"> msgType);

    </span><span style="color:#008000;">/**</span><span style="color:#008000;">
     * Triggers an asynchronous image capture. The camera service will initiate
     * a series of callbacks to the application as the image capture progresses.
     * The shutter callback occurs after the image is captured. This can be used
     * to trigger a sound to let the user know that image has been captured. The
     * raw callback occurs when the raw image data is available (NOTE: the data
     * will be null if there is no raw image callback buffer available or the
     * raw image callback buffer is not large enough to hold the raw image).
     * The postview callback occurs when a scaled, fully processed postview
     * image is available (NOTE: not all hardware supports this). The jpeg
     * callback occurs when the compressed image is available. If the
     * application does not need a particular callback, a null can be passed
     * instead of a callback method.
     *
     * &lt;p&gt;This method is only valid when preview is active (after
     * {<!-- --></span><span style="color:#808080;">@link</span><span style="color:#008000;"> #startPreview()}).  Preview will be stopped after the image is
     * taken; callers must call {<!-- --></span><span style="color:#808080;">@link</span><span style="color:#008000;"> #startPreview()} again if they want to
     * re-start preview or take more pictures. This should not be called between
     * {<!-- --></span><span style="color:#808080;">@link</span><span style="color:#008000;"> android.media.MediaRecorder#start()} and
     * {<!-- --></span><span style="color:#808080;">@link</span><span style="color:#008000;"> android.media.MediaRecorder#stop()}.
     *
     * &lt;p&gt;After calling this method, you must not call {<!-- --></span><span style="color:#808080;">@link</span><span style="color:#008000;"> #startPreview()}
     * or take another picture until the JPEG callback has returned.
     *
     * </span><span style="color:#808080;">@param</span><span style="color:#008000;"> shutter   the callback for image capture moment, or null
     * </span><span style="color:#808080;">@param</span><span style="color:#008000;"> raw       the callback for raw (uncompressed) image data, or null
     * </span><span style="color:#808080;">@param</span><span style="color:#008000;"> postview  callback with postview image data, may be null
     * </span><span style="color:#808080;">@param</span><span style="color:#008000;"> jpeg      the callback for JPEG image data, or null
     </span><span style="color:#008000;">*/</span>
    <span style="color:#0000ff;">public</span> <span style="color:#0000ff;">final</span> <span style="color:#0000ff;">void</span><span style="color:#000000;"> takePicture(ShutterCallback shutter, PictureCallback raw,
            PictureCallback postview, PictureCallback jpeg) {
        mShutterCallback </span>=<span style="color:#000000;"> shutter;
        mRawImageCallback </span>=<span style="color:#000000;"> raw;
        mPostviewCallback </span>=<span style="color:#000000;"> postview;
        mJpegCallback </span>=<span style="color:#000000;"> jpeg;

        </span><span style="color:#008000;">//</span><span style="color:#008000;"> If callback is not set, do not send me callbacks.</span>
        <span style="color:#0000ff;">int</span> msgType = 0<span style="color:#000000;">;
        </span><span style="color:#0000ff;">if</span> (mShutterCallback != <span style="color:#0000ff;">null</span><span style="color:#000000;">) {
            msgType </span>|=<span style="color:#000000;"> CAMERA_MSG_SHUTTER;
        }
        </span><span style="color:#0000ff;">if</span> (mRawImageCallback != <span style="color:#0000ff;">null</span><span style="color:#000000;">) {
            msgType </span>|=<span style="color:#000000;"> CAMERA_MSG_RAW_IMAGE;
        }
        </span><span style="color:#0000ff;">if</span> (mPostviewCallback != <span style="color:#0000ff;">null</span><span style="color:#000000;">) {
            msgType </span>|=<span style="color:#000000;"> CAMERA_MSG_POSTVIEW_FRAME;
        }
        </span><span style="color:#0000ff;">if</span> (mJpegCallback != <span style="color:#0000ff;">null</span><span style="color:#000000;">) {
            msgType </span>|=<span style="color:#000000;"> CAMERA_MSG_COMPRESSED_IMAGE;
        }

        native_takePicture(msgType);
        mFaceDetectionRunning </span>= <span style="color:#0000ff;">false</span><span style="color:#000000;">;
    }</span></pre> 
 </div> 
 <p>takePicture-&gt;native_takePicture, 会调用到JNINativeMethod, 这里通过VM执行c++的代码</p> 
 <h2>二、JNI</h2> 
 <p>frameworks/base/core/jni/android_hardware_Camera.cpp</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#0000ff;">static</span> <span style="color:#0000ff;">void</span> android_hardware_Camera_takePicture(JNIEnv *env, jobject thiz, <span style="color:#0000ff;">int</span><span style="color:#000000;"> msgType)
{
    ALOGV(</span><span style="color:#800000;">"</span><span style="color:#800000;">takePicture</span><span style="color:#800000;">"</span><span style="color:#000000;">);
    JNICameraContext</span>*<span style="color:#000000;"> context;
    sp</span>&lt;Camera&gt; camera = get_native_camera(env, thiz, &amp;<span style="color:#000000;">context);
    </span><span style="color:#0000ff;">if</span> (camera == <span style="color:#800080;">0</span>) <span style="color:#0000ff;">return</span><span style="color:#000000;">;

    </span><span style="color:#008000;">/*</span><span style="color:#008000;">
     * When CAMERA_MSG_RAW_IMAGE is requested, if the raw image callback
     * buffer is available, CAMERA_MSG_RAW_IMAGE is enabled to get the
     * notification _and_ the data; otherwise, CAMERA_MSG_RAW_IMAGE_NOTIFY
     * is enabled to receive the callback notification but no data.
     *
     * Note that CAMERA_MSG_RAW_IMAGE_NOTIFY is not exposed to the
     * Java application.
     </span><span style="color:#008000;">*/</span>
    <span style="color:#0000ff;">if</span> (msgType &amp;<span style="color:#000000;"> CAMERA_MSG_RAW_IMAGE) {
        ALOGV(</span><span style="color:#800000;">"</span><span style="color:#800000;">Enable raw image callback buffer</span><span style="color:#800000;">"</span><span style="color:#000000;">);
        </span><span style="color:#0000ff;">if</span> (!context-&gt;<span style="color:#000000;">isRawImageCallbackBufferAvailable()) {
            ALOGV(</span><span style="color:#800000;">"</span><span style="color:#800000;">Enable raw image notification, since no callback buffer exists</span><span style="color:#800000;">"</span><span style="color:#000000;">);
            msgType </span>&amp;= ~<span style="color:#000000;">CAMERA_MSG_RAW_IMAGE;
            msgType </span>|=<span style="color:#000000;"> CAMERA_MSG_RAW_IMAGE_NOTIFY;
        }
    }

    </span><span style="color:#0000ff;">if</span> (camera-&gt;takePicture(msgType) !=<span style="color:#000000;"> NO_ERROR) {
        jniThrowRuntimeException(env, </span><span style="color:#800000;">"</span><span style="color:#800000;">takePicture failed</span><span style="color:#800000;">"</span><span style="color:#000000;">);
        </span><span style="color:#0000ff;">return</span><span style="color:#000000;">;
    }
}

</span><span style="color:#0000ff;">static</span> JNINativeMethod camMethods[] =<span style="color:#000000;"> {
  { </span><span style="color:#800000;">"</span><span style="color:#800000;">native_takePicture</span><span style="color:#800000;">"</span><span style="color:#000000;">,
    </span><span style="color:#800000;">"</span><span style="color:#800000;">(I)V</span><span style="color:#800000;">"</span><span style="color:#000000;">,
    (</span><span style="color:#0000ff;">void</span> *<span style="color:#000000;">)android_hardware_Camera_takePicture },
};</span></pre> 
 </div> 
 <p> </p> 
 <p>frameworks/av/camera/Camera.cpp</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#008000;">//</span><span style="color:#008000;"> take a picture</span>
status_t Camera::takePicture(<span style="color:#0000ff;">int</span><span style="color:#000000;"> msgType)
{
    ALOGV(</span><span style="color:#800000;">"</span><span style="color:#800000;">takePicture: 0x%x</span><span style="color:#800000;">"</span><span style="color:#000000;">, msgType);
    sp </span>&lt;ICamera&gt; c =<span style="color:#000000;"> mCamera;
    </span><span style="color:#0000ff;">if</span> (c == <span style="color:#800080;">0</span>) <span style="color:#0000ff;">return</span><span style="color:#000000;"> NO_INIT;
    </span><span style="color:#0000ff;">return</span> c-&gt;<span style="color:#000000;">takePicture(msgType);
}</span></pre> 
 </div> 
 <p>frameworks/av/camera/ICamera.cpp</p> 
 <p>这边会涉及到binder IPC, binder其实是一种C/S架构通信方式, 会通知作为Server进程的V4LCameraAdapter里面的pictureThread。</p> 
 <div class="cnblogs_code"> 
  <pre>    <span style="color:#008000;">//</span><span style="color:#008000;"> take a picture - returns an IMemory (ref-counted mmap)</span>
    status_t takePicture(<span style="color:#0000ff;">int</span><span style="color:#000000;"> msgType)
    {   
        ALOGV(</span><span style="color:#800000;">"</span><span style="color:#800000;">takePicture: 0x%x</span><span style="color:#800000;">"</span><span style="color:#000000;">, msgType);
        Parcel data, reply;
        data.writeInterfaceToken(ICamera::getInterfaceDescriptor());
        data.writeInt32(msgType);
        <span style="color:#ff0000;">remote()</span></span><span style="color:#ff0000;">-&gt;transact</span>(TAKE_PICTURE, data, &amp;<span style="color:#000000;">reply);
        status_t ret </span>=<span style="color:#000000;"> reply.readInt32();
        </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> ret;
    } </span></pre> 
 </div> 
 <p> </p> 
 <p>上面源码的mCameraAdapter是由下面函数创建的, 而CameraAdapter_Factory在下面实现。</p> 
 <div class="cnblogs_code"> 
  <pre>extern "C" CameraAdapter* CameraAdapter_Factory(size_t);</pre> 
 </div> 
 <h2>三、HAL</h2> 
 <p>hardware/amlogic/camera/V4LCameraAdapter/V4LCameraAdapter.cpp</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#0000ff;">extern</span> <span style="color:#800000;">"</span><span style="color:#800000;">C</span><span style="color:#800000;">"</span> CameraAdapter*<span style="color:#000000;"> CameraAdapter_Factory(size_t sensor_index)
{
    CameraAdapter </span>*adapter =<span style="color:#000000;"> NULL;
    Mutex::Autolock </span><span style="color:#0000ff;">lock</span><span style="color:#000000;">(gAdapterLock);

    LOG_FUNCTION_NAME;

#ifdef AMLOGIC_VIRTUAL_CAMERA_SUPPORT

    </span><span style="color:#0000ff;">if</span>( sensor_index ==<span style="color:#000000;"> (size_t)(iCamerasNum)){
            </span><span style="color:#008000;">//</span><span style="color:#008000;">MAX_CAM_NUM_ADD_VCAM-1) ){<!-- --></span>
        adapter = <span style="color:#0000ff;">new</span><span style="color:#000000;"> V4LCamAdpt(sensor_index);
    }</span><span style="color:#0000ff;">else</span><span style="color:#000000;">{
</span><span style="color:#0000ff;">#endif</span><span style="color:#000000;">
        adapter </span>= <span style="color:#0000ff;">new</span><span style="color:#000000;"> V4LCameraAdapter(sensor_index);
#ifdef AMLOGIC_VIRTUAL_CAMERA_SUPPORT
    }
</span><span style="color:#0000ff;">#endif</span>

    <span style="color:#0000ff;">if</span><span style="color:#000000;"> ( adapter ) {
        CAMHAL_LOGDB(</span><span style="color:#800000;">"</span><span style="color:#800000;">New V4L Camera adapter instance created for sensor %d</span><span style="color:#800000;">"</span><span style="color:#000000;">, sensor_index);
    } </span><span style="color:#0000ff;">else</span><span style="color:#000000;"> {
        CAMHAL_LOGEA(</span><span style="color:#800000;">"</span><span style="color:#800000;">Camera adapter create failed!</span><span style="color:#800000;">"</span><span style="color:#000000;">);
    }

    LOG_FUNCTION_NAME_EXIT;

    </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> adapter;
}</span></pre> 
 </div> 
 <p>HAL层的takePicture</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#008000;">/*</span><span style="color:#008000;">static</span><span style="color:#008000;">*/</span> <span style="color:#0000ff;">int</span> V4LCameraAdapter::beginPictureThread(<span style="color:#0000ff;">void</span> *<span style="color:#000000;">cookie)
{
    V4LCameraAdapter </span>*c = (V4LCameraAdapter *<span style="color:#000000;">)cookie;
    </span><span style="color:#0000ff;">return</span> c-&gt;<span style="color:#000000;">pictureThread();
}

</span><span style="color:#008000;">/*</span><span style="color:#008000;">static</span><span style="color:#008000;">*/</span> <span style="color:#0000ff;">int</span> V4LCameraAdapter::beginPictureThread(<span style="color:#0000ff;">void</span> *<span style="color:#000000;">cookie)
{
    V4LCameraAdapter </span>*c = (V4LCameraAdapter *<span style="color:#000000;">)cookie;
    </span><span style="color:#0000ff;">return</span> c-&gt;<span style="color:#000000;">pictureThread();
}

</span><span style="color:#0000ff;">int</span><span style="color:#000000;"> V4LCameraAdapter::pictureThread()
{
    status_t ret </span>=<span style="color:#000000;"> NO_ERROR;
    </span><span style="color:#0000ff;">int</span><span style="color:#000000;"> width, height;
    CameraFrame frame;
    </span><span style="color:#0000ff;">int</span> dqTryNum = <span style="color:#800080;">3</span><span style="color:#000000;">;

#ifndef AMLOGIC_USB_CAMERA_SUPPORT
    setMirrorEffect();
</span><span style="color:#0000ff;">#endif</span>

    <span style="color:#0000ff;">if</span>( (mIoctlSupport &amp;<span style="color:#000000;"> IOCTL_MASK_FLASH)
        </span>&amp;&amp;(FLASHLIGHT_ON ==<span style="color:#000000;"> mFlashMode)){
        set_flash_mode( mCameraHandle, </span><span style="color:#800000;">"</span><span style="color:#800000;">on</span><span style="color:#800000;">"</span><span style="color:#000000;">);
    }
    </span><span style="color:#0000ff;">if</span> (<span style="color:#0000ff;">true</span><span style="color:#000000;">)
    {
        mVideoInfo</span>-&gt;buf.index = <span style="color:#800080;">0</span><span style="color:#000000;">;
        mVideoInfo</span>-&gt;buf.type =<span style="color:#000000;"> V4L2_BUF_TYPE_VIDEO_CAPTURE;
        mVideoInfo</span>-&gt;buf.memory =<span style="color:#000000;"> V4L2_MEMORY_MMAP;

#ifdef AMLOGIC_USB_CAMERA_SUPPORT
        </span><span style="color:#0000ff;">if</span><span style="color:#000000;">(mIsDequeuedEIOError){
            CAMHAL_LOGEA(</span><span style="color:#800000;">"</span><span style="color:#800000;">DQBUF EIO has occured!\n</span><span style="color:#800000;">"</span><span style="color:#000000;">);
            </span><span style="color:#0000ff;">return</span> -<span style="color:#000000;">EINVAL;
        }
</span><span style="color:#0000ff;">#endif</span><span style="color:#000000;">
        ret </span>= ioctl(mCameraHandle, VIDIOC_QBUF, &amp;mVideoInfo-&gt;<span style="color:#000000;">buf);
        </span><span style="color:#0000ff;">if</span> (ret &lt; <span style="color:#800080;">0</span><span style="color:#000000;">)
        {
            CAMHAL_LOGEA(</span><span style="color:#800000;">"</span><span style="color:#800000;">VIDIOC_QBUF Failed</span><span style="color:#800000;">"</span><span style="color:#000000;">);
            </span><span style="color:#0000ff;">return</span> -<span style="color:#000000;">EINVAL;
        }
        nQueued </span>++<span style="color:#000000;">;

#ifndef AMLOGIC_USB_CAMERA_SUPPORT
        </span><span style="color:#0000ff;">if</span>(mIoctlSupport &amp;<span style="color:#000000;"> IOCTL_MASK_ROTATE){
            set_rotate_value(mCameraHandle,mRotateValue);
        }
</span><span style="color:#0000ff;">#endif</span>

        <span style="color:#0000ff;">enum</span><span style="color:#000000;"> v4l2_buf_type bufType;
        </span><span style="color:#0000ff;">if</span> (!mVideoInfo-&gt;<span style="color:#000000;">isStreaming)
        {
            bufType </span>=<span style="color:#000000;"> V4L2_BUF_TYPE_VIDEO_CAPTURE;

            ret </span>= ioctl (mCameraHandle, VIDIOC_STREAMON, &amp;<span style="color:#000000;">bufType);
            </span><span style="color:#0000ff;">if</span> (ret &lt; <span style="color:#800080;">0</span><span style="color:#000000;">) {
                CAMHAL_LOGEB(</span><span style="color:#800000;">"</span><span style="color:#800000;">StartStreaming: Unable to start capture: %s</span><span style="color:#800000;">"</span><span style="color:#000000;">, strerror(errno));
                </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> ret;
            }

            mVideoInfo</span>-&gt;isStreaming = <span style="color:#0000ff;">true</span><span style="color:#000000;">;
        }

        </span><span style="color:#0000ff;">int</span> index = <span style="color:#800080;">0</span><span style="color:#000000;">;
        </span><span style="color:#0000ff;">char</span> *fp = <span style="color:#0000ff;">this</span>-&gt;<span style="color:#000000;">GetFrame(index);
#ifdef AMLOGIC_USB_CAMERA_SUPPORT
        </span><span style="color:#0000ff;">while</span>((mVideoInfo-&gt;buf.length != mVideoInfo-&gt;buf.bytesused)&amp;&amp;(dqTryNum&gt;<span style="color:#800080;">0</span><span style="color:#000000;">)){
        </span><span style="color:#0000ff;">if</span>(NULL !=<span style="color:#000000;"> fp){
            mVideoInfo</span>-&gt;buf.index = <span style="color:#800080;">0</span><span style="color:#000000;">;
            mVideoInfo</span>-&gt;buf.type =<span style="color:#000000;"> V4L2_BUF_TYPE_VIDEO_CAPTURE;
            mVideoInfo</span>-&gt;buf.memory =<span style="color:#000000;"> V4L2_MEMORY_MMAP;


            </span><span style="color:#0000ff;">if</span><span style="color:#000000;">(mIsDequeuedEIOError){
                CAMHAL_LOGEA(</span><span style="color:#800000;">"</span><span style="color:#800000;">DQBUF EIO has occured!\n</span><span style="color:#800000;">"</span><span style="color:#000000;">);
                </span><span style="color:#0000ff;">break</span><span style="color:#000000;">;
            }

            ret </span>= ioctl(mCameraHandle, VIDIOC_QBUF, &amp;mVideoInfo-&gt;<span style="color:#000000;">buf);
            </span><span style="color:#0000ff;">if</span> (ret &lt; <span style="color:#800080;">0</span><span style="color:#000000;">)
            {
                CAMHAL_LOGEB(</span><span style="color:#800000;">"</span><span style="color:#800000;">VIDIOC_QBUF Failed errno=%d\n</span><span style="color:#800000;">"</span><span style="color:#000000;">, errno);
                </span><span style="color:#0000ff;">break</span><span style="color:#000000;">;
            }
            nQueued </span>++<span style="color:#000000;">;
            dqTryNum </span>--<span style="color:#000000;">;
        }

#ifdef AMLOGIC_CAMERA_NONBLOCK_SUPPORT
        usleep( </span><span style="color:#800080;">10000</span><span style="color:#000000;"> );
</span><span style="color:#0000ff;">#endif</span><span style="color:#000000;">
        fp </span>= <span style="color:#0000ff;">this</span>-&gt;<span style="color:#000000;">GetFrame(index);
    }
</span><span style="color:#0000ff;">#endif</span><span style="color:#000000;">

#ifdef AMLOGIC_CAMERA_NONBLOCK_SUPPORT
        </span><span style="color:#0000ff;">while</span>(!fp &amp;&amp; (-<span style="color:#800080;">1</span> ==<span style="color:#000000;"> index) ){
            usleep( </span><span style="color:#800080;">10000</span><span style="color:#000000;"> );
            fp </span>= <span style="color:#0000ff;">this</span>-&gt;<span style="color:#000000;">GetFrame(index);
        }
</span><span style="color:#0000ff;">#else</span>
        <span style="color:#0000ff;">if</span>(!<span style="color:#000000;">fp)
        {
            CAMHAL_LOGDA(</span><span style="color:#800000;">"</span><span style="color:#800000;">GetFrame fail, this may stop preview\n</span><span style="color:#800000;">"</span><span style="color:#000000;">);
            </span><span style="color:#0000ff;">return</span> <span style="color:#800080;">0</span>; <span style="color:#008000;">//</span><span style="color:#008000;">BAD_VALUE;</span>
<span style="color:#000000;">        }
</span><span style="color:#0000ff;">#endif</span>
        <span style="color:#0000ff;">if</span> (!mCaptureBuf || !mCaptureBuf-&gt;<span style="color:#000000;">data)
        {
            </span><span style="color:#0000ff;">return</span> <span style="color:#800080;">0</span>; <span style="color:#008000;">//</span><span style="color:#008000;">BAD_VALUE;</span>
<span style="color:#000000;">        }

        </span><span style="color:#0000ff;">int</span><span style="color:#000000;"> width, height;
        uint8_t</span>* dest = (uint8_t*)mCaptureBuf-&gt;<span style="color:#000000;">data;
        uint8_t</span>* src = (uint8_t*<span style="color:#000000;">) fp;
        </span><span style="color:#0000ff;">if</span>((mCaptureWidth &lt;= <span style="color:#800080;">0</span>)||(mCaptureHeight &lt;= <span style="color:#800080;">0</span><span style="color:#000000;">)){
            mParams.getPictureSize(</span>&amp;width, &amp;<span style="color:#000000;">height);
        }</span><span style="color:#0000ff;">else</span><span style="color:#000000;">{
            width </span>=<span style="color:#000000;"> mCaptureWidth;
            height </span>=<span style="color:#000000;"> mCaptureHeight;
        }

#ifndef AMLOGIC_USB_CAMERA_SUPPORT
        </span><span style="color:#0000ff;">if</span>((mRotateValue==<span style="color:#800080;">90</span>)||(mRotateValue==<span style="color:#800080;">270</span><span style="color:#000000;">)){
            </span><span style="color:#0000ff;">int</span> temp = <span style="color:#800080;">0</span><span style="color:#000000;">;
            temp </span>=<span style="color:#000000;"> width;
            width </span>=<span style="color:#000000;"> height;
            height </span>=<span style="color:#000000;"> temp;
        }
</span><span style="color:#0000ff;">#endif</span><span style="color:#000000;">

        LOGD(</span><span style="color:#800000;">"</span><span style="color:#800000;">pictureThread mCaptureBuf=%#x dest=%#x fp=%#x width=%d height=%d</span><span style="color:#800000;">"</span><span style="color:#000000;">, (uint32_t)mCaptureBuf, (uint32_t)dest, (uint32_t)fp, width, height);
        LOGD(</span><span style="color:#800000;">"</span><span style="color:#800000;">length=%d bytesused=%d index=%d</span><span style="color:#800000;">"</span>, mVideoInfo-&gt;buf.length, mVideoInfo-&gt;<span style="color:#000000;">buf.bytesused, index);

        </span><span style="color:#0000ff;">if</span>(DEFAULT_IMAGE_CAPTURE_PIXEL_FORMAT == V4L2_PIX_FMT_RGB24){ <span style="color:#008000;">//</span><span style="color:#008000;"> rgb24</span>
            frame.mLength = width*height*<span style="color:#800080;">3</span><span style="color:#000000;">;
            frame.mQuirks </span>= CameraFrame::ENCODE_RAW_RGB24_TO_JPEG |<span style="color:#000000;"> CameraFrame::HAS_EXIF_DATA;
#ifdef AMLOGIC_USB_CAMERA_SUPPORT
            </span><span style="color:#008000;">//</span><span style="color:#008000;">convert yuyv to rgb24</span>
<span style="color:#000000;">            yuyv422_to_rgb24(src,dest,width,height);
</span><span style="color:#0000ff;">#else</span><span style="color:#000000;">
            memcpy(dest,src,mVideoInfo</span>-&gt;<span style="color:#000000;">buf.length);
</span><span style="color:#0000ff;">#endif</span><span style="color:#000000;">
        }</span><span style="color:#0000ff;">else</span> <span style="color:#0000ff;">if</span>(DEFAULT_IMAGE_CAPTURE_PIXEL_FORMAT == V4L2_PIX_FMT_YUYV){ <span style="color:#008000;">//</span><span style="color:#008000;">   422I</span>
            frame.mLength = width*height*<span style="color:#800080;">2</span><span style="color:#000000;">;
            frame.mQuirks </span>= CameraFrame::ENCODE_RAW_YUV422I_TO_JPEG |<span style="color:#000000;"> CameraFrame::HAS_EXIF_DATA;
            memcpy(dest, src, mVideoInfo</span>-&gt;<span style="color:#000000;">buf.length);
        }</span><span style="color:#0000ff;">else</span> <span style="color:#0000ff;">if</span>(DEFAULT_IMAGE_CAPTURE_PIXEL_FORMAT == V4L2_PIX_FMT_NV21){ <span style="color:#008000;">//</span><span style="color:#008000;">   420sp</span>
            frame.mLength = width*height*<span style="color:#800080;">3</span>/<span style="color:#800080;">2</span><span style="color:#000000;">;
            frame.mQuirks </span>= CameraFrame::ENCODE_RAW_YUV420SP_TO_JPEG |<span style="color:#000000;"> CameraFrame::HAS_EXIF_DATA;
#ifdef AMLOGIC_USB_CAMERA_SUPPORT
            </span><span style="color:#008000;">//</span><span style="color:#008000;">convert yuyv to nv21</span>
<span style="color:#000000;">            yuyv422_to_nv21(src,dest,width,height);
</span><span style="color:#0000ff;">#else</span><span style="color:#000000;">
            memcpy(dest,src,mVideoInfo</span>-&gt;<span style="color:#000000;">buf.length);
</span><span style="color:#0000ff;">#endif</span><span style="color:#000000;">
        }</span><span style="color:#0000ff;">else</span>{ <span style="color:#008000;">//</span><span style="color:#008000;">default case</span>
            frame.mLength = width*height*<span style="color:#800080;">3</span><span style="color:#000000;">;
            frame.mQuirks </span>= CameraFrame::ENCODE_RAW_RGB24_TO_JPEG |<span style="color:#000000;"> CameraFrame::HAS_EXIF_DATA;
            memcpy(dest, src, mVideoInfo</span>-&gt;<span style="color:#000000;">buf.length);
        }

        notifyShutterSubscribers();
        </span><span style="color:#008000;">//</span><span style="color:#008000;">TODO correct time to call this?</span>
        <span style="color:#0000ff;">if</span> (NULL !=<span style="color:#000000;"> mEndImageCaptureCallback)
            mEndImageCaptureCallback(mEndCaptureData);

        </span><span style="color:#008000;">//</span><span style="color:#008000;">gen  exif message</span>
        ExifElementsTable* exiftable = <span style="color:#0000ff;">new</span><span style="color:#000000;"> ExifElementsTable();
        GenExif(exiftable);

        frame.mFrameMask </span>=<span style="color:#000000;"> CameraFrame::IMAGE_FRAME;
        frame.mFrameType </span>=<span style="color:#000000;"> CameraFrame::IMAGE_FRAME;
        frame.mBuffer </span>= mCaptureBuf-&gt;<span style="color:#000000;">data;
        frame.mCookie2 </span>= (<span style="color:#0000ff;">void</span>*<span style="color:#000000;">)exiftable;
        frame.mAlignment </span>=<span style="color:#000000;"> width;
        frame.mOffset </span>= <span style="color:#800080;">0</span><span style="color:#000000;">;
        frame.mYuv[</span><span style="color:#800080;">0</span>] = <span style="color:#800080;">0</span><span style="color:#000000;">;
        frame.mYuv[</span><span style="color:#800080;">1</span>] = <span style="color:#800080;">0</span><span style="color:#000000;">;
        frame.mWidth </span>=<span style="color:#000000;"> width;
        frame.mHeight </span>=<span style="color:#000000;"> height;
        frame.mTimestamp </span>=<span style="color:#000000;"> systemTime(SYSTEM_TIME_MONOTONIC);

        </span><span style="color:#0000ff;">if</span> (mVideoInfo-&gt;<span style="color:#000000;">isStreaming)
        {
            bufType </span>=<span style="color:#000000;"> V4L2_BUF_TYPE_VIDEO_CAPTURE;
            ret </span>= ioctl (mCameraHandle, VIDIOC_STREAMOFF, &amp;<span style="color:#000000;">bufType);
            </span><span style="color:#0000ff;">if</span> (ret &lt; <span style="color:#800080;">0</span><span style="color:#000000;">)
            {
                CAMHAL_LOGEB(</span><span style="color:#800000;">"</span><span style="color:#800000;">StopStreaming: Unable to stop capture: %s</span><span style="color:#800000;">"</span><span style="color:#000000;">, strerror(errno));
                </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> ret;
            }

            mVideoInfo</span>-&gt;isStreaming = <span style="color:#0000ff;">false</span><span style="color:#000000;">;
        }

        mVideoInfo</span>-&gt;buf.type =<span style="color:#000000;"> V4L2_BUF_TYPE_VIDEO_CAPTURE;
        mVideoInfo</span>-&gt;buf.memory =<span style="color:#000000;"> V4L2_MEMORY_MMAP;

        nQueued </span>= <span style="color:#800080;">0</span><span style="color:#000000;">;
        nDequeued </span>= <span style="color:#800080;">0</span><span style="color:#000000;">;

        </span><span style="color:#008000;">/*</span><span style="color:#008000;"> Unmap buffers </span><span style="color:#008000;">*/</span>
        <span style="color:#0000ff;">if</span> (munmap(mVideoInfo-&gt;mem[<span style="color:#800080;">0</span>], mVideoInfo-&gt;buf.length) &lt; <span style="color:#800080;">0</span><span style="color:#000000;">)
            CAMHAL_LOGEA(</span><span style="color:#800000;">"</span><span style="color:#800000;">Unmap failed</span><span style="color:#800000;">"</span><span style="color:#000000;">);


#ifdef AMLOGIC_USB_CAMERA_SUPPORT
    mVideoInfo</span>-&gt;buf.type =<span style="color:#000000;"> V4L2_BUF_TYPE_VIDEO_CAPTURE;
    mVideoInfo</span>-&gt;buf.memory =<span style="color:#000000;"> V4L2_MEMORY_MMAP;
    mVideoInfo</span>-&gt;rb.count = <span style="color:#800080;">0</span><span style="color:#000000;">;

    ret </span>= ioctl(mCameraHandle, VIDIOC_REQBUFS, &amp;mVideoInfo-&gt;<span style="color:#000000;">rb);
    </span><span style="color:#0000ff;">if</span> (ret &lt; <span style="color:#800080;">0</span><span style="color:#000000;">) {
        CAMHAL_LOGEB(</span><span style="color:#800000;">"</span><span style="color:#800000;">VIDIOC_REQBUFS failed: %s</span><span style="color:#800000;">"</span><span style="color:#000000;">, strerror(errno));
        </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> ret;
    }</span><span style="color:#0000ff;">else</span><span style="color:#000000;">{
        CAMHAL_LOGDA(</span><span style="color:#800000;">"</span><span style="color:#800000;">VIDIOC_REQBUFS delete buffer success\n</span><span style="color:#800000;">"</span><span style="color:#000000;">);
    }
</span><span style="color:#0000ff;">#endif</span><span style="color:#000000;">
    }

    </span><span style="color:#0000ff;">if</span>( (mIoctlSupport &amp;<span style="color:#000000;"> IOCTL_MASK_FLASH)
        </span>&amp;&amp;(FLASHLIGHT_ON ==<span style="color:#000000;"> mFlashMode)){
        set_flash_mode( mCameraHandle, </span><span style="color:#800000;">"</span><span style="color:#800000;">off</span><span style="color:#800000;">"</span><span style="color:#000000;">);
    }
#ifndef AMLOGIC_USB_CAMERA_SUPPORT
    </span><span style="color:#0000ff;">if</span>(mIoctlSupport &amp;<span style="color:#000000;"> IOCTL_MASK_ROTATE){
        set_rotate_value(mCameraHandle,</span><span style="color:#800080;">0</span><span style="color:#000000;">);
        mRotateValue </span>= <span style="color:#800080;">0</span><span style="color:#000000;">;
    }
</span><span style="color:#0000ff;">#endif</span>

    <span style="color:#008000;">//</span><span style="color:#008000;"> start preview thread again after stopping it in UseBuffersCapture</span>
<span style="color:#000000;">    {
        Mutex::Autolock </span><span style="color:#0000ff;">lock</span><span style="color:#000000;">(mPreviewBufferLock);
        UseBuffersPreview(mPreviewBuffers, mPreviewBufferCount);
    }
    startPreview();

    ret </span>=<span style="color:#000000;"> setInitFrameRefCount(frame.mBuffer, frame.mFrameMask);
    </span><span style="color:#0000ff;">if</span><span style="color:#000000;"> (ret)
        LOGE(</span><span style="color:#800000;">"</span><span style="color:#800000;">setInitFrameRefCount err=%d</span><span style="color:#800000;">"</span><span style="color:#000000;">, ret);
    </span><span style="color:#0000ff;">else</span><span style="color:#000000;">
        ret </span>= sendFrameToSubscribers(&amp;<span style="color:#000000;">frame);
    </span><span style="color:#008000;">//</span><span style="color:#008000;">LOGD("pictureThread /sendFrameToSubscribers ret=%d", ret);</span>

    <span style="color:#0000ff;">return</span><span style="color:#000000;"> ret;
}

status_t V4LCameraAdapter::takePicture()
{
    LOG_FUNCTION_NAME;
    </span><span style="color:#0000ff;">if</span> (createThread(beginPictureThread, <span style="color:#0000ff;">this</span>) == <span style="color:#0000ff;">false</span><span style="color:#000000;">)
        </span><span style="color:#0000ff;">return</span> -<span style="color:#800080;">1</span><span style="color:#000000;">;
    LOG_FUNCTION_NAME_EXIT;
    </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> NO_ERROR;
}</span></pre> 
 </div> 
 <p> 可以由下面看出这里会操作设备节点</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#0000ff;">const</span> <span style="color:#0000ff;">char</span> *SENSOR_PATH[]=<span style="color:#000000;">{
            </span><span style="color:#800000;">"</span><span style="color:#800000;">/dev/video0</span><span style="color:#800000;">"</span><span style="color:#000000;">,
            </span><span style="color:#800000;">"</span><span style="color:#800000;">/dev/video1</span><span style="color:#800000;">"</span><span style="color:#000000;">,
            </span><span style="color:#800000;">"</span><span style="color:#800000;">/dev/video2</span><span style="color:#800000;">"</span><span style="color:#000000;">,
            </span><span style="color:#800000;">"</span><span style="color:#800000;">/dev/video3</span><span style="color:#800000;">"</span><span style="color:#000000;">,
            </span><span style="color:#800000;">"</span><span style="color:#800000;">/dev/video4</span><span style="color:#800000;">"</span><span style="color:#000000;">,
        };
</span><span style="color:#0000ff;">#define</span> DEVICE_PATH(_sensor_index) (SENSOR_PATH[_sensor_index])
<span style="color:#0000ff;">#else</span>
<span style="color:#0000ff;">#define</span> DEVICE_PATH(_sensor_index) (_sensor_index == 0 ? "/dev/video0" : "/dev/video1")
<span style="color:#0000ff;">#endif</span><span style="color:#000000;">

status_t V4LCameraAdapter::initialize(CameraProperties::Properties</span>*<span style="color:#000000;"> caps)
{
    ...
#ifdef AMLOGIC_CAMERA_NONBLOCK_SUPPORT
        </span><span style="color:#0000ff;">if</span> ((mCameraHandle = open(DEVICE_PATH(mSensorIndex), O_RDWR | O_NONBLOCK )) != -<span style="color:#800080;">1</span><span style="color:#000000;">)
</span><span style="color:#0000ff;">#else</span>
        <span style="color:#0000ff;">if</span> ((mCameraHandle = open(DEVICE_PATH(mSensorIndex), O_RDWR)) != -<span style="color:#800080;">1</span><span style="color:#000000;">)
</span><span style="color:#0000ff;">#endif</span><span style="color:#000000;">
    ...
}</span></pre> 
 </div> 
 <h2>四、kernel - driver</h2> 
 <p>待续</p> 
 <p> </p> 
</div> 
<p>转载于:https://www.cnblogs.com/mark-huang/archive/2013/06/05/3119217.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b1876f44ae434d9256d11c1ecd47504e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">新建word文档默认作者如何修改</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c3a1bc354c5fdccff02a85e72147045b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mini2440 uboot使用nfs方式引导内核，文件系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>