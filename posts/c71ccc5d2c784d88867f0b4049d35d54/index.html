<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Ribbon如何自定义实现负载均衡策略 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Ribbon如何自定义实现负载均衡策略" />
<meta property="og:description" content="前言 Ribbon作为Spring Cloud全家桶核心组件之一，是一套基于客户端的软负载工具，主要是基于Netfilx发布的开源项目，功能主要是应用于客户端软件的负载均衡算法、服务之间调用的桥梁。作为客户端的组件，提供了一系列的配置，如拒绝策略、超时重试、服务发现策略….主要的核心组件也是基于Load Balancer，会提供一些负载均衡策略，如轮询、加权轮询、随机连接、重试等策略。
注册中心、负载均衡、生产者服务之间的注册与调用情况
Ribbon负载均衡策略核心 IRule 接口定义了一系列的负载均衡策略
核心接口ILoadBalance定义了一系列的方法，包括获取服务列表、选择、添加、选择服务。
自定义负载均衡策略 1:代码方式配置新策略 首先定义Configuration的MyRule类，定义myRule方法返回IRule接口。
public class CustomRule extends AbstractLoadBalancerRule { private int total = 0; //被调用的次数 private int currentIndex = 0; //当前是谁在提供服务 public Server choose(ILoadBalancer lb, Object o) { if (lb == null) { return null; } Server server = null; while (server == null) { if (Thread./interrupted/()) { return null; } List&lt;Server&gt; upList = lb.getReachableServers(); //获得还活着的服务 List&lt;Server&gt; allList = lb.getAllServers(); //获取全部服务 int serverCount = allList." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/c71ccc5d2c784d88867f0b4049d35d54/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-19T14:29:22+08:00" />
<meta property="article:modified_time" content="2022-10-19T14:29:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Ribbon如何自定义实现负载均衡策略</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>前言</h3> 
<p>Ribbon作为Spring Cloud全家桶核心组件之一，是一套基于客户端的软负载工具，主要是基于Netfilx发布的开源项目，功能主要是应用于客户端软件的负载均衡算法、服务之间调用的桥梁。作为客户端的组件，提供了一系列的配置，如拒绝策略、超时重试、服务发现策略….主要的核心组件也是基于Load Balancer，会提供一些负载均衡策略，如轮询、加权轮询、随机连接、重试等策略。</p> 
<p>注册中心、负载均衡、生产者服务之间的注册与调用情况</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/cb/9d/rUMmGuuf_o.png"></p> 
<h3>Ribbon负载均衡策略核心</h3> 
<p>IRule 接口定义了一系列的负载均衡策略</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/3f/9c/di6d8D8S_o.png"></p> 
<p>核心接口ILoadBalance定义了一系列的方法，包括获取服务列表、选择、添加、选择服务。</p> 
<h3>自定义负载均衡策略</h3> 
<h4>1:代码方式配置新策略</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/85/e6/4zj9zRz7_o.png"></p> 
<p>首先定义Configuration的MyRule类，定义myRule方法返回IRule接口。</p> 
<pre><code>public class CustomRule extends AbstractLoadBalancerRule {


    private int total = 0; //被调用的次数
    private int currentIndex = 0; //当前是谁在提供服务

    public Server choose(ILoadBalancer lb, Object o) {
        if (lb == null) {
            return null;
        }
        Server server = null;

        while (server == null) {
            if (Thread./interrupted/()) {
                return null;
            }
            List&lt;Server&gt; upList = lb.getReachableServers(); //获得还活着的服务
            List&lt;Server&gt; allList = lb.getAllServers(); //获取全部服务

            int serverCount = allList.size();
            if (serverCount == 0) {

                return null;
            }

            //int index = chooseRandomInt(serverCount);
            //server = upList.get(index);

            if (total &lt; 5) {
                server = upList.get(currentIndex);
                total++;
                System./out/.println(“&lt;5” + total + “:” + currentIndex);
            } else {
                total = 0;
                currentIndex++;
                if (currentIndex &gt; upList.size() - 1) {
                    currentIndex = 0;
                    System./out/.println(“&gt;size” + total + “:” + currentIndex);
                }
                server = upList.get(currentIndex);
                System./out/.println(“&gt;5” + total + “:” + currentIndex);
            }

            if (server == null) {

                Thread./yield/();
                continue;
            }

            if (server.isAlive()) {
                return (server);
            }


            server = null;
            Thread./yield/();
        }

        return server;
    }


    @Override
    public void initWithNiwsConfig(IClientConfig iClientConfig) {

    }

    @Override
    public Server choose(Object o) {
         return choose(getLoadBalancer(), o);
    }
}
复制代码</code></pre> 
<p>自定义策略类CustomRule继承AbstractLoadBalancerRule父类，重写choose 方法，去选择自已写的负载均衡策略，这里我定义的策略是一个消费者服务被调用5次后就去调下一个服务。</p> 
<h4>2:配置文件的方式：</h4> 
<blockquote> 
 <p>XXXservice:</p> 
 <pre><code>ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer. MyRule /# 负载均衡规则/
复制代码</code></pre> 
</blockquote> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ad/a5/eTkvGpZB_o.png"></p> 
<p>启动类配置，需要通过自定义RestTemplate模版实现自定义策略的调用</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b8/c2/emTzb5Jk_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/97/b5/ya3980XY_o.png"></p> 
<p>通过postman去调服务的接口</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/7d/f1/z73p0FKd_o.png"></p> 
<p>断点代码发现调用次数超过了5次就会去，获取还存活的服务，并且下标从0开始计算，如果还存活的服务只有一个那么只能去轮询这一个还存活的服务实例。</p> 
<h3>总结</h3> 
<p>随着业务的开发的多变，我们的服务的负载均衡的策略也需要在原来的基础上，作出拓展，有些公司会根据自己的业务不同实现自己的负载均衡策略，一般情况下的开发就用默认的负载均衡规则。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0079ed3238a7c3df2b7845ae9147cb56/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">意外收获！阿里技术官私库中的Spring全家桶小册，源码实战都有</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d121c79ccedd00721ba466ea54d00621/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Docker离线安装</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>