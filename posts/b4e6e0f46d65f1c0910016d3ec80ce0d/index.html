<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java设计模式：23种设计模式全面解析，墙都不扶就服你 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java设计模式：23种设计模式全面解析，墙都不扶就服你" />
<meta property="og:description" content="命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。 迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。 观察者模式：对象间的一对多的依赖关系。 仲裁者模式：用一个中介对象来封装一系列的对象交互。 备忘录模式：在不破坏封装的前提下，保持对象的内部状态。 解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。 状态模式：允许一个对象在其对象内部状态改变时改变它的行为。 责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。 访问者模式：不改变数据结构的前提下，增加作用于一组对象元素的新功能。 三、设计模式的几种原则
**1、**单一职责原则 对于一个类，只有一个引起该类变化的原因；该类的职责是唯一的，且这个职责是唯一引起其他类变化的原因。
2、接口隔离原则 客户端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上。
3、依赖倒转原则 依赖倒转原则是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。
4、里式代换原则 任何基类可以出现的地方，子类一定可以出现。里氏代换原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受影响时，基类才能真正的被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。
5、开闭原则 （1）对于扩展是开放的（Open for extension）。这意味着模块的行为是可以扩展的。当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为。也就是说，我们可以改变模块的功能。
（2）对于修改是关闭的（Closed for modification）。对模块行为进行扩展时，不必改动模块的源代码或者二进制代码。模块的二进制可执行版本，无论是可链接的库、DLL或者.EXE文件，都无需改动。
6、迪米特法则 迪米特法则又叫做最少知识原则，就是说一个对象应当对其它对象又尽可能少的了解，不和陌生人说话。
7、合成复用原则 合成复用原则要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。
设计模式七大原则总结（超详细）
四、设计模式关系
五、设计模式感想
一共有23种设计模式，可以说都是为了提高代码的可读性、可扩展性、可复用性、类的可替换性、组件化、可移植性等等特性。通过接口、抽象类、继承、实现、委托、抽象、面向接口编程、多态、重载、重写等方式使得代码的这些特性得以彰显，可以说只有深刻的理解了这些概念背后的哲学思想才能更好的理解设计模式。在设计模式中有很多思想，比如可以使用委托的不要使用继承、开闭原则，面向扩展开放，面向修改关闭，里式代换原则，父类一定能被子类代替并使用，反置则不然，面向接口编程，功能层次和实现层次分离（桥接模式）、高内聚低耦合等思想，这些思想都是宝贵的，正是因为这样的思想的存在才使得代码的更新换代的时候能够尽可能少的甚至不用修改之前的代码，直接加入新的内容。提高软件的开发周期，便于维护和升级，便于查找和纠错，易于扩展和使用。
同样的设计模式主要分为三大类，创建型、行为型、结构型。我们可以简单的这样分类，只不过这样的分类似乎并不准确，不能一语道出所有的本质，设计模式是相互关联的，有的设计模式内部其实是使用了别的设计模式作为支撑的，但是大体上这样的一种划分便于我们去记忆，仅此而已。
六、设计模式回顾
从迭代器开始，我们将类中数据结构的遍历和类的功能实现分离出来，本质上使用了工厂模式；
其次我们学习了适配器模式，它将不同的接口进行适配，从而便于版本的兼容性以及其他功能；
然后我们学习了模板方法，使用模板面向抽象编程，便于新的子类的实现和管理；
之后学习了工厂模式，其实借用了模板模式来创建产品，是一种非常重要用处很广的一种方法；
然后我们学习了单例模式，有懒汉式、饿汉式等，生成关于某个类全局唯一的对象，注意多线程的影响；
之后是原型模式，用来复制复杂的对象，使用了clone方法，然后是builder模式，用一个新的类对已有的抽象接口进行整合和编程，从而构建出我们想要的东西；
然后是抽象工厂模式，使用了工厂模式，组合模式等模式，面向抽象编程，将抽象零件组装成抽象产品，便于具体工厂的创建，提高了代码的组件化和复用性；
然后是桥接模式，将类的功能层次和实现层次分割开来，便于对应的扩展和使用；
然后是策略模式，可以整体的替换策略，使用也很广泛；然后是组合模式，保证了同根同源，通过委托添加自己构成递归，树形结构，将具有树形特点的对象组合起来；
然后是装饰器模式，和组合模式的结构类似，同样是递归结构，从而可以不断的装饰，增加新的功能，很好用；
接着是visitor访问者模式，通过在类外访问类中的数据结构从而得到想要的结果，便于程序的可扩展性和组件化；
接着是责任链模式，推卸责任，根据问题的大小来考虑自己释放处理，本质是链表，便于职责分明；
总结 虽然我个人也经常自嘲，十年之后要去成为外卖专员，但实际上依靠自身的努力，是能够减少三十五岁之后的焦虑的，毕竟好的架构师并不多。
架构师，是我们大部分技术人的职业目标，一名好的架构师来源于机遇(公司)、个人努力(吃得苦、肯钻研)、天分(真的热爱)的三者协作的结果，实践&#43;机遇&#43;努力才能助你成为优秀的架构师。
如果你也想成为一名好的架构师，那或许这份Java成长笔记你需要阅读阅读，希望能够对你的职业发展有所帮助。
资料领取方式：戳这里免费下载
实践&#43;机遇&#43;努力才能助你成为优秀的架构师。
如果你也想成为一名好的架构师，那或许这份Java成长笔记你需要阅读阅读，希望能够对你的职业发展有所帮助。
资料领取方式：戳这里免费下载
[外链图片转存中…(img-HSnhH0wb-1628579086423)]" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/b4e6e0f46d65f1c0910016d3ec80ce0d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-10T15:04:59+08:00" />
<meta property="article:modified_time" content="2021-08-10T15:04:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java设计模式：23种设计模式全面解析，墙都不扶就服你</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <ol start="3"><li><a href="https://gitee.com/vip204888/java-p7" rel="nofollow">命令模式</a>：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。</li></ol> 
</blockquote> 
<blockquote> 
 <ol start="4"><li><a href="https://gitee.com/vip204888/java-p7" rel="nofollow">迭代器模式</a>：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。</li></ol> 
</blockquote> 
<blockquote> 
 <ol start="5"><li><a href="https://gitee.com/vip204888/java-p7" rel="nofollow">观察者模式</a>：对象间的一对多的依赖关系。</li></ol> 
</blockquote> 
<blockquote> 
 <ol start="6"><li><a href="https://gitee.com/vip204888/java-p7" rel="nofollow">仲裁者模式</a>：用一个中介对象来封装一系列的对象交互。</li></ol> 
</blockquote> 
<blockquote> 
 <ol start="7"><li><a href="https://gitee.com/vip204888/java-p7" rel="nofollow">备忘录模式</a>：在不破坏封装的前提下，保持对象的内部状态。</li></ol> 
</blockquote> 
<blockquote> 
 <ol start="8"><li><a href="https://gitee.com/vip204888/java-p7" rel="nofollow">解释器模式</a>：给定一个语言，定义它的文法的一种表示，并定义一个解释器。</li></ol> 
</blockquote> 
<blockquote> 
 <ol start="9"><li><a href="https://gitee.com/vip204888/java-p7" rel="nofollow">状态模式</a>：允许一个对象在其对象内部状态改变时改变它的行为。</li></ol> 
</blockquote> 
<blockquote> 
 <ol start="10"><li><a href="https://gitee.com/vip204888/java-p7" rel="nofollow">责任链模式</a>：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。</li></ol> 
</blockquote> 
<blockquote> 
 <ol start="11"><li><a href="https://gitee.com/vip204888/java-p7" rel="nofollow">访问者模式</a>：不改变数据结构的前提下，增加作用于一组对象元素的新功能。</li></ol> 
</blockquote> 
<p><strong>三、设计模式的几种原则</strong></p> 
<hr> 
<h4><a id="1_29"></a>**1、**单一职责原则</h4> 
<p>对于一个类，只有一个引起该类变化的原因；该类的职责是唯一的，且这个职责是唯一引起其他类变化的原因。</p> 
<h4><a id="2_37"></a>2、接口隔离原则</h4> 
<p>客户端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上。</p> 
<h4><a id="3_45"></a>3、依赖倒转原则</h4> 
<p>依赖倒转原则是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p> 
<h4><a id="4_53"></a>4、里式代换原则</h4> 
<p>任何基类可以出现的地方，子类一定可以出现。里氏代换原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受影响时，基类才能真正的被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p> 
<h4><a id="5_61"></a>5、开闭原则</h4> 
<p>（1）对于扩展是开放的（Open for extension）。这意味着模块的行为是可以扩展的。当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为。也就是说，我们可以改变模块的功能。</p> 
<p>（2）对于修改是关闭的（Closed for modification）。对模块行为进行扩展时，不必改动模块的源代码或者二进制代码。模块的二进制可执行版本，无论是可链接的库、DLL或者.EXE文件，都无需改动。</p> 
<h4><a id="6_73"></a>6、迪米特法则</h4> 
<p>迪米特法则又叫做最少知识原则，就是说一个对象应当对其它对象又尽可能少的了解，不和陌生人说话。</p> 
<h4><a id="7_81"></a>7、合成复用原则</h4> 
<p>合成复用原则要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。</p> 
<p><a href="https://gitee.com/vip204888/java-p7" rel="nofollow">设计模式七大原则总结（超详细）</a></p> 
<p><strong>四、设计模式关系</strong></p> 
<hr> 
<p><img src="https://images2.imgbox.com/4f/a7/glXHE8Fh_o.jpg" alt=""></p> 
<p><strong>五、设计模式感想</strong></p> 
<hr> 
<p>一共有23种设计模式，可以说都是为了提高代码的可读性、可扩展性、可复用性、类的可替换性、组件化、可移植性等等特性。通过接口、抽象类、继承、实现、委托、抽象、面向接口编程、多态、重载、重写等方式使得代码的这些特性得以彰显，可以说只有深刻的理解了这些概念背后的哲学思想才能更好的理解设计模式。在设计模式中有很多思想，比如可以使用委托的不要使用继承、开闭原则，面向扩展开放，面向修改关闭，里式代换原则，父类一定能被子类代替并使用，反置则不然，面向接口编程，功能层次和实现层次分离（桥接模式）、高内聚低耦合等思想，这些思想都是宝贵的，正是因为这样的思想的存在才使得代码的更新换代的时候能够尽可能少的甚至不用修改之前的代码，直接加入新的内容。提高软件的开发周期，便于维护和升级，便于查找和纠错，易于扩展和使用。</p> 
<p>同样的设计模式主要分为三大类，创建型、行为型、结构型。我们可以简单的这样分类，只不过这样的分类似乎并不准确，不能一语道出所有的本质，设计模式是相互关联的，有的设计模式内部其实是使用了别的设计模式作为支撑的，但是大体上这样的一种划分便于我们去记忆，仅此而已。</p> 
<p><img src="https://images2.imgbox.com/a6/c6/stArDvfX_o.png" alt=""></p> 
<p><strong>六、设计模式回顾</strong></p> 
<hr> 
<p>从迭代器开始，我们将类中数据结构的遍历和类的功能实现分离出来，本质上使用了工厂模式；</p> 
<p>其次我们学习了适配器模式，它将不同的接口进行适配，从而便于版本的兼容性以及其他功能；</p> 
<p>然后我们学习了模板方法，使用模板面向抽象编程，便于新的子类的实现和管理；</p> 
<p>之后学习了工厂模式，其实借用了模板模式来创建产品，是一种非常重要用处很广的一种方法；</p> 
<p>然后我们学习了单例模式，有懒汉式、饿汉式等，生成关于某个类全局唯一的对象，注意多线程的影响；</p> 
<p>之后是原型模式，用来复制复杂的对象，使用了clone方法，然后是builder模式，用一个新的类对已有的抽象接口进行整合和编程，从而构建出我们想要的东西；</p> 
<p>然后是抽象工厂模式，使用了工厂模式，组合模式等模式，面向抽象编程，将抽象零件组装成抽象产品，便于具体工厂的创建，提高了代码的组件化和复用性；</p> 
<p>然后是桥接模式，将类的功能层次和实现层次分割开来，便于对应的扩展和使用；</p> 
<p>然后是策略模式，可以整体的替换策略，使用也很广泛；然后是组合模式，保证了同根同源，通过委托添加自己构成递归，树形结构，将具有树形特点的对象组合起来；</p> 
<p>然后是装饰器模式，和组合模式的结构类似，同样是递归结构，从而可以不断的装饰，增加新的功能，很好用；</p> 
<p>接着是visitor访问者模式，通过在类外访问类中的数据结构从而得到想要的结果，便于程序的可扩展性和组件化；</p> 
<p>接着是责任链模式，推卸责任，根据问题的大小来考虑自己释放处理，本质是链表，便于职责分明；</p> 
<h2><a id="_177"></a>总结</h2> 
<p>虽然我个人也经常自嘲，十年之后要去成为外卖专员，但实际上依靠自身的努力，是能够减少三十五岁之后的焦虑的，毕竟好的架构师并不多。</p> 
<p>架构师，是我们大部分技术人的职业目标，一名好的架构师来源于机遇(公司)、个人努力(吃得苦、肯钻研)、天分(真的热爱)的三者协作的结果，实践+机遇+努力才能助你成为优秀的架构师。</p> 
<p>如果你也想成为一名好的架构师，那或许这份<strong>Java成长笔记</strong>你需要阅读阅读，希望能够对你的职业发展有所帮助。</p> 
<p><strong><a href="https://gitee.com/vip204888/java-p7" rel="nofollow">资料领取方式：戳这里免费下载</a></strong></p> 
<p><img src="https://images2.imgbox.com/4c/93/s111uLnV_o.png" alt="image"></p> 
<p>实践+机遇+努力才能助你成为优秀的架构师。</p> 
<p>如果你也想成为一名好的架构师，那或许这份<strong>Java成长笔记</strong>你需要阅读阅读，希望能够对你的职业发展有所帮助。</p> 
<p><strong><a href="https://gitee.com/vip204888/java-p7" rel="nofollow">资料领取方式：戳这里免费下载</a></strong></p> 
<p>[外链图片转存中…(img-HSnhH0wb-1628579086423)]</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/25531d6b4ea1a40aca8c079abc827e05/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">服务器销售电话拜访,拜访地是什么？如何接入拜访地？拜访地和归属地有什么区别...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/141a0f2d46eeb8d87951c7f62709b856/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">tp服务器虚拟目录,配置nginx虚拟目录配置文件支持tp的pathinfo</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>