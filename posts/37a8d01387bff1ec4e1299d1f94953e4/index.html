<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>队列(Queue) - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="队列(Queue)" />
<meta property="og:description" content="一、队列的概念 队列是一个先进先出的数据结构。
联想一下链表，在单链表中，只能对表尾进行插入，对表头进行结点的删除，这样强限制性的链表，就是所说的队列。也就是说，队列是限定在表的一端进行插入，表的另一端进行删除的数据结构。
如图去买票排队，每一列队伍都有一个队尾和队首，先来的先买票，后来的后买，买好的就从队首出去，新来买票的就需要从队尾继续排队。
通常，称进数据的一端为队尾，出数据的一端为队首，数据元素进队列的过程称为入队，出队列的过程称为出队。
队列是一个线性的数据结构，并且这个数据结构只允许在一端进行插入，另一端进行删除，禁止直接访问除这两端以外的一切数据，且队列是一个先进先出的数据结构。
如上图，队列就像一个两端相通的水管，只允许一端插入，另一端取出，取出的球就不在水管里面了，而先放入管中的球就会先从管中拿出。
队列存储结构的实现有以下两种方式：
①顺序队列：在顺序表的基础上实现的队列结构。
②链队列：在链表的基础上实现的队列结构。
两者的区别仅是顺序表和链表的区别，即在实际的物理空间中，数据集中存储的队列是顺序队列，分散存储的队列是链队列。
二、队列的结点设计与初始化 队列只有链式的设计方法，其本身分为多种队列，如顺序队列和循环队列，还有衍生的优先队列等等，以顺序队列的设计为例。
首先是队列的结点设计，可以设计出两个结构体，一个结构体 Node 表示结点，其中包含有 data 域和 next 指针，如图：
其中 data 表示数据，其可以是简单的类型，也可以是复杂的结构体。next 指针表示，下一个的指针，其指向下一个结点，通过 next 指针将各个结点链接。
然后再添加一个结构体，其包括了两个分别永远指向队列的队尾和队首的指针，看到这里是不是觉得和栈很像？
主要的操作只对这两个指针进行操作，如图所示：
其结构体设计的代码可以表示为：
//结点定义 typedef struct node{ int data; struct node *next; } node; //队列定义，队首指针和队尾指针 typedef struct queue{ node *front; //头指针 node *rear; //尾指针 } queue; 对于初始化需要初始化两个类型，一个是初始化结点，一个是初始化队列。代码中的描述，初始化队列有些不同，当初始化队列的时候，需要将头尾两个结点指向的内容统统置为空，表示是一个空队列，两个创建的函数代码可以表示为：
//初始化结点 node *init_node{ node *n=(node*)malloc(sizeof(node)); if(n==){ //建立失败，退出 exit(0); } return n; } //初始化队列 queue *init_queue { queue *q=(queue*)malloc(sizeof(queue)); if(q==) { //建立失败，退出 exit(0); } //头尾结点均赋值 q-&gt;front=; q-&gt;rear=; return q; } 三、判断队列是否为空 这是一个既简单也很要紧的操作，判断队列是否为空直接就是判断队列头指针是否是空值即可。其代码可以表示为：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/37a8d01387bff1ec4e1299d1f94953e4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-28T13:36:21+08:00" />
<meta property="article:modified_time" content="2022-03-28T13:36:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">队列(Queue)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>一、队列的概念</h2> 
<p><code>队列是一个先进先出的数据结构。</code><br> 联想一下链表，在单链表中，只能对表尾进行插入，对表头进行结点的删除，这样强限制性的链表，就是所说的队列。也就是说，队列是限定在表的一端进行插入，表的另一端进行删除的数据结构。</p> 
<p>如图去买票排队，每一列队伍都有一个队尾和队首，先来的先买票，后来的后买，买好的就从队首出去，新来买票的就需要从队尾继续排队。<br> <img src="https://images2.imgbox.com/f4/c1/hDhyqOBQ_o.png" alt=""></p> 
<p>通常，称进数据的一端为队尾，出数据的一端为队首，数据元素进队列的过程称为入队，出队列的过程称为出队。</p> 
<p>队列是一个线性的数据结构，并且这个数据结构只允许在一端进行插入，另一端进行删除，禁止直接访问除这两端以外的一切数据，且队列是一个先进先出的数据结构。<br> <img src="https://images2.imgbox.com/a5/0f/ttMxyZRS_o.png" alt=""></p> 
<p>如上图，队列就像一个两端相通的水管，只允许一端插入，另一端取出，取出的球就不在水管里面了，而先放入管中的球就会先从管中拿出。</p> 
<p>队列存储结构的实现有以下两种方式：<br> ①顺序队列：在顺序表的基础上实现的队列结构。<br> ②链队列：在链表的基础上实现的队列结构。</p> 
<p>两者的区别仅是顺序表和链表的区别，即在实际的物理空间中，数据集中存储的队列是顺序队列，分散存储的队列是链队列。</p> 
<h2><a id="_21"></a>二、队列的结点设计与初始化</h2> 
<p>队列只有链式的设计方法，其本身分为多种队列，如顺序队列和循环队列，还有衍生的优先队列等等，以顺序队列的设计为例。</p> 
<p>首先是队列的结点设计，可以设计出两个结构体，一个结构体 Node 表示结点，其中包含有 data 域和 next 指针，如图：<br> <img src="https://images2.imgbox.com/f4/98/zMwMbyhK_o.png" alt=""></p> 
<p>其中 data 表示数据，其可以是简单的类型，也可以是复杂的结构体。next 指针表示，下一个的指针，其指向下一个结点，通过 next 指针将各个结点链接。</p> 
<p>然后再添加一个结构体，其包括了两个分别永远指向队列的队尾和队首的指针，看到这里是不是觉得和栈很像？</p> 
<p>主要的操作只对这两个指针进行操作，如图所示：<br> <img src="https://images2.imgbox.com/2e/56/TDvcs112_o.png" alt=""></p> 
<p>其结构体设计的代码可以表示为：</p> 
<pre><code class="prism language-java"><span class="token comment">//结点定义</span>
typedef struct node<span class="token punctuation">{<!-- --></span> 
  <span class="token keyword">int</span> data<span class="token punctuation">;</span>
  struct node <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
  node<span class="token punctuation">;</span>
<span class="token comment">//队列定义，队首指针和队尾指针</span>
typedef struct queue<span class="token punctuation">{<!-- --></span> 
  node <span class="token operator">*</span>front<span class="token punctuation">;</span>
<span class="token comment">//头指针 </span>
  node <span class="token operator">*</span>rear<span class="token punctuation">;</span> 
<span class="token comment">//尾指针</span>
<span class="token punctuation">}</span>
  queue<span class="token punctuation">;</span>
</code></pre> 
<p>对于初始化需要初始化两个类型，一个是初始化结点，一个是初始化队列。代码中的描述，初始化队列有些不同，当初始化队列的时候，需要将头尾两个结点指向的内容统统置为空，表示是一个空队列，两个创建的函数代码可以表示为：</p> 
<pre><code class="prism language-java"><span class="token comment">//初始化结点</span>
node <span class="token operator">*</span>init_node<span class="token punctuation">{<!-- --></span>
  node <span class="token operator">*</span>n<span class="token operator">=</span><span class="token punctuation">(</span>node<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token function">sizeof</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
<span class="token comment">//建立失败，退出 </span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-java"><span class="token comment">//初始化队列</span>
queue <span class="token operator">*</span>init_queue <span class="token punctuation">{<!-- --></span> 
  queue <span class="token operator">*</span>q<span class="token operator">=</span><span class="token punctuation">(</span>queue<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token function">sizeof</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token operator">==</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
<span class="token comment">//建立失败，退出 </span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> 
<span class="token comment">//头尾结点均赋值 </span>
  q<span class="token operator">-&gt;</span>front<span class="token operator">=</span><span class="token punctuation">;</span>
  q<span class="token operator">-&gt;</span>rear<span class="token operator">=</span><span class="token punctuation">;</span> 
  <span class="token keyword">return</span> q<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_79"></a>三、判断队列是否为空</h2> 
<p>这是一个既简单也很要紧的操作，判断队列是否为空直接就是判断队列头指针是否是空值即可。其代码可以表示为：</p> 
<pre><code class="prism language-java"><span class="token comment">//队列判空</span>
<span class="token keyword">int</span> <span class="token function">empty</span><span class="token punctuation">(</span>queue <span class="token operator">*</span>q<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
  <span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token operator">-&gt;</span>front<span class="token operator">==</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> 
<span class="token comment">//1--表示真，说明队列非空 </span>
  <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment">//0--表示假，说明队列为空 </span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>或者直接利用返回值进行更简单的判断也可以，代码如下：</p> 
<pre><code class="prism language-java"><span class="token keyword">int</span> empty <span class="token punctuation">(</span>queue <span class="token operator">*</span>q<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
  <span class="token keyword">return</span> q<span class="token operator">-&gt;</span>front<span class="token operator">==</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_101"></a>四、入队操作</h2> 
<p>入队操作变化图：<br> <img src="https://images2.imgbox.com/93/3b/HzY0pKlT_o.png" alt=""></p> 
<p>进行入队(push)操作的时候，同样的，首先需要判断队列是否为空，如果队列为空的话，需要将头指针和尾指针一同指向第一个结点，代码如下：</p> 
<pre><code class="prism language-java">front<span class="token operator">=</span>n<span class="token punctuation">;</span>
rear<span class="token operator">=</span>n<span class="token punctuation">;</span>
</code></pre> 
<p>如图：<br> <img src="https://images2.imgbox.com/e5/df/I8C6aXRE_o.png" alt=""></p> 
<p>如果队列不为空的时候，这时只需要将尾结点向后移动，通过不断移动 <strong>next</strong>指针指向新的结点构成队列即可。如图：<br> <img src="https://images2.imgbox.com/1c/d0/s4QVGwt2_o.png" alt=""></p> 
<p>其代码可以表示为：</p> 
<pre><code class="prism language-java"><span class="token comment">//入队操作</span>
<span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>queue <span class="token operator">*</span>q<span class="token punctuation">,</span><span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
  node <span class="token operator">*</span>n <span class="token operator">=</span>init_node<span class="token punctuation">;</span>
  n<span class="token operator">-&gt;</span>data<span class="token operator">=</span>data<span class="token punctuation">;</span>
  n<span class="token operator">-&gt;</span>next<span class="token operator">=</span><span class="token punctuation">;</span> 
<span class="token comment">//采用尾插入法 //if(q-&gt;rear==){ </span>
<span class="token comment">//使用此方法也可以 </span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">empty</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
    q<span class="token operator">-&gt;</span>front<span class="token operator">=</span>n<span class="token punctuation">;</span> q<span class="token operator">-&gt;</span>rear<span class="token operator">=</span>n<span class="token punctuation">;</span> 
  <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span> 
    q<span class="token operator">-&gt;</span>rear<span class="token operator">-&gt;</span>next<span class="token operator">=</span>n<span class="token punctuation">;</span> 
<span class="token comment">//n成为当前尾结点的下一结点 </span>
    q<span class="token operator">-&gt;</span>rear<span class="token operator">=</span>n<span class="token punctuation">;</span> 
<span class="token comment">//让尾指针指向n </span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_137"></a>五、出队操作</h2> 
<p>出队操作变化图：<br> <img src="https://images2.imgbox.com/b9/90/UKcY0XV3_o.png" alt=""></p> 
<p>出队(pop)操作，是指在队列不为空的情况下进行的一个判断，当然在此也一定要进行队列判空的操。</p> 
<p>如图，如果队列只有一个元素了，也就是说<strong>头尾指针</strong>均指向了<strong>同一个结点</strong>，那么直接将头尾两指针置空，并释放这一个结点即可，如图：<br> <img src="https://images2.imgbox.com/19/a4/gxWLlEBH_o.png" alt=""></p> 
<p>当队列含有以上个元素时，需要将<strong>队列的头指针</strong>指向<strong>头指针当前指向的下一个元素</strong>，并释放掉当前元素即可，如图：<br> <img src="https://images2.imgbox.com/7d/a4/uxpQRv24_o.png" alt=""></p> 
<p>其代码可以表示为：</p> 
<pre><code class="prism language-java"><span class="token comment">//出队操作</span>
<span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span>queue <span class="token operator">*</span>q<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
  node <span class="token operator">*</span>n<span class="token operator">=</span>q<span class="token operator">-&gt;</span>front<span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">empty</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token punctuation">;</span> 
<span class="token comment">//此时队列为空，直接返回函数结束 </span>
  <span class="token punctuation">}</span> 
  <span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token operator">-&gt;</span>front<span class="token operator">==</span>q<span class="token operator">-&gt;</span>rear<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> 
    q<span class="token operator">-&gt;</span>front<span class="token operator">=</span><span class="token punctuation">;</span> 
<span class="token comment">//只有一个元素时直接将两端指向置为空即可 </span>
    q<span class="token operator">-&gt;</span>rear<span class="token operator">=</span><span class="token punctuation">;</span> <span class="token function">free</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">//记得归还内存空间 </span>
  <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span> 
    q<span class="token operator">-&gt;</span>front<span class="token operator">=</span>q<span class="token operator">-&gt;</span>front<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span> <span class="token function">free</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_170"></a>六、打印队列元素(遍历)</h2> 
<p>打印队列的全部元素可以帮助调试，看到队列中具体的数据，在队列不为空的情况下，通过结点的 **next **指向依次遍历并输出元素既可。其代码可以表示为：</p> 
<pre><code class="prism language-java"><span class="token comment">//打印队列元素</span>
<span class="token keyword">void</span> <span class="token function">print_queue</span><span class="token punctuation">(</span>queue <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> 
node <span class="token operator">*</span>n <span class="token operator">=</span> init_node<span class="token punctuation">;</span> 
n<span class="token operator">=</span>q<span class="token operator">-&gt;</span>front<span class="token punctuation">;</span> 
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">empty</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> <span class="token punctuation">;</span> 
<span class="token comment">//此时队列为空，直接返回函数结束 } </span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">!=</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> 
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\t"</span><span class="token punctuation">,</span>n<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> 
n<span class="token operator">=</span>n<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">//记得换行}</span>
</code></pre> 
<p>遍历操作还有很多别的表示方法，比如说进行计算队列中含有多少元素，代码如下：</p> 
<pre><code class="prism language-java"><span class="token keyword">int</span> <span class="token function">calac</span><span class="token punctuation">(</span>queue <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> 
node <span class="token operator">*</span>n <span class="token operator">=</span> init_node<span class="token punctuation">;</span> 
n<span class="token operator">=</span>q<span class="token operator">-&gt;</span>front<span class="token punctuation">;</span> 
<span class="token keyword">int</span> cnt<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token comment">//计数器设计 </span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">empty</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> 
<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token comment">//此时队列为空，直接返回函数结束 </span>
<span class="token punctuation">}</span> 
<span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">!=</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 n<span class="token operator">=</span>n<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span> cnt<span class="token operator">++</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 
<span class="token keyword">return</span> cnt<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_205"></a>七、顺序队列的假溢出</h2> 
<p>什么是假溢出？这里需要考虑到顺序队列有什么缺点，对于顺序队列而言，其存在已经足够解决大多时候的设计问题了，但是其依旧存在一些缺陷和不足。</p> 
<p>从上面的解析中看到，入队和出队操作均是直接在其后面进行结点的链接和删除，这种操作会造成其使用空间不断向出队的那一边偏移，产生假溢出。</p> 
<p>来打一个比方，先看图：<br> <img src="https://images2.imgbox.com/08/1b/goUZBGT4_o.png" alt=""></p> 
<p>上图所示，有一个顺序队列，这个队列的大小为5，其已经包含了四个元素 <strong>data1 , data2 , data3 , data4</strong>。</p> 
<p>接着，对这个队列进行出队操作，出队2个元素，队列就变成了这个样子，如图：<br> <img src="https://images2.imgbox.com/8a/eb/8PUbEbNw_o.png" alt=""></p> 
<p>从图上看到似乎没有什么问题，但是当接着再进行入队操作，比如入队2个元素，分别是 <strong>data5</strong>和** data6**。</p> 
<p>此时已经发现问题了，尾指针移动到可以进行队列操作的范围之外去了，有没有发现？</p> 
<p>这种现象称呼作为队列用的存储区还没有满，但队列却发生了溢出，把这种现象称为<strong>假溢出</strong>。如图：<br> <img src="https://images2.imgbox.com/bd/79/2rcOSkIY_o.png" alt=""></p> 
<p>那么有什么办法解决这个问题呢？这就要涉及到循环队列的性质了！</p> 
<h2><a id="_228"></a>八、循环队列的概念</h2> 
<p>可能这个时候会产生一个疑问，学习的队列不是使用链表实现的动态队列么？<strong>没有空间的时候会开辟空间，这难道还会产生假溢出么？<strong>的确，当进行动态创建队列的时候，也只不过是向后继续不断的申请内存空间；即使前面出队操作释放掉了前面的空间，但是指针依旧会</strong>向后进行移动</strong>，直到达到系统<strong>预留给程序的内存上界</strong>被强行终止；这对于极为频繁的队列操作和程序而言是致命的，这时候，就需要对我们的队列进行优化，使用更为优秀的结构——<strong>循环队列</strong>。</p> 
<p>循环队列就是将队列存储空间的最后一个位置转而绕到第一个位置，<strong>形成逻辑上的环状空间</strong>，以此来供队列循环使用，如图：<br> <img src="https://images2.imgbox.com/34/3d/DoC4Qkt8_o.png" alt=""></p> 
<p>循环队列就是给定队列的大小范围，在原有队列的基础上，只要队列的后方满了，就从这个队列的前面开始进行插入，以达到重复利用空间的效果；由于循环队列的设计思维更像一个环，因此常使用一个环图来表示，但我们需要注意，实际上循环队列不是一个真正的环，它依旧是单线性的。</p> 
<h2><a id="_237"></a>九、循环队列的结构设计</h2> 
<p>由于循环对列给定了数据范围的大小，所以不需要使用链式的动态创建方法了。因为如果使用链式存储，会无法确定何时再回到队头进行插入操作，所以采用<strong>模拟的方法</strong>，如图：<br> <img src="https://images2.imgbox.com/c3/7c/dCANNHI8_o.png" alt=""></p> 
<p>其中，data 表示一个数据域，int 为类型，其可以修改为任意自定义的类型，比如说简单的 char，float 类型等等，也可以是复杂的结构体类型。</p> 
<ul><li> <p><strong>maxsize</strong>表示循环队列的最大容纳量，其表示队列的全部可操作空间。</p> </li><li> <p><strong>rear</strong>代表尾指针，入队时移动。</p> </li><li> <p><strong>front</strong>代表头指针，出队时移动。</p> </li></ul> 
<p>其代码可以表示为：</p> 
<pre><code class="prism language-java">#define maxsize <span class="token number">10</span> 
<span class="token comment">//表示循环队列的最大容量</span>
<span class="token comment">//循环队列的结构设计</span>
typedef struct cir_queue<span class="token punctuation">{<!-- --></span> 
<span class="token keyword">int</span> data<span class="token punctuation">[</span>maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token keyword">int</span> rear<span class="token punctuation">;</span> 
<span class="token keyword">int</span> front<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
cir_queue<span class="token punctuation">;</span>
</code></pre> 
<h2><a id="_264"></a>十、循环队列的初始化</h2> 
<p>循环队列的初始化核心就在于申请空间，并且将 front 指针和 rear 指针内容赋值为0，即指向第0个元素即可，这里要注意第 0个元素内容为空，如图：<br> <img src="https://images2.imgbox.com/84/ba/aQKEa72l_o.png" alt=""></p> 
<p>其代码可以表示为：</p> 
<pre><code class="prism language-java"><span class="token comment">//初始化</span>
cir_queue <span class="token operator">*</span>init<span class="token punctuation">{<!-- --></span> 
cir_queue <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token punctuation">(</span>cir_queue<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token function">sizeof</span><span class="token punctuation">(</span>cir_queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token operator">==</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">//申请内存失败，退出程序 </span>
<span class="token punctuation">}</span> 
q<span class="token operator">-&gt;</span>front<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> 
q<span class="token operator">-&gt;</span>rear<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token keyword">return</span> q<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_284"></a>十一、循环队列的入队操作</h2> 
<p>入队操作同顺序队列的方法，直接将 rear 向后移动即可。但是要注意判断，如果 rea r达到了队列的空间上线，将要从头继续开始移动。这里推荐使用余数法，即无论如何求余都是在这片空间内进行操作，防止一次错误执行就直接整体崩溃，而且也相对而言更为简洁，不推荐使用 if 语句，这样显得比较累赘。<br> <img src="https://images2.imgbox.com/30/df/lydIwikn_o.png" alt=""></p> 
<p>注意进行加一移动位置操作的时候，不能直接 **q-&gt;rear++ **这样的操作，这样计算机判断优先级会产生让自己意想不到的后果。此外这里还需要进行一次是否队列已满的判断，当我们 rear 指针的下一个位置就是front的位置的时候，即改循环队列已满。如图：<br> <img src="https://images2.imgbox.com/d5/d4/ew6U2V38_o.png" alt=""></p> 
<p>其代码可以表示为：</p> 
<pre><code class="prism language-java"><span class="token comment">//入队操作</span>
pushvoid <span class="token function">push</span><span class="token punctuation">(</span>cir_queue <span class="token operator">*</span>q<span class="token punctuation">,</span><span class="token keyword">int</span> data<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> 
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>q<span class="token operator">-&gt;</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>maxsize<span class="token operator">==</span>q<span class="token operator">-&gt;</span>front<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> 
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"溢出，无法入队\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">return</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span> 
q<span class="token operator">-&gt;</span>rear<span class="token operator">=</span><span class="token punctuation">(</span>q<span class="token operator">-&gt;</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>maxsize<span class="token punctuation">;</span>
 q<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>q<span class="token operator">-&gt;</span>rear<span class="token punctuation">]</span><span class="token operator">=</span>data<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_306"></a>十二、循环队列的出队操作</h2> 
<p>如果顺序队列的出队操作，直接将 front 进行后移一位即可。</p> 
<p>这里上面很多地方都提过了，有一个需要留意的地方，即队列是否为空，当队列为空的时候是无法进行出队操作的。<br> <img src="https://images2.imgbox.com/57/51/1w9BvMGg_o.png" alt=""></p> 
<p>其代码可以表示为：</p> 
<pre><code class="prism language-java"><span class="token comment">//出队操作</span>
popvoid <span class="token function">pop</span><span class="token punctuation">(</span>cir_queue <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> 
<span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token operator">-&gt;</span>rear<span class="token operator">==</span>q<span class="token operator">-&gt;</span>front<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> 
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"队列为空，无法出队\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">return</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span> 
q<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>q<span class="token operator">-&gt;</span>front<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> 
q<span class="token operator">-&gt;</span>front<span class="token operator">=</span><span class="token punctuation">(</span>q<span class="token operator">-&gt;</span>front<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>maxsize<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="_328"></a>十三、循环队列的遍历操作</h2> 
<p>遍历操作需要借助一个临时变量储存位置 front 的位置信息，利用i逐步向后移动，直到 i 到达了 rear 的位置即可宣告遍历的结束。</p> 
<pre><code class="prism language-java"><span class="token comment">//遍历队列</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>cir_queue <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> 
<span class="token keyword">int</span> i<span class="token operator">=</span>q<span class="token operator">-&gt;</span>front<span class="token punctuation">;</span> 
<span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">!=</span>q<span class="token operator">-&gt;</span>rear<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> i<span class="token operator">=</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>maxsize<span class="token punctuation">;</span> 
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\t"</span><span class="token punctuation">,</span>q<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span> 
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">//记得换行</span>
<span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/359d9da354f2a244a2213b4a5395b79b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android studio jni开启debug的正确姿势</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ab16ff107394650d11541310173ad99d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SpringBoot测试类@Autowired无法获取Bean和Component</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>