<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>spring boot 使用AOP实现是否已登录检测 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="spring boot 使用AOP实现是否已登录检测" />
<meta property="og:description" content="前后端分离的开发中，用户http请求应用服务的接口时, 如果要求检测该用户是否已登录。可以实现的方法有多种， 本示例是通过aop 的方式实现，简单有效。
约定：前端http的post 请求
export async function request(url,data) { const config = { method: &#39;POST&#39;, headers: {&#39;Content-Type&#39;: &#39;application/json&#39;}, } //每个请求的参数要求附加sessionid, 该sessionid 是登录时生成的 const paramsData = Object.assign(data,{sessionid:globalData.sessionID || &#39;&#39;}) config.body = JSON.stringify(paramsData) try { const res = await window.fetch(url, config) if(res.status!==200){ return { status: res.status, data:{}, headers: res.headers, url: res.url, statusText:res.statusText } } return { status: res.status, data:await res.json(), headers: res.headers, url: res.url, } } catch (err) { return { status: 404, data:{}, headers: res." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/8edea449114ee052ebde4f8764beba2e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-16T17:30:56+08:00" />
<meta property="article:modified_time" content="2024-02-16T17:30:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">spring boot 使用AOP实现是否已登录检测</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p>        前后端分离的开发中，用户http请求应用服务的接口时, 如果要求检测该用户是否已登录。可以实现的方法有多种， 本示例是通过aop 的方式实现，简单有效。</p> 
<p>        约定：前端http的post 请求</p> 
<pre><code class="language-javascript">export async function request(url,data) {
    const config = {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
    }
	//每个请求的参数要求附加sessionid, 该sessionid 是登录时生成的
	const paramsData = Object.assign(data,{sessionid:globalData.sessionID || ''})
    config.body = JSON.stringify(paramsData)

    try {
      const res = await window.fetch(url, config)
      if(res.status!==200){
        return {
          status: res.status,
          data:{},
          headers: res.headers,
          url: res.url,
          statusText:res.statusText
        }
      }
    
      return {
        status: res.status,
        data:await res.json(),
        headers: res.headers,
        url: res.url,
      }
    
    } catch (err) {
      return {
        status: 404,
        data:{},
        headers: res.headers,
        url: res.url,
        statusText:'fetch error:'+err.toString()
      }
    }
  }
  </code></pre> 
<p></p> 
<p>1、在pom.xml 引用</p> 
<pre><code class="language-java">		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
		&lt;/dependency&gt;</code></pre> 
<p>2、创建插入标记</p> 
<pre><code class="language-java">
@Target({ElementType.METHOD}) // 只在对象方法上标记
@Retention(RetentionPolicy.RUNTIME) //运行时反射
public @interface Interceptor {
    String additionalMessage() default "";
}

</code></pre> 
<p>3、实现切入类</p> 
<pre><code class="language-java">
@Aspect
@Component
@Slf4j
public class LoggingAspect {

    @Autowired
    public StringRedisTemplate redisTemplatelocate;

    private  &lt;T&gt; T getSessionID(Object postData,Class&lt;T&gt; clazz){
        return (T)postData;
    }

    @Around("@annotation(Interceptor)") //有标记的地方将实现以下和切入
    public Object logExecutionTime(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        //获取切入方法的参数，就是前部请求的json数据
        Object[] args = proceedingJoinPoint.getArgs();

        //获取其中的sessionid
        // requestBase 实体类只有一个参sessionid , 做为其它实体类的父类，用于接收接口上传的参数。
        RequestBase requestBase=getSessionID(args[0],RequestBase.class);
        log.info("sessionid:{}",requestBase.getSessionid());

        //检测该sessionid 是否存在(redis)
        if (requestBase.getSessionid()==null || !redisTemplatelocate.hasKey(requestBase.getSessionid())) {
            //用户未登陆
            throw new Exception("用户未登陆");
        }

        //获取  request 和 response
        ServletRequestAttributes servletRequestAttributes = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes());
        log.info("request:{}",servletRequestAttributes.getRequest());
        log.info("response:{}",servletRequestAttributes.getResponse());

        MethodSignature methodSignature = (MethodSignature) proceedingJoinPoint.getSignature();
        String className = methodSignature.getDeclaringType().getSimpleName();
        String methodName = methodSignature.getMethod().getName();
        Instant startTime = Instant.now();
         //实行被切入的方法
        Object result = proceedingJoinPoint.proceed();
        
        String additionalMessage = methodSignature.getMethod().getAnnotation(Interceptor.class).additionalMessage();
        long elapsedTime = Duration.between(startTime, Instant.now()).toMillis();
        log.info("Class Name: {}, Method Name: {}, Additional Message: {}, Elapsed Time: {}ms",
                className, methodName, additionalMessage, elapsedTime);
        log.info("Result: {}", result);
        return result;
    }
}</code></pre> 
<p>4 建立api接口，在需要检测的方法上加入@Interceptor 就完成切入的检测。</p> 
<pre><code class="language-java">
@RestController
@Slf4j
public class ExampleController {

    @PostMapping("/t1")
    @Interceptor(additionalMessage = "要求检测登录")
    @ResponseBody
    public ResponseEntity&lt;RequestBase&gt; getData(@RequestBody DataRequest req) {
        try {
            return new ResponseEntity&lt;&gt;(req, HttpStatus.OK);
        } catch (Exception e) {
            return new ResponseEntity&lt;&gt;(null, HttpStatus.BAD_REQUEST);
        }
    }
}</code></pre> 
<p>5 实体类</p> 
<pre><code class="language-java">
@Data
public class DataRequest extends RequestBase {
    private  String name;
}


@Data
public class RequestBase{
    private String sessionid;
}
</code></pre> 
<p>   该方法只适用于少部分需要检测，而大部份不需要检测的情况下，如果整个包都需要检测的，利用execution方 法实现</p> 
<pre><code> @Pointcut("execution(public * com.example.myapp..*.*(..))")</code></pre> 
<pre><code class="language-java">
@Aspect
@Component
@Slf4j
public class LoginExecution {

    @Autowired
    public StringRedisTemplate redisTemplatelocate;

    private  &lt;T&gt; T getSessionID(Object postData,Class&lt;T&gt; clazz){
        return (T)postData;
    }

    //切入点： com.aop.ttt 下的所有public 方法
    @Pointcut("execution(public * com.aop.ttt..*.*(..))")
    public void publicMethods() {}

    @Around("publicMethods()")
    public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
        //获取切入方法的参数，就是前部请求的json数据
        Object[] args = joinPoint.getArgs();

        //获取其中的sessionid
        // requestBase 实体类只有一个参sessionid , 做为其它实体类的父类，用于接收接口上传的参数。
        RequestBase requestBase=getSessionID(args[0],RequestBase.class);
        log.info("sessionid:{}",requestBase.getSessionid());

        //检测该sessionid 是否存在(redis)
        if (requestBase.getSessionid()==null || !redisTemplatelocate.hasKey(requestBase.getSessionid())) {
            //用户未登陆
            throw new Exception("用户未登陆");
        }

        //获取  request 和 response
        ServletRequestAttributes servletRequestAttributes = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes());
        log.info("request:{}",servletRequestAttributes.getRequest());
        log.info("response:{}",servletRequestAttributes.getResponse());


        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();
        String className = methodSignature.getDeclaringType().getSimpleName();
        String methodName = methodSignature.getMethod().getName();
        Instant startTime = Instant.now();
        //实行被切入的方法
        Object result = joinPoint.proceed();


        long elapsedTime = Duration.between(startTime, Instant.now()).toMillis();
        log.info("Class Name: {}, Method Name: {}, Elapsed Time: {}ms",
                className, methodName, elapsedTime);
        log.info("Result: {}", result);
        return result;
    }
}
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6a5405ac67f170d3819f52e461d4a87a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python爬虫爬取图片 必应&amp;百度（仅供学习）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7e1fe84f6d1e29a5497086d7dbee46f0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Hive拉链表设计、实现、总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>