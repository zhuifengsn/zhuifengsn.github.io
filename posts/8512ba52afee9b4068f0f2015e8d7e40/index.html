<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>iOS进阶之多线程--NSThread详解 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="iOS进阶之多线程--NSThread详解" />
<meta property="og:description" content="iOS进阶之多线程–NSThread详解
https://www.jianshu.com/p/686dbf4bbb52
一个默默无闻的程序猿
1
2018.04.02 17:06:56
字数 1,856
阅读 8,643
NSThread简介
NSThread是苹果官方提供面向对象操作线程的技术，简单方便，可以直接操作线程对象，不过需要自己控制线程的生命周期。在平时使用很少，最常用到的无非就是 [NSThread currentThread]获取当前线程。
NSThread使用
1、 实例初始化、属性和实例方法
初始化
//创建线程
NSThread *newThread = [[NSThread alloc]initWithTarget:self selector:@selector(demo:) object:@“Thread”];
//或者
NSThread newThread=[[NSThread alloc]init];
NSThread newThread= [[NSThread alloc]initWithBlock:^{
NSLog(@“initWithBlock”);
}];
属性
线程字典
/
每个线程都维护了一个键-值的字典,它可以在线程里面的任何地方被访问。
你可以使用该字典来保存一些信息,这些信息在整个线程的执行过程中都保持不变。
比如,你可以使用它来存储在你的整个线程过程中 Run loop 里面多次迭代的状态信息。
NSThread实例可以使用一下方法
*/
@property (readonly, retain) NSMutableDictionary threadDictionary;
NSMutableDictionary dict = [thread threadDictionary];
优先级
@property double threadPriority ; //优先级
线程优先级
/ NSQualityOfService:
NSQualityOfServiceUserInteractive：最高优先级,主要用于提供交互UI的操作,比如处理点击事件,绘制图像到屏幕上
NSQualityOfServiceUserInitiated：次高优先级，主要用于执行需要立即返回的任务
NSQualityOfServiceDefault：默认优先级，当没有设置优先级的时候，线程默认优先级" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/8512ba52afee9b4068f0f2015e8d7e40/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-15T20:39:00+08:00" />
<meta property="article:modified_time" content="2020-09-15T20:39:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">iOS进阶之多线程--NSThread详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>iOS进阶之多线程–NSThread详解</p> 
<p>https://www.jianshu.com/p/686dbf4bbb52</p> 
<p>一个默默无闻的程序猿<br> 1<br> 2018.04.02 17:06:56<br> 字数 1,856<br> 阅读 8,643<br> NSThread简介<br> NSThread是苹果官方提供面向对象操作线程的技术，简单方便，可以直接操作线程对象，不过需要自己控制线程的生命周期。在平时使用很少，最常用到的无非就是 [NSThread currentThread]获取当前线程。</p> 
<p>NSThread使用<br> 1、 实例初始化、属性和实例方法<br> 初始化<br> //创建线程<br> NSThread *newThread = [[NSThread alloc]initWithTarget:self selector:@selector(demo:) object:@“Thread”];<br> //或者<br> NSThread <em>newThread=[[NSThread alloc]init];<br> NSThread <em>newThread= [[NSThread alloc]initWithBlock:^{<!-- --><br> NSLog(@“initWithBlock”);<br> }];<br> 属性<br> 线程字典<br> /</em></em><br> 每个线程都维护了一个键-值的字典,它可以在线程里面的任何地方被访问。<br> 你可以使用该字典来保存一些信息,这些信息在整个线程的执行过程中都保持不变。<br> 比如,你可以使用它来存储在你的整个线程过程中 Run loop 里面多次迭代的状态信息。<br> NSThread实例可以使用一下方法<br> */<br> @property (readonly, retain) NSMutableDictionary <em>threadDictionary;<br> NSMutableDictionary <em>dict = [thread threadDictionary];<br> 优先级<br> @property double threadPriority ; //优先级<br> 线程优先级<br> /</em></em> NSQualityOfService:<br> NSQualityOfServiceUserInteractive：最高优先级,主要用于提供交互UI的操作,比如处理点击事件,绘制图像到屏幕上<br> NSQualityOfServiceUserInitiated：次高优先级，主要用于执行需要立即返回的任务<br> NSQualityOfServiceDefault：默认优先级，当没有设置优先级的时候，线程默认优先级<br> NSQualityOfServiceUtility：普通优先级，主要用于不需要立即返回的任务<br> NSQualityOfServiceBackground：后台优先级，用于完全不紧急的任务<br> */<br> @property NSQualityOfService qualityOfService;<br> 线程名称<br> @property (nullable, copy) NSString <em>name;<br> 线程使用栈区大小，默认是512K<br> @property NSUInteger stackSize ;<br> 线程正在执行<br> @property (readonly, getter=isExecuting) BOOL executing;<br> 线程执行结束<br> @property (readonly, getter=isFinished) BOOL finished;<br> 线程是否可以取消<br> @property (readonly, getter=isCancelled) BOOL cancelled;<br> 实例方法<br> -(void)start; 启动线程<br> 实例化线程需要手动启动才能运行<br> [thread start];<br> -(BOOL)isMainThread; 是否为主线程<br> isMain=[thread isMainThread];<br> -(void)setName:(NSString <em>)n; 设置线程名称<br> [thread setName=@“The Second Thread”];<br> -(void)cancel ; 取消线程<br> [thread cancel];<br> -(void)main ; 线程的入口函数<br> [thread main];<br> -(void)isExecuting; 判断线程是否正在执行<br> BOOL isRunning=[thread isExecuting];<br> -(void)isFinished;判断线程是否已经结束<br> BOOL isEnd=[thread isFinished];<br> -(void)isCancelled; 判断线程是否撤销<br> isCancel=[thread isCancelled];<br> 2、类方法<br> 创建子线程并开始，注意以下两个类方法创建后就可执行，不需手动开启<br> /</em></em><br> block方式<br> */</p> 
<ul><li>(void)detachNewThreadWithBlock:(void (^)(void))block;<br> /**<br> SEL方式<br> */</li><li>(void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument;<br> +(void)currentThread;获取当前线程<br> [NSThread currentThread]<br> +(BOOL)isMultiThreaded; 当前代码运行所在线程是否是子线程<br> BOOL isMulti = [NSThread isMultiThreaded];<br> +(void)sleepUntilDate:(NSDate *)date; 当前代码所在线程睡到指定时间<br> [NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:1.0]];<br> +(void)sleepForTimeInterval:(NSTimeInterval)ti; 当前线程睡多长时间<br> [NSThread sleepForTimeInterval:1.0];<br> +(void)exit; 退出当前线程<br> [NSThread exit];<br> +(double)threadPriority; 设置当前线程优先级<br> double dPriority=[NSThread threadPriority];<br> +(BOOL)setThreadPriority:(double)p; 给当前线程设定优先级，调度优先级的取值范围是0.0 ~ 1.0，默认0.5，值越大，优先级越高。<br> BOOL isSetting=[NSThread setThreadPriority:(0.0~1.0)];<br> +(NSArray *)callStackReturnAddresses;线程的调用都会有函数的调用函数的调用就会有栈返回地址的记录，在这里返回的是函 数调用返回的虚拟地址，说白了就是在该线程中函数调用的虚拟地址的数组<br> NSArray *addressArray=[NSThread callStackReturnAddresses];<br> +(NSArray <em>)callStackSymbols 同上面的方法一样，只不过返回的是该线程调用函数的名字数字<br> NSArray</em> nameNumArray=[NSThread callStackSymbols];<br> 注意：callStackReturnAddress和callStackSymbols这两个函数可以同NSLog联合使用来跟踪线程的函数调用情况，是编程调试的重要手段</li></ul> 
<p>3、隐式创建&amp;线程间通讯<br> 以下方法位于NSObject (NSThreadPerformAdditions)分类中，所有继承NSObject 实例化对象都可调用以下方法</p> 
<p>/**<br> 指定方法在主线程中执行<br> 参数1. SEL 方法<br> 2.方法参数<br> 3.是否等待当前执行完毕<br> 4.指定的Runloop model<br> */</p> 
<ul><li>(void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;</li><li>(void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;<br> // equivalent to the first method with kCFRunLoopCommonModes<br> /**<br> 指定方法在某个线程中执行<br> 参数1. SEL 方法<br> 2.方法参数<br> 3.是否等待当前执行完毕<br> 4.指定的Runloop model<br> */</li><li>(void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));</li><li>(void)performSelector:(SEL)aSelector onThread:(NSThread <em>)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));<br> // equivalent to the first method with kCFRunLoopCommonModes<br> /</em>*<br> 指定方法在开启的子线程中执行<br> 参数1. SEL 方法<br> 2.方法参数<br> */</li><li>(void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));<br> 注意：我们经常提到的“线程间通讯”其实就是上面几个方法，并不是多高大上，也没有多复杂！！！</li></ul> 
<p>再注意：苹果声明UI更新一定要在UI线程（主线程）中执行，虽然不是所有后台线程更新UI都会出错。<br> 4、线程间资源共享&amp;线程加锁<br> 在程序运行过程中，如果存在多线程，那么各个线程读写资源就会存在先后、同时读写资源的操作，因为是在不同线程，CPU调度过程中我们无法保证哪个线程会先读写资源，哪个线程后读写资源。因此为了防止数据读写混乱和错误的发生，我们要将线程在读写数据时加锁，这样就能保证操作同一个数据对象的线程只有一个，当这个线程执行完成之后解锁，其他的线程才能操作此数据对象。NSLock / NSConditionLock / NSRecursiveLock / @synchronized都可以实现线程上锁的操作。</p> 
<p>@synchronized<br> 直接上例子：相信12306卖火车票的例子大家了解<br> 首先：开启两个线程同时售票<br> self.tickets = 20;<br> NSThread *t1 = [[NSThread alloc]initWithTarget:self selector:@selector(saleTickets) object:nil];<br> t1.name = @“售票员A”;<br> [t1 start];</p> 
<pre><code>NSThread *t2 = [[NSThread alloc]initWithTarget:self selector:@selector(saleTickets) object:nil];
t2.name = @"售票员B";
[t2 start];
</code></pre> 
<p>然后：将售票的方法加锁</p> 
<ul><li>(void)saleTickets{<!-- --><br> while (YES) {<!-- --><br> [NSThread sleepForTimeInterval:1.0];<br> //互斥锁 – 保证锁内的代码在同一时间内只有一个线程在执行<br> @synchronized (self){<!-- --><br> //1.判断是否有票<br> if (self.tickets &gt; 0) {<!-- --><br> //2.如果有就卖一张<br> self.tickets --;<br> NSLog(@“还剩%d张票 %@”,self.tickets,[NSThread currentThread]);<br> }else{<!-- --><br> //3.没有票了提示<br> NSLog(@“卖完了 %@”,[NSThread currentThread]);<br> break;<br> }<br> }<br> }</li></ul> 
<p>}<br> NSLock<br> -(BOOL)tryLock;//尝试加锁，成功返回YES ；失败返回NO ，但不会阻塞线程的运行<br> -(BOOL)lockBeforeDate:(NSDate *)limit;//在指定的时间以前得到锁。YES:在指定时间之前获得了锁；NO：在指定时间之前没有获得锁。<br> 该线程将被阻塞，直到获得了锁，或者指定时间过期。</p> 
<ul><li>(void)setName:(NSString*)newName//为锁指定一个Name</li><li>(NSString*)name//<strong>返回锁指定的</strong>name<br> @property (nullable, copy) NSString *name;线程锁名称<br> 举个例子：</li></ul> 
<p>NSLock* myLock=[[NSLock alloc]init];<br> NSString *str=@“hello”;<br> [NSThread detachNewThreadWithBlock:^{<!-- --><br> [myLock lock];<br> NSLog(@"%@",str);<br> str=@“world”;<br> [myLock unlock];<br> }];<br> [NSThread detachNewThreadWithBlock:^{<!-- --><br> [myLock lock];<br> NSLog(@"%@",str);<br> str=@“变化了”;<br> [myLock unlock];<br> }];<br> 输出结果不加锁之前，两个线程输出一样 hello；加锁之后，输出分辨为hello 与world。</p> 
<p>NSConditionLock<br> 使用此锁，在线程没有获得锁的情况下，阻塞，即暂停运行，典型用于生产者／消费者模型。</p> 
<ul><li> <p>(instancetype)initWithCondition:(NSInteger)condition;//初始化条件锁</p> </li><li> <p>(void)lockWhenCondition:(NSInteger)condition;//加锁 （条件是：锁空闲，即没被占用；条件成立）</p> </li><li> <p>(BOOL)tryLock; //尝试加锁，成功返回TRUE，失败返回FALSE</p> </li><li> <p>(BOOL)tryLockWhenCondition:(NSInteger)condition;//在指定条件成立的情况下尝试加锁，成功返回TRUE，失败返回FALSE</p> </li><li> <p>(void)unlockWithCondition:(NSInteger)condition;//在指定的条件成立时，解锁</p> </li><li> <p>(BOOL)lockBeforeDate:(NSDate *)limit;//在指定时间前加锁，成功返回TRUE，失败返回FALSE，</p> </li><li> <p>(BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;//条件成立的情况下，在指定时间前加锁，成功返回TRUE，失败返回FALSE，<br> @property (readonly) NSInteger condition;//条件锁的条件<br> @property (nullable, copy) NSString *name;//条件锁的名称<br> 举个例子：</p> <p>NSConditionLock* myCondition=[[NSConditionLock alloc]init];<br> [NSThread detachNewThreadWithBlock:^{<!-- --><br> for(int i=0;i&lt;5;i++)<br> {<!-- --><br> [myCondition lock];<br> NSLog(@“当前解锁条件：%d”,i);<br> sleep(2);<br> [myCondition unlockWithCondition:i];<br> BOOL isLocked=[myCondition tryLockWhenCondition:2];<br> if(isLocked)<br> {<!-- --><br> NSLog(@“加锁成功！！！！！”);<br> [myCondition unlock];<br> }<br> }<br> }];<br> 输出结果，在条件2 解锁之后，等待条件2 的锁加锁成功。</p> </li></ul> 
<p>NSRecursiveLock<br> 此锁可以在同一线程中多次被使用，但要保证加锁与解锁使用平衡，多用于递归函数，防止死锁。</p> 
<ul><li>(BOOL)tryLock;//尝试加锁，成功返回TRUE，失败返回FALSE</li><li>(BOOL)lockBeforeDate:(NSDate *)limit;//在指定时间前尝试加锁，成功返回TRUE，失败返回FALSE<br> @property (nullable, copy) NSString *name;//线程锁名称<br> 使用示例：</li></ul> 
<p>-(void)initRecycle:(int)value<br> {<!-- --><br> [myRecursive lock];<br> if(value&gt;0)<br> {<!-- --><br> NSLog(@“当前的value值：%d”,value);<br> sleep(2);<br> [self initRecycle:value-1];<br> }<br> [myRecursive unlock];<br> }<br> 输出结果： 从你传入的数值一直到1，不会出现死锁</p> 
<p>5、线程安全之原子属性 atomic<br> 原子属性（线程安全）与非原子属性，平时我们@property声明对象属性时会用到nonatomic，是什么意思呢？<br> 苹果系统在我们声明对象属性时默认是atomic，也就是说在读写这个属性的时候，保证同一时间内只有一个线程能够执行。当声明时用的是atomic，通常会生成 _成员变量 如果同时重写了getter&amp;setter _成员变量 就不自动生成。实际上原子属性内部有一个锁，叫做“自旋锁”。<br> 首先我们比较一下“自旋锁” &amp; “互斥锁”的异同，然后回答上面的问题</p> 
<p>共同点<br> 都能够保证线程安全<br> 不同点<br> 互斥锁：如果其他线程正在执行锁定的代码，此线程就会进入休眠状态，等待锁打开；然后被唤醒<br> 自旋锁：如果线程被锁在外面，哥么就会用死循环的方式一直等待锁打开！<br> 无论什么锁，都很消耗性能，效率不高，所以在我们平时开发过程中，会使用nonatomic</p> 
<p>@property (strong, nonatomic) NSObject *myNonatomic;<br> @property (strong, atomic) NSObject *myAtomic;<br> 根据上面描述，我们得出结论，当我们重写了myAtomic的setter和getter方法</p> 
<ul><li>(void)setMyAtomic:(NSObject *)myAtomic{<!-- --><br> _myAtomic = myAtomic;<br> }</li><li>(NSObject *)myAtomic{<!-- --><br> return _myAtomic;<br> }<br> 那么我们就必须声明一个_myAtomic静态变量</li></ul> 
<p>@synthesize myAtomic = _myAtomic;<br> 否则系统在编译的时候找不到 _myAtomic</p> 
<p>6、子线程上的Runloop<br> 在介绍子线程上的Runloop之前先来一个有意思的小插曲，我们来介绍一下Runloop，甚至模拟一个Runloop<br> Runloop 运行循环<br> -在目前iOS开发中，几乎用不到，在以前iOS黑暗时代，程序员会用到<br> 目的：<br> 保证程序不退出<br> 监听事件<br> 没有事件让程序进入休眠<br> 区分模式：<br> NSDefaultRunLoopMode - 时钟、网络事件<br> NSRunLoopCommonModes - 用户交互<br> 模拟Runloop</p> 
<p>void click(int type){<!-- --><br> printf(“正在运行第%d”,type);<br> }<br> int main(int argc, const char * argv[]) {<!-- --><br> @autoreleasepool {<!-- --><br> while (YES) {<!-- --><br> printf(“请输入选项 0 表示退出”);<br> int result = -1;<br> scanf("%d",&amp;result);<br> if (result == 0) {<!-- --><br> printf(“程序结束\n”);<br> break;<br> }else{<!-- --><br> click(result);<br> }<br> }<br> }<br> return 0;<br> }<br> 在iOS中，开辟的子线程上的Runloop是默认不开启的，并且子线程中的Runloop开启之后是手动无法关闭的。那么当我们给子线程中重复添加不同任务时并且Runloop没有开启的情况下，子线程无法监听事件（确切说是子线程的Runloop），我们后来添加的任务就无法执行。<br> 但是我们如果让子线程Runloop一直工作又浪费资源，下面介绍一个OC中常用到的可以控制子线程Runloop的例子：<br> 首先，Runloop就是一个死循环，那么我们就创建一个死循环，然后声明一个可以判断是否应该退出Runloop循环的属性<br> @property (assign, nonatomic, getter=isFinished) BOOL finished;<br> 创建子线程并添加任务</p> 
<pre><code>NSThread *t = [[NSThread alloc]initWithTarget:self selector:@selector(demo) object:nil];
[t start];
self.finished = NO;
[self performSelector:@selector(otherMethod) onThread:t withObject:nil waitUntilDone:NO];
</code></pre> 
<p>在第一个任务中加入死循环</p> 
<ul><li>(void)demo{<!-- --><br> NSLog(@"%@",[NSThread currentThread]);<br> //在OC中使用比较多的，退出循环的方式<br> while (!self.isFinished) {<!-- --><br> [[NSRunLoop currentRunLoop]runMode:NSDefaultRunLoopMode beforeDate:[NSDate dateWithTimeIntervalSinceNow:.1]];<br> }<br> NSLog(@“能来吗？”);<br> }</li></ul> 
<p>在最后添加的任务结束后结束死循环</p> 
<ul><li> <p>(void)otherMethod{<!-- --><br> for (int i = 0; i &lt; 10; i ++) {<!-- --><br> NSLog(@"%s %@",<strong>FUNCTION</strong>,[NSThread currentThread]);</p> <p>}<br> //让上面方法中的死循环结束<br> self.finished = YES;<br> }</p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/26baad0cb25467ef3e890d55aa996631/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">人机交互基础教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b1edd1887db799395f930a286d1ff4e2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">页面一次性加载数据过多时，页面卡死怎么办</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>