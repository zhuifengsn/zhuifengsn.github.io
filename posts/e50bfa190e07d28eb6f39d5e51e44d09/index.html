<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一文深度讲解JVM 内存分析工具 MAT及实践（建议收藏） - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="一文深度讲解JVM 内存分析工具 MAT及实践（建议收藏）" />
<meta property="og:description" content="1. 前言
熟练掌握 MAT 是 Java 高手的必备能力，但实践时大家往往需面对众多功能，眼花缭乱不知如何下手，小编也没有找到一篇完善的教学素材，所以整理本文帮大家系统掌握 MAT 分析工具。
本文详细讲解 MAT 众多内存分析工具功能，这些功能组合使用异常强大，熟练使用几乎可以解决所有的堆内存离线分析的问题。我们将功能划分为4类：内存分布详情、对象间依赖、对象状态详情、按条件检索。每大类有多个功能点，本文会逐一讲解各功能的场景及用法。此外，添加了原创或引用案例加强理解和掌握。
如图所示：
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
为减少对眼花缭乱的菜单的迷茫，可以通过下图先整体熟悉下各功能使用入口，后续都会讲到。
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
2. 内存分布详解及实战
2.1 全局信息概览
功能：展现堆内存大小、对象数量、class 数量、class loader 数量、GC Root 数量、环境变量、线程概况等全局统计信息。
使用入口：MAT 主界面 → Heap Dump Overview。
举例：下面是对象数量、class loader 数量、GC Root 数量，可以看出 class loader 存在异常。
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
举例：下图是线程概况，可以查看每个线程名、线程的 Retained Heap、daemon 属性等。
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
使用场景 全局概览呈现全局统计信息，重点查看整体是否有异常数据，所以有效信息有限，下面几种场景有一定帮助：
方法区溢出时（Java 8后不使用方法区，对应堆溢出），查看 class 数量异常多，可以考虑是否为动态代理类异常载入过多或类被反复重复加载。
方法区溢出时，查看 class loader 数量过多，可以考虑是否为自定义 class loader 被异常循环使用。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/e50bfa190e07d28eb6f39d5e51e44d09/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-05T10:32:24+08:00" />
<meta property="article:modified_time" content="2023-05-05T10:32:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一文深度讲解JVM 内存分析工具 MAT及实践（建议收藏）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1. 前言</p> 
<p>熟练掌握 MAT 是 Java 高手的必备能力，但实践时大家往往需面对众多功能，眼花缭乱不知如何下手，小编也没有找到一篇完善的教学素材，所以整理本文帮大家系统掌握 MAT 分析工具。</p> 
<p>本文详细讲解 MAT 众多内存分析工具功能，这些功能组合使用异常强大，熟练使用几乎可以解决所有的堆内存离线分析的问题。我们将功能划分为4类：内存分布详情、对象间依赖、对象状态详情、按条件检索。每大类有多个功能点，本文会逐一讲解各功能的场景及用法。此外，添加了原创或引用案例加强理解和掌握。</p> 
<p>如图所示：</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/64/70/s8TaJYNO_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>为减少对眼花缭乱的菜单的迷茫，可以通过下图先整体熟悉下各功能使用入口，后续都会讲到。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/fc/14/jSEGnFi1_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>2. 内存分布详解及实战</p> 
<p>2.1 全局信息概览</p> 
<p>功能：展现堆内存大小、对象数量、class 数量、class loader 数量、GC Root 数量、环境变量、线程概况等全局统计信息。</p> 
<p>使用入口：MAT 主界面 → Heap Dump Overview。</p> 
<p>举例：下面是对象数量、class loader 数量、GC Root 数量，可以看出 class loader 存在异常。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/26/7e/AuCqCxpb_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>举例：下图是线程概况，可以查看每个线程名、线程的 Retained Heap、daemon 属性等。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/23/2b/UJ63Vi7v_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>使用场景 全局概览呈现全局统计信息，重点查看整体是否有异常数据，所以有效信息有限，下面几种场景有一定帮助：</p> 
<ul><li> <p>方法区溢出时（Java 8后不使用方法区，对应堆溢出），查看 class 数量异常多，可以考虑是否为动态代理类异常载入过多或类被反复重复加载。</p> </li><li> <p>方法区溢出时，查看 class loader 数量过多，可以考虑是否为自定义 class loader 被异常循环使用。</p> </li><li> <p>GC Root 过多，可以查看 GC Root 分布，理论上这种情况极少会遇到，笔者只在 JNI 使用一个存在 BUG 的库时遇到过。</p> </li><li> <p>线程数过多，一般是频繁创建线程但无法执行结束，从概览可以了解异常表象，具体原因可以参考本文线程分析部分内容，此处不展开。</p> </li></ul> 
<p>2.2 Dominator tree</p> 
<p>注：笔者使用频率的 Top1，是高效分析 Dump 必看的功能。</p> 
<p>功能</p> 
<ul><li> <p>展现对象的支配关系图，并给出对象支配内存的大小（支配内存等同于 Retained Heap，即其被 GC 回收可释放的内存大小）</p> </li><li> <p>支持排序、支持按 package、class loader、super class、class 聚类统计</p> </li></ul> 
<p>使用入口：全局支配树： MAT 主界面 → Dominator tree。</p> 
<p>举例： 下图中通过查看 Dominator tree，了解到内存主要是由 ThreadAndListHolder-thread 及 main 两个线程支配（后面第2.6节会给出整体案例）。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e3/a1/3J769jNF_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>使用场景</p> 
<ul><li> <p>开始 Dump 分析时，首先应使用 Dominator tree 了解各支配树起点对象所支配内存的大小，进而了解哪几个起点对象是 GC 无法释放大内存的原因。</p> </li><li> <p>当个别对象支配树的 Retained Heap 很大存在明显倾斜时，可以重点分析占比高的对象支配关系，展开子树进一步定位到问题根因，如下图中可看出最终是 SameContentWrapperContainer 对象持有的 ArrayList 过大。</p> </li></ul> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6f/94/zqsaHTbM_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<ul><li> <p>在 Dominator tree 中展开树状图，可以查看支配关系路径（与 outgoing reference 的区别是：如果 X 支配 Y，则 X 释放后 Y必然可释放；如果仅仅是 X 引用 Y，可能仍有其他对象引用 Y，X 释放后 Y 仍不能释放，所以 Dominator tree 去除了 incoming reference 中大量的冗余信息）。</p> </li><li><li> <p>有些情况下可能并没有支配起点对象的 Retained Heap 占用很大内存（比如 class X 有100个对象，每个对象的 Retained Heap 是10M，则 class X 所有对象实际支配的内存是 1G，但可能 Dominator tree 的前20个都是其他class 的对象），这时可以按 class、package、class loader 做聚合，进而定位目标。</p> </li><li><li> <p>下图中各 GC Roots 所支配的内存均不大，这时需要聚合定位爆发点。</p> </li></ul> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e2/da/I0Va4yLw_o.jpg"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>在 Dominator tree 展现后按 class 聚合，如下图：</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/8c/71/PlcTlFNY_o.jpg"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>可以定位到是 SomeEntry 对象支配内存较多，然后结合代码进一步分析具体原因。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/38/f8/2dhgbvQ4_o.jpg"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>在一些操作后定位到异常持有 Retained Heap 对象后（如从代码看对象应该被回收），可以获取对象的直接支配者，操作方式如下。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/66/58/k69XRoWJ_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a4/81/pzCgqblH_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>2.3 Histogram 直方图</p> 
<p>注：笔者使用频率 Top2</p> 
<p>功能</p> 
<ul><li> <p>罗列每个类实例的数量、类实例累计内存占比，包括自身内存占用量（Shallow Heap）及支配对象的内存占用量（Retain Heap）。</p> </li><li> <p>支持按对象数量、Retained Heap、Shallow Heap（默认排序）等指标排序；支持按正则过滤；支持按 package、class loader、super class、class 聚类统计，</p> </li></ul> 
<p>使用入口：MAT 主界面 → Histogram；注意 Histogram 默认不展现 Retained Heap，可以使用计算器图标计算，如下图所示。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/8a/d1/6J4gjT3Q_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>使用场景</p> 
<ul><li> <p>有些情况 Dominator tree 无法展现出热点对象（上文提到 Dominator tree 支配内存排名前20的占比均不高，或者按 class 聚合也无明显热点对象，此时 Dominator tree 很难做关联分析判断哪类对象占比高），这时可以使用 Histogram 查看所有对象所属类的分布，快速定位占据 Retained Heap 大头的类。</p> </li></ul> 
<p>使用技巧</p> 
<ul><li> <p>Integer，String 和 Object[] 一般不直接导致内存问题。为更好的组织视图，可以通过 class loader 或 package 分组进一步聚焦，如下图。</p> </li></ul> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/50/3b/ajTaYaw9_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>Histogram 支持使用正则表达式来过滤。例如，我们可以只展示那些匹配com.q.*的类。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/99/5e/ai3f3gVG_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>可以在 Histogram 的某个类继续使用 outgoing reference 查看对象分布，进而定位哪些对象是大头</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/57/d3/NLKk7IzN_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/cd/ab/XMzLB5CF_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>2.4 Leak Suspects</p> 
<p>功能：具备自动检测内存泄漏功能，罗列可能存在内存泄漏的问题点。</p> 
<p>使用入口：一般当存在明显的内存泄漏时，分析完Dump文件后就会展现，也可以如下图在 MAT 主页 → Leak Suspects。</p> 
<p>使用场景：需要查看引用链条上占用内存较多的可疑对象。这个功能可解决一些基础问题，但复杂的问题往往帮助有限。</p> 
<p>举例</p> 
<ul><li> <p>下图中 Leak Suspects 视图展现了两个线程支配了绝大部分内存。</p> </li></ul> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f8/e1/Mpgslpbf_o.jpg"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>下图是点击上图中 Keywords 中 "Details" ,获取实例到 GC Root 的最短路径、dominator 路径的细信息。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a7/47/8mvJdXWO_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>2.5 Top Consumers</p> 
<p>功能：最大对象报告，可以展现哪些类、哪些 class loader、哪些 package 占用最高比例的内存，其功能 Histogram 及 Dominator tree 也都支持。</p> 
<p>使用场景：应用程序发生内存泄漏时，查看哪些泄漏的对象通常在 Dump 快照中会占很大的比重。因此，对简单的问题具有较高的价值。</p> 
<p>2.6 综合案例一</p> 
<p>使用工具项：Heap dump overview、Dominator tree、Histogram、Class Loader Explorer（见3.4节）、incoming references（见3.1节）</p> 
<p>程序代码</p> 
<pre></pre> 
<pre></pre> 
<p>package com.q.mat; import java.util.*; import org.objectweb.asm.*; public class ClassLoaderOOMOps extends ClassLoader implements Opcodes { public static void main(final String args[]) throws Exception { new ThreadAndListHolder(); // ThreadAndListHolder 类中会加载大对象 List&lt;ClassLoader&gt; classLoaders = new ArrayList&lt;ClassLoader&gt;(); final String className = "ClassLoaderOOMExample"; final byte[] code = geneDynamicClassBytes(className); // 循环创建自定义 class loader，并加载 ClassLoaderOOMExample while (true) { ClassLoaderOOMOps loader = new ClassLoaderOOMOps(); Class&lt;?&gt; exampleClass = loader.defineClass(className, code, 0, code.length); //将二进制流加载到内存中 classLoaders.add(loader); // exampleClass.getMethods()[0].invoke(null, new Object[]{null}); // 执行自动加载类的方法，通过反射调用main } } private static byte[] geneDynamicClassBytes(String className) throws Exception { ClassWriter cw = new ClassWriter(0); cw.visit(V1_1, ACC_PUBLIC, className, null, "java/lang/Object", null); //生成默认构造方法 MethodVisitor mw = cw.visitMethod(ACC_PUBLIC, "&lt;init&gt;", "()V", null, null); //生成构造方法的字节码指令 mw.visitVarInsn(ALOAD, 0); mw.visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "&lt;init&gt;", "()V"); mw.visitInsn(RETURN); mw.visitMaxs(1, 1); mw.visitEnd(); //生成main方法 mw = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, "main", "([Ljava/lang/String;)V", null, null); //生成main方法中的字节码指令 mw.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;"); mw.visitLdcInsn("Hello world!"); mw.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V"); mw.visitInsn(RETURN); mw.visitMaxs(2, 2); mw.visitEnd(); //字节码生成完成 return cw.toByteArray(); // 获取生成的class文件对应的二进制流 } }</p> 
<pre></pre> 
<p>package com.q.mat; import java.util.*; import org.objectweb.asm.*; public class ThreadAndListHolder extends ClassLoader implements Opcodes { private static Thread innerThread1; private static Thread innerThread2; private static final SameContentWrapperContainerProxy sameContentWrapperContainerProxy = new SameContentWrapperContainerProxy(); static { // 启用两个线程作为 GC Roots innerThread1 = new Thread(new Runnable() { public void run() { SameContentWrapperContainerProxy proxy = sameContentWrapperContainerProxy; try { Thread.sleep(60 * 60 * 1000); } catch (Exception e) { System.exit(1); } } }); innerThread1.setName("ThreadAndListHolder-thread-1"); innerThread1.start(); innerThread2 = new Thread(new Runnable() { public void run() { SameContentWrapperContainerProxy proxy = proxy = sameContentWrapperContainerProxy; try { Thread.sleep(60 * 60 * 1000); } catch (Exception e) { System.exit(1); } } }); innerThread2.setName("ThreadAndListHolder-thread-2"); innerThread2.start(); } } class IntArrayListWrapper { private ArrayList&lt;Integer&gt; list; private String name; public IntArrayListWrapper(ArrayList&lt;Integer&gt; list, String name) { this.list = list; this.name = name; } } class SameContentWrapperContainer { // 2个Wrapper内部指向同一个 ArrayList，方便学习 Dominator tree IntArrayListWrapper intArrayListWrapper1; IntArrayListWrapper intArrayListWrapper2; public void init() { // 线程直接支配 arrayList，两个 IntArrayListWrapper 均不支配 arrayList，只能线程运行完回收 ArrayList&lt;Integer&gt; arrayList = generateSeqIntList(10 * 1000 * 1000, 0); intArrayListWrapper1 = new IntArrayListWrapper(arrayList, "IntArrayListWrapper-1"); intArrayListWrapper2 = new IntArrayListWrapper(arrayList, "IntArrayListWrapper-2"); } private static ArrayList&lt;Integer&gt; generateSeqIntList(int size, int startValue) { ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(size); for (int i = startValue; i &lt; startValue + size; i++) { list.add(i); } return list; } } class SameContentWrapperContainerProxy { SameContentWrapperContainer sameContentWrapperContainer; public SameContentWrapperContainerProxy() { SameContentWrapperContainer container = new SameContentWrapperContainer(); container.init(); sameContentWrapperContainer = container; } }</p> 
<pre></pre> 
<p>启动参数：-Xmx512m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/Users/gjd/Desktop/dump/heapdump.hprof -XX:-UseCompressedClassPointers -XX:-UseCompressedOops</p> 
<p>引用关系图</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/38/9c/BDj8cb46_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>分析过程</p> 
<ol><li> <p>首先进入 Dominator tree，可以看出是 SameContentWrapperContainerProxy 对象与 main 线程两者持有99%内存不能释放导致 OOM。</p> </li></ol> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/0a/ef/qIXwE6ut_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/91/de/SksZvqmL_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>先来看方向一，在 Heap Dump Overview中可以快速定位到 Number of class loaders 数达50万以上，这种基本属于异常情况，如下图所示。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e5/9a/1CHDUIIG_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>使用 Class Loader Explorer 分析工具，此时会展现类加载详情，可以看到有524061个 class loader。我们的案例中仅有ClassLoaderOOMOps 这样的自定义类加载器，所以很快可以定位到问题。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/41/f2/1hY0UiW9_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c8/6e/OgjxmnLd_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>如果类加载器较多，不能确定是哪个引发问题，则可以将所有的 class loader对象按类做聚类，如下图所示。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/27/80/z7HQsE3f_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>Histogram 会根据 class 聚合，并展现对象数量及其 Shallow Heap 及 Retained Heap（如Retained Heap项目为空，可以点击下图中计算机的图标并计算 Retained Heap），可以看到 ClassLoaderOOMOps 有524044个对象，其 Retain Heap 占据了370M以上（上述代码是100M左右）。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/88/1a/1p6Ikbuy_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>使用 incoming references，可以找到创建的代码位置。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/62/46/QHB0lKHX_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>再来看方向二，同样在占据319M内存的 Obejct 数组采用 incoming references 查看引用路径，也很容易定位到具体代码位置。并且从下图中我们看出，Dominator tree 的起点并不一定是 GC根，且通过 Dominator tree 可能无法获取到最开始的创建路径，但 incoming references 是可以的。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/36/8a/6yccgJNQ_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>3. 对象间依赖详解及实战</p> 
<h3></h3> 
<p>3.1 References</p> 
<p>注：笔者使用频率 Top2</p> 
<p>功能：在对象引用图中查看某个特定对象的所有引用关系（提供对象对其他对象或基本类型的引用关系，以及被外部其他对象的引用关系）。通过任一对象的直接引用及间接引用详情（主要是属性值及内存占用），提供完善的依赖链路详情。</p> 
<p>使用入口：目标域右键 → List objects → with outgoing references/with incoming references.</p> 
<p>使用场景</p> 
<ul><li> <p>outgoing reference：查看对象所引用的对象，并支持链式传递操作。如查看一个大对象持有哪些内容，当一个复杂对象的 Retained Heap 较大时，通过 outgoing reference 可以查看由哪个属性引发的。下图中 A 支配 F，且 F 占据大量内存，但优化时 F 的直接支配对象 A 无法修改。可通过 outgoing reference 看关系链上 D、B、E、C，并结合业务逻辑优化中间环节，这依托 dominator tree 是做不到的。</p> </li><li><li> <p>incoming reference：查看对象被哪些对象引用，并支持链式传递操作。如查看一个大对象都被哪些对象引用，下图中 K 占内存大，所以 J 的 Retained Heap 较大，目标是从 GC Roots 摘除 J 引用，但在 Dominator tree 上 J 是树根，无法获取其被引用路径，可通过 incoming reference 查看关系链上的 H、X、Y ，并结合业务逻辑将 J 从 GC Root 链摘除。</p> </li></ul> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6d/63/0UIFnZU2_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>3.2 Thread overview</p> 
<p>功能：展现转储 dump 文件是线程执行栈、线程栈引用的对象等详细状态，也提供各线程的 Retained Heap 等关联内存信息。</p> 
<p>使用入口：MAT 主页 → Thread overview</p> 
<p>使用场景</p> 
<ul><li> <p>查看不同线程持有的内存占比，定位高内存消耗线程（开发技巧：不要直接使用 Thread 或 Executor 默认线程名避免全部混合在一起，使用线程尽量自命名方便识别，如下图中 ThreadAndListHolder-thread 是自定义线程名，可以很容易定位到具体代码）</p> </li><li> <p>查看线程的执行栈及变量，结合业务代码了解线程阻塞在什么地方，以及无法继续运行释放内存，如下图中 ThreadAndListHolder-thread 阻塞在 sleep 方法。</p> </li></ul> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ca/df/1O4NM9HE_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>3.3 Path To GC Roots</p> 
<p>功能：提供任一对象到 GC Root 的路径详情。</p> 
<p>使用入口：目标域右键 → Path To GC Roots</p> 
<p>使用场景：有时你确信已经处理了大的对象集合但依然无法回收，该功能能快速定位异常对象不能被 GC 回收的原因，直击异常对象到 GC Root 的引用路径。比 incoming reference 的优势是屏蔽掉很多不需关注的引用关系，比 Dominator tree 的优势是可以得到更全面的信息。</p> 
<p>小技巧：在排查内存泄漏时，建议选择 exclude all phantom/weak/soft etc.references 排除虚引用/弱引用/软引用等的引用链，因为被虚引用/弱引用/软引用的对象可以直接被 GC 给回收，聚焦在对象是否还存在 Strong 引用链即可。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/55/31/uEb0y2xH_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>3.4 class loader 分析</p> 
<p>功能</p> 
<ul><li> <p>查看堆中所有 class loader 的使用情况（入口：MAT 主页菜单蓝色桶图标 → Java Basics → Class Loader Explorer）。</p> </li><li> <p>查看堆中被不同class loader 重复加载的类（入口：MAT 主页菜单蓝色桶图标 → Java Basics → Duplicated Classes）。</p> </li></ul> 
<p>使用场景</p> 
<ul><li> <p>当从 Heap dump overview 了解到系统中 class loader 过多，导致占用内存异常时进入更细致的分析定位根因时使用。</p> </li><li> <p>解决 NoClassDefFoundError 问题或检测 jar 包是否被重复加载</p> </li></ul> 
<p>具体使用方法在 2.6 及 3.5 两节的案例中有介绍。</p> 
<p>3.5 综合案例二</p> 
<p>使用工具项：class loader（重复类检测）、inspector、正则检索。</p> 
<p>异常现象 ：运行时报 NoClassDefFoundError，在 classpath 中有两个不同版本的同名类。</p> 
<p>分析过程</p> 
<ol><li> <p>进入 MAT 已加载的重复类检测功能，方式如下图。</p> </li></ol> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/8e/0b/iKeieXHx_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>可以看到所有重复的类，以及相关的类加载器，如下图。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e4/25/cEGHRKGW_o.jpg"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<ul><li> <p>根据类名，在&lt;Regex&gt;框中输入类名可以过滤无效信息。</p> </li><li><li> <p>选中目标类，通过Inspector视图，可以看到被加载的类具体是在哪个jar包里。（本例中重复的类是被 URLClassloader 加载的，右键点击 “_context” 属性，最后点击 “Go Into”，在弹出的窗口中的属性 “_war” 值是被加载类的具体包位置）</p> </li></ul> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f0/3d/cTucAQFo_o.jpg"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e3/39/wGDNFqxS_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>4. 对象状态详解及实战</p> 
<h3></h3> 
<p>4.1 inspector</p> 
<p>功能：MAT 通过 inspector 面板展现对象的详情信息，如静态属性值及实例属性值、内存地址、类继承关系、package、class loader、GC Roots 等详情数据。</p> 
<p>使用场景</p> 
<ul><li> <p>当内存使用量与业务逻辑有较强关联的场景，通过 inspector 可以通过查看对象具体属性值。比如：社交场景中某个用户对象的好友列表异常，其 List 长度达到几亿，通过 inspector 面板获取到异常用户 ID，进而从业务视角继续排查属于哪个用户，本里可能有系统账号，与所有用户是好友。</p> </li><li> <p>集合等类型的使用会较多，如查看 ArrayList 的 size 属性也就了解其大小。</p> </li></ul> 
<p>举例：下图中左边的 Inspector 窗口展现了地址 0x125754cf8 的 ArrayList 实例详情，包括 modCount 等并不会在 outgoing references 展现的基本属性。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/42/ae/lmTdDm75_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<h3></h3> 
<p>4.2 集合状态</p> 
<p>功能：帮助更直观的了解系统的内存使用情况，查找浪费的内存空间。</p> 
<p>使用入口：MAT 主页 → Java Collections → 填充率/Hash冲突等功能。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a5/3e/Pov9rLAW_o.jpg"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>使用场景</p> 
<ul><li> <p>通过对 ArrayList 或数组等集合类对象按填充率聚类，定位稀疏或空集合类对象造成的内存浪费。</p> </li><li> <p>通过 HashMap 冲突率判定 hash 策略是否合理。</p> </li></ul> 
<p>具体使用方法在 4.3 节案例详细介绍。</p> 
<p>4.3 综合案例三</p> 
<p>使用工具项：Dominator tree、Histogram、集合 ratio。</p> 
<p>异常现象 ：程序 OOM，且 Dominator tree 无大对象，通过 Histogram 了解到多个 ArrayList 占据大量内存，期望通过减少 ArrayList 优化程序。</p> 
<p>程序代码</p> 
<pre></pre> 
<pre></pre> 
<p>package com.q.mat; import java.util.ArrayList; import java.util.List; public class ListRatioDemo { public static void main(String[] args) { for(int i=0;i&lt;10000;i++){ Thread thread = new Thread(new Runnable() { public void run() { HolderContainer holderContainer1 = new HolderContainer(); try { Thread.sleep(1000 * 1000 * 60); } catch (Exception e) { System.exit(1); } } }); thread.setName("inner-thread-" + i); thread.start(); } } } class HolderContainer { ListHolder listHolder1 = new ListHolder().init(); ListHolder listHolder2 = new ListHolder().init(); } class ListHolder { static final int LIST_SIZE = 100 * 1000; List&lt;String&gt; list1 = new ArrayList(LIST_SIZE); // 5%填充 List&lt;String&gt; list2 = new ArrayList(LIST_SIZE); // 5%填充 List&lt;String&gt; list3 = new ArrayList(LIST_SIZE); // 15%填充 List&lt;String&gt; list4 = new ArrayList(LIST_SIZE); // 30%填充 public ListHolder init() { for (int i = 0; i &lt; LIST_SIZE; i++) { if (i &lt; 0.05 * LIST_SIZE) { list1.add("" + i); list2.add("" + i); } if (i &lt; 0.15 * LIST_SIZE) { list3.add("" + i); } if (i &lt; 0.3 * LIST_SIZE) { list4.add("" + i); } } return this; } }</p> 
<p>分析过程</p> 
<ol><li> <p>使用 Dominator tree 查看并无高占比起点。</p> </li></ol> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b5/5c/8rPAxL11_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>使用 Histogram 定位到 ListHolder 及 ArrayList 占比过高，经过业务分析很多 List 填充率很低，不会浪费内存。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/11/61/s54Dui6q_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>查看 ArrayList 的填充率，MAT 首页 → Java Collections → Collection Fill Ratio。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/2a/f6/ZgeLJyO2_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>查看类型填写 java.util.ArrayList。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ad/d1/eCVLFyR9_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>从结果可以看出绝大部分 ArrayList 初始申请长度过大。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d4/56/CGiUkqdr_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>5. 按条件检索详解及实战</p> 
<p>5.1 OQL</p> 
<p>功能：提供一种类似于SQL的对象（类）级别统一结构化查询语言，根据条件对堆中对象进行筛选。</p> 
<p>语法</p> 
<pre></pre> 
<pre></pre> 
<p>SELECT * FROM [ INSTANCEOF ] &lt;class_name&gt; [ WHERE &lt;filter-expression&gt; ]</p> 
<ul><li> <p>Select 子句可以使用“*”，查看结果对象的引用实例（相当于 outgoing references）；可以指定具体的内容，如 Select OBJECTS v.elementData from xx 是返回的结果是完整的对象，而不是简单的对象描述信息)；可以使用 Distinct 关键词去重。</p> </li><li> <p>From 指定查询范围，一般指定类名、正则表达式、对象地址。</p> </li><li> <p>Where 用来指定筛选条件。</p> </li><li> <p>全部语法详见：OQL 语法</p> </li><li> <p>未支持的核心功能：group by value，如果有需求可以先导出结果到 csv 中，再使用 awk 等脚本工具分析即可。</p> </li></ul> 
<p>例子：查找 size＝0 且未使用过的 ArrayList：select * from java.util.ArrayList where size=0 and modCount=0。</p> 
<p>使用场景</p> 
<ul><li> <p>一般比较复杂的问题会使用 OQL，而且这类问题往往与业务逻辑有较大关系。比如大量的小对象整体占用内存高，但预期小对象应该不会过多（比如达到百万个），一个一个看又不现实，可以采用 OQL 查询导出数据排查。</p> </li></ul> 
<p>例如：微服务的分布式链路追踪系统，采集各服务所有接口名，共计200个服务却采集到了200万个接口名（一个服务不会有1万个接口），这时直接在 List 中一个个查看很难定位，可以直接用 OQL 导出，定位哪个服务接口名收集异常（如把 URL 中 ID 也统计到接口中了）</p> 
<p>5.2 检索及筛选</p> 
<p>功能：本文第二章内存分布，第三章对象间依赖的众多功能，均支持按字符串检索、按正则检索等操作。</p> 
<p>使用场景：在使用 Histogram、Thread overview 等功能时，可以进一步添加字符串匹配、正则匹配条件过滤缩小排查范围。</p> 
<p>5.3 按地址寻址</p> 
<p>功能：根据对象的虚拟内存十六进制地址查找对象。</p> 
<p>使用场景：仅知道地址并希望快速查看对象做后续分析时使用，其余可以直接使用 outgoing reference 了解对象信息。</p> 
<p>5.4 综合案例四</p> 
<p>使用工具项：OQL、Histogram、incoming references</p> 
<p>异常现象及目的 ：程序占用内存高，存在默认初始化较长的 ArrayList，需分析 ArrayList 被使用的占比，通过数据支撑是否采用懒加载模式，并分析具体哪块代码创建了空 ArrayList。</p> 
<p>程序代码</p> 
<pre></pre> 
<pre></pre> 
<p>public class EmptyListDemo { public static void main(String[] args) { EmptyValueContainerList emptyValueContainerList = new EmptyValueContainerList(); FilledValueContainerList filledValueContainerList = new FilledValueContainerList(); System.out.println("start sleep..."); try { Thread.sleep(50 * 1000 * 1000); } catch (Exception e) { System.exit(1); } } } class EmptyValueContainer { List&lt;Integer&gt; value1 = new ArrayList(10); List&lt;Integer&gt; value2 = new ArrayList(10); List&lt;Integer&gt; value3 = new ArrayList(10); } class EmptyValueContainerList { List&lt;EmptyValueContainer&gt; list = new ArrayList(500 * 1000); public EmptyValueContainerList() { for (int i = 0; i &lt; 500 * 1000; i++) { list.add(new EmptyValueContainer()); } } } class FilledValueContainer { List&lt;Integer&gt; value1 = new ArrayList(10); List&lt;Integer&gt; value2 = new ArrayList(10); List&lt;Integer&gt; value3 = new ArrayList(10); public FilledValueContainer init() { value1.addAll(Arrays.asList(1, 3, 5, 7, 9)); value2.addAll(Arrays.asList(2, 4, 6, 8, 10)); value1.addAll(Arrays.asList(1, 1, 1, 1, 1, 1, 1, 1, 1, 1)); return this; } } class FilledValueContainerList { List&lt;FilledValueContainer&gt; list = new ArrayList(500); public FilledValueContainerList() { for (int i = 0; i &lt; 500; i++) { list.add(new FilledValueContainer().init()); } } }</p> 
<p>分析过程</p> 
<ol><li> <p>内存中有50万个 capacity = 10 的空 ArrayList 实例。我们分析下这些对象的占用内存总大小及对象创建位置，以便分析延迟初始化（即直到使用这些对象的时候才将之实例化，否则一直为null）是否有必要。</p> </li><li> <p>使用 OQL 查询出初始化后未被使用的 ArrayList（size=0 且 modCount=0），语句如下图。可以看出公有 150 万个空 ArrayList，这些对象属于浪费内存。我们接下来计算下总计占用多少内存，并根据结果看是否需要优化。</p> </li></ol> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/71/05/H4CE7GHj_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>计算 150万 ArrayList占内存总量，直接点击右上方带黄色箭头的 Histogram 图标，这个图标是在选定的结果再用直方图展示，总计支配了120M 左右内存（所以这里点击结果，不包含 modCount 或 size 大于0的 ArrayList 对象）。这类在选定结果继续分析很多功能都支持，如正则检索、Histogram、Dominator tree等等。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b2/1e/JMt9A8f8_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>查看下图 ArrayList 的具体来源，可用 incoming references，下图中显示了清晰的对象创建路径。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d6/cd/RmajWYFj_o.png"></p> 
<p>​</p> 
<p>编辑切换为居中</p> 
<p>添加图片注释，不超过 140 字（可选）</p> 
<p></p> 
<p>总结</p> 
<p>至此本文讲解了 MAT 各项工具的功能、使用方法、适用场景，也穿插了4个实战案例，熟练掌握对分析 JVM 内存问题大有裨益，尤其是各种功能的组合使用。</p> 
<blockquote>
        资源获取： 
 <br> 大家 
 <strong>点赞、收藏、关注、评论</strong>啦 、 
 <strong>查看</strong>👇🏻👇🏻👇🏻 
 <strong>微信公众号获取联系方式</strong>👇🏻👇🏻👇🏻 
 <br> 
 <strong>精彩专栏推荐订阅：</strong>在 
 <strong>下方专栏</strong>👇🏻👇🏻👇🏻👇🏻 
 <br> 
 <a href="https://blog.csdn.net/m0_63437643/article/details/127276380?spm=1001.2014.3001.5501" title="每天学四小时：Java+Spring+JVM+分布式高并发，架构师指日可待">每天学四小时：Java+Spring+JVM+分布式高并发，架构师指日可待</a> 
</blockquote> 
<p><img alt="" height="108" src="https://images2.imgbox.com/18/fa/zXYsFRGp_o.jpg" width="108"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a19c5cf6180e66e25ca2e8dcd78854b9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Oracle19c最新版保姆级别最详细的安装配置教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0b5490eb2c217b3fa097f80445d54b1e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">DS1302芯片介绍</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>