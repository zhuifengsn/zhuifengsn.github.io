<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>第六章 聚合函数 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="第六章 聚合函数" />
<meta property="og:description" content="1. 聚合函数介绍 什么是聚合函数
聚合函数作用于一组数据，并对一组数据返回一个值。
聚合函数类型
AVG()
SUM()
MAX()
MIN()
COUNT()聚合函数语法
1.1 AVG和SUM函数 可以对数值型数据使用AVG 和 SUM 函数。
SELECT AVG(salary), MAX(salary),MIN(salary), SUM(salary) FROM employees WHERE job_id LIKE &#39;%REP%&#39;; 1.2 MIN和MAX函数 可以对任意数据类型的数据使用 MIN 和 MAX 函数。
SELECT MIN(hire_date), MAX(hire_date) FROM employees; 1.3 COUNT函数 COUNT(*)返回表中记录总数，适用于任意数据类型。 SELECT COUNT(*) FROM employees WHERE department_id = 50; COUNT(expr) 返回expr不为空的记录总数。 SELECT COUNT(commission_pct) FROM employees WHERE department_id = 50; 问题：用count()，count(1)，count(列名)谁好呢?其实，对于MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。Innodb引擎的表用count(),count(1)直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但好于具体的count(列名)。问题：能不能使用count(列名)替换count()?
不要使用 count(列名)来替代 count() ，count() 是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。说明：count()会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/ba98ccae53eb6c55728b0b500ba3b77b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-13T20:30:33+08:00" />
<meta property="article:modified_time" content="2022-11-13T20:30:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">第六章 聚合函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1__0"></a>1. 聚合函数介绍</h2> 
<ul><li>什么是聚合函数<br> 聚合函数作用于一组数据，并对一组数据返回一个值。<br> <img src="https://images2.imgbox.com/05/a4/7B3x84KK_o.png" alt="在这里插入图片描述"></li><li>聚合函数类型<br> AVG()<br> SUM()<br> MAX()<br> MIN()<br> COUNT()</li><li>聚合函数语法<br> <img src="https://images2.imgbox.com/68/f2/4bk1JMJm_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="11_AVGSUM_13"></a>1.1 AVG和SUM函数</h3> 
<p>可以对数值型数据使用AVG 和 SUM 函数。</p> 
<pre><code class="prism language-java"><span class="token class-name">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">MAX</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">MIN</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span>
<span class="token constant">FROM</span> employees
<span class="token constant">WHERE</span> job_id <span class="token constant">LIKE</span> <span class="token char">'%REP%'</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="12_MINMAX_22"></a>1.2 MIN和MAX函数</h3> 
<p>可以对任意数据类型的数据使用 MIN 和 MAX 函数。</p> 
<pre><code class="prism language-java"><span class="token class-name">SELECT</span> <span class="token function">MIN</span><span class="token punctuation">(</span>hire_date<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">MAX</span><span class="token punctuation">(</span>hire_date<span class="token punctuation">)</span>
<span class="token class-name">FROM</span> employees<span class="token punctuation">;</span>
</code></pre> 
<h3><a id="13_COUNT_30"></a>1.3 COUNT函数</h3> 
<ul><li>COUNT(*)返回表中记录总数，适用于任意数据类型。</li></ul> 
<pre><code class="prism language-java"><span class="token class-name">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>
<span class="token constant">FROM</span> employees
<span class="token class-name">WHERE</span> department_id <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>COUNT(expr) 返回expr不为空的记录总数。</li></ul> 
<pre><code class="prism language-java"><span class="token class-name">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>commission_pct<span class="token punctuation">)</span>
<span class="token constant">FROM</span> employees
<span class="token class-name">WHERE</span> department_id <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li>问题：用count(<em>)，count(1)，count(列名)谁好呢?其实，对于MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。Innodb引擎的表用count(</em>),count(1)直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但好于具体的count(列名)。</li><li>问题：能不能使用count(列名)替换count(<em>)?<br> 不要使用 count(列名)来替代 count(</em>) ，count(<em>) 是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。说明：count(</em>)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</li></ul> 
<h3><a id="2_GROUP_BY_50"></a>2. GROUP BY</h3> 
<h3><a id="21__51"></a>2.1 基本使用</h3> 
<p><img src="https://images2.imgbox.com/7b/fe/7xQ6fNUt_o.png" alt="在这里插入图片描述"><br> 可以使用GROUP BY子句将表中的数据分成若干组</p> 
<pre><code class="prism language-java"><span class="token class-name">SELECT</span> column<span class="token punctuation">,</span> <span class="token function">group_function</span><span class="token punctuation">(</span>column<span class="token punctuation">)</span>
<span class="token constant">FROM</span> table
<span class="token punctuation">[</span><span class="token constant">WHERE</span> condition<span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token constant">GROUP</span> <span class="token constant">BY</span> group_by_expression<span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token constant">ORDER</span> <span class="token constant">BY</span> column<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>明确：WHERE一定放在FROM后面</p> 
</blockquote> 
<h3><a id="22__64"></a>2.2 使用多个列分组</h3> 
<pre><code class="prism language-java"><span class="token constant">SELECT</span> department_id dept_id<span class="token punctuation">,</span> job_id<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span>
<span class="token constant">FROM</span> employees
<span class="token constant">GROUP</span> <span class="token class-name">BY</span> department_id<span class="token punctuation">,</span> job_id <span class="token punctuation">;</span>
</code></pre> 
<p>使用 WITH ROLLUP 关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所有记录的总和，即统计记录数量。</p> 
<pre><code class="prism language-java"><span class="token class-name">SELECT</span> department_id<span class="token punctuation">,</span><span class="token function">AVG</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span>
<span class="token constant">FROM</span> employees
<span class="token constant">WHERE</span> department_id <span class="token operator">&gt;</span> <span class="token number">80</span>
<span class="token constant">GROUP</span> <span class="token constant">BY</span> department_id <span class="token class-name">WITH</span> <span class="token constant">ROLLUP</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>注意：<br> 当使用ROLLUP时，不能同时使用ORDER BY子句进行结果排序，即ROLLUP和ORDER BY是互相排斥的。</p> 
</blockquote> 
<h2><a id="3_HAVING_82"></a>3. HAVING</h2> 
<h3><a id="31__83"></a>3.1 基本使用</h3> 
<p><img src="https://images2.imgbox.com/98/0b/vnzWk4GX_o.png" alt="在这里插入图片描述"><br> 过滤分组：HAVING子句</p> 
<ul><li>行已经被分组。</li><li>使用了聚合函数。</li><li>满足HAVING 子句中条件的分组将被显示。</li><li>HAVING 不能单独使用，必须要跟 GROUP BY 一起使用。<br> <img src="https://images2.imgbox.com/8d/30/p6vENmcu_o.png" alt="在这里插入图片描述"></li><li><strong>非法使用聚合函数 ： 不能在 WHERE 子句中使用聚合函数。如下：</strong></li></ul> 
<pre><code class="prism language-java"><span class="token class-name">SELECT</span> department_id<span class="token punctuation">,</span> <span class="token function">AVG</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span>
<span class="token constant">FROM</span> employees
<span class="token class-name">WHERE</span> <span class="token function">AVG</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">8000</span>
<span class="token constant">GROUP</span> <span class="token class-name">BY</span> department_id<span class="token punctuation">;</span>
</code></pre> 
<h3><a id="32_WHEREHAVING_99"></a>3.2 WHERE和HAVING的对比</h3> 
<ul><li>区别1：WHERE 可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件；<br> HAVING 必须要与 GROUP BY 配合使用，可以把分组计算的函数和分组字段作为筛选条件。这决定了，在需要对数据进行分组统计的时候，HAVING 可以完成 WHERE 不能完成的任务。这是因为，在查询语法结构中，WHERE 在 GROUP BY 之前，所以无法对分组结果进行筛选。HAVING 在 GROUP BY 之后，可以使用分组字段和分组中的计算函数，对分组的结果集进行筛选，这个功能是 WHERE 无法完成的。另外，WHERE排除的记录不再包括在分组中。</li><li>区别2：如果需要通过连接从关联表中获取需要的数据，WHERE 是先筛选后连接，而 HAVING 是先连接 后筛选。这一点，就决定了在关联查询中，WHERE 比 HAVING 更高效。因为 WHERE 可以先筛选，用一个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也比较高。HAVING 则需要先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用的资源就比较多，执行效率也较低。<br> <img src="https://images2.imgbox.com/33/c8/Alh1klwA_o.png" alt="在这里插入图片描述"><br> <strong>开发中的选择：</strong><br> WHERE 和 HAVING 也不是互相排斥的，我们可以在一个查询里面同时使用 WHERE 和 HAVING。包含分组统计函数的条件用 HAVING，普通条件用 WHERE。这样，我们就既利用了 WHERE 条件的高效快速，又发挥了 HAVING 可以使用包含分组统计函数的查询条件的优点。当数据量特别大的时候，运行效率会有很大的差别。</li></ul> 
<h2><a id="4_SELECT_109"></a>4. SELECT的执行过程</h2> 
<h3><a id="41__110"></a>4.1 查询的结构</h3> 
<pre><code class="prism language-java">#方式<span class="token number">1</span>：
<span class="token constant">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token constant">FROM</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token constant">WHERE</span> 多表的连接条件
<span class="token constant">AND</span> 不包含组函数的过滤条件
<span class="token constant">GROUP</span> <span class="token constant">BY</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token constant">HAVING</span> 包含组函数的过滤条件
<span class="token constant">ORDER</span> <span class="token constant">BY</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token constant">ASC</span><span class="token operator">/</span><span class="token constant">DESC</span>
<span class="token constant">LIMIT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
#方式<span class="token number">2</span>：
<span class="token constant">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token constant">FROM</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token constant">JOIN</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token constant">ON</span> 多表的连接条件
<span class="token constant">JOIN</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token constant">ON</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token constant">WHERE</span> 不包含组函数的过滤条件
<span class="token constant">AND</span><span class="token operator">/</span><span class="token constant">OR</span> 不包含组函数的过滤条件
<span class="token constant">GROUP</span> <span class="token constant">BY</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token constant">HAVING</span> 包含组函数的过滤条件
<span class="token constant">ORDER</span> <span class="token constant">BY</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token constant">ASC</span><span class="token operator">/</span><span class="token constant">DESC</span>
<span class="token constant">LIMIT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
#其中：
#（<span class="token number">1</span>）from：从哪些表中筛选
#（<span class="token number">2</span>）on：关联多表查询时，去除笛卡尔积
#（<span class="token number">3</span>）where：从表中筛选的条件
#（<span class="token number">4</span>）group by：分组依据
#（<span class="token number">5</span>）having：在统计结果中再次筛选
#（<span class="token number">6</span>）order by：排序
#（<span class="token number">7</span>）limit：分页
</code></pre> 
<p>你需要记住 SELECT 查询时的两个顺序：<br> <strong>1. 关键字的顺序是不能颠倒的：</strong></p> 
<pre><code class="prism language-java"><span class="token constant">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token constant">FROM</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token constant">WHERE</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token constant">GROUP</span> <span class="token constant">BY</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token constant">HAVING</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token constant">ORDER</span> <span class="token constant">BY</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token constant">LIMIT</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre> 
<p><strong>2.SELECT 语句的执行顺序（在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同）：</strong></p> 
<pre><code class="prism language-java"><span class="token constant">FROM</span> <span class="token operator">-&gt;</span> <span class="token constant">WHERE</span> <span class="token operator">-&gt;</span> <span class="token constant">GROUP</span> <span class="token constant">BY</span> <span class="token operator">-&gt;</span> <span class="token constant">HAVING</span> <span class="token operator">-&gt;</span> <span class="token constant">SELECT</span> 的字段 <span class="token operator">-&gt;</span> <span class="token constant">DISTINCT</span> <span class="token operator">-&gt;</span> <span class="token constant">ORDER</span> <span class="token constant">BY</span> <span class="token operator">-&gt;</span> <span class="token constant">LIMIT</span>
</code></pre> 
<p>比如你写了一个 SQL 语句，那么它的关键字顺序和执行顺序是下面这样的：</p> 
<pre><code class="prism language-java"><span class="token constant">SELECT</span> <span class="token class-name">DISTINCT</span> player_id<span class="token punctuation">,</span> player_name<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> as num # 顺序 <span class="token number">5</span>
<span class="token constant">FROM</span> player <span class="token constant">JOIN</span> team <span class="token constant">ON</span> player<span class="token punctuation">.</span>team_id <span class="token operator">=</span> team<span class="token punctuation">.</span>team_id # 顺序 <span class="token number">1</span>
<span class="token constant">WHERE</span> height <span class="token operator">&gt;</span> <span class="token number">1.80</span> # 顺序 <span class="token number">2</span>
<span class="token constant">GROUP</span> <span class="token constant">BY</span> player<span class="token punctuation">.</span>team_id # 顺序 <span class="token number">3</span>
<span class="token constant">HAVING</span> num <span class="token operator">&gt;</span> <span class="token number">2</span> # 顺序 <span class="token number">4</span>
<span class="token constant">ORDER</span> <span class="token constant">BY</span> num <span class="token constant">DESC</span> # 顺
</code></pre> 
<h3><a id="43_SQL__165"></a>4.3 SQL 的执行原理</h3> 
<p>SELECT 是先执行 FROM 这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：</p> 
<ol><li>首先先通过 CROSS JOIN 求笛卡尔积，相当于得到虚拟表 vt（virtual table）1-1；</li><li>通过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2；</li><li>添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟<br> 表 vt1-2 的基础上增加外部行，得到虚拟表 vt1-3。<br> 当然如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得到是我们的原始数据。<br> 然后进入第三步和第四步，也就是 GROUP 和 HAVING 阶段 。在这个阶段中，实际上是在虚拟表 vt2 的基础上进行分组和分组过滤，得到中间的虚拟表 vt3 和 vt4 。<br> 当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到 SELECT 和 DISTINCT<br> 阶段 。<br> 首先在 SELECT 阶段会提取想要的字段，然后在 DISTINCT 阶段过滤掉重复的行，分别得到中间的虚拟表vt5-1 和 vt5-2 。<br> 当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是 ORDER BY 阶段 ，得到虚拟表 vt6 。<br> 最后在 vt6 的基础上，取出指定行的记录，也就是 LIMIT 阶段 ，得到最终的结果，对应的是虚拟表<br> vt7 。<br> 当然我们在写 SELECT 语句的时候，不一定存在所有的关键字，相应的阶段就会省略。<br> 同时因为 SQL 是一门类似英语的结构化查询语言，所以我们在写 SELECT 语句的时候，还要注意相应的关键字顺序，所谓底层运行的原理，就是我们刚才讲到的执行顺序。</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/935f5fd6d1659f8e0da37a89b04f6285/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于Redis的 Jwt Token续期</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/58f8969d8744f8eef36215f082f26756/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Centos7 安装Redis详细教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>