<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Web系列二十五】前后端使用proto&#43;grpc实现数据传输 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Web系列二十五】前后端使用proto&#43;grpc实现数据传输" />
<meta property="og:description" content="目录
写在前面
简介
定义
编码
使用过程
环境配置
后端
开发环境
pom配置
前端
开发环境
安装依赖
建立通信
定义Proto结构
编译proto文件
后端
前端
使用proto
后端
前端
参考资料
简介 定义 protocol buffers 是一种语言无关、平台无关、可扩展的序列化结构数据的方法，它可用于（数据）通信协议、数据存储等。通信时所传递的信息是通过Protobuf定义的message数据结构进行打包，然后编译成二进制的码流再进行传输或者存储。
Protocol buffers 是一种灵活，高效，自动化机制的结构数据序列化方法－可类比 XML，但是比 XML 更小（3 ~ 10倍）、更快（20 ~ 100倍）、更为简单。
Protobuf 使用的时候必须写一个 IDL（Interface description language）文件，在里面定义好数据结构，只有预先定义了的数据结构，才能被序列化和反序列化。其中，序列化是将对象转换二进制数据，反序列化是将二进制数据转换成对象。
编码 ProtoBuf 编码格式类似于TLV 格式(Tag | Length | Value)，Tag为字段唯一标识，Length为Value域的长度，Value为数据本身。其中，Tag由field_number和wire_type两个部分组成，field_number是message定义字段时指定的字段编号，wire_type是ProtoBuf 编码类型，根据这个类型选择不同的 Value 编码方案。wire_type最多可表达8种编码类型(因为是3bit的)，目前已经定义了六种(Varint,64-bit,Length-delimited,Start group,End group,32-bit，其中Start group和End group已经弃用)。
在ProtoBuf 中，Length是可选的，即有些类型的数据结构编码后格式是(Tag | Value)，如Varint,64-bit和32-bit。为确定这种格式的数据边界引入了Varint编码。
使用过程 第一步，创建 .proto 文件，定义数据结构。第二步，protoc 编译 .proto 文件生成读写接口第三步，调用接口实现序列化、反序列化以及读写 环境配置 后端 开发环境 spring boot &#43; maven" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/32773cf187f7680ac75674366f9d4696/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-24T09:15:55+08:00" />
<meta property="article:modified_time" content="2023-10-24T09:15:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Web系列二十五】前后端使用proto&#43;grpc实现数据传输</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2-toc" style="margin-left:0px;"><a href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2" rel="nofollow">写在前面</a></p> 
<p id="%E7%AE%80%E4%BB%8B-toc" style="margin-left:0px;"><a href="#%E7%AE%80%E4%BB%8B" rel="nofollow">简介</a></p> 
<p id="%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#%E5%AE%9A%E4%B9%89" rel="nofollow">定义</a></p> 
<p id="h_451390348_1-toc" style="margin-left:40px;"><a href="#h_451390348_1" rel="nofollow">编码</a></p> 
<p id="h_451390348_2-toc" style="margin-left:40px;"><a href="#h_451390348_2" rel="nofollow">使用过程</a></p> 
<p id="%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-toc" style="margin-left:0px;"><a href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE" rel="nofollow">环境配置</a></p> 
<p id="%E5%90%8E%E7%AB%AF-toc" style="margin-left:40px;"><a href="#%E5%90%8E%E7%AB%AF" rel="nofollow">后端</a></p> 
<p id="%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-toc" style="margin-left:80px;"><a href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83" rel="nofollow">开发环境</a></p> 
<p id="pom%E9%85%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#pom%E9%85%8D%E7%BD%AE" rel="nofollow">pom配置</a></p> 
<p id="%E5%89%8D%E7%AB%AF-toc" style="margin-left:40px;"><a href="#%E5%89%8D%E7%AB%AF" rel="nofollow">前端</a></p> 
<p id="%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-toc" style="margin-left:80px;"><a href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83" rel="nofollow">开发环境</a></p> 
<p id="%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96-toc" style="margin-left:80px;"><a href="#%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96" rel="nofollow">安装依赖</a></p> 
<p id="%E5%BB%BA%E7%AB%8B%E9%80%9A%E4%BF%A1-toc" style="margin-left:0px;"><a href="#%E5%BB%BA%E7%AB%8B%E9%80%9A%E4%BF%A1" rel="nofollow">建立通信</a></p> 
<p id="%E5%AE%9A%E4%B9%89Proto%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#%E5%AE%9A%E4%B9%89Proto%E7%BB%93%E6%9E%84" rel="nofollow">定义Proto结构</a></p> 
<p id="%E7%BC%96%E8%AF%91proto%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#%E7%BC%96%E8%AF%91proto%E6%96%87%E4%BB%B6" rel="nofollow">编译proto文件</a></p> 
<p id="%E5%90%8E%E7%AB%AF-toc" style="margin-left:80px;"><a href="#%E5%90%8E%E7%AB%AF" rel="nofollow">后端</a></p> 
<p id="%E5%89%8D%E7%AB%AF-toc" style="margin-left:80px;"><a href="#%E5%89%8D%E7%AB%AF" rel="nofollow">前端</a></p> 
<p id="%E4%BD%BF%E7%94%A8proto-toc" style="margin-left:40px;"><a href="#%E4%BD%BF%E7%94%A8proto" rel="nofollow">使用proto</a></p> 
<p id="%E5%90%8E%E7%AB%AF-toc" style="margin-left:80px;"><a href="#%E5%90%8E%E7%AB%AF" rel="nofollow">后端</a></p> 
<p id="%E5%89%8D%E7%AB%AF-toc" style="margin-left:80px;"><a href="#%E5%89%8D%E7%AB%AF" rel="nofollow">前端</a></p> 
<p id="%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-toc" style="margin-left:0px;"><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" rel="nofollow">参考资料</a></p> 
<hr id="hr-toc"> 
<h2>简介</h2> 
<h3 id="%E5%AE%9A%E4%B9%89">定义</h3> 
<p>        protocol buffers 是一种语言无关、平台无关、可扩展的序列化结构数据的方法，它可用于（数据）通信协议、数据存储等。通信时所传递的信息是通过Protobuf定义的message数据结构进行打包，然后编译成二进制的码流再进行传输或者存储。</p> 
<p>        Protocol buffers 是一种灵活，高效，自动化机制的结构数据序列化方法－可类比 XML，但是比 XML 更小（3 ~ 10倍）、更快（20 ~ 100倍）、更为简单。</p> 
<p>        Protobuf 使用的时候必须写一个 IDL（Interface description language）文件，在里面定义好数据结构，只有预先定义了的数据结构，才能被序列化和反序列化。其中，序列化是将对象转换二进制数据，反序列化是将二进制数据转换成对象。</p> 
<h3 id="h_451390348_1">编码</h3> 
<p>        ProtoBuf 编码格式类似于TLV 格式(Tag | Length | Value)，Tag为字段唯一标识，Length为Value域的长度，Value为数据本身。其中，Tag由field_number和wire_type两个部分组成，field_number是message定义字段时指定的字段编号，wire_type是ProtoBuf 编码类型，根据这个类型选择不同的 Value 编码方案。wire_type最多可表达8种编码类型(因为是3bit的)，目前已经定义了六种(Varint,64-bit,Length-delimited,Start group,End group,32-bit，其中Start group和End group已经弃用)。</p> 
<p>        在ProtoBuf 中，Length是可选的，即有些类型的数据结构编码后格式是(Tag | Value)，如Varint,64-bit和32-bit。为确定这种格式的数据边界引入了Varint编码。</p> 
<h3 id="h_451390348_2">使用过程</h3> 
<ul><li>第一步，创建 .proto 文件，定义数据结构。</li><li>第二步，protoc 编译 .proto 文件生成读写接口</li><li>第三步，调用接口实现序列化、反序列化以及读写</li></ul> 
<h2 id="%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">环境配置</h2> 
<h3 id="%E5%90%8E%E7%AB%AF">后端</h3> 
<h4 id="%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83">开发环境</h4> 
<p>        spring boot + maven</p> 
<h4 id="pom%E9%85%8D%E7%BD%AE">pom配置</h4> 
<p>        在Pom文件中添加以下配置。</p> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
        &lt;/project ...&gt;
    ...
    &lt;properties&gt;
        ...
        &lt;grpc.version&gt;1.6.1&lt;/grpc.version&gt;
        &lt;protobuf.version&gt;3.3.0&lt;/protobuf.version&gt;
        &lt;os.detected.classifer&gt;windows-x86_64&lt;/os.detected.classifer&gt;
        ...
    &lt;/properties&gt;
    ...
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.xolstice.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;protobuf-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;0.5.0&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;protocArtifact&gt;com.google.protobuf:protoc:${protobuf.version}:exe:${os.detected.vlassifer}&lt;/protocArtifact&gt;
                    &lt;pluginId&gt;grpc-java&lt;/pluginId&gt;
                    &lt;pluginArtifact&gt;io.grpc:protoc-gen-grpc-java:${grpc.version}:exe:${os.detected.classifer}&lt;/pluginArtifact&gt;
                    &lt;protoSourceRoot&gt;src/main/resources/proto&lt;/protoSourceRoot&gt;
                    &lt;outputDorectory&gt;src/main/jsvs&lt;/outputDorectory&gt;
                    &lt;clearOutputDirectory&gt;false/clearOutputDirectory&gt;
                &lt;/configuration&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;compile&lt;/goal&gt;
                            &lt;goal&gt;compile-custom&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
    ...
&lt;/project&gt;</code></pre> 
<h3 id="%E5%89%8D%E7%AB%AF">前端</h3> 
<h4>开发环境</h4> 
<p>        vue</p> 
<h4 id="%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96">安装依赖</h4> 
<pre><code class="language-bash">npm install pbjs
npm install protobufjs</code></pre> 
<p>        在package.json中添加一下命令，其中xxx对应每个proto文件的名称，如果有多个文件，需要分多次执行</p> 
<pre><code class="language-TypeScript">{
    "scripts": {
        "proto": "pbjs -t json-module -w commonjs -o --ts src/utils/proto/xxx.ts src/utils/proto/xxx.proto"
    }
}</code></pre> 
<h2 id="%E5%BB%BA%E7%AB%8B%E9%80%9A%E4%BF%A1">建立通信</h2> 
<h3 id="%E5%AE%9A%E4%B9%89Proto%E7%BB%93%E6%9E%84">定义Proto结构</h3> 
<p>        student结构</p> 
<pre><code class="language-TypeScript">syntax = "proto3";

package com.test.proto;

option java_multiple_diles = false;
option java_package = "com.test.protobuf";
option java_outer_classname = "StudentVO";

message Student {
    int32 number = 1;
    string name = 2;
}</code></pre> 
<p>         继承student的class结构</p> 
<pre><code class="language-TypeScript">syntax = "proto3";

import "student.proto";

pacakge com.test.proto;

option java_mutiple_files = false;
option java_package = "com.test.protobuf";
option java_outer_classname = "ClassVO";

message Class {
    enum Grade {
        One = 0;
        Two = 1;
        Three = 2;
    };
    
    string name = 1;
    Grade grade = 2;
    com.test.proto.Student student = 3;
}</code></pre> 
<p>         rpc服务</p> 
<pre><code class="language-TypeScript">syntax = "proto3";

import "class.proto";

pacakge com.test.proto;

option java_mutiple_files = false;
option java_package = "com.test.protobuf";
option java_outer_classname = "ClassService";

service ClassService {
    rpc SendClassMessage(Class) return (Result) {}
}

message Result {
    enum Statu {
        SUCCESS = 0;
        FAIL = 1;
    }
    
    State result = 1;
}</code></pre> 
<p>        要在.proto文件中添加注释，请使用C/ C++风格的//和/<em>…</em> /语法。</p> 
<blockquote> 
 <ol><li>syntax：指定Proto语法，默认使用的是proto2；</li><li>import：用于导入包，类似python;</li><li>package：定义包的名称</li><li>option：用于java。指定输出的是java包名称以及类的名称</li><li>message：数据结构</li><li>enum：枚举类型</li><li>repeated: 表示列表</li><li>service：rpc服务</li></ol> 
</blockquote> 
<h3 id="%E7%BC%96%E8%AF%91proto%E6%96%87%E4%BB%B6">编译proto文件</h3> 
<p>        编译前要确保前后端使用的是同样的proto文件</p> 
<h4>后端</h4> 
<p>         添加了依赖之后可以发现Maven中会有一个Protobuf的插件，点击插件中的compile就可以编译生成java格式的文件了</p> 
<h4>前端</h4> 
<p>        修改package.json中的文件名后，执行npm run proto即可</p> 
<h3 id="%E4%BD%BF%E7%94%A8proto">使用proto</h3> 
<p>        前面已经使用编译工具生成了前后端不同语言的proto类，类中定义了proto的结构以及decode\encode方法，因此使用起来很简单，只要建立普通的前后端通信，如http\websocket\rpc等，然后使用proto类作为信息的载体即可。</p> 
<p>        以Student为例，前后端通信接口可以类似如下方式建立<strong>(代码不完整，删减了部分信息)</strong>。</p> 
<h4>后端</h4> 
<p>        StudentController.java</p> 
<pre><code class="language-java">@Api(tags = "学生信息接口")
@RestController
@RequestMapping("student")
@CrossOrigin
public class StudentController {

    @Autowired
    private StudentService studentService;
    
    @ApiOperation("根据班级信息获取学生信息")
    @PostMapping(value="queryStudentData", produces="application/x-protobuf")
    public StudentVO.Student queryStudentData(
        @ApiParam(name = "number", value = "学号")
        @RequestParam("number") Integer number
    ) throws IOException {
        return studentService.queryStudentData(number);
    }
}</code></pre> 
<p>        StudentService.java</p> 
<pre><code class="language-java">public interface StudentService {
    StudentVO.Student queryStudentData(Integer number);
}</code></pre> 
<p>        StudentServiceImpl.java</p> 
<pre><code class="language-java">public StudentVO.Student queryStudentData(Integer number) {
    StudentVO.Student.Builder student = StudentVO.Student.newBuilder();
    student.setNumber(number);
    student.setName("student1");
    return student.build();
}</code></pre> 
<h4>前端</h4> 
<p>        studentServer.ts</p> 
<pre><code class="language-TypeScript">export async function queryStudentData (name: number) {
    return axios.create(
            {
                timeout: 5 * 60 * 1000,
                baseURL: 'http://' + import.meta.env.IP + ':' + import.meta.env.PORT
            }
        ).post(
            '/student/queryStudentData?number=' + number   
        )
}</code></pre> 
<p>        student.ts</p> 
<pre><code class="language-TypeScript">import { queryStudentData } from '@/api/http/studentServer.ts'

function getStudent(num: number) {
    let student
    await queryStudentData(1).then((res: any) =&gt; {
        let uint8 = new Uint8Array(res.data)
        student = enc.decode(uint8)
    })
    return student
}</code></pre> 
<h2 id="%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</h2> 
<p><a href="https://zhuanlan.zhihu.com/p/451390348" rel="nofollow" title="ProtoBuf介绍(内含官网汉化文档) - 知乎 (zhihu.com)">ProtoBuf介绍(内含官网汉化文档) - 知乎 (zhihu.com)</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/904f7448c563f0721ac5f82ded7c87f5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Windows 10系统升级后，右键菜单中的“管理员取得所有权”选项消失了</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/32a677e89643ff43e451df0d2d3177c2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Web系列二十六】el-input内容约束的一些方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>