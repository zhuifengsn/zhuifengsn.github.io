<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;创建型模式-工厂模式 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;创建型模式-工厂模式" />
<meta property="og:description" content="一、简单工厂模式 1.1 简单工厂模式 简单工厂模式（Simple Factory Pattern）专门定义一个类来负责创建其他类的实例，被创建的实例通常具有共同的父类。
简单工厂模式，是一种实例化对象的方式，只要输入需要实例化对象的名字，就可以通过工厂对象的相应工厂函数来制造你需要的对象。
1.2 简单工厂模式的角色 （1）Factory工厂角色（工厂类）：
工厂角色即工厂类，是简单工厂模式的核心，负责创建所有实例的内部逻辑，工厂类可以被外界直接调用，创建所需要的产品对象。
（2）Product（抽象产品角色）：
抽象产品角色是简单工厂模式所创建的所有对象的父类，负责描述所有实例所共有的公告接口。所创建的具体产品对象都是其子类对象。
（3）ConcreteProduct（具体产品角色）：
具体产品角色是简单工厂模式的创建目标。每个具体产品角色都继承了抽象产品角色，需要实现定义在抽象产品中的方法。
ProductA、ProductB和ProductC继承自Product虚拟类，Show方法是不同产品的自描述；Factory依赖于ProductA、ProductB和ProductC，Factory根据不同的条件创建不同的Product对象
依赖关系：箭头指向被依赖的一方
继承关系：
1.3 简单工厂模式的应用 在程序中，需要创建的对象很多，导致对象的new操作多且杂时，需要使用简单工厂模式；
由于对象的创建过程是我们不需要去关心的，而我们注重的是对象的实际操作，所以，我们需要分离对象的创建和操作两部分，如此，方便后期的程序扩展和维护。
1.4 简单工厂模式的优缺点 优点：
本着高内聚低耦合的原则，将系统的逻辑部分和功能分开。
缺点：
简单工厂模式会增加系统类的个数，在一定程度上增加了系统的复杂度和理解难度；系统扩展难，一旦增加新产品，就需要修改工厂逻辑，不利于系统的扩展与维护；简单工厂模式中所有产品的创建都是由同一个工厂创建，工厂类职责较重，业务逻辑较为复杂，具体产品与工厂类之间耦合度高，严重影响了系统的灵活性和扩展性。 1.5 简单工厂模式实现 某电视机厂为各个品牌代工生产电视机，可以使用简单工厂的模式来实现。
#include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; typedef enum ProductTypeTag { Hair, Hisense, }PRODUCTTYPE; //抽象产品类 TV(电视机类) class TV { public: virtual void Show() = 0; virtual ~TV(){};//声明析构函数为虚函数，防止内存泄漏 }; //具体产品类 HairTV(海尔电视类) class HairTV : public TV { public: void Show() { cout&lt;&lt;&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/c0523d83b33789bc1190d19474c580a1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-30T20:27:35+08:00" />
<meta property="article:modified_time" content="2022-08-30T20:27:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;创建型模式-工厂模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、简单工厂模式</h2> 
<h3>1.1 简单工厂模式</h3> 
<p>简单工厂模式（Simple Factory Pattern）专门定义<strong>一个类来负责创建其他类的实例，被创建的实例通常具有共同的父类。</strong></p> 
<p>简单工厂模式，是一种实例化对象的方式，只要输入需要实例化对象的名字，就可以通过工厂对象的相应工厂函数来制造你需要的对象。</p> 
<h3>1.2 简单工厂模式的角色</h3> 
<p>（1）Factory工厂角色（工厂类）：</p> 
<p>工厂角色即工厂类，是简单工厂模式的核心，负责创建所有实例的内部逻辑，工厂类可以被外界直接调用，创建所需要的产品对象。</p> 
<p>（2）Product（抽象产品角色）：</p> 
<p>抽象产品角色是简单工厂模式所创建的所有对象的父类，负责描述所有实例所共有的公告接口。所创建的具体产品对象都是其子类对象。</p> 
<p>（3）ConcreteProduct（具体产品角色）：</p> 
<p>具体产品角色是简单工厂模式的创建目标。每个具体产品角色都继承了抽象产品角色，需要实现定义在抽象产品中的方法。</p> 
<p></p> 
<p>ProductA、ProductB和ProductC继承自Product虚拟类，Show方法是不同产品的自描述；Factory依赖于ProductA、ProductB和ProductC，Factory根据不同的条件创建不同的Product对象</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/05/53/bb2JXEgV_o.png"></p> 
<p> 依赖关系：箭头指向被依赖的一方</p> 
<p>继承关系：</p> 
<h3> 1.3 简单工厂模式的应用</h3> 
<p>在程序中，需要创建的对象很多，导致对象的new操作多且杂时，需要使用简单工厂模式；<br> 由于对象的创建过程是我们不需要去关心的，而我们注重的是对象的实际操作，所以，我们需要分离对象的创建和操作两部分，如此，方便后期的程序扩展和维护。</p> 
<h3>1.4 简单工厂模式的优缺点</h3> 
<p>优点：</p> 
<p>本着高内聚低耦合的原则，将系统的逻辑部分和功能分开。</p> 
<p>缺点：</p> 
<ul><li>简单工厂模式会增加系统类的个数，在一定程度上增加了系统的复杂度和理解难度；</li><li>系统扩展难，一旦增加新产品，就需要修改工厂逻辑，不利于系统的扩展与维护；简单工厂模式中所有<strong>产品的创建都是由同一个工厂创建，工厂类职责较重，业务逻辑较为复杂，具体产品与工厂类之间耦合度高，严重影响了系统的灵活性和扩展性</strong>。</li></ul> 
<h3>1.5 简单工厂模式实现</h3> 
<p>某电视机厂为各个品牌代工生产电视机，可以使用简单工厂的模式来实现。</p> 
<p><img alt="" height="391" src="https://images2.imgbox.com/4b/1d/uwJPSifA_o.png" width="758"></p> 
<p></p> 
<p></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
  
typedef enum ProductTypeTag
{
  Hair,
  Hisense,
}PRODUCTTYPE;
  
//抽象产品类 TV(电视机类)
class TV
{
public:
  virtual void Show() = 0;
  virtual ~TV(){};//声明析构函数为虚函数，防止内存泄漏
};
 //具体产品类 HairTV(海尔电视类)
class HairTV : public TV
{
public:
  void Show()
  {
    cout&lt;&lt;"I'm HairTV "&lt;&lt;endl;
  }
};
 //具体产品类 HisenseTV(海信电视类)  
class  HisenseTV : public TV
{
public:
  void Show()
  {
    cout&lt;&lt;"I'm HisenseTV"&lt;&lt;endl;
  }
};
  

// 工厂类 TVFactory(电视机工厂类)
class TVFactory
{
public:
  TV* CreateTV(PRODUCTTYPE type)
  {
    switch (type)
    {
    case Hair:
      return new HairTV();
  
    case Hisense:
      return new HisenseTV();
    default:
      return NULL;
    }
  }
};
  
int main(int argc, char *argv[])
{
    // 创建工厂类对象
    TVFactory* myTVFactory = new  TVFactory();
    TV* hairTV = myTVFactory-&gt;CreateTV(Hair);
    if (hairTV != NULL)
        hairTV-&gt;Show();

    TV* hisenseTV = myTVFactory-&gt;CreateTV(Hisense);
    if (hisenseTV != NULL)
        hisenseTV-&gt;Show();

    delete  myTVFactory;
    myTVFactory = NULL;

    delete hairTV;
    hairTV = NULL;

    delete hisenseTV;
    hisenseTV = NULL;  
  
    return 0;
}</code></pre> 
<p>调试结果：</p> 
<p><img alt="" height="84" src="https://images2.imgbox.com/cb/ba/czpHpzLj_o.png" width="208"></p> 
<p></p> 
<p>TVFactory 是工厂类，它是整个系统的核心，提供了静态工厂方法CreateTV（），该方法中包含一个字符串类型的参数，在内部业务逻辑中根据参数值得不同实例化不同的具体产品类，返回相依的对象。<span style="color:#fe2c24;">简单工厂模式的缺点是 如增加 生成TCL电视时，需要修改工厂类TVFactory</span>。 </p> 
<p>小结：</p> 
<p>在程序中，需要创建的对象很多，导致对象的new操作多且杂时，需要使用简单工厂模式。</p> 
<h2>二、工厂方法模式</h2> 
<h3>2.1 工厂方法简介</h3> 
<p>简单工厂模式中<strong>最大的缺点是当有新产品要加入系统时，必须要修改工厂类，加入必要的处理逻辑，违背了“开闭原则”</strong>。</p> 
<p>工厂方法模式定义：在工厂模式中，<span style="color:#4da8ee;">工厂父类负责定义创建产品对象的公告接口，而工厂子类负责生成具体的产品对象</span>。<strong>目的是将产品的实例化操作延迟到工厂子类中完成</strong>，通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p> 
<h3>2.2 模式结构</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/09/66/kLntQOs8_o.png"></p> 
<p> （1）Product （抽象产品）</p> 
<p>抽象产品是定义产品的接口，是工厂方法模式所创建对象的超类型，也是产品对象的共同父类或接口。</p> 
<p>（2）ConcreteProduct（具体产品）</p> 
<p>具体产品实现了抽象产品的接口，某种类型的具体产品由专门的具体工厂创建。</p> 
<p>（3）Factory(抽象工厂)</p> 
<p>（4）ConcreteFactory（具体工厂）</p> 
<p>具体工厂是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户调用，返回一个具体产品类的实例。</p> 
<p></p> 
<h3>2.3 应用    </h3> 
<p>工厂方法模式的意义是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以<span style="color:#4da8ee;">使系统在不修改具体工厂角色的情况下引进新的产品</span>。</p> 
<p>1.在设计的初期，就考虑到产品在后期会进行扩展的情况下，可以使用工厂方法模式；</p> 
<p>2.产品结构较复杂的情况下，可以使用工厂方法模式；</p> 
<p>                                                                                                                                                        </p> 
<h3>2.4 优缺点</h3> 
<p>优点：系统的扩展性好，符合“开闭原则”  。系统加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品即可。</p> 
<p>缺点：在添加新产品时，需要编写新的具体产品类，而且要提供与之对应的具体工厂类，系统中类的个数将成对增加，一定程度上增加了系统的复杂度。</p> 
<h3>2.5 举例</h3> 
<p>简单工厂模式，通过一个电视机代工厂来生产电视机，当需要增加新的品牌的电视机时不得不修该工厂类中的工厂方法，违反了“开闭原则”。</p> 
<p>工厂方法模式，将原有的工厂进行分割，<span style="color:#4da8ee;">为每种品牌的电视机提供一个子工厂，海尔工厂专门负责生产海尔电视机，海信工厂专门负责生产海信电视机，若增加TCL电视，只需要增加一个新的TCL工厂。</span></p> 
<p><img alt="" height="317" src="https://images2.imgbox.com/85/7c/aeDW8B9S_o.png" width="1200"></p> 
<p></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
 /*抽象产品类 TV(电视机类)*/ 
class TV
{
public:
  virtual void Show() = 0;
 virtual ~TV();//声明析构函数为虚函数，防止内存泄漏
};
 /*具体产品类 HairTV(海尔电视机类)*/ 
class HairTV : public TV
{
public:
  void Show()
  {
    cout&lt;&lt; "I'm HairTV"&lt;&lt;endl;
  }
};
/*具体产品类 HisenseTV(海信电视机类)*/
class HisenseTV : public TV
{
public:
  void Show()
  {
    cout&lt;&lt; "I'm HisenseTV"&lt;&lt;endl;
  }
};
/*工厂类(电视机工厂类)*/  
class TVFactory
{
public:
  virtual TV *CreateTV() = 0;
   virtual ~TVFactory(){};//析构函数声明为虚函数，防止内存泄漏
};
 /*具体工厂类 HairTVFactory(海尔电视机工厂类)*/ 
class HairTVFactory : public TVFactory
{
public:
  TV *CreateTV()
  {
    return new HairTV ();
  }
};
 /*具体工厂类 HisenseTV(海信电视机工厂类)*/ 
class HisenseTVFactory : public TVFactory
{
public:
  TV *CreateTV()
  {
    return new HisenseTV ();
  }
};
  
int main(int argc , char *argv [])
{
  TVFactory *hairTVFactory = new HairTVFactory();
  TV *hairTV = hairTVFactory-&gt;CreateTV();
  hairTV-&gt;Show();
  
  TVFactory *hisenseTVFactory = new HisenseTVFactory();
  TV *hisenseTV = hisenseTVFactory-&gt;CreateTV();
  hisenseTV-&gt;Show();
  
  if (hairTVFactory!= NULL)
  {
    delete hairTVFactory;
    hairTVFactory = NULL;
  }
  
  if (hairTV != NULL)
  {
    delete hairTV;
    hairTV = NULL;
  }
  
  if (hisenseTVFactory != NULL)
  {
    delete hisenseTVFactory;
    hisenseTVFactory = NULL;
  }
  
  if (hisenseTV != NULL)
  {
    delete hisenseTV;
    hisenseTV = NULL;
  }
  return 0;
}

</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="92" src="https://images2.imgbox.com/39/8c/fVAWk1BT_o.png" width="193"></p> 
<p></p> 
<h3>三、抽象工厂模式</h3> 
<h3>3.1 抽象工厂模式</h3> 
<p>抽象工厂模式是工厂方法模式的泛化版，工厂模式是一种特殊的抽象工厂模式，<span style="color:#fe2c24;">在工厂模式中，每个具体工厂只能生产一种具体的产品</span>，如海尔电视机厂只生产海尔电视机，而抽象工厂方法模式中，一个具体的工厂可以生产多个具体产品。</p> 
<h3>3.2 模式角色</h3> 
<p>产品等级结构与产品族：</p> 
<p>产品等级结构：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/6e/e1/mXBev0Go_o.png"></p> 
<p> （1）AbstractFactory（抽象工厂）</p> 
<p>抽象工厂用于声明生成抽象产品的方法，<span style="color:#38d8f0;">在一个抽象工厂中可以定义一组方法，每一个方法对应一个产品等级结构。</span></p> 
<p>（2）ConcreteFactory  （具体工厂）</p> 
<p>具体工厂实现了抽象工厂声明的抽象产品的方法，生成一组具体产品</p> 
<p>（3）AbstractProduct （抽象产品）</p> 
<p>抽象产品为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法。</p> 
<p>（4）ConcreteProdunct （具体产品）</p> 
<p>具体产品定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。</p> 
<p></p> 
<h3> 3.3 应用</h3> 
<p>当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说的更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来对产品进行创建，则更合适一点。</p> 
<ol><li>适合于产品之间相互关联、相互依赖且相互约束的地方</li><li>需要动态切换产品族的地方</li></ol> 
<h3>3.4 优缺点</h3> 
<p><strong>优点：</strong></p> 
<ol><li>抽象工厂模式将产品族的依赖与约束关系放到抽象工厂中，便于管理。</li><li>职责解耦，用户不需要关心一堆自己不关心的细节，由抽象工厂来负责组件的创建</li><li>切换产品族容易，只需要增加一个具体工厂实现，客户端选择另一个套餐就可以了</li></ol> 
<p><strong>缺点：</strong></p> 
<ol><li>抽象工厂模式类增加的速度很快，有一个产品族就需要增加一个具体工厂实现，比较繁琐</li><li>产品族难以扩展产品。当产品族中增加一个产品时，抽象工厂接口中需要增加一个函数，对应的所有具体工厂实现都需要修改，修改放大严重。</li><li>抽象工厂并未完全屏蔽创建细节，给出的都是组件。对于这种情况可以结合工厂模式或简单工厂模式一起使用。</li></ol> 
<h3>3.5 举例</h3> 
<p>如一个电器工厂可以生产多种类型的电器，如海尔工厂可以生产海尔电视机、海尔空调等，TCL工厂可以生产TCL电视、TCL空调等。<span style="color:#ff9900;">相同品牌的电器构成一个产品族，而相同类型的电器构成了一个产品等级结构。</span></p> 
<p><img alt="" height="706" src="https://images2.imgbox.com/a9/cc/SI4GP7GW_o.png" width="1200"></p> 
<p></p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
  
// 抽象产品类类 Television(电视机类)
class Television
{
public:
    virtual void Show() = 0;
    virtual ~Television(){};//析构函数声明为虚函数，防止内存泄漏
};

//具体产品类 HaierTelevision（海尔电视机类）
class HaierTelevision : public Television
{
public:
    void Show()
    {
        cout &lt;&lt; "I'm HaierTelevision" &lt;&lt; endl;
    }
};
//具体产品类 TCLTelevision（TCL电视机类）
class TCLTelevision : public Television
{
public:
    void Show()
    {
        cout &lt;&lt; "I'm TCLTelevision" &lt;&lt; endl;
    }
};

// 抽象产品类  AirCondition（空调类）
class AirCondition
{
public:
    virtual void Show() = 0;
    virtual ~AirCondition(){};//析构函数声明为虚函数，防止内存泄漏
};
//具体产品类 HairAirCondition(海尔空调类)
class HairAirCondition : public AirCondition
{
public:
    void Show()
    {
        cout &lt;&lt; "I'm HairAirCondition" &lt;&lt; endl;
    }
};
//具体产品类 TCLAirCondition(TCL空调类)
class TCLAirCondition : public AirCondition
{
public:
    void Show()
    {
        cout &lt;&lt; "I'm TCLAirCondition" &lt;&lt; endl;
    }
};

// 抽象工厂类 EFactory(电器工厂类)
class EFactory
{
public:
    virtual Television* CreateTelevision() = 0;
    virtual AirCondition* CreateAirCondition() = 0;
     virtual ~EFactory(){};//析构函数声明为虚函数，防止内存泄漏
};
//具体工厂类 HairFactory(海尔工厂类)
class HairFactory : public EFactory
{
public:
    Television* CreateTelevision()
    {
        return new HaierTelevision();
    }

    AirCondition* CreateAirCondition()
    {
        return new HairAirCondition();
    }
};
//具体工厂类 TCLFactory(TCL工厂类) 
class TCLFactory : public EFactory
{
public:
    Television* CreateTelevision()
    {
        return new TCLTelevision();
    }

    AirCondition* CreateAirCondition()
    {
        return new TCLAirCondition();
    }
};
  
int main(int argc, char *argv[])
{
  EFactory *hairFactory = new HairFactory ();/*实例化工厂抽象类*/
  Television *haierTelevision =hairFactory-&gt;CreateTelevision();/*实例化产品抽象类*/
  AirCondition *haierAirCondition = hairFactory-&gt;CreateAirCondition();
  
  haierTelevision-&gt;Show();
  haierAirCondition-&gt;Show();
  
  EFactory *tCLFactory = new TCLFactory ();
  Television *tCLTelevision = tCLFactory-&gt;CreateTelevision();
  AirCondition *tCLAirCondition = tCLFactory-&gt;CreateAirCondition();
  
  tCLTelevision-&gt;Show();
  tCLAirCondition-&gt;Show();
  
  if (hairFactory != NULL)
  {
    delete hairFactory;
    hairFactory = NULL;
  }
  
  if (haierTelevision != NULL)
  {
    delete haierTelevision;
    haierTelevision= NULL;
  }
  
  if (tCLAirCondition != NULL)
  {
    delete tCLAirCondition;
    tCLAirCondition = NULL;
  }
  
  if (tCLFactory != NULL)
  {
    delete tCLFactory;
    tCLFactory= NULL;
  }
  
  if (tCLTelevision != NULL)
  {
    delete tCLTelevision;
    tCLTelevision = NULL;
  }
  
  if (tCLAirCondition != NULL)
  {
    delete tCLAirCondition;
    tCLAirCondition = NULL;
  }
}</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="120" src="https://images2.imgbox.com/3e/5f/i0ykPL3m_o.png" width="277"></p> 
<p></p> 
<h2>四、总结</h2> 
<ol><li>大家应该已经发现了，其实抽象工厂模式如果只有一个组件的话，其实是退化到了工厂方法模式，也就是没有了产品族的概念，只剩一个产品了，因此简单工厂，工厂方法，抽象工厂这三者之间是有内在联系的，区别只是产品的复杂度。</li><li>抽象工厂的本质是选择产品族，因此大家可以根据这个特征来识别是否可以应用抽象工厂。</li></ol> 
<p>简单工厂：唯一工厂类，一个产品抽象类，工厂类的创建方法依据入参判断并创建具体产品对象。<br> 工厂方法：多个工厂类，一个产品抽象类，利用多态创建不同的产品对象，避免了大量的if-else判断。<br> 抽象工厂：多个工厂类，多个产品抽象类，产品子类分组，同一个工厂实现类创建同组中的不同产品，减少了工厂子类的数量。<br>  </p> 
<p> </p> 
<p></p> 
<p></p> 
<p>参考文献：</p> 
<p>【1】<a href="https://www.cnblogs.com/huiz/p/8232783.html" rel="nofollow" id="cb_post_title_url" title="工厂模式（C++实现）">工厂模式（C++实现）</a>：<a href="https://www.cnblogs.com/huiz/p/8232783.html" rel="nofollow" title="工厂模式（C++实现） - 1点er执着 - 博客园">工厂模式（C++实现） - 1点er执着 - 博客园</a></p> 
<p>【2】设计模式之简单工厂，工厂方法模式（c++）：<a href="https://blog.csdn.net/u012219045/article/details/60467306" title="设计模式之简单工厂，工厂方法模式（c++）_u012219045的专栏-CSDN博客_c++ 工厂方法模式">设计模式之简单工厂，工厂方法模式（c++）_u012219045的专栏-CSDN博客_c++ 工厂方法模式</a></p> 
<p>【3】<a href="https://www.cnblogs.com/jostree/p/4251756.html" rel="nofollow" title="C++实现设计模式之 — 简单工厂模式">C++实现设计模式之 — 简单工厂模式</a>：<a href="https://www.cnblogs.com/jostree/p/4251756.html" rel="nofollow" title="C++实现设计模式之 — 简单工厂模式 - jostree - 博客园">C++实现设计模式之 — 简单工厂模式 - jostree - 博客园</a></p> 
<p>【4】 C++设计模式之简单工厂模式实例：<a href="https://www.jb51.net/article/55858.htm" rel="nofollow" title="https://www.jb51.net/article/55858.htm">https://www.jb51.net/article/55858.htm</a></p> 
<p>【5】C++设计模式之工厂方法模式：<a href="https://www.jb51.net/article/55860.htm" rel="nofollow" title="https://www.jb51.net/article/55860.htm">https://www.jb51.net/article/55860.htm</a></p> 
<p>【6】C++设计模式之抽象工厂模式：<a href="https://www.jb51.net/article/55861.htm" rel="nofollow" title="https://www.jb51.net/article/55861.htm">https://www.jb51.net/article/55861.htm</a></p> 
<p>【7】抽象工厂模式和工厂模式的区别: <a href="https://www.zhihu.com/question/20367734" rel="nofollow" title="抽象工厂模式和工厂模式的区别？ - 知乎">抽象工厂模式和工厂模式的区别？ - 知乎</a></p> 
<p>【8】抽象工厂模式应用场景(24种设计模式优缺点)：<a href="https://www.haitaoseo.com/960718.html" rel="nofollow" title="https://www.haitaoseo.com/960718.html">https://www.haitaoseo.com/960718.html</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e2f3717d8660575047e93cc115d7ae25/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">勒索病毒现状和防御勒索病毒最佳实践（云端和线下个人电脑，服务器都可部署）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cf2e99b7f7b6db85387641032f8f80a3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring的@Bean注解原理详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>