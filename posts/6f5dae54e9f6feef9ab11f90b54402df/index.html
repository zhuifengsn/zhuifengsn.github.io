<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>InnoDB---读已提交隔离级别的实现 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="InnoDB---读已提交隔离级别的实现" />
<meta property="og:description" content="对于读已提交隔离级别的实现方式，从逻辑上需要明确两个部分，一是加锁部分二是解锁部分。加锁，对应的是获取数据，确保在指定的隔离级别下读取到应该读到的数据。解锁则意味着要在适当的时机释放锁且不影响隔离级别的语义还能提高并发度。
加锁部分，实现分为两个方面：一是加锁的时候，读已提交隔离级别不加间隙锁，这样就能允许并发的其他事务执行插入操作因而产生幻象现象，因为读已提交隔离级别是允许幻象异常存在的。如下代码，加锁的时候，根据隔离级别是否加间隙锁。
row_sel_get_clust_rec[1](...)
{...
if (!node-&gt;read_view) {
...
if (srv_locks_unsafe_for_binlog
|| trx-&gt;isolation_level &lt;= TRX_ISO_READ_COMMITTED) {
lock_type = LOCK_REC_NOT_GAP; //小于等于读已提交，则不加间隙锁，允许其他事务插入，因此可发生幻象
} else {
lock_type = LOCK_ORDINARY; //大于读已提交，则加间隙锁，防止其他事务插入某个范围内的数据，避免幻象
}
...} 其次，要确定可以读取到什么样的元组，即判断是不是没有被提交的元组也可以读到。既然是读已提交级别，则必然是只能读取到已经被提交的元组，这样才能体现“已提交”的含义。这时，就涉及到数据的可见性判断的问题（本节不讨论可见性问题，详情参见12.2节）。
解锁部分，要及时释放锁，这样便于其他事务能够读取到不应当被本事务锁定的记录（InnoDB中“记录”是索引项，通过记录才能真正找到元组）。以索引上的范围扫描为例，查看锁的释放条件。
ha_innopart::read_range_next_in_part(...) //Return next record in index range scan from a partition
{...
error = ha_innobase::index_next(read_record); //获得记录，则会加锁，此时error的值被赋予0
if (error == 0 &amp;&amp; !in_range_check_pushed_down) { //记录被加过了锁
/* compare_key uses table-&gt;record[0], so we need to copy the data if not already there. */" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/6f5dae54e9f6feef9ab11f90b54402df/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-04-19T14:18:44+08:00" />
<meta property="article:modified_time" content="2017-04-19T14:18:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">InnoDB---读已提交隔离级别的实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="bct fc05 fc11 nbw-blog ztag"> 
 <p><span style="font-size:10.5pt;"><span style="mso-spacerun:yes;">     </span>对于读已提交隔离级别的实现方式，从逻辑上需要明确两个部分，一是加锁部分二是解锁部分。加锁，对应的是获取数据，确保在指定的隔离级别下读取到应该读到的数据。解锁则意味着要在适当的时机释放锁且不影响隔离级别的语义还能提高并发度。<span lang="EN-US"></span></span></p> 
 <p><span style="font-size:10.5pt;" lang="EN-US"><span style="mso-spacerun:yes;">    </span></span><span style="font-size:10.5pt;">加锁部分，实现分为两个方面：一是加锁的时候，读已提交隔离级别不加间隙锁，这样就能允许并发的其他事务执行插入操作因而产生幻象现象，因为读已提交隔离级别是允许幻象异常存在的。如下代码，加锁的时候，根据隔离级别是否加间隙锁。<span lang="EN-US"></span></span></p> 
 <div style="mso-element:para-border-div;border:solid #CCCCCC 1.0pt;mso-border-alt: solid #CCCCCC .75pt;padding:4.0pt 31.0pt 4.0pt 4.0pt;background:#F0F7FE;"> 
  <p><b style="mso-bidi-font-weight:normal;"><span style="background:#D9D9D9;mso-shading:white;mso-pattern:gray-15 auto;" lang="EN-US">row_sel_get_clust_rec<a title="" style="mso-footnote-id:ftn1" href="http://blog.163.com/li_hx/blog/#_ftn1" rel="nofollow"><span style="mso-special-character:footnote;"><b style="mso-bidi-font-weight:normal;">[1]</b></span></a></span></b><span lang="EN-US">(...)</span></p> 
  <p><span lang="EN-US">{...</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">    </span>if (!node-&gt;read_view) {<!-- --></span></p> 
  <p><span lang="EN-US">...</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">        </span>if (srv_locks_unsafe_for_binlog</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">            </span>|| trx-&gt;isolation_level &lt;= <b style="mso-bidi-font-weight:normal;"><span style="background:#D9D9D9;mso-shading:white;mso-pattern:gray-15 auto;">TRX_ISO_READ_COMMITTED</span></b>) {<!-- --></span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">            </span>lock_type = <b style="mso-bidi-font-weight:normal;"><span style="background:#D9D9D9;mso-shading:white;mso-pattern:gray-15 auto;">LOCK_REC_NOT_GAP</span></b>;<span style="mso-spacerun:yes;">  </span>//</span><b style="mso-bidi-font-weight:normal;"><span style="background:#D9D9D9;mso-shading:white;mso-pattern:gray-15 auto;">小于等于读已提交，则不加间隙锁，允许其他事务插入，因此可发生幻象</span></b></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">        </span>} else {<!-- --></span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">            </span>lock_type = <b style="mso-bidi-font-weight:normal;"><span style="background:#D9D9D9;mso-shading:white;mso-pattern:gray-15 auto;">LOCK_ORDINARY</span></b>;<span style="mso-spacerun:yes;">  </span><span style="mso-spacerun:yes;">    </span>//</span><b style="mso-bidi-font-weight:normal;"><span style="background:#D9D9D9;mso-shading: white;mso-pattern:gray-15 auto;">大于读已提交，则加间隙锁，防止其他事务插入某个范围内的数据，避免幻象</span></b></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">        </span>}</span></p> 
  <p><span lang="EN-US">...}<span style="mso-spacerun:yes;">   </span></span></p> 
 </div> 
 <p><span style="font-size:10.5pt;" lang="EN-US"><span style="mso-spacerun:yes;">    </span></span><span style="font-size:10.5pt;">其次，要确定可以读取到什么样的元组，即判断是不是没有被提交的元组也可以读到。既然是读已提交级别，则必然是只能读取到已经被提交的元组，这样才能体现“已提交”的含义。这时，就涉及到数据的可见性判断的问题（本节不讨论可见性问题，详情参见<span lang="EN-US">12.2</span>节）。<span lang="EN-US"></span></span></p> 
 <p><span style="font-size:10.5pt;" lang="EN-US"> </span></p> 
 <p><span style="font-size:10.5pt;" lang="EN-US"><span style="mso-spacerun:yes;">    </span></span><span style="font-size:10.5pt;">解锁部分，要及时释放锁，这样便于其他事务能够读取到不应当被本事务锁定的记录（<span lang="EN-US">InnoDB</span>中“记录”是索引项，通过记录才能真正找到元组）。以索引上的范围扫描为例，查看锁的释放条件。<span lang="EN-US"></span></span></p> 
 <div style="mso-element:para-border-div;border:solid #CCCCCC 1.0pt;mso-border-alt: solid #CCCCCC .75pt;padding:4.0pt 31.0pt 4.0pt 4.0pt;background:#F0F7FE;"> 
  <p><span lang="EN-US">ha_innopart::<b style="mso-bidi-font-weight:normal;"><span style="background:#D9D9D9;mso-shading:white;mso-pattern:gray-15 auto;">read_range_next_in_part</span></b>(...)<span style="mso-spacerun:yes;">  </span>//<b style="mso-bidi-font-weight:normal;">Return next record in <span style="background:#D9D9D9;mso-shading:white;mso-pattern: gray-15 auto;">index range scan</span> from a partition</b></span></p> 
  <p><span lang="EN-US">{...</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">    </span>error = ha_innobase::index_next(read_record); //</span><b style="mso-bidi-font-weight: normal;"><span style="background:#D9D9D9;mso-shading:white;mso-pattern:gray-15 auto;">获得记录，则会加锁，此时<span lang="EN-US">error</span>的值被赋予<span lang="EN-US">0</span></span></b></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">    </span>if (<b style="mso-bidi-font-weight:normal;"><span style="background:#D9D9D9;mso-shading: white;mso-pattern:gray-15 auto;">error == 0</span></b> &amp;&amp; !in_range_check_pushed_down) {<!-- --><span style="mso-spacerun:yes;">  </span>//</span>记录被加过了锁</p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">        </span>/* compare_key uses table-&gt;record[0], so we need to copy the da<wbr></wbr>ta if not already there. */</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">        </span>if (record != NULL) {<!-- --></span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">            </span><b style="mso-bidi-font-weight:normal;">copy_cached_row</b>(<b style="mso-bidi-font-weight: normal;"><span style="background:#D9D9D9;mso-shading:white;mso-pattern:gray-15 auto;">table-&gt;record[0]<a title="" style="mso-footnote-id:ftn2" href="http://blog.163.com/li_hx/blog/#_ftn2" rel="nofollow"><span style="mso-special-character:footnote;"><b style="mso-bidi-font-weight:normal;">[2]</b></span></a></span></b>, read_record); //</span><b style="mso-bidi-font-weight:normal;"><span style="background:#D9D9D9;mso-shading:white;mso-pattern:gray-15 auto;">复制获取到的元组到表级的数据缓冲区</span></b></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">        </span>}</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">        </span>if (compare_key(end_range) &gt; 0) { //</span><b style="mso-bidi-font-weight:normal;"><span style="background:#D9D9D9;mso-shading:white;mso-pattern:gray-15 auto;">超出要读取的范围，则释放锁</span></b></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">            </span>/* must use ha_innobase:: due to set/update_partition</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">            </span>could overwrite states if ha_innopart::unlock_row() was used. */</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">            </span>ha_innobase::<b style="mso-bidi-font-weight:normal;"><span style="background:#D9D9D9;mso-shading:white;mso-pattern:gray-15 auto;">unlock_row</span></b>();//</span><b style="mso-bidi-font-weight:normal;"><span style="background:#D9D9D9;mso-shading: white;mso-pattern:gray-15 auto;">释放锁</span></b></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">            </span>error = HA_ERR_END_OF_FILE;</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">        </span>}</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">    </span>}</span></p> 
  <p><span lang="EN-US">...</span></p> 
  <p><span lang="EN-US">}</span></p> 
 </div> 
 <p><span style="font-size:10.5pt;" lang="EN-US"><span style="mso-spacerun:yes;">    </span></span><span style="font-size:10.5pt;">根据隔离级别确定是否要释放锁。<span lang="EN-US"></span></span></p> 
 <div style="mso-element:para-border-div;border:solid #CCCCCC 1.0pt;mso-border-alt: solid #CCCCCC .75pt;padding:4.0pt 31.0pt 4.0pt 4.0pt;background:#F0F7FE;"> 
  <p><span lang="EN-US">/** <b style="mso-bidi-font-weight:normal;">Removes a new lock </b>set on a row, if it was not read optimistically. This can be called after a row has been read</span></p> 
  <p><span lang="EN-US">in the processing of an <b style="mso-bidi-font-weight: normal;">UPDATE or a DELETE</b> query, if the option innodb_locks_unsafe_for_binlog is set. */</span></p> 
  <p><span lang="EN-US">void<span style="mso-spacerun:yes;">    </span>//</span><b style="mso-bidi-font-weight:normal;">被<span lang="EN-US">mysql_update()/mysql_delete()</span>调用，用于为记录解锁。另外少数情况是：被<span lang="EN-US">join_read_key()</span>等调用</b></p> 
  <p><span lang="EN-US">ha_innobase::<b style="mso-bidi-font-weight:normal;"><span style="background:#D9D9D9;mso-shading:white;mso-pattern:gray-15 auto;">unlock_row</span></b>(void)<span style="mso-spacerun:yes;">   </span>//</span><b style="mso-bidi-font-weight: normal;">在<span lang="EN-US">UPDATE</span>或<span lang="EN-US">DELETE</span>执行时，一个元组被读取操作后，所施加的锁“可能”被本方法释放</b></p> 
  <p><span lang="EN-US">{...<span style="mso-spacerun:yes;">                            </span>//</span><b style="mso-bidi-font-weight:normal;">所施加的锁是否被释放，取决于下面对隔离级别的判断</b></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">    </span>switch (m_prebuilt-&gt;row_read_type) {<!-- --></span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">    </span>case ROW_READ_WITH_LOCKS:</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">        </span>if (!srv_locks_unsafe_for_binlog</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">            </span>&amp;&amp; m_prebuilt-&gt;trx-&gt;isolation_level</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">            </span>&gt; <b style="mso-bidi-font-weight:normal;"><span style="background: #D9D9D9;mso-shading:white;mso-pattern:gray-15 auto;">TRX_ISO_READ_COMMITTED</span></b>) {<!-- --><span style="mso-spacerun:yes;">  </span>//</span><b style="mso-bidi-font-weight: normal;"><span style="background:#D9D9D9;mso-shading:white;mso-pattern:gray-15 auto;">隔离级别是可重复读或序列化，则满足大于读已提交，所以执行<span lang="EN-US">break</span>不解锁</span></b></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">            </span>break;</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">        </span>}</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">        </span>/* fall through */</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;"> </span><span style="mso-spacerun:yes;">   </span>case ROW_READ_TRY_SEMI_CONSISTENT:<span style="mso-spacerun:yes;">  </span></span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">        </span><b style="mso-bidi-font-weight:normal;"><span style="background:#D9D9D9;mso-shading: white;mso-pattern:gray-15 auto;">row_unlock_for_mysql</span></b>(m_prebuilt, FALSE); <span style="mso-spacerun:yes;"> </span>//</span><b style="mso-bidi-font-weight: normal;"><span style="background:#D9D9D9;mso-shading:white;mso-pattern:gray-15 auto;">如果是读已提交隔离级别，则能执行到解锁操作</span></b></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">        </span>break; <span style="mso-spacerun:yes;"> </span>//</span><b style="mso-bidi-font-weight:normal;"><span style="background:#D9D9D9;mso-shading: white;mso-pattern:gray-15 auto;">意味着读已提交隔离级别加锁过后，则释放锁，而不是等待事务结束时释放锁。所以更新等操作可以被其他事务有机会看到<a title="" style="mso-footnote-id:ftn3" href="http://blog.163.com/li_hx/blog/#_ftn3" rel="nofollow"><span lang="EN-US"><span style="mso-special-character: footnote;"><b style="mso-bidi-font-weight:normal;">[3]</b></span></span></a></span></b></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">    </span>case ROW_READ_DID_SEMI_CONSISTENT:</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">        </span>m_prebuilt-&gt;row_read_type = ROW_READ_TRY_SEMI_CONSISTENT;</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">        </span>break;</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">    </span>}</span></p> 
  <p><span lang="EN-US">...</span></p> 
  <p><span lang="EN-US">}</span></p> 
 </div> 
 <p><span style="font-size:10.5pt;" lang="EN-US"><span style="mso-spacerun:yes;">    </span></span><span style="font-size:10.5pt;">紧接着，判断并发事务间的提交关系（涉及了可见性判断规则：通过<span lang="EN-US">lock_clust_rec_cons_read_sees()</span>调用<span lang="EN-US">changes_visible()</span>利用元组上的事务<span lang="EN-US">ID</span>与快照的左右边界比较），然后再确定是否是解锁。如下是解锁的过程。</span></p> 
 <div style="mso-element:para-border-div;border:solid #CCCCCC 1.0pt;mso-border-alt: solid #CCCCCC .75pt;padding:4.0pt 31.0pt 4.0pt 4.0pt;background:#F0F7FE;"> 
  <p><span lang="EN-US">/** This can on<wbr></wbr>ly be used when srv_locks_unsafe_for_binlog is TRUE or this</span></p> 
  <p><span lang="EN-US">session is using a <b style="mso-bidi-font-weight: normal;"><span style="background:#D9D9D9;mso-shading:white;mso-pattern:gray-15 auto;">READ COMMITTED</span></b> or<b style="mso-bidi-font-weight:normal;"> <span style="background:#D9D9D9;mso-shading:white;mso-pattern:gray-15 auto;">READ UNCOMMITTED</span></b> isolation level.</span></p> 
  <p><span lang="EN-US">Before calling this function row_search_for_mysql() must have initialized prebuilt-&gt;new_rec_locks to store the information which new</span></p> 
  <p><span lang="EN-US">record locks really were set. This function removes a newly set clustered index record lock under prebuilt-&gt;pcur or</span></p> 
  <p><span lang="EN-US">prebuilt-&gt;clust_pcur.<span style="mso-spacerun:yes;">  </span>Thus, this implements a 'mini-rollback' that releases the latest clustered index record lock we set.</span></p> 
  <p><span lang="EN-US">@param[in,out]<span style="mso-spacerun:yes;">    </span>prebuilt<span style="mso-spacerun:yes;">       </span><span style="mso-spacerun:yes;">       </span><span style="mso-spacerun:yes;"> </span>prebuilt struct in MySQL handle</span></p> 
  <p><span lang="EN-US">@param[in]<span style="mso-spacerun:yes;">  </span><span style="mso-spacerun:yes;">    </span><span style="mso-spacerun:yes;">  </span>has_latches_on_recs<span style="mso-spacerun:yes;">    </span>TRUE if called so that we have the latches on the records under pcur</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">                    </span><span style="mso-spacerun:yes;">                           </span>and clust_pcur, and we do not need to reposition the cursors. */</span></p> 
  <p><span lang="EN-US">void</span></p> 
  <p><b style="mso-bidi-font-weight:normal;"><span style="background:#D9D9D9;mso-shading:white;mso-pattern:gray-15 auto;" lang="EN-US">row_unlock_for_mysql</span></b><span lang="EN-US">(row_prebuilt_t* prebuilt, ibool has_latches_on_recs)</span></p> 
  <p><span lang="EN-US">{...</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">    </span>if (prebuilt-&gt;new_rec_locks &gt;= 1) {<!-- --></span></p> 
  <p><span lang="EN-US">...</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">        </span>/* If the record has been modified by this transaction, do not unlock it. */</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">        </span>if (index-&gt;trx_id_offset) {<!-- --><span style="mso-spacerun:yes;">  </span>//</span><b style="mso-bidi-font-weight:normal;"><span style="background:#D9D9D9;mso-shading: white;mso-pattern:gray-15 auto;">如果是被本事务修改，则不释放锁（修改元组则会写事务<span lang="EN-US">ID</span>到元组中）</span></b></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">            </span><b style="mso-bidi-font-weight:normal;"><span style="background:#D9D9D9;mso-shading: white;mso-pattern:gray-15 auto;">rec_trx_id</span></b> = trx_read_trx_id(rec + index-&gt;trx_id_offset);<span style="mso-spacerun:yes;">  </span>//</span><b style="mso-bidi-font-weight:normal;">获得元组上的事务<span lang="EN-US">id</span>值</b></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">        </span>} else {...</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">            </span>offsets = rec_get_offsets(rec, index, offsets, ULINT_UNDEFINED, &amp;heap);</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">            </span><b style="mso-bidi-font-weight:normal;"><span style="background:#D9D9D9;mso-shading: white;mso-pattern:gray-15 auto;">rec_trx_id</span></b> = <b style="mso-bidi-font-weight: normal;"><span style="background:#D9D9D9;mso-shading:white;mso-pattern:gray-15 auto;">row_get_rec_trx_id</span></b>(rec, index, offsets); <span style="mso-spacerun:yes;">   </span><span style="mso-spacerun:yes;"> </span><span style="mso-spacerun:yes;"> </span>//</span><b style="mso-bidi-font-weight:normal;">获得元组上的事务<span lang="EN-US">id</span>值</b></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">            </span>if (UNIV_LIKELY_NULL(heap)) {<!-- --></span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">                </span>mem_heap_free(heap);</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">            </span>}</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">        </span>}</span></p> 
  <p><span lang="EN-US"> </span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">        </span>if (<b style="mso-bidi-font-weight:normal;"><span style="background:#D9D9D9;mso-shading: white;mso-pattern:gray-15 auto;">rec_trx_id</span></b> != trx-&gt;id) {<!-- --><span style="mso-spacerun:yes;">  </span>//</span><b style="mso-bidi-font-weight:normal;"><span style="background:#D9D9D9;mso-shading:white;mso-pattern:gray-15 auto;">元组上的事务<span lang="EN-US">id</span>不是本事务的<span lang="EN-US">id</span>，表明元组是被其他事务修改，释放锁</span></b></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">            </span>/* We did not update the record: unlock it */</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">            </span>rec = btr_pcur_get_rec(pcur);</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">            </span><b style="mso-bidi-font-weight:normal;"><span style="background:#D9D9D9;mso-shading: white;mso-pattern:gray-15 auto;">lock_rec_unlock</span></b>(trx, btr_pcur_get_block(pcur), rec, static_cast&lt;enum lock_mode&gt;(prebuilt-&gt;select_lock_type));</span></p> 
  <p><span lang="EN-US"> </span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">            </span>if (prebuilt-&gt;new_rec_locks &gt;= 2) {<!-- --><span style="mso-spacerun:yes;">  </span>//<b style="mso-bidi-font-weight:normal;">new_rec_lock</b></span><b style="mso-bidi-font-weight:normal;">通常是<span lang="EN-US">0</span>，如果隔离级别是<span lang="EN-US">READ COMMITTED</span>或<span lang="EN-US">READ UNCOMMITTED</span></b></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">                </span>rec = btr_pcur_get_rec(clust_pcur);<span style="mso-spacerun:yes;">  </span>//</span><b style="mso-bidi-font-weight:normal;">则在<span lang="EN-US">row_search_mvcc()</span>中获得记录锁后设置为<span lang="EN-US">2</span>，所以需要对应解锁</b></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">                </span><b style="mso-bidi-font-weight:normal;"><span style="background:#D9D9D9; mso-shading:white;mso-pattern:gray-15 auto;">lock_rec_unlock</span></b>(trx, btr_pcur_get_block(clust_pcur), rec, static_cast&lt;enum lock_mode&gt;(prebuilt-&gt;select_lock_type));</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">            </span>}</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">        </span>}</span></p> 
  <p><span lang="EN-US">no_unlock:</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">        </span>mtr_commit(&amp;mtr);</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">    </span>}</span></p> 
  <p><span lang="EN-US">...</span></p> 
  <p><span lang="EN-US">}</span></p> 
 </div> 
 <p><span style="font-size:10.5pt;" lang="EN-US"><span style="mso-spacerun:yes;">   </span></span></p> 
 <p><span style="font-size:10.5pt;" lang="EN-US"><span style="mso-spacerun:yes;">    </span></span><span style="font-size:10.5pt;">在一个事务块内，如果存在多条<span lang="EN-US">SELECT</span>语句，则在读已提交隔离级别下，每条<span lang="EN-US">SELECT</span>语句分别使用自己的快照（<span lang="EN-US">Read view</span>，即为每条<span lang="EN-US">SELECT</span>生成一个<span lang="EN-US">Read view</span>，每条<span lang="EN-US">SELECT</span>结束后，通过调用<span lang="EN-US">MVCC::view_close()</span>方法，<span lang="EN-US">Read view</span>会被关闭）。<span lang="EN-US"></span></span></p> 
 <p><span style="font-size:10.5pt;" lang="EN-US"><span style="mso-spacerun:yes;">    </span></span><span style="font-size:10.5pt;">对于一个<span lang="EN-US">UPDATE</span>或<span lang="EN-US">DELETE</span>操作，当有页面（索引页面）因增加或删除了元组而分离或合并时，需要让新页继承旧页的锁信息，这时继承操作是通过<span lang="EN-US">lock_rec_add_to_queue()</span>函数加锁完成的，但是，加锁时会有间隙锁存在，代码如下：<span lang="EN-US"></span></span></p> 
 <div style="mso-element:para-border-div;border:solid #CCCCCC 1.0pt;mso-border-alt: solid #CCCCCC .75pt;padding:4.0pt 31.0pt 4.0pt 4.0pt;background:#F0F7FE;"> 
  <p><b style="mso-bidi-font-weight:normal;"><span style="background:#D9D9D9;mso-shading:white;mso-pattern:gray-15 auto;" lang="EN-US">lock_rec_add_to_queue</span></b><span lang="EN-US">(<span style="mso-spacerun:yes;">  </span>//</span><b style="mso-bidi-font-weight:normal;"><span style="background:#D9D9D9;mso-shading: white;mso-pattern:gray-15 auto;">被<span lang="EN-US">lock_rec_inherit_to_gap()</span>调用，在原先的锁的基础上加持间隙锁<span lang="EN-US">GAP</span></span></b></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">        </span>LOCK_REC | <b style="mso-bidi-font-weight:normal;"><span style="background:#D9D9D9;mso-shading:white;mso-pattern:gray-15 auto;">LOCK_GAP</span></b> | lock_get_mode(lock),<span style="mso-spacerun:yes;">  </span>//<b style="mso-bidi-font-weight:normal;">lock_get_mode(lock)</b></span><b style="mso-bidi-font-weight:normal;">是原先锁的粒度和类型，<span style="background:#D9D9D9;mso-shading:white;mso-pattern:gray-15 auto;" lang="EN-US">LOCK_GAP</span><span style="background:#D9D9D9;mso-shading:white;mso-pattern:gray-15 auto;">是必须加持的类型</span></b></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">        </span>heir_block, heir_heap_no, lock-&gt;index,</span></p> 
  <p><span lang="EN-US"><span style="mso-spacerun:yes;">        </span>lock-&gt;trx, FALSE);</span></p> 
 </div> 
 <div style="mso-element:footnote-list;"> 
  <br> 
  <hr size="1" align="left" width="33%"> 
  <div style="mso-element:footnote;"> 
   <p><a title="" style="mso-footnote-id:ftn1" href="http://blog.163.com/li_hx/blog/#_ftnref1" rel="nofollow"><span lang="EN-US"><span style="mso-special-character:footnote;">[1]</span></span></a><span lang="EN-US"> </span>位于<span lang="EN-US">row0sel.cc</span>文件中。</p> 
  </div> 
  <div style="mso-element:footnote;"> 
   <p><a title="" style="mso-footnote-id:ftn2" href="http://blog.163.com/li_hx/blog/#_ftnref2" rel="nofollow"><span lang="EN-US"><span style="mso-special-character:footnote;">[2]</span></span></a><span lang="EN-US"> </span>执行器使用的表的数据就是从<b style="mso-bidi-font-weight:normal;"><span style="background:#D9D9D9; mso-shading:white;mso-pattern:gray-15 auto;" lang="EN-US">table-&gt;record[0]</span></b>获得的。</p> 
  </div> 
  <div style="mso-element:footnote;"> 
   <p><a title="" style="mso-footnote-id:ftn3" href="http://blog.163.com/li_hx/blog/#_ftnref3" rel="nofollow"><span lang="EN-US"><span style="mso-special-character:footnote;">[3]</span></span></a><span lang="EN-US"> </span>注意，只是存在能被其他事务读到修改后的数据的可能，单是还没有判断事务是否已经提交。</p> 
  </div> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7330c72d4d7506e7cb5fdb39addea23b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;11新特性</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ad30594de9fe421abb24f0e9fc0c3a79/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">html escape unescape</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>