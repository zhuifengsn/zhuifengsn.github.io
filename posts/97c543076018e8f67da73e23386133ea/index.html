<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>浅析kubernates的pv和pvc - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="浅析kubernates的pv和pvc" />
<meta property="og:description" content="文章目录 概要名词解释什么是Pod什么是StorgeClass静态PV和动态PVPV和PVC的生命周期 PVC ， PV和 StorageClass的关系小结 概要 最近，在看许多Kubenates的相关文章的时候，了解到了一个概念，是我之前不清楚的。–PV&amp;PVC 。那么今天就总结下这几天的收获。
在总结之前我先解释下PV和PVC是什么意思。
PV：Persistent VolumePVC：Persistent Volume Claim 【通俗字面理解】
从英文的解释上看，大致可以理解为PV就是一个持久化的卷；PVC就是PV的声明
【docker层面理解】
谈到卷，相信学习过docker的小伙伴并不陌生。Volume用于持久化数据的一种机制。那么就可以把PV看做成docker里的卷，那么PVC又怎么理解呢？就是用于统一调用管理PV的。
【官方解释】
PV :持久化卷的意思，是对底层的共享存储的一种抽象
PVC（Persistent Volume Claim）：是持久卷请求于存储需求的一种声明(PVC其实就是用户向kubernetes系统发出的一种资源需求申请。)
这里还需要明确几个职责：
存储：存储工程师维护PV： kubernetes管理员维护PVC：kubernetes用户维护 所以kubernates引入了pvc的概念后，用户就很好的能够使资源的利用率达到最高
名词解释 上面在简单的了解了什么是PV和PVC之后，接下来根据上图所示，介绍几个概念。
概述：
什么是Pod什么是StorageClass静态PV和动态PVPV和PVC的生命周期 什么是Pod Pod是kubernetes中最小的资源管理组件，Pod也是最小化运行容器化应用的资源对象。
大家都知道，docker是利用生成镜像在容器里运行的工具。
kubernates则是通过Pod承载容器进行运行的工具。
在k8s里一个Pod可以运行一个容器，也可以运行多个容器。不过最常用的是单个容器。
什么是StorgeClass 在上图种，我们可以看到Pod与我们的PVC进行绑定，换言之，Pod消耗的是PVC。然后PVC请求PV资源，而PV资源必须要是管理员事先创建好的。
这样一来就会存在一个问题，当我们的Pod请求的资源没有相应的PV去与PVC匹配的时候，这个时候就必须要管理员手动创建PV。二者之间必然会存在一定的误差，这个时候就引入了StorgeClass
可用于将存储资源定义为具有显着特性的类别（Class）而不是具体的PV，用户通过PVC直接向意向的类别发出申请，匹配由管理员事先创建的PV，或者由其按需为用户动态创建PV，这样做甚至免去了需要事先创建PV的过程。
静态PV和动态PV 在了解了StorgeClass机制后，我们就很好的理解什么是静态PV和动态PV
【静态】：
需要我们自己去手动创建，业务少的情况下可以用手动创建。
【动态】：
根据 yaml 文件里面的参数自动创建合适的 pv，业务量大或者静态 pv 无法满足需求的时候需要动态创建 pv。
PV和PVC的生命周期 其实不论是PV还是PVC，他们之间的关联关系都遵循着一个统一的生命周期：
资源创建–&gt;资源绑定–&gt;资源使用–&gt;资源释放–&gt;资源回收。这么一个生命周期。
【资源创建】
由管理员静态创建PV，或者由PVC动态创建PV。
【资源绑定】
由PVC根据Pod所需要的资源大小以及读取模式绑定PV。PV一旦被绑定，就被该Pod独占。
【资源使用】
PV一旦被PVC绑定，那么Pod就可以像使用Volume一样根据PVC的定义消耗PVC，进而PVC消耗PV
【资源释放】
用户删除PVC来释放PV
当存储资源使用完毕后，用户可以删除PVC，与该PVC绑定的PV将会被标记为“已释放”，但还不能立刻与其他的PVC进行绑定，通过之前PVC写入的数据可能还被留在存储设备上，只有在清除之后该PV才能再次使用
【资源回收】
Kubernetes根据PV设置的回收策略进行资源的回收
对于PV，管理员可以设定回收策略，用于设置与之绑定的PVC释放资源之后如何处理遗留数据的问题，只有PV的存储空间完成回收，才能供新的PVC绑定和使用
PVC ， PV和 StorageClass的关系 PVC 描述的** 是 Pod 想要使用的持久化存储的属性** 。比如存储的大小、读写权限等。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/97c543076018e8f67da73e23386133ea/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-06T17:42:34+08:00" />
<meta property="article:modified_time" content="2023-06-06T17:42:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">浅析kubernates的pv和pvc</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_1" rel="nofollow">概要</a></li><li><a href="#_28" rel="nofollow">名词解释</a></li><li><ul><li><a href="#Pod_37" rel="nofollow">什么是Pod</a></li><li><a href="#StorgeClass_43" rel="nofollow">什么是StorgeClass</a></li><li><a href="#PVPV_49" rel="nofollow">静态PV和动态PV</a></li><li><a href="#PVPVC_58" rel="nofollow">PV和PVC的生命周期</a></li></ul> 
   </li><li><a href="#PVC__PV_StorageClass_75" rel="nofollow">PVC ， PV和 StorageClass的关系</a></li><li><a href="#_80" rel="nofollow">小结</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_1"></a>概要</h3> 
<p><code> 最近，在看许多Kubenates的相关文章的时候，了解到了一个概念，是我之前不清楚的。</code>–<strong><code>PV&amp;PVC</code></strong> 。那么今天就总结下这几天的收获。</p> 
<p>在总结之前我先解释下PV和PVC是什么意思。</p> 
<ul><li>PV：Persistent Volume</li><li>PVC：Persistent Volume Claim</li></ul> 
<p>【通俗字面理解】</p> 
<blockquote> 
 <p>从英文的解释上看，大致可以理解为PV就是一个持久化的卷；PVC就是PV的声明</p> 
</blockquote> 
<hr> 
<p>【docker层面理解】</p> 
<blockquote> 
 <p>谈到卷，相信学习过docker的小伙伴并不陌生。Volume用于持久化数据的一种机制。那么就可以把PV看做成docker里的卷，那么PVC又怎么理解呢？就是用于统一调用管理PV的。</p> 
</blockquote> 
<p>【官方解释】</p> 
<blockquote> 
 <p><code>PV :</code>持久化卷的意思，是对底层的共享存储的一种抽象<br> <code>PVC（Persistent Volume Claim）：</code>是持久卷请求于存储需求的一种声明(PVC其实就是用户向kubernetes系统发出的一种资源需求申请。)</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/b3/81/g8tztY2W_o.png" alt="在这里插入图片描述"><br> 这里还需要明确几个职责：</p> 
<ul><li>存储：存储工程师维护</li><li>PV： kubernetes管理员维护</li><li>PVC：kubernetes用户维护</li></ul> 
<p>所以kubernates引入了pvc的概念后，用户就很好的能够使资源的利用率达到最高</p> 
<h3><a id="_28"></a>名词解释</h3> 
<p>上面在简单的了解了什么是PV和PVC之后，接下来根据上图所示，介绍几个概念。</p> 
<p>概述：</p> 
<ul><li>什么是Pod</li><li>什么是StorageClass</li><li>静态PV和动态PV</li><li>PV和PVC的生命周期</li></ul> 
<h4><a id="Pod_37"></a>什么是Pod</h4> 
<p>Pod是kubernetes中最小的资源管理组件，Pod也是最小化运行容器化应用的资源对象。<br> 大家都知道，docker是利用生成镜像在容器里运行的工具。<br> kubernates则是通过Pod承载容器进行运行的工具。<br> 在k8s里一个Pod可以运行一个容器，也可以运行多个容器。不过最常用的是单个容器。</p> 
<h4><a id="StorgeClass_43"></a>什么是StorgeClass</h4> 
<p>在上图种，我们可以看到Pod与我们的PVC进行绑定，换言之，Pod消耗的是PVC。然后PVC请求PV资源，而PV资源必须要是管理员事先创建好的。<br> 这样一来就会存在一个问题，当我们的Pod请求的资源没有相应的PV去与PVC匹配的时候，这个时候就必须要管理员手动创建PV。二者之间必然会存在一定的误差，这个时候就引入了<code>StorgeClass</code></p> 
<p><strong>可用于将存储资源定义为具有显着特性的类别（Class）而不是具体的PV，用户通过PVC直接向意向的类别发出申请，匹配由管理员事先创建的PV，或者由其按需为用户动态创建PV，这样做甚至免去了需要事先创建PV的过程。</strong></p> 
<h4><a id="PVPV_49"></a>静态PV和动态PV</h4> 
<p>在了解了StorgeClass机制后，我们就很好的理解什么是静态PV和动态PV</p> 
<p>【静态】：<br> 需要我们自己去手动创建，业务少的情况下可以用手动创建。</p> 
<p>【动态】：<br> 根据 yaml 文件里面的参数自动创建合适的 pv，业务量大或者静态 pv 无法满足需求的时候需要动态创建 pv。</p> 
<h4><a id="PVPVC_58"></a>PV和PVC的生命周期</h4> 
<p>其实不论是PV还是PVC，他们之间的关联关系都遵循着一个统一的生命周期：<br> 资源创建–&gt;资源绑定–&gt;资源使用–&gt;资源释放–&gt;资源回收。这么一个生命周期。</p> 
<p>【资源创建】<br> 由管理员静态创建PV，或者由PVC动态创建PV。<br> 【资源绑定】<br> 由PVC根据Pod所需要的资源大小以及读取模式绑定PV。PV一旦被绑定，就被该Pod独占。<br> 【资源使用】<br> PV一旦被PVC绑定，那么Pod就可以像使用Volume一样根据PVC的定义消耗PVC，进而PVC消耗PV<br> 【资源释放】<br> 用户删除PVC来释放PV<br> 当存储资源使用完毕后，用户可以删除PVC，与该PVC绑定的PV将会被标记为“已释放”，<code>但还不能立刻与其他的PVC进行绑定，通过之前PVC写入的数据可能还被留在存储设备上，只有在清除之后该PV才能再次使用</code><br> 【资源回收】<br> Kubernetes根据PV设置的回收策略进行资源的回收<br> 对于PV，管理员可以设定回收策略，用于设置与之绑定的PVC释放资源之后如何处理遗留数据的问题，<code>只有PV的存储空间完成回收，才能供新的PVC绑定和使用</code></p> 
<h3><a id="PVC__PV_StorageClass_75"></a>PVC ， PV和 StorageClass的关系</h3> 
<ul><li> <p>PVC 描述的<code>** 是 Pod 想要使用的持久化存储的属性** </code>。比如存储的大小、读写权限等。</p> </li><li> <p>PV 描述的<code>则是一个具体的 Volume 的属性</code>，比如 Volume 的类型、挂载目录、远程存储服务器地址等。</p> </li><li> <p>而 StorageClass 的作用，<code>则是充当 PV 的模板</code>。并且，<strong>只有同属于一个 StorageClass 的 PV 和 PVC，才可以绑定在一起。</strong></p> </li></ul> 
<h3><a id="_80"></a>小结</h3> 
<p>pv，pvc实际上可以看作是接口和实现类的关系。<br> pvc定义了pod所需要的存储属性，pvc根据这个属性调用了某一个可以实现此存储能力的pv。<br> 这样理解pv和pvc就比较轻松了。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1c15585845bad1456e0802420bd106a9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言课程设计——职工信息管理系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a42025ca875e82a435ebe695cc0d282e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">提取文件夹内所有文件名</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>