<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言实现Vigenere(维吉利亚)加密 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言实现Vigenere(维吉利亚)加密" />
<meta property="og:description" content="维吉尼亚密码 人们在单一 恺撒密码的基础上扩展出多表密码，称为“维吉尼亚”密码。该方法最早记录在 吉奥万·巴蒂斯塔·贝拉索（ Giovan Battista Bellaso）于1553年所著的书《吉奥万·巴蒂斯塔·贝拉索先生的密码》（意大利语：La cifra del. Sig. Giovan Battista Bellaso）中。 维吉尼亚密码引入了“ 密钥”的概念，即根据密钥来决定用哪一行的密表来进行替换，以此来对抗字频统计。假如以上面第一行代表明文字母，左面第一列代表密钥字母，对如下明文加密： TO BE OR NOT TO BE THAT IS THE QUESTION 当选定RELATIONS作为密钥时，加密过程是：明文一个字母为T，第一个密钥字母为R，因此可以找到在R行中代替T的为K，依此类推，得出对应关系如下： 密钥:RELAT IONSR ELATI ONSRE LATIO NSREL 明文:TOBEO RNOTT OBETH ATIST HEQUE STION 密文:KSMEH ZBBLK SMEMP OGAJX SEJCS FLZSY 历史上以维吉尼亚密表为基础又演变出很多种加密方法，其基本元素无非是密表与密钥，并一直沿用到二战以后的初级电子密码机上。 公元16世纪晚期，想要获得更高的保密度的人获得了一种设计更加精细的密码表。 实现图片：
实现代码：
#include &lt;stdio.h&gt; #include &lt;malloc.h&gt; #include &lt;stdlib.h&gt; #include &lt;memory.h&gt; #define MAXSIZE 1000 typedef struct duplexNode{ char alphabet; struct duplexNode * previous; struct duplexNode * next; }DuplexNode,*DuplexLinkList; typedef enum{ FAILED,SUCCESS }Status; Status initDuplexLinkList(DuplexLinkList * duplexLinkList); void vigenere(DuplexLinkList *duplexLinkList,char al,int n); char * s_gets(char * s,int n); int main(void) { char str_temp[MAXSIZE] = {&#39;\0&#39;}; int rand_temp[MAXSIZE] = {0}; int j = 0; DuplexLinkList duplexLinkList = NULL; if(initDuplexLinkList(&amp;duplexLinkList) == FAILED) { fprintf(stderr,&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/bfec4dac38a17b394a61f5859ff01c31/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-02-17T11:53:15+08:00" />
<meta property="article:modified_time" content="2018-02-17T11:53:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言实现Vigenere(维吉利亚)加密</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<dl class="lemmaWgt-lemmaTitle lemmaWgt-lemmaTitle-"> 
 <dd class="lemmaWgt-lemmaTitle-title"> 
  <h2>维吉尼亚密码</h2> 
 </dd> 
</dl> 
<div class="lemma-summary"> 
 <div class="para">
   人们在单一 
  <a href="https://baike.baidu.com/item/%E6%81%BA%E6%92%92%E5%AF%86%E7%A0%81" rel="nofollow">恺撒密码</a>的基础上扩展出多表密码，称为“维吉尼亚”密码。该方法最早记录在 
  <a href="https://baike.baidu.com/item/%E5%90%89%E5%A5%A5%E4%B8%87%C2%B7%E5%B7%B4%E8%92%82%E6%96%AF%E5%A1%94%C2%B7%E8%B4%9D%E6%8B%89%E7%B4%A2" rel="nofollow">吉奥万·巴蒂斯塔·贝拉索</a>（ Giovan Battista Bellaso）于1553年所著的书《吉奥万·巴蒂斯塔·贝拉索先生的密码》（意大利语：La cifra del. Sig. Giovan Battista Bellaso）中。 
 </div> 
</div> 
<p></p> 
<div class="para">
  维吉尼亚密码引入了“ 
 <a href="https://baike.baidu.com/item/%E5%AF%86%E9%92%A5" rel="nofollow">密钥</a>”的概念，即根据密钥来决定用哪一行的密表来进行替换，以此来对抗字频统计。假如以上面第一行代表明文字母，左面第一列代表密钥字母，对如下明文加密： 
</div> 
<div class="para">
  TO BE OR NOT TO BE THAT IS THE QUESTION 
</div> 
<div class="para">
  当选定RELATIONS作为密钥时，加密过程是：明文一个字母为T，第一个密钥字母为R，因此可以找到在R行中代替T的为K，依此类推，得出对应关系如下： 
</div> 
<div class="para">
  密钥:RELAT IONSR ELATI ONSRE LATIO NSREL 
</div> 
<div class="para">
  明文:TOBEO RNOTT OBETH ATIST HEQUE STION 
</div> 
<div class="para">
  密文:KSMEH ZBBLK SMEMP OGAJX SEJCS FLZSY 
</div> 
<div class="para">
  历史上以维吉尼亚密表为基础又演变出很多种加密方法，其基本元素无非是密表与密钥，并一直沿用到二战以后的初级电子密码机上。 
</div> 
<div class="para">
  公元16世纪晚期，想要获得更高的保密度的人获得了一种设计更加精细的密码表。 
</div> 
<br> 
<p>实现图片：</p> 
<p><img src="https://images2.imgbox.com/49/e2/r43G1TtD_o.png" alt=""></p> 
<p><br></p> 
<p>实现代码：</p> 
<p></p> 
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'DejaVu Sans Mono';font-size:11.3pt;"><span style="color:#bbb529;">#include </span><span style="color:#6a8759;">&lt;stdio.h&gt;
</span><span style="color:#bbb529;">#include </span><span style="color:#6a8759;">&lt;malloc.h&gt;
</span><span style="color:#bbb529;">#include </span><span style="color:#6a8759;">&lt;stdlib.h&gt;
</span><span style="color:#bbb529;">#include </span><span style="color:#6a8759;">&lt;memory.h&gt;
</span><span style="color:#6a8759;">
</span><span style="color:#bbb529;">#define </span><span style="color:#908b25;">MAXSIZE </span><span style="color:#6897bb;">1000
</span><span style="color:#6897bb;">
</span><span style="color:#cc7832;font-weight:bold;">typedef struct </span><span style="color:#b5b6e3;">duplexNode</span>{
    <span style="color:#cc7832;font-weight:bold;">char </span><span style="color:#9373a5;">alphabet</span><span style="color:#cc7832;">;
</span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">struct </span><span style="color:#b5b6e3;">duplexNode </span>* <span style="color:#9373a5;">previous</span><span style="color:#cc7832;">;
</span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">struct </span><span style="color:#b5b6e3;">duplexNode </span>* <span style="color:#9373a5;">next</span><span style="color:#cc7832;">;
</span>}<span style="color:#b9bcd1;">DuplexNode</span><span style="color:#cc7832;">,</span>*<span style="color:#b9bcd1;">DuplexLinkList</span><span style="color:#cc7832;">;
</span><span style="color:#cc7832;">
</span><span style="color:#cc7832;font-weight:bold;">typedef enum</span>{
    <span style="color:#9876aa;font-style:italic;">FAILED</span><span style="color:#cc7832;">,</span><span style="color:#9876aa;font-style:italic;">SUCCESS
</span>}<span style="color:#b9bcd1;">Status</span><span style="color:#cc7832;">;
</span><span style="color:#cc7832;">
</span><span style="color:#b9bcd1;">Status </span><span style="color:#ffc66d;">initDuplexLinkList</span>(<span style="color:#b9bcd1;">DuplexLinkList </span>* duplexLinkList)<span style="color:#cc7832;">;
</span><span style="color:#cc7832;font-weight:bold;">void </span><span style="color:#ffc66d;">vigenere</span>(<span style="color:#b9bcd1;">DuplexLinkList </span>*duplexLinkList<span style="color:#cc7832;">,</span><span style="color:#cc7832;font-weight:bold;">char </span>al<span style="color:#cc7832;">,</span><span style="color:#cc7832;font-weight:bold;">int </span>n)<span style="color:#cc7832;">;
</span><span style="color:#cc7832;font-weight:bold;">char </span>* <span style="color:#ffc66d;">s_gets</span>(<span style="color:#cc7832;font-weight:bold;">char </span>* s<span style="color:#cc7832;">,</span><span style="color:#cc7832;font-weight:bold;">int </span>n)<span style="color:#cc7832;">;
</span><span style="color:#cc7832;">
</span><span style="color:#cc7832;font-weight:bold;">int </span><span style="color:#ffc66d;">main</span>(<span style="color:#cc7832;font-weight:bold;">void</span>)
{

    <span style="color:#cc7832;font-weight:bold;">char </span>str_temp[<span style="color:#908b25;">MAXSIZE</span>] = {<!-- --><span style="color:#6a8759;">'</span><span style="color:#cc7832;">\0</span><span style="color:#6a8759;">'</span>}<span style="color:#cc7832;">;
</span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">int </span>rand_temp[<span style="color:#908b25;">MAXSIZE</span>] = {<!-- --><span style="color:#6897bb;">0</span>}<span style="color:#cc7832;">;
</span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">int </span>j = <span style="color:#6897bb;">0</span><span style="color:#cc7832;">;
</span><span style="color:#cc7832;">    </span><span style="color:#b9bcd1;">DuplexLinkList </span>duplexLinkList = <span style="color:#908b25;">NULL</span><span style="color:#cc7832;">;
</span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">if</span>(initDuplexLinkList(&amp;duplexLinkList) == <span style="color:#9876aa;font-style:italic;">FAILED</span>)
    {
        fprintf(<span style="color:#908b25;">stderr</span><span style="color:#cc7832;">,</span><span style="color:#6a8759;">"failed of init!"</span>)<span style="color:#cc7832;">;
</span><span style="color:#cc7832;">        </span>exit(<span style="color:#6897bb;">1</span>)<span style="color:#cc7832;">;
</span><span style="color:#cc7832;">    </span>}
    printf(<span style="color:#6a8759;">"</span><span style="font-family:'DejaVu Sans';color:#6a8759;">请输入明文：</span><span style="color:#6a8759;">"</span>)<span style="color:#cc7832;">;
</span><span style="color:#cc7832;">    </span>s_gets(str_temp<span style="color:#cc7832;">,</span><span style="color:#908b25;">MAXSIZE</span>)<span style="color:#cc7832;">;
</span><span style="color:#cc7832;">
</span><span style="color:#cc7832;">    </span>printf(<span style="color:#6a8759;">"</span><span style="font-family:'DejaVu Sans';color:#6a8759;">随机密匙</span><span style="color:#6a8759;">:"</span>)<span style="color:#cc7832;">;
</span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">while</span>(str_temp[j] != <span style="color:#6a8759;">'</span><span style="color:#cc7832;">\0</span><span style="color:#6a8759;">'</span>)
    {
        rand_temp[j] = rand()%<span style="color:#6897bb;">100</span>+<span style="color:#6897bb;">1</span><span style="color:#cc7832;">;
</span><span style="color:#cc7832;">        </span>printf(<span style="color:#6a8759;">"</span><span style="color:#cc7832;">%d</span><span style="color:#6a8759;"> "</span><span style="color:#cc7832;">,</span>rand_temp[j])<span style="color:#cc7832;">;
</span><span style="color:#cc7832;">        </span>j++<span style="color:#cc7832;">;
</span><span style="color:#cc7832;">    </span>}

    printf(<span style="color:#6a8759;">"</span><span style="color:#cc7832;">\n</span><span style="color:#6a8759;">"</span>)<span style="color:#cc7832;">;
</span><span style="color:#cc7832;">
</span><span style="color:#cc7832;">    </span>printf(<span style="color:#6a8759;">"</span><span style="font-family:'DejaVu Sans';color:#6a8759;">密文</span><span style="color:#6a8759;">:"</span>)<span style="color:#cc7832;">;
</span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">for</span>(<span style="color:#cc7832;font-weight:bold;">int </span>m=<span style="color:#6897bb;">0</span><span style="color:#cc7832;">;</span>m&lt;j<span style="color:#cc7832;">;</span>m++)
        vigenere(&amp;duplexLinkList<span style="color:#cc7832;">,</span>str_temp[m]<span style="color:#cc7832;">,</span>rand_temp[m])<span style="color:#cc7832;">;
</span><span style="color:#cc7832;">
</span><span style="color:#cc7832;">    </span>printf(<span style="color:#6a8759;">"</span><span style="color:#cc7832;">\n</span><span style="color:#6a8759;">"</span>)<span style="color:#cc7832;">;
</span><span style="color:#cc7832;">
</span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">return </span><span style="color:#6897bb;">0</span><span style="color:#cc7832;">;
</span>}


<span style="color:#b9bcd1;">Status </span><span style="color:#ffc66d;">initDuplexLinkList</span>(<span style="color:#b9bcd1;">DuplexLinkList </span>* duplexLinkList)
{
    (*duplexLinkList) = (<span style="color:#b9bcd1;">DuplexNode </span>*)malloc(<span style="color:#cc7832;font-weight:bold;">sizeof</span>(<span style="color:#b9bcd1;">DuplexNode</span>))<span style="color:#cc7832;">;
</span><span style="color:#cc7832;">    </span>(*duplexLinkList)-&gt;<span style="color:#9373a5;">alphabet </span>= <span style="color:#908b25;">NULL</span><span style="color:#cc7832;">;
</span><span style="color:#cc7832;">    </span><span style="color:#b9bcd1;">DuplexNode </span>*p<span style="color:#cc7832;">, </span>*q = <span style="color:#908b25;">NULL</span><span style="color:#cc7832;">;
</span><span style="color:#cc7832;">    </span>p = (*duplexLinkList)<span style="color:#cc7832;">;
</span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">int </span>k<span style="color:#cc7832;">;
</span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">for</span>(k=<span style="color:#6897bb;">0</span><span style="color:#cc7832;">;</span>k&lt;<span style="color:#6897bb;">26</span><span style="color:#cc7832;">;</span>k++)
    {
        q = (<span style="color:#b9bcd1;">DuplexNode </span>*)malloc(<span style="color:#cc7832;font-weight:bold;">sizeof</span>(<span style="color:#b9bcd1;">DuplexNode</span>))<span style="color:#cc7832;">;
</span><span style="color:#cc7832;">
</span><span style="color:#cc7832;">        </span><span style="color:#cc7832;font-weight:bold;">if</span>(!q)
        {
            fprintf(<span style="color:#908b25;">stderr</span><span style="color:#cc7832;">,</span><span style="color:#6a8759;">"error due to malloc!</span><span style="color:#cc7832;">\n</span><span style="color:#6a8759;">"</span>)<span style="color:#cc7832;">;
</span><span style="color:#cc7832;">            </span><span style="color:#cc7832;font-weight:bold;">return </span><span style="color:#9876aa;font-style:italic;">FAILED</span><span style="color:#cc7832;">;
</span><span style="color:#cc7832;">        </span>}
        q-&gt;<span style="color:#9373a5;">alphabet </span>= (<span style="color:#cc7832;font-weight:bold;">char</span>) (<span style="color:#6a8759;">'A' </span>+ k)<span style="color:#cc7832;">;
</span><span style="color:#cc7832;">
</span><span style="color:#cc7832;">        </span>q-&gt;<span style="color:#9373a5;">previous </span>= p<span style="color:#cc7832;">;
</span><span style="color:#cc7832;">        </span>q-&gt;<span style="color:#9373a5;">next </span>= <span style="color:#908b25;">NULL</span><span style="color:#cc7832;">;
</span><span style="color:#cc7832;">        </span>p-&gt;<span style="color:#9373a5;">next </span>= q<span style="color:#cc7832;">;
</span><span style="color:#cc7832;">
</span><span style="color:#cc7832;">        </span>p = q<span style="color:#cc7832;">;
</span><span style="color:#cc7832;">    </span>}

    q-&gt;<span style="color:#9373a5;">next </span>= (*duplexLinkList)-&gt;<span style="color:#9373a5;">next</span><span style="color:#cc7832;">;
</span><span style="color:#cc7832;">    </span>(*duplexLinkList)-&gt;<span style="color:#9373a5;">next</span>-&gt;<span style="color:#9373a5;">previous </span>= q<span style="color:#cc7832;">;
</span><span style="color:#cc7832;">
</span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">return </span><span style="color:#9876aa;font-style:italic;">SUCCESS</span><span style="color:#cc7832;">;
</span>}

<span style="color:#cc7832;font-weight:bold;">void </span><span style="color:#ffc66d;">vigenere</span>(<span style="color:#b9bcd1;">DuplexLinkList </span>*duplexLinkList<span style="color:#cc7832;">,</span><span style="color:#cc7832;font-weight:bold;">char </span>al<span style="color:#cc7832;">,</span><span style="color:#cc7832;font-weight:bold;">int </span>n)
{
    <span style="color:#b9bcd1;">DuplexNode </span>* node = (*duplexLinkList)-&gt;<span style="color:#9373a5;">next</span><span style="color:#cc7832;">; </span><span style="color:#808080;">//</span><span style="font-family:'DejaVu Sans';color:#808080;">指向</span><span style="color:#808080;">A
</span><span style="color:#808080;">    </span><span style="color:#cc7832;font-weight:bold;">int </span>i = al - <span style="color:#6a8759;">'A'</span><span style="color:#cc7832;">;
</span><span style="color:#cc7832;">
</span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">for</span>(<span style="color:#cc7832;font-weight:bold;">int </span>k=<span style="color:#6897bb;">0</span><span style="color:#cc7832;">;</span>k&lt;i+n<span style="color:#cc7832;">;</span>k++)
        node = node-&gt;<span style="color:#9373a5;">next</span><span style="color:#cc7832;">;
</span><span style="color:#cc7832;">
</span><span style="color:#cc7832;">    </span>printf(<span style="color:#6a8759;">"</span><span style="color:#cc7832;">%c</span><span style="color:#6a8759;">"</span><span style="color:#cc7832;">,</span>node-&gt;<span style="color:#9373a5;">alphabet</span>)<span style="color:#cc7832;">;
</span>}

<span style="color:#cc7832;font-weight:bold;">char </span>* <span style="color:#ffc66d;">s_gets</span>(<span style="color:#cc7832;font-weight:bold;">char </span>* s<span style="color:#cc7832;">,</span><span style="color:#cc7832;font-weight:bold;">int </span>n)
{
    <span style="color:#cc7832;font-weight:bold;">char </span>*st=<span style="color:#908b25;">NULL</span><span style="color:#cc7832;">,</span>*find=<span style="color:#908b25;">NULL</span><span style="color:#cc7832;">;
</span><span style="color:#cc7832;">
</span><span style="color:#cc7832;">    </span>st = fgets(s<span style="color:#cc7832;">,</span>n<span style="color:#cc7832;">,</span><span style="color:#908b25;">stdin</span>)<span style="color:#cc7832;">;
</span><span style="color:#cc7832;">
</span><span style="color:#cc7832;">    </span><span style="color:#cc7832;font-weight:bold;">if</span>(st)
    {
        find = strchr(st<span style="color:#cc7832;">,</span><span style="color:#6a8759;">'</span><span style="color:#cc7832;">\n</span><span style="color:#6a8759;">'</span>)<span style="color:#cc7832;">;
</span><span style="color:#cc7832;">        </span><span style="color:#cc7832;font-weight:bold;">if</span>(find)
            *find = <span style="color:#6a8759;">'</span><span style="color:#cc7832;">\0</span><span style="color:#6a8759;">'</span><span style="color:#cc7832;">;
</span><span style="color:#cc7832;">        </span><span style="color:#cc7832;font-weight:bold;">else
</span><span style="color:#cc7832;font-weight:bold;">            while</span>(getchar() != <span style="color:#6a8759;">'</span><span style="color:#cc7832;">\n</span><span style="color:#6a8759;">'</span>)
                <span style="color:#cc7832;font-weight:bold;">continue</span><span style="color:#cc7832;">;
</span><span style="color:#cc7832;">    </span>}

    <span style="color:#cc7832;font-weight:bold;">return </span>st<span style="color:#cc7832;">;
</span><span style="color:#cc7832;">
</span>}</pre> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d534b60c4601c31d657d066d6299b6a6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言数据结构之如何快速查找链表的中间节点</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5f5ba8b70ffead91ef52e146bf2f3998/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言数据结构之逆波兰表达式求值</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>