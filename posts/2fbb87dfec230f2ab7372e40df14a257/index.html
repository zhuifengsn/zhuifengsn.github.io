<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>高级Bash脚本编程指南(2)：Shell特殊字符 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="高级Bash脚本编程指南(2)：Shell特殊字符" />
<meta property="og:description" content="高级Bash脚本编程指南(2)：Shell特殊字符
成于坚持，败于止步
注释 表示注释
在引号中间和#等表示#本身
3.echo ${PATH#*:} # 参数替换,不是一个注释
4.echo $(( 2#101011 )) # 数制转换,不是一个注释
; 分隔
1.命令分隔，在一行中写多个命令 echo “aa” ; echo “bb”
2.在条件中的if和then如果放在同一行，也用;分隔
;; case条件的结束
1.命令分隔，在一行中写多个命令 echo “aa” ; echo “bb”
2.在条件中的if和then如果放在同一行，也用;分隔
echo hello; echo there
if [ -x “$filename” ]; then # 注意: &#34;if&#34;和&#34;then&#34;需要分隔.
echo “File $filename exists.”; cp $filename $filename.bak
else
echo “File $filename not found.”; touch $filename
fi; echo “File test complete.”
. 命令相当于
1.命令：source" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/2fbb87dfec230f2ab7372e40df14a257/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-04-30T14:03:39+08:00" />
<meta property="article:modified_time" content="2019-04-30T14:03:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">高级Bash脚本编程指南(2)：Shell特殊字符</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>高级Bash脚本编程指南(2)：Shell特殊字符</p> 
<p>成于坚持，败于止步</p> 
<h2><a id="_4"></a>注释</h2> 
<ol><li> <p>表示注释</p> </li><li> <p>在引号中间和#等表示#本身</p> </li></ol> 
<p>3.echo ${PATH#*:} # 参数替换,不是一个注释</p> 
<p>4.echo $(( 2#101011 )) # 数制转换,不是一个注释</p> 
<p>; 分隔</p> 
<p>1.命令分隔，在一行中写多个命令 echo “aa” ; echo “bb”</p> 
<p>2.在条件中的if和then如果放在同一行，也用;分隔</p> 
<p>;; case条件的结束</p> 
<p>1.命令分隔，在一行中写多个命令 echo “aa” ; echo “bb”</p> 
<p>2.在条件中的if和then如果放在同一行，也用;分隔</p> 
<p>echo hello; echo there<br> if [ -x “$filename” ]; then # 注意: "if"和"then"需要分隔.<br> echo “File $filename exists.”; cp $filename $filename.bak<br> else<br> echo “File $filename not found.”; touch $filename<br> fi; echo “File test complete.”<br> . 命令相当于<br> 1.命令：source</p> 
<p>2.文件名的前缀，隐藏文件</p> 
<p>3.目录：.当前目录，…父目录</p> 
<p>4.正则表达式：匹配任意单个字符</p> 
<p>首先，先举例说明一下"."作为source使用的实例</p> 
<p>#!/bin/bash<br> . data-file # 加载一个数据文件.</p> 
<h2><a id="source_datafile__45"></a>与"source data-file"效果相同, 但是更具可移植性.</h2> 
<h2><a id="datafile_basename_46"></a>文件"data-file"必须存在于当前工作目录, 因为这个文件是使用’basename’来引用的.</h2> 
<p>echo “variable1 = $variable1”<br> echo “variable3 = $variable3”<br> let “sum = $variable2 + $variable4”<br> echo “sum = $sum”<br> exit 0<br> 上面是编写的data_file脚本，通过 . data-file引入，相当于c语言中的include data-file，我们看看data-file的内容</p> 
<h2><a id="_53"></a>这是需要被脚本加载的数据文件.</h2> 
<h2><a id="___54"></a>这种文件可以包含变量, 函数, 等等.</h2> 
<h2><a id="source_55"></a>在脚本中可以通过’source’或者’.'命令来加载.</h2> 
<h2><a id="_56"></a>让我们初始化一些变量.</h2> 
<p>variable1=22<br> variable2=474<br> variable3=5<br> variable4=97<br> message1=“Hello, how are you?”<br> message2=“Enough for now. Goodbye.”<br> 接下来我们看看脚本的执行结果：<br> root@ubuntu:~/resource/study/shell_study# chmod 777 include_file<br> root@ubuntu:~/resource/study/shell_study# ls<br> clear_log data-file include_file show_self<br> root@ubuntu:~/resource/study/shell_study# ./include_file<br> variable1 = 22<br> variable3 = 5<br> sum = 571<br> 上面的结果已经很有力的说明了我们想要的结论</p> 
<p>.作为隐藏文件时，建立隐藏文件的方法：touch .data-file</p> 
<p>.作为匹配字符说明如下：ab. 可以表示ab+任意字符，处理换行，并且必须是一个字符ab.不能表示ab</p> 
<p>“” 部分引用 支持通配符扩展</p> 
<p>"STRING"将会阻止(解释)STRING中大部分特殊的字符</p> 
<p>’ ‘ 全引用，不进行通配符扩展</p> 
<p>'STRING’将会阻止STRING中所有特殊字符的解释. 这是一种比使用"更强烈的形式</p> 
<p>\ 转义</p> 
<p>\X将会"转义"字符X. 这等价于"X", 也等价于’X’. \通常用来转义"和’, 这样双引号和单引号就不会被解释成特殊含义了.</p> 
<p>/ 目录分隔符</p> 
<p>分隔文件名不同的部分(比如 /home/bozo/projects/Makefile).也可以用来作为除法算术操作符.</p> 
<p>, 多个命令都被执行，但返回最后一个</p> 
<p>逗号操作符链接了一系列的算术操作. 虽然里边所有的内容都被运行了,但只有最后一项被返回.</p> 
<p>let “t2 = ((a = 9, 15 / 3))” # Set “a = 9” and “t2 = 15 / 3”<br> 逗号之前会运算，但是只有最后一项被返回</p> 
<p>` 后置引用</p> 
<p><code>command</code>结构可以将命令的输出赋值到一个变量中去.<br> cd <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         L 
        
       
         O 
        
        
        
          G 
         
        
          D 
         
        
       
         I 
        
       
         R 
        
       
         i 
        
       
         f 
        
       
         [ 
        
       
         ‘ 
        
       
         p 
        
       
         w 
        
       
         d 
        
       
         ‘ 
        
       
         ! 
        
       
         = 
        
       
         &amp;quot; 
        
       
      
        LOG_DIR if [ `pwd` != &amp;quot; 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathit">L</span><span class="mord mathit" style="margin-right: 0.02778em;">O</span><span class="mord"><span class="mord mathit">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathit" style="margin-right: 0.07847em;">I</span><span class="mord mathit" style="margin-right: 0.00773em;">R</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mopen">[</span><span class="mord">‘</span><span class="mord mathit">p</span><span class="mord mathit" style="margin-right: 0.02691em;">w</span><span class="mord mathit">d</span><span class="mord">‘</span><span class="mclose">!</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord">"</span></span></span></span></span>LOG_DIR" ]<br> then<br> echo “Can’t change to $LOG_DIR”<br> exit $E_XCD<br> fi<br> 这里例子是最有力的的说明，在上一章中只不过没有到这个方法，这里pwd命令会返回当前路径，然后与LOG_DIR进行比较，同样你可以定义一个变量保存pwd返回的内容，比如：<br> path=<code>pwd</code></p> 
<p>: 操作符</p> 
<p>1.空操作，等价于"NOP" (no op, 一个什么也不干的命令).</p> 
<p>2.死循环： while :，可以被认为与shell的内建命令，与true作用相同.</p> 
<p>while :<br> do<br> operation-1<br> operation-2<br> …<br> operation-n<br> done</p> 
<h2><a id="_125"></a>与下边相同:</h2> 
<h2><a id="while_true_126"></a>while true</h2> 
<h2><a id="do_127"></a>do</h2> 
<h2><a id="_128"></a>…</h2> 
<h2><a id="done_129"></a>done</h2> 
<p>3.在if/then中表示什么都不做，引出分支</p> 
<p>if condition<br> then : # 什么都不做,引出分支.<br> else<br> take-some-action<br> fi<br> 4.设置默认参数 : ${username=<code>whoami</code>}<br> : ${username=<code>whoami</code>}</p> 
<h2><a id="usernamewhoami___username_139"></a>${username=<code>whoami</code>} 如果没有开头的":"的话, 将会给出一个错误, 除非"username"是一个命令或者内建命令</h2> 
<dl> 
 
   5.变量替换 : ${HOSTNAME?} ${USER?} ${MAIL?} 
  
 <dd>
   ${HOSTNAME?} ${USER?} ${MAIL?} 
 </dd> 
</dl> 
<h2><a id="__142"></a>如果一个或多个必要的环境变量没被设置的话, 就打印错误信息.</h2> 
<dl> 
 
   6.在和 &gt; (重定向操作符)结合使用时,把一个文件截断到0 长度,没有修改它的权限；如果文件在之前并不存在,那么就创建它.如: 
  
 <dd> 
  <blockquote> 
   <p><a href="http://data.xxx" rel="nofollow">data.xxx</a> #文件"<a href="http://data.xxx" rel="nofollow">data.xxx</a>"现在被清空了. 与 cat /dev/null &gt;<a href="http://data.xxx" rel="nofollow">data.xxx</a> 的作用相同 然而,这不会产生一个新的进程,因为":"是一个内建命令.</p> 
  </blockquote> 
 </dd> 
 
   7.可能用来作为注释行, 虽然我们不推荐这么做. 使用#来注释的话, 将关闭剩余行的错误检查, 所以可以在注释行中写任何东西. 然而, 使用:的话将不会这样. 
  
 <dd>
   This is a comment that generates an error, ( if [ $x -eq 3] ). 
 </dd> 
</dl> 
<p>8.":"还用来在/etc/passwd和<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         P 
        
       
         A 
        
       
         T 
        
       
         H 
        
       
         变 
        
       
         量 
        
       
         中 
        
       
         做 
        
       
         分 
        
       
         隔 
        
       
         符 
        
       
         . 
        
       
         b 
        
       
         a 
        
       
         s 
        
       
         h 
        
       
      
        PATH变量中做分隔符. bash 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathit" style="margin-right: 0.13889em;">P</span><span class="mord mathit">A</span><span class="mord mathit" style="margin-right: 0.13889em;">T</span><span class="mord mathit" style="margin-right: 0.08125em;">H</span><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">做</span><span class="mord cjk_fallback">分</span><span class="mord cjk_fallback">隔</span><span class="mord cjk_fallback">符</span><span class="mord">.</span><span class="mord mathit">b</span><span class="mord mathit">a</span><span class="mord mathit">s</span><span class="mord mathit">h</span></span></span></span></span> echo $PATH<br> /usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin:/sbin:/usr/sbin:/usr/games</p> 
<ul><li>匹配0个或多个字符；数学乘法；**幂运算<br> root@ubuntu:~/resource/study/shell_study# ls<br> clear_log data-file include_file show_self<br> root@ubuntu:~/resource/study/shell_study# echo *<br> clear_log data-file include_file show_self<br> ? 匹配任意一个字符；但在((a&gt;b?a:b))表示c语言中的三目运算</li></ul> 
<p>(( t = a&lt;45?7:11 )) # C语言风格的三元操作.</p> 
<p>$ 字符</p> 
<p>1.取变量的值 echo $PATH</p> 
<p>var1=5<br> var2=23skidoo<br> echo $var1 # 5<br> echo $var2 # 23skidoo<br> 2.正则表达式中表示行的结尾</p> 
<p>在正则表达式中, "$"表示行结束符，先分析一下下面的例子吧</p> 
<p>root@ubuntu:~/resource/study/shell_study# echo slfjalj<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         f 
        
       
         d 
        
       
         j 
        
       
         g 
        
       
         l 
        
       
         s 
        
       
         l 
        
       
         f 
        
       
         j 
        
       
         a 
        
       
         l 
        
       
         j 
        
       
         3. 
        
       
      
        fdjgl slfjalj 3. 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit">d</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">s</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit" style="margin-right: 0.10764em;">f</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit" style="margin-right: 0.05724em;">j</span><span class="mord">3</span><span class="mord">.</span></span></span></span></span>{} 参数替换 ${PAHT}</p> 
<p>#!/bin/bash</p> 
<h2><a id="paramsubsh_180"></a><a href="http://param-sub.sh" rel="nofollow">param-sub.sh</a></h2> 
<h2><a id="_181"></a>一个变量是否被声明或设置,</h2> 
<p>#+ 将会影响这个变量是否使用默认值,<br> #+ 即使这个变量值为空(null).</p> 
<p>username0=<br> echo “username0 has been declared, but is set to null.”<br> echo "username0 = ${username0-<code>whoami</code>}"这里定义了username0且初始化是null，所以这里不会有输出，这里的“-”相当于“=”</p> 
<h2><a id="_188"></a>不会有输出.</h2> 
<p>echo</p> 
<p>echo username1 has not been declared.<br> echo "username1 = ${username1-<code>whoami</code>}"这里username1在上面没有定义并初始化为null，所以会显示</p> 
<h2><a id="_194"></a>将会输出默认值.</h2> 
<p>username2=<br> echo “username2 has been declared, but is set to null.”<br> echo "username2 = ${username2:-<code>whoami</code>}"这里上面初始化了username2并初始化为null，但是这里有个“：”</p> 
<h2><a id="_199"></a>^</h2> 
<h2><a id="__200"></a>会输出, 因为:-会比-多一个条件测试.</h2> 
<h2><a id="_201"></a>可以与上边的例子比较一下.</h2> 
<h2><a id="_203"></a>再来一个:</h2> 
<p>variable=</p> 
<h2><a id="__206"></a>变量已经被声明, 但是设为空值.</h2> 
<p>echo “<span class="katex--inline">KaTeX parse error: Expected 'EOF', got '#' at position 15: {variable-0}" #̲ (没有输出) echo "</span>{variable:-1}” # 1</p> 
<h2><a id="_210"></a>^</h2> 
<p>unset variable</p> 
<p>echo “<span class="katex--inline">KaTeX parse error: Expected 'EOF', got '#' at position 15: {variable-2}" #̲ 2 echo "</span>{variable:-3}” # 3</p> 
<p>exit 0<br> 我们也看看他的执行结果：<br> root@ubuntu:~/resource/study/shell_study# chmod 777 para_sub<br> root@ubuntu:~/resource/study/shell_study# ls<br> clear_log data-file include_file para_sub show_self<br> root@ubuntu:~/resource/study/shell_study# ./para_sub<br> username0 has been declared, but is set to null.<br> username0 =</p> 
<p>username1 has not been declared.<br> username1 = root<br> username2 has been declared, but is set to null.<br> username2 = root ^</p> 
<p>1<br> 2<br> 3<br> 4.$* 所有参数</p> 
<p>5.$# 参数个数</p> 
<p>6.$$ 进程的ID</p> 
<p>7.$? 进程的返回状态</p> 
<p>( )字符</p> 
<p>1.命令组，在一个子Shell中运行 (a=3;echo $a) 其中定义的变量在后面不可用</p> 
<p>在括号中的变量,由于是在子shell中,所以对于脚本剩下的部分是不可用的. 父进程, 也就是脚本本身, 将不能够读取在子进程中创建的变量, 也就是在子shell中创建的变量.<br> a=123<br> ( a=321; )</p> 
<p>echo “a = $a” # a = 123</p> 
<h2><a id="a__251"></a>在圆括号中a变量, 更像是一个局部变量.</h2> 
<p>2.数组初始化： array=(a,b,c)</p> 
<p>{}大括号扩展</p> 
<p>cat {file1,file2,file3} &gt; combined_file</p> 
<h2><a id="file1_file2_file3_combined_file_257"></a>把file1, file2, file3连接在一起, 并且重定向到combined_file中.</h2> 
<p>cp file22.{txt,backup}</p> 
<h2><a id="file22txtfile22b_261"></a>拷贝"file22.txt"到"file22.b</h2> 
<p>{ } 代码块，即一个匿名函数，但其中定义的变量在后面依然可用<br> #!/bin/bash</p> 
<h2><a id="etcfstab_264"></a>从/etc/fstab中读行.</h2> 
<p>File=/etc/fstab<br> {<!-- --><br> read line1<br> read line2<br> read line3<br> } &lt; $File</p> 
<p>echo “First line in <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         F 
        
       
         i 
        
       
         l 
        
       
         e 
        
       
         i 
        
       
         s 
        
       
         : 
        
       
         &amp;quot; 
        
       
         e 
        
       
         c 
        
       
         h 
        
       
         o 
        
       
         &amp;quot; 
        
       
      
        File is:&amp;quot; echo &amp;quot; 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathit" style="margin-right: 0.13889em;">F</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">i</span><span class="mord mathit">s</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord">"</span><span class="mord mathit">e</span><span class="mord mathit">c</span><span class="mord mathit">h</span><span class="mord mathit">o</span><span class="mord">"</span></span></span></span></span>line1”<br> echo<br> echo “Second line in <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         F 
        
       
         i 
        
       
         l 
        
       
         e 
        
       
         i 
        
       
         s 
        
       
         : 
        
       
         &amp;quot; 
        
       
         e 
        
       
         c 
        
       
         h 
        
       
         o 
        
       
         &amp;quot; 
        
       
      
        File is:&amp;quot; echo &amp;quot; 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathit" style="margin-right: 0.13889em;">F</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">i</span><span class="mord mathit">s</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord">"</span><span class="mord mathit">e</span><span class="mord mathit">c</span><span class="mord mathit">h</span><span class="mord mathit">o</span><span class="mord">"</span></span></span></span></span>line2”<br> echo<br> echo “third line in <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         F 
        
       
         i 
        
       
         l 
        
       
         e 
        
       
         i 
        
       
         s 
        
       
         : 
        
       
         &amp;quot; 
        
       
         e 
        
       
         c 
        
       
         h 
        
       
         o 
        
       
         &amp;quot; 
        
       
      
        File is:&amp;quot; echo &amp;quot; 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathit" style="margin-right: 0.13889em;">F</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right: 0.01968em;">l</span><span class="mord mathit">e</span><span class="mord mathit">i</span><span class="mord mathit">s</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord">"</span><span class="mord mathit">e</span><span class="mord mathit">c</span><span class="mord mathit">h</span><span class="mord mathit">o</span><span class="mord">"</span></span></span></span></span>line3”<br> exit 0<br> 执行结果：<br> root@ubuntu:~/resource/study/shell_study# ./test1<br> First line in /etc/fstab is:</p> 
<h2><a id="etcfstab_static_file_system_information_284"></a>/etc/fstab: static file system information.</h2> 
<p>Second line in /etc/fstab is:</p> 
<h2><a id="_287"></a></h2> 
<p>third line in /etc/fstab is:</p> 
<h2><a id="Use_blkid_o_value_s_UUID_to_print_the_universally_unique_identifier_290"></a>Use ‘blkid -o value -s UUID’ to print the universally unique identifier</h2> 
<p>接下来看一个例子：<br> #!/bin/bash</p> 
<p>{<!-- --><br> echo “Just for a test:”<br> echo <code>pwd</code><br> echo “Test end”<br> } &gt; “test-context” # 把代码块中的所有输出都重定向到文件中.</p> 
<p>echo “Results of rpm test in test-context”<br> exit 0<br> 看看运行结果：<br> root@ubuntu:~/resource/study/shell_study# chmod 777 test2<br> root@ubuntu:~/resource/study/shell_study# ./test2<br> Results of rpm test in test-context<br> root@ubuntu:~/resource/study/shell_study# ls<br> clear_log include_file show_self test2<br> data-file para_sub test1 test-context<br> root@ubuntu:~/resource/study/shell_study# cat test-context<br> Just for a test:<br> /root/resource/study/shell_study<br> Test end<br> { } ; 用在find的-exec中 $find -name *.txt -exec cat {} ;</p> 
<p>[ ] 字符</p> 
<p>1.测试 [-z $1]</p> 
<p>2.数组元素 a[1]=‘test’<br> 3.[[]]表示测试 使用[[ … ]]条件判断结构, 而不是[ … ], 能够防止脚本中的许多逻辑错误. 比如, &amp;&amp;, ||, &lt;, 和&gt; 操作符能够正常存在于[[ ]]条件判断结构中, 但是如果出现在[ ]结构中的话, 会报错.</p> 
<p>4.(( ))数学运算</p> 
<p>5.在正则表达式中表示范围 [a-z]</p> 
<p>&lt; &lt;&lt; &gt; 重定向和进程替换 ls -al &gt; a.txt</p> 
<p>scriptname &gt;filename 重定向scriptname的输出到文件filename中. 如果filename存在的话, 那么将会被覆盖.</p> 
<p>command &amp;&gt;filename 重定向command的stdout和stderr到filename中.</p> 
<p>command &gt;&amp;2 重定向command的stdout到stderr中.</p> 
<p>scriptname &gt;&gt;filename 把scriptname的输出追加到文件filename中. 如果filename不存在的话, 将会被创建.</p> 
<p>[i]&lt;&gt;filename 打开文件filename用来读写, 并且分配文件描述符i给这个文件. 如果filename不存在, 这个文件将会被创建.</p> 
<blockquote> 
 <p>&lt; 还用在ASCII比较 if [[ “<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          v 
         
        
          e 
         
        
          g 
         
        
          1 
         
        
          &amp;quot; 
         
        
          &amp;lt; 
         
        
          &amp;quot; 
         
        
       
         veg1&amp;quot; &amp;lt; &amp;quot; 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathit" style="margin-right: 0.03588em;">v</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mord">1</span><span class="mord">"</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord">"</span></span></span></span></span>veg2” ]]</p> 
</blockquote> 
<p>&lt;,&gt; 正则表达式中的单词边界.如:bash$grep ‘&lt;the&gt;’ textfile</p> 
<p>| 管道</p> 
<p>分析前边命令的输出, 并将输出作为后边命令的输入. 这是一种产生命令链的好方法.</p> 
<p>echo ls -l | sh # 传递"echo ls -l"的输出到shell中,与一个简单的"ls -l"结果相同.</p> 
<p>cat *.lst | sort | uniq # 合并和排序所有的".lst"文件, 然后删除所有重复的行.</p> 
<p>管道是进程间通讯的一个典型办法, 将一个进程的stdout放到另一个进程的stdin中. 标准的方法是将一个一般命令的输出, 比如cat或者echo, 传递到一个 “过滤命令”(在这个过滤命令中将处理输入)中, 然后得到结果.</p> 
<p>cat $filename1 $filename2 | grep $search_word</p> 
<p>当然输出的命令也可以传递到脚本中.</p> 
<p>#!/bin/bash</p> 
<h2><a id="uppercasesh____357"></a><a href="http://uppercase.sh" rel="nofollow">uppercase.sh</a> : 修改输入, 全部转换为大写.</h2> 
<p>tr ‘a-z’ ‘A-Z’</p> 
<h2><a id="_359"></a>字符范围必须被""引用起来来阻止产生单字符的文件名.</h2> 
<p>exit 0<br> 现在让我们输送ls -l的输出到一个脚本中.<br> bash$ ls -l | ./uppercase.sh<br> -RW-RW-R-- 1 BOZO BOZO 109 APR 7 19:49 1.TXT<br> -RW-RW-R-- 1 BOZO BOZO 109 APR 14 16:48 2.TXT<br> -RW-R–R-- 1 BOZO BOZO 725 APR 20 20:56 DATA-FILE<br> 管道中的每个进程的stdout比须被下一个进程作为stdin来读入. 否则, 数据流会阻塞, 并且管道将产生一些非预期的行为.</p> 
<p>cat file1 file2 | ls -l | sort# 从"cat file1 file2"中的输出并没出现.</p> 
<p>作为子进程的运行的管道, 不能够改变脚本的变量.</p> 
<p>variable=“initial_value”</p> 
<p>echo “new_value” | read variable</p> 
<p>echo “variable = $variable” # variable = initial_value</p> 
<p>如果管道中的某个命令产生了一个异常,并中途失败,那么这个管道将过早的终止. 这种行为被叫做broken pipe, 并且这种状态下将发送一个SIGPIPE 信号.</p> 
<blockquote> 
 <p>| 强制重定向(即使设置了noclobber 选项–就是-C 选项).这将强制的覆盖一个现存文件.</p> 
</blockquote> 
<p>|| 逻辑或操作 ；用在两个命令之间的时候，表示在前一个命令结束时，若返回值为 false，继续执行下一个命令</p> 
<p>&amp;&amp; 逻辑与；用在两个命令之间的时候，表示在前一个命令结束时，若返回值为 true，继续执行下一个命令</p> 
<p>&amp; 后台运行<br> 看一个例子<br> #!/bin/bash</p> 
<h2><a id="backgroundloopsh_389"></a><a href="http://background-loop.sh" rel="nofollow">background-loop.sh</a></h2> 
<p>for i in 1 2 3 4 5 6 7 8 9 10 # 第一个循环.<br> do <br> echo<br> echo -n "$i "<br> done &amp; # 在后台运行这个循环.</p> 
<h2><a id="2__396"></a>在第2个循环之后, 将在某些时候执行.</h2> 
<p>echo # 这个’echo’某些时候将不会显示.<br> for i in 11 12 13 14 15 16 17 18 19 20 # 第二个循环.<br> do<br> echo -n "$i "<br> done<br> echo # 这个’echo’某些时候将不会显示.<br> exit 0<br> 看一下结果：<br> root@ubuntu:~/resource/study/shell_study# ./for_test</p> 
<p>11 12 13 14 15 16 17 18 19 20<br> root@ubuntu:~/resource/study/shell_study#<br> 1<br> 2<br> 3<br> 4<br> 5<br> 6<br> 7<br> 8<br> 9<br> 10</p> 
<ul><li>在所有的命令内如果想使用选项参数的话,前边都要加上"-".</li></ul> 
<p>1.参数选项</p> 
<ol start="2"><li> <p>减号</p> </li><li> <p>重定向stdin和stdout：cd /source/directory &amp;&amp; tar cf - . ) | (cd /dest/directory &amp;&amp; tar xpvf -)</p> </li></ol> 
<p>4.先前的工作目录 cd -</p> 
<p>5.注：使用-开头的文件名和变量名可能会出现一些问题</p> 
<ul><li>一个命令或者过滤器的选项标记.</li></ul> 
<p>~ home目录</p> 
<p>~+ 当前工作目录</p> 
<p>~- 先前工作目录</p> 
<p>^ 正则表达式中表示行首</p> 
<p>其中命令的很多细节并没有研究的很彻底，好多好碎，以后见到用到具体的命令再具体分析吧<br> 先到这里了，O(∩_∩)O~</p> 
<p>我的专栏地址：<a href="http://blog.csdn.net/column/details/shell-daily-study.html">http://blog.csdn.net/column/details/shell-daily-study.html</a></p> 
<h3><a id="_446"></a>待续。。。。</h3> 
<p>作者：Ela–学海无涯<br> 来源：CSDN<br> 原文：<a href="https://blog.csdn.net/xinyuwuxian/article/details/8835697">https://blog.csdn.net/xinyuwuxian/article/details/8835697</a><br> 版权声明：本文为博主原创文章，转载请附上博文链接！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ecb7f1f2376f0e4ccab9051bb74c140d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Patient Orientation</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2bdabab0e35b94e8d96c9a1a4be10e3f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android中OpenGl ES兼容性问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>