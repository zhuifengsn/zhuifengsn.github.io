<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python花式读取大文件(10g/50g/1t)遇到的性能问题（面试向） - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python花式读取大文件(10g/50g/1t)遇到的性能问题（面试向）" />
<meta property="og:description" content="最近无论是面试还是笔试，有一个高频问题始终阴魂不散，那就是给一个大文件，至少超过10g,在内存有限的情况下（低于2g），该以什么姿势读它？
所有人都知道，用python读文件有一套”标准流程“：
def retrun_count(fname): &#34;&#34;&#34;计算文件有多少行 &#34;&#34;&#34; count = 0 with open(fname) as file: for line in file: count &#43;= 1 return count 为什么这种文件读取方式会成为标准？这是因为它有两个好处：
with 上下文管理器会自动关闭打开的文件描述符
在迭代文件对象时，内容是一行一行返回的，不会占用太多内存
但这套标准做法并非没有缺点。如果被读取的文件里，根本就没有任何换行符，那么上面的第二个好处就不成立了。当代码执行到 for line in file 时，line 将会变成一个非常巨大的字符串对象，消耗掉非常可观的内存。
如果有一个 5GB 大的文件 big_file.txt，它里面装满了随机字符串。只不过它存储内容的方式稍有不同，所有的文本都被放在了同一行里
如果我们继续使用前面的 return_count 函数去统计这个大文件行数。那么在一台pc上，这个过程会足足花掉 65 秒，并在执行过程中吃掉机器 2GB 内存
为了解决这个问题，我们需要暂时把这个“标准做法”放到一边，使用更底层的 file.read() 方法。与直接循环迭代文件对象不同，每次调用 file.read(chunk_size) 会直接返回从当前位置往后读取 chunk_size 大小的文件内容，不必等待任何换行符出现。
所以，如果使用 file.read() 方法，我们的函数可以改写成这样:
def return_count_v2(fname): count = 0 block_size = 1024 * 8 with open(fname) as fp: while True: chunk = fp." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/6e96da6a76887b62563d1b9085930af8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-21T11:00:14+08:00" />
<meta property="article:modified_time" content="2023-12-21T11:00:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python花式读取大文件(10g/50g/1t)遇到的性能问题（面试向）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>最近无论是面试还是笔试，有一个高频问题始终阴魂不散，那就是给一个大文件，至少超过10g,在内存有限的情况下（低于2g），该以什么姿势读它？</p> 
<p>所有人都知道，用python读文件有一套”标准流程“：</p> 
<pre><code>def retrun_count(fname):
    """计算文件有多少行
    """
    count = 0
    with open(fname) as file:
        for line in file:
            count += 1
    return count

</code></pre> 
<p>为什么这种文件读取方式会成为标准？这是因为它有两个好处：</p> 
<p>with 上下文管理器会自动关闭打开的文件描述符<br> 在迭代文件对象时，内容是一行一行返回的，不会占用太多内存</p> 
<p>但这套标准做法并非没有缺点。如果被读取的文件里，根本就没有任何换行符，那么上面的第二个好处就不成立了。当代码执行到 for line in file 时，line 将会变成一个非常巨大的字符串对象，消耗掉非常可观的内存。</p> 
<p>如果有一个 5GB 大的文件 big_file.txt，它里面装满了随机字符串。只不过它存储内容的方式稍有不同，所有的文本都被放在了同一行里</p> 
<p>如果我们继续使用前面的 return_count 函数去统计这个大文件行数。那么在一台pc上，这个过程会足足花掉 65 秒，并在执行过程中吃掉机器 2GB 内存</p> 
<p>为了解决这个问题，我们需要暂时把这个“标准做法”放到一边，使用更底层的 file.read() 方法。与直接循环迭代文件对象不同，每次调用 file.read(chunk_size) 会直接返回从当前位置往后读取 chunk_size 大小的文件内容，不必等待任何换行符出现。</p> 
<p>所以，如果使用 file.read() 方法，我们的函数可以改写成这样:</p> 
<pre><code>def return_count_v2(fname):

    count = 0
    block_size = 1024 * 8
    with open(fname) as fp:
        while True:
            chunk = fp.read(block_size)
            # 当文件没有更多内容时，read 调用将会返回空字符串 ''
            if not chunk:
                break
            count += 1
    return count

</code></pre> 
<p>在新函数中，我们使用了一个 while 循环来读取文件内容，每次最多读取 8kb 大小，这样可以避免之前需要拼接一个巨大字符串的过程，把内存占用降低非常多。</p> 
<p>利用生成器解耦代码</p> 
<p>假如我们在讨论的不是 Python，而是其他编程语言。那么可以说上面的代码已经很好了。但是如果你认真分析一下 return_count_v2 函数，你会发现在循环体内部，存在着两个独立的逻辑：数据生成（read 调用与 chunk 判断） 与 数据消费。而这两个独立逻辑被耦合在了一起。</p> 
<p>为了提升复用能力，我们可以定义一个新的 chunked_file_reader 生成器函数，由它来负责所有与“数据生成”相关的逻辑。这样 return_count_v3 里面的主循环就只需要负责计数即可。</p> 
<pre><code>def chunked_file_reader(fp, block_size=1024 * 8):
    """生成器函数：分块读取文件内容
    """
    while True:
        chunk = fp.read(block_size)
        # 当文件没有更多内容时，read 调用将会返回空字符串 ''
        if not chunk:
            break
        yield chunk


def return_count_v3(fname):
    count = 0
    with open(fname) as fp:
        for chunk in chunked_file_reader(fp):
            count += 1
    return count


</code></pre> 
<p>进行到这一步，代码似乎已经没有优化的空间了，但其实不然。iter(iterable) 是一个用来构造迭代器的内建函数，但它还有一个更少人知道的用法。当我们使用 iter(callable, sentinel) 的方式调用它时，会返回一个特殊的对象，迭代它将不断产生可调用对象 callable 的调用结果，直到结果为 setinel 时，迭代终止。</p> 
<pre><code>def chunked_file_reader(file, block_size=1024 * 8):
    """生成器函数：分块读取文件内容，使用 iter 函数
    """
    # 首先使用 partial(fp.read, block_size) 构造一个新的无需参数的函数
    # 循环将不断返回 fp.read(block_size) 调用结果，直到其为 '' 时终止
    for chunk in iter(partial(file.read, block_size), ''):
        yield chunk

</code></pre> 
<p>最后只需要两行代码，就构造出了一个可复用的分块读取方法，和一开始的”标准流程“按行读取 2GB 内存/耗时 65 秒 相比，使用生成器的版本只需要 7MB 内存 / 12 秒就能完成计算。效率提升了接近 4 倍，内存占用更是不到原来的 1%，简直完美。</p> 
<center> 
 <b>---------------------------END--------------------------- </b> 
</center> 
<h3><a id="_102"></a>题外话</h3> 
<p>感谢你能看到最后，给大家准备了一些福利！</p> 
<p><font face="幼圆" size="4" color="red">感兴趣的小伙伴，赠送全套Python学习资料，包含面试题、简历资料等具体看下方。<br> </font><br> <img src="https://images2.imgbox.com/91/e6/WA0vjA3N_o.gif"><br> 👉<font color="red">CSDN大礼包🎁：</font><a href="https://blog.csdn.net/weixin_68789096/article/details/132275547?spm=1001.2014.3001.5502">全网最全《Python学习资料》免费赠送🆓！</a><font color="#66cc66">（安全链接，放心点击）</font></p> 
<p><strong>一、Python所有方向的学习路线</strong></p> 
<p>Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照下面的知识点去找对应的学习资源，保证自己学得较为全面。</p> 
<p><img src="https://images2.imgbox.com/c0/8e/Q5zYIBIV_o.png" alt="img"></p> 
<p><strong>二、Python兼职渠道推荐</strong>*</p> 
<p>学的同时助你创收，每天花1-2小时兼职，轻松稿定生活费.<br> <img src="https://images2.imgbox.com/90/3f/n58Augiw_o.png" alt="在这里插入图片描述"></p> 
<p><strong>三、最新Python学习笔记</strong></p> 
<p>当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。</p> 
<p><img src="https://images2.imgbox.com/3e/c2/2dmEPdmh_o.png" alt="img"></p> 
<p><strong>四、实战案例</strong></p> 
<p>纸上得来终觉浅，要学会跟着视频一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。</p> 
<p><img src="https://images2.imgbox.com/70/9f/PjxiCB0D_o.png" alt="img"></p> 
<img src="https://images2.imgbox.com/09/10/2Z9GAUt8_o.gif"> 
<p>👉<font color="red">CSDN大礼包🎁：</font><a href="https://blog.csdn.net/weixin_68789096/article/details/132275547?spm=1001.2014.3001.5502">全网最全《Python学习资料》免费赠送🆓！</a><font color="#66cc66">（安全链接，放心点击）</font></p> 
<p>若有侵权，请联系删除</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/131dbc8ceb657fe8997b22a77e1c8cf6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">国产AI文档分析产品对比测评，司马阅领先！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2c2b8fc1b0b4886e78805316ac38c351/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">echarts 基础实现我国地图板块</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>