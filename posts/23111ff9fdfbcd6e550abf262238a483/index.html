<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>exec族函数、system函数、popen函数 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="exec族函数、system函数、popen函数" />
<meta property="og:description" content="exec族函数 1.定义 exec函数族提供了一个在进程中启动另一个程序执行的方法。它可以根据指定的文件名或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段，在执行完之后，原调用进程的内容除了进程号外，其他全部被新的进程替换了。另外，这里的可执行文件既可以是二进制文件，也可以是Linux下任何可执行的脚本文件。
2.作用 我们在用fork创建新进程后，经常会在新的进程中调用exec族函数去执行另一个程序。当进程调用exec族函数时，该进程被完全替换成新程序。因为调用exec族函数并不创建新进程，所以前后进程ID并不会改变
3.函数原型 #include &lt;unistd.h&gt; extern char **environ; int execl(const char *path, const char *arg, ...); int execlp(const char *file, const char *arg, ...); int execle(const char *path, const char *arg,..., char * const envp[]); int execv(const char *path, char *const argv[]); int execvp(const char *file, char *const argv[]); int execvpe(const char *file, char *const argv[],char *const envp[]); 4.返回值 exec函数族的函数执行成功后不会返回，调用失败时，会设置errno并返回-1，然后从原程序的调用点接着往下执行。
5.参数 path：可执行文件的路径名字
arg：可执行程序所带的参数，第一个参数为可执行文件名字，没有带路径且arg必须以NULL结束
file：如果参数file中包含/，则就将其视为路径名，否则就按 PATH环境变量，在它所指定的各目录中搜寻可执行文件。
6.exec族函数实例 （1）execl()函数 #include &lt;unistd." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/23111ff9fdfbcd6e550abf262238a483/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-29T17:35:59+08:00" />
<meta property="article:modified_time" content="2024-01-29T17:35:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">exec族函数、system函数、popen函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>exec族函数</h3> 
<h4>1.定义</h4> 
<p>exec函数族提供了一个在进程中启动另一个程序执行的方法。它可以根据指定的文件名或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段，在执行完之后，原调用进程的内容除了进程号外，其他全部被新的进程替换了。另外，这里的可执行文件既可以是二进制文件，也可以是Linux下任何可执行的脚本文件。</p> 
<h4>2.作用</h4> 
<p>我们在用fork创建新进程后，经常会在新的进程中调用exec族函数去执行另一个程序。当进程调用exec族函数时，该进程被完全替换成新程序。<span style="color:#fe2c24;"><span style="background-color:#fef2f0;">因为调用exec族函数并不创建新进程，所以前后进程ID并不会改变</span></span></p> 
<h4>3.函数原型</h4> 
<pre><code class="language-cpp">#include &lt;unistd.h&gt;
extern char **environ;

int execl(const char *path, const char *arg, ...);
int execlp(const char *file, const char *arg, ...);
int execle(const char *path, const char *arg,..., char * const envp[]);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[],char *const envp[]);

</code></pre> 
<h4> 4.返回值</h4> 
<p>exec函数族的函数执行成功后不会返回，调用失败时，会设置errno并返回-1，然后从原程序的调用点接着往下执行。</p> 
<h4>5.参数</h4> 
<p>path：可执行文件的路径名字<br> arg：可执行程序所带的参数，第一个参数为可执行文件名字，没有带路径且arg必须以NULL结束<br> file：如果参数file中包含/，则就将其视为路径名，否则就按 PATH环境变量，在它所指定的各目录中搜寻可执行文件。</p> 
<h4>6.exec族函数实例</h4> 
<h4>（1）execl()函数</h4> 
<blockquote> 
 <p>#include &lt;unistd.h&gt;</p> 
 <p>int execl(const char *path, const char *arg, ...);</p> 
</blockquote> 
<pre><code class="language-cpp">
#include &lt;stdio.h&gt;
int main(int argc,char **argv){
	int i;

	for(i = 0;i &lt; argc;i++){
		printf("argv[%d]: %s\n",i,argv[i]);
	}
	return 0;
}

//这个demo非常简单，打印我们输入的参数，我们把这个文件命名为demo1（可执行文件）

======================分割线==================================


#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
int main(int argc ,char **argv){
	
	printf("before execl!\n");	
	if(execl("./demo1","demo1","abc",NULL) == -1){
		printf("execl filed!\n");
		
		perror("because");
	}
	printf("after execl failure!\n");
	return 0;
}

</code></pre> 
<p>r如上代码所示，这个demo使用execl函数，传入path也就是demo1的路径（这里也可以写绝对路径），argv的第一个参数是我们需要的可执行文件名字，abc是第二个参数，结尾必须以NULL结尾。<span style="color:#fe2c24;"><span style="background-color:#fef2f0;">如果execl执行后返回-1，代表没有这个文件</span></span>，会执行printf(“execl filed!\n”);这句话。我们可以通过perror来打印错误信息，那么紧接着会执行printf(“after execl failure!\n”);，因为filed会原程序的调用点接着往下执行。 如果成功就直接去调用execlnewpro了。</p> 
<h4> （2）execlp()函数</h4> 
<blockquote> 
 <p>#include &lt;unistd.h&gt;</p> 
 <p>int execlp(const char *file, const char *arg, ...);</p> 
</blockquote> 
<p>那么execl函数后面加一个p是什么意思呢？<span style="color:#fe2c24;"><span style="background-color:#fef2f0;">p：使用文件名，并从PATH环境进行寻找可执行文件</span></span> ，，，带p的函数包括execlp、execvp、execvpe，如果参数file中包含/，则就将其视为路径名，否则就按 PATH环境变量，在它所指定的各目录中搜寻可执行文件。举个例子，PATH=/bin:/usr/bin</p> 
<p>接着上面的demo我们继续，比如我现在想要获取时间，需要用到date命令</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
int main(int argc ,char **argv){
	
	printf("before execlp!\n");	
	if(execlp("date","date",NULL,NULL) == -1){
		printf("execlp filed!\n");
		
		perror("because");
	}
	printf("after execlp failure!\n");
	return 0;
}
</code></pre> 
<blockquote> 
 <p>补充：</p> 
 <p>whereis 想要查看命令，作用是查看命令的绝对路径比如whereis ls，可以查看ls的绝对路径<br> echo $ PATH Linux查看当前系统环境变来量<br> export PATH=$ PATH:（pwd查看当前的路径）<br> 比如：<br> pwd（回车） /home/xxx/process<br> export PATH=$ PATH: /home/xxx/process ，这样就把当前路路径加到环境变量中了</p> 
</blockquote> 
<h4>（3）execvp()函数</h4> 
<blockquote> 
 <p>#include &lt;unistd.h&gt;</p> 
 <p>int execvp(const char *file, char *const argv[]);</p> 
</blockquote> 
<p><span style="color:#fe2c24;"><span style="background-color:#fef2f0;">v：应先构造一个指向各参数的指针数组，然后将该数组的地址作为这些函数的参数。</span></span></p> 
<pre><code class="language-cpp">
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main(void){
	
	char *argv[] = {"ls","-l",NULL};
	if(execvp("ls",argv) == -1){
		printf("execl filed!\n");
		
		perror("becasue");
	}
	printf("Execute after failure!\n");
	return 0;
}

//先指定好char *argv[] = {"ls","-l",NULL};，我们exec函数直接使用，一样的效果，目的一样，使用方法不一样
</code></pre> 
<h4> （4）总结</h4> 
<blockquote> 
 <p><strong>exec族函数参数极难记忆和分辨，函数名中的字符会给我们一些帮助：</strong></p> 
 <ul><li>l : 使用参数列表</li><li>p：使用文件名，并从PATH环境进行寻找可执行文件</li><li>v：应先构造一个指向各参数的指针数组，然后将该数组的地址作为这些函数的参数。</li><li>e：多了envp[]数组，使用新的环境变量代替调用进程的环境变量</li></ul> 
</blockquote> 
<h3> system()函数</h3> 
<pre><code class="language-cpp">#include &lt;stdlib.h&gt;
int system(const char *command);

函数说明：
system()会调用fork()产生子进程，由子进程来调用/bin/sh-c string来执行参数string字符串所代表的命令
此命令执行完后随即返回原调用的进程。在调用system()期间SIGCHLD 信号会被暂时搁置，SIGINT和SIGQUIT 信号则会被忽略。

sh -c就相当于./  就是为了执行后面的指令string

返回值：
如果fork()失败 返回-1:出现错误

如果exec()失败，表示不能执行Shell,返回值相当于Shell执行了exit(127)如果执行成功则返回子Shell的终止状态

如果system()在调用/bin/sh时失败则返回127，其他失败原因返回-1。若参数string为空指针(NULL)，则返回非零值。

如果system()调用成功则最后会返回执行shell命令后的返回值，但是此返回值也有可能为 system()调用/bin/sh失败所返回的127，因此最好能再检查errno 来确认执行成功。

system调用结束后还会返回原程序继续执行system下面的代码，而exec族函数不会。

我的理解：
在system函数调用成功时返回进程的状态值
当因shell不能执行时也就是system()在调
用/bin/sh时失败时返回127，其他失败情况
返回-1，命令string为空指针(NULL)system
函数的返回值很简单明了，只有0和1。返回1，
表明系统的命令处理程序，即/bin/sh是可用的。
相反，如果命令处理程序不可用，则返回0。 在
判断返回值时最好能再检查errno来确认执行成功

</code></pre> 
<p>从上述来看，可以写出system函数原型</p> 
<pre><code class="language-cpp">int system(const char *string)
{
    pid_t pid;
    int status;
    
    if(string==NULL){
        return(1);
    }

    if(pid=fork()&lt;0){
        status=-1;
    }

    else if(pid==0){
        execl("bin/sh", "sh", "-c", string, (char*)0);
        _exit(127);
    }

    else{
        while(waitpid(pid,&amp;status,0)&lt;0){
            if(errno != EINTER){
                status=-1;
                break;
            }
        }
    }
    
    return status;
}</code></pre> 
<h3>popen()函数</h3> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
FILE *popen(const char *command, const char *type);
int pclose(FILE *stream);
</code></pre> 
<h4>1.函数说明</h4> 
<ul><li>popen()会调用fork()产生子进程，然后从子进程中调用/bin/sh -c来执行参数command的指令。</li><li>参数type可使用“r”代表读取，“w”代表写入。依照此type值，popen()会建立管道连到子进程的标准输出设备（比如说：ps指令，可以用“”r“”根据返回的指针读取子进程的标准输出内容）或标准输入设备，然后返回一个文件指针。随后进程便可利用此文件指针来读取子进程的输出设备或是写入到子进程的标准输入设备中。</li><li>此外，所有使用文件指针(FILE*)操作的函数也都可以使用，除了fclose()以外。</li><li>如果 type 为 r，那么调用进程读进 command 的标准输出。如果 type 为 w，那么调用进程写到 command 的标准输入。</li><li>popen比sysytem的好处是可以通过管道获取运行结果</li></ul> 
<h4>2.返回值</h4> 
<p>若成功则返回文件指针，否则返回NULL，错误原因存于errno中。</p> 
<h4>3.注意</h4> 
<p>popen()会继承环境变量，通过环境变量可能会造成系统安全的问题。</p> 
<h4>4.为什么用popen</h4> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main()
{
        system("ps");
        return 0;
}

这几行代码的运行结果如下：

   PID TTY          TIME CMD
 20157 pts/3    00:00:03 bash
 24755 pts/3    00:00:00 popen
 24756 pts/3    00:00:00 sh
 24757 pts/3    00:00:00 ps

如果想要把它运行的结果放到文件或者字符串中去
就要用到popen函数将结果流入到文件中去，如下面代码：

#include&lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
int main()
{
        char* buf;
        FILE* fd;
        int n_read;
        buf=(char*)malloc(1024);
        fd=popen("ps","r");
        n_read=fread(buf,1,1024,fd);
        pclose(fd);
        printf("管道输出:%s",buf);
        return 0;
}

以下是输出结果：

管道输出:   PID TTY          TIME CMD
 20157 pts/3    00:00:03 bash
 24865 pts/3    00:00:00 popen
 24866 pts/3    00:00:00 sh
 24867 pts/3    00:00:00 ps

如果有将信息流入到内存而不打印则屏幕上面没有显示。
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3cba600106f76ebf416b2407a87cc521/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Sublime Text 3配置 Java 开发环境</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/26dfe69bbe6661c31e4f095a6e4e1542/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">TBTOOLS标记染色体上的gene</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>