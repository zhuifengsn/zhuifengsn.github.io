<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>@ComponentScan 注解 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="@ComponentScan 注解" />
<meta property="og:description" content="基本使用 @ComponentScan 注解的作用就是根据指定的扫描路径，把路径中符合扫描规则的类装配到 Spring 容器中。
加入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; 复制代码 配置启动类，使用ComponentScan扫描指定包路径 @ComponentScan(basePackages = &#34;com.cxyxj.componentscan.app&#34;) public class AppMain { public static void main(String[] args) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppMain.class); // 打印 bean 名称 String[] beanDefinitionNames = context.getBeanDefinitionNames(); for (String name : beanDefinitionNames){ System.out.println(name); } } } 复制代码 运行结果：
org.springframework.context.annotation.internalConfigurationAnnotationProcessor org.springframework.context.annotation.internalAutowiredAnnotationProcessor org.springframework.context.annotation.internalCommonAnnotationProcessor org.springframework.context.event.internalEventListenerProcessor org.springframework.context.event.internalEventListenerFactory appMain 复制代码 除了 Spring 本身注册的一些 bean 之外， AppMain这个类也注册进了容器中。
上述的使用方式，在没什么特殊的要求下，在实际工作当中完全满足项目的开发。@ComponentScan注解还有其他好用的功能，我们有必要了解并会使用。
@ComponentScan注解与XML文件中的context:component-scan标签等效。
&lt;beans&gt; &lt;context:component-scan base-package=&#34;com.cxyxj&#34;/&gt; &lt;/beans&gt; 复制代码 注解定义 @Retention(RetentionPolicy." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/27ffa5b502be0c6f29d99124c8b2542d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-29T13:44:08+08:00" />
<meta property="article:modified_time" content="2023-03-29T13:44:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">@ComponentScan 注解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>基本使用</h2> 
<p>@ComponentScan 注解的作用就是根据指定的扫描路径，把路径中符合扫描规则的类装配到 Spring 容器中。</p> 
<ul><li>加入依赖</li></ul> 
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;5.1.8.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
复制代码</code></pre> 
<ul><li>配置启动类，使用<code>ComponentScan</code>扫描指定包路径</li></ul> 
<pre><code>@ComponentScan(basePackages = "com.cxyxj.componentscan.app")
public class AppMain {

    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(AppMain.class);
        // 打印 bean 名称
        String[] beanDefinitionNames = context.getBeanDefinitionNames();
        for (String name : beanDefinitionNames){
            System.out.println(name);
        }

    }
}
复制代码</code></pre> 
<p>运行结果：</p> 
<pre><code>org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
appMain
复制代码</code></pre> 
<p>除了 Spring 本身注册的一些 bean 之外， <code>AppMain</code>这个类也注册进了容器中。</p> 
<p>上述的使用方式，在没什么特殊的要求下，在实际工作当中完全满足项目的开发。<code>@ComponentScan</code>注解还有其他好用的功能，我们有必要了解并会使用。</p> 
<p><code>@ComponentScan</code>注解与XML文件中的<code>context:component-scan</code>标签等效。</p> 
<pre><code>&lt;beans&gt;
    &lt;context:component-scan base-package="com.cxyxj"/&gt;
&lt;/beans&gt;
复制代码</code></pre> 
<h2>注解定义</h2> 
<pre><code>@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Repeatable(ComponentScans.class)
public @interface ComponentScan {

	// basePackages 的别名
    // 在没有其他属性的情况下可以如此写：@ComponentScan("com.cxyxj.componentscan")
    // 而不需要：@ComponentScan(basePackages = "com.cxyxj.componentscan")
	@AliasFor("basePackages")
	String[] value() default {};

    // 扫描带注解的包路径，默认是@Component
	@AliasFor("value")
	String[] basePackages() default {};

	// 扫描指定带注解的类，同时会扫描该类所在的包，默认是@Component
    //示例： @ComponentScan(basePackageClasses = {UserServiceImpl.class})
	Class&lt;?&gt;[] basePackageClasses() default {};

	// beanName 的生成器
	Class&lt;? extends BeanNameGenerator&gt; nameGenerator() default BeanNameGenerator.class;

	// 解析@Scope注解
	Class&lt;? extends ScopeMetadataResolver&gt; scopeResolver() default AnnotationScopeMetadataResolver.class;

	// 是否为扫描到的Bean生成代理
     /**
     * ScopedProxyMode有四个取值
     *  1.DEFAULT:默认值，默认情况下取no
     *  2.NO:不开启代理
     *  3.INTERFACES:使用jdk动态代理
     *  4.TARGET_CLASS:使用cglib代理
     *  假如有一个单例beanA，其中有一个属性B，B的Scope是session，此时，容器在启动时创建A的过程中需要注入B属性，
     *  但是B的scope是session,这种情况下是注入不了的（只有用户访问时才会创建），是会报错的
     *  但是如果将B的Scope的ProxyMode属性配置为INTERFACES或者TARGET_CLASS时，那么B就会生成一个ScopedProxyFactoryBean类型的BeanDefinitionHolder
     *  在A注入B时，就会注入一个ScopedProxyFactoryBean类型的Bean
     */
	ScopedProxyMode scopedProxy() default ScopedProxyMode.DEFAULT;

	// 控制符合组件检测条件的类文件，默认是包路径下的 **/*.class
	String resourcePattern() default ClassPathScanningCandidateComponentProvider.DEFAULT_RESOURCE_PATTERN;

	// 是否自动检测带有 @Component 注解的类，默认为 true
    // 像 @Repository、 @Controller、@Service、@Configuration 内部都包含了 @Component
	boolean useDefaultFilters() default true;

    /**
     * 如果扫描到的类符合 includeFilters 中的过滤条件
     * 这个类会被注册到容器中
     * 过滤类型与如下5种
     * 1、ANNOTATION：注解类型（默认）
     * 2、ASSIGNABLE_TYPE：指定类
     * 3、ASPECTJ：指定表达式
     * 4、REGEX：正则表达式
     * 5、CUSTOM：自定义类型
     */
	Filter[] includeFilters() default {};

	// 如果扫描到的类符合 excludeFilters 中的过滤条件
    // 这个类不会被注册
	Filter[] excludeFilters() default {};

	// 扫描到的类是否应延迟初始化，默认为 false
	boolean lazyInit() default false;

	// 声明要用作包含过滤器或排除过滤器的类型过滤器
	@Retention(RetentionPolicy.RUNTIME)
	@Target({})
	@interface Filter {

		// 要使用的过滤器类型，默认为 ANNOTATION
		FilterType type() default FilterType.ANNOTATION;

		// classes 的别名
		@AliasFor("classes")
		Class&lt;?&gt;[] value() default {};

    /**
     * 作用同上面的 value 相同
     * 过滤器的参数，参数必须为class数组
     * 只能用于 ANNOTATION 、ASSIGNABLE_TYPE 、CUSTOM 这三个类型
     * ANNOTATION：参数为注解类，比如：Controller.class
     * ASSIGNABLE_TYPE：参数为类，如 UserServiceImpl.class
     * CUSTOM：参数为实现 TypeFilter 接口的类 ，如 MyTypeFilter.class
     * 实现了TypeFilter 接口的类，还能实现 EnvironmentAware，BeanFactoryAware，		BeanClassLoaderAware，ResourceLoaderAware 这四个回调接口
     * 它们各自的方法将在 TypeFilter#match 之前被调用
     */
		@AliasFor("value")
		Class&lt;?&gt;[] classes() default {};

		//这个属性主要用于 ASPECTJ 类型和  REGEX 类型
		String[] pattern() default {};

	}

}
复制代码</code></pre> 
<p>接下来使用一下几个重要属性。</p> 
<h2>实践</h2> 
<h4>basePackageClasses</h4> 
<p>创建 <code>ProductServiceImpl</code>、<code>UserServiceImpl</code>两个类，并放在 <code>impl</code>包下。整体包结构如下：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/cc/cd/L1UsqaRR_o.png"></p> 
<p>类中内容如下：</p> 
<ul><li>ProductServiceImpl类中包含 <code>@Configuration</code>注解</li></ul> 
<pre><code>@Configuration
public class ProductServiceImpl {
}
复制代码</code></pre> 
<ul><li>UserServiceImpl则是普通类</li></ul> 
<pre><code>public class UserServiceImpl {
}
复制代码</code></pre> 
<ul><li>在<code>ComponentScan</code>注解增加 <code>basePackageClasses</code>的属性，指定 <code>UserServiceImpl</code>。上面讲过<code>basePackageClasses</code>会扫描指定带注解的类，同时会扫描该类所在的包。</li></ul> 
<pre><code>@ComponentScan(basePackages = "com.cxyxj.componentscan.app",basePackageClasses = {UserServiceImpl.class})
复制代码</code></pre> 
<ul><li>启动结果</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/99/11/nuBVm0jo_o.png"></p> 
<p>由于指定的 <code>UserServiceImpl</code>上面没有注解，所以没被加入容器中。</p> 
<h4>useDefaultFilters</h4> 
<p><code>useDefaultFilters</code> 的值默认为 true，也就是默认会往 <code>includeFilters</code>中添加一个为 <code> @Component</code>注解类型的过滤器。这时我们将 <code>useDefaultFilters</code>的值修改为 false ，这会扫描出来几个类呢？</p> 
<pre><code>@ComponentScan(basePackages = "com.cxyxj.componentscan.app",basePackageClasses = {UserServiceImpl.class},useDefaultFilters = false)
复制代码</code></pre> 
<ul><li>启动结果</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/39/6e/kFV973Ku_o.png"></p> 
<p>答案是一个都没有，请忽略 <code>AppMain</code> ，这相当于是我们手动调用 <code>context.register(AppMain.class)</code>进行注册的。</p> 
<h4>includeFilters</h4> 
<p>我们想把 <code>ProductServiceImpl</code>扫描出来，需要怎么做呢？</p> 
<p>ANNOTATION</p> 
<ul><li>修改 <code>@ComponentScan</code>的值，增加 <code>includeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION,value = {Configuration.class}</code>，指定 value 的值为 <code>@Configuration</code>。</li></ul> 
<p>这代表着只要扫描到的类中包含 <code>@Configuration</code>注解，就会被注册到容器中。一般我们<strong>自定义的注解</strong>就可以结合该方式。</p> 
<pre><code>@ComponentScan(basePackages = "com.cxyxj.componentscan.app",
        basePackageClasses = {UserServiceImpl.class},
        useDefaultFilters = false,
        includeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION,value = {Configuration.class})
)
复制代码</code></pre> 
<ul><li>启动结果</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/01/3c/0vbWiIp9_o.png"></p> 
<p>ASSIGNABLE_TYPE</p> 
<p>将 <code>UserServiceImpl</code>加入到容器中，但是它是一个普普通通的类，这时可以使用 <code>ASSIGNABLE_TYPE</code>。</p> 
<ul><li>includeFilters 值修改如下：</li></ul> 
<pre><code>includeFilters = @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE,value = {UserServiceImpl.class})
复制代码</code></pre> 
<ul><li>启动结果</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/52/bf/5TWpo2FH_o.png"></p> 
<p>ASPECTJ</p> 
<p>如果觉得一个一个的加入比较麻烦，可以使用 <code>ASPECTJ</code>表达式的方式。</p> 
<ul><li>includeFilters 值修改如下：</li></ul> 
<pre><code>includeFilters = @ComponentScan.Filter(type = FilterType.ASPECTJ,pattern = {"com.cxyxj.componentscan.impl.*"})
复制代码</code></pre> 
<ul><li>启动结果</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/4e/84/WAWeg2Gp_o.png"></p> 
<p>如果启动报错需要加入 <code>aspectj</code>的依赖。</p> 
<pre><code>&lt;!--aspectj 支持--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;
    &lt;version&gt;1.9.6&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
    &lt;version&gt;1.9.6&lt;/version&gt;
&lt;/dependency&gt;
复制代码</code></pre> 
<p>REGEX</p> 
<p>跟 <code>ASPECTJ</code>能达到效果的是 <code>REGEX</code>，使用正则表达式进行匹配。需要注意的是进行匹配的值是类的全限定名，比如：<code>com.cxyxj.componentscan.impl.UserServiceImpl</code>。</p> 
<ul><li>includeFilters 值修改如下：</li></ul> 
<pre><code>includeFilters = @ComponentScan.Filter(type = FilterType.REGEX,pattern = {"[A-Za-z.]+Impl$"})
复制代码</code></pre> 
<ul><li>启动结果</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/69/f9/ziUaClWC_o.png"></p> 
<p>CUSTOM</p> 
<p>如果觉得上述几种方式都不满足需求，我们可以进行自定义过滤规则。</p> 
<ul><li>创建 <code>CustomTypeFilter</code> 类，并实现 <code>TypeFilter</code>接口，重写其 <code>match</code>方法。</li></ul> 
<pre><code>public class CustomTypeFilter implements TypeFilter {


    /**
     *
     * @param metadataReader：可以获得当前正在扫描的类的信息
     * @param metadataReaderFactory：可以获得 MetadataReader。metadataReaderFactory.getMetadataReader(UserServiceImpl.class.getName());
     * @return match方法返回false 则表示不通过过滤规则，true 表示通过过滤规则
     * @throws IOException
     */
    @Override
    public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {
        //Class元数据
        ClassMetadata classMetadata = metadataReader.getClassMetadata();
        //全限定名称
        String className = classMetadata.getClassName();
        //如果名称包含 User 则通过过滤
        if(className.contains("User")){
            return true;
        }
        return false;
    }
}
复制代码</code></pre> 
<ul><li>includeFilters 值修改如下：</li></ul> 
<pre><code> includeFilters = @ComponentScan.Filter(type = FilterType.CUSTOM,value = {CustomTypeFilter.class})
复制代码</code></pre> 
<ul><li>启动结果</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/21/a2/cKVSPS9o_o.png"></p> 
<p>通过自定义过滤规则的扫描，只有 <code>UserServiceImpl</code>符合。</p> 
<p><code>excludeFilters</code> 的使用方式与 <code>includeFilters</code>一致。只不过 <code>excludeFilters</code>是排除而已。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0c09986d6f85c67510370790dfaabb11/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">springcloud理解及使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/edc4e6fa5493f7b288684083fdefc15e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算机视觉入门 - MacOS搭建Python的OpenCV环境并在VScode上使用的详细步骤（完整版）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>