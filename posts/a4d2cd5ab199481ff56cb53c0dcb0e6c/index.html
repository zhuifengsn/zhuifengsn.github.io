<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JVM知识梳理，想找工作的你还不看这份资料就晚了 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JVM知识梳理，想找工作的你还不看这份资料就晚了" />
<meta property="og:description" content="* 方法区中，常量引用的对象 * 本地方法栈中Native引用的对象 * java 虚拟机内部的引用…(具体详见P70）。 算法思路：以GC ROOT 的对象作为起始点，从这些节点开始向下搜索，走过的路径称为引用链（ Reference Chain ） 当一个对象到GC ROOT 时没有任何引用链就会被判”缓刑“，要想真正死亡需要经历两次标记，刚才所说的只是暂时标记了一次，第二次标记的时候系统需要判断该对象是否有必要执行一次finalize() 方法，如果对象没有覆盖，或者是已经调用了一次finalize（） 方法 那就判定为不用执行，这时候直接回收了 3. 关于引用：四种：强引用（不会被回收）、软引用（引用那些，有用但是非必须的对象。栈溢出异常之前会回收软引用中的对象）、弱引用（也是非必须的对象，但是它更加弱，当垃圾收集机制开始时，弱引用中的对象都会被回收）、虚引用 4. 回收方法区：回收的是废弃的常量和不再被引用的类型，废弃的常量很好理解，但是不再被引用的类型需要满足一下三个条件： 5. 该类的所有的实例全部都已经被回收 6. 该类的类加载器也被回收 7. java.lang.Class 对象在任何地方都没有被引入 常用的垃圾收集算法：
2. 标记清除算法（Mark-Sweep）：可以标记存活对象，也可标记死亡对象。缺点就是容易产生大量的内存碎片
3. 复制算法（Copying）：把内存区分成两部分，每次只是用其中的一部分，当这一部分用完之后，就会把还存活的对象复制到另一部分，然后把之前用的全部删了，这样就不容易产生内存碎片了，当然缺点也是显而易见，他的效率很低 4. 标记整理算法（Mark-compact）：类似Mark-Sweep ，他也会进行标记，但是标记之后他不会立马去清除可回收的对象，而是先把存活的对象都向一端进行移动，然后再清理掉边界以外的内存 5. 分代收集理论：Eden 、Young Generation （Minor GC）、Old Generation（Magor GC） 。 Eden ： from survivor ：to survivor = 8 ：1：1 大部分的对象都是在Eden区生成。回收的时候先把Eden区存活的对象复制到from survivor区，然后清空Eden。当from survivor区里面存满的时候，from survivor区和Eden区存活的对象会被复制到to区，然后清空，最后交换to survivor和from survivor，保持 to survivor是空的。to survivor要是也满了的话，会把to survivor中的对象存到老年区，老年代也满了的话就触发 FULL GC ——新生代、老年代都回收 GC什么时候被触发：一般来说，当新对象生成，向Eden区申请空间失败的时候就会触发Scavenge GC，清楚非存活对象，并把存活对象移到from survivor区，因为大部分的对象都是从eden开始的，所以垃圾回收比较频繁，所以需要效率高的回收算法 常见的垃圾收集器" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/a4d2cd5ab199481ff56cb53c0dcb0e6c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-11T18:48:24+08:00" />
<meta property="article:modified_time" content="2021-08-11T18:48:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JVM知识梳理，想找工作的你还不看这份资料就晚了</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <pre><code>*   方法区中，常量引用的对象

    

*   本地方法栈中Native引用的对象

    

    *   java 虚拟机内部的引用…(具体详见P70）。

    

    算法思路：以GC ROOT 的对象作为起始点，从这些节点开始向下搜索，走过的路径称为引用链（ Reference Chain ） 当一个对象到GC ROOT 时没有任何引用链就会被判”缓刑“，要想真正死亡需要经历两次标记，刚才所说的只是暂时标记了一次，第二次标记的时候系统需要判断该对象是否有必要执行一次finalize() 方法，如果对象没有覆盖，或者是已经调用了一次finalize（） 方法 那就判定为不用执行，这时候直接回收了

    



3.  关于引用：四种：强引用（不会被回收）、软引用（引用那些，有用但是非必须的对象。栈溢出异常之前会回收软引用中的对象）、弱引用（也是非必须的对象，但是它更加弱，当垃圾收集机制开始时，弱引用中的对象都会被回收）、虚引用

    

4.  回收方法区：回收的是废弃的常量和不再被引用的类型，废弃的常量很好理解，但是不再被引用的类型需要满足一下三个条件：

    

5.  该类的所有的实例全部都已经被回收

    

6.  该类的类加载器也被回收

    

7.  java.lang.Class 对象在任何地方都没有被引入
</code></pre> 
<ol start="3"><li> <p>常用的垃圾收集算法：</p> <p>2. 标记清除算法（Mark-Sweep）：可以标记存活对象，也可标记死亡对象。缺点就是容易产生大量的内存碎片</p> <pre><code>
3. 复制算法（Copying）：把内存区分成两部分，每次只是用其中的一部分，当这一部分用完之后，就会把还存活的对象复制到另一部分，然后把之前用的全部删了，这样就不容易产生内存碎片了，当然缺点也是显而易见，他的效率很低



4. 标记整理算法（Mark-compact）：类似Mark-Sweep ，他也会进行标记，但是标记之后他不会立马去清除可回收的对象，而是先把存活的对象都向一端进行移动，然后再清理掉边界以外的内存



5. 分代收集理论：Eden 、Young Generation （Minor GC）、Old Generation（Magor GC） 。 

   

   Eden ： from survivor ：to survivor  =   8 ：1：1

   

   大部分的对象都是在Eden区生成。回收的时候先把Eden区存活的对象复制到from survivor区，然后清空Eden。当from survivor区里面存满的时候，from survivor区和Eden区存活的对象会被复制到to区，然后清空，最后交换to survivor和from survivor，保持 to survivor是空的。to survivor要是也满了的话，会把to survivor中的对象存到老年区，老年代也满了的话就触发 FULL GC ——新生代、老年代都回收

   

GC什么时候被触发：一般来说，当新对象生成，向Eden区申请空间失败的时候就会触发Scavenge GC，清楚非存活对象，并把存活对象移到from survivor区，因为大部分的对象都是从eden开始的，所以垃圾回收比较频繁，所以需要效率高的回收算法 

</code></pre> 
  <ol start="6"><li> <p>常见的垃圾收集器</p> 
    <ol><li> <p>Serial 收集器：串行回收；他是单线程的回收器；使用复制算法，有STW机制 优势：简单而高， 是client级别默认的GC方式 新生代单线程回收器</p> </li><li> <p>Serial Old 执行老年代垃圾回收， 标记压缩算法 单线程</p> </li><li> <p>ParNew 并行回收 Serial 多线程版本 处理新生代垃圾回收 复制算法 STW 机制</p> </li><li> <p>Parallel Scavenge 回收器 ：吞吐量优先 自适应调节策略 复制算法、并行回收 SWT机制 是server级别默认采用的GC方式</p> </li><li> <p>Parallel Old 用来替换 Serial Old 标记压缩 并行回收 SWT</p> </li><li> <p>CMS （Concurrent - Mark - Sweep）：低延迟 ，并发收集器，让垃圾收集线程和用户线程同时工作 JAVA8 默认回收器 标记清除算法 STW机制 老年代收集器 在G1 出现前CMS 还是比较广泛的。JDK 9 +被标记成废弃</p> </li><li> <p>G 1 区域化分代式 ：G1 目标 在延迟可控的情况下，获得尽可能高的吞吐量</p> </li></ol> </li></ol> </li></ol> 
<p>对象的创建过程：</p> 
<p>​ java虚拟机遇到new指令的时候，他会先检查指令参数是否在常量池中定位到一个类的引用，并检查这个符号所引用代表的类是否被加载、解析、初始化，如果没有那就先执行类加载过程。———检查中…——— 》》》》检查通过之后就是分配堆内存空间（空间大小在类加载完之后就会被确定）。引出两种分配内存的方式：1. 指针碰撞（内存规整，只移动指针就行） 2. 空闲列表（内存不规整，虚拟机需要维护一个列表，记录哪些是可用的内存，并划分给对象） 内存是否规整又取决于垃圾回收器是否带有空间压缩整理 的能决定———内存分配中…————》》》分配完之后，虚拟机将分配的空间初始化零值（不包括对象头） 然后intit（）初始化方法</p> 
<h4><a id="_106"></a>最后</h4> 
<p><strong>对于很多Java工程师而言，想要提升技能，往往是自己摸索成长，不成体系的学习效果低效漫长且无助。</strong></p> 
<p><strong>整理的这些资料希望对Java开发的朋友们有所参考以及少走弯路，本文的重点是你有没有收获与成长，其余的都不重要，希望读者们能谨记这一点。</strong></p> 
<p><strong>再免费分享一波我的Java面试真题+视频学习详解+技能进阶书籍</strong></p> 
<p><strong><a href="https://gitee.com/vip204888/java-p7" rel="nofollow">点击这里即可免费获取以上我收集整理的全部学习资料</a></strong></p> 
<p>。**</p> 
<p><strong>再免费分享一波我的Java面试真题+视频学习详解+技能进阶书籍</strong></p> 
<p><strong><a href="https://gitee.com/vip204888/java-p7" rel="nofollow">点击这里即可免费获取以上我收集整理的全部学习资料</a></strong></p> 
<p><img src="https://images2.imgbox.com/fb/60/92H8Ykhp_o.png" alt="美团二面惜败，我的凉经复盘（附学习笔记+面试整理+进阶书籍）"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a576d1195c52d8c09739ced2e812ce73/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JVM知识梳理，想学IT的必看</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c6ac703bf31ed293953ccf818830c2a9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">服务器数据库系列,服务器数据库客户端和服务端</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>