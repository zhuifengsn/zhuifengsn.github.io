<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言结构体 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言结构体" />
<meta property="og:description" content="目录
1.为何需要结构体，什么是结构体 ？
结构体的概念：
2.结构体的声明
结构体变量定义和初始化
结构体成员的访问
.操作符
-&gt;操作符
结构体传参
1.为何需要结构体，什么是结构体 ？ 对于日期，分数，数字，名字这些简单的对象我们可以用整形，浮点型，字符进行描述。而对于一个人（例如：学生）这种复杂对象时，我们难以仅仅用整形，浮点型进行描述，往往我们需要多个数据类型整合起来描述。
例如：学生，我们用姓名，年龄，性别，成绩描述
姓名——&gt;字符数组
年龄——&gt;整形
性别——&gt;字符数组
成绩——&gt;浮点数
这时候，我们就要引出
结构体的概念： 结构是一些值的集合，这些值成为成员变量。结构的每个成员可以是不同类型的变量。
2.结构体的声明 在main函数前面进行声明
注：变量列表里也可以不创建变量
依然以学生为例，
struct stu { char name[20];//名字 int age;//年龄 char sex[10];//性别 float score;//成绩 };//不创建变量 struct stu { char name[20];//名字 int age;//年龄 char sex[10];//性别 float score;//成绩 }s1,s2;//创建变量 注：s1,s2是通过struct stu类型创建的变量，s1,s2是全局变量
注：结尾有分号
struct stu { char name[20];//名字 int age;//年龄 char sex[10];//性别 float score;//成绩 }s1,s2; //s1,s2为全局变量 int main() { struct stu s3; //注意:struct stu是结构体类型，此处struct不能省略 struct stu s4; //此处s3,s4为局部变量 return 0; } 注：s3，s4是局部变量" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/fa4dcea5aacf06dedb76139c667483ed/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-27T10:17:42+08:00" />
<meta property="article:modified_time" content="2022-03-27T10:17:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言结构体</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%93%E6%9E%84%E4%BD%93%20%EF%BC%9F-toc" style="margin-left:0px;"><a href="#1.%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%93%E6%9E%84%E4%BD%93%20%EF%BC%9F" rel="nofollow">1.为何需要结构体，什么是结构体 ？</a></p> 
<p id="%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9A" rel="nofollow">结构体的概念：</a></p> 
<p id="2.%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%A3%B0%E6%98%8E-toc" style="margin-left:0px;"><a href="#2.%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%A3%B0%E6%98%8E" rel="nofollow">2.结构体的声明</a></p> 
<p id="%C2%A0%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:0px;"><a href="#%C2%A0%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow"> 结构体变量定义和初始化</a></p> 
<p id="%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE-toc" style="margin-left:0px;"><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE" rel="nofollow">结构体成员的访问</a></p> 
<p id=".%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:40px;"><a href="#.%E6%93%8D%E4%BD%9C%E7%AC%A6" rel="nofollow">.操作符</a></p> 
<p id="-%3E%E6%93%8D%E4%BD%9C%E7%AC%A6-toc" style="margin-left:40px;"><a href="#-%3E%E6%93%8D%E4%BD%9C%E7%AC%A6" rel="nofollow">-&gt;操作符</a></p> 
<p id="%E7%BB%93%E6%9E%84%E4%BD%93%E4%BC%A0%E5%8F%82-toc" style="margin-left:0px;"><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%BC%A0%E5%8F%82" rel="nofollow">结构体传参</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<h2 id="1.%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%93%E6%9E%84%E4%BD%93%20%EF%BC%9F">1.为何需要结构体，什么是结构体 ？</h2> 
<p>对于日期，分数，数字，名字这些简单的对象我们可以用整形，浮点型，字符进行描述。而对于一个人（例如：学生）这种复杂对象时，我们难以仅仅用整形，浮点型进行描述，往往我们需要<u>多个数据类型整合</u>起来描述。</p> 
<p>例如：学生，我们用姓名，年龄，性别，成绩描述</p> 
<p>姓名——&gt;字符数组</p> 
<p>年龄——&gt;整形</p> 
<p>性别——&gt;字符数组</p> 
<p>成绩——&gt;浮点数</p> 
<p>这时候，我们就要引出</p> 
<h4 id="%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9A">结构体的概念：</h4> 
<blockquote> 
 <p>结构是一些<strong>值的集合</strong>，这些值成为成员变量。结构的每个成员可以是不同类型的变量。</p> 
</blockquote> 
<p><img alt="" height="217" src="https://images2.imgbox.com/a6/a6/Z1ImHXa5_o.png" width="376"></p> 
<hr> 
<p></p> 
<h2 id="2.%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%A3%B0%E6%98%8E">2.结构体的声明</h2> 
<p>在main函数前面进行声明</p> 
<p><img alt="" height="157" src="https://images2.imgbox.com/10/78/fvws2LkK_o.png" width="314"></p> 
<p>注：变量列表里也可以不创建变量</p> 
<hr> 
<p>依然以学生为例，</p> 
<pre><code>struct stu {
	char name[20];//名字
	int age;//年龄
	char sex[10];//性别
	float score;//成绩
};//不创建变量</code></pre> 
<pre><code>struct stu {
	char name[20];//名字
	int age;//年龄
	char sex[10];//性别
	float score;//成绩
}s1,s2;//创建变量
</code></pre> 
<p>注：s1,s2是通过struct stu类型创建的变量，<strong>s1,s2是全局变量</strong></p> 
<p>注：<strong>结尾有分号</strong></p> 
<hr> 
<pre><code>struct stu {
	char name[20];//名字
	int age;//年龄
	char sex[10];//性别
	float score;//成绩
}s1,s2;
//s1,s2为全局变量
int main() {
	struct stu s3;      //注意:struct stu是结构体类型，此处struct不能省略
	struct stu s4;
	//此处s3,s4为局部变量
	return 0;
}</code></pre> 
<p> 注：<strong>s3，s4是局部变量</strong></p> 
<p>如果你感觉定义时麻烦，我们也可以简化一下，用typedef类型重定义，操作如下：</p> 
<pre><code>struct stu {
	char name[20];//名字
	int age;//年龄
	char sex[10];//性别
	float score;//成绩
}s1,s2;

typedef struct stu stu;

int main() {
	stu s3;
	stu s4;
	//此处s3,s4为局部变量
	return 0;
}</code></pre> 
<p><img alt="" height="142" src="https://images2.imgbox.com/f8/c8/AAEBxPr7_o.png" width="331"></p> 
<p></p> 
<p>也可以在定义这个结构体时，对整个结构体类型重定义 ，操作如下</p> 
<pre><code>typedef struct stu {
	char name[20];//名字
	int age;//年龄
	char sex[10];//性别
	float score;//成绩
}stu;//注意这不是变量

int main() {
	stu s3;
	stu s4;

	return 0;
}</code></pre> 
<p> <img alt="" height="318" src="https://images2.imgbox.com/f8/57/Tq0tZ2Kd_o.png" width="404"></p> 
<p> </p> 
<p><strong>特殊的声明： </strong></p> 
<p>在结构体声明时可以不完全声明：</p> 
<pre><code>//匿名结构体类型
struct {//省去了结构体标签
	char name[20];
	int age;
	char sex[10];
	float score;
}x;</code></pre> 
<p>此结构体只能用一次 </p> 
<p></p> 
<pre><code>struct {
	char name[20];
	int age;
	char sex[10];
	float score;
}x;
struct {
	char name[20];
	int age;
	char sex[10];
	float score;
}*p;
int main() {
	p = &amp;x;
}</code></pre> 
<p><img alt="" height="55" src="https://images2.imgbox.com/36/08/NhA7ItqS_o.png" width="424"></p> 
<p>若在主函数中p=&amp;x，编译器报错</p> 
<p>原因：匿名结构体成员如果一样，在编译器看来也是不同的类型</p> 
<p> </p> 
<h2 id="%C2%A0%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"> 结构体变量定义和初始化</h2> 
<p>我们继续以学生举例:</p> 
<pre><code>struct stu {
	char name[20];
	int age;
	char sex[10];
	float score;
}s1;

int main() {
	struct stu s2;      
	return 0;
}</code></pre> 
<p>这是定义了一个全局变量s1,和局部变量s2</p> 
<hr> 
<p><strong>初始化</strong>：定义变量的同时<strong>赋初值</strong></p> 
<p>这是初始化</p> 
<pre><code>struct stu {
	char name[20];
	int age;
	char sex[10];
	float score;
}s1 = {"zhangsan",18,"male",91};  //初始化

int main() {
	struct stu s2 = {"lisi",19,"female",92};   //初始化
	return 0;</code></pre> 
<p>结构体也可以嵌套初始化</p> 
<pre><code>struct subject {
	float math;
	float English;
};

struct stu {
	char name[20];
	int age;
	char sex[10];
	struct subject stu;
};

int main() {
	struct stu s = { "lisi",19,"female",{90,91} };//注意括号中的括号
	return 0;
}</code></pre> 
<p><img alt="" height="476" src="https://images2.imgbox.com/7e/55/4zx851CA_o.png" width="384"></p> 
<p><strong>结构体自引用 </strong></p> 
<pre><code>struct node {
	int data;
	struct node* next;
};</code></pre> 
<p>指针指向下一个同类型的自己 </p> 
<hr> 
<p></p> 
<h2 id="%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE">结构体成员的访问</h2> 
<p>访问结构体成员有两种方式： 第一个是用操作符  .   第二个是用操作符   -&gt;  </p> 
<hr> 
<h3 id=".%E6%93%8D%E4%BD%9C%E7%AC%A6">.操作符</h3> 
<p>形式为：结构体变量 . 结构体成员</p> 
<pre><code>#include&lt;stdio.h&gt;

struct stu {
	char name;
	int age;
	char sex[10];
};

int main() {
	struct stu s = {'w',19,"female"};
	printf("%c\n", s.name);
	printf("%d\n", s.age);
    printf("%s\n",s.sex);
	return 0;
}</code></pre> 
<p>也可以对已初始化的变量进行修改 </p> 
<pre><code>#include&lt;stdio.h&gt;

struct stu {
	char name;
	int age;
	char sex[10];
};

int main() {
	struct stu s = { 'w',19,"female" };
	s.name = 'c';   //修改
	printf("%c\n", s.name);
	printf("%d\n", s.age);
	printf("%s\n", s.sex);
	return 0;
}</code></pre> 
<hr> 
<h3 id="-%3E%E6%93%8D%E4%BD%9C%E7%AC%A6">-&gt;操作符</h3> 
<p>形式为：结构体指针 -&gt; 结构体成员</p> 
<pre><code>#include&lt;stdio.h&gt;

struct stu {
	char name;
	int age;
	char sex[10];
};
void print1(struct stu* stu) {
	printf("%c\n", stu-&gt;name);
	printf("%d\n", stu-&gt;age);
	printf("%s\n", stu-&gt;sex);
}
int main() {
	struct stu s = { 'w',19,"female" };
	print1(&amp;s);
	return 0;
}</code></pre> 
<hr> 
<h2 id="%E7%BB%93%E6%9E%84%E4%BD%93%E4%BC%A0%E5%8F%82">结构体传参</h2> 
<p>这里涉及到两种方式：一种是传址，一种是传值</p> 
<p>传址：</p> 
<pre><code>#include&lt;stdio.h&gt;

struct stu {
	char name;
	int age;
	char sex[10];
};
void print1(struct stu* stu) {
	printf("%c\n", stu-&gt;name);
	printf("%d\n", stu-&gt;age);
	printf("%s\n", stu-&gt;sex);
}
int main() {
	struct stu s = { 'w',19,"female" };
	print1(&amp;s);
	return 0;
}</code></pre> 
<p><img alt="" height="512" src="https://images2.imgbox.com/5b/29/6Q4boBAe_o.png" width="786">  </p> 
<p>传值 ：</p> 
<pre><code>#include&lt;stdio.h&gt;

struct stu {
	char name;
	int age;
	char sex[10];
};
void print1(struct stu stu) {
	printf("%c\n", stu.name);
	printf("%d\n", stu.age);
	printf("%s\n", stu.sex);
}
int main() {
	struct stu s = { 'w',19,"female" };
	print1(s);
	return 0;
}</code></pre> 
<p> <img alt="" height="510" src="https://images2.imgbox.com/b7/6c/oSJWYko7_o.png" width="688"></p> 
<p></p> 
<p></p> 
<p>对比以上两种方式，我们应该尽量选择第一种传址</p> 
<p>原因：函数传参时，参数是需要压栈的。如果传递一个结构体对象时，结构体过大，参数压栈的系统开销比较大，导致性能下降。</p> 
<p>通俗来讲，传值时，实参传递给形参，形参是其一份临时拷贝，结构体过大导致拷贝的形参也过大，占用空间是原来的2倍，相比于传址占用的内存空间更大</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/02d64f9170e892f030fea5581ae25a41/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言———打印100—200之间的素数并统计素数个数的三种写法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/46cbb148601e280f94fc0e834c95eb42/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux：Centos8 环境搭建指南</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>