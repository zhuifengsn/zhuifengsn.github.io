<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构(全) - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构(全)" />
<meta property="og:description" content="目录 第一章 绪 论
1.1 数据结构的基本概念
1.2 数据结构的三要素
1.2.1 数据的逻辑结构
1.2.2 数据的存储（物理）结构：
1.2.3 数据的运算
1.3 算法的基本概念
第二章 线性表
2.1 线性表的存储结构
2.2 顺序表与链表的比较
2.3 栈
2.4 队列
2.4 数组与特殊矩阵
2.5 串
第三章 树和二叉树
3.1 树和森林
3.1.1 树的基本术语
3.1.2 树的性质
3.1.3 树与森林的遍历
3.1.4 树的存储结构
3.1.5 树转二叉树
3.2 二叉树
3.2.1 二叉树的性质
3.2.4 线索二叉树
3.3 哈夫曼树和哈夫曼编码
第四章 图
4.1 图的基本概念
4.2 图的存储结构 4.3 最小生成树
4.3.1 Prim算法
4.3.2 Kruskal 算法（克鲁斯卡尔）
4.4 最短路径
4.5 有向⽆环图（DAG）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/13e438824ef055c12eb442ce67d94a24/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-25T16:36:02+08:00" />
<meta property="article:modified_time" content="2023-11-25T16:36:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构(全)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong> </p> 
<p id="%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BB%AA%20%E8%AE%BA-toc" style="margin-left:0px;"><a href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BB%AA%20%E8%AE%BA" rel="nofollow">第一章 绪 论</a></p> 
<p id="1.1%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#1.1%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">1.1 数据结构的基本概念</a></p> 
<p id="1.2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0-toc" style="margin-left:40px;"><a href="#1.2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0" rel="nofollow">1.2 数据结构的三要素</a></p> 
<p id="1.2.1%20%E6%95%B0%E6%8D%AE%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#1.2.1%20%E6%95%B0%E6%8D%AE%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84" rel="nofollow">1.2.1 数据的逻辑结构</a></p> 
<p id="1.2.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%EF%BC%88%E7%89%A9%E7%90%86%EF%BC%89%E7%BB%93%E6%9E%84%EF%BC%9A-toc" style="margin-left:80px;"><a href="#1.2.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%EF%BC%88%E7%89%A9%E7%90%86%EF%BC%89%E7%BB%93%E6%9E%84%EF%BC%9A" rel="nofollow">1.2.2 数据的存储（物理）结构：</a></p> 
<p id="1.2.3%C2%A0%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%90%E7%AE%97-toc" style="margin-left:80px;"><a href="#1.2.3%C2%A0%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%90%E7%AE%97" rel="nofollow">1.2.3 数据的运算</a></p> 
<p id="1.3%20%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#1.3%20%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">1.3 算法的基本概念</a></p> 
<p id="%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8-toc" style="margin-left:0px;"><a href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8" rel="nofollow">第二章 线性表</a></p> 
<p id="2.1%20%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#2.1%20%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84" rel="nofollow">2.1 线性表的存储结构</a></p> 
<p id="2.2%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83-toc" style="margin-left:40px;"><a href="#2.2%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83" rel="nofollow">2.2 顺序表与链表的比较</a></p> 
<p id="2.3%20%E6%A0%88-toc" style="margin-left:40px;"><a href="#2.3%20%E6%A0%88" rel="nofollow">2.3 栈</a></p> 
<p id="2.4%20%E9%98%9F%E5%88%97-toc" style="margin-left:40px;"><a href="#2.4%20%E9%98%9F%E5%88%97" rel="nofollow">2.4 队列</a></p> 
<p id="2.4%20%E6%95%B0%E7%BB%84%E4%B8%8E%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5-toc" style="margin-left:40px;"><a href="#2.4%20%E6%95%B0%E7%BB%84%E4%B8%8E%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5" rel="nofollow">2.4 数组与特殊矩阵</a></p> 
<p id="2.5%20%E4%B8%B2-toc" style="margin-left:40px;"><a href="#2.5%20%E4%B8%B2" rel="nofollow">2.5 串</a></p> 
<p id="%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:0px;"><a href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">第三章 树和二叉树</a></p> 
<p id="3.1%C2%A0%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97-toc" style="margin-left:40px;"><a href="#3.1%C2%A0%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97" rel="nofollow">3.1 树和森林</a></p> 
<p id="3.1.1%20%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD%3A-toc" style="margin-left:80px;"><a href="#3.1.1%20%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD%3A" rel="nofollow">3.1.1 树的基本术语</a></p> 
<p id="3.1.2%20%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8-toc" style="margin-left:80px;"><a href="#3.1.2%20%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8" rel="nofollow">3.1.2 树的性质</a></p> 
<p id="3.1.3%20%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86%3A-toc" style="margin-left:80px;"><a href="#3.1.3%20%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86%3A" rel="nofollow">3.1.3 树与森林的遍历</a></p> 
<p id="3.1.4%C2%A0%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%9A-toc" style="margin-left:80px;"><a href="#3.1.4%C2%A0%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%9A" rel="nofollow">3.1.4 树的存储结构</a></p> 
<p id="3.1.5%C2%A0%E6%A0%91%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:80px;"><a href="#3.1.5%C2%A0%E6%A0%91%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">3.1.5 树转二叉树</a></p> 
<p id="3.2%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:0px;"><a href="#3.2%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">        </a><a href="#3.2%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">3.2 二叉树</a></p> 
<p id="3.2.1%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8-toc" style="margin-left:80px;"><a href="#3.2.1%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8" rel="nofollow">3.2.1 二叉树的性质</a></p> 
<p id="3.2.4%C2%A0%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:80px;"><a href="#3.2.4%C2%A0%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">3.2.4 线索二叉树</a></p> 
<p id="3.3%20%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%92%8C%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81-toc" style="margin-left:40px;"><a href="#3.3%20%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%92%8C%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81" rel="nofollow">3.3 哈夫曼树和哈夫曼编码</a></p> 
<p id="%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%9B%BE-toc" style="margin-left:0px;"><a href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%9B%BE" rel="nofollow">第四章 图</a></p> 
<p id="4.1%20%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A-toc" style="margin-left:40px;"><a href="#4.1%20%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A" rel="nofollow">4.1 图的基本概念</a></p> 
<p id="4.2%20%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%C2%A0-toc" style="margin-left:40px;"><a href="#4.2%20%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%C2%A0" rel="nofollow">4.2 图的存储结构 </a></p> 
<p id="4.3%20%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-toc" style="margin-left:40px;"><a href="#4.3%20%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91" rel="nofollow">4.3 最小生成树</a></p> 
<p id="4.3.1%C2%A0Prim%E7%AE%97%E6%B3%95-toc" style="margin-left:80px;"><a href="#4.3.1%C2%A0Prim%E7%AE%97%E6%B3%95" rel="nofollow">4.3.1 Prim算法</a></p> 
<p id="4.3.2%20Kruskal%20%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%EF%BC%89-toc" style="margin-left:80px;"><a href="#4.3.2%20Kruskal%20%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%EF%BC%89" rel="nofollow">4.3.2 Kruskal 算法（克鲁斯卡尔）</a></p> 
<p id="4.4%20%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-toc" style="margin-left:40px;"><a href="#4.4%20%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84" rel="nofollow">4.4 最短路径</a></p> 
<p id="4.5%20%E6%9C%89%E5%90%91%E2%BD%86%E7%8E%AF%E5%9B%BE%EF%BC%88DAG%EF%BC%89-toc" style="margin-left:40px;"><a href="#4.5%20%E6%9C%89%E5%90%91%E2%BD%86%E7%8E%AF%E5%9B%BE%EF%BC%88DAG%EF%BC%89" rel="nofollow">4.5 有向⽆环图（DAG）</a></p> 
<p id="4.6%20%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#4.6%20%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F" rel="nofollow">4.6 拓扑排序</a></p> 
<p id="4.7%20%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84-toc" style="margin-left:40px;"><a href="#4.7%20%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84" rel="nofollow">4.7 关键路径</a></p> 
<p id="%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%9F%A5%E6%89%BE-toc" style="margin-left:0px;"><a href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%9F%A5%E6%89%BE" rel="nofollow">第五章 查找</a></p> 
<p id="5.1%20%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%EF%BC%88%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE%EF%BC%89%EF%BC%9A-toc" style="margin-left:40px;"><a href="#5.1%20%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%EF%BC%88%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE%EF%BC%89%EF%BC%9A" rel="nofollow">5.1 顺序查找（线性查找）</a></p> 
<p id="5.%202%20%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%EF%BC%9A-toc" style="margin-left:40px;"><a href="#5.%202%20%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%EF%BC%9A" rel="nofollow">5.2 折半查找</a></p> 
<p id="5.3%C2%A0%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE-toc" style="margin-left:40px;"><a href="#5.3%C2%A0%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE" rel="nofollow">5.3 分块查找</a></p> 
<p id="5.4%C2%A0%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91-toc" style="margin-left:40px;"><a href="#5.4%C2%A0%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91" rel="nofollow">5.4 二叉排序树</a></p> 
<p id="5.5%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:40px;"><a href="#5.5%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">5.5 平衡二叉树</a></p> 
<p id="5.6%C2%A0%E7%BA%A2%E9%BB%91%E6%A0%91-toc" style="margin-left:40px;"><a href="#5.6%C2%A0%E7%BA%A2%E9%BB%91%E6%A0%91" rel="nofollow">5.6 红黑树</a></p> 
<p id="5.7%20B%E6%A0%91-toc" style="margin-left:40px;"><a href="#5.7%20B%E6%A0%91" rel="nofollow">5.7 B树</a></p> 
<p id="5.8%20B%2B%E6%A0%91-toc" style="margin-left:40px;"><a href="#5.8%20B%2B%E6%A0%91" rel="nofollow">5.8 B+树</a></p> 
<p id="5.9%C2%A0%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%88Hash%EF%BC%89-toc" style="margin-left:40px;"><a href="#5.9%C2%A0%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%88Hash%EF%BC%89" rel="nofollow">5.9 哈希表（Hash）</a></p> 
<p id="5.9.1%C2%A0%E6%9E%84%E9%80%A0%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#5.9.1%C2%A0%E6%9E%84%E9%80%A0%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0" rel="nofollow">5.9.1 构造哈希函数</a></p> 
<p id="5.9.2%20%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81-toc" style="margin-left:80px;"><a href="#5.9.2%20%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81" rel="nofollow">5.9.2 处理冲突</a></p> 
<p id="%E7%AC%AC%E5%85%AD%E7%AB%A0%C2%A0%E6%8E%92%E5%BA%8F-toc" style="margin-left:0px;"><a href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%C2%A0%E6%8E%92%E5%BA%8F" rel="nofollow">第六章 排序</a></p> 
<p id="6.1%20%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#6.1%20%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" rel="nofollow">6.1 直接插入排序</a></p> 
<p id="6.2%20%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#6.2%20%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" rel="nofollow">6.2 希尔排序</a></p> 
<p id="6.3%C2%A0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#6.3%C2%A0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" rel="nofollow">6.3 冒泡排序</a></p> 
<p id="6.4%C2%A0%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#6.4%C2%A0%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" rel="nofollow">6.4 快速排序</a></p> 
<p id="6.5%C2%A0%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#6.5%C2%A0%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" rel="nofollow">6.5 简单选择排序</a></p> 
<p id="6.6%C2%A0%E5%A0%86%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#6.6%C2%A0%E5%A0%86%E6%8E%92%E5%BA%8F" rel="nofollow">6.6 堆排序</a></p> 
<p id="6.6.1%C2%A0%E5%BB%BA%E7%AB%8B%E5%A4%A7%E6%A0%B9%E5%A0%86-toc" style="margin-left:80px;"><a href="#6.6.1%C2%A0%E5%BB%BA%E7%AB%8B%E5%A4%A7%E6%A0%B9%E5%A0%86" rel="nofollow">6.6.1 建立大根堆</a></p> 
<p id="6.6.2%C2%A0%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4-toc" style="margin-left:80px;"><a href="#6.6.2%C2%A0%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4" rel="nofollow">6.6.2 堆的插入与删除</a></p> 
<p id="6.7%C2%A0%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#6.7%C2%A0%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" rel="nofollow">6.7 归并排序</a></p> 
<p id="6.8%C2%A0%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#6.8%C2%A0%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F" rel="nofollow">6.8 基数排序</a></p> 
<p id="6.9%C2%A0%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F-toc" style="margin-left:40px;"><a href="#6.9%C2%A0%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F" rel="nofollow">6.9 外部排序</a></p> 
<p id="6.9.1%C2%A0%E8%B4%A5%E8%80%85%E6%A0%91-toc" style="margin-left:80px;"><a href="#6.9.1%C2%A0%E8%B4%A5%E8%80%85%E6%A0%91" rel="nofollow">6.9.1 败者树</a></p> 
<p id="6.9.2%C2%A0%E7%BD%AE%E6%8D%A2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#6.9.2%C2%A0%E7%BD%AE%E6%8D%A2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" rel="nofollow">6.9.2 置换-选择排序</a></p> 
<p id="6.9.3%C2%A0%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91-toc" style="margin-left:80px;"><a href="#6.9.3%C2%A0%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91" rel="nofollow">6.9.3 最佳归并树</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BB%AA%20%E8%AE%BA" style="margin-left:0px;text-align:center;"><strong>第一章 绪 论</strong></h2> 
<p></p> 
<h3 id="1.1%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" style="margin-left:0px;text-align:justify;"><strong>1.1 数据结构的基本概念</strong></h3> 
<blockquote> 
 <p style="margin-left:0;text-align:justify;"><strong>        数据：</strong>所有能输入到计算机中并能被程序识别和处理的符号集合。包括:  <strong>数值数据：</strong>整数、实数等。<strong>非数值数据：</strong>图形、图象、声音、文字等。</p> 
</blockquote> 
<p style="margin-left:0;text-align:justify;"><strong>        数据元素：</strong>数据的基本单位，在程序中作为一个整体进行考虑和处理。</p> 
<p style="text-align:justify;"><strong>        数据项：</strong>构成数据元素的最小单位</p> 
<p style="text-align:justify;"><strong>关系图:</strong></p> 
<p class="img-center"><img alt="" height="290" src="https://images2.imgbox.com/39/aa/1tpoMB28_o.png" width="597"></p> 
<p style="margin-left:0;text-align:justify;"><strong>        数据类型：</strong>一组值的集合以及定义于这个值集上的一组操作（如：int）, 原子类,结构类</p> 
<p style="margin-left:0;text-align:justify;"><strong>        抽象数据类型(ADT)：</strong>一个数据模型以及定义在该模型上的一组操作<strong>,</strong> 也就是定义了一个数据结构。</p> 
<h3 id="1.2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0" style="margin-left:0px;text-align:justify;"><strong>1.2 数据结构的三要素</strong></h3> 
<blockquote> 
 <p style="margin-left:0;text-align:justify;"><strong>        数据结构：</strong>相互之间存在一定<strong>关系</strong>的<strong>数据元素</strong>的集合, 如下为数据结构的三要素</p> 
</blockquote> 
<p class="img-center"><img alt="" height="188" src="https://images2.imgbox.com/cc/2a/vYTOzw5Z_o.png" width="597"></p> 
<h4 id="1.2.1%20%E6%95%B0%E6%8D%AE%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><strong>1.2.1 数据的逻辑结构</strong></h4> 
<blockquote> 
 <p><strong>        </strong>数据元素之间<strong>逻辑关系</strong>的整体。</p> 
</blockquote> 
<p style="text-align:justify;"><strong>        集合：</strong>数据元素之间没有关系</p> 
<p style="text-align:justify;"><strong>        线性结构：</strong>数据元素之间是一对一的线性关系</p> 
<p style="text-align:justify;"><strong>        树结构：</strong>数据元素之间是一对多的层次关系</p> 
<p style="text-align:justify;"><strong>        图结构：</strong>数据元素之间是多对多的任意关系</p> 
<p class="img-center"><img alt="" height="225" src="https://images2.imgbox.com/05/d2/nidUjCcs_o.png" width="597"></p> 
<p></p> 
<h4 id="1.2.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%EF%BC%88%E7%89%A9%E7%90%86%EF%BC%89%E7%BB%93%E6%9E%84%EF%BC%9A" style="text-align:justify;"><strong>1.2.2 数据的存储（物理）结构：</strong></h4> 
<blockquote> 
 <p style="text-align:justify;"><strong>    </strong>    数据及其逻辑结构在计算机中的表示。</p> 
</blockquote> 
<p style="text-align:justify;"><strong>        顺序存储结构：</strong>用一组连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置表示</p> 
<p style="text-align:justify;"><strong>        链接存储结构：</strong>用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针来表示</p> 
<p class="img-center"><img alt="" height="208" src="https://images2.imgbox.com/19/8e/rOk42FWX_o.png" width="597"></p> 
<h4 id="1.2.3%C2%A0%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%90%E7%AE%97">1.2.3 <strong>数据的运算</strong></h4> 
<blockquote> 
 <p><strong>      </strong>  根据逻辑结构来定义, 根据存储结构来实现。</p> 
</blockquote> 
<h3 id="1.3%20%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" style="margin-left:0px;text-align:justify;"><strong>1.3 算法的基本概念</strong></h3> 
<blockquote> 
 <p style="margin-left:0;text-align:justify;"><strong>        算法 : </strong>是对特定问题求解步骤的一种描述，是指令的有限序列。<strong>程序 = 数据结构 + 算法</strong>; 算法必须是<strong>有穷的</strong>，而程序可以是无穷的</p> 
</blockquote> 
<p style="margin-left:0;text-align:justify;"><strong>算法的基本特性：</strong></p> 
<ul><li style="margin-left:0px;text-align:justify;">        有穷性: 有穷时间内能执行完 
  <ul><li style="margin-left:0px;text-align:justify;">        确定性: 相同输入只会有相同输出 
    <ul><li style="margin-left:0px;text-align:justify;">        可行性: 可以用已有的基本操作实现算法</li></ul></li></ul></li></ul> 
<p style="margin-left:0;text-align:justify;"><strong>好算法的特点：</strong></p> 
<ul><li style="text-align:justify;">高效性</li><li style="text-align:justify;">正确性</li><li style="text-align:justify;">健壮性: 能处理一些异常</li><li style="text-align:justify;">可理解性</li><li style="text-align:justify;">抽象分级</li></ul> 
<p style="margin-left:0;text-align:justify;"><strong>算法分析：</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>        时间复杂度：</strong>当问题规模充分大时，算法中<strong>基本语句</strong>的执行次数在渐近意义下的阶——关注的是增长趋势，用大O记号表示</p> 
<p style="margin-left:0;text-align:justify;"><strong>        常见的时间复杂度：</strong><em>Ο</em>(1)＜O(<img alt="log_{2}^{n}" class="mathcode" src="https://images2.imgbox.com/6e/66/6SJJpXpO_o.png">)＜O(<em>n</em>)＜O(<img alt="nlog_{2}^{n}" class="mathcode" src="https://images2.imgbox.com/17/6f/uTSqsNx9_o.png">)＜O(<img alt="n^{2}" class="mathcode" src="https://images2.imgbox.com/3d/ee/TMWdFuQX_o.png">)＜O(<img alt="2^{n}" class="mathcode" src="https://images2.imgbox.com/1b/94/e8QoDtm9_o.png">)＜O(<em>n</em>!)&lt; O(n<em>n</em>) (常对幂指阶)</p> 
<p style="margin-left:0;text-align:justify;"><strong>        空间复杂度：</strong>算法在执行过程中需要的<strong>辅助空间</strong>数量, 递归程序看递归深度与问题规模n的关系。</p> 
<h2 id="%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8" style="background-color:transparent;margin-left:0px;text-align:center;"><strong>第二章 线性表</strong></h2> 
<blockquote> 
 <p style="margin-left:0;text-align:justify;"><strong>        线性表的逻辑结构：</strong><em>n</em>（<em>n</em>≥0）个具有<strong>相同类型</strong>的数据元素的<strong>有限序列。</strong></p> 
</blockquote> 
<h3 id="2.1%20%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84" style="margin-left:0px;text-align:justify;"><strong>2.1 线性表的存储结构</strong></h3> 
<p style="text-align:justify;"><strong>        顺序表：</strong>静态存储分配，编译时确定容量，用一段地址连续的存储单元依次存储线性表的数据元素，逻辑关系通过存储位置（下标）来实现（<strong>随机存储</strong>）</p> 
<p style="text-align:justify;"><strong>        链表：</strong>动态存储分配，运行时分配空间，用一组任意的存储单元存放线性表的元素，用指针来反映数据元素之间的    逻辑关系（<strong>顺序存储</strong>）</p> 
<p style="text-align:justify;"><strong>        备注: </strong>位序从1开始 。</p> 
<p style="margin-left:0;text-align:justify;"><strong>顺序表与单链表图:</strong></p> 
<p class="img-center"><img alt="" height="426" src="https://images2.imgbox.com/8c/df/BqKiYAB3_o.png" width="553"></p> 
<p><strong>双链表示意图:</strong></p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="119" src="https://images2.imgbox.com/67/a1/lneOXY2k_o.png" width="1083"></p> 
<p style="margin-left:0;text-align:justify;"><strong>循环链表示意图:</strong></p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="108" src="https://images2.imgbox.com/52/bc/NBBC2W9Z_o.png" width="714"></p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="171" src="https://images2.imgbox.com/f0/df/rr1NMU24_o.png" width="868"></p> 
<p style="margin-left:0;text-align:justify;"><strong>静态链表示意图:</strong></p> 
<p class="img-center"><img alt="" height="413" src="https://images2.imgbox.com/dd/69/qo6Y9tI9_o.png" width="360"></p> 
<h3 id="2.2%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83" style="margin-left:0px;text-align:justify;"><strong>2.2 顺序表与链表的比较</strong></h3> 
<p style="margin-left:0;text-align:justify;"><strong>存储密度比较：</strong></p> 
<ul><li style="text-align:justify;"><strong>顺序表：</strong>只存储数据元素、预分配存储空间</li><li style="text-align:justify;"><strong>链表：</strong>指针的结构性开销、链表中的元素个数没有限制</li></ul> 
<p style="margin-left:0;text-align:justify;"><strong>按位查找：</strong></p> 
<ul><li style="text-align:justify;"><strong>顺序表</strong>：<em>O</em>(1)，随机存取</li><li style="text-align:justify;"><strong>链表</strong>：<em>O</em>(<em>n</em>)，顺序存取</li></ul> 
<p style="margin-left:0;text-align:justify;"><strong>插入和删除：</strong></p> 
<ul><li style="text-align:justify;"><strong>顺序表</strong>：<em>O</em>(<em>n</em>)，平均移动表长一半的元素</li><li style="text-align:justify;"><strong>链表</strong>：不用移动元素，合适位置的指针——<em>Ｏ</em>(1)</li></ul> 
<p style="margin-left:0;text-align:justify;"><strong>时间复杂度：</strong></p> 
<ul><li style="text-align:justify;"><strong>顺序表：</strong>若线性表<strong>频繁查找</strong>却很少进行插入和删除操作</li><li style="text-align:justify;"><strong>链表：</strong>若线性表需<strong>频繁插入</strong>和<strong>删除</strong>时</li></ul> 
<p style="margin-left:0;text-align:justify;"><strong>空间复杂度：</strong></p> 
<ul><li style="text-align:justify;"><strong>顺序表：</strong>知道线性表的大致长度，空间效率会更高</li><li style="text-align:justify;"><strong>链表：</strong>若线性表中元素<strong>个数变化</strong>较大或者未知</li></ul> 
<h3 id="2.3%20%E6%A0%88" style="margin-left:0px;text-align:justify;"><strong><strong>2.3 栈</strong></strong></h3> 
<blockquote> 
 <p style="margin-left:0;text-align:justify;"><strong>        定义：</strong>限定仅在一端（栈顶）进行插入和删除操作的线性表，后进先出。</p> 
</blockquote> 
<p><strong>栈示意图：</strong></p> 
<p></p> 
<p><img alt="" height="422" src="https://images2.imgbox.com/4a/c6/um5q0ACQ_o.png" width="957"></p> 
<p style="margin-left:0;text-align:justify;"><strong>        时间复杂度(</strong>插入与删除<strong>)</strong>：顺序栈与链栈均为<em>O</em>(1)</p> 
<p style="margin-left:0;text-align:justify;"><strong>        空间复杂度：</strong>链栈多一个指针域，结构性开销较大，使用过程中元素个数变化较大时，用链栈；反之顺序栈。</p> 
<p style="margin-left:0;text-align:justify;"><strong>        出栈元素不同排列的个数:</strong> <em><img alt="\frac{1}{n+1}C_{2n}^{n}" class="mathcode" src="https://images2.imgbox.com/4a/1a/mYu8jYu0_o.png"></em>  (卡特兰数)</p> 
<p style="margin-left:0;text-align:justify;"><strong>        共享栈:</strong> 两个栈共享一片内存空间, 两个栈从两边往中间增长。</p> 
<p style="margin-left:0;text-align:justify;"><strong>存储结构:</strong></p> 
<ul><li style="text-align:justify;">顺序栈初始化：top=-1</li><li style="text-align:justify;">链栈初始化：top=NULL</li></ul> 
<p style="margin-left:0;text-align:justify;"><strong>栈的应用:</strong></p> 
<p style="margin-left:0;text-align:justify;">        1) 括号匹配</p> 
<p style="margin-left:0;text-align:justify;">        2) 递归</p> 
<p style="margin-left:0;text-align:justify;">        3) 后缀表达式</p> 
<p style="margin-left:0;text-align:justify;">        4) 中缀表达式：设两个栈（数据栈和运算符栈），根据运算符栈的优先级进行运算。</p> 
<h3 id="2.4%20%E9%98%9F%E5%88%97" style="margin-left:0px;text-align:justify;"><strong><strong>2.4 队列</strong></strong></h3> 
<blockquote> 
 <p style="margin-left:0;text-align:justify;"><strong>        定义: </strong>只允许在一端插入, 在另一端删除。具有先进先出的特点。</p> 
</blockquote> 
<p><strong>队列示意图:</strong></p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/97/f5/KwrEfHEX_o.png" width="1113"></p> 
<p style="margin-left:0;text-align:justify;"><strong>        时间复杂度：</strong>均为O（1）</p> 
<p style="margin-left:0;text-align:justify;"><strong>        空间复杂度：</strong>链队列多一个指针域，结构性开销较大；循环队列存在浪费空间和溢出问题。使用过程中元素个数变化较大时，用链队列；反之循环队列。</p> 
<p style="margin-left:0;text-align:justify;"><strong>        双端队列: </strong>只允许从两端插入、两端删除的线性表。</p> 
<p style="margin-left:0;text-align:justify;"><strong>双端队列示意图： </strong></p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="691" src="https://images2.imgbox.com/59/7f/FQkJSjpX_o.png" width="1161"></p> 
<p style="margin-left:0;text-align:justify;"><strong>存储结构:</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>        链队列:</strong>队头指针指向队头元素的前一个位置，队尾指针指向队尾元素，先进先出。</p> 
<p style="margin-left:0;text-align:justify;"><strong>        循环队列：</strong></p> 
<p style="text-align:justify;"><strong>                1）队空：</strong>front=rear</p> 
<p style="text-align:justify;"><strong>                2）队满：</strong>(rear+1)%QueueSize=front</p> 
<p style="text-align:justify;"><strong>                3）队列元素个数：</strong>（队尾-队头+队长）%队长==(rear-front+QueueSize)%QueueSize</p> 
<p style="margin-left:0;text-align:justify;"><strong>队列的应用:</strong></p> 
<p style="margin-left:0;text-align:justify;">        1) 树的层次遍历</p> 
<p style="margin-left:0;text-align:justify;">        2) 图的广度优先遍历</p> 
<h3 id="2.4%20%E6%95%B0%E7%BB%84%E4%B8%8E%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5" style="margin-left:0px;text-align:justify;">2.4 数组与特殊矩阵</h3> 
<p style="margin-left:0;text-align:justify;"><strong>一维数组的存储结构：</strong></p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="146" src="https://images2.imgbox.com/d3/16/RBTU9uXB_o.png" width="1178"></p> 
<p><strong>二维数组的存储结构：</strong></p> 
<p> <img alt="" height="560" src="https://images2.imgbox.com/68/22/eFVYfdsL_o.png" width="1200"></p> 
<p><strong>对称矩阵的压缩(行优先)：</strong></p> 
<p><img alt="" height="699" src="https://images2.imgbox.com/50/dd/kiMkKKm5_o.png" width="1200"></p> 
<p><strong>下三角矩阵的压缩(行优先)：</strong></p> 
<p> <img alt="" height="718" src="https://images2.imgbox.com/27/7a/oW7GUFj4_o.png" width="1200"></p> 
<p><strong> 上三角(行优先):</strong><img alt="" height="690" src="https://images2.imgbox.com/b8/8f/eLXqOoRQ_o.png" width="1200"></p> 
<p><strong>三对角矩阵的压缩(行优先)：</strong></p> 
<p><img alt="" height="685" src="https://images2.imgbox.com/20/dc/UVKbOMJo_o.png" width="1200"></p> 
<p><strong>稀疏矩阵压缩：</strong></p> 
<p><img alt="" height="643" src="https://images2.imgbox.com/e1/f7/DbDkdHhR_o.png" width="1200"></p> 
<p><strong>十字链表法压缩稀疏矩阵：</strong></p> 
<p><img alt="" height="710" src="https://images2.imgbox.com/16/cc/pqPBEQTd_o.png" width="1200"></p> 
<h3 id="2.5%20%E4%B8%B2" style="margin-left:0px;text-align:justify;">2.5 串</h3> 
<blockquote> 
 <p>        串，即字符串（String）是由零个或多个字符组成的有限序列。串是一种特殊的线性表，数据元素之间呈线性关系。</p> 
</blockquote> 
<p><strong>字符串模式匹配：</strong></p> 
<p>       <strong> 1）朴素模式匹配算法</strong></p> 
<p><strong>        2）KMP算法</strong></p> 
<p><strong>手算KMP的next数组示意图:</strong></p> 
<p><img alt="" height="284" src="https://images2.imgbox.com/37/3e/tWbcPfHO_o.png" width="835"></p> 
<p><strong>求next[2] :</strong></p> 
<p><img alt="" height="151" src="https://images2.imgbox.com/6a/fb/iYXa5p2E_o.png" width="815"></p> 
<p><img alt="" height="155" src="https://images2.imgbox.com/91/f3/j0mjAyAQ_o.png" width="816"></p> 
<p><strong>求next[3]: </strong></p> 
<p><img alt="" height="156" src="https://images2.imgbox.com/75/07/gCJaPfIB_o.png" width="809"></p> 
<p><img alt="" height="158" src="https://images2.imgbox.com/48/9d/PZdb27sO_o.png" width="818"></p> 
<p><strong>求next[4]: </strong></p> 
<p><img alt="" height="148" src="https://images2.imgbox.com/b2/74/Xz18H2tD_o.png" width="816"></p> 
<p><img alt="" height="155" src="https://images2.imgbox.com/79/60/vgvWJe4S_o.png" width="818"></p> 
<p><strong>求next[5]: </strong></p> 
<p><img alt="" height="151" src="https://images2.imgbox.com/98/aa/Uox5dS9B_o.png" width="830"></p> 
<p><img alt="" height="160" src="https://images2.imgbox.com/22/57/TRz8QoP8_o.png" width="823"></p> 
<p><strong>C语言求KMP的next数组代码示例:</strong></p> 
<pre><code class="language-cpp">void Createnext(char *sub, int *next){
    assert(sub != NULL &amp;&amp; next != NULL);
    int j = 2;             //模式串的next指针
    int k = 0;             //next数组的回溯值,初始化为next[1]=0
    int lenSub = strlen(sub);
    assert(lenSub != 0);
    next[0] = -1;
    next[1] = 0;
    while (j &lt; lenSub){
        if (sub[j-1] == sub[k]){
            next[j] = ++k;
            j++;
        }
        else{
            k = next[k];
            if (k == -1){
                k = 0;
                next[j] = k;
                j++;
            }
        }
    }
}</code></pre> 
<p><strong>求nextValue:</strong></p> 
<pre><code class="language-cpp">void nextValue(char *sub, int *next) {
	int lenSub = strlen(sub);
	for(int j=2;j&lt;lensub; j++){
		if(sub[j]==sub[next[j]])
			next[j]=next[next[j]]
	}
}</code></pre> 
<p><strong>备注: </strong></p> 
<p>        1) 实现next有多种不同方式, 对应不同的next数组使用</p> 
<p>        2) 根据实现方式不同, next数组整体+1不影响KMP算法。</p> 
<h2 id="%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91" style="background-color:transparent;margin-left:0px;text-align:center;">第三章 树和二叉树</h2> 
<h3 id="3.1%C2%A0%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97" style="margin-left:0px;"><strong>3.1 树和森林</strong></h3> 
<blockquote> 
 <p style="margin-left:0px;text-align:justify;"><strong>        定义（树）：</strong><em>n</em>（<em>n</em>≥0）个结点（数据元素）的有限集合，当 <em>n</em>＝0 时，称为空树。</p> 
</blockquote> 
<h4 id="3.1.1%20%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD%3A" style="margin-left:0px;text-align:justify;"><strong>3.1.1 树的基本术语</strong></h4> 
<p style="margin-left:0;text-align:justify;"><strong>        结点的度：</strong>结点所拥有的子树的个数。</p> 
<p style="margin-left:0;text-align:justify;"><strong>        叶子结点：</strong>度为 0 的结点，也称为终端结点。</p> 
<p style="margin-left:0;text-align:justify;"><strong>        分支结点：</strong>度不为 0 的结点，也称为非终端结点。</p> 
<p style="margin-left:0;text-align:justify;"><strong>        孩子：</strong>树中某结点子树的根结点称为这个结点的孩子结点。</p> 
<p style="margin-left:0;text-align:justify;"><strong>        双亲：</strong>这个结点称为它孩子结点的双亲结点。</p> 
<p style="margin-left:0;text-align:justify;"><strong>        兄弟：</strong>具有同一个双亲的孩子结点互称为兄弟。</p> 
<p style="margin-left:0;text-align:justify;"><strong>        路径：</strong>结点序列 <strong><em>n</em>1, <em>n</em>2, …, <em>nk </em></strong>称为一条由 <strong><em>n</em>1 </strong>至 <strong><em>nk </em></strong>的路径，当且仅当满足结点 <strong><em>ni </em></strong>是 <strong><em>ni</em>+1 </strong>的双亲<strong>（1&lt;=<em>i</em>&lt;<em>k</em>）</strong>的关系。</p> 
<p style="margin-left:0;text-align:justify;"><strong>        路径长度：</strong>路径上经过的边的个数。</p> 
<p style="margin-left:0;text-align:justify;"><strong>        祖先、子孙：</strong>如果有一条路径从结点 <em>x </em>到结点 <em>y</em>，则 <em>x </em>称为 <em>y </em>的祖先，而 <em>y </em>称为 <em>x </em>的子孙。</p> 
<p style="margin-left:0;text-align:justify;"><strong>        结点所在层数：</strong>根结点的层数为 1；对其余结点，若某结点在第 <em>k</em> 层，则其孩子结点在第 <em>k</em>+1 层。</p> 
<p style="margin-left:0;text-align:justify;"><strong>        树的深度（高度）：</strong>树中所有结点的最大层数。</p> 
<p style="margin-left:0;text-align:justify;"><strong>        树的宽度：</strong>树中每一层结点个数的最大值。</p> 
<p style="margin-left:0;text-align:justify;">        <strong>树的度：</strong>树中各结点度的最大值。</p> 
<p style="margin-left:0;text-align:justify;">     <strong>   树的路径长度:  </strong>从根到每个结点的路径长度总和</p> 
<p style="margin-left:0;text-align:justify;"><strong>        备注:</strong> 在线性结构中，逻辑关系表现为前驱——后继,一对一; 在树结构中，逻辑关系表现为双亲——孩子,一对多。</p> 
<p style="margin-left:0;text-align:justify;">        <strong>森林:</strong> 森林是m（m≥0）棵互不相交的树的集合, m可为0, 即空森林。</p> 
<h4 id="3.1.2%20%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8" style="background-color:transparent;margin-left:0px;text-align:justify;"><strong>3.1.2 树的性质</strong></h4> 
<p style="margin-left:0;text-align:justify;"><strong>        结点数=总度数+1</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>        度为m的树第 i 层至多有 <img alt="m^{i-1}" class="mathcode" src="https://images2.imgbox.com/c6/cd/25cLg6Zv_o.png"> 个结点（i≥1）</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>        高度为h的m叉树至多有<img alt="\frac{m^{h}-1}{m-1}" class="mathcode" src="https://images2.imgbox.com/fc/3c/nuTap9AT_o.png"> 个结点</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>        具有n个结点的m叉树的最小高度为 <img alt="\left \lceil log_{m}^{n(m-1)+1} \right \rceil" class="mathcode" src="https://images2.imgbox.com/ca/00/wbcmbvLM_o.png"></strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>最小高度推理过程图:</strong></p> 
<p class="img-center"><img alt="" height="307" src="https://images2.imgbox.com/b3/e6/gY4aPnOv_o.png" width="635"></p> 
<h4 id="3.1.3%20%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86%3A" style="margin-left:0px;text-align:justify;"><strong>3.1.3 树与森林的遍历</strong></h4> 
<p style="margin-left:0;text-align:justify;"><strong>树的遍历:</strong></p> 
<ul><li style="text-align:justify;">先根遍历(先根后子树)</li><li style="text-align:justify;">后根遍历(先子树后根)</li><li style="text-align:justify;">层序遍历</li></ul> 
<p><strong>森林的遍历:</strong></p> 
<ul><li style="text-align:justify;">前序遍历(先根, 后子树)</li><li style="text-align:justify;">中序遍历(先子树后根, 其实就是后序遍历树)</li></ul> 
<p><strong>区别与联系: </strong></p> 
<p style="margin-left:0;text-align:justify;">    <span style="color:#fe2c24;"><strong>    1) 树的前序遍历等价于其树转化二叉树的前序遍历！</strong></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#fe2c24;"><strong>        2) 树的后序遍历等价于其树转化二叉树的中序遍历！</strong></span></p> 
<p><img alt="" height="136" src="https://images2.imgbox.com/a0/58/pFhy1L7A_o.png" width="834"></p> 
<h4 id="3.1.4%C2%A0%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%9A" style="margin-left:0px;text-align:justify;"><strong>3.1.4 树的存储结构</strong></h4> 
<p style="margin-left:0;text-align:justify;"><strong>双亲表示法图:</strong></p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="448" src="https://images2.imgbox.com/e1/ce/YwyeeHKr_o.png" width="828"></p> 
<p style="text-align:justify;"><strong>孩子表示法图:</strong></p> 
<p style="text-align:justify;"><img alt="" height="443" src="https://images2.imgbox.com/10/b3/Q1SaTyn3_o.png" width="856"></p> 
<p><strong>孩子兄弟表示法图(树/森林转化为二叉树):</strong></p> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="325" src="https://images2.imgbox.com/53/4e/dN13CHRc_o.png" width="852"></p> 
<h4 id="3.1.5%C2%A0%E6%A0%91%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91" style="background-color:transparent;">3.1.5 树转二叉树</h4> 
<p><strong>在树转为二叉树后, 有以下结论:</strong></p> 
<p><span style="color:#fe2c24;"><strong>        1) 树的叶子结点数量 = 二叉树左空指针数量</strong></span><strong>(形象理解为树越宽, 兄弟越多, 越是向右长)</strong></p> 
<p><span style="color:#fe2c24;"><strong>        2) 树的非叶子结点数量 = 二叉树右空指针-1</strong></span><strong>(树越高, 有儿子定是非结点,  越是向左长, -1可以理解为不包含最后一个儿子的右空指针 )</strong></p> 
<h3 id="3.2%C2%A0%E4%BA%8C%E5%8F%89%E6%A0%91">3.2 <strong><strong>二叉树</strong></strong></h3> 
<h4 id="3.2.1%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8" style="background-color:transparent;"><strong><strong>3.2.1 二叉树的性质</strong></strong></h4> 
<p style="margin-left:0;text-align:justify;"><strong>斜树：</strong></p> 
<ul><li style="text-align:justify;"><strong>左斜树：</strong>所有结点都只有左子树的二叉树</li><li style="text-align:justify;"><strong>右斜树：</strong>所有结点都只有右子树的二叉树</li></ul> 
<p style="margin-left:0;text-align:justify;"><strong>        满二叉树：</strong>所有分支结点都存在左子树和右子树，且所有叶子都在同一层上的二叉树</p> 
<p style="margin-left:0;text-align:justify;"><strong>        完全二叉树：</strong>在满二叉树中，从最后一个结点开始，连续去掉任意个结点得到的二叉树</p> 
<p style="margin-left:0;text-align:justify;"><strong>完全二叉树特点：</strong></p> 
<ul><li style="text-align:justify;">叶子结点只能出现在最下两层且最下层的叶子结点都集中在二叉树的左面</li><li style="text-align:justify;">完全二叉树中如果有度为 1 的结点，只可能有一个，且该结点只有左孩子</li><li style="text-align:justify;">深度为 <em>k</em> 的完全二叉树在 <em>k</em>-1 层上一定是满二叉树</li><li style="text-align:justify;">在同样结点个数的二叉树中，完全二叉树的深度最小</li></ul> 
<p style="margin-left:0;text-align:justify;"><strong>        性质：<span style="color:#fe2c24;">在二叉树中，如果叶子结点数为 <em>n</em>0，度为 2 的结点数为 <em>n</em>2，则有: <em>n</em>0＝<em>n</em>2+1 </span></strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>证明:</strong> 设 <strong><em>n </em></strong>为二叉树的结点总数，<strong><em>n</em>1 </strong>为二叉树中度为 1 的结点数，则有：</p> 
<p style="margin-left:0px;text-align:center;"><strong> <em>n</em>＝<em>n</em>0＋<em>n</em>1＋<em>n</em>2 </strong></p> 
<p style="margin-left:0;text-align:justify;">        在二叉树中，除了根结点外，其余结点都有唯一的一个分枝进入，一个度为 1 的结点射出一个分枝，一个度为 2 的结点射出两个分枝，所以有：</p> 
<p style="margin-left:0px;text-align:center;"><strong><em>n</em>＝<em>n</em>1＋2<em>n</em>2＋1</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>        性质：<span style="color:#fe2c24;">二叉树的第 <em>i</em> 层上最多有<img alt="2^{i-1}" class="mathcode" src="https://images2.imgbox.com/d3/2c/ujHpYvAq_o.png">个结点（<em>i</em>≥1）</span></strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>        性质：<span style="color:#fe2c24;">一棵深度为 <em>k</em> 的二叉树中，最多有 <img alt="2^{k}-1" class="mathcode" src="https://images2.imgbox.com/e1/c8/mrpbU6N3_o.png">个结点</span></strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>        性质：<span style="color:#fe2c24;">具有 <em>n </em>个结点的完全二叉树的深度为 <img alt="log_{2}^{n}" class="mathcode" src="https://images2.imgbox.com/4e/c1/EKVoJdxK_o.png">向下取整+1 (或<img alt="log_{2}^{n+1}" class="mathcode" src="https://images2.imgbox.com/6e/76/Tyumy8CA_o.png">向上取整)</span></strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>证明：</strong>设具有 <em>n</em> 个结点的完全二叉树的深度为 <em>k</em>，则：</p> 
<p style="margin-left:0;text-align:center;"><img alt="2^{k-1}" class="mathcode" src="https://images2.imgbox.com/ed/e9/QV3lvVpi_o.png"><em>≤n</em>  <em>&lt;</em><img alt="2^{k}" class="mathcode" src="https://images2.imgbox.com/04/bb/wBTFDTmq_o.png"></p> 
<p style="margin-left:0;text-align:left;">对不等式取对数，有：</p> 
<p style="margin-left:0;text-align:center;"><strong><em>k</em>-1 ≤ <img alt="log_{2}^{n}" class="mathcode" src="https://images2.imgbox.com/57/9e/9Xoa9eru_o.png">＜<em>k</em></strong></p> 
<p style="margin-left:0;text-align:left;">即：</p> 
<p style="margin-left:0;text-align:center;"><img alt="log_{2}^{n}" class="mathcode" src="https://images2.imgbox.com/d1/6c/9gAooukc_o.png"><strong>＜<em>k </em>≤ </strong><img alt="log_{2}^{n}" class="mathcode" src="https://images2.imgbox.com/53/25/r0TVuevv_o.png"><strong>+1</strong></p> 
<p style="margin-left:0;text-align:justify;">由于 <em>k</em> 是整数，故必有</p> 
<p style="margin-left:0;text-align:center;"><strong><em>k</em>＝ </strong><img alt="log_{2}^{n}" src="https://images2.imgbox.com/1a/ca/YgIvcyR6_o.png"><strong> +1</strong> </p> 
<p style="margin-left:0;text-align:justify;"><strong>        性质：</strong>对一棵具有 <em>n</em> 个结点的完全二叉树中<strong>从 1 开始</strong>按层序编号，对于任意的序号为 <em>i</em>（1≤<em>i</em>≤<em>n</em>）的结点（简称结点 <em>i</em>），有：</p> 
<ul><li style="text-align:justify;"><strong><span style="color:#fe2c24;">如果 <em>i</em>＞1，则结点 <em>i</em> 的双亲结点的序号为 <em>i</em>/2，否则结点 <em>i</em> 无双亲结点</span></strong></li><li style="text-align:justify;"><strong><span style="color:#fe2c24;">如果 2<em>i</em>≤<em>n</em>，则结点 <em>i</em> 的左孩子的序号为 2<em>i</em>，否则结点 <em>i</em> 无左孩子</span></strong></li><li style="text-align:justify;"><strong><span style="color:#fe2c24;">如果 2<em>i</em>+1≤<em>n</em>，则结点 <em>i</em> 的右孩子的序号为2<em>i</em>+1，否则结点 <em>i</em> 无右孩子</span></strong></li></ul> 
<p><strong>        性质：</strong>若已知一棵二叉树的前序序列和中序序列，或者中序序列和后序序列，能唯一确定一颗二叉树。 </p> 
<p style="margin-left:0;text-align:justify;"><strong>3.2.2 二叉树的遍历</strong></p> 
<blockquote> 
 <p style="margin-left:0;text-align:justify;"><strong>        </strong>从根结点出发，按照某种次序访问树中所有结点，并且每个结点仅被访问一次。</p> 
</blockquote> 
<ul><li style="text-align:justify;">前序遍历（深度优先遍历）</li><li style="text-align:justify;">中序遍历</li><li style="text-align:justify;">后序遍历</li><li style="text-align:justify;">层序遍历（广度优先遍历）</li></ul> 
<p style="margin-left:0;text-align:justify;"><strong>3.2.3 二叉树的存储</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>链式存储图:</strong></p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="526" src="https://images2.imgbox.com/50/b3/bZKxj0tQ_o.png" width="1148"></p> 
<p style="margin-left:0;text-align:justify;"><strong>顺序存储图:</strong></p> 
<p><img alt="" height="460" src="https://images2.imgbox.com/76/e6/giIbvCI4_o.png" width="1063"></p> 
<h4 id="3.2.4%C2%A0%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91">3.2.4 线索二叉树</h4> 
<blockquote> 
 <p>        利用二叉树中n+1个空指针, 将指针指向结点的前驱和后继。</p> 
</blockquote> 
<p><strong>存储结构:</strong></p> 
<p></p> 
<p class="img-center"><img alt="" height="92" src="https://images2.imgbox.com/03/8b/6XsyBEFK_o.png" width="551"></p> 
<p><strong>示例图:</strong></p> 
<p><img alt="" height="479" src="https://images2.imgbox.com/ac/34/wUt5Mnpa_o.png" width="1064"></p> 
<p><strong>三种线索化的对比图:</strong></p> 
<p><img alt="" height="626" src="https://images2.imgbox.com/e9/c2/D2oTNmHT_o.png" width="1087"></p> 
<p><strong> 各自特点:</strong></p> 
<p><img alt="" height="293" src="https://images2.imgbox.com/46/0f/AmgK6JN9_o.png" width="985"></p> 
<h3 id="3.3%20%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%92%8C%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81">3.3 哈夫曼树和哈夫曼编码</h3> 
<p style="margin-left:0;text-align:justify;"><strong><strong>        带权路径长度(WPL)：</strong></strong>从根结点到各个叶子结点的路径长度与相应叶子结点权值的乘积之和</p> 
<p style="margin-left:0;text-align:justify;"><strong>        最优二叉树（哈夫曼树）：</strong>给定一组具有确定权值的叶子结点，带权路径长度最小的二叉树</p> 
<p style="margin-left:0;text-align:justify;"><strong>特点：</strong></p> 
<ul><li style="text-align:justify;">权值越大的叶子结点越靠近根结点</li><li style="text-align:justify;">只有度为 0 和度为 2 的结点，不存在度为 1 的结点</li></ul> 
<p><strong>        前缀编码：</strong>在一组编码中，任一编码都不是其它任何编码的前缀,<strong> </strong>前缀编码保证了在解码时不会有多种可能。 </p> 
<h2 id="%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%9B%BE" style="margin-left:0px;text-align:center;"><strong>第四章 图</strong></h2> 
<blockquote> 
 <p style="margin-left:0;text-align:justify;"><strong>        定义</strong>：顶点集V和边集E组成，记为G = (V, E)</p> 
</blockquote> 
<p style="margin-left:0;text-align:justify;"><strong>        注意：</strong>线性表可以是空表，树可以是空树，但图不可以是空，即V一定是非空集, 边集E可以为空</p> 
<p style="margin-left:0;text-align:justify;"><strong>        子图：</strong>若图<em>G</em>=(<em>V</em>, <em>E</em>)，<em>G'</em>=(<em>V'</em>, <em>E</em>')，如果<em>V'</em> 属于 <em>V</em> 且<em>E' </em>属于<em>E</em>，则称图<em>G'</em>是<em>G</em>的子图</p> 
<h3 id="4.1%20%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A" style="background-color:transparent;margin-left:0px;text-align:justify;"><strong>4.1 图的基本概念</strong></h3> 
<p style="margin-left:0;text-align:justify;"><strong>图的分类:</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>        无向边</strong>：表示为(<em>vi</em>,<em>vj</em>)，顶点<em>vi</em>和<em>vj</em>之间的边没有方向</p> 
<p style="margin-left:0;text-align:justify;"><strong>        有向边</strong>（弧）：表示为&lt;<em>vi</em>,<em>vj</em>&gt;，从<em>vi </em>到<em>vj </em>的边有方向, vi为弧尾, vj为弧头</p> 
<p style="margin-left:0;text-align:justify;"><strong>        稠密图</strong>：边数很多的图</p> 
<p style="margin-left:0;text-align:justify;"><strong>        稀疏图</strong>：边数很少的图</p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#fe2c24;"><strong>        无向完全图</strong>：无向图中，任意两个顶点之间都存在边</span></p> 
<p style="margin-left:0;text-align:justify;"><strong>        <span style="color:#fe2c24;">有向完全图</span></strong><span style="color:#fe2c24;">：有向图中，任意两个顶点之间都存在方向相反的两条弧</span></p> 
<p style="margin-left:0;text-align:left;"><strong>度、入度和出度</strong>：</p> 
<p style="margin-left:0;text-align:justify;"><strong>        顶点的度</strong>：在无向图中，顶点 <em>v </em>的度是指依附于该顶点的边数，通常记为TD (<em>v</em>)</p> 
<p style="margin-left:0;text-align:justify;"><strong>        顶点的入度</strong>：在有向图中，顶点 <em>v</em> 的入度是指以该顶点为弧头的弧的数目，记为ID (<em>v</em>)；</p> 
<p style="margin-left:0;text-align:justify;"><strong>        顶点的出度</strong>：在有向图中，顶点 <em>v</em> 的出度是指以该顶点为弧尾的弧的数目，记为OD (<em>v</em>)；</p> 
<p style="margin-left:0;text-align:justify;"><strong>        握手定理:</strong></p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="228" src="https://images2.imgbox.com/52/59/2P5S2uwa_o.png" width="1030">​​​​​​​</p> 
<p> <strong>路径：</strong> </p> 
<p style="margin-left:0;text-align:justify;"><strong>        回路（环）</strong>：第一个顶点和最后一个顶点相同的路径</p> 
<p style="margin-left:0;text-align:justify;"><strong>        简单路径</strong>：序列中顶点不重复出现的路径</p> 
<p style="margin-left:0;text-align:justify;"><strong>        简单回路（简单环）</strong>：除第一个和最后一个顶点外，其余顶点不重复出现的回路。</p> 
<p style="margin-left:0;text-align:justify;"><strong>        路径长度：</strong>非带权图——路径上边的个数</p> 
<p style="margin-left:0;text-align:justify;"><strong>        路径长度：</strong>带权图——路径上边的权值之和<strong> </strong></p> 
<p style="margin-left:0;text-align:justify;"><strong><strong>无向连通图：</strong></strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>        连通顶点：</strong>在无向图中，如果顶点<em>vi</em>和顶点<em>vj</em>(<em>i</em>≠<em>j</em>)之间有路径，则称顶点<em>vi</em>和<em>vj</em>是连通的</p> 
<p style="margin-left:0;text-align:justify;"><strong>        <span style="color:#fe2c24;">连通图：</span></strong><span style="color:#fe2c24;">在无向图中，如果任意两个顶点都是连通的，则称该无向图是连通图</span></p> 
<p style="margin-left:0;text-align:justify;"><strong>        连通分量：</strong>非连通图的极大连通子图、连通分量是对无向图的一种划分</p> 
<p style="margin-left:0;text-align:justify;"><strong>连通分量示意图:</strong></p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="287" src="https://images2.imgbox.com/da/af/cH9mngIm_o.png" width="471"><img alt="" height="284" src="https://images2.imgbox.com/72/b9/bF8adiYA_o.png" width="183"></p> 
<p style="margin-left:0;text-align:justify;"><strong>有向强连通图、强连通分量：</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>        强连通顶点：</strong>在有向图中，如果从顶点vi到顶点vj和从顶点vj到顶点vi均有路径，则称顶点vi和vj是强连通的</p> 
<p style="margin-left:0;text-align:justify;"><strong>   <span style="color:#fe2c24;">     强连通图</span></strong><span style="color:#fe2c24;">：在有向图中，如果任意两个顶点都是强连通的，则称该有向图是强连通图</span></p> 
<p style="margin-left:0;text-align:justify;"><strong>        强连通分量</strong>：非强连通图的极大连通子图</p> 
<p><strong>强连通分量示意图: </strong></p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="284" src="https://images2.imgbox.com/e5/6a/KytlFZ38_o.png" width="697"></p> 
<p><strong>子图与生成子图:</strong></p> 
<p><img alt="" height="480" src="https://images2.imgbox.com/ec/d2/O529vWs9_o.png" width="1200"></p> 
<p><strong>常考点</strong></p> 
<p><strong>无向图:</strong></p> 
<p>      <span style="color:#fe2c24;">  所有顶点的度之和=2|E|</span></p> 
<p><span style="color:#fe2c24;">        若G是连通图，则最少有 n-1 条边（树），若 |E|&gt;n-1，则一定有回路</span></p> 
<p><span style="color:#fe2c24;">        若G是非连通图，则最多可能有 <img alt="C_{n-1}^{2}" class="mathcode" src="https://images2.imgbox.com/05/47/cGMSLcJI_o.png"> 条边 (n-1个完全图+1个孤点)</span></p> 
<p><span style="color:#fe2c24;">        无向完全图共有<img alt="C_{n}^{2}" class="mathcode" src="https://images2.imgbox.com/ff/0a/E9FB3LgI_o.png">条边</span></p> 
<p><strong>有向图:</strong></p> 
<p><span style="color:#fe2c24;">        所有顶点的出度之和=入度之和=|E|</span></p> 
<p><span style="color:#fe2c24;">        所有顶点的度之和=2|E|</span></p> 
<p><span style="color:#fe2c24;">        若G是强连通图，则最少有 n 条边（形成回路）</span></p> 
<p><span style="color:#fe2c24;">        有向完全图共有<img alt="2C_{n}^{2}" class="mathcode" src="https://images2.imgbox.com/18/e3/ReLHVQoX_o.png">条边</span></p> 
<p style="margin-left:0;text-align:justify;"><strong>图的遍历：</strong>从图中某一顶点出发访问图中所有顶，并且每个结点仅被访问一次。</p> 
<ul><li style="text-align:justify;">深度优先遍历序列（dfs）</li><li style="text-align:justify;">广度优先遍历序列（bfs）</li></ul> 
<p>    <strong>备注: </strong> 调⽤BFS/DFS函数的次数 = 连通分量数</p> 
<h3 id="4.2%20%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%C2%A0"><strong>4.2 图的存储结构</strong> </h3> 
<p style="margin-left:0;text-align:justify;"><strong>邻接矩阵：</strong></p> 
<ul><li style="text-align:justify;"><strong>一维数组：</strong>存储图中顶点的信息</li><li style="text-align:justify;"><strong>二维数组（邻接矩阵）：</strong>存储图中各顶点之间的邻接关系</li></ul> 
<p style="margin-left:0;text-align:justify;"><strong>特点：</strong>一个图能唯一确定一个邻接矩阵，存储稀疏图时，浪费空间。空间复杂度为:<strong><em> </em></strong><em>O</em>(<img alt="n^{2}" class="mathcode" src="https://images2.imgbox.com/28/58/vw6Aaz72_o.png">)。</p> 
<p style="margin-left:0;text-align:justify;"><strong>示意图:</strong></p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="337" src="https://images2.imgbox.com/61/81/Ch72ui2A_o.png" width="1152"></p> 
<p><strong>性质 (行*列) :</strong></p> 
<p><img alt="" height="356" src="https://images2.imgbox.com/80/ac/XOCCjsro_o.png" width="1200"></p> 
<p><strong>邻接表：</strong></p> 
<ul><li style="text-align:justify;"><strong>顶点表：</strong>所有边表的头指针和存储顶点信息的一维数组</li><li style="text-align:justify;"><strong>边表（邻接表）：</strong>顶点 <em>v</em> 的所有邻接点链成的单链表</li></ul> 
<p><strong>示意图:</strong></p> 
<p><img alt="" height="326" src="https://images2.imgbox.com/5a/57/zWzWKPpI_o.png" width="893"></p> 
<p style="margin-left:0;text-align:justify;"><strong>特点：</strong>空间复杂度为：<em>O</em>（n+e）, 适合存储稀疏图。</p> 
<p style="margin-left:0;text-align:justify;"><strong>两者区别:</strong></p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="240" src="https://images2.imgbox.com/ec/bb/v72dedrW_o.png" width="968"></p> 
<p><strong>十字链表法图:</strong></p> 
<p><img alt="" height="615" src="https://images2.imgbox.com/36/fc/e5iJO0h8_o.png" width="1087"></p> 
<p><strong>备注: </strong></p> 
<p>        1) 十字链表只用于<strong>存储有向图</strong></p> 
<p>        2) 顺着<strong>绿色</strong>线路找: 找到指定顶点的所有出边</p> 
<p>        3) 顺着<strong>橙色</strong>线路找: 找到指定顶点的所有入边</p> 
<p>        4) <strong>空间复杂度：</strong>O(|V|+|E|)</p> 
<p><strong>邻接多重表图:</strong></p> 
<p><img alt="" height="573" src="https://images2.imgbox.com/12/29/IeZcpmWv_o.png" width="1030"></p> 
<p><strong>备注:</strong></p> 
<p>        1) 邻接多重表只适用于<strong>存储无向图</strong></p> 
<p style="margin-left:0;text-align:justify;">        2) <strong>空间复杂度：</strong>O(|V|+|E|)</p> 
<p style="margin-left:0;text-align:justify;"><strong>四者区别: </strong></p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="348" src="https://images2.imgbox.com/c8/af/1RSOannu_o.png" width="1092"></p> 
<h3 id="4.3%20%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91" style="margin-left:0px;text-align:justify;">4.3 最小生成树</h3> 
<p style="margin-left:0;text-align:justify;"><strong>        生成树：</strong>连通图的生成树是包含全部顶点的一个极小连通子图, 可用DFS和BFS生成。</p> 
<p style="margin-left:0;text-align:justify;"><strong>        生成树的代价：</strong>在无向连通网中，生成树上各边的权值之和</p> 
<p style="margin-left:0;text-align:justify;"><strong>        最小生成树：</strong>在无向连通网中，代价最小的生成树</p> 
<p style="margin-left:0;text-align:justify;">        <strong>性质: </strong>各边权值互不相等时, 最小生成树是唯一的。边数为顶点数-1</p> 
<p style="margin-left:0;text-align:justify;"><strong>生成森林示意图:</strong></p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="492" src="https://images2.imgbox.com/22/10/MLE3ytYa_o.png" width="1200"></p> 
<h4 id="4.3.1%C2%A0Prim%E7%AE%97%E6%B3%95" style="margin-left:0px;text-align:justify;">4.3.1 Prim算法</h4> 
<blockquote> 
 <p style="margin-left:0;text-align:justify;">        从某⼀个顶点开始构建⽣成树；每次将代价最⼩的新顶点纳⼊⽣成树，直到所有顶点都纳⼊为⽌。基于贪心算法的策略。</p> 
</blockquote> 
<p style="margin-left:0;text-align:justify;"><strong>        时间复杂度</strong>：O(|V|2) 适合⽤于边<span style="color:#fe2c24;">稠密图。</span></p> 
<h4 id="4.3.2%20Kruskal%20%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%EF%BC%89" style="margin-left:0px;text-align:justify;">4.3.2 Kruskal 算法（克鲁斯卡尔）</h4> 
<blockquote> 
 <p style="margin-left:0;text-align:justify;">        每次选择⼀条权值最⼩的边，使这条边的两头连通（原本已经连通的就不选）, 直到所有结点都连通。基于贪心算法的策略。</p> 
</blockquote> 
<p style="margin-left:0;text-align:justify;"><strong>        时间复杂度：</strong>O( |E|log2|E| ) 适合⽤于边<span style="color:#fe2c24;">稀疏图。</span></p> 
<h3 id="4.4%20%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84" style="margin-left:0px;text-align:justify;"><span style="color:#0d0016;">4.4 最短路径</span></h3> 
<p style="margin-left:0;text-align:justify;"><strong>        </strong>非带权图: 边数最少的路径（广度优先遍历）</p> 
<p style="margin-left:0;text-align:justify;"><strong>        </strong>带权图: 边上的权值之和最少的路径</p> 
<h4 style="margin-left:0px;text-align:justify;"><strong>4.4.1 Dijkstra算法</strong></h4> 
<p style="margin-left:0;text-align:justify;"><strong>        时间复杂度：</strong><em>O</em>(<em>n</em>2)</p> 
<p style="margin-left:0;text-align:justify;">      <strong>  备注:</strong> Dijkstra 算法不适⽤于有负权值的带权图</p> 
<h4 style="margin-left:0px;text-align:justify;"><strong>4.4.2 Floyd算法</strong></h4> 
<p style="margin-left:0;text-align:justify;"><strong>核心代码:</strong></p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="289" src="https://images2.imgbox.com/39/21/Kisi3uBf_o.png" width="683"> <strong>       时间复杂度：</strong><em>O(n3)</em></p> 
<p style="margin-left:0;text-align:justify;"><em>      </em><strong>  备注:</strong> 可以⽤于负权值带权图, 不能解决带有“负权回路”的图</p> 
<p style="margin-left:0;text-align:justify;"><strong>三者区别:</strong></p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="401" src="https://images2.imgbox.com/2f/4e/xQ8fhB4v_o.png" width="816"></p> 
<h3 id="4.5%20%E6%9C%89%E5%90%91%E2%BD%86%E7%8E%AF%E5%9B%BE%EF%BC%88DAG%EF%BC%89">4.5 有向⽆环图（DAG）</h3> 
<p><strong>描述表达式 (简化前) :</strong></p> 
<p><img alt="" height="452" src="https://images2.imgbox.com/b4/a2/C7RhhJvq_o.png" width="717"></p> 
<p><strong>描述表达式 (简化后) :</strong></p> 
<p><img alt="" height="440" src="https://images2.imgbox.com/42/09/Zr9wP9zG_o.png" width="736"></p> 
<h3 id="4.6%20%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F" style="background-color:transparent;">4.6 拓扑排序</h3> 
<blockquote> 
 <p>        AOV⽹(Activity On Vertex NetWork，⽤顶点表示活动的⽹)： ⽤DAG图（有向⽆环图）表示⼀个⼯程。顶点表示活动，有向边表示活动Vi必须先于活动Vj进⾏</p> 
</blockquote> 
<p><strong>如图:</strong></p> 
<p><img alt="" height="372" src="https://images2.imgbox.com/c0/a1/s7cwnXBu_o.png" width="657"></p> 
<p><strong>拓扑排序的实现：</strong></p> 
<p>        ① 从AOV⽹中选择⼀个没有前驱（⼊度为0）的顶点并输出。</p> 
<p>        ② 从⽹中删除该顶点和所有以它为起点的有向边。</p> 
<p>        ③ 重复①和②直到当前的AOV⽹为空或当前⽹中不存在⽆前驱的顶点为⽌。</p> 
<p><strong>逆拓扑排序（可用DFS算法实现）:</strong></p> 
<p>        ① 从AOV⽹中选择⼀个没有后继（出度为0）的顶点并输出。</p> 
<p>        ② 从⽹中删除该顶点和所有以它为终点的有向边。</p> 
<p>        ③ 重复①和②直到当前的AOV⽹为空</p> 
<h3 id="4.7%20%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84">4.7 关键路径</h3> 
<blockquote> 
 <p>        在带权有向图中，以<span style="color:#fe2c24;"><strong>顶点表示事件</strong></span>，以<span style="color:#fe2c24;"><strong>有向边表示活动</strong></span>，以边上的权值表示完成该活动的开销（如完成活动所需的时间），称之为⽤边表示活动的⽹络，简称<strong>AOE⽹</strong></p> 
</blockquote> 
<p><strong>示意图:</strong></p> 
<p class="img-center"><img alt="" height="269" src="https://images2.imgbox.com/39/67/q7r5VeNa_o.png" width="659"></p> 
<p>   <strong>     关键活动</strong>: 从源点到汇点的有向路径可能有多条，所有路径中，具有最⼤路径⻓度的路径称为 关键路径，⽽把关键路径上的活动称为关键活动。</p> 
<p>        <strong>事件vk的最早发⽣时间: </strong>决定了所有从vk开始的活动能够开⼯的最早时间。</p> 
<p>        <strong>活动ai的最早开始时间:</strong> 指该活动弧的起点所表⽰的事件的最早发⽣时间。</p> 
<p>        <strong>事件vk的最迟发⽣时间:</strong> 它是指在不推迟整个⼯程完成的前提下，该事件最迟必须发⽣的时间。</p> 
<p>        <strong>活动ai的最迟开始时间:</strong> 它是指该活动弧的终点所表示事件的最迟发⽣时间与该活动所需时间之差。</p> 
<p>        <strong>活动ai的时间余量：</strong>表⽰在不增加完成整个⼯程所需总时间的情况下，活动ai可以拖延的时间。d(k)=0的活动就是关键活动, 由关键活动可得关键路径。</p> 
<p><strong>示例图:</strong></p> 
<p><img alt="" height="494" src="https://images2.imgbox.com/d1/b4/3Fi0NUq2_o.png" width="1023"></p> 
<p></p> 
<h2 id="%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%9F%A5%E6%89%BE" style="margin-left:0px;text-align:center;"><strong>第五章 查找</strong></h2> 
<p style="margin-left:0;text-align:justify;"><strong>        静态查找 ：</strong>不涉及插入和删除操作的查找</p> 
<p style="margin-left:0;text-align:justify;"><strong>        动态查找 ：</strong>涉及插入和删除操作的查找</p> 
<p style="margin-left:0;text-align:justify;"><strong>        查找⻓度: </strong>在查找运算中，需要对⽐关键字的次数称为查找⻓度</p> 
<p style="margin-left:0;text-align:justify;"><strong>        平均查找长度：</strong>衡量查找算法的效率</p> 
<p style="margin-left:0;text-align:justify;"><strong>公式:</strong></p> 
<p class="img-center"><img alt="" height="322" src="https://images2.imgbox.com/b7/9a/V7GabWZU_o.png" width="401"></p> 
<h3 id="5.1%20%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%EF%BC%88%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE%EF%BC%89%EF%BC%9A" style="background-color:transparent;margin-left:0px;text-align:justify;"><strong>5.1 顺序查找（线性查找）：</strong></h3> 
<blockquote> 
 <p style="margin-left:0;text-align:justify;"><strong>        </strong>顺序查找适合于存储结构为顺序存储或链接存储的线性表。</p> 
</blockquote> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#ffffff;">　　<strong><span style="color:#000000;">基本思想：</span></strong><span style="color:#000000;">从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="color:#ff0000;">        时间复杂度: O(n)</span>。</strong></p> 
<p style="margin-left:0;text-align:justify;"><strong>有序顺序查找的ASL图:</strong></p> 
<p style="margin-left:0;text-align:justify;"><img alt="" height="485" src="https://images2.imgbox.com/5a/6f/a3JP45eM_o.png" width="912"></p> 
<p><strong>        无序查找失败时的平均查找长度:</strong>  n+1次 (带哨兵的情况)</p> 
<h3 id="5.%202%20%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%EF%BC%9A" style="margin-left:0px;text-align:justify;">5. 2 折半查找：</h3> 
<blockquote> 
 <p style="margin-left:0;text-align:justify;"><strong>        </strong>元素必须是有序的，如果是无序的则要先进行排序操作。</p> 
</blockquote> 
<p style="margin-left:0;text-align:justify;"><strong>        基本思想：</strong><span style="color:#000000;">用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表。</span></p> 
<p style="margin-left:0;text-align:justify;"><strong>        公式：</strong>mid=(low+high)/2, 即mid=low+1/2*(high-low);</p> 
<p style="margin-left:0;text-align:justify;">　　         1）相等，mid位置的元素即为所求</p> 
<p style="margin-left:0;text-align:justify;">　         　2）&gt;，low=mid+1;</p> 
<p style="margin-left:0;text-align:justify;">                3）&lt;，high=mid-1。</p> 
<p style="margin-left:0;text-align:justify;"><strong>        时间复杂度: </strong><span style="color:#ff0000;"><img alt="O(log_{2}^{n})" class="mathcode" src="https://images2.imgbox.com/2b/b0/RmbZik6W_o.png"></span></p> 
<p style="margin-left:0;text-align:justify;"><strong>        备注：</strong><span style="color:#000000;">对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，不建议使用。</span></p> 
<h3 id="5.3%C2%A0%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE" style="margin-left:0px;text-align:justify;">5.3 分块查找</h3> 
<blockquote> 
 <p style="margin-left:0;text-align:justify;">        分块查找，⼜称索引顺序查找。</p> 
</blockquote> 
<p style="margin-left:0;text-align:justify;"><strong>        基本思想：</strong>将查找表分为若干子块, 块内的元素可以无序, 块间的元素是有序的, 即前一个快的最大元素小于后一个块的最大元素。再建立索引表, 索引表中的每个元素含有各块的最大关键字和第一个元素的地址。索引表按关键字有序排列。</p> 
<p style="margin-left:0;text-align:justify;"><strong>示意图:</strong></p> 
<p class="img-center"><img alt="" height="485" src="https://images2.imgbox.com/3f/e7/K2tCXwF0_o.png" width="1029"></p> 
<p><strong>备注:</strong> </p> 
<p>        1) 设索引查找和块内查找的平均查找⻓度分别为LI、LS，则分块查找的<strong>平均查找⻓度</strong>为</p> 
<p style="text-align:center;"><strong>ASL=LI + LS</strong></p> 
<p><strong>       </strong> 2) 将长度为n的查找表均匀分为b块, 每块s个记录, 在等概率情况下, 若在块内和索引表中均采用顺序查找, 则<strong>平均查找长度为:</strong></p> 
<p><img alt="" height="134" src="https://images2.imgbox.com/37/46/EHPBABoD_o.png" width="1094"></p> 
<h3 id="5.4%C2%A0%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91">5.4 二叉排序树</h3> 
<blockquote> 
 <p>        又称二叉查找树（BST，Binary Search Tree）, 是具有如下性质的二叉树：左子树结点值 &lt; 根结点值 &lt; 右子树结点值</p> 
</blockquote> 
<p><strong>        二叉排序树的插入:  </strong>新插入的结点 一定是叶子。</p> 
<p><strong>二叉排序树的删除</strong></p> 
<p>        1) 情况一, 删除叶结点, 直接删除</p> 
<p>        2) 情况二, 待删除结点只有一颗子树, 让子树代替待删除结点</p> 
<p>        3) 情况三, 待删除结点有左, 右子树, 则令待删除的直接前驱(或直接后继(中序遍历))代替待删除结点。</p> 
<p><strong>示意图:</strong> (30为直接前驱, 60为直接后继)</p> 
<p class="img-center"><img alt="" height="494" src="https://images2.imgbox.com/df/ac/q24ZCija_o.png" width="605"></p> 
<p><strong>平均查找效率: </strong>主要取决于树的高度。</p> 
<p><strong>时间复杂度:<span style="color:#ff0000;"> <img alt="O(log_{2}^{n})" class="mathcode" src="https://images2.imgbox.com/4e/09/OKRGZmbO_o.png"></span></strong></p> 
<h3 id="5.5%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">5.5 平衡二叉树</h3> 
<blockquote> 
 <p>        简称平衡树（AVL树）, 树上任一结点的左子树和右子树的 高度之差不超过1。 结点的平衡因子=左子树高-右子树高。</p> 
</blockquote> 
<p><strong>平衡二叉树</strong><strong>的插:</strong></p> 
<p><strong> LL型:</strong></p> 
<p><img alt="" height="429" src="https://images2.imgbox.com/f2/89/RZW2TrXp_o.png" width="1091"></p> 
<p><strong>RR型:</strong></p> 
<p><img alt="" height="432" src="https://images2.imgbox.com/1f/0f/n2ouZXwA_o.png" width="969"></p> 
<p><strong>RL型:</strong></p> 
<p><img alt="" height="436" src="https://images2.imgbox.com/c7/bd/ERptEpzG_o.png" width="1080"></p> 
<p><img alt="" height="445" src="https://images2.imgbox.com/b8/7e/eR9tVThb_o.png" width="1079"></p> 
<p><strong>LR型:</strong></p> 
<p><img alt="" height="446" src="https://images2.imgbox.com/4f/5b/VwwKAS2H_o.png" width="1092"></p> 
<p><strong>        平衡二叉树的删除: 同上</strong></p> 
<p><strong>考点:</strong></p> 
<p>        假设以<img alt="n_{h}" class="mathcode" src="https://images2.imgbox.com/3d/d4/VFTBB9Kz_o.png">表示<strong>深度为h</strong>的平衡树中含有的<span style="color:#fe2c24;"><strong>最少结点数</strong></span>。 则有<img alt="n_{0}" class="mathcode" src="https://images2.imgbox.com/63/00/EtFbf5N3_o.png"> = 0, <img alt="n_{1}" class="mathcode" src="https://images2.imgbox.com/11/09/glrkNKBt_o.png"> = 1, <img alt="n_{2}" class="mathcode" src="https://images2.imgbox.com/4b/3e/YwWl0GnP_o.png"> = 2，并且有<img alt="n_{h}" class="mathcode" src="https://images2.imgbox.com/75/46/cSc5gtrO_o.png">= <img alt="n_{h-1}" class="mathcode" src="https://images2.imgbox.com/6a/88/EScLSTyX_o.png"> + <img alt="n_{h-2}+1" class="mathcode" src="https://images2.imgbox.com/80/bd/7frTy1re_o.png"> </p> 
<p>        <strong>时间复杂度: <span style="color:#ff0000;"><img alt="O(log_{2}^{n})" class="mathcode" src="https://images2.imgbox.com/af/76/AlLD0U9C_o.png"></span></strong></p> 
<h3 id="5.6%C2%A0%E7%BA%A2%E9%BB%91%E6%A0%91" style="background-color:transparent;">5.6 红黑树</h3> 
<blockquote> 
 <p>        与AVL树相比, 插入/删除 很多时候不会破坏“红黑”特性，无需频繁调整树的形态。因为AVL是高度差严格要求不超过1, 红黑树高度差不超过2倍, 较为宽泛。</p> 
</blockquote> 
<p><strong>定义:</strong></p> 
<p>        ①每个结点或是红色，或是黑色的</p> 
<p>        ②根节点是黑色的</p> 
<p>        ③叶结点（外部结点、NULL结点、失败结点）均是黑色的</p> 
<p>        ④不存在两个相邻的红结点（即红结点的父节点和孩子结点均是黑色）</p> 
<p>        ⑤对每个结点，从该节点到任一叶结点的简单路径上，所含黑结点的数目相同</p> 
<p>        <strong>口诀: </strong>左根右，根叶黑 不红红，黑路同</p> 
<p><strong>示例图:</strong></p> 
<p class="img-center"><img alt="" height="354" src="https://images2.imgbox.com/7c/a5/S1ZWBVVl_o.png" width="733"></p> 
<p><strong>性质:</strong></p> 
<p>        <strong>性质1：</strong>从根节点到叶结点的最长路径不大于最短路径的2倍 (红结点只能穿插 在各个黑结点中间)</p> 
<p>       <strong> 性质2</strong>：有n个内部节点的红黑树高度  <img alt="h\leq 2log_{2}^{n+1}" class="mathcode" src="https://images2.imgbox.com/6c/b4/gtFo5imP_o.png"></p> 
<p>        <strong>结论: </strong>若根节点黑高为h，内部结点数（关键字）最多有 <img alt="2^{2h}-1" class="mathcode" src="https://images2.imgbox.com/30/6f/4LcW12ur_o.png">, 最少有<img alt="2^{h}-1" class="mathcode" src="https://images2.imgbox.com/78/3d/9M7RYSMV_o.png"></p> 
<p><strong>示例图:</strong></p> 
<p><img alt="" height="365" src="https://images2.imgbox.com/17/4c/rtnnwK9d_o.png" width="719"></p> 
<p><img alt="" height="370" src="https://images2.imgbox.com/2b/06/qFajqOAk_o.png" width="744"></p> 
<p><strong>红黑树的插入操作:</strong></p> 
<p><img alt="" height="461" src="https://images2.imgbox.com/f3/07/H8W392HX_o.png" width="1023"></p> 
<p><strong>红黑树的插入示例图:</strong></p> 
<p><img alt="" height="527" src="https://images2.imgbox.com/04/e6/l3V3q81g_o.png" width="1148"></p> 
<p><img alt="" height="569" src="https://images2.imgbox.com/2d/5f/MU0MVEOt_o.png" width="1191"></p> 
<p><img alt="" height="499" src="https://images2.imgbox.com/89/dc/tRysKoaW_o.png" width="1189"></p> 
<p><img alt="" height="575" src="https://images2.imgbox.com/37/d9/h1KvhK6C_o.png" width="1193"></p> 
<p><img alt="" height="576" src="https://images2.imgbox.com/ed/d4/MWeNRwqk_o.png" width="1174"></p> 
<p><img alt="" height="568" src="https://images2.imgbox.com/65/43/Of8l6dd2_o.png" width="1162"></p> 
<p><img alt="" height="567" src="https://images2.imgbox.com/b4/77/uwTjIYcE_o.png" width="1176"></p> 
<p><img alt="" height="583" src="https://images2.imgbox.com/b3/c6/8Byt5X5J_o.png" width="1173"><img alt="" height="578" src="https://images2.imgbox.com/46/e4/8I8WChWG_o.png" width="1164"></p> 
<p><img alt="" height="585" src="https://images2.imgbox.com/65/aa/REGed0pw_o.png" width="1123"></p> 
<p><img alt="" height="574" src="https://images2.imgbox.com/dc/e6/5Pe97sbE_o.png" width="1159"></p> 
<p> <img alt="" height="570" src="https://images2.imgbox.com/c8/4f/JdxkFJOO_o.png" width="1077"></p> 
<p><img alt="" height="578" src="https://images2.imgbox.com/bc/5b/FDTGcrp5_o.png" width="1105"></p> 
<p><img alt="" height="570" src="https://images2.imgbox.com/de/9c/RMliD5S7_o.png" width="1089"></p> 
<p><img alt="" height="574" src="https://images2.imgbox.com/8d/38/bzXt9cIS_o.png" width="1136"></p> 
<p><img alt="" height="574" src="https://images2.imgbox.com/25/34/leuHVvjw_o.png" width="1115"></p> 
<p> <strong>       红黑树的删除: </strong>和“二叉排序树的删除”一样! 具体还是算了吧, 放过自己。。。</p> 
<p>        <strong>时间复杂度: <span style="color:#ff0000;"><img alt="O(log_{2}^{n})" class="mathcode" src="https://images2.imgbox.com/48/05/8CzwSL6I_o.png"></span></strong></p> 
<h3 id="5.7%20B%E6%A0%91" style="background-color:transparent;">5.7 B树</h3> 
<blockquote> 
 <p>        B树，⼜称多路平衡查找树，B树中所被允许的孩⼦个数的最⼤值称为B树的阶，通常⽤m表示。</p> 
</blockquote> 
<p><strong> m阶B树的特性:</strong></p> 
<p>        1）树中每个结点⾄多有m棵⼦树，即⾄多含有m-1个关键字。</p> 
<p>        2）若根结点不是终端结点，则⾄少有两棵⼦树。</p> 
<p>        3）除根结点外的所有⾮叶结点⾄少有<img alt="\left \lceil m/2 \right \rceil" class="mathcode" src="https://images2.imgbox.com/ad/e2/UTw0t5qJ_o.png"> 棵⼦树，即⾄少含有<img alt="\left \lceil m/2 \right \rceil-1" class="mathcode" src="https://images2.imgbox.com/a9/95/uTpdYqP2_o.png">个关键字。 </p> 
<p>        4) 所有的叶结点都出现在同⼀层次上，并且不带信息, ( 指向这些结点的指针为空 ) 。</p> 
<p>        5) 最小高度: <img alt="log_{m}^{n+1}\leqslant h" class="mathcode" src="https://images2.imgbox.com/6e/29/zxsooIQE_o.png">   (n为关键字)</p> 
<p>        6) 最大高度: <img alt="h\leqslant log_{\left \lceil m/2 \right \rceil}^{\frac{n+1}{2}}+1" class="mathcode" src="https://images2.imgbox.com/ac/43/7cOmvPwA_o.png"></p> 
<p>        7) 所有⼦树⾼度要相同</p> 
<p><strong>示例图: </strong></p> 
<p><img alt="" height="325" src="https://images2.imgbox.com/1c/75/n7j4gNyN_o.png" width="1068"></p> 
<p>B树的插入(5阶为例):</p> 
<p class="img-center"><img alt="" height="128" src="https://images2.imgbox.com/a1/8e/BYj8OyS7_o.png" width="349"></p> 
<p class="img-center"><img alt="" height="271" src="https://images2.imgbox.com/20/e6/3AMSQEz7_o.png" width="520"></p> 
<p></p> 
<p class="img-center"><img alt="" height="225" src="https://images2.imgbox.com/a0/00/9xN8EvWN_o.png" width="519"></p> 
<p><img alt="" height="260" src="https://images2.imgbox.com/e2/0b/Dt2zuLrw_o.png" width="737"><img alt="" height="236" src="https://images2.imgbox.com/91/c6/ge8Dr5cZ_o.png" width="822"></p> 
<p><img alt="" height="246" src="https://images2.imgbox.com/26/ea/p9M0ywyO_o.png" width="880"><img alt="" height="248" src="https://images2.imgbox.com/fc/de/BS0lGH1z_o.png" width="985"></p> 
<p><img alt="" height="269" src="https://images2.imgbox.com/7a/50/COHv2D4z_o.png" width="1059"><img alt="" height="367" src="https://images2.imgbox.com/5e/5d/gzDB86Ft_o.png" width="1066"></p> 
<p><strong>B树的删除:</strong></p> 
<p>        1) 若被删除关键字在终端节点，则直接删除该关键字 （要注意节点关键字个数是否低于下限 ⌈m/2⌉ − 1）</p> 
<p></p> 
<p><img alt="" height="353" src="https://images2.imgbox.com/c1/ce/YWmksGyH_o.png" width="1058"></p> 
<p><img alt="" height="367" src="https://images2.imgbox.com/d3/e5/7vlbyIIs_o.png" width="1060"></p> 
<p>        2) 若被删除关键字在⾮终端节点，则⽤<strong>直接前驱</strong>或<strong>直接后继</strong>来替代被删除的关键字</p> 
<p><img alt="" height="362" src="https://images2.imgbox.com/38/0e/70RvzlAM_o.png" width="1061"></p> 
<p><strong> 删除77:</strong></p> 
<p><img alt="" height="346" src="https://images2.imgbox.com/41/5f/bvXr5S14_o.png" width="1067"></p> 
<p><img alt="" height="354" src="https://images2.imgbox.com/c5/2a/RUL8FkTv_o.png" width="1060"></p> 
<p><strong>删除38:</strong><img alt="" height="340" src="https://images2.imgbox.com/b3/58/mnuOf3vl_o.png" width="1056"></p> 
<p><img alt="" height="354" src="https://images2.imgbox.com/9d/70/srtg6EkH_o.png" width="1060"></p> 
<p><img alt="" height="363" src="https://images2.imgbox.com/6f/03/MXFRciEX_o.png" width="1070"><img alt="" height="374" src="https://images2.imgbox.com/f3/43/iaQKb3J6_o.png" width="1059"></p> 
<p><strong>删除90:</strong></p> 
<p><img alt="" height="363" src="https://images2.imgbox.com/d4/0e/Mzb5z6hl_o.png" width="1059"></p> 
<p><img alt="" height="359" src="https://images2.imgbox.com/d5/2e/6ojHUJ2G_o.png" width="1058"><img alt="" height="369" src="https://images2.imgbox.com/1f/52/8nSX32g8_o.png" width="1060"></p> 
<p><img alt="" height="361" src="https://images2.imgbox.com/38/82/CRlpBpyM_o.png" width="1059"></p> 
<p><img alt="" height="369" src="https://images2.imgbox.com/0f/c3/54pDtxaa_o.png" width="1060"></p> 
<p>        3) 若被删除关键字所在结点删除前的关键字个数低于下限，且此时与该结点相邻的左、右兄弟结 点的关键字个数均=⌈m/2⌉ − 1，则将关键字删除后与左（或右）兄弟结点及双亲结点中的关键字进⾏<strong>合并</strong> </p> 
<p><strong>删除49:</strong></p> 
<p><img alt="" height="372" src="https://images2.imgbox.com/2b/49/W6Hx79nd_o.png" width="1060"></p> 
<p><img alt="" height="348" src="https://images2.imgbox.com/53/7b/Pb3ZPBCm_o.png" width="1061"></p> 
<p> <img alt="" height="366" src="https://images2.imgbox.com/1a/79/CrZysrA6_o.png" width="1056"></p> 
<p><img alt="" height="366" src="https://images2.imgbox.com/da/4e/nzwWjW6i_o.png" width="1059"></p> 
<p><img alt="" height="365" src="https://images2.imgbox.com/0e/57/EoBrxerj_o.png" width="1056"></p> 
<p><img alt="" height="245" src="https://images2.imgbox.com/cb/3f/vxUl1Cnb_o.png" width="1065"></p> 
<h3 id="5.8%20B%2B%E6%A0%91" style="background-color:transparent;">5.8 B+树</h3> 
<p><strong>⼀棵m阶的B+树需满⾜下列条件</strong></p> 
<p>        1）每个分⽀结点最多有m棵⼦树（孩⼦结点）。</p> 
<p>        2）⾮叶根结点⾄少有两棵⼦树，其他每个分⽀结点⾄少有 ⌈m/2⌉ 棵⼦树。</p> 
<p>        3）结点的⼦树个数与关键字个数相等。</p> 
<p>        4）所有<strong>叶结点包含全部关键字及指向相应记录的指针</strong>，叶结点中将关键字按⼤⼩顺序排列，并且相邻叶结点按⼤⼩顺序相互链接起来</p> 
<p>        5）所有分⽀结点中仅包含它的各个⼦结点中关键字的最⼤值及指向其⼦结点的指针。所有<strong>⾮叶结点仅起索引作⽤</strong>，</p> 
<p>        6) 所有⼦树⾼度要相同</p> 
<p><strong>B+树示例图:</strong></p> 
<p><img alt="" height="399" src="https://images2.imgbox.com/ca/6f/8vaodUZ8_o.png" width="1083"></p> 
<p><strong>B+树与B树的对比图:</strong></p> 
<p><img alt="" height="436" src="https://images2.imgbox.com/06/c9/HcPpIVEq_o.png" width="885"></p> 
<h3 id="5.9%C2%A0%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%88Hash%EF%BC%89" style="background-color:transparent;">5.9 <strong><strong><span style="color:#000000;">哈希表（Hash）</span></strong></strong></h3> 
<blockquote> 
 <p>        根据数据元素的关键字 计算出它在散列表中的存储地址。</p> 
</blockquote> 
<p>        <strong>哈希函数：</strong> 建⽴了“关键字”→“存储地址”的映射关系。</p> 
<p>        <strong>冲突（碰撞）：</strong>在散列表中插⼊⼀个数据元素时，需要根据关键字的值确定其存储地址，若 该地址已经存储了其他元素，则称这种情况为“冲突（碰撞）”</p> 
<p><strong>        同义词：</strong>若不同的关键字通过散列函数映射到同⼀个存储地址，则称它们为“同义词”</p> 
<p><strong>        复杂度分析</strong>：对于无冲突的Hash表而言，<span style="color:#ff0000;">查找复杂度为O(1)</span> </p> 
<h4 id="5.9.1%C2%A0%E6%9E%84%E9%80%A0%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0">5.9.1 构造哈希函数</h4> 
<p>        1) 除留余数法 —— H(key) = key % p, 取⼀个不⼤于m但最接近或等于m的质数p</p> 
<p>     <strong>   适⽤场景：</strong>较为通⽤，只要关键字是整数即可</p> 
<p>        2) 直接定址法 —— H(key) = key 或 H(key) = a*key + b</p> 
<p>       <strong> 适⽤场景：</strong>关键字分布基本连续</p> 
<p>        3) 数字分析法 —— 选取数码分布较为均匀的若⼲位作为散列地</p> 
<p>     <strong>   适⽤场景：</strong>关键字集合已知，且关键字的某⼏个数码位分布均匀</p> 
<p>        4) 平⽅取中法——取关键字的平⽅值的中间⼏位作为散列地址</p> 
<p>        <strong>适⽤场景：</strong>关键字的每位取值都不够均匀。</p> 
<h4 id="5.9.2%20%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81">5.9.2 处理冲突</h4> 
<p><strong>拉链法示意图:</strong></p> 
<p><img alt="" height="341" src="https://images2.imgbox.com/46/15/Vi2YO8AO_o.png" width="798"></p> 
<p><strong>开放定址法:</strong></p> 
<p>        1) 线性探测法</p> 
<p>        2) 平⽅探测法</p> 
<p>        3) 双散列法</p> 
<p>        4) 伪随机序列法</p> 
<p><strong>示意图:</strong></p> 
<p><img alt="" height="247" src="https://images2.imgbox.com/bd/70/n5GwIVtE_o.png" width="804"></p> 
<p><strong>        删除操作: </strong>采用<strong>开放定址</strong>法时, 只能<strong>逻辑删除。</strong></p> 
<p><strong>        装填因子: </strong>表中记录数 <strong>/</strong> 散列表长度 。</p> 
<p>      <strong>  备注:</strong> 平均查找长度的查找失败包含不放元素的情况。(特殊: 根据散列函数来算: 2010真题)</p> 
<p>       <strong> 聚集: </strong>处理冲突的方法选取不当,而导致不同关键字的元素对同一散列地址进行争夺的现象</p> 
<h2 id="%E7%AC%AC%E5%85%AD%E7%AB%A0%C2%A0%E6%8E%92%E5%BA%8F" style="text-align:center;"><strong>第六章 排序</strong></h2> 
<p><strong>        稳定</strong> ：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</p> 
<p><strong>        内排序</strong> ：所有排序操作都在内存中完成；</p> 
<p><strong>        外排序</strong> ：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行。</p> 
<p style="margin-left:0;text-align:justify;"><strong>参考博客：</strong></p> 
<p style="margin-left:0;text-align:justify;"><a href="https://blog.csdn.net/weixin_41190227/article/details/86600821?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164291828016780264074429%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164291828016780264074429&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-86600821.pc_search_insert_es_download&amp;utm_term=%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95&amp;spm=1018.2226.3001.4187" title="超详细十大经典排序算法总结（java代码）c或者cpp的也可以明白_Top_Spirit的博客-CSDN博客">超详细十大经典排序算法总结（java代码）c或者cpp的也可以明白_Top_Spirit的博客-CSDN博客</a></p> 
<h3 id="6.1%20%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">6.1 直接插入排序</h3> 
<p style="margin-left:0;text-align:justify;"><strong>动图演示</strong>：</p> 
<p class="img-center"><img alt="" height="311" src="https://images2.imgbox.com/7c/80/GHuIp5tf_o.gif" width="500"></p> 
<p>         <strong>优化: </strong>折半插入排序</p> 
<h3 id="6.2%20%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">6.2 希尔排序</h3> 
<blockquote> 
 <p>        又称<strong>缩小增量排序</strong>, 先将待排序表分割成若⼲形如 L[i, i + d, i + 2d,…, i + kd] 的“特殊”⼦表，对各个⼦表分别进⾏直接插⼊排序。缩⼩增量d，重复上述过程，直到d=1为⽌。建议每次将增量缩⼩⼀半。</p> 
</blockquote> 
<p><strong>示例图:</strong></p> 
<p class="img-center"><img alt="" height="603" src="https://images2.imgbox.com/ad/45/Ez0nBWSG_o.png" width="578"></p> 
<h3 id="6.3%C2%A0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">6.3 冒泡排序</h3> 
<p><strong>动图演示:</strong></p> 
<p><img alt="" height="257" src="https://images2.imgbox.com/af/23/KWccOLYE_o.gif" width="826"></p> 
<h3 id="6.4%C2%A0%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">6.4 快速排序</h3> 
<blockquote> 
 <p><strong>算法思想：</strong></p> 
 <p><strong>        1) </strong>在待排序表L[1…n]中任取⼀个元素pivot作为<strong>枢轴</strong>（或<strong>基准</strong>）</p> 
 <p>        2) 通过⼀趟排序将待排序表<strong>划分为独⽴的两部分</strong>L[1…k-1]和L[k+1…n]，使得L[1…k-1]中的所有元素⼩于pivot，L[k+1…n]中的所有元素⼤于等于 pivot，则pivot放在了其最终位置L(k)上，这个过程称为⼀次“划分”。</p> 
 <p>        3) 然后分别递归地对两个⼦表重复上述过程，直每部分内只有⼀个元素或空为⽌，即所有元素放在了其最终位置上。</p> 
</blockquote> 
<p><strong>示例图:</strong></p> 
<p><img alt="" height="276" src="https://images2.imgbox.com/3e/fc/fZ46tIrJ_o.png" width="679"></p> 
<p><img alt="" height="281" src="https://images2.imgbox.com/07/36/G32T2elF_o.png" width="662"></p> 
<p><img alt="" height="296" src="https://images2.imgbox.com/3c/98/Ews1mti6_o.png" width="669"></p> 
<p> <img alt="" height="295" src="https://images2.imgbox.com/c9/6e/puF2LpWi_o.png" width="645"></p> 
<p><img alt="" height="305" src="https://images2.imgbox.com/fb/86/lMhNW2OS_o.png" width="645"></p> 
<p><img alt="" height="326" src="https://images2.imgbox.com/d8/2f/mfXOW7zn_o.png" width="646"></p> 
<p><img alt="" height="267" src="https://images2.imgbox.com/65/15/DK7tKPBo_o.png" width="667"></p> 
<p><img alt="" height="302" src="https://images2.imgbox.com/6b/58/3bCSQajA_o.png" width="655"></p> 
<p> <img alt="" height="287" src="https://images2.imgbox.com/98/42/i0JRtwDs_o.png" width="655"></p> 
<p><img alt="" height="294" src="https://images2.imgbox.com/5e/a9/CsYSYa8O_o.png" width="643"></p> 
<p><img alt="" height="287" src="https://images2.imgbox.com/76/5c/XGXM2FAO_o.png" width="658"></p> 
<p><img alt="" height="266" src="https://images2.imgbox.com/09/d2/fSqJKk9e_o.png" width="637"></p> 
<h3 id="6.5%C2%A0%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">6.5 简单选择排序</h3> 
<p><strong>        算法思想: </strong>每⼀趟在待排序元素中选取关键字最⼩的元素加⼊有序⼦序列。</p> 
<p><strong>动画演示:</strong></p> 
<p><img alt="" height="248" src="https://images2.imgbox.com/c5/3d/vQVO1R1w_o.gif" width="811"></p> 
<h3 id="6.6%C2%A0%E5%A0%86%E6%8E%92%E5%BA%8F" style="background-color:transparent;">6.6 堆排序</h3> 
<p>        <strong>⼤根堆: </strong>若满⾜：L(i)≥L(2i)且L(i)≥L(2i+1) （1 ≤ i ≤n/2 ）</p> 
<p>     <strong>   ⼩根堆:</strong> 若满⾜：L(i)≤L(2i)且L(i)≤L(2i+1) （1 ≤ i ≤n/2 ）</p> 
<p><strong>大根堆示例图:</strong></p> 
<p><img alt="" height="378" src="https://images2.imgbox.com/43/64/3bVDu7gB_o.png" width="1050"></p> 
<h4 id="6.6.1%C2%A0%E5%BB%BA%E7%AB%8B%E5%A4%A7%E6%A0%B9%E5%A0%86">6.6.1 建立大根堆</h4> 
<p>       <strong> 思路：</strong>从<img alt="\left \lfloor len/2 \right \rfloor" class="mathcode" src="https://images2.imgbox.com/cb/6b/wV4shtSH_o.png">开始,<strong> </strong>把所有⾮终端结点都检查⼀遍，是否满足大根堆的要求，如果不满⾜，则进⾏调整。若元素互换破坏了下⼀级的堆，则采⽤相同的方法继续往下调整（⼩元素不断“下坠”）</p> 
<p><strong>小元素下坠示例图: </strong></p> 
<p><img alt="" height="366" src="https://images2.imgbox.com/db/4e/8lcISI9q_o.png" width="637"></p> 
<p><img alt="" height="367" src="https://images2.imgbox.com/8d/a0/b3nVJtFN_o.png" width="602"></p> 
<p> <img alt="" height="393" src="https://images2.imgbox.com/d4/21/9fR8ZQX5_o.png" width="655"></p> 
<p>      <strong>  结论: </strong>建堆的过程，关键字对⽐次数不超过4n，建堆时间复杂度=O(n)</p> 
<h4 id="6.6.2%C2%A0%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4">6.6.2 堆的插入与删除</h4> 
<p><strong>        插入: </strong>将新增元素放到表尾, 而后根据大小根堆进行上升调整。</p> 
<p><strong>        删除: </strong>被删除的元素⽤堆底元素替代，然后让该 元素不断“下坠”，直到⽆法下坠为⽌</p> 
<p><strong>排序动图演示:</strong></p> 
<p class="img-center"><img alt="" height="364" src="https://images2.imgbox.com/98/94/1y6McO8z_o.gif" width="547"></p> 
<h3 id="6.7%C2%A0%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" style="background-color:transparent;">6.7 归并排序</h3> 
<blockquote> 
 <p>        该算法是采用分治法, 把两个或多个已经有序的序列合并成⼀个。</p> 
</blockquote> 
<p><strong>2路归并图:</strong></p> 
<p class="img-center"><img alt="" height="439" src="https://images2.imgbox.com/23/ff/oPPCk6gK_o.png" width="568"></p> 
<p><strong>        结论：</strong>n个元素进⾏2路归并排序，归并趟数(高度) = ⌈log2n⌉ </p> 
<h3 id="6.8%C2%A0%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F" style="background-color:transparent;">6.8 基数排序</h3> 
<p><strong>        基数排序</strong>是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；</p> 
<p><strong>动图演示:</strong> </p> 
<p><img alt="" height="574" src="https://images2.imgbox.com/d7/0b/z3LgMgCR_o.gif" width="1012"></p> 
<p>      <strong>  时间复杂度: </strong>⼀趟分配O(n)，⼀趟收集O(r)，总共 d 趟分配、收集，总的时间复杂度=O(d(n+r)） , 其中把d为关键字拆 为d个部分, r为每个部分可能 取得 r 个值。</p> 
<p><strong>基数排序适用场景:</strong></p> 
<p>        ①数据元素的关键字可以⽅便地拆分为 d 组，且 d 较⼩</p> 
<p>        ②每组关键字的取值范围不⼤，即 r 较⼩</p> 
<p>        ③数据元素个数 n 较⼤</p> 
<p><strong>如:</strong></p> 
<p><img alt="" height="506" src="https://images2.imgbox.com/de/f2/4KG0zdBS_o.png" width="1084"></p> 
<p><strong>内部排序总结:</strong></p> 
<p><img alt="image" src="https://images2.imgbox.com/f7/25/rt2rypT5_o.png"></p> 
<h3 id="6.9%C2%A0%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F">6.9 外部排序</h3> 
<blockquote> 
 <p>        数据元素太多，⽆法⼀次全部读⼊内存进⾏排序, 读写磁盘的频率成为衡量外部排序算法的主要因素。</p> 
</blockquote> 
<p><strong>示例图:</strong></p> 
<p><img alt="" height="436" src="https://images2.imgbox.com/14/08/yYcMzybj_o.png" width="999"></p> 
<p><img alt="" height="425" src="https://images2.imgbox.com/c9/53/8qkur8Et_o.png" width="998"></p> 
<p><strong>        结论: </strong>采⽤多路归并可以减少归并趟数，从⽽减少磁盘I/O(读写)次数。对 r 个初始归并段，做k路归并，则归并树可⽤ k 叉树表示 若树⾼为h，则归并趟数 = h-1 = <img alt="\left \lceil log_{k}^{r} \right \rceil" class="mathcode" src="https://images2.imgbox.com/12/a5/2pTVZeYt_o.png">。K越大, r越小, 读写磁盘次数越少。</p> 
<h4 id="6.9.1%C2%A0%E8%B4%A5%E8%80%85%E6%A0%91" style="background-color:transparent;">6.9.1 败者树</h4> 
<blockquote> 
 <p>        使⽤k路平衡归并策略，选出⼀个最小元素需要对⽐关键字 （k-1）次，导致内部归并所需时间增加。因此引入败者树。</p> 
</blockquote> 
<p><strong>示例图:</strong></p> 
<p><img alt="" height="476" src="https://images2.imgbox.com/99/b6/Jgay64AP_o.png" width="994"></p> 
<p>        <strong>结论: </strong>对于 k 路归并，第⼀次构造败者 树需要对⽐关键字 k-1 次 , 有了败者树，选出最⼩元素，只需对⽐关键字<img alt="\left \lceil log_{2}^{k} \right \rceil" class="mathcode" src="https://images2.imgbox.com/02/91/cT48K6Ch_o.png">次</p> 
<h4 id="6.9.2%C2%A0%E7%BD%AE%E6%8D%A2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">6.9.2 置换-选择排序</h4> 
<blockquote> 
 <p>        使用置换-选择排序可以减少初始化归并段。</p> 
</blockquote> 
<p><strong>示意图:</strong></p> 
<p><img alt="" height="406" src="https://images2.imgbox.com/84/a6/hkLCUC5H_o.png" width="942"></p> 
<p><img alt="" height="420" src="https://images2.imgbox.com/b4/0a/amL1hTcd_o.png" width="931"><img alt="" height="408" src="https://images2.imgbox.com/72/eb/44TEE3UU_o.png" width="986"></p> 
<p><img alt="" height="421" src="https://images2.imgbox.com/97/75/FwaKH7i3_o.png" width="982"></p> 
<p><img alt="" height="428" src="https://images2.imgbox.com/e9/81/5hd9kfX4_o.png" width="986"></p> 
<p><img alt="" height="437" src="https://images2.imgbox.com/42/d7/eQ6VVA0v_o.png" width="990"> <img alt="" height="415" src="https://images2.imgbox.com/9b/07/eq4IWLD1_o.png" width="975"></p> 
<p><img alt="" height="422" src="https://images2.imgbox.com/e4/97/78m5C7zm_o.png" width="983"></p> 
<p><img alt="" height="424" src="https://images2.imgbox.com/85/79/6VdySX8s_o.png" width="992"></p> 
<p><img alt="" height="418" src="https://images2.imgbox.com/94/52/EtPr84L5_o.png" width="978"></p> 
<h4 id="6.9.3%C2%A0%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91">6.9.3 最佳归并树</h4> 
<p><strong>原理图:</strong></p> 
<p><img alt="" height="491" src="https://images2.imgbox.com/af/9b/nri3QOBq_o.png" width="945"></p> 
<p>      <strong>  注意：</strong>对于k叉归并，若初始归并段的数量⽆法构成严格的 k 叉归并树， 则需要补充⼏个⻓度为 0 的“虚段”，再进⾏ k 叉哈夫曼树的构造。</p> 
<p><strong>示例图:</strong></p> 
<p><img alt="" height="464" src="https://images2.imgbox.com/82/0c/VZj9FEle_o.png" width="994"></p> 
<hr> 
<p><strong>结束!  !  !</strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#fe2c24;"><strong>注: 以上部分图片素材来自王道数据结构</strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e0ce548ad060974ed6dcea928660d2bf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">王道操作系统大题汇总（纯手写版，思路过程详细）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9679ce14c01793dbad63eb7fe97443cc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C语言】结构体&#43;位段&#43;枚举&#43;联合(2)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>