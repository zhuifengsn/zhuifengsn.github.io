<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C#高级--设计模式（七个原则） - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C#高级--设计模式（七个原则）" />
<meta property="og:description" content="一、单一职责原则 原理：
单一职责原则即：对于一个类而言，应该仅有一个引起他变化的原因。换言之，一个类只负责一个功能领域中的相应职责。
单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则，其难点和重点在于发现职责，并把这些职责相互分离，即区分职责的粒度问题。
总而言之，就是一个类中，只负责一件事，只有一个引起变更的原因。
单一职责的好处是：
好处一：提高代码的可读性，提高系统的可维护性
好处二：降低类的复杂度，一个模块只负责一个职责，提高系统的可拓展性和可维护性。
好处三：降低变更引起的风险。变更是必然的。如果单一职责做的更好，当修改一个功能的时候可以显著降低对另一个功能的影响。
二、开放封闭原则 原理：
1、对扩展开放，对修改关闭。其目的即：提高代码可复用性和可维护性。 尽量少地去改动已有的模块，尤其是底层模块。
2、在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级，可以通过使用接口和抽象类达到这样的效果。
其精神所在即：面向需求，对程序的改动是通过添加新代码进行的而不是更改现有代码。 不更改抽象层而可修改系统实现层。
三、里氏替换原则 原理：
1、任何基类可以出现的地方，子类一定可以出现，即：子类型必须能够替换掉其父类型。
2、LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。
3、LSP是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范
四、依赖倒置原则 原理：
1.高层模块不应该依赖于低层模块，两者都应以来抽象；
2.抽象不应该依赖于细节，细节应该依赖与抽象。
简单的说就是要求对抽象进行编程，不要对实现进行编程，这里的抽象即抽象类和接口。
依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，互不影响，
实现模块间的松耦合。 关于依赖
1、⼀一个优秀的⾯面向对象程序设计，核⼼心的原则之⼀一就是将变化「隔离」/「封装」，
使得变化部分发⽣生变化时，其他部分，不不受影响。
2、为了了实现这个⽬目的，需要使⽤用⾯面向接⼝口编程，使⽤用后，客户类，不不再直接依赖服务类，
⽽而是依赖⼀一个抽象的接⼝口，这样，客户类就不不能在内部直接实例例化服务类。
3、但是客户类在运⾏行行的过程中，⼜又需要具体的服务类来提供服务，因为接⼝口是不不能实例例化的，
就产⽣生了了⼀一个⽭矛盾：客户类不不允许实例例化服务类，但是客户类⼜又需要服务类的服务。
4、为了了解决这个⽭矛盾，我们设计了了⼀一种解决⽅方案，既：客户类定义⼀一个注⼊入点，⽤用于服务类的注⼊入，
⽽而客户类的客户类（Program类）负责根据情况，实例例化服务类，注⼊入到客户类中，从⽽而解决了了这个⽭矛盾。
依赖倒置代码案例如下所示：
namespace Program_依赖倒置原则 { internal class Program { static void Main(string[] args) { //歌手歌唱不同国家的歌曲 Singer singer = new Singer(); singer.SingSongChinese(new ChinenseSong()); singer.SingSongChinese(new JapaneseSong()); Console.ReadKey(); } } interface ISong { string SingSong(); } class ChinenseSong:ISong { public string SingSong() { return &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/f3cfd22c6eec4be7f26c40584c7c2296/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-25T20:57:55+08:00" />
<meta property="article:modified_time" content="2024-02-25T20:57:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C#高级--设计模式（七个原则）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、单一职责原则</h3> 
<p><strong>原理：</strong></p> 
<blockquote> 
 <p>单一职责原则即：<strong>对于一个类而言，应该仅有一个引起他变化的原因</strong>。换言之，一个类只负责一个功能领域中的相应职责。</p> 
 <p>单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则，其难点和重点在于<strong>发现职责，并把这些职责相互分离</strong>，即<strong>区分职责的粒度问题</strong>。</p> 
 <p>总而言之，就是一个类中，只负责一件事，只有一个引起变更的原因。</p> 
</blockquote> 
<p><strong>单一职责的好处是：</strong></p> 
<blockquote> 
 <p>好处一：提高代码的可读性，提高系统的可维护性</p> 
 <p>好处二：降低类的复杂度，一个模块只负责一个职责，提高系统的可拓展性和可维护性。</p> 
 <p>好处三：降低变更引起的风险。变更是必然的。如果单一职责做的更好，当修改一个功能的时候可以显著降低对另一个功能的影响。</p> 
</blockquote> 
<h3>二、开放封闭原则</h3> 
<p><strong>原理：</strong></p> 
<blockquote> 
 <p>1、对扩展开放，对修改关闭。其目的即：提高代码可复用性和可维护性。 尽量少地去改动已有的模块，尤其是底层模块。</p> 
 <p>2、在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级，可以通过使用接口和抽象类达到这样的效果。</p> 
 <p></p> 
 <p>其精神所在即：面向需求，对程序的改动是通过添加新代码进行的而不是更改现有代码。 不更改抽象层而可修改系统实现层。</p> 
</blockquote> 
<h3>三、里氏替换原则</h3> 
<p><strong>原理：</strong></p> 
<blockquote> 
 <p>1、任何基类可以出现的地方，子类一定可以出现，即：子类型必须能够替换掉其父类型。</p> 
 <p>2、LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。</p> 
 <p>3、LSP是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范</p> 
</blockquote> 
<h3>四、依赖倒置原则</h3> 
<p><strong>原理：</strong></p> 
<blockquote> 
 <p><strong>1.高层模块不应该依赖于低层模块，两者都应以来抽象；</strong></p> 
 <p><strong>2.抽象不应该依赖于细节，细节应该依赖与抽象。</strong></p> 
 <p> 简单的说就是要求对抽象进行编程，不要对实现进行编程，这里的抽象即抽象类和接口。</p> 
</blockquote> 
<p><strong>依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，互不影响，</strong></p> 
<p><strong>实现模块间的松耦合。 </strong></p> 
<p style="text-align:center;"><strong>关于依赖</strong></p> 
<blockquote> 
 <p> 1、⼀一个优秀的⾯面向对象程序设计，核⼼心的原则之⼀一就是将变化「隔离」/「封装」，<br> 使得变化部分发⽣生变化时，其他部分，不不受影响。<br> 2、为了了实现这个⽬目的，需要使⽤用⾯面向接⼝口编程，使⽤用后，客户类，不不再直接依赖服务类，<br> ⽽而是依赖⼀一个抽象的接⼝口，这样，客户类就不不能在内部直接实例例化服务类。<br> 3、但是客户类在运⾏行行的过程中，⼜又需要具体的服务类来提供服务，因为接⼝口是不不能实例例化的，<br> 就产⽣生了了⼀一个⽭矛盾：客户类不不允许实例例化服务类，但是客户类⼜又需要服务类的服务。<br> 4、为了了解决这个⽭矛盾，我们设计了了⼀一种解决⽅方案，既：客户类定义⼀一个注⼊入点，⽤用于服务类的注⼊入，<br> ⽽而客户类的客户类（Program类）负责根据情况，实例例化服务类，注⼊入到客户类中，从⽽而解决了了这个⽭矛盾。</p> 
</blockquote> 
<p>依赖倒置代码案例如下所示：</p> 
<pre><code class="language-cs">namespace Program_依赖倒置原则
{
    internal class Program
    {
        static void Main(string[] args)
        {
            //歌手歌唱不同国家的歌曲

            Singer singer = new Singer();
            singer.SingSongChinese(new ChinenseSong());
            singer.SingSongChinese(new JapaneseSong());

            Console.ReadKey();
        }

    }

    interface ISong
    {
        string SingSong();
    }

    class ChinenseSong:ISong
    {
        public string SingSong()
        {
            return "我在唱中文歌";
        }
    }

    class KoreaSong : ISong
    {
        public string SingSong()
        {
            return "韩国歌曲";
        }
    }

    class JapaneseSong : ISong
    {
        public string SingSong()
        {
            return "日本歌曲";
        }
    }

    class Singer
    {
        //调用者和被调用者之间是强耦合的关系
        //使用抽象封装变化
        //  通过抽象，使各个模块或者类的实现彼此独立，互不影响，实现模块间的松耦合
        public void SingSongChinese(ISong cs)
        {
            Console.WriteLine("正在唱"+cs.SingSong());
        }
    }
}</code></pre> 
<p> </p> 
<h3>五、接口隔离原则</h3> 
<p><strong>原理：</strong></p> 
<blockquote> 
 <p>1、客户端不应该依赖他不需要的接口。</p> 
 <p>2、一个类对另一个类的依赖应该建立在最小接口上</p> 
 <p>3、接口尽量细分不要一个接口中放多种方法。</p> 
 <p>它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p> 
</blockquote> 
<p><strong>代码案例： </strong></p> 
<pre><code class="language-cs">namespace Program_接口分离原则
{
    internal class Program
    {
        static void Main(string[] args)
        {
        }
    }

    interface IScore
    {
        //修改某个学生的成绩
        void ChangeScore();

    }

    //接口要符合高内聚
    //接口要符合单一职责原则
    //还要实现类权限的问题，对接口中的方法进行分类细分
    
    interface ISuperScore
    {
        void AddScore();
        //删除某个学生的成绩
        void DeleteScore();
    }

    interface IQueryScore
    {
        void QueryScore();
    }

    class Teacher:IScore,IQueryScore
    {
        public void AddScore() { }
        public void DeleteScore() { }
        public void QueryScore() { }

        public void ChangeScore()
        {

        }
    }

    class Student : IQueryScore
    {
        public void QueryScore()
        {
            throw new NotImplementedException();
        }
    }
}</code></pre> 
<h3>六、迪米特原则</h3> 
<p><strong>原理：</strong></p> 
<blockquote> 
 <p>1、它要求一个对象对其他对象有最少的了解（最少知识原则）。</p> 
 <p>2、降低类之间的耦合、</p> 
 <p>3、迪米特法则实际上是一个类在创建方法和属性时要遵守的法则。</p> 
 <p></p> 
 <p>迪米特法则强调，在类的结构设计上，尽量降低成员的访问权限。</p> 
 <p>其根本思想即<strong>强调了类之间的松耦合。</strong> 一般来说，类之间的耦合越弱，越有利于复用，一个处于弱耦合的类被修改，不会对关系类造成波及。</p> 
</blockquote> 
<p><strong>案例打印总公司员工和分公司员工信息： </strong></p> 
<pre><code class="language-cs">namespace Program_迪米特原则
{
    internal class Program
    {
        static void Main(string[] args)
        {
            //总公司员工类：ID
            //总公司员工管理类
              //添加总公司员工
              //打印总公司每个员工
              //打印分公司每个员工
            //分公司员工类
            //分公司管理类
            HeadEmployeeManager headEmployeeManager = new HeadEmployeeManager();
            headEmployeeManager.PrintEmployee();

            Console.ReadKey();
        }

        class HeadEmployee
        {
            public int ID { get; set; }

        }


        class HeadEmployeeManager
        {
            //总公司员工集合
            private List&lt;HeadEmployee&gt; headEmployee = new List&lt;HeadEmployee&gt;();
        
            //添加总公司员工
            public List&lt;HeadEmployee&gt; AddHeadEmployees()
            {
                for(int i = 0; i &lt; 10; i++)
                {
                    headEmployee.Add(new HeadEmployee {  ID = i+1 });
                }
                return headEmployee;
            }


            public void PrintEmployee()
            {
                this.AddHeadEmployees();
                //打印总公司员工
                Console.WriteLine("===========================以下是总公司员工的编号==========================");
                for (int i = 0;i&lt;headEmployee.Count;i++)
                {
                    Console.WriteLine(headEmployee[i].ID);
                }
                Console.WriteLine("==========================以下是分公司员工的编号============================");
                //打印分公司员工

                //创建分公司员工管理类的对象
                BodyEmployeeManager bodyEmployeeManager = new BodyEmployeeManager();
                //调用AddBodyEmployee添加分公司成员，并获取返回值
                List&lt;BodyEmployee&gt; listBodyEmployees = bodyEmployeeManager.AddBodyEmployees();

                for(int i = 0; i &lt; listBodyEmployees.Count;i++)
                {
                    Console.WriteLine(listBodyEmployees[i].ID);
                }
            }
        }

        //分公司
        class BodyEmployee
        {
            public int ID { get; set; }
        }


        class BodyEmployeeManager
        {
            private List&lt;BodyEmployee&gt; bodyEmployees = new List&lt;BodyEmployee&gt;();

            public List&lt;BodyEmployee&gt; AddBodyEmployees()
            {
                for(int i = 0; i &lt; 5; i++)
                {
                    bodyEmployees.Add(new BodyEmployee {  ID = i+1 });
                }
                return bodyEmployees;
            }
        }
    }
}
</code></pre> 
<h3>七、合成复用原则</h3> 
<p><strong>原理：</strong></p> 
<blockquote> 
 <p>1.合成复用原则，又称为组合聚合复用原则。</p> 
 <p>2.尽量使用对象组合，而不是继承来达到复用。</p> 
 <p>3.合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p> 
</blockquote> 
<p><strong>继承带来的问题： </strong></p> 
<blockquote> 
 <p>1.破坏了系统的封装性，基类发生了改变，子类的实现也会发生改变。</p> 
 <p>2.子类如果不需要Method3，则系统的耦合性变高。</p> 
 <p><strong>3.继承使静态的不能在程序运行时发生改变。</strong></p> 
</blockquote> 
<p><strong>合成复用具体情况实施代码： </strong></p> 
<pre><code class="language-cs">namespace Program_复合复用原则
{
    internal class Program
    {
        static void Main(string[] args)
        {
            //继承问题:
            //可能造成子类泛滥
            //可能会造成子类数量爆炸
            //打破了类的封装性

            //创建油车对象
            GasCar gascar = new GasCar(new RedColor());
            gascar.Move();
            Console.ReadKey();

        }
    }

    interface IColor
    {
        string GetColor();
    }

    class WhiteColor : IColor
    {
        public string GetColor()
        {
            return "我是白色的汽车";
        }
    }

    class BlackColor : IColor
    {
        public string GetColor()
        {
            return "我是黑色的汽车";
        }
    }

    class RedColor : IColor
    {
        public string GetColor()
        {
            return "我是红色的汽车";
        }
    }

    abstract class Car
    {
        public IColor color { get; set; }

        public Car(IColor Color)//组合，强拥有关系
        {
            this.color = Color;
        }
        public abstract void Move();
    }

    class GasCar : Car
    {
        public GasCar(IColor color) : base(color)
        {
        }

        public override void Move()
        {
            Console.WriteLine(this.color.GetColor()+"的电动汽车");
        }
    }

    class ElectricCar : Car
    {
        public ElectricCar(IColor Color) : base(Color)
        {

        }

        public override void Move() 
        {
            Console.WriteLine(this.color.GetColor()+"的汽油汽车");

        }
    }
}
</code></pre> 
<h3>八、设计原则总结</h3> 
<p><img alt="" height="575" src="https://images2.imgbox.com/b7/51/ZidHF9bx_o.png" width="1200"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/29dd32bb8e7c8fc8e042b783713d7edd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">kubernetes集群搭建(1.26版本)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2751a1a7c9555f0a81ea534979031e39/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java/Python/Go不同开发语言基础数据结构和相关操作总结-GC篇</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>