<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java源码分析之ArrayList - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java源码分析之ArrayList" />
<meta property="og:description" content="ArrayList就是传说中的动态数组，就是Array的复杂版本，它提供了如下一些好处：动态的增加和减少元素、灵活的设置数组的大小......
认真阅读本文，我相信一定会对你有帮助。比如为什么ArrayList里面提供了一个受保护的removeRange方法？提供了其他没有被调用过的私有方法？
首先看到对ArrayList的定义：
public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 从ArrayList&lt;E&gt;可以看出它是支持泛型的，它继承自AbstractList，实现了List、RandomAccess、Cloneable、java.io.Serializable接口。
AbstractList提供了List接口的默认实现（个别方法为抽象方法）。
List接口定义了列表必须实现的方法。
RandomAccess是一个标记接口，接口内没有定义任何内容。
实现了Cloneable接口的类，可以调用Object.clone方法返回该对象的浅拷贝。
通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。序列化接口没有方法或字段，仅用于标识可序列化的语义。
ArrayList的属性
ArrayList定义只定义类两个私有属性：
/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. */ private transient Object[] elementData; /** * The size of the ArrayList (the number of elements it contains). * * @serial */ private int size; 很容易理解，elementData存储ArrayList内的元素，size表示它包含的元素的数量。 有个关键字需要解释：transient。 Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。 transient是Java语言的关键字，用来表示一个域不是该对象串行化的一部分。当一个对象被串行化的时候，transient型变量的值不包括在串行化的表示中，然而非transient型的变量是被包括进去的。 有点抽象，看个例子应该能明白。 public class UserInfo implements Serializable { private static final long serialVersionUID = 996890129747019948L; private String name; private transient String psw; public UserInfo(String name, String psw) { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/1d1e9abaa60fc92be1ad1e3fc3c7e035/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-01-25T08:52:19+08:00" />
<meta property="article:modified_time" content="2013-01-25T08:52:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java源码分析之ArrayList</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">  ArrayList就是传说中的动态数组，就是Array的复杂版本，它提供了如下一些好处：动态的增加和减少元素、灵活的设置数组的大小......</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">     认真阅读本文，我相信一定会对你有帮助。比如为什么ArrayList里面提供了一个受保护的removeRange方法？提供了其他没有被调用过的私有方法？</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">     首先看到对ArrayList的定义：</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> </p> 
<pre><code class="language-java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;  implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</code></pre> 
<p></p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">  从ArrayList&lt;E&gt;可以看出它是支持泛型的，它继承自AbstractList，实现了List、RandomAccess、Cloneable、java.io.Serializable接口。</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">     AbstractList提供了List接口的默认实现（个别方法为抽象方法）。</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">     List接口定义了列表必须实现的方法。</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">     RandomAccess是一个标记接口，接口内没有定义任何内容。</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">     实现了Cloneable接口的类，可以调用Object.clone方法返回该对象的浅拷贝。</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">     通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。序列化接口没有方法或字段，仅用于标识可序列化的语义。</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">     <span style="margin:0px; padding:0px">ArrayList的属性</span></p> 
<p align="left" style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">     ArrayList定义只定义类两个私有属性：</p> 
<pre><code class="language-java">/**
      * The array buffer into which the elements of the ArrayList are stored.
      * The capacity of the ArrayList is the length of this array buffer.
      */
     private transient Object[] elementData;
 
     /**
      * The size of the ArrayList (the number of elements it contains).
      *
      * @serial
      */
     private int size;</code></pre> 
<br> 
<pre><code class="language-java">  很容易理解，elementData存储ArrayList内的元素，size表示它包含的元素的数量。

    有个关键字需要解释：transient。

    Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。
transient是Java语言的关键字，用来表示一个域不是该对象串行化的一部分。当一个对象被串行化的时候，transient型变量的值不包括在串行化的表示中，然而非transient型的变量是被包括进去的。

    有点抽象，看个例子应该能明白。</code></pre> 
<br> 
<pre><code class="language-java">public class UserInfo implements Serializable {
     private static final long serialVersionUID = 996890129747019948L;
     private String name;
     private transient String psw;
 
     public UserInfo(String name, String psw) {
         this.name = name;
         this.psw = psw;
     }
 
     public String toString() {
         return "name=" + name + ", psw=" + psw;
     }
 }
 
 public class TestTransient {
     public static void main(String[] args) {
         UserInfo userInfo = new UserInfo("张三", "123456");
         System.out.println(userInfo);
         try {
             // 序列化，被设置为transient的属性没有被序列化
             ObjectOutputStream o = new ObjectOutputStream(new FileOutputStream(
                     "UserInfo.out"));
             o.writeObject(userInfo);
             o.close();
         } catch (Exception e) {
             // TODO: handle exception
             e.printStackTrace();
         }
         try {
             // 重新读取内容
             ObjectInputStream in = new ObjectInputStream(new FileInputStream(
                     "UserInfo.out"));
             UserInfo readUserInfo = (UserInfo) in.readObject();
             //读取后psw的内容为null
             System.out.println(readUserInfo.toString());
         } catch (Exception e) {
             // TODO: handle exception
             e.printStackTrace();
         }
     }
 }</code></pre> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">  被标记为transient的属性在对象被序列化的时候不会被保存。</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">     接着回到ArrayList的分析中......</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">     <span style="margin:0px; padding:0px">ArrayList的构造方法</span></p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">     看完属性看构造方法。ArrayList提供了三个构造方法：</p> 
<pre><code class="language-java">/**
      * Constructs an empty list with the specified initial capacity.
      */
     public ArrayList(int initialCapacity) {
     super();
         if (initialCapacity &lt; 0)
             throw new IllegalArgumentException("Illegal Capacity: "+
                                                initialCapacity);
     this.elementData = new Object[initialCapacity];
     }
 
     /**
      * Constructs an empty list with an initial capacity of ten.
      */
     public ArrayList() {
     this(10);
     }
 
     /**
      * Constructs a list containing the elements of the specified
      * collection, in the order they are returned by the collection's
      * iterator.
      */
     public ArrayList(Collection&lt;? extends E&gt; c) {
     elementData = c.toArray();
     size = elementData.length;
     // c.toArray might (incorrectly) not return Object[] (see 6260652)
     if (elementData.getClass() != Object[].class)
         elementData = Arrays.copyOf(elementData, size, Object[].class);
     }</code></pre> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">    第一个构造方法使用提供的initialCapacity来初始化elementData数组的大小。第二个构造方法调用第一个构造方法并传入参数10，即默认elementData数组的大小为10。第三个构造方法则将提供的集合转成数组返回给elementData（返回若不是Object[]将调用Arrays.copyOf方法将其转为Object[]）。</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">     <span style="margin:0px; padding:0px">ArrayList的其他方法</span></p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> <span style="margin:0px; padding:0px">    add(E e)</span></p> 
<p align="left" style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">     add(E e)都知道是在尾部添加一个元素，如何实现的呢？</p> 
<pre><code class="language-java">public boolean add(E e) {
    ensureCapacity(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
    }</code></pre> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">  书上都说ArrayList是基于数组实现的，属性中也看到了数组，具体是怎么实现的呢？比如就这个添加元素的方法，如果数组大，则在将某个位置的值设置为指定元素即可，如果数组容量不够了呢？</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">     看到add(E e)中先调用了ensureCapacity(size+1)方法，之后将元素的索引赋给elementData[size]，而后size自增。例如初次添加时，size为0，add将elementData[0]赋值为e，然后size设置为1（类似执行以下两条语句elementData[0]=e;size=1）。将元素的索引赋给elementData[size]不是会出现数组越界的情况吗？这里关键就在ensureCapacity(size+1)中了。</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">     根据ensureCapacity的方法名可以知道是确保容量用的。ensureCapacity(size+1)后面的注释可以明白是增加modCount的值（加了俩感叹号，应该蛮重要的，来看看）。</p> 
<pre><code class="language-java">/**
      * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if
      * necessary, to ensure that it can hold at least the number of elements
      * specified by the minimum capacity argument.
      *
      * @param   minCapacity   the desired minimum capacity
      */
     public void ensureCapacity(int minCapacity) {
     modCount++;
     int oldCapacity = elementData.length;
     if (minCapacity &gt; oldCapacity) {
         Object oldData[] = elementData;
         int newCapacity = (oldCapacity * 3)/2 + 1;
             if (newCapacity &lt; minCapacity)
         newCapacity = minCapacity;
             // minCapacity is usually close to size, so this is a win:
             elementData = Arrays.copyOf(elementData, newCapacity);
     }
     }</code></pre> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> The number of times this list has been structurally modified.</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">     这是对modCount的解释，意为记录list结构被改变的次数（观察源码可以发现每次调用ensureCapacoty方法，modCount的值都将增加，但未必数组结构会改变，所以感觉对modCount的解释不是很到位）。</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">     <span style="margin:0px; padding:0px">增加modCount之后，判断minCapacity（即size+1）是否大于oldCapacity（即elementData.length），若大于，则调整容量为max((oldCapacity*3)/2+1,minCapacity)，调整elementData容量为新的容量，即将返回一个内容为原数组元素，大小为新容量的数组赋给elementData；否则不做操作。</span></p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> <span style="margin:0px; padding:0px">    所以调用ensureCapacity至少将<span style="margin:0px; padding:0px">elementData的容量</span>增加的1，所以elementData[size]不会出现越界的情况。</span></p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">     <span style="margin:0px; padding:0px">容量的拓展将导致数组元素的复制，多次拓展容量将执行多次整个数组内容的复制。若提前能大致判断list的长度，调用ensureCapacity调整容量，将有效的提高运行速度。</span></p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> <span style="margin:0px; padding:0px">    可以理解提前分配好空间可以提高运行速度，但是测试发现提高的并不是很大，而且若list原本数据量就不会很大效果将更不明显。</span></p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> <span style="margin:0px; padding:0px">    add(int index, E element)</span></p> 
<p align="left" style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">     add(int index,E element)在指定位置插入元素。</p> 
<pre><code class="language-java">public void add(int index, E element) {
     if (index &gt; size || index &lt; 0)
         throw new IndexOutOfBoundsException(
         "Index: "+index+", Size: "+size);
 
     ensureCapacity(size+1);  // Increments modCount!!
     System.arraycopy(elementData, index, elementData, index + 1,
              size - index);
     elementData[index] = element;
     size++;
     }</code></pre> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">    首先判断指定位置index是否超出elementData的界限，之后调用ensureCapacity调整容量（若容量足够则不会拓展），调用System.arraycopy将elementData从index开始的size-index个元素复制到index+1至size+1的位置（即index开始的元素都向后移动一个位置），然后将index位置的值指向element。<span style="margin:0px; padding:0px">       </span></p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> <span style="margin:0px; padding:0px">    addAll(Collection&lt;? extends E&gt; c)</span></p> 
<pre><code class="language-java">public boolean addAll(Collection&lt;? extends E&gt; c) {
     Object[] a = c.toArray();
         int numNew = a.length;
     ensureCapacity(size + numNew);  // Increments modCount
         System.arraycopy(a, 0, elementData, size, numNew);
         size += numNew;
     return numNew != 0;
     }</code></pre> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">   先将集合c转换成数组，根据转换后数组的程度和ArrayList的size拓展容量，之后调用System.arraycopy方法复制元素到elementData的尾部，调整size。根据返回的内容分析，只要集合c的大小不为空，即转换后的数组长度不为0则返回true。</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> <span style="margin:0px; padding:0px">    addAll(int index,Collection&lt;? extends E&gt; c)</span></p> 
<pre><code class="language-java">public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
     if (index &gt; size || index &lt; 0)
         throw new IndexOutOfBoundsException(
         "Index: " + index + ", Size: " + size);
 
     Object[] a = c.toArray();
     int numNew = a.length;
     ensureCapacity(size + numNew);  // Increments modCount
 
     int numMoved = size - index;
     if (numMoved &gt; 0)
         System.arraycopy(elementData, index, elementData, index + numNew,
                  numMoved);
 
         System.arraycopy(a, 0, elementData, index, numNew);
     size += numNew;
     return numNew != 0;
     }</code></pre> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">   先判断index是否越界。其他内容与addAll(Collection&lt;? extends E&gt; c)基本一致，只是复制的时候先将index开始的元素向后移动X（c转为数组后的长度）个位置（也是一个复制的过程），之后将数组内容复制到elementData的index位置至index+X。</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> <span style="margin:0px; padding:0px">    clear()</span></p> 
<pre><code class="language-java">public void clear() {
     modCount++;
 
     // Let gc do its work
     for (int i = 0; i &lt; size; i++)
         elementData[i] = null;
 
     size = 0;
     }</code></pre> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> clear的时候并没有修改elementData的长度（好不容易申请、拓展来的，凭什么释放，留着搞不好还有用呢。这使得确定不再修改list内容之后最好调用trimToSize来释放掉一些空间），只是将所有元素置为null，size设置为0。</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> <span style="margin:0px; padding:0px">    clone()</span></p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">     返回此 ArrayList 实例的浅表副本。（不复制这些元素本身。）</p> 
<pre><code class="language-java">public Object clone() {
     try {
         ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone();
         v.elementData = Arrays.copyOf(elementData, size);
         v.modCount = 0;
         return v;
     } catch (CloneNotSupportedException e) {
         // this shouldn't happen, since we are Cloneable
         throw new InternalError();
     }
     }</code></pre> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">   调用父类的clone方法返回一个对象的副本，将返回对象的elementData数组的内容赋值为原对象elementData数组的内容，将副本的modCount设置为0。</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> <span style="margin:0px; padding:0px">    contains(Object)</span></p> 
<pre><code class="language-html">public boolean contains(Object o) {
     return indexOf(o) &gt;= 0;
     }</code></pre> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">  indexOf方法返回值与0比较来判断对象是否在list中。接着看indexOf。</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> <span style="margin:0px; padding:0px">    indexOf(Object)</span></p> 
<pre><code class="language-java">public int indexOf(Object o) {
     if (o == null) {
         for (int i = 0; i &lt; size; i++)
         if (elementData[i]==null)
             return i;
     } else {
         for (int i = 0; i &lt; size; i++)
         if (o.equals(elementData[i]))
             return i;
     }
     return -1;
     }</code></pre> 
<br> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> 通过遍历elementData数组来判断对象是否在list中，若存在，返回index（[0,size-1]），若不存在则返回-1。所以contains方法可以通过indexOf(Object)方法的返回值来判断对象是否被包含在list中。</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">     既然看了indexOf(Object)方法，接着就看lastIndexOf，光看名字应该就明白了返回的是传入对象在elementData数组中最后出现的index值。</p> 
<pre><code class="language-java">public int lastIndexOf(Object o) {
     if (o == null) {
         for (int i = size-1; i &gt;= 0; i--)
         if (elementData[i]==null)
             return i;
     } else {
         for (int i = size-1; i &gt;= 0; i--)
         if (o.equals(elementData[i]))
             return i;
     }
     return -1;
     }</code></pre> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> 采用了从后向前遍历element数组，若遇到Object则返回index值，若没有遇到，返回-1。</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">     <span style="margin:0px; padding:0px">get(int index)</span></p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">     这个方法看着很简单，应该是返回elementData[index]就完了。</p> 
<pre><code class="language-java">public E get(int index) {
     RangeCheck(index);

     return (E) elementData[index];
     }</code></pre> 
<br> 
<span style="color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">但看代码的时候看到调用了RangeCheck方法，而且还是大写的方法，看看究竟有什么内容吧。</span> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> </p> 
<pre><code class="language-java">/**
      * Checks if the given index is in range.
 */
 private void RangeCheck(int index) {
     if (index &gt;= size)
         throw new IndexOutOfBoundsException(
         "Index: "+index+", Size: "+size);
     }</code></pre> 
<br> 
<p></p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">  就是检查一下是不是超出数组界限了，超出了就抛出IndexOutBoundsException异常。为什么要大写呢？？？</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> <span style="margin:0px; padding:0px">    isEmpty()</span></p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">     直接返回size是否等于0。</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> <span style="margin:0px; padding:0px">    remove(int index)</span></p> 
<pre><code class="language-java">public E remove(int index) {
     RangeCheck(index);
     modCount++;
     E oldValue = (E) elementData[index];
     int numMoved = size - index - 1;
     if (numMoved &gt; 0)
         System.arraycopy(elementData, index+1, elementData, index,
                  numMoved);
     elementData[--size] = null; // Let gc do its work
     return oldValue;
     }</code></pre> 
<br> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> 首先是检查范围，修改modCount，保留将要被移除的元素，将移除位置之后的元素向前挪动一个位置，将list末尾元素置空（null），返回被移除的元素。</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> <span style="margin:0px; padding:0px">    remove(Object o)</span></p> 
<pre><code class="language-java">public boolean remove(Object o) {
     if (o == null) {
             for (int index = 0; index &lt; size; index++)
         if (elementData[index] == null) {
             fastRemove(index);
             return true;
         }
     } else {
         for (int index = 0; index &lt; size; index++)
         if (o.equals(elementData[index])) {
             fastRemove(index);
             return true;
         }
         }
     return false;
     }</code></pre> 
<br> 
<span style="color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">  首先通过代码可以看到，当移除成功后返回true，否则返回false。remove(Object o)中通过遍历element寻找是否存在传入对象，一旦找到就调用fastRemove移除对象。为什么找到了元素就知道了index，不通过remove(index)来移除元素呢？因为fastRemove跳过了判断边界的处理，因为找到元素就相当于确定了index不会超过边界，而且fastRemove并不返回被移除的元素。下面是fastRemove的代码，基本和remove(index)一致。</span> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> </p> 
<pre><code class="language-java">private void fastRemove(int index) {
         modCount++;
         int numMoved = size - index - 1;
         if (numMoved &gt; 0)
             System.arraycopy(elementData, index+1, elementData, index,
                              numMoved);
         elementData[--size] = null; // Let gc do its work
     }</code></pre> 
<br> 
<span style="margin:0px; padding:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">  removeRange(int fromIndex,int toIndex)</span> 
<p></p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> </p> 
<pre><code class="language-java">protected void removeRange(int fromIndex, int toIndex) {
     modCount++;
     int numMoved = size - toIndex;
         System.arraycopy(elementData, toIndex, elementData, fromIndex,
                          numMoved);
 
     // Let gc do its work
     int newSize = size - (toIndex-fromIndex);
     while (size != newSize)
         elementData[--size] = null;
     }</code></pre> 
<p></p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> 执行过程是将elementData从toIndex位置开始的元素向前移动到fromIndex，然后将toIndex位置之后的元素全部置空顺便修改size。</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">     <span style="margin:0px; padding:0px; color:rgb(153,51,102)"><span style="margin:0px; padding:0px">这个方法是protected，及受保护的方法，为什么这个方法被定义为protected呢？</span></span></p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> <span style="margin:0px; padding:0px; color:rgb(153,51,102)"><span style="margin:0px; padding:0px">    这是一个解释，但是可能不容易看明白。http://stackoverflow.com/questions/2289183/why-is-javas-abstractlists-removerange-method-protected</span></span></p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> <span style="margin:0px; padding:0px; color:rgb(153,51,102)">    先看下面这个例子</span></p> 
<pre><code class="language-java">ArrayList&lt;Integer&gt; ints = new ArrayList&lt;Integer&gt;(Arrays.asList(0, 1, 2,
                 3, 4, 5, 6));
         // fromIndex low endpoint (inclusive) of the subList
         // toIndex high endpoint (exclusive) of the subList
        ints.subList(2, 4).clear();
         System.out.println(ints);</code></pre> 
<span style="color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> </span> 
<span style="margin:0px; padding:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"><span style="margin:0px; padding:0px; color:rgb(153,51,102)">输出结果是[0, 1, 4, 5, 6]，结果是不是像调用了removeRange(int fromIndex,int toIndex)！哈哈哈，就是这样的。但是为什么效果相同呢？是不是调用了removeRange<span style="margin:0px; padding:0px"><span style="margin:0px; padding:0px">(int fromIndex,int toIndex)呢？</span></span></span></span> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; font-family:tahoma,arial,sans-serif; line-height:18px"> <span style="color:#993366"><span style="margin:0px; padding:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">set(int index,E element)</span></span></p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; font-family:tahoma,arial,sans-serif; line-height:18px"> <span style="color:#444444"></span></p> 
<pre><code class="language-java">public E set(int index, E element) {
     RangeCheck(index);
 
     E oldValue = (E) elementData[index];
     elementData[index] = element;
     return oldValue;
     }</code></pre> 
<p></p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">   首先检查范围，用新元素替换旧元素并返回旧元素。</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> <span style="margin:0px; padding:0px">    size()</span></p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">     size()方法直接返回size。</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> <span style="margin:0px; padding:0px">    toArray()</span></p> 
<pre><code class="language-java">public Object[] toArray() {
         return Arrays.copyOf(elementData, size);
     }</code></pre> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">  调用Arrays.copyOf将返回一个数组，数组内容是size个elementData的元素，即拷贝elementData从0至size-1位置的元素到新数组并返回。</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> <span style="margin:0px; padding:0px">    toArray(T[] a)</span></p> 
<pre><code class="language-java">public &lt;T&gt; T[] toArray(T[] a) {
         if (a.length &lt; size)
             // Make a new array of a's runtime type, but my contents:
             return (T[]) Arrays.copyOf(elementData, size, a.getClass());
     System.arraycopy(elementData, 0, a, 0, size);
         if (a.length &gt; size)
             a[size] = null;
         return a;
     }</code></pre> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">  如果传入数组的长度小于size，返回一个新的数组，大小为size，类型与传入数组相同。所传入数组长度与size相等，则将elementData复制到传入数组中并返回传入的数组。若传入数组长度大于size，除了复制elementData外，还将把返回数组的第size个元素置为空。</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> <span style="margin:0px; padding:0px">    trimToSize()</span></p> 
<pre><code class="language-java">public void trimToSize() {
     modCount++;
     int oldCapacity = elementData.length;
     if (size &lt; oldCapacity) {
             elementData = Arrays.copyOf(elementData, size);
     }
     }</code></pre> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px"> 由于elementData的长度会被拓展，size标记的是其中包含的元素的个数。所以会出现size很小但elementData.length很大的情况，将出现空间的浪费。trimToSize将返回一个新的数组给elementData，元素内容保持不变，length很size相同，节省空间。</p> 
<p style="margin:10px auto; padding-top:0px; padding-bottom:0px; color:rgb(68,68,68); font-family:tahoma,arial,sans-serif; line-height:18px">      学习Java最好的方式还必须是读源码。读完源码你才会发现这东西为什么是这么玩的，有哪些限制，关键点在哪里等等。而且这些源码都是大牛们写的，你能从中学习到很多。 </p> 
<br> 
<br> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/20ab49cee933b86a888be75b07734647/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vncserver的使用简介</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3975b8b825f0dfb66c0dd19be18c97d3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">牛人总结python中string模块各属性以及函数的用法，果断转了，好东西</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>