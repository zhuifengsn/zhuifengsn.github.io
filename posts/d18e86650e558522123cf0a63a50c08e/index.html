<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言——链表（带头节点与不带头节点） - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言——链表（带头节点与不带头节点）" />
<meta property="og:description" content="✅简介：与大家一起加油，希望文章能够帮助各位！！！！ 💬保持学习、保持热爱、认真分享、一起进步！！！ 文章目录 前言
一、动态数组的弊端
二、单链表
1.链表的优势
2.什么是链表 3.如何定义一个链表
3.1底层代码逻辑 3.2链表元素的插入、删除操作 4.如何让我们在读入数据时降低时间开销 总结
前言 上篇文章写了顺序表（数组），虽然我们现在可以创造出来动态增加的数组，但是动态数组还是有一系列的问题：
一、动态数组的弊端 缺点一：我们的数组需要连续的整片的空间，而我们计算机中没有这么大的空间。
如下图：图中我们可以清晰的看到当第三次申请空间的时候，计算机明明有这么多空间但是却申请失败，因为数组需要连续不间断的空间来存放数据。
第二个缺点就是当我们扩容的时候，我们需要遍历之前的数据进行拷贝，浪费时间。当数据规模不大的时候，可以忽略。但是当数据达到一定程度后就会出现拷贝整个数组可能需要较长的时间，对性能会产生一定的影响。
二、单链表 1.链表的优势 动态性：链表是一种动态数据结构，可以在运行时灵活地插入、删除和修改元素，而不需要预先指定容量。这意味着链表可以根据需要动态地增长或缩小，提供更好的灵活性。
内存管理：链表的节点可以在内存中非连续地分布，每个节点可以存储任意数量的数据。这种内存分配方式可以更有效地利用内存空间，并且可以避免由于连续内存分配导致的碎片化问题。
从下面这张图也可以看出，链表和数组刚好互补。
2.什么是链表 链表是一种常见的线性数据结构，它由一系列的节点组成，每个节点包含两部分：数据和指向下一个节点的指针。每个节点可以在内存中不连续地分布，通过指针将它们串联在一起。下面呢，进入正题！！！ 3.如何定义一个链表 首先呢，我们先看这张图！这是带头节点，带头节点的链表是在链表头部添加了一个额外的节点，该节点不存储任何数据，只是作为链表的起始位置。带头节点的链表中，头节点的下一个节点才是实际存储数据的第一个节点。
不带头节点的主要区别就是在于第一个的问题，不带头结点首先定义一个同类型的指针，指向第一个存放元素的地址值，直接从存储数据的第一个节点开始。这里呢，因为不带头节点的代码更麻烦一点，所以我们主要以不带头节点的链表进行讲解！
3.1底层代码逻辑 首先，定义一个结构体（链表）
typedef struct _abc { struct _abc* next;//指向下一个 int value; } link; 现在，我们拥有了一个个的节点，该怎样去把他们去串在一起呢？
看完下面的代码，如果你学过数据结构的话不难看出这段代码的时间复杂度O(),怎样去降低这个时间的耗费呢？自己可以先停下来思考一下，后面会提到呦！！！
link* head = NULL; //定义头指针 int num; while (true){ printf(&#34;请输入链表中的值：&#34;); link* l = (link*)malloc(sizeof(link)); scanf(&#34;%d&#34;, &amp;num); if (num == -1) //如果num==-1结束循环 break; l-&gt;value = num; l-&gt;next = NULL; link* k = head; if (k) {//如果k=NULL进入 while (k-&gt;next) { k = k-&gt;next; } k-&gt;next = l; //循环结束，链表走到了最后一个位置，我们需要把新增加的元素加上去 } else { head = l;//如果head==NULL的话（第一次读入数据），则让head指向l的地址 } } 遍历链表！！！ 千万要记得malloc得到的空间一定要还回去，每次循环就是把指向地址的指针后移，读出数据。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/d18e86650e558522123cf0a63a50c08e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-18T00:30:37+08:00" />
<meta property="article:modified_time" content="2023-07-18T00:30:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言——链表（带头节点与不带头节点）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <h4 id="%E2%9C%85%E7%AE%80%E4%BB%8B%EF%BC%9A%E4%B8%8E%E5%A4%A7%E5%AE%B6%E4%B8%80%E8%B5%B7%E5%8A%A0%E6%B2%B9%EF%BC%8C%E5%B8%8C%E6%9C%9B%E6%96%87%E7%AB%A0%E8%83%BD%E5%A4%9F%E5%B8%AE%E5%8A%A9%E5%90%84%E4%BD%8D%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81">✅简介：与大家一起加油，希望文章能够帮助各位！！！！</h4> 
 <h4 id="%F0%9F%92%AC%E4%BF%9D%E6%8C%81%E5%AD%A6%E4%B9%A0%E3%80%81%E4%BF%9D%E6%8C%81%E7%83%AD%E7%88%B1%E3%80%81%E8%AE%A4%E7%9C%9F%E5%88%86%E4%BA%AB%E3%80%81%E4%B8%80%E8%B5%B7%E8%BF%9B%E6%AD%A5%EF%BC%81%EF%BC%81%EF%BC%81">💬保持学习、保持热爱、认真分享、一起进步！！！</h4> 
</blockquote> 
<div> 
 <h4 id="%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">文章目录</h4> 
 <p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
 <p id="%E4%B8%80%E3%80%81%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%BC%8A%E7%AB%AF-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%BC%8A%E7%AB%AF" rel="nofollow">一、动态数组的弊端</a></p> 
 <p id="%E4%BA%8C%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8" rel="nofollow">二、单链表</a></p> 
 <p id="1.%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8A%BF-toc" style="margin-left:40px;"><a href="#1.%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8A%BF" rel="nofollow">1.链表的优势</a></p> 
 <p id="2.%E4%BB%80%E4%B9%88%E6%98%AF%E9%93%BE%E8%A1%A8%C2%A0-toc" style="margin-left:40px;"><a href="#2.%E4%BB%80%E4%B9%88%E6%98%AF%E9%93%BE%E8%A1%A8%C2%A0" rel="nofollow">2.什么是链表 </a></p> 
 <p id="3.%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><a href="#3.%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8" rel="nofollow">3.如何定义一个链表</a></p> 
 <p id="3.1%E5%BA%95%E5%B1%82%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91%C2%A0-toc" style="margin-left:80px;"><a href="#3.1%E5%BA%95%E5%B1%82%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91%C2%A0" rel="nofollow">3.1底层代码逻辑 </a></p> 
 <p id="3.2%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E7%9A%84%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%C2%A0-toc" style="margin-left:80px;"><a href="#3.2%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E7%9A%84%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%C2%A0" rel="nofollow">3.2链表元素的插入、删除操作 </a></p> 
 <p id="4.%E5%A6%82%E4%BD%95%E8%AE%A9%E6%88%91%E4%BB%AC%E5%9C%A8%E8%AF%BB%E5%85%A5%E6%95%B0%E6%8D%AE%E6%97%B6%E9%99%8D%E4%BD%8E%E6%97%B6%E9%97%B4%E5%BC%80%E9%94%80%C2%A0-toc" style="margin-left:40px;"><a href="#4.%E5%A6%82%E4%BD%95%E8%AE%A9%E6%88%91%E4%BB%AC%E5%9C%A8%E8%AF%BB%E5%85%A5%E6%95%B0%E6%8D%AE%E6%97%B6%E9%99%8D%E4%BD%8E%E6%97%B6%E9%97%B4%E5%BC%80%E9%94%80%C2%A0" rel="nofollow">4.如何让我们在读入数据时降低时间开销 </a></p> 
 <p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
</div> 
<hr> 
<h2 id="%E5%89%8D%E8%A8%80"><a id="_12"></a>前言</h2> 
<p><code>上篇文章写了顺序表（数组），虽然我们现在可以创造出来动态增加的数组，但是动态数组还是有一系列的问题：</code></p> 
<p><img alt="" height="715" src="https://images2.imgbox.com/31/0a/dqWyDOf3_o.jpg" width="1154"></p> 
<hr> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%BC%8A%E7%AB%AF"><a id="pandas_22"></a>一、动态数组的弊端</h2> 
<blockquote> 
 <p>缺点一：我们的数组需要连续的整片的空间，而我们计算机中没有这么大的空间。</p> 
 <p>如下图：图中我们可以清晰的看到当第三次申请空间的时候，计算机明明有这么多空间但是却申请失败，因为数组需要连续不间断的空间来存放数据。</p> 
</blockquote> 
<p class="img-center"><img alt="" height="544" src="https://images2.imgbox.com/83/a0/v5zoKELQ_o.png" width="1200"></p> 
<blockquote> 
 <p> 第二个缺点就是当我们扩容的时候，我们需要遍历之前的数据进行拷贝，浪费时间。当数据规模不大的时候，可以忽略。但是当数据达到一定程度后就会出现拷贝整个数组可能需要较长的时间，对性能会产生一定的影响。</p> 
</blockquote> 
<h2 id="%E4%BA%8C%E3%80%81%E5%8D%95%E9%93%BE%E8%A1%A8"><a id="_26"></a>二、单链表</h2> 
<h3 id="1.%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8A%BF"><a id="1_27"></a>1.链表的优势</h3> 
<blockquote> 
 <ol><li> <p>动态性：链表是一种动态数据结构，可以在运行时灵活地插入、删除和修改元素，而不需要预先指定容量。这意味着链表可以根据需要动态地增长或缩小，提供更好的灵活性。</p> </li><li> <p>内存管理：链表的节点可以在内存中非连续地分布，每个节点可以存储任意数量的数据。这种内存分配方式可以更有效地利用内存空间，并且可以避免由于连续内存分配导致的碎片化问题。</p> </li></ol> 
</blockquote> 
<p></p> 
<p> 从下面这张图也可以看出，链表和数组刚好互补。<img alt="" height="732" src="https://images2.imgbox.com/ff/6c/Mvty6wys_o.jpg" width="1200"></p> 
<h3 id="2.%E4%BB%80%E4%B9%88%E6%98%AF%E9%93%BE%E8%A1%A8%C2%A0">2.什么是链表 </h3> 
<blockquote> 
 <p>链表是一种常见的线性数据结构，它由一系列的节点组成，每个节点包含两部分：数据和指向下一个节点的指针。每个节点可以在内存中不连续地分布，通过指针将它们串联在一起。下面呢，进入正题！！！ </p> 
</blockquote> 
<p><code class="language-c"> </code></p> 
<h3 id="3.%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8"><a id="2_41"></a>3.如何定义一个链表</h3> 
<blockquote> 
 <p>首先呢，我们先看这张图！这是带头节点，带头节点的链表是在链表头部添加了一个额外的节点，该节点不存储任何数据，只是作为链表的起始位置。带头节点的链表中，头节点的下一个节点才是实际存储数据的第一个节点。</p> 
</blockquote> 
<p><img alt="" height="521" src="https://images2.imgbox.com/63/74/GR6UIZ3u_o.png" width="1200"></p> 
<blockquote> 
 <p> 不带头节点的主要区别就是在于第一个的问题，不带头结点首先定义一个同类型的指针，指向第一个存放元素的地址值，直接从存储数据的第一个节点开始。这里呢，因为不带头节点的代码更麻烦一点，所以我们主要以不带头节点的链表进行讲解！</p> 
</blockquote> 
<p> <img alt="" height="510" src="https://images2.imgbox.com/82/26/74PxxWAt_o.png" width="1200"></p> 
<hr> 
<h4 id="3.1%E5%BA%95%E5%B1%82%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91%C2%A0">3.1底层代码逻辑 </h4> 
<blockquote> 
 <p>首先，定义一个结构体（链表）</p> 
</blockquote> 
<pre><code class="language-cs">typedef struct _abc {
	struct _abc* next;//指向下一个
	int value;
} link;</code></pre> 
<blockquote> 
 <p> 现在，我们拥有了一个个的节点，该怎样去把他们去串在一起呢？</p> 
 <p>看完下面的代码，如果你学过数据结构的话不难看出这段代码的<span style="color:#fe2c24;">时间复杂度O(<img alt="n^2" class="mathcode" src="https://images2.imgbox.com/db/37/zr99RzD2_o.png">)</span><span style="color:#0d0016;">,怎样去降低这个时间的耗费呢？自己可以先停下来思考一下，后面会提到呦！！！</span></p> 
</blockquote> 
<pre><code class="language-cs">link* head = NULL; //定义头指针
	int num;
	while (true){
		printf("请输入链表中的值：");
		link* l = (link*)malloc(sizeof(link));
		scanf("%d", &amp;num);
		if (num == -1) //如果num==-1结束循环
			break;
		l-&gt;value = num;
		l-&gt;next = NULL;
		link* k = head;
		if (k) {//如果k=NULL进入
			while (k-&gt;next) {
				k = k-&gt;next;
			}
			k-&gt;next = l; //循环结束，链表走到了最后一个位置，我们需要把新增加的元素加上去
		} else {
			head = l;//如果head==NULL的话（第一次读入数据），则让head指向l的地址
		}
	}</code></pre> 
<blockquote> 
 <p>遍历链表！！！ 千万要记得<span style="color:#fe2c24;">malloc得到的空间一定要还回去</span><span style="color:#0d0016;">，每次循环就是把指向地址的指针后移，读出数据。</span></p> 
</blockquote> 
<pre><code class="language-cs">for (link* p = head; p; p = p-&gt;next) {
			printf("%d\t", p-&gt;value);
		}
	printf("\n");
    //释放资源
	list* li = p-&gt;head;
	while (li != NULL) {
		list* temp = li;
		li = li-&gt;next;
		free(temp);
	}</code></pre> 
<h4 id="3.2%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E7%9A%84%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%C2%A0">3.2链表元素的插入、删除操作 </h4> 
<blockquote> 
 <p>数组要插入一个元素：首先我们需要把这个元素插入位置后面所有的元素后移一位，然后再增加进去。而链表就不需要这么麻烦：</p> 
 <ol><li>创建一个新的节点，并将要插入的元素存储在该节点中。</li><li>将新节点的指针指向原本插入位置上的节点，即将新节点连接到链表中。</li><li>将插入位置前一个节点的指针指向新节点，即将前一个节点与新节点连接起来。<br> 如下图：</li></ol> 
</blockquote> 
<p> <img alt="" height="201" src="https://images2.imgbox.com/52/87/RjQvh5Kq_o.png" width="1200"></p> 
<p><img alt="" height="601" src="https://images2.imgbox.com/51/72/S2kft9Ys_o.png" width="1200"></p> 
<p></p> 
<pre><code class="language-cs">void inBehind(arr* m, int locat, int value) {
	if (locat &lt; 0)
		printf("输入有误！\n");
	if (locat == 0) {
		list* l = (list*)malloc(sizeof(list));
		l-&gt;value = value;
		l-&gt;next = m-&gt;head;
		m-&gt;head = l;
	} else {
		list* p = m-&gt;head;
		for (int i = 0; i &lt; locat - 1; p = p-&gt;next, i++); //因为函数头指向了第一个list所以这里需要-1
		list* l = (list*)malloc(sizeof(list));
		l-&gt;value = value;
		l-&gt;next = p-&gt;next;
		p-&gt;next = l;
	}
}</code></pre> 
<blockquote> 
 <p>数组删除一个元素通常需要将被删除元素后面的所有元素向前移动一位，以填补被删除元素的位置。这样，就完成了元素在数组中的删除操作。相对于插入操作，数组的删除操作时间复杂度通常也是O(n)，因为需要移动后续元素。</p> 
 <p>链表删除一个元素的步骤如下：</p> 
 <ol><li>找到要删除的节点的前一个节点（如果是双向链表，还需找到后一个节点）。</li><li>将要删除的节点从链表中断开，即调整前一个节点（和后一个节点）的指针连接关系。</li></ol> 
 <p>这样，就完成了元素在链表中的删除操作。相对于数组，链表的删除操作只需要修改节点之间的指针，时间复杂度通常是O(1)。</p> 
</blockquote> 
<p> <img alt="" height="255" src="https://images2.imgbox.com/c0/4c/wVG18EMH_o.png" width="1200"></p> 
<p> <img alt="" height="536" src="https://images2.imgbox.com/2c/30/Iban8lf8_o.png" width="1200"></p> 
<p></p> 
<pre><code class="language-cs">void del(arr* m,int locat){
	list* p=m-&gt;head;
	if(locat&lt;1)
		printf("输入有误！\n");
	if(locat==1){
		list* a=p-&gt;next;
		free(p);
		m-&gt;head=a;
	}else{
		list* a=p;//让a指向p的后面 
		list* b=p-&gt;next;//b指向p的前面 
		for(int i=0;i&lt;locat-1;i++){
			b=b-&gt;next;
			p=p-&gt;next;
			if(i==locat-2)
				continue;
			a=a-&gt;next;
		}
		//循环后，p指向了要删除的地址
		a-&gt;next=b;
		free(p);	//释放资源 
	}
}</code></pre> 
<blockquote> 
 <p> 如果是插入或者删除数据在第一的元素的话需要我们单独讨论，而封装成函数的话，这时候我们需要改变head指针的指向，如果我们传入的只是head的话，是改变不了的head指针的指向的。在函数中修改指针指向的内容，不会对指针本身产生影响。如果你想修改指针本身的值（如指向不同的地址），你需要传递指针的指针或使用返回值将修改后的指针返回给调用函数。</p> 
</blockquote> 
<h3 id="4.%E5%A6%82%E4%BD%95%E8%AE%A9%E6%88%91%E4%BB%AC%E5%9C%A8%E8%AF%BB%E5%85%A5%E6%95%B0%E6%8D%AE%E6%97%B6%E9%99%8D%E4%BD%8E%E6%97%B6%E9%97%B4%E5%BC%80%E9%94%80%C2%A0">4.如何让我们在读入数据时降低时间开销 </h3> 
<blockquote> 
 <p> 避免重复遍历：在每次插入节点时，可以记录链表的尾部节点，避免每次都从头部开始遍历链表找到尾部节点。这样可以减少遍历的次数，提高效率。</p> 
</blockquote> 
<pre><code class="language-cs">typedef struct _list {
	struct _list* next;
	int value;
} list;
typedef struct {
	list* head;//链表头部
	list* behind;//链表尾部
} arr;</code></pre> 
<blockquote> 
 <p> 上面定义一个struct结构体，一个指向链表头部，一个指向链表尾部。这样每次写入数据可以减少遍历的次数。时间复杂度为O(n)。</p> 
</blockquote> 
<pre><code class="language-cs">arr a;
	arr* p = &amp;a;
	p-&gt;behind = NULL;
	p-&gt;head = NULL;
	printf("请输入添加的数据：");
	while (true) {
		int num;
		scanf("%d", &amp;num);
		if (num == -1) break;
		list* q = (list*)malloc(sizeof(list));
		q-&gt;value = num;
		q-&gt;next = NULL;
		if (p-&gt;head == NULL) {
			p-&gt;head = q; //刚开始没有数据，让链表的头和尾的地址都指向q
			p-&gt;behind = q;
		} else {
			p-&gt;behind-&gt;next = q;
			p-&gt;behind = q;
		}
	}</code></pre> 
<h2 id="%E6%80%BB%E7%BB%93"><a id="_55"></a>总结</h2> 
<blockquote> 
 <p>这篇文章主要讲述了单链表的一些操作，代码里面重要的地方也有注释的。</p> 
 <p>以后也会持续更新！！！</p> 
 <p>成功不是将来才有的，而是从决定去做的那一刻起，持续累积而成。</p> 
 <p>以上均是个人的理解，如果有不对的地方请各位大佬帮忙斧正！</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a17ac570b1a44e7b83adb3d631dc2703/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">OpenWrt安装使用教程（x86/64架构）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bc84bd620c90242f608d620a2fb793b1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HCIP第一次作业</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>