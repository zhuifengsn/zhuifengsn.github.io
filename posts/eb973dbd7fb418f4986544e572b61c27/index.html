<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C#语言入门详解（刘铁锰）---抽象类与开闭原则 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C#语言入门详解（刘铁锰）---抽象类与开闭原则" />
<meta property="og:description" content="C#语言入门详解（刘铁锰）视频教程：https://www.bilibili.com/video/BV1wx411K7rb
IDE：VS2019
.NET Core 3.1
1.概念 ///接口和抽象类（abstract）都是软件工程产物；
///具体类-&gt;抽象类-&gt;接口， 原来越抽象，内部实现的东西越来越少；
///抽象类是未完全实现逻辑的类（可以有字段和非public成员，它们代表了具体逻辑）；
///抽象类为复用而生，专门用做基类，也具有解耦作用；
///抽象类中封装确定的。开放不确定的，推迟到合适的子类中去实现；
///接口是完全未实现逻辑的“类”（纯虚类；只有函数成员；成员全部public）；
///接口为解耦而生：高内聚、低耦合，方便测试；
///接口是一个协约；
///接口和抽象类都不能实例化，只能用来声明变量，引用具体类的实例；
2.实例 /// &lt;summary&gt; 为做基类而生的抽象类与开闭原则 &lt;/summary&gt; interface IVehicle { void FillFuel(); void Run(); void Stop(); } abstract class Vehicle:IVehicle //存在抽象方法，所以为抽象类 { public void Stop() { Console.WriteLine(&#34;Stopped!&#34;); } public void FillFuel() { Console.WriteLine(&#34;pay and fill fuel&#34;); } public abstract void Run(); //抽象方法 } class Car : Vehicle { public override void Run() { Console.WriteLine(&#34;car is running." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/eb973dbd7fb418f4986544e572b61c27/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-23T22:20:07+08:00" />
<meta property="article:modified_time" content="2021-08-23T22:20:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C#语言入门详解（刘铁锰）---抽象类与开闭原则</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>C#语言入门详解（刘铁锰）视频教程：<a href="https://www.bilibili.com/video/BV1wx411K7rb" rel="nofollow">https://www.bilibili.com/video/BV1wx411K7rb</a></p> 
<p>IDE：VS2019</p> 
<p>.NET Core 3.1</p> 
<h2 style="margin-left:0px;">1.概念            </h2> 
<p style="margin-left:0;"><span style="color:#808080;">            ///</span>接口和抽象类（abstract）都是软件工程产物；</p> 
<p style="margin-left:0;">            <span style="color:#808080;">///</span>具体类-&gt;抽象类-&gt;接口， 原来越抽象，内部实现的东西越来越少；</p> 
<p style="margin-left:0;">            <span style="color:#808080;">///</span>抽象类是未完全实现逻辑的类（可以有字段和非public成员，它们代表了具体逻辑）；</p> 
<p style="margin-left:0;">            <span style="color:#808080;">///</span>抽象类为复用而生，专门用做基类，也具有解耦作用；</p> 
<p style="margin-left:0;">            <span style="color:#808080;">///</span>抽象类中封装确定的。开放不确定的，推迟到合适的子类中去实现；</p> 
<p style="margin-left:0;">            <span style="color:#808080;">///</span>接口是完全未实现逻辑的“类”（纯虚类；只有函数成员；成员全部public）；</p> 
<p style="margin-left:0;">            <span style="color:#808080;">///</span>接口为解耦而生：高内聚、低耦合，方便测试；</p> 
<p style="margin-left:0;">            <span style="color:#808080;">///</span>接口是一个协约；</p> 
<p style="margin-left:0;">            <span style="color:#808080;">///</span>接口和抽象类都不能实例化，只能用来声明变量，引用具体类的实例；</p> 
<h2 style="margin-left:0px;">2.实例</h2> 
<pre><code class="language-cs">/// &lt;summary&gt; 为做基类而生的抽象类与开闭原则 &lt;/summary&gt;
    interface IVehicle
    {
        void FillFuel();
        void Run();
        void Stop();

    }
    abstract class Vehicle:IVehicle //存在抽象方法，所以为抽象类
    {
        public void Stop() 
        {
            Console.WriteLine("Stopped!");
        }
        public void FillFuel() 
        {
            Console.WriteLine("pay and fill fuel");
        }

        public abstract void Run(); //抽象方法
    }

    class Car : Vehicle
    {
        public override void Run()
        {
            Console.WriteLine("car is running...");
        }
    }

    class TrunkCar : Vehicle
    {
        public override void Run()
        {
            Console.WriteLine("trunkcar is running...");
        }
    }
    class RaceCar : Vehicle
    {
        public override void Run()
        {
            Console.WriteLine("racecar is sunning...");
        }
    }
</code></pre> 
<h2 style="margin-left:5.65pt;">3.开闭原则</h2> 
<pre><code class="language-cs">OCP(Open  Closed  Principle)一个软件实体应该对扩展开放，对修改封闭。
上述例子中，
interface IVehicle抽象出了车辆的3个必备方法：
        void FillFuel();
        void Run();
        void Stop();

类Vehicle继承了IVehicle，
abstract class Vehicle:IVehicle 
类Vehicle实现了接口中的2个方法，对于所有车辆这两个方法是相同的
        public void Stop() 
        public void FillFuel() 
剩余的1个方法void Run()作为抽象方法开放给子类。Run()可能会根据具体车辆的不同而变化，所以声明为抽象方法留给子类去实现。
public abstract void Run(); //抽象方法
声明了3个子类，
class Car : Vehicle
class TrunkCar : Vehicle
class RaceCar : Vehicle
三个子类Car、TrunkCar、RaceCar的Run()方法很显然是不同的，分别实现了public abstract void Run()
public override void Run()
        {
            Console.WriteLine("car is running...");
        }
public override void Run()
        {
            Console.WriteLine("trunkcar is running...");
        }
        public override void Run()
        {
            Console.WriteLine("racecar is sunning...");
        }
按照上述代码组织结构，当需要给Vehicle添加新的子类时，不需要对Vehicle进行任何修改，只需要在新的子类中实现public abstract void Run()。
</code></pre> 
<p style="margin-left:0;"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/038e8f09bfe88eeffd1b99bc9e8c02a3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">循环链表.</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f117d6661928cb25a9c42a6b6facc8fa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C#语言入门详解（刘铁锰）---泛型</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>