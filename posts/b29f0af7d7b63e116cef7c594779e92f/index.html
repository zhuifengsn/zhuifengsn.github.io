<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vuex页面刷新数据丢失问题的四种解决方式 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vuex页面刷新数据丢失问题的四种解决方式" />
<meta property="og:description" content="vuex是大家使用vue时大多数都会选择的,但是当页面刷新之后vuex数据会丢失,下面这篇文章主要给大家介绍了关于vuex页面刷新数据丢失问题的四种解决方式,需要的朋友可以参考下
为什么说刷新页面vuex的数据会丢失 刷新页面vuex的数据会丢失属于正常现象，因为JS的数据都是保存在浏览器的堆栈内存里面的，刷新浏览器页面，以前堆栈申请的内存被释放，这就是浏览器的运行机制，那么堆栈里的数据自然就清空了。
第一种方法用sessionStorage 将接口返回的数据保存在vuex的store里，也将这些信息也保存在sessionStorage里。注意的是vuex中的变量是响应式的，而sessionStorage不是，当你改变vuex中的状态，组件会检测到改变，而sessionStorage就不会了，页面要重新刷新才可以看到改变，所以应让vuex中的状态从sessionStorage中得到，这样组件就可以响应式的变化。
在store文件夹里面的js文件 示例如下
const state = { authInfo: JSON.parse(sessionStorage.getItem(&#34;COMPANY_AUTH_INFO&#34;)) || {} } const getters = { authInfo: state =&gt; state.authInfo, } const mutations = { SET_COMPANY_AUTH_INFO(state, data) { state.authInfo = data sessionStorage.setItem(&#34;COMPANY_AUTH_INFO&#34;, JSON.stringify(data)) } } //actions 模块里无需使用 sessionStorage export default { namespaced: true, state, getters, mutations, //actions, } 其实这里还可以用 localStorage，但是它没有期限；所以常用的还是sessionStorage，当浏览器关闭时会话结束。
第二种方法是 vuex-along 示例如下 （1）安装 vuex-along
npm install vuex-along --save （2）在store文件夹里的index.js中引入vuex-along并配置相关代码
import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; import indexOne from &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/b29f0af7d7b63e116cef7c594779e92f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-17T21:21:10+08:00" />
<meta property="article:modified_time" content="2023-06-17T21:21:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vuex页面刷新数据丢失问题的四种解决方式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>vuex是大家使用vue时大多数都会选择的,但是当页面刷新之后vuex数据会丢失,下面这篇文章主要给大家介绍了关于vuex页面刷新数据丢失问题的四种解决方式,需要的朋友可以参考下</p> 
<h3 id="heading-0">为什么说刷新页面vuex的数据会丢失</h3> 
<p>刷新页面vuex的数据会丢失属于正常现象，因为JS的数据都是保存在浏览器的堆栈内存里面的，刷新浏览器页面，以前堆栈申请的内存被释放，这就是浏览器的运行机制，那么堆栈里的数据自然就清空了。</p> 
<h3 id="heading-1">第一种方法用sessionStorage</h3> 
<p>将接口返回的数据保存在vuex的store里，也将这些信息也保存在sessionStorage里。注意的是vuex中的变量是响应式的，而sessionStorage不是，当你改变vuex中的状态，组件会检测到改变，而sessionStorage就不会了，页面要重新刷新才可以看到改变，所以应让vuex中的状态从sessionStorage中得到，这样组件就可以响应式的变化。</p> 
<p>在store文件夹里面的js文件 示例如下</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/55/6b/YlYbba2B_o.gif"></p> 
<pre>const state = {
  authInfo: JSON.parse(sessionStorage.getItem("COMPANY_AUTH_INFO")) || {}
}

const getters = {
  authInfo: state =&gt; state.authInfo,
}
const mutations = {
  SET_COMPANY_AUTH_INFO(state, data) {
    state.authInfo = data
    sessionStorage.setItem("COMPANY_AUTH_INFO", JSON.stringify(data))
  }
}

//actions 模块里无需使用 sessionStorage

export default {
  namespaced: true,
  state,
  getters,
  mutations,
  //actions,
}</pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f1/2e/p49d4y3T_o.gif"></p> 
<p>其实这里还可以用 localStorage，但是它没有期限；所以常用的还是sessionStorage，当浏览器关闭时会话结束。</p> 
<h3 id="heading-2">第二种方法是 vuex-along</h3> 
<h4 id="heading-3">示例如下</h4> 
<p>（1）安装 vuex-along</p> 
<pre>npm install vuex-along --save</pre> 
<p>（2）在store文件夹里的index.js中引入vuex-along并配置相关代码</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/0d/99/cH084Ve8_o.gif"></p> 
<pre>import Vue from 'vue'
import Vuex from 'vuex'
import indexOne from "./modules/indexOne"
import VueXAlong from 'vuex-along'

Vue.use(Vuex)
const store=new Vuex.Store({
    strict: false,
    modules:{
        indexOne
    },
    
plugins: [VueXAlong({
        name: 'along',     //存放在localStroage或者sessionStroage 中的名字
        local: false,      //是否存放在local中  false 不存放 如果存放按照下面session的配置配
        session: { list: [], isFilter: true }   
        //如果值不为false 那么可以传递对象 其中 当isFilter设置为true时， list 数组中的值就会被过滤调,这些值不会存放在seesion或者local中
      })]

})

export default store;</pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/48/51/GqxsVs5L_o.gif"></p> 
<p></p> 
<h3 id="heading-4">第三种方法是 vuex-persistedstate</h3> 
<h4 id="heading-5">示例如下</h4> 
<p>（1）安装 vuex-persistedstate</p> 
<pre>npm install --save vuex-persistedstate</pre> 
<p> （2）在store文件夹里的index.js中引入vuex-persistedstate并配置相关代码</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/81/19/GPnKFIl2_o.gif"></p> 
<pre>import Vue from 'vue'
import Vuex from 'vuex'
import user from './modules/user'
import createPersistedState from "vuex-persistedstate"
Vue.use(Vuex)

const store = new Vuex.Store({
  modules: {
    user
  },

plugins: [createPersistedState({
    storage: window.sessionStorage,
    reducer(val) {
      return { // 只储存state中的user 
        user: val.base
      }
    }
  })]
})

export default store;</pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e4/d1/2SPsmhWF_o.gif"></p> 
<h3 id="heading-6">第四种方法是 vuex-persist</h3> 
<h4 id="heading-7">示例如下</h4> 
<p>（1）安装 vuex-persist</p> 
<pre>npm install --save vuex-persist
or
yarn add vuex-persist</pre> 
<p>（2）在store文件夹里的index.js中引入vuex-persist并配置相关代码</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c3/ac/OJibR3cu_o.gif"></p> 
<pre>import Vue from 'vue'
import Vuex from 'vuex'
import indexOne from "./modules/indexOne"
import VuexPersistence from 'vuex-persist'
Vue.use(Vuex)

const vuexLocal = new VuexPersistence({
    storage: window.localStorage
})

const store = new Vuex.Store({
    strict: false,
    modules:{
        indexOne,
    },
    plugins: [vuexLocal.plugin]
     
  }) 

export default store;</pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f7/52/Bn5ogqxV_o.gif"></p> 
<p>其实解决此问题的方法有很多,基本上都是要借助于localStorage或者sessionStroage来存放。</p> 
<p>日常开发中，遇到数据量大的时候，一般在页面刷新的时候再次请求远程数据，使之动态更新vuex数据。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8e04c71e9d9f3fc91f6aee89fa4f5a3a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux机器配置互信</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c472d69c5720bd6e75b92c91f57a06f4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算机网络层——习题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>