<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MFC线程局部存储 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MFC线程局部存储" />
<meta property="og:description" content="MFC占用系统TLS的一个槽口，将它扩展成很多个。
从程序启动说起。
// appmodul.cpp#ifndef _AFXDLLchar _afxInitAppState = (char)(AfxInitialize(FALSE, _MFC_VER), atexit(&amp;_AfxTermAppState));	// goto 10#elsechar _afxInitAppState = (char)(AfxInitialize(FALSE, _MFC_VER));#endif 上面的代码定义了一个全局变量_afxInitAppState，该全局变量初始化时调用函数AfxInitialize()，也就是它初始化了MFC的线程局部存储。
// initialize app state such that it points to this module&#39;s core state// appmodul.cppBOOL AFXAPI AfxInitialize(BOOL bDLL, DWORD dwVersion){AFX_MODULE_STATE* pModuleState = AfxGetModuleState();// ...return TRUE;} AfxInitialize函数调用AfxGetModuleState()函数。
// afxstate.cpp AFX_MODULE_STATE* AFXAPI AfxGetModuleState(){_AFX_THREAD_STATE* pState = _afxThreadState;	// ...}// afxtls_." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/d5f69309f50ef7c1f7b8f3e908c5fde7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-01-21T15:00:00+08:00" />
<meta property="article:modified_time" content="2011-01-21T15:00:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MFC线程局部存储</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>MFC占用系统TLS的一个槽口，将它扩展成很多个。</p> 
<p> </p> 
<p>从程序启动说起。</p> 
<p><textarea name="code" class="cpp:collapse:firstline[67]">// appmodul.cpp
#ifndef _AFXDLL
char _afxInitAppState = (char)(AfxInitialize(FALSE, _MFC_VER), atexit(&amp;_AfxTermAppState));		// goto 10
#else
char _afxInitAppState = (char)(AfxInitialize(FALSE, _MFC_VER));
#endif</textarea> </p> 
<p>上面的代码定义了一个全局变量_afxInitAppState，该全局变量初始化时调用函数<strong>AfxInitialize</strong>()，也就是它初始化了MFC的线程局部存储。</p> 
<p> </p> 
<p><textarea name="code" class="css:firstline[34]">// initialize app state such that it points to this module's core state
// appmodul.cpp
BOOL AFXAPI AfxInitialize(BOOL bDLL, DWORD dwVersion)
{
	AFX_MODULE_STATE* pModuleState = AfxGetModuleState();
	// ...
	return TRUE;
}</textarea> </p> 
<p>AfxInitialize函数调用<strong>AfxGetModuleState</strong>()函数。</p> 
<p> </p> 
<p><textarea name="code" class="cpp">// afxstate.cpp 
AFX_MODULE_STATE* AFXAPI AfxGetModuleState()
{
	_AFX_THREAD_STATE* pState = _afxThreadState;	
	// ...
}

// afxtls_.h 
CThreadLocal&lt;_AFX_THREAD_STATE&gt; _afxThreadState;</textarea> </p> 
<p>_afxThreadState是一个全局变量，类型为CThreadLocal&lt;_AFX_THREAD_STATE&gt;，赋值为_AFX_THREAD_STATE*类型，调用CThreadLocal的成员函数如下：</p> 
<p> </p> 
<p><textarea name="code" class="c-sharp">template&lt;class TYPE&gt;
class CThreadLocal : public CThreadLocalObject
{
	// Attributes
public:
	AFX_INLINE TYPE* GetData()
	{
		TYPE* pData = (TYPE*)CThreadLocalObject::GetData(&amp;CreateObject);
		return pData;
	}
	//...
	AFX_INLINE operator TYPE*()
	{ 
		return GetData();
	}
	//...

	// Implementation
public:
	static CNoTrackObject* AFXAPI CreateObject()
	{ return new TYPE; }
};</textarea> </p> 
<p>接下来调用父类中的CThreadLocalObject::GetData()函数，它的一个参数是一个函数指针，用于创建指定_AFX_THREAD_STATE对象。</p> 
<p><textarea name="code" class="cpp">//
// afxtls.cpp 404
CNoTrackObject* CThreadLocalObject::GetData(
	CNoTrackObject* (AFXAPI* pfnCreateObject)())
{
	if (m_nSlot == 0)
	{
		// 到这里，说明还没有分配SLOT
		if (_afxThreadData == NULL)
		{
			// MFC通过CThreadSlotData来扩展系统TLS，构造该对象时分配系统槽口
			// ,将槽口号存放在CThreadSlotData::m_tlsIndex成员中。同时，
			// _afxThreadData是全局唯一的对象，也就是它来管理MFC的TLS
			_afxThreadData = new(__afxThreadData) CThreadSlotData;
		}
		// 分配MFC槽口，分配完成后CThreadLocalObject::m_nSlot成员记录了SLOT号
		m_nSlot = _afxThreadData-&gt;AllocSlot();		
	}
	// 获取SLOT数据，存放的是指针（类型为：CNoTrackObject*）。
	CNoTrackObject* pValue = static_cast&lt;CNoTrackObject*&gt;(_afxThreadData-&gt;GetThreadValue(m_nSlot));
	if (pValue == NULL)
	{
		// 当前线程的该槽口中没有数据，先创建数据。
		pValue = (*pfnCreateObject)();

		// 设置MFC槽口数据为新分配的值
		_afxThreadData-&gt;SetValue(m_nSlot, pValue);
	}
	return pValue;
}
</textarea> <br> </p> 
<p>详细代码如下：</p> 
<p><textarea name="code" class="cpp">CThreadSlotData::CThreadSlotData()
{
	// 以CThreadData作为节点构成的链表，每个节点记录
	// 了一个线程的SLOT数组指针和SLOT数组项数。每个
	// 线程的TLS槽口保存一个CThreadData实例指针。
	m_list.Construct(offsetof(CThreadData, pNext));

	// initialize state and allocate TLS index
	m_nAlloc = 0;	// 记录了SLOT状态数组的大小。
	m_nRover = 1;   // first slot (0) is always reserved
	m_nMax = 0;		// SLOT状态数组中被占用过的最大单元序号。

	// 以CSlotData作为数据项构成的动态线性表。dwFlags标志
	// 记录了每个SLOT单元的空闲和占用状态，hInst记录了客户
	// 对象所属的模块。SLOT状态数组每次以32单位扩展。
	m_pSlotData = NULL;


	// MFC线程独立对象管理子系统只占用一个TLS槽口
	// , 申请得到的TLS槽口号保存在m_tlsIndex属性中。
	m_tlsIndex = TlsAlloc();	
	if (m_tlsIndex == (DWORD)-1)
		AfxThrowMemoryException();

	InitializeCriticalSection(&amp;m_sect);
}


//
// afxtls.cpp 157
int CThreadSlotData::AllocSlot()
{
	EnterCriticalSection(&amp;m_sect);
	int nAlloc = m_nAlloc;
	int nSlot = m_nRover;
	if (nSlot &gt;= nAlloc || (m_pSlotData[nSlot].dwFlags &amp; SLOT_USED))
	{
		// search for first free slot, starting at beginning
		for (nSlot = 1;
			nSlot &lt; nAlloc &amp;&amp; (m_pSlotData[nSlot].dwFlags &amp; SLOT_USED); nSlot++)
			;

		// if none found, need to allocate more space
		if (nSlot &gt;= nAlloc)
		{
			// realloc memory for the bit array and the slot memory
			int nNewAlloc = m_nAlloc+32;
			HGLOBAL hSlotData;
			if (m_pSlotData == NULL)
			{
				hSlotData = GlobalAlloc(GMEM_MOVEABLE, nNewAlloc * sizeof(CSlotData));
			}
			else
			{
				hSlotData = GlobalHandle(m_pSlotData);
				GlobalUnlock(hSlotData);
				hSlotData = GlobalReAlloc(hSlotData, nNewAlloc * sizeof(CSlotData), GMEM_MOVEABLE|GMEM_SHARE);
			}

			CSlotData* pSlotData = (CSlotData*)GlobalLock(hSlotData);

			// always zero initialize after success
			memset(pSlotData+m_nAlloc, 0, (nNewAlloc-m_nAlloc)*sizeof(CSlotData));
			m_nAlloc = nNewAlloc;
			m_pSlotData = pSlotData;
		}
	}

	// adjust m_nMax to largest slot ever allocated
	if (nSlot &gt;= m_nMax)
		m_nMax = nSlot+1;

	m_pSlotData[nSlot].dwFlags |= SLOT_USED;
	// update m_nRover (likely place to find a free slot is next one)
	m_nRover = nSlot+1;

	LeaveCriticalSection(&amp;m_sect);
	return nSlot;   // slot can be used for FreeSlot, GetValue, SetValue
}


inline void* CThreadSlotData::GetThreadValue(int nSlot)
{
	EnterCriticalSection(&amp;m_sect);
	if( nSlot &lt;= 0 || nSlot &gt;= m_nMax ) // check for retail builds.
	{
		LeaveCriticalSection(&amp;m_sect);
		return NULL;
	}

	CThreadData* pData = (CThreadData*)TlsGetValue(m_tlsIndex);
	if (pData == NULL || nSlot &gt;= pData-&gt;nCount)
	{
		LeaveCriticalSection(&amp;m_sect);
		return NULL;
	}
	void* pRetVal = pData-&gt;pData[nSlot];
	LeaveCriticalSection(&amp;m_sect);
	return pRetVal;
}</textarea> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/879eab7b1e226d729c4a452fdf657ab2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">qss</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5821ae07f8f88c22234932095395b551/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">u-boot在S3C2440上的移植问题及解决方法集锦（三）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>