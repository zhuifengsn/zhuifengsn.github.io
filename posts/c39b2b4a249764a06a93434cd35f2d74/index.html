<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>提升性能，避免伪共享(False Sharing)-缓存行填充7个long - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="提升性能，避免伪共享(False Sharing)-缓存行填充7个long" />
<meta property="og:description" content="技巧: padding long类型 1到7，加x变量，总共 8 * 8 = 64 个字节 等于 64位计算机 一个内存行的大小。
在多线程操作某一变量的时候，这样利用padding声明的x单独读享一个缓存行，而不是与其他变量共享内存行，所以在读取或写入变量时不用每次都因为volatile或其他语义重新load x的内存及取值，所以速度更快。
做一个测试，利用两个线程对一个volatile变量循环赋值，看看分别的耗时差多少：
public class VolatileTest { private static class Padding{ //这句注释掉会发现耗时变成了270 public volatile long p1,p2,p3,p4,p5,p6,p7; } private static class T extends Padding{ public volatile long x = 0L; } public static T[] arr = new T[2]; static { arr[0] = new T(); arr[1] = new T(); } public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(()-&gt;{ for(long a=0;a&lt;1000_0000L;a&#43;&#43;){ arr[0]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/c39b2b4a249764a06a93434cd35f2d74/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-02-24T21:47:39+08:00" />
<meta property="article:modified_time" content="2020-02-24T21:47:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">提升性能，避免伪共享(False Sharing)-缓存行填充7个long</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:#f33b45;"><strong>技巧: padding long类型 1到7，加x变量，总共 8 * 8 = 64 个字节 等于 64位计算机 一个内存行的大小。</strong></span></p> 
<p><span style="color:#f33b45;"><strong>在多线程操作某一变量的时候，这样利用padding声明的x单独读享一个缓存行，而不是与其他变量共享内存行，所以在读取或写入变量时不用每次都因为volatile或其他语义重新load x的内存及取值，所以速度更快。</strong></span></p> 
<p>做一个测试，利用两个线程对一个volatile变量循环赋值，看看分别的耗时差多少：</p> 
<pre><code class="language-java">public class VolatileTest {
    private static class Padding{
        //这句注释掉会发现耗时变成了270
        public volatile long p1,p2,p3,p4,p5,p6,p7;
    }
    private static class T extends Padding{
        public volatile long x = 0L;
    }

    public static T[] arr = new T[2];

    static {
        arr[0] = new T();
        arr[1] = new T();
    }

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(()-&gt;{
            for(long a=0;a&lt;1000_0000L;a++){
                arr[0].x = a;
            }
        });
        Thread t2 = new Thread(()-&gt;{
            for(long a=0;a&lt;1000_0000L;a++){
                arr[1].x = a;
            }
        });

        final long start = System.nanoTime();
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.println((System.nanoTime()-start)/1000000);
    }
}
</code></pre> 
<p>可以看到<br><img alt="" height="145" src="https://images2.imgbox.com/1f/5a/Ipn13L5R_o.png" width="520"></p> 
<p>当把7个用于填充缓存行的padding 注释加上以后，时间瞬间变长了好几倍</p> 
<p><img alt="" height="194" src="https://images2.imgbox.com/a3/11/CHl3nrpO_o.png" width="442"></p> 
<p><br> 转自：<a href="http://ifeve.com/falsesharing/" rel="nofollow">http://ifeve.com/falsesharing/</a></p> 
<p>原理：</p> 
<p>缓存系统中是以缓存行（cache line）为单位存储的。缓存行是2的整数幂个连续字节，一般为32-256个字节。最常见的缓存行大小是64个字节。当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。缓存行上的写竞争是运行在SMP系统中并行线程实现可伸缩性最重要的限制因素。有人将伪共享描述成无声的性能杀手，因为从代码中很难看清楚是否会出现伪共享。</p> 
<p>为了让可伸缩性与线程数呈线性关系，就必须确保不会有两个线程往同一个变量或缓存行中写。两个线程写同一个变量可以在代码中发现。为了确定互相独立的变量是否共享了同一个缓存行，就需要了解内存布局，或找个工具告诉我们。Intel VTune就是这样一个分析工具。本文中我将解释Java对象的内存布局以及我们该如何填充缓存行以避免伪共享。</p> 
<table align="center" cellpadding="0" cellspacing="0"><tbody><tr><td><a href="http://ifeve.com/wp-content/uploads/2013/01/cache-line.png" rel="nofollow"><img alt="cache-line.png" src="https://images2.imgbox.com/55/8f/Nteee9cL_o.png"></a></td></tr><tr><td>图 1.</td></tr></tbody></table> 
<p>图1说明了伪共享的问题。在核心1上运行的线程想更新变量X，同时核心2上的线程想要更新变量Y。不幸的是，这两个变量在同一个缓存行中。每个线程都要去竞争缓存行的所有权来更新变量。如果核心1获得了所有权，缓存子系统将会使核心2中对应的缓存行失效。当核心2获得了所有权然后执行更新操作，核心1就要使自己对应的缓存行失效。这会来来回回的经过L3缓存，大大影响了性能。如果互相竞争的核心位于不同的插槽，就要额外横跨插槽连接，问题可能更加严重。</p> 
<p><a name="javaMemoryLayout">Java内存布局(Java Memory Layout)</a></p> 
<p>对于HotSpot JVM，所有对象都有两个字长的对象头。第一个字是由24位哈希码和8位标志位（如锁的状态或作为锁对象）组成的Mark Word。第二个字是对象所属类的引用。如果是数组对象还需要一个额外的字来存储数组的长度。每个对象的起始地址都对齐于8字节以提高性能。因此当封装对象的时候为了高效率，对象字段声明的顺序会被重排序成下列基于字节大小的顺序：</p> 
<ol><li>doubles (8) 和 longs (8)</li><li>ints (4) 和 floats (4)</li><li>shorts (2) 和 chars (2)</li><li>booleans (1) 和 bytes (1)</li><li>references (4/8)</li><li>&lt;子类字段重复上述顺序&gt;</li></ol> 
<p>（译注：更多HotSpot虚拟机对象结构相关内容:<a href="http://www.infoq.com/cn/articles/jvm-hotspot" rel="nofollow">http://www.infoq.com/cn/articles/jvm-hotspot</a>）</p> 
<p><strong><span style="color:#f33b45;">了解这些之后就可以在任意字段间用7个long来填充缓存行。在</span><a href="http://code.google.com/p/disruptor/" rel="nofollow"><span style="color:#f33b45;">Disruptor</span></a><span style="color:#f33b45;">里我们对</span><a href="http://code.google.com/p/disruptor/source/browse/trunk/code/src/main/com/lmax/disruptor/RingBuffer.java" rel="nofollow"><span style="color:#f33b45;">RingBuffer</span></a><span style="color:#f33b45;">的cursor和</span><a href="http://code.google.com/p/disruptor/source/browse/trunk/code/src/main/com/lmax/disruptor/BatchEventProcessor.java" rel="nofollow"><span style="color:#f33b45;">BatchEventProcessor</span></a><span style="color:#f33b45;">的序列进行了缓存行填充。</span></strong></p> 
<p>为了展示其性能影响，我们启动几个线程，每个都更新它自己独立的计数器。计数器是volatile long类型的，所以其它线程能看到它们的进展。<a name="results"></a></p> 
<p> </p> 
<pre><code class="language-java">public final class FalseSharing
    implements Runnable
{
    public final static int NUM_THREADS = 4; // change
    public final static long ITERATIONS = 500L * 1000L * 1000L;
    private final int arrayIndex;
 
    private static VolatileLong[] longs = new VolatileLong[NUM_THREADS];
    static
    {
        for (int i = 0; i &lt; longs.length; i++)
        {
            longs[i] = new VolatileLong();
        }
    }
 
    public FalseSharing(final int arrayIndex)
    {
        this.arrayIndex = arrayIndex;
    }
 
    public static void main(final String[] args) throws Exception
    {
        final long start = System.nanoTime();
        runTest();
        System.out.println("duration = " + (System.nanoTime() - start));
    }
 
    private static void runTest() throws InterruptedException
    {
        Thread[] threads = new Thread[NUM_THREADS];
 
        for (int i = 0; i &lt; threads.length; i++)
        {
            threads[i] = new Thread(new FalseSharing(i));
        }
 
        for (Thread t : threads)
        {
            t.start();
        }
 
        for (Thread t : threads)
        {
            t.join();
        }
    }
 
    public void run()
    {
        long i = ITERATIONS + 1;
        while (0 != --i)
        {
            longs[arrayIndex].value = i;
        }
    }
 
    public final static class VolatileLong
    {
        public volatile long value = 0L;
        public long p1, p2, p3, p4, p5, p6; // comment out
    }
}</code></pre> 
<p><br> 结果(Results)</p> 
<p>运行上面的代码，增加线程数以及添加/移除缓存行的填充，下面的图2描述了我得到的结果。这是在我4核Nehalem上测得的运行时间。</p> 
<table align="center" cellpadding="0" cellspacing="0"><tbody><tr><td><a href="http://ifeve.com/wp-content/uploads/2013/01/duration.png" rel="nofollow"><img alt="duration.png" src="https://images2.imgbox.com/69/b3/ZpKIIi20_o.png"></a></td></tr><tr><td>图 2.</td></tr></tbody></table> 
<p>从不断上升的测试所需时间中能够明显看出伪共享的影响。没有缓存行竞争时，我们几近达到了随着线程数的线性扩展。</p> 
<p>这并不是个完美的测试，因为我们不能确定这些VolatileLong会布局在内存的什么位置。它们是独立的对象。但是经验告诉我们同一时间分配的对象趋向集中于一块。</p> 
<p>所以你也看到了，伪共享可能是无声的性能杀手。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ad5af3f3cecea08802b0e54d45618907/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">人机融合智能与深度态势感知</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d06f17d9855f07c198b943e2606e16d4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">正弦定理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>