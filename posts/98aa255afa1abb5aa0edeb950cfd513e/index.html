<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2024.2.27 模拟实现 RabbitMQ —— 网络通信设计（客户端） - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2024.2.27 模拟实现 RabbitMQ —— 网络通信设计（客户端）" />
<meta property="og:description" content="目录
需求分析
RabbitMQ 客户端设定
ConnectionFactory（连接工厂）
Connection（连接）
Channel（通道）
针对 客户端 和 服务器 单元测试
需求分析 RabbitMQ 客户端设定 一个客户端可以有多个模块每个模块均可以和 Broker Server 之间建立 &#34;逻辑上的连接&#34;（channel）这几个模块的 channel 彼此之间是相互不影响的同时这几个 channel 复用了同一个 TCP 连接此处我们将仿照 RabbitMQ 客户端设定 ConnectionFactory（连接工厂） 这个类持有服务器的地址该类用于创建 Connection 对象 具体代码编写：
import lombok.Getter; import lombok.Setter; import java.io.IOException; @Getter @Setter public class ConnectionFactory { // broker server 的 ip 地址 private String host; // broker server 的端口号 private int port; public Connection newConnection() throws IOException { Connection connection = new Connection(host,port); return connection; } // 访问 broker server 的哪个虚拟主机 // 下列几个属性暂时先不搞了 // private String virtualHostName; // private String username; // private String password; } Connection（连接） 这个类表示一个 TCP 连接，持有 Socket 对象该类用于写入请求/读取响应，管理多个 Channel 对象 具体代码编写：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/98aa255afa1abb5aa0edeb950cfd513e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-26T18:05:44+08:00" />
<meta property="article:modified_time" content="2024-02-26T18:05:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2024.2.27 模拟实现 RabbitMQ —— 网络通信设计（客户端）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90-toc" style="margin-left:0px;"><strong><a href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90" rel="nofollow">需求分析</a></strong></p> 
<p id="RabbitMQ%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%BE%E5%AE%9A-toc" style="margin-left:80px;"><strong><a href="#RabbitMQ%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%BE%E5%AE%9A" rel="nofollow">RabbitMQ 客户端设定</a></strong></p> 
<p id="ConnectionFactory%EF%BC%88%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%8E%82%EF%BC%89-toc" style="margin-left:80px;"><strong><a href="#ConnectionFactory%EF%BC%88%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%8E%82%EF%BC%89" rel="nofollow">ConnectionFactory（连接工厂）</a></strong></p> 
<p id="Connection%EF%BC%88%E8%BF%9E%E6%8E%A5%EF%BC%89-toc" style="margin-left:80px;"><strong><a href="#Connection%EF%BC%88%E8%BF%9E%E6%8E%A5%EF%BC%89" rel="nofollow">Connection（连接）</a></strong></p> 
<p id="Channel%EF%BC%88%E9%80%9A%E9%81%93%EF%BC%89-toc" style="margin-left:80px;"><strong><a href="#Channel%EF%BC%88%E9%80%9A%E9%81%93%EF%BC%89" rel="nofollow">Channel（通道）</a></strong></p> 
<p id="%E9%92%88%E5%AF%B9%20%E5%AE%A2%E6%88%B7%E7%AB%AF%20%E5%92%8C%20%E6%9C%8D%E5%8A%A1%E5%99%A8%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-toc" style="margin-left:0px;"><strong><a href="#%E9%92%88%E5%AF%B9%20%E5%AE%A2%E6%88%B7%E7%AB%AF%20%E5%92%8C%20%E6%9C%8D%E5%8A%A1%E5%99%A8%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" rel="nofollow">针对 客户端 和 服务器 单元测试</a></strong></p> 
<hr id="hr-toc"> 
<h2>需求分析</h2> 
<blockquote> 
 <h4 id="RabbitMQ%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%BE%E5%AE%9A"><strong>RabbitMQ 客户端设定</strong></h4> 
 <ul><li><strong>一个客户端可以有多个模块</strong></li><li><strong>每个模块均可以和 Broker Server 之间建立 "逻辑上的连接"（channel）</strong></li><li><strong>这几个模块的 channel 彼此之间是相互不影响的</strong></li><li><strong>同时这几个 channel 复用了同一个 TCP 连接</strong></li><li><span style="color:#fe2c24;"><strong>此处我们将仿照 RabbitMQ 客户端设定</strong></span></li></ul> 
 <hr> 
 <h4 id="ConnectionFactory%EF%BC%88%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%8E%82%EF%BC%89">ConnectionFactory（连接工厂）</h4> 
 <ul><li><strong>这个类持有服务器的地址</strong></li><li><strong>该类用于创建 Connection 对象</strong></li></ul> 
 <p><span style="color:#4da8ee;"><strong>具体代码编写：</strong></span></p> 
 <pre><code class="language-java">import lombok.Getter;
import lombok.Setter;

import java.io.IOException;

@Getter
@Setter
public class ConnectionFactory {
//    broker server 的 ip 地址
    private String host;
//    broker server 的端口号
    private int port;

    public Connection newConnection() throws IOException {
        Connection connection = new Connection(host,port);
        return connection;
    }

//    访问 broker server 的哪个虚拟主机
//    下列几个属性暂时先不搞了
//    private String virtualHostName;
//    private String username;
//    private String password;
}</code></pre> 
 <hr> 
 <h4 id="Connection%EF%BC%88%E8%BF%9E%E6%8E%A5%EF%BC%89">Connection（连接）</h4> 
 <ul><li><strong>这个类表示一个 TCP 连接，持有 Socket 对象</strong></li><li><strong>该类用于写入请求/读取响应</strong><strong>，管理多个 Channel 对象</strong></li></ul> 
 <p><span style="color:#4da8ee;"><strong>具体代码编写：</strong></span></p> 
 <ul><li><span style="color:#1c7331;"><strong>编写成员变量</strong></span></li></ul> 
 <pre><code class="language-java">    private Socket socket = null;
//    需要管理多个 channel 使用一个 hash 表把若干个 channel 组织起来
    private ConcurrentHashMap&lt;String,Channel&gt; channelMap = new ConcurrentHashMap&lt;&gt;();

    private InputStream inputStream;
    private OutputStream outputStream;
    private DataOutputStream dataOutputStream;
    private DataInputStream dataInputStream;

//用来处理 0xc 的回调，这里开销可能会很大，不希望把 扫描线程 阻塞住，因此使用 线程池 来处理
    private ExecutorService callbackPool = null;</code></pre> 
 <ul><li><span style="color:#1c7331;"><strong>编写构造方法</strong></span></li><li><span style="color:#1c7331;"><strong>此处不仅需要初始化成员变量，还需创建一个扫描线程，不停的从 socket 中读取响应数据，并将读取到的响应交给 dispatchResponse 方法执行</strong></span></li></ul> 
 <pre><code class="language-java"> public Connection(String host, int port) throws IOException {
        socket = new Socket(host,port);
        inputStream = socket.getInputStream();
        outputStream = socket.getOutputStream();
        dataInputStream = new DataInputStream(inputStream);
        dataOutputStream = new DataOutputStream(outputStream);

        callbackPool = Executors.newFixedThreadPool(4);

//        创建一个 扫描线程，由这个线程负责不停的从 socket 中取响应数据 把这个响应数据再交给对应的 channel 负责处理
        Thread t = new Thread(() -&gt; {
            try {
                while (!socket.isClosed()) {
                    Response response = readResponse();
                    dispatchResponse(response);
                }
            }catch (SocketException e) {
//                连接正常断开，此时这个异常直接忽略
                System.out.println("[Connection] 连接正常断开！");
            }catch (IOException | ClassNotFoundException | MqException e) {
                System.out.println("[Connection] 连接异常断开！");
                e.printStackTrace();
            }
        });
        t.start();
    }</code></pre> 
 <ul><li><span style="color:#1c7331;"><strong>编写 dispatchResponse 方法</strong></span></li><li><span style="color:#1c7331;"><strong>使用该方法来区分，当前响应是一个针对控制请求的响应，还是服务器推送过来的消息</strong></span></li><li><span style="color:#1c7331;"><strong>如果是服务器推送过来的消息，type = 0xc，也就需要执行回调，通过线程池来执行</strong></span></li><li><span style="color:#1c7331;"><strong>如果只是一个普通的响应，就将该结果放到 channel 的 哈希表中</strong></span></li><li><span style="color:#1c7331;"><strong>随后 channel 的 putReturns 方法会唤醒所有阻塞等待的线程，让这些线程从 哈希表中拿与自己 rid 相等的返回结果</strong></span></li></ul> 
 <pre><code class="language-java">//    使用这个方法来分别处理，当前的响应是一个针对控制请求的响应，还是服务器推送的消息
    private void dispatchResponse(Response response) throws IOException, ClassNotFoundException, MqException {
        if(response.getType() == 0xc) {
//            服务器推送来的消息数据
            SubScribeReturns subScribeReturns = (SubScribeReturns) BinaryTool.fromBytes(response.getPayload());
//            根据 channelId 找到对应的 channel 对象
            Channel channel = channelMap.get(subScribeReturns.getChannelId());
            if(channel == null) {
                throw new MqException("[Connection] 该消息对应的 channel 在客户端中不存在！channelId = " + channel.getChannelId());
            }
//            执行该 channel 对象内部的回调
//            此处我们直接将回调方法交给线程池来执行，而不是用扫描线程来执行
            callbackPool.submit(() -&gt; {
                try {
                    channel.getConsumer().handleDelivery(subScribeReturns.getConsumerTag(),subScribeReturns.getBasicProperties(),
                            subScribeReturns.getBody());
                } catch (MqException | IOException e) {
                    e.printStackTrace();
                }
            });
        }else {
//            当前响应是针对刚才控制请求的响应
            BasicReturns basicReturns = (BasicReturns) BinaryTool.fromBytes(response.getPayload());
//            把这个结果放到对应的 channel 的 hash 表中
            Channel channel = channelMap.get(basicReturns.getChannelId());
            if(channel == null) {
                throw new MqException("[Connection] 该消息对应的 channel 在客户端中不存在！channelId = " + channel.getChannelId());
            }
            channel.putReturns(basicReturns);
        }
    }</code></pre> 
 <ul><li><span style="color:#1c7331;"><strong>编写 发送请求 与 读取响应 的方法</strong></span></li></ul> 
 <pre><code class="language-java">//    发送请求
    public void writeRequest(Request request) throws IOException {
        dataOutputStream.writeInt(request.getType());
        dataOutputStream.writeInt(request.getLength());
        dataOutputStream.write(request.getPayload());
        dataOutputStream.flush();
        System.out.println("[Connection] 发送请求！ type = " + request.getType() + ",length = " + request.getLength());
    }

//    读取响应
    public Response readResponse() throws IOException {
        Response response = new Response();
        response.setType(dataInputStream.readInt());
        response.setLength(dataInputStream.readInt());
        byte[] payload = new byte[response.getLength()];
        int n = dataInputStream.read(payload);
        if(n != payload.length) {
            throw new IOException("读取的响应数据不完整！");
        }
        response.setPayload(payload);
        System.out.println("[Connection] 收到响应！ type = " + response.getType() + ",length = " + response.getLength());
        return response;
    }</code></pre> 
 <ul><li><span style="color:#1c7331;"><strong>编写创建 channel 的方法</strong></span></li></ul> 
 <p><span style="color:#0d0016;"><strong>注意：</strong></span></p> 
 <p></p> 
 <ul><li><strong>我们的代码中使用了多次 UUID </strong></li><li><strong>message 的 id，就是用 UUID 当时加了个 M- 前缀</strong></li><li><strong>现在 channel 的 id 也是使用 UUID 此时加个 C- 前缀</strong></li><li><strong>rid 也使用 UUID 来生成，加个前缀  R-</strong></li></ul> 
 <pre><code class="language-java">//    通过这个方法，在 Connection 中能够创建出一个 Channel
    public Channel createChannel() throws IOException, InterruptedException {
        String channelId = "C-" + UUID.randomUUID().toString();
        Channel channel = new Channel(channelId,this);
//        把这个 channel 对象放到 Connection 管理 channel 的 哈希表 中
        channelMap.put(channelId,channel);
//        同时也需要把 创建 channel 的这个消息也告诉服务器
        boolean ok = channel.createChannel();
        if(!ok) {
//            服务器这里创建失败了！！整个这次创建 channel 操作不顺利！
//            把刚才已经加入 hash 表的键值对，再删了
            channelMap.remove(channelId);
            return null;
        }
        return channel;
    }</code></pre> 
 <ul><li><span style="color:#1c7331;"><strong>编写释放 Connection 相关资源的方法</strong></span></li></ul> 
 <pre><code class="language-java">    public void close() {
//        关闭 Connection 释放上述资源
        try {
            callbackPool.shutdownNow();
            channelMap.clear();
            inputStream.close();
            outputStream.close();
            socket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }</code></pre> 
 <hr> 
 <h4 id="Channel%EF%BC%88%E9%80%9A%E9%81%93%EF%BC%89">Channel（通道）</h4> 
 <ul><li> <p><strong>这个类表示一个逻辑上的连接</strong></p> </li><li> <p><strong>该类用于提供一系列的方法，去和服务器提供的核心 API 相对应</strong></p> </li><li> <p><strong>客户端提供的这些方法，其方法内部就是发送了一个特定的请求</strong></p> </li></ul> 
 <p><span style="color:#4da8ee;"><strong>具体代码编写：</strong></span></p> 
 <ul><li><span style="color:#1c7331;"><strong>编写成员变量  与 构造方法</strong></span></li></ul> 
 <pre><code class="language-java">    private String channelId;
//    当前这个 channel 属于哪个连接的
    private Connection connection;
//    用来存储后续客户端收到的服务器的响应
    private ConcurrentHashMap&lt;String, BasicReturns&gt; basicReturnsMap = new ConcurrentHashMap&lt;&gt;();
//    如果当前 Channel 订阅了某个队列，就需要在此处记录下对应回调是啥，当该队列的消息返回回来的时候，调用回调
//    此处约定一个 Channel 中只能有一个回调
    private Consumer consumer = null;

    public Channel(String channelId,Connection connection) {
        this.channelId = channelId;
        this.connection = connection;
    }</code></pre> 
 <ul><li><span style="color:#1c7331;"><strong>实现 type = 0x1，即创建 channel</strong></span></li><li><span style="color:#1c7331;"><strong>构造请求发给服务器，随后阻塞等待，唤醒后从 basicReturnsMap 中尝试获取响应结果</strong></span></li><li><span style="color:#1c7331;"><strong>其余 type （0xc 除外，因为 0xc 只有响应没有请求）类型的请求与 0x1 大差不差，对着所需参数，构造即可</strong></span></li></ul> 
 <pre><code class="language-java">//    在这个方法中，和服务器进行交互，告知服务器，此处客户端创建了新的 channel 了
    public Boolean createChannel() throws IOException, InterruptedException {
//        对于创建 Channel 来说，
        BasicArguments basicArguments = new BasicArguments();
        basicArguments.setChannelId(channelId);
        basicArguments.setRid(generateRid());
        byte[] payload = BinaryTool.toBytes(basicArguments);

        Request request = new Request();
        request.setType(0x1);
        request.setLength(payload.length);
        request.setPayload(payload);

//        构造出完整请求之后，就可以发送这个请求了
        connection.writeRequest(request);
//        等待服务器的响应
        BasicReturns basicReturns = waitResult(basicArguments.getRid());
        return basicReturns.isOk();
    }

    private String generateRid() {
        return "R-" + UUID.randomUUID().toString();
    }

//    期望使用这个方法来阻塞等待服务器的响应
    private BasicReturns waitResult(String rid) throws InterruptedException {
        BasicReturns basicReturns = null;
        while ((basicReturns = basicReturnsMap.get(rid)) == null) {
//            如果查询结果为 null，说明响应还没回来
//            此时就需要阻塞等待
            synchronized (this) {
                wait();
            }
        }
//        读取成功之后，还需要把这个消息从 哈希表中给删除掉
        basicReturnsMap.remove(rid);
        System.out.println("[Channel] 获取到服务器响应！rid = " + rid);
        return basicReturns;
    }

    public void putReturns(BasicReturns basicReturns) {
        basicReturnsMap.put(basicReturns.getRid(),basicReturns);
        synchronized (this) {
//            当前也不知道有多少个线程在等待上述的这个响应
//            把所有的等待的线程都唤醒
            notifyAll();
        }
    }</code></pre> 
 <ul><li><span style="color:#1c7331;"><strong>特别注意 type = 0xa ，即 订阅消息</strong></span></li></ul> 
 <p><img alt="" height="856" src="https://images2.imgbox.com/90/ed/tPXVRxQi_o.png" width="1200"></p> 
 <ul><li><span style="color:#fe2c24;"><strong>其次值得注意的是 consumerTag 使用 channelId 来表示</strong></span></li></ul> 
 <pre><code class="language-java">//    订阅消息
    public boolean basicConsume(String queueName, boolean autoAck, Consumer consumer) throws MqException, IOException, InterruptedException {
//        先设置回调
        if(this.consumer != null) {
            throw new MqException("该 channel 已经设置过消费消息的回调了，不能重复设置！");
        }
        this.consumer = consumer;
        BasicConsumeArguments basicConsumeArguments = new BasicConsumeArguments();
        basicConsumeArguments.setRid(generateRid());
        basicConsumeArguments.setChannelId(channelId);
//        此处 ConsumerTag 也使用 channelId 来表示
        basicConsumeArguments.setConsumerTag(channelId);
        basicConsumeArguments.setQueueName(queueName);
        basicConsumeArguments.setAutoAck(autoAck);
        byte[] payload = BinaryTool.toBytes(basicConsumeArguments);

        Request request = new Request();
        request.setType(0xa);
        request.setLength(payload.length);
        request.setPayload(payload);

        connection.writeRequest(request);
        BasicReturns basicReturns = waitResult(basicConsumeArguments.getRid());
        return basicReturns.isOk();
    }</code></pre> 
</blockquote> 
<h2 id="%E9%92%88%E5%AF%B9%20%E5%AE%A2%E6%88%B7%E7%AB%AF%20%E5%92%8C%20%E6%9C%8D%E5%8A%A1%E5%99%A8%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">针对 客户端 和 服务器 单元测试</h2> 
<blockquote> 
 <ul><li><strong>编写测试用例代码是十分重要的！</strong></li></ul> 
 <pre><code class="language-java">package com.example.demo;

import com.example.demo.common.Consumer;
import com.example.demo.common.MqException;
import com.example.demo.mqclient.Channel;
import com.example.demo.mqclient.Connection;
import com.example.demo.mqclient.ConnectionFactory;
import com.example.demo.mqserver.BrokerServer;
import com.example.demo.mqserver.core.BasicProperties;
import com.example.demo.mqserver.core.ExchangeType;
import org.apache.tomcat.util.http.fileupload.FileUtils;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.boot.SpringApplication;

import java.io.File;
import java.io.IOException;

public class MqClientTests {
    private BrokerServer brokerServer = null;
    private ConnectionFactory connectionFactory = null;
    private Thread t = null;

    @BeforeEach
    public void setUp() throws IOException {
//        1、先启动服务器
        DemoApplication.context = SpringApplication.run(DemoApplication.class);
        brokerServer = new BrokerServer(9090);
        t = new Thread(() -&gt; {
//        这个 start 方法会进入一个死循环，使用一个新的线程来运行 start 即可！
            try {
                brokerServer.start();
            } catch (IOException e) {
                e.printStackTrace();
            }
        });
        t.start();

//        2、配置 ConnectionFactory
        connectionFactory = new ConnectionFactory();
        connectionFactory.setHost("127.0.0.1");
        connectionFactory.setPort(9090);

    }

    @AfterEach
    public void tearDown() throws IOException {
//        停止服务器
        brokerServer.stop();
//        t.join();
        DemoApplication.context.close();

//        删除必要的文件
        File file = new File("./data");
        FileUtils.deleteDirectory(file);

        connectionFactory = null;
    }

    @Test
    public void testConnection() throws IOException {
        Connection connection = connectionFactory.newConnection();
        Assertions.assertNotNull(connection);
    }

    @Test
    public void testChannel() throws IOException, InterruptedException {
        Connection connection = connectionFactory.newConnection();
        Assertions.assertNotNull(connection);
        Channel channel = connection.createChannel();
        Assertions.assertNotNull(channel);
    }

    @Test
    public void testExchange() throws IOException, InterruptedException {
        Connection connection = connectionFactory.newConnection();
        Assertions.assertNotNull(connection);
        Channel channel = connection.createChannel();
        Assertions.assertNotNull(channel);

        boolean ok = channel.exchangeDeclare("testExchange", ExchangeType.DIRECT,true,false,null);
        Assertions.assertTrue(ok);

        ok = channel.exchangeDelete("testExchange");
        Assertions.assertTrue(ok);

//        此处稳妥起见，把该关闭的要进行关闭
        channel.close();
        connection.close();
    }

    @Test
    public void testQueue() throws IOException, InterruptedException{
        Connection connection = connectionFactory.newConnection();
        Assertions.assertNotNull(connection);
        Channel channel = connection.createChannel();
        Assertions.assertNotNull(channel);

        boolean ok = channel.queueDeclare("testQueue",true,false,false,null);
        Assertions.assertTrue(ok);

        ok = channel.queueDelete("testQueue");
        Assertions.assertTrue(ok);

        channel.close();
        connection.close();
    }

    @Test
    public void testBinding() throws IOException, InterruptedException{
        Connection connection = connectionFactory.newConnection();
        Assertions.assertNotNull(connection);
        Channel channel = connection.createChannel();
        Assertions.assertNotNull(channel);

        boolean ok = channel.exchangeDeclare("testExchange", ExchangeType.DIRECT,true,false,null);
        Assertions.assertTrue(ok);

        ok = channel.queueDeclare("testQueue",true,false,false,null);
        Assertions.assertTrue(ok);

        ok = channel.queueBind("testQueue","testExchange","testBindingKey");
        Assertions.assertTrue(ok);

        ok = channel.queueUnbind("testQueue","testExchange");
        Assertions.assertTrue(ok);

        channel.close();
        connection.close();
    }

    @Test
    public void testMessage() throws IOException, InterruptedException, MqException {
        Connection connection = connectionFactory.newConnection();
        Assertions.assertNotNull(connection);
        Channel channel = connection.createChannel();
        Assertions.assertNotNull(channel);

        boolean ok = channel.exchangeDeclare("testExchange", ExchangeType.DIRECT,true,false,null);
        Assertions.assertTrue(ok);

        ok = channel.queueDeclare("testQueue",true,false,false,null);
        Assertions.assertTrue(ok);

        byte[] requestBody = "hello".getBytes();
        ok = channel.basicPublish("testExchange","testQueue",null,requestBody);
        Assertions.assertTrue(ok);

        channel.basicConsume("testQueue", true, new Consumer() {
            @Override
            public void handleDelivery(String consumerTag, BasicProperties basicProperties, byte[] body) throws MqException, IOException {
                System.out.println("[消费数据] 开始！");
                System.out.println("consumeTag = " + consumerTag);
                System.out.println("basicProperties = " + basicProperties);
                Assertions.assertArrayEquals(requestBody,body);
                System.out.println("[消费数据] 结束！");
            }
        });
        Assertions.assertTrue(ok);

        Thread.sleep(500);

        channel.close();
        connection.close();
    }
}
</code></pre> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/21cd5401b8128900a08ab05510a1c774/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">WPF 附加属性&#43;控件模板，完成自定义控件。建议观看HandyControl源码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3dc34280783f5cdf4eeba8afd75a90f7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Unity】如何从现有项目中抽取好用的资源</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>