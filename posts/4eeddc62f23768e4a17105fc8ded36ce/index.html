<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android基础开发-数据存储 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android基础开发-数据存储" />
<meta property="og:description" content="SharedPreferences-xml 共享参数的用法
SharedPreferences是Android的一个轻量级存储工具，采用的存储结构是Key-Value的
键值对方式。
共享参数的存储介质是符合XML规范的配置文件。保存路径是:/data/data/应用包名/shared_prefs/文件名.xml
类似于java中的*.properties的配置文件
共享参数的使用场景
共享参数主要适用于如下场合:
简单且孤立的数据。若是复杂且相互间有关的数据，则要保存在数据库中。
文本形式的数据。若是二进制数据，则要保存在文件中。
需要持久化存储的数据。在App退出后再次启动时，之前保存的数据仍然有效。
实际开发中，共享参数经常存储的数据有App的个性化配置信息、用户使用App的行为信
息、临时需要保存的片段信息等。
程序闪退，保存到内存中的信息是没有的。
//data目录下，创建一个config.xml的文件 SharedPreferences config = getSharedPreferences(&#34;config&#34;, Context.MODE_PRIVATE); SharedPreferences.Editor edit = config.edit(); edit.putString(&#34;hello&#34;,&#34;world&#34;); edit.commit(); String hello = config.getString(&#34;hello&#34;,&#34;&#34;); &lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39; standalone=&#39;yes&#39; ?&gt; &lt;map&gt; &lt;string name=&#34;hello&#34;&gt;world&lt;/string&gt; &lt;/map&gt; 数据库SQLite-*.sql sQLiteDatabase是SQLiteH0B法有3类:
管理类，用于数据库层面的操作。
openDatabase:打开指定路径的数据库。
isOpen:判断数据库是否已打开。
close:关闭数据库。
getVersion:获取数据库的版本号。
setVersion:设置数据库的版本号。
SQLiteDatabase sqLiteDatabase = openOrCreateDatabase(getFilesDir() &#43; &#34;/test.db&#34;, Context.MODE_PRIVATE, null); String path = sqLiteDatabase.getPath(); Toast.makeText(this,&#34;path的值==&#34;&#43;path, Toast.LENGTH_SHORT).show(); // deleteDatabase(getFilesDir() &#43; &#34;/test.db&#34;); 数据库管理器SQLiteDatabase
事务类,用于事务层面的操作。
beginTransaction:开始事务。
setTransactionSuccessful:设置事务的成功标志。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/4eeddc62f23768e4a17105fc8ded36ce/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-26T09:17:27+08:00" />
<meta property="article:modified_time" content="2024-02-26T09:17:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android基础开发-数据存储</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>SharedPreferences-xml</h2> 
<p>共享参数的用法<br> SharedPreferences是Android的一个轻量级存储工具，采用的存储结构是Key-Value的<br> 键值对方式。<br> 共享参数的存储介质是符合XML规范的配置文件。保存路径是:/data/data/应用包名/shared_prefs/文件名.xml</p> 
<p>类似于java中的*.properties的配置文件</p> 
<p>共享参数的使用场景<br> 共享参数主要适用于如下场合:<br> 简单且孤立的数据。若是复杂且相互间有关的数据，则要保存在数据库中。<br> 文本形式的数据。若是二进制数据，则要保存在文件中。<br> 需要持久化存储的数据。在App退出后再次启动时，之前保存的数据仍然有效。<br> 实际开发中，<strong>共享参数经常存储的数据有App的个性化配置信息、用户使用App的行为信<br> 息、临时需要保存的片段信息等</strong>。</p> 
<p>程序闪退，保存到内存中的信息是没有的。</p> 
<pre><code class="language-java">//data目录下，创建一个config.xml的文件
        SharedPreferences config = getSharedPreferences("config", Context.MODE_PRIVATE);
        SharedPreferences.Editor edit = config.edit();
        edit.putString("hello","world");
        edit.commit();

        String hello = config.getString("hello","");</code></pre> 
<pre><code class="language-XML">&lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?&gt;
&lt;map&gt;
    &lt;string name="hello"&gt;world&lt;/string&gt;
&lt;/map&gt;</code></pre> 
<p></p> 
<h2>数据库SQLite-*.sql</h2> 
<p>sQLiteDatabase是SQLiteH0B法有3类:<br> 管理类，用于数据库层面的操作。<br>     openDatabase:打开指定路径的数据库。<br>     isOpen:判断数据库是否已打开。<br>     close:关闭数据库。<br>     getVersion:获取数据库的版本号。<br>     setVersion:设置数据库的版本号。</p> 
<pre><code class="language-java">
        SQLiteDatabase sqLiteDatabase = openOrCreateDatabase(getFilesDir() + "/test.db", Context.MODE_PRIVATE, null);
        String path = sqLiteDatabase.getPath();
        Toast.makeText(this,"path的值=="+path, Toast.LENGTH_SHORT).show();

//        deleteDatabase(getFilesDir() + "/test.db");</code></pre> 
<p><img alt="" height="147" src="https://images2.imgbox.com/7a/54/u4REknf5_o.png" width="373"></p> 
<p>数据库管理器SQLiteDatabase<br>     事务类,用于事务层面的操作。<br>         beginTransaction:开始事务。<br>         setTransactionSuccessful:设置事务的成功标志。<br>         endTransaction:结束事务。</p> 
<p>数据处理类,用于数据表层面的操作。<br>     execSQL:执行拼接好的SQL控制语句。<br>     delete:删除符合条件的记录。<br>     update:更新符合条件的记录。<br>     insert:插入一条记录。<br>     query:执行查询操作，返回结果集的游标。<br>     rawQuery:执行拼接好的SQL查询语句，返回结果集的游标。</p> 
<h2>存储卡文件操作</h2> 
<p>公共区域：</p> 
<p>        1、所有应用都可以访问的公用区域</p> 
<p>        2、仅有A应用访问的私有空间区域</p> 
<p>        3、仅有B应用访问的私有空间区域</p> 
<pre><code class="language-java">package com.pshdhx.utils;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class FileUtil {
    //把字符串保存到指定路径的文本文件
    public static void saveText(String path,String txt){
        BufferedWriter os = null;
        try{
            os = new BufferedWriter(new FileWriter(path));
            os.write(txt);
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            if(os != null){
                try {
                    os.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    //从指定路径的文本文件读取字符串
    public static String openTxt(String path){
        StringBuffer sb = new StringBuffer();
        BufferedReader br = null;
        try{
            br = new BufferedReader(new FileReader(path));
            String line = null;
            while ((line = br.readLine()) != null){
                sb.append(line);
            }
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            if(br != null){
                try {
                    br.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        return sb.toString();
    }
}
</code></pre> 
<pre><code class="language-java"> //外部存储的私有空间
        String path1 = getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS).toString();
        path1 = path1 + File.separatorChar + "myFileName.txt";
        FileUtil.saveText(path1,"hhhhhh哈哈哈");

        //外部存储的公共空间
        //注册清单文件开启读写权限
        String s = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).toString();
</code></pre> 
<pre>&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;
&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt;
android:requestLegacyExternalStorage="true"</pre> 
<p>storage和SD卡的目录，其实就是一个映射。</p> 
<p><img alt="" height="385" src="https://images2.imgbox.com/18/2c/H62BDpIV_o.png" width="504"></p> 
<h2> 在存储卡上读取图片</h2> 
<p>将图片缓存到缓存里，不用每次读取图片都要从网络中获取。</p> 
<p>Android 的位图工具是Bitmap，App读写Bitmap可以使用性能更好的</p> 
<p>BufferedOutputStream和BufferedInputStream。<br> Android还提供了BitmapFactory工具用于读取各种来源的图片，相关方法如下:<br> decodeResource:该方法可从资源文件中读取图片信息。<br> decodeFile:该方法可将指定路径的图片读取到Bitmap对象。</p> 
<p>decodeStream:该方法从输入流中读取位图数据。</p> 
<h3>实现效果：</h3> 
<p>将图片读取到外部存储里边保存，然后从保存的位置再读取到ImageView显示</p> 
<p><img alt="" height="410" src="https://images2.imgbox.com/41/07/56vuNY1T_o.png" width="506"></p> 
<p><img alt="" height="461" src="https://images2.imgbox.com/73/c6/n25udxQc_o.png" width="377"></p> 
<h3>代码：</h3> 
<pre><code class="language-java">@Override
    public void onClick(View v) {
        switch (v.getId()){
            case R.id.save_pic:
                String fileName = System.currentTimeMillis()+".jpeg";
                path = getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS).toString()+ File.pathSeparatorChar+fileName;
                System.out.println("path = " + path);
                Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.dog);
                FileUtil.saveImage(path,bitmap);
                //ToastUtil.showMsg(this,"图片保存成功！");
                System.out.println("图片保存成功！");
                break;
            case R.id.read_pic:
              Bitmap bitmap1 = FileUtil.openImage(path);
                picShow.setImageBitmap(bitmap1);

                Bitmap bitmap2 = BitmapFactory.decodeFile(path);
                picShow.setImageBitmap(bitmap2);

                picShow.setImageURI(Uri.parse(path));
                break;
        }

    }</code></pre> 
<pre><code class="language-java">  public static void saveImage(String path, Bitmap bitmap) {
        FileOutputStream fos = null;
        try {
            fos = new FileOutputStream(path);
            bitmap.compress(Bitmap.CompressFormat.JPEG, 100, fos);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (fos != null) {
                try {
                    fos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

    }

    public static Bitmap openImage(String path) {
        Bitmap bitmap = null;
        FileInputStream fis = null;
        try {
            fis = new FileInputStream(path);
            bitmap = BitmapFactory.decodeStream(fis);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        return bitmap;
    }</code></pre> 
<h2 style="background-color:transparent;">Application</h2> 
<p>Application是android的一大组件，在App运行过程中有且仅有一个Application对象贯彻整个生命周期。</p> 
<pre><code class="language-java">package com.pshdhx.middleComponent;

import android.app.Application;
import android.content.res.Configuration;

public class MyApplication extends Application {

    private static MyApplication mApp;
    public static MyApplication getInstance(){
        return mApp;
    }

    //App启动时，调用
    @Override
    public void onCreate() {
        mApp = this;
        super.onCreate();
    }

    //App终止时，调用--不给开发者使用
    @Override
    public void onTerminate() {
        super.onTerminate();
    }

    //在配置改变时，调用。比如说横屏变为竖屏【屏幕旋转时，会重新创建activity】
    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
    }
}
</code></pre> 
<p>接着下activity中，就可以使用application类中的map对象了，供所有的activity使用。</p> 
<p>主要存取3类数据：</p> 
<p>1、用户名、手机号</p> 
<p>2、不方便由意图传递的数据。例如位图对象、非字符串类型的集合对象。</p> 
<p>3、容易因频繁分配内存到导致内存泄露的对象，如Handler对象等。</p> 
<h2 style="background-color:transparent;">利用Room简化数据库操作</h2> 
<p>实体类：</p> 
<pre><code class="language-java">@Dao
public interface BookDao {
    @Insert
    void insert(Book... book);

    @Update
    void upd(Book... book);

    @Delete
    void del(Book... book);

    @Query("select * from book")
    List&lt;Book&gt; qry(Book... book);

    @Query("select * from book where name = :name order by  id desc")
    List&lt;Book&gt; qryByName(String name);
}</code></pre> 
<p>Application</p> 
<pre><code class="language-java"> //App启动时，调用
    @Override
    public void onCreate() {
        mApp = this;
        super.onCreate();
        bookDataBase = Room.databaseBuilder(this,BookDataBase.class,"book")
                //允许迁移数据库【如果没有添加，发生数据库变更时，Room默认会删除原数据库再创建新数据库，如此原来的数据会丢失】
                .addMigrations()
                //允许在主线程中操作数据库
                .allowMainThreadQueries()
                .build();

    }



    public BookDataBase getBookDataBase(){
        return bookDataBase;
    }</code></pre> 
<p>activity使用：</p> 
<pre><code class="language-java">bookDao = MyApplication.getInstance().getBookDataBase().bookDao();

@Override
    public void onClick(View v) {
        String inputBookName = bookName.getText().toString();
        String inputBookAuthor = author.getText().toString();
        switch (v.getId()) {
            case R.id.book_add:
                Book b1 = new Book();
                b1.setName(inputBookName);
                b1.setAuthor(inputBookAuthor);
                bookDao.insert(b1);
                break;

        }
    }</code></pre> 
<p> </p> 
<pre><code class="language-java">@Database(entities = {Book.class},version = 1,exportSchema = true)
public abstract class BookDataBase extends RoomDatabase {

    public abstract BookDao bookDao();
}</code></pre> 
<p></p> 
<h2 style="background-color:transparent;">android常用框架组件</h2> 
<p>1、Jetpack</p> 
<p>        MVC MVP MVVM</p> 
<p>        androidx</p> 
<p>        Jetpack组成</p> 
<p>2、LifeCycle</p> 
<p>        LifeCycle解耦页面和组件</p> 
<p>        LifeCycleService解耦service和组件</p> 
<p>        ProcessLifecycleOwner监听程序与生命周期</p> 
<p>3、ViewModel</p> 
<p>        作用与应用</p> 
<p>        生命周期特性</p> 
<p>        AndroidViewModel</p> 
<p>4、LiveData</p> 
<p>        应用与优势</p> 
<p>        ViewModel+liveData实现Fragment间通信</p> 
<p>5、DataBinding</p> 
<p>        DataBinding意义与应用、ActivityMainBinding的由来</p> 
<p>        二级页面的绑定</p> 
<p>        自定义BindingAdapter加载网络图片与参数可选</p> 
<p>        双向绑定BaseOvservable与ObservableField</p> 
<p>        RecyclerView的绑定</p> 
<p>        DataBinding+ViewModel+LivaData整合</p> 
<p>6、MVVM架构设计</p> 
<p>        MVVM架构与Jetpack</p> 
<p>        数据模型驱动界面更新</p> 
<p>        使用Jetpack组件构建MVVM应用程序</p> 
<p>7、Room</p> 
<p>        Android官方的ORM库</p> 
<p>        Room+ViewModel+LiveData</p> 
<p>        使用Migration升级数据库</p> 
<p>        异常处理</p> 
<p>        Schema文件记录排查问题</p> 
<p>        销毁和重建策略</p> 
<p>        欲填充数据库</p> 
<p>8、Navigation</p> 
<p>9、WorkManager</p> 
<p>10、Paging</p> 
<p>11、Compose</p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8627eb01a4d8b2720233e766faecfda2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">哪种文件摆渡系统 可以实现跨网文件安全收发？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/390fe0ce4adda5d5928757be23fed9e0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux--串口屏显示控制实验</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>