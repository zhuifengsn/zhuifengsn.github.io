<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c语言位域 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c语言位域" />
<meta property="og:description" content="一 位域 1.1 概述 ：C 语言的位域（bit-field）是一种特殊的结构体成员，允许我们按位对成员进行定义，指定其占用的位数 注意这里说的是位数 不是字节
如果程序的结构中包含多个开关的变量，即变量值为 TRUE/FALSE，如下：
struct { unsigned int widthValidated; unsigned int heightValidated; } status; 这种结构需要 8 字节的内存空间，但在实际上，在每个变量中，我们只存储 0 或 1，在这种情况下，C 语言提供了一种更好的利用内存空间的方式。如果您在结构内使用这样的变量，您可以定义变量的宽度来告诉编译器，您将只使用这些字节。例如，上面的结构可以重写成
struct { unsigned int widthValidated : 1; unsigned int heightValidated : 1; } status; 现在，上面的结构中，status 变量将占用 4 个字节的内存空间，但是只有 2 位被用来存储值。如果您用了 32 个变量，每一个变量宽度为 1 位，那么 status 结构将使用 4 个字节，但只要您再多用一个变量，如果使用了 33 个变量，那么它将分配内存的下一段来存储第 33 个变量，这个时候就开始使用 8 个字节。让我们看看下面的实例来理解这个概念
#include &lt;stdio.h&gt; #include &lt;string.h&gt; /* 定义简单的结构 */ struct { unsigned int widthValidated; unsigned int heightValidated; } status1; /* 定义位域结构 */ struct { unsigned int widthValidated : 1; unsigned int heightValidated : 1; } status2; int main( ) { printf( &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/fb597e3e8cde07b8f291d014ae4bc302/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-18T15:26:30+08:00" />
<meta property="article:modified_time" content="2024-02-18T15:26:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c语言位域</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一 位域</h2> 
<h3>1.1 概述</h3> 
<p>：C 语言的位域（bit-field）是一种特殊的结构体成员，允许我们按位对成员进行定义，指定其占用的位数 注意这里说的是位数 不是字节</p> 
<p>如果程序的结构中包含多个开关的变量，即变量值为 <strong>TRUE/FALSE</strong>，如下：</p> 
<pre><code class="language-cs">struct
{
  unsigned int widthValidated;
  unsigned int heightValidated;
} status;
</code></pre> 
<p>这种结构需要 8 字节的内存空间，但在实际上，在每个变量中，我们只存储 0 或 1，在这种情况下，C 语言提供了一种更好的利用内存空间的方式。如果您在结构内使用这样的变量，您可以定义变量的宽度来告诉编译器，您将只使用这些字节。例如，上面的结构可以重写成</p> 
<pre><code class="language-cs">struct
{
  unsigned int widthValidated : 1;
  unsigned int heightValidated : 1;
} status;
</code></pre> 
<p>现在，上面的结构中，status 变量将占用 4 个字节的内存空间，但是只有 2 位被用来存储值。如果您用了 32 个变量，每一个变量宽度为 1 位，那么 status 结构将使用 4 个字节，但只要您再多用一个变量，如果使用了 33 个变量，那么它将分配内存的下一段来存储第 33 个变量，这个时候就开始使用 8 个字节。让我们看看下面的实例来理解这个概念</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
 
/* 定义简单的结构 */
struct
{
  unsigned int widthValidated;
  unsigned int heightValidated;
} status1;
 
/* 定义位域结构 */
struct
{
  unsigned int widthValidated : 1;
  unsigned int heightValidated : 1;
} status2;
 
int main( )
{
   printf( "Memory size occupied by status1 : %d\n", sizeof(status1));
   printf( "Memory size occupied by status2 : %d\n", sizeof(status2));
 
   return 0;
}</code></pre> 
<p>运行结果是 </p> 
<p>Memory size occupied by status1 : 8<br> Memory size occupied by status2 : 4<br>  </p> 
<p>位域的特点和使用方法如下：</p> 
<ul><li>定义位域时，可以指定成员的位域宽度，即成员所占用的位数。</li><li>位域的宽度不能超过其数据类型的大小，因为位域必须适应所使用的整数类型。</li><li>位域的数据类型可以是 <code>int</code>、<code>unsigned int</code>、<code>signed int</code> 等整数类型，也可以是枚举类型。</li><li>位域可以单独使用，也可以与其他成员一起组成结构体。</li><li>位域的访问是通过点运算符（<code>.</code>）来实现的，与普通的结构体成员访问方式相同。、</li></ul> 
<h3>位域声明</h3> 
<p>有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有 0 和 1 两种状态，用 1 位二进位即可。为了节省存储空间，并使处理简便，C 语言又提供了一种数据结构，称为"位域"或"位段"。</p> 
<p>所谓"位域"是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。</p> 
<p>典型的实例：</p> 
<ul><li>用 1 位二进位存放一个开关量时，只有 0 和 1 两种状态。</li><li>读取外部文件格式——可以读取非标准的文件格式。例如：9 位的整数。</li></ul> 
<h4>位域的定义和位域变量的说明</h4> 
<p>位域定义与结构定义相仿，其形式为：</p> 
<pre><code class="language-cpp">struct 位域结构名 
{

 位域列表

};
</code></pre> 
<p>其中位域列表的形式为：</p> 
<pre><code class="language-cs">type [member_name] : width ;
</code></pre> 
<p>下面是有关位域中变量元素的描述：</p> 
<table><tbody><tr><th>元素</th><th>描述</th></tr><tr><td>type</td><td>只能为 int(整型)，unsigned int(无符号整型)，signed int(有符号整型) 三种类型，决定了如何解释位域的值。</td></tr><tr><td>member_name</td><td>位域的名称。</td></tr><tr><td>width</td><td>位域中位的数量。宽度必须小于或等于指定类型的位宽度。</td></tr></tbody></table> 
<p>带有预定义宽度的变量被称为<strong>位域</strong>。位域可以存储多于 1 位的数，例如，需要一个变量来存储从 0 到 7 的值，您可以定义一个宽度为 3 位的位域，如下：</p> 
<p>为什么是宽度为3的位域 因为7 在二进制是111 所以需要3个bit位就够了</p> 
<pre><code class="language-cs">struct
{
  unsigned int age : 3;
} Age;</code></pre> 
<p>示例：</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

struct packed_struct {
   unsigned int f1 : 1;   // 1位的位域
   unsigned int f2 : 1;   // 1位的位域
   unsigned int f3 : 1;   // 1位的位域
   unsigned int f4 : 1;   // 1位的位域
   unsigned int type : 4; // 4位的位域
   unsigned int my_int : 9; // 9位的位域
};

int main() {
   struct packed_struct pack;

   pack.f1 = 1;
   pack.f2 = 0;
   pack.f3 = 1;
   pack.f4 = 0;
   pack.type = 7;
   pack.my_int = 255;

   printf("f1: %u\n", pack.f1);
   printf("f2: %u\n", pack.f2);
   printf("f3: %u\n", pack.f3);
   printf("f4: %u\n", pack.f4);
   printf("type: %u\n", pack.type);
   printf("my_int: %u\n", pack.my_int);

   return 0;
}</code></pre> 
<p><img alt="" height="200" src="https://images2.imgbox.com/7c/1c/SL73tXE4_o.png" width="644"></p> 
<p>计算字节数：</p> 
<p>示例：</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;

struct example1 {
   int a : 4;
   int b : 5;
   int c : 7;
};

int main() {
   struct example1 ex1;

   printf("Size of example1: %lu bytes\n", sizeof(ex1));

   return 0;
}</code></pre> 
<p> </p> 
<p>以上实例中，example1 结构体包含三个位域成员 a，b 和 c，它们分别占用 4 位、5 位和 7 位。</p> 
<p>通过 sizeof 运算符计算出 example1 结构体的字节数，并输出结果：</p> 
<p>运行结果是7+5+4=16个bit位 4个字节</p> 
<p><strong>对于位域的定义尚有以下几点说明：</strong></p> 
<ul><li> <p>一个位域存储在同一个字节中，如一个字节所剩空间不够存放另一位域时，则会从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：</p> <p>struct bs{ unsigned a:4; unsigned :4; /* 空域 */ unsigned b:4; /* 从下一单元开始存放 */ unsigned c:4 }</p> <p>在这个位域定义中，a 占第一字节的 4 位，后 4 位填 0 表示不使用，b 从第二字节开始，占用 4 位，c 占用 4 位。</p> </li><li> <p>位域的宽度不能超过它所依附的数据类型的长度，成员变量都是有类型的，这个类型限制了成员变量的最大长度，: 后面的数字不能超过这个长度。</p> </li><li> <p>位域可以是无名位域，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：</p> <p>struct k{ int a:1; int :2; /* 该 2 位不能使用 */ int b:3; int c:2; };</p> </li></ul> 
<p>从以上分析可以看出，位域在本质上就是一种结构类型，不过其成员是按二进位分配的。</p> 
<h4></h4> 
<h4>位域的使用</h4> 
<p>位域的使用和结构成员的使用相同，其一般形式为：</p> 
<p>位域变量名.位域名<br> 位域变量名-&gt;位域名<br>  </p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
 
int main(){
    struct bs{
        unsigned a:1;
        unsigned b:3;
        unsigned c:4;
    } bit,*pbit;
    bit.a=1;    /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */
    bit.b=7;    /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */
    bit.c=15;    /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */
    printf("%d,%d,%d\n",bit.a,bit.b,bit.c);    /* 以整型量格式输出三个域的内容 */
    pbit=&amp;bit;    /* 把位域变量 bit 的地址送给指针变量 pbit */
    pbit-&gt;a=0;    /* 用指针方式给位域 a 重新赋值，赋为 0 */
    pbit-&gt;b&amp;=3;    /* 使用了复合的位运算符 "&amp;="，相当于：pbit-&gt;b=pbit-&gt;b&amp;3，位域 b 中原有值为 7，与 3 作按位与运算的结果为 3（111&amp;011=011，十进制值为 3） */
    pbit-&gt;c|=1;    /* 使用了复合位运算符"|="，相当于：pbit-&gt;c=pbit-&gt;c|1，其结果为 15 */
    printf("%d,%d,%d\n",pbit-&gt;a,pbit-&gt;b,pbit-&gt;c);    /* 用指针方式输出了这三个域的值 */
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8a3ee855c1a9751176414296ffd01d42/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">概率基础——几何分布</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/62754b9da1fa0164e367d9b778cdcdf7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">测试333</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>