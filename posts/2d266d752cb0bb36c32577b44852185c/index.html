<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; sizeof(struct)计算结构体大小 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43; sizeof(struct)计算结构体大小" />
<meta property="og:description" content="一、sizeof() 在学习C&#43;&#43;的时候会学到一个sizeof操作符，在 C 语言中，sizeof() 是一个判断数据类型或者表达式长度的运算符。单位是位（byte）。
我们都知道char、short、int、long、float、double的大小；
二、结构体的大小 定义一个结构体：
struct stru{ char a; int b; float c; double d; }; cout &lt;&lt; &#34;struct: &#34; &lt;&lt; sizeof(stru) &lt;&lt; &#34; 字节&#34; &lt;&lt; endl; 请问输出是什么？
可能你是这么想的： sizeof(stru) = sizeof(a) &#43; sizeof(b) &#43; sizeof(c) &#43; sizeof(d) = 1 &#43; 4 &#43; 4 &#43; 8 = 17;
实际上并不是这样的。
在计算结构体大小的时候存在对齐的问题
类型 对齐方式（变量存放的起始地址相对于结构的起始地址的偏移量） Char 偏移量必须为sizeof(char)即1的倍数 Short 偏移量必须为sizeof(short)即2的倍数 int 偏移量必须为sizeof(int)即4的倍数 float 偏移量必须为sizeof(float)即4的倍数 double 偏移量必须为sizeof(double)即8的倍数 偏移量指的是结构体变量中成员的地址和结构体变量地址的差。结构体大小等于最后一个成员的偏移量加上最后一个成员的大小。
然而，在实际中，存储变量时地址要求对齐，编译器在编译程序时会遵循两条原则： （1）结构体变量中成员的偏移量必须是成员大小的整数倍（0被认为是任何数的整数倍） （2）结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数。 下面详细讲解：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/2d266d752cb0bb36c32577b44852185c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-31T13:07:46+08:00" />
<meta property="article:modified_time" content="2019-08-31T13:07:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; sizeof(struct)计算结构体大小</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="sizeof_0"></a>一、sizeof()</h3> 
<p>在学习C++的时候会学到一个sizeof操作符，在 C 语言中，sizeof() 是一个判断数据类型或者表达式长度的运算符。单位是位（byte）。<br> 我们都知道char、short、int、long、float、double的大小；<br> <img src="https://images2.imgbox.com/c6/ee/byYYcMdl_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_6"></a>二、结构体的大小</h3> 
<p>定义一个结构体：</p> 
<pre><code>struct stru{
	char a;
	int b;
	float c;
	double d;
};
</code></pre> 
<pre><code>	cout &lt;&lt; "struct: " &lt;&lt; sizeof(stru) &lt;&lt; " 字节" &lt;&lt; endl;
</code></pre> 
<p>请问输出是什么？<br> 可能你是这么想的： <code>sizeof(stru) = sizeof(a) + sizeof(b) + sizeof(c) + sizeof(d) = 1 + 4 + 4 + 8 = 17;</code><br> 实际上并不是这样的。<br> 在计算结构体大小的时候存在对齐的问题</p> 
<pre><code>类型      对齐方式（变量存放的起始地址相对于结构的起始地址的偏移量） 
Char      偏移量必须为sizeof(char)即1的倍数 
Short     偏移量必须为sizeof(short)即2的倍数 
int         偏移量必须为sizeof(int)即4的倍数 
float      偏移量必须为sizeof(float)即4的倍数 
double   偏移量必须为sizeof(double)即8的倍数 
</code></pre> 
<p><strong>偏移量指的是结构体变量中成员的地址和结构体变量地址的差。结构体大小等于最后一个成员的偏移量加上最后一个成员的大小。</strong></p> 
<pre><code>  然而，在实际中，存储变量时地址要求对齐，编译器在编译程序时会遵循两条原则：

  （1）结构体变量中成员的偏移量必须是成员大小的整数倍（0被认为是任何数的整数倍） 

  （2）结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数。
</code></pre> 
<p><strong>下面详细讲解：</strong></p> 
<pre><code>struct stru{
	char a;   //第一个成员a的偏移量为0
	int b;    //第二个成员b的偏移量是第一个成员的偏移量加上第一个成员的大小（0+1=1，但是必须是第二个变量类型长度4的倍数，即为4）
	float c;  //第三个成员c的偏移量是第二个成员的偏移量加上第二个成员的大小（4+4=8，但是必须是第三个变量类型长度4的倍数，即为8）
	double d; //第四个成员d的偏移量是第三个成员的偏移量加上第三个成员的大小（8+4=12，但是必须是第四个变量类型长度8的倍数，即为16）  
};
//最后计算结构体大小等于最后一个成员（第四个）的偏移量（16）加上最后一个成员的大小（8）。
//即16+8(double)=24
//另外结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数。
//大于等于24并且1,4,4,8的公倍数------&gt;24

</code></pre> 
<p><strong>那么我在加一个变量int e；则猜猜结构体大小是多少？<br> 下面进行讲解：</strong></p> 
<pre><code>struct stru{
	char a;   //第一个成员a的偏移量为0
	int b;    //第二个成员b的偏移量是第一个成员的偏移量加上第一个成员的大小（0+1=1，但是必须是第二个变量类型长度4的倍数，即为4）
	float c;  //第三个成员c的偏移量是第二个成员的偏移量加上第二个成员的大小（4+4=8，是第三个变量类型长度4的倍数，即为8）
	double d; //第四个成员d的偏移量是第三个成员的偏移量加上第三个成员的大小（8+4=12，但是必须是第四个变量类型长度8的倍数，即为16） 
	int e;	  //第五个成员e的偏移量是第四个成员的偏移量加上第四个成员的大小（16+8=24，是第五个变量类型长度4的倍数，即为24）  
};
//最后计算结构体大小等于最后一个成员（第五个）的偏移量（24）加上最后一个成员的大小（4）。
//即24+4(double)=28
//另外结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数。
//大于等于28并且1,4,4,8,4的公倍数------&gt;32


</code></pre> 
<p><strong>源码：</strong></p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;
 
struct stru{
	char a;   //第一个成员a的偏移量为0
	int b;    //第二个成员b的偏移量是第一个成员的偏移量加上第一个成员的大小（0+1=1，但是必须是第二个变量类型长度4的倍数，即为4）
	float c;  //第三个成员c的偏移量是第二个成员的偏移量加上第二个成员的大小（4+4=8，是第三个变量类型长度4的倍数，即为8）
	double d; //第四个成员d的偏移量是第三个成员的偏移量加上第三个成员的大小（8+4=12，但是必须是第四个变量类型长度8的倍数，即为16） 
	int e;	  //第五个成员e的偏移量是第四个成员的偏移量加上第四个成员的大小（16+8=24，是第五个变量类型长度4的倍数，即为24）  
};
//最后计算结构体大小等于最后一个成员（第五个）的偏移量（24）加上最后一个成员的大小（4）。
//即24+4(double)=28
//另外结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数。
//大于等于28并且1,4,4,8,4的公倍数------&gt;32 
int main()
{
	cout &lt;&lt; "char: " &lt;&lt; sizeof(char) &lt;&lt; " 字节" &lt;&lt; endl;
	cout &lt;&lt; "short: " &lt;&lt; sizeof(short) &lt;&lt; " 字节" &lt;&lt; endl;
	cout &lt;&lt; "int: " &lt;&lt; sizeof(int) &lt;&lt; " 字节" &lt;&lt; endl;
	cout &lt;&lt; "long: " &lt;&lt; sizeof(long) &lt;&lt; " 字节" &lt;&lt; endl;
	cout &lt;&lt; "float: " &lt;&lt; sizeof(float) &lt;&lt; " 字节" &lt;&lt; endl;
	cout &lt;&lt; "double: " &lt;&lt; sizeof(double) &lt;&lt; " 字节" &lt;&lt; endl; 
	
	cout &lt;&lt; "struct: " &lt;&lt; sizeof(stru) &lt;&lt; " 字节" &lt;&lt; endl;

	system("pause");
	return 0;
}
</code></pre> 
<h3><a id="x64x86_110"></a>三、不同平台下x64和x86</h3> 
<p><strong>经过验证两个平台下的大小是相同的。</strong></p> 
<p>作者：GL3_24<br> 来源：CSDN<br> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dbf82057c1190c57e98fb8d85073f407/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">滴滴笔试--算术转移（20190827）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e7c3529016d3b23dcfcaf3847a9046fd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">网络安全传输系统(3)—OpenSSL加密传输</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>