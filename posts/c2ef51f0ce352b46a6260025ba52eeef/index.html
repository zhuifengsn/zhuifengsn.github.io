<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Django开发，日常错误。 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Django开发，日常错误。" />
<meta property="og:description" content="文章目录 一、migrate失败关于fake和fake-initial参数 以及其他的一些migrate可选用参数 二、在使用cx_Oracle模块中文乱码三、在使用django多线程时引发的问题四、get_or_create()一条记录被创建了两次五、Request body exceeded settings.DATA_UPLOAD_MAX_MEMORY_SIZE. 一、migrate失败 错误如下：
django.db.utils.ProgrammingError: relation &#34;user&#34; already exists 解决方式：
python3 manage.py migrate mfxx (migrations文件) --fake-initial 关于fake和fake-initial参数 以及其他的一些migrate可选用参数 –fake migrate命令的–fake参数在官方文档中的解释是，记录或消除migrate记录，但不去真的运行SQL以改变数据结构。换句话说，一般的migrate的流程是 1.读取migrations文件，解析成SQL；2.执行SQL改变数据库结构或内容；3.将本次migrate的信息录入django_migrations。但是如果加上–fake参数，那么第2步会被直接跳过而变更直接被记录到django_migrations中。 这个参数的使用场景常常是这样的： 当一个migration文件执行出错，而我们明确知道这个错该如何修正，我们完全可以手动去对数据库结构做一些修改。然后再带–fake参数地运行本次变更对应的migration文件。“假装”我们正确地做了一次migrate。 –fake-initial –fake-initial的原理是类似的，只不过其针对的只是执行0001_initial这个文件。所以说fake-initial的使用场景更加狭窄，即上面所说的对于数据库中有结构，但是0001_initial.py重新生成并且需要写入django_migrations记录时，用到这个参数。 sqlmigrate 另外migrate还有一个比较有用的参数是sqlmigrate。其用法是sqlmigrate app 000x_xxx。它的意思是将某个特定的migrations文件翻译成SQL打印到屏幕上。我们手动去执行这些SQL效果和自动去migrate的效果是一样的。因此在自动migrate时出错的时候，可以利用sqlmigrate打印出SQL，具体查看哪些SQL有问题。如果可以排除，那么可以手动修改出错的SQL并执行，再带有–fake参数执行下这个migrate即可。 二、在使用cx_Oracle模块中文乱码 在使用cx_Oracle模块读取oracle数据中的中文数据的时候，返回值是？？？？， 解决方案：
import os os.environ[&#39;NLS_LANG&#39;] = &#39;SIMPLIFIED CHINESE_CHINA.UTF8&#39; 三、在使用django多线程时引发的问题 在使用多线程的时候，需要考虑数据库存储时间问题。
多线程意味着django可以同时处理多个请求
下面有一个情景：
有一个用来存储数据的接口，逻辑是先利用主键判断这条数据是否已经存在，如果存在则返回“此数据已经存在”，否则存下来。
某时候。同时收到两个完全一样的请求，要存贮的数据也完全一样。两个请求同时判断了数据是否已经存在，很显然，不存在，然后两个请求一起存储数据，这是其中一个请求会引发IntegrityError的错误。
这虽然影响不大，但还需注意。
如果有需求的话，可以将这个主键存在redis中，有效期可以设置1小时，redis的速度是非常快的。
四、get_or_create()一条记录被创建了两次 理论上不会被创建两次，但在多线程下确实有可能的。
五、Request body exceeded settings.DATA_UPLOAD_MAX_MEMORY_SIZE. 完整的报错日志：
ERROR 2019-09-24 09:27:23,160 scheme:https path:/asset/api/interface/ method:POST data:&lt;QueryDict: {}&gt; Traceback (most recent call last): File &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/c2ef51f0ce352b46a6260025ba52eeef/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-09-12T10:10:33+08:00" />
<meta property="article:modified_time" content="2019-09-12T10:10:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Django开发，日常错误。</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#migrate_1" rel="nofollow">一、migrate失败</a></li><li><ul><li><a href="#fakefakeinitial_migrate_10" rel="nofollow">关于fake和fake-initial参数 以及其他的一些migrate可选用参数</a></li></ul> 
   </li><li><a href="#cx_Oracle_23" rel="nofollow">二、在使用cx_Oracle模块中文乱码</a></li><li><a href="#django_29" rel="nofollow">三、在使用django多线程时引发的问题</a></li><li><a href="#get_or_create_38" rel="nofollow">四、get_or_create()一条记录被创建了两次</a></li><li><a href="#Request_body_exceeded_settingsDATA_UPLOAD_MAX_MEMORY_SIZE_41" rel="nofollow">五、Request body exceeded settings.DATA_UPLOAD_MAX_MEMORY_SIZE.</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="migrate_1"></a>一、migrate失败</h3> 
<p>错误如下：</p> 
<pre><code>django.db.utils.ProgrammingError: relation "user" already exists
</code></pre> 
<p>解决方式：</p> 
<pre><code>python3 manage.py migrate mfxx (migrations文件) --fake-initial
</code></pre> 
<h4><a id="fakefakeinitial_migrate_10"></a>关于fake和fake-initial参数 以及其他的一些migrate可选用参数</h4> 
<ul><li>–fake 
  <ul><li>migrate命令的–fake参数在官方文档中的解释是，记录或消除migrate记录，但不去真的运行SQL以改变数据结构。</li><li>换句话说，一般的migrate的流程是 
    <ul><li>1.读取migrations文件，解析成SQL；</li><li>2.执行SQL改变数据库结构或内容；</li><li>3.将本次migrate的信息录入django_migrations。</li><li>但是如果加上–fake参数，那么第2步会被直接跳过而变更直接被记录到django_migrations中。</li></ul> </li><li>这个参数的使用场景常常是这样的： 当一个migration文件执行出错，而我们明确知道这个错该如何修正，我们完全可以手动去对数据库结构做一些修改。然后再带–fake参数地运行本次变更对应的migration文件。“假装”我们正确地做了一次migrate。</li></ul> </li><li>–fake-initial 
  <ul><li>–fake-initial的原理是类似的，只不过其针对的只是执行0001_initial这个文件。所以说fake-initial的使用场景更加狭窄，即上面所说的对于数据库中有结构，但是0001_initial.py重新生成并且需要写入django_migrations记录时，用到这个参数。</li></ul> </li><li>sqlmigrate 
  <ul><li>另外migrate还有一个比较有用的参数是sqlmigrate。其用法是sqlmigrate app 000x_xxx。它的意思是将某个特定的migrations文件翻译成SQL打印到屏幕上。我们手动去执行这些SQL效果和自动去migrate的效果是一样的。因此在自动migrate时出错的时候，可以利用sqlmigrate打印出SQL，具体查看哪些SQL有问题。如果可以排除，那么可以手动修改出错的SQL并执行，再带有–fake参数执行下这个migrate即可。</li></ul> </li></ul> 
<h3><a id="cx_Oracle_23"></a>二、在使用cx_Oracle模块中文乱码</h3> 
<p>在使用cx_Oracle模块读取oracle数据中的中文数据的时候，返回值是？？？？， 解决方案：</p> 
<pre><code>import os 
os.environ['NLS_LANG'] = 'SIMPLIFIED CHINESE_CHINA.UTF8' 
</code></pre> 
<h3><a id="django_29"></a>三、在使用django多线程时引发的问题</h3> 
<p>在使用多线程的时候，需要考虑数据库存储时间问题。<br> 多线程意味着django可以同时处理多个请求<br> 下面有一个情景：<br> 有一个用来存储数据的接口，逻辑是先利用主键判断这条数据是否已经存在，如果存在则返回“此数据已经存在”，否则存下来。<br> 某时候。同时收到两个完全一样的请求，要存贮的数据也完全一样。两个请求同时判断了数据是否已经存在，很显然，不存在，然后两个请求一起存储数据，这是其中一个请求会引发IntegrityError的错误。<br> 这虽然影响不大，但还需注意。<br> 如果有需求的话，可以将这个主键存在redis中，有效期可以设置1小时，redis的速度是非常快的。</p> 
<h3><a id="get_or_create_38"></a>四、get_or_create()一条记录被创建了两次</h3> 
<p>理论上不会被创建两次，但在多线程下确实有可能的。</p> 
<h3><a id="Request_body_exceeded_settingsDATA_UPLOAD_MAX_MEMORY_SIZE_41"></a>五、Request body exceeded settings.DATA_UPLOAD_MAX_MEMORY_SIZE.</h3> 
<p>完整的报错日志：</p> 
<pre><code>ERROR 2019-09-24 09:27:23,160 scheme:https path:/asset/api/interface/ method:POST data:&lt;QueryDict: {}&gt;
Traceback (most recent call last):
  File "/code/asset_apps/main/views/error_Traceback.py", line 20, in wrap
    return function(*args, **kwargs)
  File "/usr/local/lib/python3.6/site-packages/django/utils/decorators.py", line 63, in bound_func
    return func.__get__(self, type(self))(*args2, **kwargs2)
  File "/code/asset_apps/main/service/Interface.py", line 407, in post
    data = json.loads(request.body)
  File "/usr/local/lib/python3.6/site-packages/django/http/request.py", line 269, in body
    raise RequestDataTooBig('Request body exceeded settings.DATA_UPLOAD_MAX_MEMORY_SIZE.')
django.core.exceptions.RequestDataTooBig: Request body exceeded settings.DATA_UPLOAD_MAX_MEMORY_SIZE.
</code></pre> 
<p>其实翻译过来就是：请求体超出设置<br> DATA_UPLOAD_MAX_MEMORY_SIZE：这个设置翻译过来就是：数据上传最大内存大小<br> 默认大小是2.5M，如果有需要可以自己重新设置，以字节为单位：</p> 
<pre><code>DATA_UPLOAD_MAX_MEMORY_SIZE = 10485760    # 设置为最大10M
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e285f82410dbdf4b11d97fd15ca21d51/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java.lang.UnsatisfiedLinkError: dalvik.system.PathClassLoader[DexPathList[[zip file .</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/be5db3f65f5ad37723a46efcf252c2ed/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">springboot整合swagger-bootstrap-ui,过滤器放开并解决自定义错误信息返回冲突</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>