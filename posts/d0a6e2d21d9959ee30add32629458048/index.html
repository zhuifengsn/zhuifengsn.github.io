<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>docker 命令（总结和图解） - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="docker 命令（总结和图解）" />
<meta property="og:description" content="docker 命令 docker 命令图 Images镜像相关的命令
docker images: 列出所有镜像
docker rmi: 删除镜像
docker tag: 给源镜像创建一个新的标签，变成新的镜像
docker history: 显示镜像的历史
…
Container容器相关的命令
docker start: 启动一个或者多个容器
docker kill/stop: 杀死/停止一个或者多个容器
docker pause/unpause: 暂停/启动 一个或者多个容器
docker rm: 移除一个或者多个容器
docker ps: 列出所有容器
…
镜像和容器之间转换的命令
docker commit: 把容器的改变 提交创建一个新的镜像
docker create: 创建新容器，但并不启动（注意与docker run 的区分）需要手动启动。start\stop
docker run: 创建并启动容器
…
docker的主要命令图解：
docker 命令列表 命令作用attach绑定到运行中容器的 标准输入, 输出,以及错误流（这样似乎也能进入容器内容，但是一定小心，他们操作的就是控制台，控制台的退出命令会生效，比如redis,nginx…build从一个 Dockerfile 文件构建镜像commit把容器的改变 提交创建一个新的镜像cp容器和本地文件系统间 复制 文件/文件夹create创建新容器，但并不启动（注意与docker run 的区分）需要手动启动。start\stopdiff检查容器里文件系统结构的更改【A：添加文件或目录 D：文件或者目录删除 C：文件或者目录更改】events获取服务器的实时事件exec在运行时的容器内运行命令export导出容器的文件系统为一个tar文件。commit是直接提交成镜像，export是导出成文件方便传输history显示镜像的历史images列出所有镜像import导入tar的内容创建一个镜像，再导入进来的镜像直接启动不了容器。/docker-entrypoint.sh nginx -g &#39;daemon of;&#39;docker ps --no-trunc 看下之前的完整启动命令再用他info显示系统信息inspect获取docker对象的底层信息kill杀死一个或者多个容器load从 tar 文件加载镜像login登录Docker registrylogout退出Docker registrylogs获取容器日志；容器以前在前台控制台能输出的所有内容，都可以看到pause暂停一个或者多个容器port列出容器的端口映射ps列出所有容器pull从registry下载一个image 或者repositorypush给registry推送一个image或者repositoryrename重命名一个容器restart重启一个或者多个容器rm移除一个或者多个容器rmi移除一个或者多个镜像run创建并启动容器save把一个或者多个镜像保存为tar文件search去docker hub寻找镜像start启动一个或者多个容器stats显示容器资源的实时使用状态stop停止一个或者多个容器tag给源镜像创建一个新的标签，变成新的镜像top显示正在运行容器的进程unpausepause的反操作update更新一个或者多个docker容器配置versionShow the Docker version informationcontainer管理容器image管理镜像network管理网络volume管理卷 docker 命令示例 docker pull redis : 等价docker pull redis:latest, 下载镜像" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/d0a6e2d21d9959ee30add32629458048/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-17T16:39:51+08:00" />
<meta property="article:modified_time" content="2022-07-17T16:39:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">docker 命令（总结和图解）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="docker__0"></a>docker 命令</h2> 
<h3><a id="docker__1"></a>docker 命令图</h3> 
<ul><li> <p>Images镜像相关的命令</p> 
  <blockquote> 
   <p><code>docker images</code>: 列出所有镜像<br> <code>docker rmi</code>: 删除镜像<br> <code>docker tag</code>: 给源镜像创建一个新的标签，变成新的镜像<br> <code>docker history</code>: 显示镜像的历史<br> …</p> 
  </blockquote> </li><li> <p>Container容器相关的命令</p> 
  <blockquote> 
   <p><code>docker start</code>: 启动一个或者多个容器<br> <code>docker kill/stop</code>: 杀死/停止一个或者多个容器<br> <code>docker pause/unpause</code>: 暂停/启动 一个或者多个容器<br> <code>docker rm</code>: 移除一个或者多个容器<br> <code>docker ps</code>: 列出所有容器<br> …</p> 
  </blockquote> </li><li> <p>镜像和容器之间转换的命令</p> 
  <blockquote> 
   <p><code>docker commit</code>: 把容器的改变 提交创建一个新的镜像<br> <code>docker create</code>: 创建新容器，但并不启动（注意与docker run 的区分）需要手动启动。start\stop<br> <code>docker run</code>: 创建并启动容器<br> …</p> 
  </blockquote> </li></ul> 
<p>docker的主要命令图解：<br> <img src="https://images2.imgbox.com/a0/48/3t6ZDkM7_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="docker__26"></a>docker 命令列表</h3> 
<table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>attach</td><td>绑定到运行中容器的 标准输入, 输出,以及错误流（这样似乎也能进入容器内容，但是一定小心，他们操作的就是控制台，控制台的退出命令会生效，比如redis,nginx…</td></tr><tr><td>build</td><td>从一个 Dockerfile 文件构建镜像</td></tr><tr><td>commit</td><td>把容器的改变 提交创建一个新的镜像</td></tr><tr><td>cp</td><td>容器和本地文件系统间 复制 文件/文件夹</td></tr><tr><td>create</td><td>创建新容器，但并不启动（注意与docker run 的区分）需要手动启动。start\stop</td></tr><tr><td>diff</td><td>检查容器里文件系统结构的更改【A：添加文件或目录 D：文件或者目录删除 C：文件或者目录更改】</td></tr><tr><td>events</td><td>获取服务器的实时事件</td></tr><tr><td>exec</td><td>在运行时的容器内运行命令</td></tr><tr><td>export</td><td>导出容器的文件系统为一个tar文件。commit是直接提交成镜像，export是导出成文件方便传输</td></tr><tr><td>history</td><td>显示镜像的历史</td></tr><tr><td>images</td><td>列出所有镜像</td></tr><tr><td>import</td><td>导入tar的内容创建一个镜像，再导入进来的镜像直接启动不了容器。/docker-entrypoint.sh nginx -g 'daemon of;'docker ps --no-trunc 看下之前的完整启动命令再用他</td></tr><tr><td>info</td><td>显示系统信息</td></tr><tr><td>inspect</td><td>获取docker对象的底层信息</td></tr><tr><td>kill</td><td>杀死一个或者多个容器</td></tr><tr><td>load</td><td>从 tar 文件加载镜像</td></tr><tr><td>login</td><td>登录Docker registry</td></tr><tr><td>logout</td><td>退出Docker registry</td></tr><tr><td>logs</td><td>获取容器日志；容器以前在前台控制台能输出的所有内容，都可以看到</td></tr><tr><td>pause</td><td>暂停一个或者多个容器</td></tr><tr><td>port</td><td>列出容器的端口映射</td></tr><tr><td>ps</td><td>列出所有容器</td></tr><tr><td>pull</td><td>从registry下载一个image 或者repository</td></tr><tr><td>push</td><td>给registry推送一个image或者repository</td></tr><tr><td>rename</td><td>重命名一个容器</td></tr><tr><td>restart</td><td>重启一个或者多个容器</td></tr><tr><td>rm</td><td>移除一个或者多个容器</td></tr><tr><td>rmi</td><td>移除一个或者多个镜像</td></tr><tr><td>run</td><td>创建并启动容器</td></tr><tr><td>save</td><td>把一个或者多个镜像保存为tar文件</td></tr><tr><td>search</td><td>去docker hub寻找镜像</td></tr><tr><td>start</td><td>启动一个或者多个容器</td></tr><tr><td>stats</td><td>显示容器资源的实时使用状态</td></tr><tr><td>stop</td><td>停止一个或者多个容器</td></tr><tr><td>tag</td><td>给源镜像创建一个新的标签，变成新的镜像</td></tr><tr><td>top</td><td>显示正在运行容器的进程</td></tr><tr><td>unpause</td><td>pause的反操作</td></tr><tr><td>update</td><td>更新一个或者多个docker容器配置</td></tr><tr><td>version</td><td>Show the Docker version information</td></tr><tr><td>container</td><td>管理容器</td></tr><tr><td>image</td><td>管理镜像</td></tr><tr><td>network</td><td>管理网络</td></tr><tr><td>volume</td><td>管理卷</td></tr></tbody></table> 
<h3><a id="docker__73"></a>docker 命令示例</h3> 
<p>docker pull redis : 等价docker pull redis:latest, 下载镜像<br> docker rmi -f： 删除镜像<br> docker images -aq: 删除全部镜像<br> docker image prune #移除游离镜像 dangling：游离镜像（没有镜像名字的）<br> docker tag 原镜像:标签 新镜像名:标签 #重命名</p> 
<p>docker create [OPTIONS] IMAGE [COMMAND] [ARG…]<br> docker create [设置项] 镜像名 [启动] [启动参数…]<br> docker create redis: 按照redis:latest镜像启动一个容器</p> 
<p>docker kill是强制kill -9（直接拔电源）；<br> docker stop可以允许优雅停机(当前正在运行中的程序处理完所有事情后再停止)</p> 
<p>docker create --name myredis -p 6379（主机的端口）:6379（容器的端口） redis -p port1:port2</p> 
<p>docker run --name myredis2 -p 6379:6379 -p 8888:6379 redis ：默认是前台启动的，一般加上-d 让他后台悄悄启动, 虚拟机的很多端口绑定容器的一个端口是允许的<br> docker run -d == docker create + docker start</p> 
<h4><a id="docker_95"></a>删除docker所有运行的容器</h4> 
<pre><code class="prism language-bash"><span class="token function">docker</span> <span class="token function">rm</span> -f <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> <span class="token function">ps</span> -aq<span class="token variable">)</span></span>
</code></pre> 
<h4><a id="docker_exec_it_101"></a>docker exec -it</h4> 
<blockquote> 
 <p>进入运行中的容器内部</p> 
</blockquote> 
<p><code>exec</code>: Run a command in a running container(在运行的容器中运行命令)<br> <code>exec -i</code>: --interactive(相互作用的). Keep STDIN open even if not attached(即使没有连接，也要保持STDIN打开)<br> <code>exec -t</code>: --tty Allocate a pseudo-TTY(分配一个伪终端设备)</p> 
<p>如下：<br> docker exec -it mynginx4 /bin/bash： 0用户，以特权方式进入容器</p> 
<h3><a id="docker_run__112"></a>docker run 部署容器</h3> 
<p>常用关键参数 OPTIONS 说明：</p> 
<blockquote> 
 <p><code>-d</code>: 后台运行容器，并返回容器ID；<br> <code>-i</code>: 以交互模式运行容器，通常与 -t 同时使用；<br> <code>-P</code>: 随机端口映射，容器内部端口随机映射到主机的端口<br> <code>-p</code>:指定端口映射，格式为：主机(宿主)端口:容器端口<br> <code>-</code>t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用<br> <code>--name</code>=“nginx-lb”:为容器指定一个名称；<br> <code>--dns</code> 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；<br> <code>--dns-search</code> example.com: 指定容器DNS搜索域名，默认和宿主一致；<br> <code>-h</code> “mars”: 指定容器的hostname；<br> <code>-e</code> username=“ritchie”: 设置环境变量；<br> <code>--env-file</code>=[]: 从指定文件读入环境变量；<br> -<code>-cpuset</code>=“0-2” or --cpuset=“0,1,2”: 绑定容器到指定CPU运行；<br> <code>-m</code> :设置容器使用内存最大值；<br> <code>--net</code>=“bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；<br> <code>--link</code>=[]: 添加链接到另一个容器；<br> <code>--expose</code>=[]: 开放一个端口或一组端口；<br> <code>--restart</code> , 指定重启策略，可以写–restart=awlays 总是故障重启<br> <code>--volume</code> , -v: 绑定一个卷。一般格式 主机文件或文件夹:虚拟机文件或文件夹</p> 
</blockquote> 
<p>常见部署案例：</p> 
<p><strong>部署Nginx</strong></p> 
<pre><code class="prism language-bash"><span class="token comment">#注意 外部的/nginx/conf下面的内容必须存在，否则挂载会覆盖</span>
<span class="token function">docker</span> run --name nginx-app <span class="token punctuation">\</span>
-v /app/nginx/html:/usr/share/nginx/html:ro <span class="token punctuation">\</span>
-v /app/nginx/conf:/etc/nginx
-d nginx
</code></pre> 
<p><strong>部署MySQL</strong></p> 
<pre><code class="prism language-bash"><span class="token comment"># 5.7版本</span>
<span class="token function">docker</span> run -p <span class="token number">3306</span>:3306 --name mysql57-app <span class="token punctuation">\</span>
-v /app/mysql/log:/var/log/mysql <span class="token punctuation">\</span>
-v /app/mysql/data:/var/lib/mysql <span class="token punctuation">\</span>
-v /app/mysql/conf:/etc/mysql/conf.d <span class="token punctuation">\</span>
-e <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span><span class="token number">123456</span> <span class="token punctuation">\</span>
-d mysql:5.7

<span class="token comment">#8.x版本,引入了 secure-file-priv 机制，磁盘挂载将没有权限读写data数据，</span>
<span class="token comment"># 所以需要将权限透传，或者chmod -R 777 /app/mysql/data</span>

<span class="token comment"># --privileged 特权容器，容器内使用真正的root用户</span>
<span class="token function">docker</span> run -p <span class="token number">3306</span>:3306 --name mysql8-app <span class="token punctuation">\</span>
-v /app/mysql/conf:/etc/mysql/conf.d <span class="token punctuation">\</span>
-v /app/mysql/log:/var/log/mysql <span class="token punctuation">\</span>
-v /app/mysql/data:/var/lib/mysql <span class="token punctuation">\</span>
-e <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span><span class="token number">123456</span> <span class="token punctuation">\</span>
--privileged <span class="token punctuation">\</span> 
-d mysql
</code></pre> 
<p><strong>部署Redis</strong></p> 
<pre><code class="prism language-bash"><span class="token comment"># 提前准备好redis.conf文件，创建好相应的文件夹。如：</span>
port <span class="token number">6379</span>
appendonly <span class="token function">yes</span>
<span class="token comment">#更多配置参照 https://raw.githubusercontent.com/redis/redis/6.0/redis.conf</span>
<span class="token function">docker</span> run -p <span class="token number">6379</span>:6379 --name redis <span class="token punctuation">\</span>
-v /app/redis/redis.conf:/etc/redis/redis.conf <span class="token punctuation">\</span>
-v /app/redis/data:/data <span class="token punctuation">\</span>
-d redis:6.2.1-alpine3.13 <span class="token punctuation">\</span>
redis-server /etc/redis/redis.conf --appendonly <span class="token function">yes</span>
</code></pre> 
<p><strong>部署ElasticSearch</strong></p> 
<pre><code class="prism language-bash"><span class="token comment">#准备文件和文件夹，并chmod -R 777 xxx</span>
<span class="token comment">#配置文件内容，参照</span>
https://www.elastic.co/guide/en/elasticsearch/reference/7.5/node.name.html 搜索相
关配置
<span class="token comment"># 考虑为什么挂载使用esconfig ...</span>
<span class="token function">docker</span> run --name<span class="token operator">=</span>elasticsearch -p <span class="token number">9200</span>:9200 -p <span class="token number">9300</span>:9300 <span class="token punctuation">\</span>
-e <span class="token string">"discovery.type=single-node"</span> <span class="token punctuation">\</span>
-e <span class="token assign-left variable">ES_JAVA_OPTS</span><span class="token operator">=</span><span class="token string">"-Xms300m -Xmx300m"</span> <span class="token punctuation">\</span>
-v /app/es/data:/usr/share/elasticsearch/data <span class="token punctuation">\</span>
-v /app/es/plugins:/usr/shrae/elasticsearch/plugins <span class="token punctuation">\</span>
-v esconfig:/usr/share/elasticsearch/config <span class="token punctuation">\</span>
-d elasticsearch:7.12.0
</code></pre> 
<h4><a id="_201"></a>重启策略</h4> 
<ul><li><code>no</code>，默认策略，在容器退出时不重启容器</li><li><code>on-failure</code>，在容器非正常退出时（退出状态非0），才会重启容器</li><li><code>on-failure:3</code>，在容器非正常退出时重启容器，最多重启3次</li><li><code>always</code>，在容器退出时总是重启容器</li><li><code>unless-stopped</code>，在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0d838422ac747b7479520d4a8a98e256/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">爬虫练习题（二）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c529f869b6fc45b45d9c704b6e7fff1d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【免费】win7 所有.net framework框架集合，免费下载，若要运行此应用程序，您必须首先安装net framework如何解决</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>