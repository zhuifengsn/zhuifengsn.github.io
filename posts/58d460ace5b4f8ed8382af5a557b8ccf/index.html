<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c语言数据结构之实现一元多项式的加减运算 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c语言数据结构之实现一元多项式的加减运算" />
<meta property="og:description" content="实现结构：单项链表
思路：对于两个一元多项式中所有指数相同的项，对应系数相加，若其和不为零，则构成“和多项式”中的一项；对于两个一元多项式中所有指数不相同的项，则分别复抄到“和多项式”中去，减法亦然。
main.c
#include &lt;stdio.h&gt; #include &lt;malloc.h&gt; #include &#34;poly.h&#34; #include &#34;lArray.h&#34; void printInfo(); void eatline(); void choose_option(); void poly_exp_add(polyLinkList *ptr); void poly_exp_view(polyLinkList *ptr); void poly_exp_del(polyLinkList *ptr); void poly_addition(polyLinkList *ptr); void poly_sub(polyLinkList *ptr); int main() { printInfo(); choose_option(); return 0; } void printInfo() { printf(&#34;一元多项式的运算-----------------------\n&#34;); printf(&#34;0.添加一元表达式.\n&#34;); printf(&#34;1.查看表达式列表.\n&#34;); printf(&#34;2.删除一个表达式.\n&#34;); printf(&#34;3.一元多项式的加法.\n&#34;); printf(&#34;4.一元多项式的减法.\n&#34;); printf(&#34;6.退出.\n&#34;); printf(&#34;-------------------------------------\n&#34;); } void choose_option() { polyLinkList Poly_Link_List; initPolyLinkList(&amp;Poly_Link_List); int d; do{ scanf(&#34;%d&#34;,&amp;d); eatline(); switch(d) { case 0://添加一元表达式 poly_exp_add(&amp;Poly_Link_List); break; case 1://查看表达式列表 poly_exp_view(&amp;Poly_Link_List); break; case 2://删除一个表达式 poly_exp_del(&amp;Poly_Link_List); break; case 3://一元多项式的加法 poly_addition(&amp;Poly_Link_List); break; case 4://一元多项式的减法 poly_sub(&amp;Poly_Link_List); break; case 6://退出 break; default: break; } printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/58d460ace5b4f8ed8382af5a557b8ccf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-02-10T00:08:48+08:00" />
<meta property="article:modified_time" content="2018-02-10T00:08:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c语言数据结构之实现一元多项式的加减运算</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-size:24px;">实现结构：单项链表<br></span></p> 
<p><span style="font-size:24px;">思路：对于两个一元多项式中所有指数相同的项，对应系数相加，若其和不为零，则构成“和多项式”中的一项；对于两个一元多项式中所有指数不相同的项，则分别复抄到“和多项式”中去，减法亦然。</span></p> 
<p><span style="font-size:24px;"><br></span></p> 
<p><span style="font-size:24px;">main.c</span></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;
#include "poly.h"
#include "lArray.h"

void printInfo();
void eatline();
void choose_option();

void poly_exp_add(polyLinkList *ptr);

void poly_exp_view(polyLinkList *ptr);

void poly_exp_del(polyLinkList *ptr);

void poly_addition(polyLinkList *ptr);

void poly_sub(polyLinkList *ptr);

int main() {
    printInfo();
    choose_option();
    return 0;
}

void printInfo()
{
    printf("一元多项式的运算-----------------------\n");
    printf("0.添加一元表达式.\n");
    printf("1.查看表达式列表.\n");
    printf("2.删除一个表达式.\n");
    printf("3.一元多项式的加法.\n");
    printf("4.一元多项式的减法.\n");
    printf("6.退出.\n");
    printf("-------------------------------------\n");
}

void choose_option()
{

    polyLinkList Poly_Link_List;

    initPolyLinkList(&amp;Poly_Link_List);


    int d;

    do{
        scanf("%d",&amp;d);
        eatline();
        switch(d)
        {
            case 0://添加一元表达式
                poly_exp_add(&amp;Poly_Link_List);
                break;
            case 1://查看表达式列表
                poly_exp_view(&amp;Poly_Link_List);
                break;
            case 2://删除一个表达式
                poly_exp_del(&amp;Poly_Link_List);
                break;
            case 3://一元多项式的加法
                poly_addition(&amp;Poly_Link_List);
                break;
            case 4://一元多项式的减法
                poly_sub(&amp;Poly_Link_List);
                break;
            case 6://退出
                break;
            default:
                break;
        }

        printf("-&gt;");
    }while(d != 6);
}

void poly_sub(polyLinkList *ptr) {
    int id1;
    int id2;
    char strExp[100] = "\0";

    poly_exp_view(ptr);
    printf("\n");
    printf("请输入要进行减法运算的id1和id2，以\",\"隔开,并按下回车键\n");

    printf("例子:1,2\n");
    printf("-&gt;");
    while(scanf("%d,%d",&amp;id1,&amp;id2) == 2)
    {
        struct polyNode * p1 = findById(ptr,id1);
        struct polyNode * p2 = findById(ptr,id2);
        if(p1 &amp;&amp; p2)
        {
            subtractPoly(p1-&gt;linkList,p2-&gt;linkList);
            printPolyn(p1-&gt;linkList,strExp);
            printf("结果:%s\n",strExp);
            printf("要退出请按任意键并敲下回车，不退出请继续输入表达式的id,eg:1,2\n");
            printf("-&gt;");
            strExp[0] = '\0';
        }else{
            printf("两个表达式有一个id不存在，请重新输入.\n");
            printf("-&gt;");
        }
        eatline();
    }
    eatline();
    printf("操作取消.\n");

}

void poly_addition(polyLinkList *ptr) {
    int id1;
    int id2;
    char strExp[100]="\0";
    poly_exp_view(ptr);
    printf("\n");
    printf("请输入要进行加法运算的id1和id2，以\",\"隔开，并按下回车键\n");

    printf("例子:1,2\n");
    printf("-&gt;");
    while(scanf("%d,%d",&amp;id1,&amp;id2) == 2)
    {
        struct polyNode * p1 = findById(ptr,id1);
        struct polyNode * p2 = findById(ptr,id2);

        if(p1 &amp;&amp; p2)
        {
            addPolyn(p1-&gt;linkList,p2-&gt;linkList);
            printPolyn(p1-&gt;linkList,strExp);
            printf("结果:%s\n",strExp);
            printf("要退出请按任意键并敲下回车，不退出请继续输入表达式的id,eg:1,2\n");
            printf("-&gt;");
            strExp[0] = '\0';
        }else{
            printf("两个表达式有一个id不存在，请重新输入.\n");
            printf("-&gt;");
        }

        eatline();
    }
    eatline();
    printf("操作取消.\n");
}

void poly_exp_del(polyLinkList *ptr) {
    int id;
    printf("请输入要删除节点的id:");
    if(scanf("%d",&amp;id) == 1)
    {
        polyLinkList_remove(ptr,id);
    }
    eatline();
}

void poly_exp_view(polyLinkList *ptr) {
    struct polyNode ** pnList = findAll(ptr);
    int i = 0;
    printf("------------------------------------\n");
    printf("|   id   |           表达式         |\n");//36-2-(id)-(表达式) = 29
    char strExp[100]="\0"; //表达式空间
    for(;i&lt;ptr-&gt;length;i++)
    {
        printPolyn(pnList[i]-&gt;linkList,strExp);
        printf("|%8d|%23s  |\n",pnList[i]-&gt;id,strExp);
        strExp[0]='\0';

    }

    printf("------------------------------------\n");
}

//表达式添加
void poly_exp_add(polyLinkList *ptr) {

    struct polyNode * pnode = (struct polyNode * )malloc(sizeof(struct polyNode));

    LinkList * linkList = (LinkList * )malloc(sizeof(LinkList));


    Term term;
    int j = 1;

    printf("请输入表达式的系数n和指数e并以逗号\",\"隔开,格式:n,e\n");
    printf("结束输入请输入任意数字并回车.\n");
    printf("请输入%d项:",j);;

    while(scanf("%d,%d",&amp;term.n,&amp;term.e) == 2)
    {
        eatline();
        createPolyn(linkList,term);
        printf("请输入%d项:",++j);
    }
    if(j!=1)//至少输入了一项
    {

        pnode-&gt;id = ptr-&gt;length+1;
        pnode-&gt;linkList = linkList;

        polyLinkList_add(ptr,pnode);
    }

    eatline();
}


void eatline()
{
    while(getchar() != '\n')
        continue;
}</code></pre> 
<p><br></p> 
<p>poly.h</p> 
<pre><code class="language-cpp">#ifndef _POLY_H_
#define _POLY_H_

#include &lt;stdbool.h&gt;
typedef struct{
    int n;//系数
    int e;//指数
}Term;

typedef struct node{
    Term term;
    struct node * next;//下一节点
}Node;

typedef struct{
    int length;
    Node * head;
}LinkList;

void createPolyn(LinkList * pLinkList,Term term);
void destroyPolyn(LinkList * pLinkList);
void printPolyn(LinkList * pLinkList,char * strExp);
int polynLength(LinkList * pLinkList);
void addPolyn(LinkList * pa,LinkList * pb);
void subtractPoly(LinkList * pa,LinkList * pb);
void multiplyPolyn(LinkList * pa,LinkList * pb);
int cmpTerm(Node * pa,Node *pb);
#endif</code></pre> 
<p>poly.c</p> 
<pre><code class="language-cpp">#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;
#include &lt;string.h&gt;
#include "poly.h"

/**
 * 创建一元多项式
 * @param pLinkList
 * @param term
 */
void createPolyn(LinkList *pLinkList,Term term) {

    Node * pn = NULL;
    if(pLinkList-&gt;head)
    {
        pn = pLinkList-&gt;head;

        while(pn-&gt;next)
            pn = pn-&gt;next;

        pn-&gt;next = (Node *)malloc(sizeof(Node));
        pn-&gt;next-&gt;term = term;
    }else{
        pn = (Node *)malloc(sizeof(Node));
        pLinkList-&gt;head = pn;
        pn-&gt;term = term;
    }

     pLinkList-&gt;length++;
}

/**
 * 销毁一元多项式
 * @param pLinkList
 */
void destroyPolyn(LinkList *pLinkList) {
    Node * pn = pLinkList-&gt;head;
    Node * ptemp;
    while(pn)
    {
        ptemp = pn;
        pn = pn-&gt;next;
        free(ptemp);
    }
}

/**
 * 打印表达式
 * @param pLinkList
 */
void printPolyn(LinkList *pLinkList,char * strExp) {
    Node * pn = pLinkList-&gt;head;
    char strTemp[50];
    bool isFirstPlus = true;//去除表达式第一个加号

    while(pn)
    {
        if(pn-&gt;term.e == 0){
            if(pn-&gt;term.n != 0){
                if(pn-&gt;term.n &gt; 0){
                    if(isFirstPlus){
                        sprintf(strTemp,"%d",pn-&gt;term.n);
                    }
                    else{
                        sprintf(strTemp,"+%d",pn-&gt;term.n);
                    }
                }
                else if(pn-&gt;term.n &lt; 0){
                    sprintf(strTemp,"%d",pn-&gt;term.n);
                }
                isFirstPlus = false;
                strcat(strExp,strTemp);
            }
        }else{
            if(pn-&gt;term.n &lt; 0){
                if(pn-&gt;term.e == 1)
                    sprintf(strTemp,"%dX",pn-&gt;term.n);
                else
                    sprintf(strTemp,"%dX^%d",pn-&gt;term.n,pn-&gt;term.e);
                isFirstPlus = false;
                strcat(strExp,strTemp);
            }else if(pn-&gt;term.n &gt; 0) {
                if(pn-&gt;term.n == 1)
                    if(pn-&gt;term.e == 1)
                        if(isFirstPlus)
                            sprintf(strTemp, "X");
                        else
                            sprintf(strTemp, "+X");
                    else
                        if(isFirstPlus)
                            sprintf(strTemp, "X^%d", pn-&gt;term.e);
                        else
                            sprintf(strTemp, "+X^%d", pn-&gt;term.e);
                else
                    if(pn-&gt;term.e == 1)
                        if(isFirstPlus)
                            sprintf(strTemp, "%dX", pn-&gt;term.n);
                        else
                            sprintf(strTemp, "+%dX", pn-&gt;term.n);
                    else
                        if(isFirstPlus)
                            sprintf(strTemp, "%dX^%d", pn-&gt;term.n, pn-&gt;term.e);
                        else
                            sprintf(strTemp, "+%dX^%d", pn-&gt;term.n, pn-&gt;term.e);
                isFirstPlus = false;
                strcat(strExp,strTemp);
            }
        }
        pn = pn-&gt;next;
    }
}

/**
 * 获取表达式项数
 * @param pLinkList
 * @return
 */
int polynLength(LinkList *pLinkList) {
    if(pLinkList)
        return pLinkList-&gt;length;
    else
        return 0;
}

/**
 * 一元多项式的加法运算
 * @param pa
 * @param pb
 * @return 将pa = pa + pb,pa、pb无用的释放掉.
 */
void addPolyn(LinkList *pa, LinkList *pb) {
    Node *na,*nb,*temp,*pre=NULL;
    na = pa-&gt;head;
    nb = pb-&gt;head;

    while(na &amp;&amp; nb)
    {
        if(cmpTerm(na,nb) == -1) {
            pre = na;
            na = na-&gt;next;
        }
        else if(cmpTerm(na,nb) == 0)
        {
            if(na-&gt;term.n + nb-&gt;term.n != 0)
            {
                na-&gt;term.n+=nb-&gt;term.n;
                temp = nb;
                nb = nb-&gt;next;
                pre = na;
                na = na-&gt;next;
                free(temp);
            }else{
                temp = na;
                na = na-&gt;next;
                if(!pre)//当位于第一个节点时候
                    pa-&gt;head = na;
                else
                    pre-&gt;next = na;
                free(temp);
                temp = nb;
                nb = nb-&gt;next;
                free(temp);
            }
        }else{
            temp = nb-&gt;next;
            nb-&gt;next = na;
            if(!pre)
                pa-&gt;head = nb;
            else
                pre-&gt;next = nb;
            nb = temp;
        }
    }

    if(nb)//如果b还有剩余节点
    {
        pre-&gt;next = nb;//链接剩余节点
    }
}


/**
 * 一元多项式的减法运算
 * @param pa
 * @param pb
 * @return
 */
void subtractPoly(LinkList * pa,LinkList * pb)
{
    Node *na,*nb,*temp = NULL, *pre = NULL;
    na = pa-&gt;head;
    nb = pb-&gt;head;

    while(na &amp;&amp; nb)
    {
        if(cmpTerm(na,nb) == -1)
        {
            pre = na;
            na = na-&gt;next;
        }else if(cmpTerm(na,nb) == 0)
        {
            if(na-&gt;term.n - nb-&gt;term.n != 0)
            {
                na-&gt;term.n -= nb-&gt;term.n;
                temp = nb;
                nb = nb-&gt;next;
                free(temp);
                pre = na;
                na = na-&gt;next;
            }else{

                if(!pre)
                    pa-&gt;head = na-&gt;next;
                else
                    pre-&gt;next = na-&gt;next;

                temp = na;
                na = na-&gt;next;
                free(temp);

                temp = nb;
                nb = nb-&gt;next;
                free(temp);
            }
        }else{
            nb-&gt;term.n = -nb-&gt;term.n;
            temp = nb-&gt;next;
            nb-&gt;next = na;
            if(!pre)
                pa-&gt;head = nb;
            else
                pre-&gt;next = nb;
            nb = temp;
        }
    }


    if(nb)
    {
        pre-&gt;next = nb;
        while(nb)
        {
            nb-&gt;term.n = -nb-&gt;term.n;
            nb = nb-&gt;next;
        }
    }
}

/**
 * 一元多项式的乘法运算
 * @param pa
 * @param pb
 * @return
 */
void multiplyPolyn(LinkList * pa,LinkList * pb)
{

}

/**
 * 比较ta 和 tb 指数的大小关系，分别返回 1,0,-1
 * @param ta
 * @param tb
 * @return
 */
int cmpTerm(Node * pa,Node *pb)
{
    if(pa-&gt;term.e &gt; pb-&gt;term.e)
        return 1;
    else if(pa-&gt;term.e == pb-&gt;term.e)
        return 0;
    else
        return -1;
}</code></pre> 
<p>lArray.h</p> 
<pre><code class="language-cpp">#ifndef _L_ARRAY_H_
#define _L_ARRAY_H_
#include "poly.h"

struct polyNode{
    int id;
    LinkList * linkList;
    struct polyNode * next;
};

typedef struct{
    struct polyNode * head;
    int length;
    struct polyNode * tail;//当前链表的尾节点
}polyLinkList;

void initPolyLinkList(polyLinkList * pll);
void polyLinkList_add(polyLinkList * pll,struct polyNode * pnode);
void polyLinkList_remove(polyLinkList * pll,int id);
void polyLinkList_update(polyLinkList * pll, struct polyNode * pnode);
struct polyNode * findById(polyLinkList * pll, int id);

/**
 * 查找数组内所有节点
 * @param pll
 * @return 返回首节点指针
 */
struct polyNode ** findAll(polyLinkList * pll);

#endif</code></pre> 
<p>lArray.c</p> 
<pre><code class="language-cpp">#include "lArray.h"
#include &lt;stdlib.h&gt;

void initPolyLinkList(polyLinkList * pll)
{
    pll-&gt;tail = NULL;
    pll-&gt;length = 0;
    pll-&gt;head = NULL;
}

void polyLinkList_add(polyLinkList * pll,struct polyNode * pnode)
{
    if(!pll-&gt;tail)//如果尾部指针为空，说明链表没有元素
    {
        pll-&gt;head = pnode;
        pll-&gt;tail = pnode;
    }else{
        pll-&gt;tail-&gt;next = pnode;
        pll-&gt;tail = pnode;
    }
    pll-&gt;length++;
}

void polyLinkList_remove(polyLinkList * pll,int id)
{
    struct polyNode * node = pll-&gt;head;
    if(node)
    {
        if(node-&gt;id == id)//首节点即是需要删除的节点
        {
            pll-&gt;head = node-&gt;next;
            free(node);
            pll-&gt;length--;
        }else{
            while(node-&gt;next)
            {
                if(node-&gt;next-&gt;id == id)
                {
                    free(node-&gt;next);
                    node-&gt;next = node-&gt;next-&gt;next;
                    pll-&gt;length--;
                    break;
                }
                node = node-&gt;next;
            }
        }

    }
}

/**
 * 根据节点的id来更新
 * @param pll
 * @param pnode
 */
void polyLinkList_update(polyLinkList * pll, struct polyNode * pnode)
{
    if(pnode){
        struct polyNode * node = findById(pll,pnode-&gt;id);
        node-&gt;linkList = pnode-&gt;linkList;
    }
}
struct polyNode * findById(polyLinkList * pll, int id)
{
    struct polyNode * node = pll-&gt;head;
    while(node)
    {
        if(node-&gt;id == id)
            return node;
        node = node-&gt;next;
    }

    return NULL;
}

/**
 * 查找数组内所有节点
 * @param pll
 * @return 返回首节点指针,用完记得释放
 */
struct polyNode ** findAll(polyLinkList * pll)
{
    if(pll){
        if(pll-&gt;length != 0)
        {
            struct polyNode ** pnArray = (struct polyNode **)malloc(sizeof(struct polyNode *)*pll-&gt;length);
            struct polyNode * node = pll-&gt;head;
            int i = 0;
            while(node)
            {
                *(pnArray+i) = node;
                node = node-&gt;next;
                i++;
            }
            return pnArray;
        }
    }

    return NULL;
}

</code></pre> 
<p>测试用例：    12X^12+12X^14+12X^17<br>              21X^12+243X^14+1223X^123321<br></p> 
<p>进行减法操作：-9X^12-231X^14+12X^17-1223X^123321<br></p> 
<p>因为时间比较紧张，所以只是实现了一元多项式的加减法运算，乘除法运算没有实现。</p> 
<p><br></p> 
<p><img src="https://images2.imgbox.com/0c/c1/ysUdOVIH_o.png" alt=""></p> 
<p><br></p> 
<p></p> 
<p><img src="https://images2.imgbox.com/19/38/bvawLbi2_o.png" alt=""></p> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c16f08a21dcb142e6bbf6e458d6b0ed0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python中escape和unescape</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fa20fb75acc5940a1bd7afa8909e556b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c语言数据结构之顺序线性表的合并、并集</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>