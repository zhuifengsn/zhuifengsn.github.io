<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>华清远见嵌入式学习——驱动开发——作业1 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="华清远见嵌入式学习——驱动开发——作业1" />
<meta property="og:description" content="作业要求： 通过字符设备驱动分步注册过程实现LED驱动的编写，编写应用程序测试，发布到CSDN
作业答案： 运行效果： 驱动代码： #include &lt;linux/init.h&gt; #include &lt;linux/module.h&gt; #include &lt;linux/fs.h&gt; #include &lt;linux/io.h&gt; #include &lt;linux/device.h&gt; #include &lt;linux/slab.h&gt; #include &lt;linux/cdev.h&gt; #include &lt;linux/uaccess.h&gt; #include &#34;head.h&#34; struct cdev *cdev; char kbuf[128] = {0}; unsigned int major = 0; // 主设备号 unsigned int minor = 0; // 次设备号 dev_t devno; struct class *cls; struct device *dev; gpio_t *vir_led1; gpio_t *vir_led2; gpio_t *vir_led3; unsigned int *vir_rcc; // 封装操作方法 // 定义操作方法对象并初始化 int mycdev_open(struct inode *inode, struct file *file) { printk(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/8a4aa0459672a66a62dc1d9f58171c29/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-18T17:07:11+08:00" />
<meta property="article:modified_time" content="2024-02-18T17:07:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">华清远见嵌入式学习——驱动开发——作业1</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><span style="color:#fe2c24;">作业要求：</span></h2> 
<p>通过字符设备驱动分步注册过程实现LED驱动的编写，编写应用程序测试，发布到CSDN</p> 
<p></p> 
<h2><span style="color:#fe2c24;">作业答案：</span></h2> 
<h3><span style="color:#0d0016;">运行效果：</span></h3> 
<p><img alt="" height="180" src="https://images2.imgbox.com/07/bb/jQRFG8wn_o.gif" width="320"></p> 
<h3><span style="color:#0d0016;">驱动代码：</span></h3> 
<pre><code class="language-cs">#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/io.h&gt;
#include &lt;linux/device.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/cdev.h&gt;
#include &lt;linux/uaccess.h&gt;
#include "head.h"

struct cdev *cdev;
char kbuf[128] = {0};
unsigned int major = 0; // 主设备号
unsigned int minor = 0; // 次设备号
dev_t devno;
struct class *cls;
struct device *dev;

gpio_t *vir_led1;
gpio_t *vir_led2;
gpio_t *vir_led3;
unsigned int *vir_rcc;

// 封装操作方法
// 定义操作方法对象并初始化
int mycdev_open(struct inode *inode, struct file *file)
{
    printk("%s:%s:%d\n", __FILE__, __func__, __LINE__);
    return 0;
}
ssize_t mycdev_read(struct file *file, char *ubuf, size_t size, loff_t *lof)
{
    printk("%s:%s:%d\n", __FILE__, __func__, __LINE__);
    unsigned long ret;
    // 向用户空间读取拷贝
    if (size &gt; sizeof(kbuf)) // 用户空间期待读取的大小内核满足不了，那就给内核支持的最大大小
        size = sizeof(kbuf);
    ret = copy_to_user(ubuf, kbuf, size);
    if (ret) // 拷贝失败
    {
        printk("copy_to_user filed\n");
        return ret;
    }
    return 0;
}
ssize_t mycdev_write(struct file *file, const char *ubuf, size_t size, loff_t *lof)
{
    unsigned long ret;
    // 从用户空间读取数据
    if (size &gt; sizeof(kbuf)) // 用户空间期待读取的大小内核满足不了，那就给内核支持的最大大小
        size = sizeof(kbuf);
    ret = copy_from_user(kbuf, ubuf, size);
    if (ret) // 拷贝失败
    {
        printk("copy_to_user filed\n");
        return ret;
    }

    return 0;
}

long mycdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
    int wh;
    int ret=copy_from_user(&amp;wh,(void *)arg,4);
    if(ret)//拷贝失败
    {
        printk("copy_from_user filed\n");
        return ret;
    }
    switch(cmd)
    {
        case LED_ON:
        switch(wh)
        {
            case 1:
             vir_led1-&gt;ODR |= (1&lt;&lt;10);
             break;
            case 2:
             vir_led2-&gt;ODR |= (1&lt;&lt;10);
             break;
            case 3:
             vir_led3-&gt;ODR |= (1&lt;&lt;8);
             break;
        } 
            break;
        case LED_OFF:
            switch(wh)
        {
            case 1:
              vir_led1-&gt;ODR &amp;= (~(1&lt;&lt;10));
             break;
            case 2:
              vir_led2-&gt;ODR &amp;= (~(1&lt;&lt;10));
             break;
            case 3:
              vir_led3-&gt;ODR &amp;= (~(1&lt;&lt;8));
             break;
        } 
           
            break;
    }
    return 0;
}

int mycdev_close(struct inode *inode, struct file *file)
{
    printk("%s:%s:%d\n", __FILE__, __func__, __LINE__);
    return 0;
}

int all_led_init(void)
{
    //寄存器地址的映射
    vir_led1=ioremap(PHY_LED1_ADDR,sizeof(gpio_t));
    if(vir_led1==NULL)
    {
        printk("ioremap filed：%d\n",__LINE__);
        return -ENOMEM;
    }
     vir_led2=ioremap(PHY_LED2_ADDR,sizeof(gpio_t));
    if(vir_led2==NULL)
    {
        printk("ioremap filed：%d\n",__LINE__);
        return -ENOMEM;
    }
     vir_led3=vir_led1;
    vir_rcc=ioremap(PHY_RCC_ADDR,4);
    if(vir_rcc==NULL)
    {
        printk("ioremap filed：%d\n",__LINE__);
        return -ENOMEM;
    }
    printk("物理地址映射成功\n");
    //寄存器的初始化
    //rcc
    (*vir_rcc) |= (3&lt;&lt;4);
    //led1
    vir_led1-&gt;MODER &amp;= (~(3&lt;&lt;20));
    vir_led1-&gt;MODER |= (1&lt;&lt;20);
    vir_led1-&gt;ODR &amp;= (~(1&lt;&lt;10));
    //led2
    vir_led2-&gt;MODER &amp;= (~(3&lt;&lt;20));
    vir_led2-&gt;MODER |= (1&lt;&lt;20);
    vir_led2-&gt;ODR &amp;= (~(1&lt;&lt;10));
    //led3
    vir_led3-&gt;MODER &amp;= (~(3&lt;&lt;16));
    vir_led3-&gt;MODER |= (1&lt;&lt;16);
    vir_led3-&gt;ODR &amp;= (~(1&lt;&lt;8));
    printk("寄存器初始化成功\n");
 
    return 0;
}

// 定义操作方法结构体变量并赋值
struct file_operations fops={
 
    .open=mycdev_open,
    .read=mycdev_read,
    .write=mycdev_write,
    .unlocked_ioctl=mycdev_ioctl,
    .release=mycdev_close,
};
static int __init mycdev_init(void)
{
    int ret;
    // 1.申请字符设备驱动对象空间
    cdev = cdev_alloc();
    if (cdev == NULL)
    {
        return -EFAULT;
    }
    printk("字符设备驱动对象申请成功\n");
    // 2.初始化字符设备驱动对象
    cdev_init(cdev, &amp;fops);
    // 3.申请设备号
    if (major == 0) // 动态申请
    {
        ret = alloc_chrdev_region(&amp;devno, minor, 3, "myled");
        if (ret)
        {
            printk("动态申请设备号失败\n");
            goto out1;
        }
        // 为了统一和静态申请设备号的操作
        major = MAJOR(devno);
        minor = MINOR(devno);
    }
    else // 静态指定
    {
        ret = register_chrdev_region(MKDEV(major, minor), 3, "myled");
        if (ret)
        {
            printk("静态申请设备号失败\n");
            goto out1;
        }
    }
    printk("设备号申请成功\n");
    // 4.注册驱动
    ret = cdev_add(cdev, MKDEV(major, minor), 3);
    if (ret)
    {
        printk("注册驱动失败\n");
        goto out2;
    }
    printk("注册驱动成功\n");
    // 5.向上提交目录
    cls = class_create(THIS_MODULE, "led");
    if (IS_ERR(cls))
    {
        printk("向上提交目录失败\n");
        ret = -PTR_ERR(cls);
        goto out3;
    }
    printk("向上提交目录成功\n");
    // 6.向上提交设备节点
    int i;
    for (i = 0; i &lt; 3; i++)
    {
        dev = device_create(cls, NULL, MKDEV(major, i), NULL, "myled%d", i);
        if (IS_ERR(dev))
        {
            printk("向上提交设备信息失败\n");
            ret = -PTR_ERR(dev);
            goto out4;
        }
    }
    printk("向上提交设备信息成功\n");

    // 寄存器映射以及初始化
    all_led_init();

    return 0;
out4:
    // 销毁提交成功的设备信息
    for (--i; i &gt;= 0; i--)
    {
        device_destroy(cls, MKDEV(major, i));
    }
    // 销毁目录
    class_destroy(cls);
out3:
    cdev_del(cdev);
out2:
    unregister_chrdev_region(MKDEV(major, minor), 3);
out1:
    kfree(cdev);
    return ret;
}
static void __exit mycdev_exit(void)
{
    // 1.释放设备信息
    int i;
    for (i = 0; i &lt; 3; i++)
    {
        device_destroy(cls, MKDEV(major, i));
    }
    // 2.销毁目录
    class_destroy(cls);
    // 3.注销驱动对象
    cdev_del(cdev);
    // 4.释放设备号
    unregister_chrdev_region(MKDEV(major, minor), 3);
    // 5.释放对象空间
    kfree(cdev);
}
module_init(mycdev_init);
module_exit(mycdev_exit);
MODULE_LICENSE("GPL");</code></pre> 
<h3>应用程序：</h3> 
<pre><code class="language-cs">#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include&lt;unistd.h&gt;
#include&lt;string.h&gt;
#include&lt;sys/ioctl.h&gt;
#include"head.h"
 
 
int main(int argc, char const *argv[])
{
    int a,b;
    int fd=open("/dev/myled0",O_RDWR);
    if(fd&lt;0)
    {
        printf("打开设备文件失败\n");
        exit(-1);
    }
    while(1)
    {
        //从终端读取
        printf("请输入要实现的功能\n");
        printf("0(关灯) 1(开灯)\n");
        printf("请输入&gt;");
        scanf("%d",&amp;a);
        printf("请输入要控制的灯\n");
        printf("1(LED1) 2(LED2) 3(LED3)\n");
        printf("请输入&gt;");
        scanf("%d",&amp;b);
        switch(a)
        {
            case 1:
                ioctl(fd,LED_ON,&amp;b);
                break;
            case 0:
                ioctl(fd,LED_OFF,&amp;b);
                break;
        }
    }
 
    
    close(fd);
 
    return 0;
}</code></pre> 
<h3>头文件：</h3> 
<pre><code class="language-cs">#ifndef __HEAD_H__
#define __HEAD_H__ 
typedef struct{
    unsigned int MODER;
    unsigned int OTYPER;
    unsigned int OSPEEDR;
    unsigned int PUPDR;
    unsigned int IDR;
    unsigned int ODR;
}gpio_t;
#define PHY_LED1_ADDR 0X50006000
#define PHY_LED2_ADDR    0X50007000
#define PHY_LED3_ADDR 0X50006000
#define PHY_RCC_ADDR    0X50000A28
 
//构建功能码
#define LED_ON _IOW('l',1,int)  
#define LED_OFF _IOW('l',0,int)
#endif </code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/315424600ca6b54cdc82edd33eafd5ba/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux文件系统原理分析（2）inode索引节点</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b7a79927a28641ed76ce64f59aafcbcb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">用纯HTML写一个凭证并打印</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>