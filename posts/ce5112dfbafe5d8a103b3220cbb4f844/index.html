<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Redis底层数据结构 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Redis底层数据结构" />
<meta property="og:description" content="文章目录 前言一、什么是Redis二、底层数据结构有哪些三、Redis进阶 - 数据结构：底层数据结构详解1.简单动态字符串 - sds（1）SDS 定义（2）为什么使用SDS（3）空间预分配补进一步理解（4）小结 2.压缩列表 - ZipList（1）ziplist结构（2）Entry结构（3）为什么ZipList特别省内存（4）ziplist的缺点 3.快表 - QuickList（1）quicklist结构（2）quicklist内存布局图（3）quicklist更多额外信息 4.字典/哈希表 - Dict（1）数据结构（2）一些要点 5.整数集 - IntSet（1）intset结构（2）内存布局图（3）整数集合的升级 6.跳表 - ZSkipList（1）什么是跳跃表（2）Redis跳跃表的设计（3）为什么不用平衡树或者哈希表 7.参考文章 总结 前言 Redis 是一个数据结构服务器。Redis 的核心是提供一组原生数据类型，可帮助您解决各种各样的问题，从缓存到队列再到事件处理。下面是每种数据类型的简短描述，以及更广泛的概述。
一、什么是Redis REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库。
Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。
Redis 通常被称为数据结构数据库，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets)和有序集合(sorted sets)等类型。
Redis 是一种开源（BSD 许可）内存数据结构存储，用作数据库、缓存、消息代理和流引擎。Redis 提供数据结构，例如 字符串、散列、列表、集合、带范围查询的排序集合、位图、hyperloglogs、地理空间索引和流。Redis 具有内置复制、Lua 脚本、LRU 逐出、事务和不同级别的磁盘持久性，并通过Redis Sentinel和Redis Cluster 的自动分区提供高可用性。
您可以对这些类型运行原子操作，例如附加到字符串；递增哈希中的值；将元素推入列表；计算集合交集、并集和差集；或获得排序集中排名最高的成员。
为了获得最佳性能，Redis 使用内存中的数据集。根据您的用例，Redis 可以通过定期将数据集转储到磁盘或通过将每个命令附加到基于磁盘的日志来持久保存您的数据。如果您只需要功能丰富的联网内存缓存，也可以禁用持久性。
Redis 支持异步复制，具有快速非阻塞同步和自动重新连接，并在网络拆分时进行部分重新同步。
您可以从大多数编程语言中使用 Redis 。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/ce5112dfbafe5d8a103b3220cbb4f844/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-02T16:49:40+08:00" />
<meta property="article:modified_time" content="2023-03-02T16:49:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis底层数据结构</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_4" rel="nofollow">前言</a></li><li><a href="#Redis_10" rel="nofollow">一、什么是Redis</a></li><li><a href="#_28" rel="nofollow">二、底层数据结构有哪些</a></li><li><a href="#Redis___40" rel="nofollow">三、Redis进阶 - 数据结构：底层数据结构详解</a></li><li><ul><li><a href="#1__sds_41" rel="nofollow">1.简单动态字符串 - sds</a></li><li><ul><li><a href="#1SDS__45" rel="nofollow">（1）SDS 定义</a></li><li><a href="#2SDS_102" rel="nofollow">（2）为什么使用SDS</a></li><li><a href="#3_124" rel="nofollow">（3）空间预分配补进一步理解</a></li><li><a href="#4_132" rel="nofollow">（4）小结</a></li></ul> 
   </li><li><a href="#2__ZipList_145" rel="nofollow">2.压缩列表 - ZipList</a></li><li><ul><li><a href="#1ziplist_149" rel="nofollow">（1）ziplist结构</a></li><li><a href="#2Entry_158" rel="nofollow">（2）Entry结构</a></li><li><a href="#3ZipList_229" rel="nofollow">（3）为什么ZipList特别省内存</a></li><li><a href="#4ziplist_243" rel="nofollow">（4）ziplist的缺点</a></li></ul> 
   </li><li><a href="#3__QuickList_251" rel="nofollow">3.快表 - QuickList</a></li><li><ul><li><a href="#1quicklist_256" rel="nofollow">（1）quicklist结构</a></li><li><a href="#2quicklist_351" rel="nofollow">（2）quicklist内存布局图</a></li><li><a href="#3quicklist_355" rel="nofollow">（3）quicklist更多额外信息</a></li></ul> 
   </li><li><a href="#4__Dict_380" rel="nofollow">4.字典/哈希表 - Dict</a></li><li><ul><li><a href="#1_382" rel="nofollow">（1）数据结构</a></li><li><a href="#2_423" rel="nofollow">（2）一些要点</a></li></ul> 
   </li><li><a href="#5__IntSet_448" rel="nofollow">5.整数集 - IntSet</a></li><li><ul><li><a href="#1intset_452" rel="nofollow">（1）intset结构</a></li><li><a href="#2_465" rel="nofollow">（2）内存布局图</a></li><li><a href="#3_469" rel="nofollow">（3）整数集合的升级</a></li></ul> 
   </li><li><a href="#6__ZSkipList_480" rel="nofollow">6.跳表 - ZSkipList</a></li><li><ul><li><a href="#1_482" rel="nofollow">（1）什么是跳跃表</a></li><li><a href="#2Redis_492" rel="nofollow">（2）Redis跳跃表的设计</a></li><li><a href="#3_525" rel="nofollow">（3）为什么不用平衡树或者哈希表</a></li></ul> 
   </li><li><a href="#7_552" rel="nofollow">7.参考文章</a></li></ul> 
  </li><li><a href="#_562" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_4"></a>前言</h2> 
<p>Redis 是一个数据结构服务器。Redis 的核心是提供一组原生数据类型，可帮助您解决各种各样的问题，从缓存到队列再到事件处理。下面是每种数据类型的简短描述，以及更广泛的概述。</p> 
<hr> 
<h2><a id="Redis_10"></a>一、什么是Redis</h2> 
<p>REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是<strong>跨平台</strong>的<strong>非关系型数据库</strong>。</p> 
<p>Redis 是一个<strong>开源</strong>的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。</p> 
<p>Redis 通常被称为<strong>数据结构数据库</strong>，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets)和有序集合(sorted sets)等类型。</p> 
<p>Redis 是一种开源（BSD 许可）内存数据结构存储，用作数据库、缓存、消息代理和流引擎。Redis 提供数据结构，例如 字符串、散列、列表、集合、带范围查询的排序集合、位图、hyperloglogs、地理空间索引和流。Redis 具有内置复制、Lua 脚本、LRU 逐出、事务和不同级别的磁盘持久性，并通过Redis Sentinel和Redis Cluster 的自动分区提供高可用性。</p> 
<p>您可以对这些类型运行原子操作，例如附加到字符串；递增哈希中的值；将元素推入列表；计算集合交集、并集和差集；或获得排序集中排名最高的成员。</p> 
<p>为了获得最佳性能，Redis 使用内存中的数据集。根据您的用例，Redis 可以通过定期将数据集转储到磁盘或通过将每个命令附加到基于磁盘的日志来持久保存您的数据。如果您只需要功能丰富的联网内存缓存，也可以禁用持久性。</p> 
<p>Redis 支持异步复制，具有快速非阻塞同步和自动重新连接，并在网络拆分时进行部分重新同步。</p> 
<p>您可以从大多数编程语言中使用 Redis 。<br> Redis 是用ANSI C编写的，适用于大多数 POSIX 系统，如 Linux、*BSD 和 Mac OS X，无需外部依赖。Linux和OS X是Redis开发和测试最多的两个操作系统，我们推荐使用Linux进行部署。Redis 可以在 SmartOS 等 Solaris 派生系统中工作，但支持是最大的努力。<strong>Windows 版本没有官方支持。</strong></p> 
<h2><a id="_28"></a>二、底层数据结构有哪些</h2> 
<blockquote> 
 <p>以下内容引用自【原文链接：<a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html" rel="nofollow">https://pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html</a>】</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/c7/48/tCV7gOT3_o.png" alt="在这里插入图片描述"></p> 
<ul><li>简单动态字符串 - sds</li><li>压缩列表 - ZipList</li><li>快表 - QuickList</li><li>字典/哈希表 - Dict</li><li>整数集 - IntSet</li><li>跳表 - ZSkipList</li></ul> 
<h2><a id="Redis___40"></a>三、Redis进阶 - 数据结构：底层数据结构详解</h2> 
<h3><a id="1__sds_41"></a>1.简单动态字符串 - sds</h3> 
<blockquote> 
 <p>Redis 是用 C 语言写的，但是对于Redis的字符串，却不是 C语言中的字符串（即以空字符’\0’结尾的字符数组），它是自己构建了一种名为 简单动态字符串（simple dynamicstring,SDS）的抽象类型，并将 SDS 作为 Redis的默认字符串表示。</p> 
</blockquote> 
<h4><a id="1SDS__45"></a>（1）SDS 定义</h4> 
<blockquote> 
 <p>这是一种用于存储二进制数据的一种结构，具有动态扩容的特点。其实现位于src/sds.h与src/sds.c中。</p> 
</blockquote> 
<ul><li>SDS的总体概览如下图:<br> <img src="https://images2.imgbox.com/e1/2a/c1QOHfVg_o.png" alt="在这里插入图片描述"></li></ul> 
<p>其中<code>sdshdr</code>是头部，<code>buf</code>是真实存储用户数据的地方。另外注意，从命名上能看出来，这个数据结构除了能存储二进制数据，显然是用于设计作为字符串使用的，所以在buf中，用户数据后总跟着一个\0。即图中 <code>"数据" + "\0"</code> 是为所谓的buf。</p> 
<ul><li>如下是6.0源码中sds相关的结构：</li></ul> 
<pre><code class="prism language-c"><span class="token comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.
 * However is here to document the layout of type 5 SDS strings. */</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr5</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, and 5 msb of string length */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr8</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">uint8_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>
    <span class="token class-name">uint8_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr16</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">uint16_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>
    <span class="token class-name">uint16_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr32</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">uint32_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>
    <span class="token class-name">uint32_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr64</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">uint64_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>
    <span class="token class-name">uint64_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>通过上图我们可以看到，SDS有五种不同的头部。 其中sdshdr5实际并未使用到。所以实际上有四种不同的头部，分别如下:</p> 
<p><img src="https://images2.imgbox.com/40/26/v6h6GVNM_o.png" alt="在这里插入图片描述"></p> 
<p>其中：</p> 
<ul><li><code>len</code> 保存了SDS保存字符串的长度</li><li><code>buf[]</code> 数组用来保存字符串的每个元素</li><li><code>alloc</code>分别以uint8，uint16，uint32，uint64表示整个SDS，除过头部与末尾的\0，剩余的字节数。</li><li><code>flags</code> 始终为一字节，以低三位标示着头部的类型，高5位未使用。</li></ul> 
<hr> 
<h4><a id="2SDS_102"></a>（2）为什么使用SDS</h4> 
<blockquote> 
 <p>为什么不使用C语言字符串实现，而是使用 SDS呢？这样实现有什么好处？</p> 
</blockquote> 
<ul><li> <p><strong>常数复杂度获取字符串长度</strong><br> 由于 len 属性的存在，我们获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O(1)。而对于 C 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。通过 <code>strlen key</code> 命令可以获取 key 的字符串长度。</p> </li><li> <p><strong>杜绝缓冲区溢出</strong><br> 我们知道在 C 语言中使用 <code>strcat</code> 函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。而对于 SDS 数据类型，在进行字符修改的时候，<strong>会首先根据记录的 len 属性检查内存空间是否满足需求</strong>，如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出。</p> </li><li> <p><strong>减少修改字符串的内存重新分配次数</strong><br> C语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。<br> 而对于SDS，由于<code>len</code>属性和<code>alloc</code>属性的存在，对于修改字符串SDS实现了空间预分配和惰性空间释放两种策略：<br> 1、 <code>空间预分配</code>：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。<br> 2、 <code>惰性空间释放</code>：对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 <code>alloc</code> 属性将这些字节的数量记录下来，等待后续使用。（当然SDS也提供了相应的API，当我们有需要时，也可以手动释放这些未使用的空间。）</p> </li><li> <p><strong>二进制安全</strong><br> 因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而所有 SDS 的API 都是以处理二进制的方式来处理 <code>buf</code> 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。</p> </li><li> <p><strong>兼容部分 C 字符串函数</strong><br> 虽然 SDS 是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库<code>&lt;string.h&gt;</code> 中的一部分函数。</p> </li></ul> 
<hr> 
<h4><a id="3_124"></a>（3）空间预分配补进一步理解</h4> 
<p>当执行追加操作时，比如现在给<code>key=‘Hello World’</code>的字符串后追加<code>‘ again!’</code>则这时的len=18，free由0变成了18，此时的<code>buf='Hello World again!\0....................'</code>(.表示空格)，也就是buf的内存空间是18+18+1=37个字节，其中‘\0’占1个字节redis给字符串多分配了18个字节的预分配空间，所以下次还有append追加的时候，如果预分配空间足够，就无须在进行空间分配了。在当前版本中，当新字符串的长度小于1M时，redis会分配他们所需大小一倍的空间，当大于1M的时候，就为他们额外多分配1M的空间。</p> 
<p>思考：<strong>这种分配策略会浪费内存资源吗？</strong><br> 答：执行过APPEND 命令的字符串会带有额外的预分配空间，这些预分配空间不会被释放，除非该字符串所对应的键被删除，或者等到关闭Redis 之后，再次启动时重新载入的字符串对象将不会有预分配空间。因为执行APPEND 命令的字符串键数量通常并不多，占用内存的体积通常也不大，所以这一般并不算什么问题。另一方面，如果执行APPEND 操作的键很多，而字符串的体积又很大的话，那可能就需要修改Redis 服务器，让它定时释放一些字符串键的预分配空间，从而更有效地使用内存。</p> 
<hr> 
<h4><a id="4_132"></a>（4）小结</h4> 
<p>redis的字符串表示为sds，而不是C字符串（以\0结尾的char*）， 它是Redis 底层所使用的字符串表示，它被用在几乎所有的Redis 模块中。可以看如下对比：</p> 
<table><thead><tr><th>C字符串</th><th>SDS</th></tr></thead><tbody><tr><td>获取字符串长度的复杂度为O(N)</td><td>获取字符串长度的复杂度为O(1)</td></tr><tr><td>API是不安全的，可能会造成缓冲区溢出</td><td>API是安全的，不会造成缓冲区溢出</td></tr><tr><td>修改字符串长度N次内存重分配</td><td>修改字符串长度N次最多需要执行N次内存重分配</td></tr><tr><td>只能保存文本数据</td><td>可以保存文本或者二进制数据</td></tr><tr><td>可以适用所有&lt;string.h&gt;库中的函数</td><td>可以使用一部分&lt;string.h&gt;库中的函数</td></tr></tbody></table> 
<p>一般来说，SDS 除了保存数据库中的字符串值以外，SDS 还可以作为缓冲区（buffer）：包括 AOF 模块中的AOF缓冲区以及客户端状态中的输入缓冲区。</p> 
<h3><a id="2__ZipList_145"></a>2.压缩列表 - ZipList</h3> 
<blockquote> 
 <p>ziplist是为了提高存储效率而设计的一种特殊编码的双向链表。它可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储。它能在O(1)的时间复杂度下完成list两端的push和pop操作。但是因为每次操作都需要重新分配ziplist的内存，所以实际复杂度和ziplist的内存使用量相关。</p> 
</blockquote> 
<h4><a id="1ziplist_149"></a>（1）ziplist结构</h4> 
<p>整个ziplist在内存中的存储格式如下：<br> <img src="https://images2.imgbox.com/15/1e/WqPTz1N2_o.png" alt="在这里插入图片描述"></p> 
<ul><li><code>zlbytes</code>字段的类型是uint32_t，这个字段中存储的是整个ziplist所占用的内存的字节数</li><li><code>zltail</code>字段的类型是uint32_t，它指的是ziplist中最后一个entry的偏移量。 用于快速定位最后一个entry，以快速完成pop等操作</li><li><code>zllen</code>字段的类型是uint16_t，它指的是整个ziplit中entry的数量。 这个值只占2bytes（16位）: 如果ziplist中entry的数目小于65535(2的16次方)，那么该字段中存储的就是实际entry的值。 若等于或超过65535，那么该字段的值固定为65535，但实际数量需要一个个entry的去遍历所有entry才能得到。</li><li><code>zlend</code>是一个终止字节，其值为全F，即0xff。 ziplist保证任何情况下，一个entry的首字节都不会是255</li></ul> 
<h4><a id="2Entry_158"></a>（2）Entry结构</h4> 
<p>那么entry是什么结构呢？</p> 
<ul><li>先看下源码中相关介绍</li></ul> 
<p><strong>第一种情况</strong>：一般结构 <code>&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</code><br> <code>prevlen</code>：前一个entry的大小，编码方式见下文；<br> <code>encoding</code>：不同的情况下值不同，用于表示当前entry的类型和长度；<br> <code>entry-data</code>：这是用于存储entry表示的数据；<br> <strong>第二种情况</strong>：在entry中存储的是int类型时，encoding和entry-data会合并在encoding中表示，此时没有entry-data字段；<br> redis中，在存储数据时，会先尝试将string转换成int存储，节省空间；<br> 此时entry结构：<code>&lt;prevlen&gt; &lt;encoding&gt;</code></p> 
<ul><li><strong>prevlen编码</strong></li></ul> 
<p>当前一个元素长度小于254（255用于zlend）的时候，prevlen长度为1个字节，值即为前一个entry的长度，如果长度大于等于254的时候，prevlen用5个字节表示，第一字节设置为254，后面4个字节存储一个小端的无符号整型，表示前一个entry的长度；</p> 
<pre><code class="prism language-sh"><span class="token operator">&lt;</span>prevlen from <span class="token number">0</span> to <span class="token number">25</span><span class="token operator"><span class="token file-descriptor important">3</span>&gt;</span> <span class="token operator">&lt;</span>encoding<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>entry<span class="token operator">&gt;</span>      //长度小于254结构
0xFE <span class="token operator">&lt;</span><span class="token number">4</span> bytes unsigned little endian prevlen<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>encoding<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>entry<span class="token operator">&gt;</span>   //长度大于等于254
</code></pre> 
<ul><li>encoding编码<br> encoding的长度和值根据保存的是int还是string，还有数据的长度而定；<br> 前两位用来表示类型，当为“11”时，表示entry存储的是int类型，其它表示存储的是string；</li></ul> 
<p><strong>存储string时</strong>：<br> <code>|00pppppp|</code> ：此时encoding长度为1个字节，该字节的后六位表示entry中存储的string长度，因为是6位，所以entry中存储的string长度不能超过63；<br> <code>|01pppppp|qqqqqqqq|</code> 此时encoding长度为两个字节；<br> 此时encoding的后14位用来存储string长度，长度不能超过16383；<br> <code>|10000000|qqqqqqqq|rrrrrrrr|ssssssss|ttttttt|</code> 此时encoding长度为5个字节，后面的4个字节用来表示encoding中存储的字符串长度，长度不能超过2^32 - 1；<br> <strong>存储int时</strong>：<br> <code>|11000000|</code> encoding为3个字节，后2个字节表示一个int16；<br> <code>|11010000|</code> encoding为5个字节，后4个字节表示一个int32；<br> <code>|11100000|</code> encoding 为9个字节，后8字节表示一个int64；<br> <code>|11110000|</code> encoding为4个字节，后3个字节表示一个有符号整型；<br> <code>|11111110|</code> encoding为2字节，后1个字节表示一个有符号整型；<br> <code>|1111xxxx|</code> encoding长度就只有1个字节，xxxx表示一个0 - 12的整数值；<br> <code>|11111111|</code> 还记得zlend么？</p> 
<ul><li><strong>源码中数据结构支撑</strong><br> 你可以看到为了操作上的简易实际还增加了几个属性</li></ul> 
<pre><code class="prism language-c"><span class="token comment">/* We use this function to receive information about a ziplist entry.
 * Note that this is not how the data is actually encoded, is just what we
 * get filled by a function in order to operate more easily. */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zlentry</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> prevrawlensize<span class="token punctuation">;</span> <span class="token comment">/* Bytes used to encode the previous entry len*/</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> prevrawlen<span class="token punctuation">;</span>     <span class="token comment">/* Previous entry len. */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> lensize<span class="token punctuation">;</span>        <span class="token comment">/* Bytes used to encode this entry type/len.
                                    For example strings have a 1, 2 or 5 bytes
                                    header. Integers always use a single byte.*/</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">;</span>            <span class="token comment">/* Bytes used to represent the actual entry.
                                    For strings this is just the string length
                                    while for integers it is 1, 2, 3, 4, 8 or
                                    0 (for 4 bit immediate) depending on the
                                    number range. */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> headersize<span class="token punctuation">;</span>     <span class="token comment">/* prevrawlensize + lensize. */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> encoding<span class="token punctuation">;</span>      <span class="token comment">/* Set to ZIP_STR_* or ZIP_INT_* depending on
                                    the entry encoding. However for 4 bits
                                    immediate integers this can assume a range
                                    of values and must be range-checked. */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>            <span class="token comment">/* Pointer to the very start of the entry, that
                                    is, this points to prev-entry-len field. */</span>
<span class="token punctuation">}</span> zlentry<span class="token punctuation">;</span>
</code></pre> 
<p><code>prevrawlensize</code>表示 previous_entry_length字段的长度<br> <code>prevrawlen</code>表示 previous_entry_length字段存储的内容<br> <code>lensize</code>表示 encoding字段的长度len表示数据内容长度<br> <code>headersize</code> 表示当前元素的首部长度，即previous_entry_length字段长度与encoding字段长度之和<br> <code>encoding</code>表示数据类型<br> <code>p</code>表示当前元素首地址</p> 
<h4><a id="3ZipList_229"></a>（3）为什么ZipList特别省内存</h4> 
<blockquote> 
 <p>所以只有理解上面的Entry结构，我们才会真正理解ZipList为什么是特别节省内存的数据结构。</p> 
</blockquote> 
<ul><li>ziplist节省内存是相对于普通的list来说的，如果是普通的数组，那么它每个元素占用的内存是一样的且取决于最大的那个元素（很明显它是需要预留空间的）；</li><li>所以ziplist在设计时就很容易想到要尽量让每个元素按照实际的内容大小存储，所以增加encoding字段，针对不同的encoding来细化存储大小；</li><li>这时候还需要解决的一个问题是遍历元素时如何定位下一个元素呢？在普通数组中每个元素定长，所以不需要考虑这个问题；<br> 但是ziplist中每个data占据的内存不一样，所以为了解决遍历，需要增加记录上一个元素的length，<strong>所以增加了prelen字段</strong>。</li></ul> 
<p><strong>为什么我们去研究ziplist特别节省内存的数据结构？</strong><br> 在实际应用中，大量存储字符串的优化是需要你对底层的数据结构有一定的理解的，而ziplist在场景优化的时候也被考虑采用的首选。</p> 
<hr> 
<h4><a id="4ziplist_243"></a>（4）ziplist的缺点</h4> 
<p>最后我们再看看它的一些缺点：</p> 
<ul><li>ziplist也不预留内存空间，并且在移除结点后，也是立即缩容，这代表每次写操作都会进行内存分配操作。</li><li>结点如果扩容，导致结点占用的内存增长，并且超过254字节的话，可能会导致链式反应: 其后一个结点的entry.prevlen需要从一字节扩容至五字节。 <strong>最坏情况下，第一个结点的扩容，会导致整个ziplist表中的后续所有结点的entry.prevlen字段扩容。</strong> 虽然这个内存重分配的操作依然只会发生一次，但代码中的时间复杂度是o(N)级别，因为链式扩容只能一步一步的计算。 但这种情况的概率十分的小，一般情况下链式扩容能连锁反映五六次就很不幸了。 之所以说这是一个蛋疼问题，是因为，这样的坏场景下，其实时间复杂度并不高: 依次计算每个entry新的空间占用，也就是o(N)，总体占用计算出来后，只执行一次内存重分配，与对应的memmove操作，就可以了。</li></ul> 
<hr> 
<h3><a id="3__QuickList_251"></a>3.快表 - QuickList</h3> 
<blockquote> 
 <p>quicklist这个结构是Redis在3.2版本后新加的，之前的版本是list(即linkedlist)， 用于String数据类型中。</p> 
</blockquote> 
<p>它是一种以ziplist为结点的双端链表结构. 宏观上，quicklist是一个链表，微观上，链表中的每个结点都是一个ziplist。</p> 
<h4><a id="1quicklist_256"></a>（1）quicklist结构</h4> 
<p>如下是6.0源码中quicklist相关的结构：</p> 
<pre><code class="prism language-c"><span class="token comment">/* Node, quicklist, and Iterator are the only data structures used currently. */</span>

<span class="token comment">/* quicklistNode is a 32 byte struct describing a ziplist for a quicklist.
 * We use bit fields keep the quicklistNode at 32 bytes.
 * count: 16 bits, max 65536 (max zl bytes is 65k, so max count actually &lt; 32k).
 * encoding: 2 bits, RAW=1, LZF=2.
 * container: 2 bits, NONE=1, ZIPLIST=2.
 * recompress: 1 bit, bool, true if node is temporarry decompressed for usage.
 * attempted_compress: 1 bit, boolean, used for verifying during testing.
 * extra: 10 bits, free for future use; pads out the remainder of 32 bits */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">quicklistNode</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">struct</span> <span class="token class-name">quicklistNode</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">quicklistNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>zl<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> sz<span class="token punctuation">;</span>             <span class="token comment">/* ziplist size in bytes */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> count <span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">;</span>     <span class="token comment">/* count of items in ziplist */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> encoding <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>   <span class="token comment">/* RAW==1 or LZF==2 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> container <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">/* NONE==1 or ZIPLIST==2 */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> recompress <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* was this node previous compressed? */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> attempted_compress <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* node can't compress; too small */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> extra <span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">/* more bits to steal for future usage */</span>
<span class="token punctuation">}</span> quicklistNode<span class="token punctuation">;</span>

<span class="token comment">/* quicklistLZF is a 4+N byte struct holding 'sz' followed by 'compressed'.
 * 'sz' is byte length of 'compressed' field.
 * 'compressed' is LZF data with total (compressed) length 'sz'
 * NOTE: uncompressed length is stored in quicklistNode-&gt;sz.
 * When quicklistNode-&gt;zl is compressed, node-&gt;zl points to a quicklistLZF */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">quicklistLZF</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> sz<span class="token punctuation">;</span> <span class="token comment">/* LZF size in bytes*/</span>
    <span class="token keyword">char</span> compressed<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> quicklistLZF<span class="token punctuation">;</span>

<span class="token comment">/* Bookmarks are padded with realloc at the end of of the quicklist struct.
 * They should only be used for very big lists if thousands of nodes were the
 * excess memory usage is negligible, and there's a real need to iterate on them
 * in portions.
 * When not used, they don't add any memory overhead, but when used and then
 * deleted, some overhead remains (to avoid resonance).
 * The number of bookmarks used should be kept to minimum since it also adds
 * overhead on node deletion (searching for a bookmark to update). */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">quicklistBookmark</span> <span class="token punctuation">{<!-- --></span>
    quicklistNode <span class="token operator">*</span>node<span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>
<span class="token punctuation">}</span> quicklistBookmark<span class="token punctuation">;</span>


<span class="token comment">/* quicklist is a 40 byte struct (on 64-bit systems) describing a quicklist.
 * 'count' is the number of total entries.
 * 'len' is the number of quicklist nodes.
 * 'compress' is: -1 if compression disabled, otherwise it's the number
 *                of quicklistNodes to leave uncompressed at ends of quicklist.
 * 'fill' is the user-requested (or default) fill factor.
 * 'bookmakrs are an optional feature that is used by realloc this struct,
 *      so that they don't consume memory when not used. */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">quicklist</span> <span class="token punctuation">{<!-- --></span>
    quicklistNode <span class="token operator">*</span>head<span class="token punctuation">;</span>
    quicklistNode <span class="token operator">*</span>tail<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> count<span class="token punctuation">;</span>        <span class="token comment">/* total count of all entries in all ziplists */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span>          <span class="token comment">/* number of quicklistNodes */</span>
    <span class="token keyword">int</span> fill <span class="token operator">:</span> QL_FILL_BITS<span class="token punctuation">;</span>              <span class="token comment">/* fill factor for individual nodes */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> compress <span class="token operator">:</span> QL_COMP_BITS<span class="token punctuation">;</span> <span class="token comment">/* depth of end nodes not to compress;0=off */</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> bookmark_count<span class="token operator">:</span> QL_BM_BITS<span class="token punctuation">;</span>
    quicklistBookmark bookmarks<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> quicklist<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">quicklistIter</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> quicklist <span class="token operator">*</span>quicklist<span class="token punctuation">;</span>
    quicklistNode <span class="token operator">*</span>current<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>zi<span class="token punctuation">;</span>
    <span class="token keyword">long</span> offset<span class="token punctuation">;</span> <span class="token comment">/* offset in current ziplist */</span>
    <span class="token keyword">int</span> direction<span class="token punctuation">;</span>
<span class="token punctuation">}</span> quicklistIter<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">quicklistEntry</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> quicklist <span class="token operator">*</span>quicklist<span class="token punctuation">;</span>
    quicklistNode <span class="token operator">*</span>node<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>zi<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>value<span class="token punctuation">;</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> longval<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> sz<span class="token punctuation">;</span>
    <span class="token keyword">int</span> offset<span class="token punctuation">;</span>
<span class="token punctuation">}</span> quicklistEntry<span class="token punctuation">;</span>
</code></pre> 
<p>这里定义了6个结构体:</p> 
<ul><li><code>quicklistNode</code>，宏观上，quicklist是一个链表，这个结构描述的就是链表中的结点。它通过zl字段持有底层的ziplist。简单来讲，它描述了一个ziplist实例</li><li><code>quicklistLZF</code>，ziplist是一段连续的内存，用LZ4算法压缩后，就可以包装成一个quicklistLZF结构。是否压缩quicklist中的每个ziplist实例是一个可配置项。若这个配置项是开启的，那么quicklistNode.zl字段指向的就不是一个ziplist实例，而是一个压缩后的quicklistLZF实例</li><li><code>quicklistBookmark</code>，在quicklist尾部增加的一个书签，它只有在大量节点的多余内存使用量可以忽略不计的情况且确实需要分批迭代它们，才会被使用。当不使用它们时，它们不会增加任何内存开销。</li><li><code>quicklist</code>，这就是一个双链表的定义。head、tail分别指向头尾指针。len代表链表中的结点。count指的是整个quicklist中的所有ziplist中的entry的数目。fill字段影响着每个链表结点中ziplist的最大占用空间，compress影响着是否要对每个ziplist以LZ4算法进行进一步压缩以更节省内存空间。</li><li><code>quicklistIter</code>是一个迭代器</li><li><code>quicklistEntry</code>是对ziplist中的entry概念的封装。quicklist作为一个封装良好的数据结构，不希望使用者感知到其内部的实现，所以需要把ziplist.entry的概念重新包装一下。</li></ul> 
<h4><a id="2quicklist_351"></a>（2）quicklist内存布局图</h4> 
<p>quicklist的内存布局图如下所示:<br> <img src="https://images2.imgbox.com/27/1c/RpvHFkWU_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3quicklist_355"></a>（3）quicklist更多额外信息</h4> 
<p>下面是有关quicklist的更多额外信息:</p> 
<ul><li><code>quicklist.fill</code>的值影响着每个链表结点中，ziplist的长度。<br> ①当数值为负数时，代表以字节数限制单个ziplist的最大长度。<br> 具体为：<br> -1 不超过4kb；<br> -2 不超过 8kb；<br> -3 不超过 16kb；<br> -4 不超过 32kb；<br> -5 不超过 64kb<br> ②当数值为正数时，代表以entry数目限制单个ziplist的长度。值即为数目。由于该字段仅占16位，所以以entry数目限制ziplist的容量时，最大值为2^15个。</li><li><code>quicklist.compress</code>的值影响着quicklistNode.zl字段指向的是原生的ziplist，还是经过压缩包装后的quicklistLZF<br> ①0 表示不压缩，zl字段直接指向ziplist<br> ②1 表示quicklist的链表头尾结点不压缩，其余结点的zl字段指向的是经过压缩后的quicklistLZF<br> ③2 表示quicklist的链表头两个，与末两个结点不压缩，其余结点的zl字段指向的是经过压缩后的quicklistLZF<br> ④以此类推，最大值为2^16quicklistNode.encoding字段，以指示本链表结点所持有的ziplist是否经过了压缩。1代表未压缩，持有的是原生的ziplist，2代表压缩过</li><li><code>quicklistNode.container</code>字段指示的是每个链表结点所持有的数据类型是什么。默认的实现是ziplist，对应的该字段的值是2，目前Redis没有提供其它实现。所以实际上，该字段的值恒为2</li><li><code>quicklistNode.recompress</code>字段指示的是当前结点所持有的ziplist是否经过了解压。如果该字段为1即代表之前被解压过，且需要在下一次操作时重新压缩。</li></ul> 
<p>quicklist的具体实现代码篇幅很长，这里就不贴代码片断了，从内存布局上也能看出来，由于每个结点持有的ziplist是有上限长度的，所以在与操作时要考虑的分支情况比较多。</p> 
<p>quicklist有自己的优点，也有缺点，对于使用者来说，其使用体验类似于线性数据结构，list作为最传统的双链表，结点通过指针持有数据，指针字段会耗费大量内存。ziplist解决了耗费内存这个问题。但引入了新的问题: 每次写操作整个ziplist的内存都需要重分配。quicklist在两者之间做了一个平衡。并且使用者可以通过自定义<code>quicklist.fill</code>，根据实际业务情况，经验主义调参。</p> 
<hr> 
<h3><a id="4__Dict_380"></a>4.字典/哈希表 - Dict</h3> 
<p>本质上就是哈希表, 这个在很多语言中都有，对于开发人员人员来说比较熟悉，这里就简单介绍下。</p> 
<h4><a id="1_382"></a>（1）数据结构</h4> 
<p><strong>哈希表结构定义：</strong></p> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictht</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">//哈希表数组</span>
    dictEntry <span class="token operator">*</span><span class="token operator">*</span>table<span class="token punctuation">;</span>
    <span class="token comment">//哈希表大小</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span>
    <span class="token comment">//哈希表大小掩码，用于计算索引值</span>
    <span class="token comment">//总是等于 size-1</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sizemask<span class="token punctuation">;</span>
    <span class="token comment">//该哈希表已有节点的数量</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">;</span>
 
<span class="token punctuation">}</span>dictht
</code></pre> 
<p>哈希表是由数组 table 组成，table 中每个元素都是指向 dict.h/dictEntry 结构，dictEntry 结构定义如下：</p> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span><span class="token punctuation">{<!-- --></span>
     <span class="token comment">//键</span>
     <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>
     <span class="token comment">//值</span>
     <span class="token keyword">union</span><span class="token punctuation">{<!-- --></span>
          <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">;</span>
          uint64_tu64<span class="token punctuation">;</span>
          int64_ts64<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>v<span class="token punctuation">;</span>
 
     <span class="token comment">//指向下一个哈希表节点，形成链表</span>
     <span class="token keyword">struct</span> <span class="token class-name">dictEntry</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>dictEntry
</code></pre> 
<p>key 用来保存键，val 属性用来保存值，值可以是一个指针，也可以是uint64_t整数，也可以是int64_t整数。</p> 
<p>注意这里还有一个指向下一个哈希表节点的指针，我们知道哈希表最大的问题是存在哈希冲突，如何解决哈希冲突，有开放地址法和链地址法。这里采用的便是链地址法，通过next这个指针可以将多个哈希值相同的键值对连接在一起，用来<strong>解决哈希冲突</strong>。<br> <img src="https://images2.imgbox.com/6f/16/lsZGIxWs_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_423"></a>（2）一些要点</h4> 
<ul><li>哈希算法：Redis计算哈希值和索引值方法如下：</li></ul> 
<pre><code class="prism language-sh"><span class="token comment">#1、使用字典设置的哈希函数，计算键 key 的哈希值</span>
<span class="token builtin class-name">hash</span> <span class="token operator">=</span> dict-<span class="token operator">&gt;</span>type-<span class="token operator">&gt;</span>hashFunction<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">#2、使用哈希表的sizemask属性和第一步得到的哈希值，计算索引值</span>
index <span class="token operator">=</span> <span class="token builtin class-name">hash</span> <span class="token operator">&amp;</span> dict-<span class="token operator">&gt;</span>ht<span class="token punctuation">[</span>x<span class="token punctuation">]</span>.sizemask<span class="token punctuation">;</span>
</code></pre> 
<ul><li>解决哈希冲突：这个问题上面我们介绍了，方法是链地址法。通过字典里面的 * next 指针指向下一个具有相同索引值的哈希表节点。</li><li>扩容和收缩：当哈希表保存的键值对太多或者太少时，就要通过 rerehash(重新散列）来对哈希表进行相应的扩展或者收缩。具体步骤：<br> 1、如果执行扩展操作，会基于原哈希表创建一个大小等于 ht[0].used*2n 的哈希表（也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表）。相反如果执行的是收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表。<br> 2、重新利用上面的哈希算法，计算索引值，然后将键值对放到新的哈希表位置上。<br> 3、所有键值对都迁徙完毕后，释放原哈希表的内存空间。</li><li>触发扩容的条件：<br> 1、服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于1。<br> 2、服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于5。<br> ps：负载因子 = 哈希表已保存节点数量 / 哈希表大小。</li><li>渐近式 rehash<br> 什么叫渐进式 rehash？也就是说扩容和收缩操作不是一次性、集中式完成的，而是分多次、渐进式完成的。如果保存在Redis中的键值对只有几个几十个，那么 rehash 操作可以瞬间完成，但是如果键值对有几百万，几千万甚至几亿，那么要一次性的进行 rehash，势必会造成Redis一段时间内不能进行别的操作。所以Redis采用渐进式 rehash,这样在进行渐进式rehash期间，字典的删除查找更新等操作可能会在两个哈希表上进行，第一个哈希表没有找到，就会去第二个哈希表上进行查找。但是进行 增加操作，一定是在新的哈希表上进行的。</li></ul> 
<hr> 
<h3><a id="5__IntSet_448"></a>5.整数集 - IntSet</h3> 
<blockquote> 
 <p>整数集合（intset）是集合类型的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。</p> 
</blockquote> 
<h4><a id="1intset_452"></a>（1）intset结构</h4> 
<p>首先看源码结构</p> 
<pre><code>typedef struct intset {
    uint32_t encoding;
    uint32_t length;
    int8_t contents[];
} intset;
</code></pre> 
<p><code>encoding</code> 表示编码方式，的取值有三个：INTSET_ENC_INT16, INTSET_ENC_INT32, INTSET_ENC_INT64<br> <code>length</code> 代表其中存储的整数的个数<br> <code>contents</code> 指向实际存储数值的连续内存区域, 就是一个数组；整数集合的每个元素都是 contents 数组的一个数组项（item），各个项在数组中按值得大小从小到大有序排序，且数组中不包含任何重复项。（虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组，但实际上 contents 数组并不保存任何 int8_t 类型的值，contents 数组的真正类型取决于 encoding 属性的值）</p> 
<h4><a id="2_465"></a>（2）内存布局图</h4> 
<p>其内存布局如下图所示<br> <img src="https://images2.imgbox.com/15/d2/ipp28Gej_o.png" alt="在这里插入图片描述"><br> 我们可以看到，content数组里面每个元素的数据类型是由encoding来决定的，那么如果原来的数据类型是int16, 当我们再插入一个int32类型的数据时怎么办呢？这就是下面要说的intset的升级。</p> 
<h4><a id="3_469"></a>（3）整数集合的升级</h4> 
<p>当在一个int16类型的整数集合中插入一个int32类型的值，整个集合的所有元素都会转换成32类型。 整个过程有三步：</p> 
<ol><li>根据新元素的类型（比如int32），扩展整数集合底层数组的空间大小，并为新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。</li><li>最后改变encoding的值，length+1。</li></ol> 
<p><strong>那么如果我们删除掉刚加入的int32类型时，会不会做一个降级操作呢？</strong><br> 不会。主要还是减少开销的权衡。</p> 
<hr> 
<h3><a id="6__ZSkipList_480"></a>6.跳表 - ZSkipList</h3> 
<blockquote> 
 <p>跳跃表结构在 Redis 中的运用场景只有一个，那就是作为有序列表 (Zset) 的使用。跳跃表的性能可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且在实现方面比平衡树要优雅，这就是跳跃表的长处。跳跃表的缺点就是需要的存储空间比较大，属于利用空间来换取时间的数据结构。</p> 
</blockquote> 
<h4><a id="1_482"></a>（1）什么是跳跃表</h4> 
<blockquote> 
 <p>跳跃表要解决什么问题呢？如果你一上来就去看它的实现，你很难理解设计的本质，所以先要看它的设计要解决什么问题。</p> 
</blockquote> 
<p>对于于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。比如查找12，需要7次查找<br> <img src="https://images2.imgbox.com/2d/c1/F2NthFiL_o.png" alt="在这里插入图片描述"></p> 
<p>如果我们增加如下两级索引，那么它搜索次数就变成了3次<br> <img src="https://images2.imgbox.com/fc/11/latgLHKc_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2Redis_492"></a>（2）Redis跳跃表的设计</h4> 
<p>redis跳跃表并没有在单独的类（比如skplist.c)中定义，而是其定义在server.h中, 如下:</p> 
<pre><code class="prism language-c"><span class="token comment">/* ZSETs use a specialized version of Skiplists */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token punctuation">{<!-- --></span>
    sds ele<span class="token punctuation">;</span>
    <span class="token keyword">double</span> score<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>backward<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">zskiplistLevel</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>forward<span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> span<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> level<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> zskiplistNode<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplist</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>header<span class="token punctuation">,</span> <span class="token operator">*</span>tail<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> length<span class="token punctuation">;</span>
    <span class="token keyword">int</span> level<span class="token punctuation">;</span>
<span class="token punctuation">}</span> zskiplist<span class="token punctuation">;</span>
</code></pre> 
<p>其内存布局如下图:</p> 
<p>zskiplist的<strong>核心设计要点</strong></p> 
<ul><li>头节点不持有任何数据, 且其level[]的长度为32</li><li>每个结点 
  <ul><li><code>ele</code>字段，持有数据，是sds类型</li><li><code>score</code>字段, 其标示着结点的得分, 结点之间凭借得分来判断先后顺序, 跳跃表中的结点按结点的得分升序排列.</li><li><code>backward</code>指针, 这是原版跳跃表中所没有的. 该指针指向结点的前一个紧邻结点.</li><li><code>level</code>字段, 用以记录所有结点(除过头节点外)；每个结点中最多持有32个zskiplistLevel结构. 实际数量在结点创建时, 按幂次定律随机生成(不超过32). 每个zskiplistLevel中有两个字段 
    <ul><li>forward字段指向比自己得分高的某个结点(不一定是紧邻的), 并且, 若当前zskiplistLevel实例在level[]中的索引为X, 则其forward字段指向的结点, 其level[]字段的容量至少是X+1. 这也是上图中, 为什么forward指针总是画的水平的原因.</li><li>span字段代表forward字段指向的结点, 距离当前结点的距离. 紧邻的两个结点之间的距离定义为1.</li></ul> </li></ul> </li></ul> 
<h4><a id="3_525"></a>（3）为什么不用平衡树或者哈希表</h4> 
<p><strong>为什么不是平衡树，先看下作者的回答</strong><br> https://news.ycombinator.com/item?id=1171423</p> 
<pre><code class="prism language-sh">There are a few reasons:

They are not very memory intensive. It<span class="token string">'s up to you basically. Changing parameters about the probability of a node to have a given number of levels will make then less memory intensive than btrees.
A sorted set is often target of many ZRANGE or ZREVRANGE operations, that is, traversing the skip list as a linked list. With this operation the cache locality of skip lists is at least as good as with other kind of balanced trees.

They are simpler to implement, debug, and so forth. For instance thanks to the skip list simplicity I received a patch (already in Redis master) with augmented skip lists implementing ZRANK in O(log(N)). It required little changes to the code.

About the Append Only durability &amp; speed, I don'</span>t think it is a good idea to optimize Redis at cost of <span class="token function">more</span> code and <span class="token function">more</span> complexity <span class="token keyword">for</span> a use <span class="token keyword">case</span> that IMHO should be rare <span class="token keyword">for</span> the Redis target <span class="token punctuation">(</span>fsync<span class="token punctuation">(</span><span class="token punctuation">)</span> at every <span class="token builtin class-name">command</span><span class="token punctuation">)</span>. Almost no one is using this feature even with ACID SQL databases, as the performance hint is big anyway.
About threads: our experience shows that Redis is mostly I/O bound. I'm using threads to serve things from Virtual Memory. The long term solution to exploit all the cores, assuming your <span class="token function">link</span> is so fast that you can saturate a single core, is running multiple instances of Redis <span class="token punctuation">(</span>no locks, almost fully scalable linearly with number of cores<span class="token punctuation">)</span>, and using the <span class="token string">"Redis Cluster"</span> solution that I plan to develop <span class="token keyword">in</span> the future.
</code></pre> 
<p>简而言之就是实现简单且达到了类似效果。</p> 
<ul><li>skiplist与平衡树、哈希表的比较</li></ul> 
<p>来源于：https://www.jianshu.com/p/8ac45fd01548<br> skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。<br> 在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。<br> 平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。<br> 从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。<br> 查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。<br> 从算法实现难度上来比较，skiplist比平衡树要简单得多。</p> 
<h3><a id="7_552"></a>7.参考文章</h3> 
<ul><li>Redis 6.0源码</li><li>https://www.cnblogs.com/neooelric/p/9621736.html</li></ul> 
<p>还参考了<br> https://www.cnblogs.com/hunternet/p/11248192.html<br> https://www.jianshu.com/p/8ac45fd01548</p> 
<hr> 
<h2><a id="_562"></a>总结</h2> 
<p>本文记录了redis的底层数据结构及详解，核心内容运用了大篇幅的引用，因为原文图文并茂，内容真的很详细，是学习redis底层数据结构的不二之选！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9a50766678165f5cfcf8732db1c8aa14/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">@Autowired和@Resource到底有什么区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e53640f7671bf984c2bb6320c717c041/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">LCD1602原理驱动代码及例程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>