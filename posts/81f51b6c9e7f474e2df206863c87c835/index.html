<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 正则表达式的使用指南 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java 正则表达式的使用指南" />
<meta property="og:description" content="本文属于技术文章，国外网站Copy过来参考使用，不再具体翻译了，相信程序都能有这些英语阅读能力。 1. 概述 In this article, we will discuss the Java Regex API and how regular expressions can be used in Java programming language.
In the world of regular expressions, there are many different flavors to choose from, such as grep, Perl, Python, PHP, awk and much more.
This means that a regular expression that works in one programming language may not work in another. The regular expression syntax in the Java is most similar to that found in Perl." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/81f51b6c9e7f474e2df206863c87c835/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-06-06T16:35:19+08:00" />
<meta property="article:modified_time" content="2019-06-06T16:35:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 正则表达式的使用指南</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>本文属于技术文章，国外网站Copy过来参考使用，不再具体翻译了，相信程序都能有这些英语阅读能力。</h3> 
<h3 id="Overview"><strong>1. 概述</strong></h3> 
<p>In this article, we will discuss the Java Regex API and how regular expressions can be used in Java programming language.</p> 
<p>In the world of regular expressions, there are many different flavors to choose from, such as grep, Perl, Python, PHP, awk and much more.</p> 
<p>This means that a regular expression that works in one programming language may not work in another. The regular expression syntax in the Java is most similar to that found in Perl.</p> 
<h3 id="Setup"><strong>2. 配置</strong></h3> 
<p>To use regular expressions in Java, we do not need any special setup. The JDK contains a special package<em>java.util.regex</em> totally dedicated to regex operations. We only need to import it into our code.</p> 
<p>Moreover, the <em>java.lang.String</em> class also has inbuilt regex support that we commonly use in our code.</p> 
<h3 id="Package"><strong>3. Java Regex Package</strong></h3> 
<p>The <em>java.util.regex</em> package consists of three classes: <em>Pattern, Matcher </em>and<em> PatternSyntaxException:</em></p> 
<ul><li><em>Pattern</em> object is a compiled regex. The <em>Pattern </em>class provides no public constructors. To create a pattern, we must first invoke one of its public static <em>compile </em>methods, which will then return a <em>Pattern </em>object. These methods accept a regular expression as the first argument.</li><li><em>Matcher</em> object interprets the pattern and performs match operations against an input <em>String</em>. It also defines no public constructors. We obtain a <em>Matcher </em>object by invoking the <em>matcher </em>method on a <em>Pattern </em>object.</li><li><em>PatternSyntaxException</em> object is an unchecked exception that indicates a syntax error in a regular expression pattern.</li></ul> 
<p>We will explore these classes in detail; however, we must first understand how a regex is constructed in Java.</p> 
<p>If you are already familiar with regex from a different environment, you may find certain differences, but they are minimal.</p> 
<h3 id="Simple"><strong>4. 例子程序</strong></h3> 
<p><strong>Let’s start with the simplest use case for a regex.</strong> As we noted earlier, when a regex is applied to a String, it may match zero or more times.</p> 
<p>The most basic form of pattern matching supported by the <em>java.util.regex</em> API is the <strong>match of a <em>String</em> literal</strong>. For example, if the regular expression is <em>foo </em>and the input <em>String</em> is <em>foo</em>, the match will succeed because the <em>Strings</em> are identical:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenText_whenSimpleRegexMatches_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>Pattern pattern = Pattern.compile(</code><code>"foo"</code><code>);</code></p> <p><code>    </code><code>Matcher matcher = pattern.matcher(</code><code>"foo"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertTrue(matcher.find());</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>We first create a <em>Pattern</em> object by calling its static <em>compile</em> method and passing it a pattern we want to use.</p> 
<p>Then we create a <em>Matcher</em> object be calling the <em>Pattern</em> object’s <em>matcher</em> method and passing it the text we want to check for matches.</p> 
<p>After that, we call the method <em>find</em> in the Matcher object.</p> 
<p>The <em>find</em> method keeps advancing through the input text and returns true for every match, so we can use it to find the match count as well:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenText_whenSimpleRegexMatchesTwice_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>Pattern pattern = Pattern.compile(</code><code>"foo"</code><code>);</code></p> <p><code>    </code><code>Matcher matcher = pattern.matcher(</code><code>"foofoo"</code><code>);</code></p> <p><code>    </code><code>int</code> <code>matches = </code><code>0</code><code>;</code></p> <p><code>    </code><code>while</code> <code>(matcher.find()) {<!-- --></code></p> <p><code>        </code><code>matches++;</code></p> <p><code>    </code><code>}</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>2</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>Since we will be running more tests, we can abstract the logic for finding number of matches in a method called <em>runTest</em>:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> </td><td> <p><code>public</code> <code>static</code> <code>int</code> <code>runTest(</code><code>String</code> <code>regex, </code><code>String</code> <code>text) {<!-- --></code></p> <p><code>    </code><code>Pattern pattern = Pattern.compile(regex);</code></p> <p><code>    </code><code>Matcher matcher = pattern.matcher(text);</code></p> <p><code>    </code><code>int</code> <code>matches = </code><code>0</code><code>;</code></p> <p><code>    </code><code>while</code> <code>(matcher.find()) {<!-- --></code></p> <p><code>        </code><code>matches++;</code></p> <p><code>    </code><code>}</code></p> <p><code>    </code><code>return</code> <code>matches;</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>When we get 0 matches, the test should fail, otherwise, it should pass.</p> 
<h3 id="Characters"><strong>5. Meta Characters</strong></h3> 
<p>Meta characters affect the way a pattern is matched, in a way adding logic to the search pattern. The Java API supports several metacharacters, the most straightforward being the dot <em>“.” </em>which matches any character:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenText_whenMatchesWithDotMetach_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"."</code><code>, </code><code>"foo"</code><code>);</code></p> <p><code>    </code> </p> <p><code>    </code><code>assertTrue(matches &gt; </code><code>0</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>Considering the previous example where regex <em>foo</em> matched the text <em>foo</em> as well as <em>foofoo</em> two times. If we used the dot metacharacter in the regex, we would not get two matches in the second case:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenRepeatedText_whenMatchesOnceWithDotMetach_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches= runTest(</code><code>"foo."</code><code>, </code><code>"foofoo"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>1</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>Notice the dot after the <em>foo</em> in the regex. The matcher matches every text that is preceded by <em>foo</em> since the last dot part means any character after. So after finding the first <em>foo</em>, the rest is seen as any character. That is why there is only a single match.</p> 
<p>The API supports several other meta characters <em>&lt;([{\^-=$!|]})?*+.&gt;</em> which we will be looking into further in this article.</p> 
<h3 id="Classes"><strong>6. Character Classes</strong></h3> 
<p>Browsing through the official <em><a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html" rel="nofollow">Pattern</a> </em>class specification, we will discover summaries of supported regex constructs. Under character classes, we have about 6 constructs.</p> 
<h4><strong>6.1. OR Class</strong></h4> 
<p>Constructed as <em>[abc]</em>. Any of the elements in the set is matched:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenORSet_whenMatchesAny_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"[abc]"</code><code>, </code><code>"b"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>1</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>If they all appear in the text, each is matched separately with no regard to order:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenORSet_whenMatchesAnyAndAll_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"[abc]"</code><code>, </code><code>"cab"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>3</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>They can also be alternated as part of a <em>String</em>. In the following example, when we create different words by alternating the first letter with each element of the set, they are all matched:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenORSet_whenMatchesAllCombinations_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"[bcr]at"</code><code>, </code><code>"bat cat rat"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>3</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<h4><strong>6.2. NOR Class</strong></h4> 
<p>The above set is negated by adding a caret as the first element:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenNORSet_whenMatchesNon_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"[^abc]"</code><code>, </code><code>"g"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertTrue(matches &gt; </code><code>0</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>Another case:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenNORSet_whenMatchesAllExceptElements_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"[^bcr]at"</code><code>, </code><code>"sat mat eat"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertTrue(matches &gt; </code><code>0</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<h4><strong>6.3. Range Class</strong></h4> 
<p>We can define a class that specifies a range within which the matched text should fall using a hyphen(-), likewise, we can also negate a range.</p> 
<p>Matching uppercase letters:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenUpperCaseRange_whenMatchesUpperCase_</code></p> <p><code>  </code><code>thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code></p> <p><code>      </code><code>"[A-Z]"</code><code>, </code><code>"Two Uppercase alphabets 34 overall"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>2</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>Matching lowercase letters:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenLowerCaseRange_whenMatchesLowerCase_</code></p> <p><code>  </code><code>thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code></p> <p><code>      </code><code>"[a-z]"</code><code>, </code><code>"Two Uppercase alphabets 34 overall"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>26</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>Matching both upper case and lower case letters:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenBothLowerAndUpperCaseRange_</code></p> <p><code>  </code><code>whenMatchesAllLetters_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code></p> <p><code>      </code><code>"[a-zA-Z]"</code><code>, </code><code>"Two Uppercase alphabets 34 overall"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>28</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>Matching a given range of numbers:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenNumberRange_whenMatchesAccurately_</code></p> <p><code>  </code><code>thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code></p> <p><code>      </code><code>"[1-5]"</code><code>, </code><code>"Two Uppercase alphabets 34 overall"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>2</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>Matching another range of numbers:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenNumberRange_whenMatchesAccurately_</code></p> <p><code>  </code><code>thenCorrect2(){<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code></p> <p><code>      </code><code>"[30-35]"</code><code>, </code><code>"Two Uppercase alphabets 34 overall"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>1</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p><strong>6.4. Union Class</strong></p> 
<p>A union character class is a result of combining two or more character classes:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenTwoSets_whenMatchesUnion_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"[1-3[7-9]]"</code><code>, </code><code>"123456789"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>6</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>The above test will only match 6 out of the 9 integers because the union set skips 3, 4 and 5.</p> 
<h4><strong>6.5. Intersection Class</strong></h4> 
<p>Similar to the union class, this class results from picking common elements between two or more sets. To apply intersection, we use the <em>&amp;&amp;</em>:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenTwoSets_whenMatchesIntersection_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"[1-6&amp;&amp;[3-9]]"</code><code>, </code><code>"123456789"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>4</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>We get 4 matches because the intersection of the two sets has only 4 elements.</p> 
<h4><strong>6.6. Subtraction Class</strong></h4> 
<p>We can use subtraction to negate one or more character classes, for example matching a set of odd decimal numbers:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenSetWithSubtraction_whenMatchesAccurately_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"[0-9&amp;&amp;[^2468]]"</code><code>, </code><code>"123456789"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>5</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>Only <em>1,3,5,7,9</em> will be matched.</p> 
<h3 id="Predefined"><strong>7. Predefined Character Classes</strong></h3> 
<p>The Java regex API also accepts predefined character classes. Some of the above character classes can be expressed in shorter form though making the code less intuitive. One special aspect of the Java version of this regex is the escape character.</p> 
<p>As we will see, most characters will start with a backslash, which has a special meaning in Java. For these to be compiled by the <em>Pattern</em> class – the leading backslash must be escaped i.e. <em>\d</em> becomes <em>\\d</em>.</p> 
<p>Matching digits, equivalent to <em>[0-9]</em>:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenDigits_whenMatches_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"\\d"</code><code>, </code><code>"123"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>3</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>Matching non-digits, equivalent to <em>[^0-9]</em>:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenNonDigits_whenMatches_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>mathces = runTest(</code><code>"\\D"</code><code>, </code><code>"a6c"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>2</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>Matching white space:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenWhiteSpace_whenMatches_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"\\s"</code><code>, </code><code>"a c"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>1</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>Matching non-white space:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenNonWhiteSpace_whenMatches_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"\\S"</code><code>, </code><code>"a c"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>2</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>Matching a word character, equivalent to <em>[a-zA-Z_0-9]</em>:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenWordCharacter_whenMatches_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"\\w"</code><code>, </code><code>"hi!"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>2</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>Matching a non-word character:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenNonWordCharacter_whenMatches_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"\\W"</code><code>, </code><code>"hi!"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>1</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<h3 id="Quantifiers"><strong>8. Quantifiers</strong></h3> 
<p>The Java regex API also allows us to use quantifiers. These enable us to further tweak the match’s behavior by specifying the number of occurrences to match against.</p> 
<p>To match a text zero or one time, we use the<em> ?</em> quantifier:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenZeroOrOneQuantifier_whenMatches_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"\\a?"</code><code>, </code><code>"hi"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>3</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>Alternatively, we can use the brace syntax, also supported by the Java regex API:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenZeroOrOneQuantifier_whenMatches_thenCorrect2() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"\\a{0,1}"</code><code>, </code><code>"hi"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>3</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>This example introduces the concept of zero-length matches. It so happens that if a quantifier’s threshold for matching is zero, it always matches everything in the text including an empty <em>String</em> at the end of every input. This means that even if the input is empty, it will return one zero-length match.</p> 
<p>This explains why we get 3 matches in the above example despite having a S<em>tring</em> of length two. The third match is zero-length empty <em>String</em>.</p> 
<p>To match a text zero or limitless times, we us * quantifier, it is just similar to ?:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenZeroOrManyQuantifier_whenMatches_thenCorrect() {<!-- --></code></p> <p><code>     </code><code>int</code> <code>matches = runTest(</code><code>"\\a*"</code><code>, </code><code>"hi"</code><code>);</code></p> <p><code> </code> </p> <p><code>     </code><code>assertEquals(matches, </code><code>3</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>Supported alternative:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenZeroOrManyQuantifier_whenMatches_thenCorrect2() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"\\a{0,}"</code><code>, </code><code>"hi"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>3</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>The quantifier with a difference is +, it has a matching threshold of 1. If the required <em>String</em> does not occur at all, there will be no match, not even a zero-length <em>String</em>:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenOneOrManyQuantifier_whenMatches_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"\\a+"</code><code>, </code><code>"hi"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertFalse(matches);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>Supported alternative:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenOneOrManyQuantifier_whenMatches_thenCorrect2() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"\\a{1,}"</code><code>, </code><code>"hi"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertFalse(matches);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>As it is in Perl and other languages, the brace syntax can be used to match a given text a number of times:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenBraceQuantifier_whenMatches_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"a{3}"</code><code>, </code><code>"aaaaaa"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>2</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>In the above example, we get two matches since a match occurs only if <em>a</em> appears three times in a row. However, in the next test we won’t get a match since the text only appears two times in a row:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenBraceQuantifier_whenFailsToMatch_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"a{3}"</code><code>, </code><code>"aa"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertFalse(matches &gt; </code><code>0</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>When we use a range in the brace, the match will be greedy, matching from the higher end of the range:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenBraceQuantifierWithRange_whenMatches_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"a{2,3}"</code><code>, </code><code>"aaaa"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>1</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>We’ve specified at least two occurrences but not exceeding three, so we get a single match instead where the matcher sees a single <em>aaa</em> and <em>a</em> lone a which can’t be matched.</p> 
<p>However, the API allows us to specify a lazy or reluctant approach such that the matcher can start from the lower end of the range in which case matching two occurrences as <em>aa</em> and <em>aa</em>:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenBraceQuantifierWithRange_whenMatchesLazily_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"a{2,3}?"</code><code>, </code><code>"aaaa"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>2</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<h3 id="Capturing"><strong>9. Capturing Groups</strong></h3> 
<p>The API also allows us to <strong>treat multiple characters as a single unit through capturing groups</strong>.</p> 
<p>It will attache numbers to the capturing groups and allow back referencing using these numbers.</p> 
<p>In this section, we will see a few examples on how to use capturing groups in Java regex API.</p> 
<p>Let’s use a capturing group that matches only when an input text contains two digits next to each other:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenCapturingGroup_whenMatches_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>maches = runTest(</code><code>"(\\d\\d)"</code><code>, </code><code>"12"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>1</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>The number attached to the above match is <em>1</em>, using a back reference to tell the matcher that we want to match another occurrence of the matched portion of the text. This way, instead of:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenCapturingGroup_whenMatches_thenCorrect2() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"(\\d\\d)"</code><code>, </code><code>"1212"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>2</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>Where there are two separate matches for the input, we can have one match but propagating the same regex match to span the entire length of the input using back referencing:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenCapturingGroup_whenMatchesWithBackReference_</code></p> <p><code>  </code><code>thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"(\\d\\d)\\1"</code><code>, </code><code>"1212"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>1</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>Where we would have to repeat the regex without back referencing to achieve the same result:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenCapturingGroup_whenMatches_thenCorrect3() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"(\\d\\d)(\\d\\d)"</code><code>, </code><code>"1212"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>1</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>Similarly, for any other number of repetitions, back referencing can make the matcher see the input as a single match:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenCapturingGroup_whenMatchesWithBackReference_</code></p> <p><code>  </code><code>thenCorrect2() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"(\\d\\d)\\1\\1\\1"</code><code>, </code><code>"12121212"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(matches, </code><code>1</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>But if you change even the last digit, the match will fail:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenCapturingGroupAndWrongInput_</code></p> <p><code>  </code><code>whenMatchFailsWithBackReference_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"(\\d\\d)\\1"</code><code>, </code><code>"1213"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertFalse(matches &gt; </code><code>0</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>It is important not to forget the escape backslashes, this is crucial in Java syntax.</p> 
<h3 id="Boundary"><strong>10. Boundary Matchers</strong></h3> 
<p>The Java regex API also supports boundary matching. If we care about where exactly in the input text the match should occur, then this is what we are looking for. With the previous examples, all we cared about was whether a match was found or not.</p> 
<p>To match only when the required regex is true at the beginning of the text, we use the caret <em>^.</em></p> 
<p>This test will fail since the text <em>dog</em> can be found at the beginning:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenText_whenMatchesAtBeginning_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"^dog"</code><code>, </code><code>"dogs are friendly"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertTrue(matches &gt; </code><code>0</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>The following test will fail:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenTextAndWrongInput_whenMatchFailsAtBeginning_</code></p> <p><code>  </code><code>thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"^dog"</code><code>, </code><code>"are dogs are friendly?"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertFalse(matches &gt; </code><code>0</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>To match only when the required regex is true at the end of the text, we use the dollar character <em>$. </em>A match will be found in the following case:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenText_whenMatchesAtEnd_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"dog$"</code><code>, </code><code>"Man's best friend is a dog"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertTrue(matches &gt; </code><code>0</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>And no match will be found here:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenTextAndWrongInput_whenMatchFailsAtEnd_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"dog$"</code><code>, </code><code>"is a dog man's best friend?"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertFalse(matches &gt; </code><code>0</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>If we want a match only when the required text is found at a word boundary, we use <em>\\b</em> regex at the beginning and end of the regex:</p> 
<p>Space is a word boundary:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenText_whenMatchesAtWordBoundary_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"\\bdog\\b"</code><code>, </code><code>"a dog is friendly"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertTrue(matches &gt; </code><code>0</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>The empty string at the beginning of a line is also a word boundary:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenText_whenMatchesAtWordBoundary_thenCorrect2() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"\\bdog\\b"</code><code>, </code><code>"dog is man's best friend"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertTrue(matches &gt; </code><code>0</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>These tests pass because the beginning of a <em>String</em>, as well as space between one text and another, marks a word boundary, however, the following test shows the opposite:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenWrongText_whenMatchFailsAtWordBoundary_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"\\bdog\\b"</code><code>, </code><code>"snoop dogg is a rapper"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertFalse(matches &gt; </code><code>0</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>Two-word characters appearing in a row does not mark a word boundary, but we can make it pass by changing the end of the regex to look for a non-word boundary:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenText_whenMatchesAtWordAndNonBoundary_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"\\bdog\\B"</code><code>, </code><code>"snoop dogg is a rapper"</code><code>);</code></p> <p><code>    </code><code>assertTrue(matches &gt; </code><code>0</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<h3 id="Pattern"><strong>11. Pattern Class Methods</strong></h3> 
<p>Previously, we have only created <em>Pattern</em> objects in a basic way. However, this class has another variant of the <em>compile</em> method that accepts a set of flags alongside the regex argument affecting the way the pattern is matched.</p> 
<p>These flags are simply abstracted integer values. Let’s overload the <em>runTest</em> method in the test class so that it can take a flag as the third argument:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> </td><td> <p><code>public</code> <code>static</code> <code>int</code> <code>runTest(String regex, String text, </code><code>int</code> <code>flags) {<!-- --></code></p> <p><code>    </code><code>pattern = Pattern.compile(regex, flags);</code></p> <p><code>    </code><code>matcher = pattern.matcher(text);</code></p> <p><code>    </code><code>int</code> <code>matches = </code><code>0</code><code>;</code></p> <p><code>    </code><code>while</code> <code>(matcher.find()){<!-- --></code></p> <p><code>        </code><code>matches++;</code></p> <p><code>    </code><code>}</code></p> <p><code>    </code><code>return</code> <code>matches;</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>In this section, we will look at the different supported flags and how they are used.</p> 
<p><strong><em>Pattern.CANON_EQ</em></strong></p> 
<p>This flag enables canonical equivalence. When specified, two characters will be considered to match if, and only if, their full canonical decompositions match.</p> 
<p>Consider the accented Unicode character <em>é</em>. Its composite code point is <em>u00E9</em>. However, Unicode also has a separate code point for its component characters <em>e</em>, <em>u0065</em> and the acute accent, <em>u0301</em>. In this case, composite character <em>u00E9</em> is indistinguishable from the two character sequence <em>u0065 u</em><em>0301</em>.</p> 
<p>By default, matching does not take canonical equivalence into account:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenRegexWithoutCanonEq_whenMatchFailsOnEquivalentUnicode_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"\u00E9"</code><code>, </code><code>"\u0065\u0301"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertFalse(matches &gt; </code><code>0</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>But if we add the flag, then the test will pass:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenRegexWithCanonEq_whenMatchesOnEquivalentUnicode_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"\u00E9"</code><code>, </code><code>"\u0065\u0301"</code><code>, Pattern.CANON_EQ);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertTrue(matches &gt; </code><code>0</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p><em><strong>Pattern.CASE_INSENSITIVE</strong></em></p> 
<p>This flag enables matching regardless of case. By default matching takes case into account:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenRegexWithDefaultMatcher_whenMatchFailsOnDifferentCases_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"dog"</code><code>, </code><code>"This is a Dog"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertFalse(matches &gt; </code><code>0</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>So using this flag, we can change the default behavior:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenRegexWithCaseInsensitiveMatcher</code></p> <p><code>  </code><code>_whenMatchesOnDifferentCases_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code></p> <p><code>      </code><code>"dog"</code><code>, </code><code>"This is a Dog"</code><code>, Pattern.CASE_INSENSITIVE);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertTrue(matches &gt; </code><code>0</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>We can also use the equivalent, embedded flag expression to achieve the same result:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenRegexWithEmbeddedCaseInsensitiveMatcher</code></p> <p><code>  </code><code>_whenMatchesOnDifferentCases_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"(?i)dog"</code><code>, </code><code>"This is a Dog"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertTrue(matches &gt; </code><code>0</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p><em><strong>Pattern.COMMENTS</strong></em></p> 
<p>The Java API allows one to include comments using # in the regex. This can help in documenting complex regex that may not be immediately obvious to another programmer.</p> 
<p>The comments flag makes the matcher ignore any white space or comments in the regex and only consider the pattern. In the default matching mode the following test would fail:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenRegexWithComments_whenMatchFailsWithoutFlag_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code></p> <p><code>      </code><code>"dog$  #check for word dog at end of text"</code><code>, </code><code>"This is a dog"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertFalse(matches &gt; </code><code>0</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>This is because the matcher will look for the entire regex in the input text, including the spaces and the # character. But when we use the flag, it will ignore the extra spaces and the every text starting with # will be seen as a comment to be ignored for each line:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenRegexWithComments_whenMatchesWithFlag_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code></p> <p><code>      </code><code>"dog$  #check end of text"</code><code>,</code><code>"This is a dog"</code><code>, Pattern.COMMENTS);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertTrue(matches &gt; </code><code>0</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>There is also an alternative embedded flag expression for this:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenRegexWithComments_whenMatchesWithEmbeddedFlag_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code></p> <p><code>      </code><code>"(?x)dog$  #check end of text"</code><code>, </code><code>"This is a dog"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertTrue(matches &gt; </code><code>0</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p><em><strong>Pattern.DOTALL</strong></em></p> 
<p>By default, when we use the dot “.” expression in regex, we are matching every character in the input <em>String</em> until we encounter a new line character.</p> 
<p>Using this flag, the match will include the line terminator as well. We will understand better with the following examples. These examples will be a little different. Since we are interested in asserting against the matched <em>String</em>, we will use <em>matcher</em>‘s <em>group</em> method which returns the previous match.</p> 
<p>First, we will see the default behavior:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenRegexWithLineTerminator_whenMatchFails_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>Pattern pattern = Pattern.compile(</code><code>"(.*)"</code><code>);</code></p> <p><code>    </code><code>Matcher matcher = pattern.matcher(</code></p> <p><code>      </code><code>"this is a text"</code> <code>+ System.getProperty(</code><code>"line.separator"</code><code>) </code></p> <p><code>        </code><code>+ </code><code>" continued on another line"</code><code>);</code></p> <p><code>    </code><code>matcher.find();</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(</code><code>"this is a text"</code><code>, matcher.group(</code><code>1</code><code>));</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>As we can see, only the first part of the input before the line terminator is matched.</p> 
<p>Now in <em>dotall</em> mode, the entire text including the line terminator will be matched:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenRegexWithLineTerminator_whenMatchesWithDotall_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>Pattern pattern = Pattern.compile(</code><code>"(.*)"</code><code>, Pattern.DOTALL);</code></p> <p><code>    </code><code>Matcher matcher = pattern.matcher(</code></p> <p><code>      </code><code>"this is a text"</code> <code>+ System.getProperty(</code><code>"line.separator"</code><code>) </code></p> <p><code>        </code><code>+ </code><code>" continued on another line"</code><code>);</code></p> <p><code>    </code><code>matcher.find();</code></p> <p><code>    </code><code>assertEquals(</code></p> <p><code>      </code><code>"this is a text"</code> <code>+ System.getProperty(</code><code>"line.separator"</code><code>) </code></p> <p><code>        </code><code>+ </code><code>" continued on another line"</code><code>, matcher.group(</code><code>1</code><code>));</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>We can also use an embedded flag expression to enable <em>dotall</em> mode:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> <p>11</p> <p>12</p> <p>13</p> <p>14</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenRegexWithLineTerminator_whenMatchesWithEmbeddedDotall</code></p> <p><code>  </code><code>_thenCorrect() {<!-- --></code></p> <p><code>    </code> </p> <p><code>    </code><code>Pattern pattern = Pattern.compile(</code><code>"(?s)(.*)"</code><code>);</code></p> <p><code>    </code><code>Matcher matcher = pattern.matcher(</code></p> <p><code>      </code><code>"this is a text"</code> <code>+ System.getProperty(</code><code>"line.separator"</code><code>) </code></p> <p><code>        </code><code>+ </code><code>" continued on another line"</code><code>);</code></p> <p><code>    </code><code>matcher.find();</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(</code></p> <p><code>      </code><code>"this is a text"</code> <code>+ System.getProperty(</code><code>"line.separator"</code><code>) </code></p> <p><code>        </code><code>+ </code><code>" continued on another line"</code><code>, matcher.group(</code><code>1</code><code>));</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p><em><strong>Pattern.LITERAL</strong></em></p> 
<p>When in this mode, matcher gives no special meaning to any metacharacters, escape characters or regex syntax. Without this flag, the matcher will match the following regex against any input <em>String</em>:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenRegex_whenMatchesWithoutLiteralFlag_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"(.*)"</code><code>, </code><code>"text"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertTrue(matches &gt; </code><code>0</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>This is the default behavior we have been seeing in all the examples. However, with this flag, no match will be found, since the matcher will be looking for <em>(.*)</em> instead of interpreting it:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenRegex_whenMatchFailsWithLiteralFlag_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"(.*)"</code><code>, </code><code>"text"</code><code>, Pattern.LITERAL);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertFalse(matches &gt; </code><code>0</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>Now if we add the required string, the test will pass:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenRegex_whenMatchesWithLiteralFlag_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code><code>"(.*)"</code><code>, </code><code>"text(.*)"</code><code>, Pattern.LITERAL);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertTrue(matches &gt; </code><code>0</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>There is no embedded flag character for enabling literal parsing.</p> 
<p><em><strong>Pattern.MULTILINE</strong></em></p> 
<p>By default <em>^</em> and <em>$</em> metacharacters match absolutely at the beginning and at the end respectively of the entire input <em>String</em>. The matcher disregards any line terminators:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenRegex_whenMatchFailsWithoutMultilineFlag_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code></p> <p><code>      </code><code>"dog$"</code><code>, </code><code>"This is a dog"</code> <code>+ System.getProperty(</code><code>"line.separator"</code><code>) </code></p> <p><code>      </code><code>+ </code><code>"this is a fox"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertFalse(matches &gt; </code><code>0</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>The match fails because the matcher searches for <em>dog</em> at the end of the entire <em>String</em> but the <em>dog</em> is present at the end of the first line of the string.</p> 
<p>However, with the flag, the same test will pass since the matcher now takes into account line terminators. So the String <em>dog</em> is found just before the line terminates, hence success:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenRegex_whenMatchesWithMultilineFlag_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code></p> <p><code>      </code><code>"dog$"</code><code>, </code><code>"This is a dog"</code> <code>+ System.getProperty(</code><code>"line.separator"</code><code>) </code></p> <p><code>      </code><code>+ </code><code>"this is a fox"</code><code>, Pattern.MULTILINE);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertTrue(matches &gt; </code><code>0</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>Here is the embedded flag version:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenRegex_whenMatchesWithEmbeddedMultilineFlag_</code></p> <p><code>  </code><code>thenCorrect() {<!-- --></code></p> <p><code>    </code><code>int</code> <code>matches = runTest(</code></p> <p><code>      </code><code>"(?m)dog$"</code><code>, </code><code>"This is a dog"</code> <code>+ System.getProperty(</code><code>"line.separator"</code><code>) </code></p> <p><code>      </code><code>+ </code><code>"this is a fox"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertTrue(matches &gt; </code><code>0</code><code>);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<h3 id="Matcher"><strong>12. Matcher Class Methods</strong></h3> 
<p>In this section, we will look at some useful methods of the <em>Matcher</em> class. We will group them according to functionality for clarity.</p> 
<h4><strong>12.1. Index Methods</strong></h4> 
<p>Index methods provide useful index values that show precisely where the match was found in the input <em>String</em> . In the following test, we will confirm the start and end indices of the match for <em>dog</em> in the input <em>String</em> :</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>givenMatch_whenGetsIndices_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>Pattern pattern = Pattern.compile(</code><code>"dog"</code><code>);</code></p> <p><code>    </code><code>Matcher matcher = pattern.matcher(</code><code>"This dog is mine"</code><code>);</code></p> <p><code>    </code><code>matcher.find();</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(</code><code>5</code><code>, matcher.start());</code></p> <p><code>    </code><code>assertEquals(</code><code>8</code><code>, matcher.end());</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<h4><strong>12.2. Study Methods</strong></h4> 
<p>Study methods go through the input <em>String</em> and return a boolean indicating whether or not the pattern is found. Commonly used are <em>matches</em> and <em>lookingAt</em> methods.</p> 
<p>The <em>matches</em> and <em>lookingAt</em> methods both attempt to match an input sequence against a pattern. The difference, is that <em>matches</em> requires the entire input sequence to be matched, while <em>lookingAt</em> does not.</p> 
<p>Both methods start at the beginning of the input <em>String</em> :</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>whenStudyMethodsWork_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>Pattern pattern = Pattern.compile(</code><code>"dog"</code><code>);</code></p> <p><code>    </code><code>Matcher matcher = pattern.matcher(</code><code>"dogs are friendly"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertTrue(matcher.lookingAt());</code></p> <p><code>    </code><code>assertFalse(matcher.matches());</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>The matches method will return true in a case like so:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>whenMatchesStudyMethodWorks_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>Pattern pattern = Pattern.compile(</code><code>"dog"</code><code>);</code></p> <p><code>    </code><code>Matcher matcher = pattern.matcher(</code><code>"dog"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertTrue(matcher.matches());</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<h4><strong>12.3. Replacement Methods</strong></h4> 
<p>Replacement methods are useful to replace text in an input string. The common ones are <em>replaceFirst</em> and <em>replaceAll</em>.</p> 
<p>The <em>replaceFirst</em> and <em>replaceAll</em> methods replace the text that matches a given regular expression. As their names indicate, <em>replaceFirst</em> replaces the first occurrence, and <em>replaceAll</em> replaces all occurrences:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> <p>10</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>whenReplaceFirstWorks_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>Pattern pattern = Pattern.compile(</code><code>"dog"</code><code>);</code></p> <p><code>    </code><code>Matcher matcher = pattern.matcher(</code></p> <p><code>      </code><code>"dogs are domestic animals, dogs are friendly"</code><code>);</code></p> <p><code>    </code><code>String newStr = matcher.replaceFirst(</code><code>"cat"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(</code></p> <p><code>      </code><code>"cats are domestic animals, dogs are friendly"</code><code>, newStr);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<p>Replace all occurrences:</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>1</p> <p>2</p> <p>3</p> <p>4</p> <p>5</p> <p>6</p> <p>7</p> <p>8</p> <p>9</p> </td><td> <p><code>@Test</code></p> <p><code>public</code> <code>void</code> <code>whenReplaceAllWorks_thenCorrect() {<!-- --></code></p> <p><code>    </code><code>Pattern pattern = Pattern.compile(</code><code>"dog"</code><code>);</code></p> <p><code>    </code><code>Matcher matcher = pattern.matcher(</code></p> <p><code>      </code><code>"dogs are domestic animals, dogs are friendly"</code><code>);</code></p> <p><code>    </code><code>String newStr = matcher.replaceAll(</code><code>"cat"</code><code>);</code></p> <p><code> </code> </p> <p><code>    </code><code>assertEquals(</code><code>"cats are domestic animals, cats are friendly"</code><code>, newStr);</code></p> <p><code>}</code></p> </td></tr></tbody></table> 
<h3 id="Conclusion"><strong>13. Conclusion</strong></h3> 
<p>In this article, we have learned how to use regular expressions in Java and also explored the most important features of the <em>java.util.regex</em> package.</p> 
<p>The full source code for the project including all the code samples used here can be found by the<a href="https://download.csdn.net/download/lzy_168/11229378"> link</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eb7e5f1e09816a8cca11b8089d675fde/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">luogu 黑题 P3724大佬</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ff3a0462518a8343114981230c305b61/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java反编译工具Java Decompiler</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>