<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[LGOJ5558]心上秋（倍增） - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[LGOJ5558]心上秋（倍增）" />
<meta property="og:description" content="题意 给一颗边带权的树，边权为1~5，多次询问树上某条路径组成的边权序列的LIS
思路 假设已知边权序列，设\(f_{i,j}\)表示处理了前\(i\)个数，当前\(LIS\)中的最后一个数为\(j\)时的\(LIS\)长度，显然有\(f_{i,j}=max(f_{i-1,k}&#43;1),(k\leq j)\)，由于边权为1~5，这个算法一次是\(O(n)\)的
通过上述对\(f\)的处理的思路就可以得到倍增法
设\(fa_{rt,i}\)表示从\(rt\)向上跳\(2^i\)步到的节点
设\(g_{rt,i,j,k}\)，表示从\(rt\)向上跳\(2^i\)步得到的边权序列，当前\(LIS\)中的最小数为\(j\)，最大数为\(k\)时的\(LIS\)长度
有转移方程
\(g_{rt,i,j,k}=max(g_{rt,i-1,j,p}&#43;g_{fa_{rt,i-1},i-1,p,k})\) 利用这个数组优化上面求\(f\)的过程即可
注意：虽然从\(y\)向\(lca\)走求的是最长不上升子序列（与\(LIS\)相反），但是可以发现\(g\)数组在\(j\geq k\)就可以表示最长不上升子序列（虽然这样与定义不符，但确实可以用）
Code #include&lt;bits/stdc&#43;&#43;.h&gt; #define N 30005 #define Max(x,y) ((x)&gt;(y)?(x):(y)) #define Min(x,y) ((x)&lt;(y)?(x):(y)) using namespace std; const int temp = 16; int n,m,dep[N]; int dp[2][temp][6],g[N][temp][6][6],f[N][temp]; int l[N],r[N],cl,cr;//倍增时向上经过的断点 bool rev; struct Edge { int next,to,dis; }edge[N&lt;&lt;1];int head[N],cnt=1; void add_edge(int from,int to,int dis) { edge[&#43;&#43;cnt].next=head[from]; edge[cnt].to=to; edge[cnt].dis=dis; head[from]=cnt; } template &lt;class T&gt; void read(T &amp;x) { char c;int sign=1; while((c=getchar())&gt;&#39;9&#39;||c&lt;&#39;0&#39;) if(c==&#39;-&#39;) sign=-1; x=c-48; while((c=getchar())&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;) x=x*10&#43;c-48; x*=sign; } void dfs(int rt,int fa) { dep[rt]=dep[fa]&#43;1; for(int i=head[rt];i;i=edge[i]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/b6f0cb5a1295f805ea7c3a5e15d540ac/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-09-28T16:40:00+08:00" />
<meta property="article:modified_time" content="2019-09-28T16:40:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[LGOJ5558]心上秋（倍增）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown"> 
 <h3 id="题意"><a href="https://www.luogu.org/problem/P5558" rel="nofollow">题意</a></h3> 
 <p>给一颗边带权的树，边权为1~5，多次询问树上某条路径组成的边权序列的LIS</p> 
 <h3 id="思路">思路</h3> 
 <p>假设已知边权序列，设<span class="math inline">\(f_{i,j}\)</span>表示处理了前<span class="math inline">\(i\)</span>个数，当前<span class="math inline">\(LIS\)</span>中的最后一个数为<span class="math inline">\(j\)</span>时的<span class="math inline">\(LIS\)</span>长度，显然有<span class="math inline">\(f_{i,j}=max(f_{i-1,k}+1),(k\leq j)\)</span>，由于边权为1~5，这个算法一次是<span class="math inline">\(O(n)\)</span>的</p> 
 <p>通过上述对<span class="math inline">\(f\)</span>的处理的思路就可以得到倍增法</p> 
 <p>设<span class="math inline">\(fa_{rt,i}\)</span>表示从<span class="math inline">\(rt\)</span>向上跳<span class="math inline">\(2^i\)</span>步到的节点<br> 设<span class="math inline">\(g_{rt,i,j,k}\)</span>，表示从<span class="math inline">\(rt\)</span>向上跳<span class="math inline">\(2^i\)</span>步得到的边权序列，当前<span class="math inline">\(LIS\)</span>中的最小数为<span class="math inline">\(j\)</span>，最大数为<span class="math inline">\(k\)</span>时的<span class="math inline">\(LIS\)</span>长度</p> 
 <p>有转移方程</p> 
 <h4 id="g_rtijkmaxg_rti-1jpg_fa_rti-1i-1pk"><span class="math inline">\(g_{rt,i,j,k}=max(g_{rt,i-1,j,p}+g_{fa_{rt,i-1},i-1,p,k})\)</span></h4> 
 <p>利用这个数组优化上面求<span class="math inline">\(f\)</span>的过程即可</p> 
 <p>注意：虽然从<span class="math inline">\(y\)</span>向<span class="math inline">\(lca\)</span>走求的是最长不上升子序列（与<span class="math inline">\(LIS\)</span>相反），但是可以发现<span class="math inline">\(g\)</span>数组在<span class="math inline">\(j\geq k\)</span>就可以表示最长不上升子序列（<del>虽然这样与定义不符，但确实可以用</del>）</p> 
 <h3 id="code">Code</h3> 
 <pre><code class="language-cpp"><code>#include&lt;bits/stdc++.h&gt;
#define N 30005
#define Max(x,y) ((x)&gt;(y)?(x):(y))
#define Min(x,y) ((x)&lt;(y)?(x):(y)) 
using namespace std;
const int temp = 16;
int n,m,dep[N];
int dp[2][temp][6],g[N][temp][6][6],f[N][temp];
int l[N],r[N],cl,cr;//倍增时向上经过的断点 
bool rev;

struct Edge
{
    int next,to,dis;
}edge[N&lt;&lt;1];int head[N],cnt=1;
void add_edge(int from,int to,int dis)
{
    edge[++cnt].next=head[from];
    edge[cnt].to=to;
    edge[cnt].dis=dis;
    head[from]=cnt;
}
template &lt;class T&gt;
void read(T &amp;x)
{
    char c;int sign=1;
    while((c=getchar())&gt;'9'||c&lt;'0') if(c=='-') sign=-1; x=c-48;
    while((c=getchar())&gt;='0'&amp;&amp;c&lt;='9') x=x*10+c-48; x*=sign;
}
void dfs(int rt,int fa)
{
    dep[rt]=dep[fa]+1;
    for(int i=head[rt];i;i=edge[i].next)
    {
        int v=edge[i].to;
        if(v==fa) continue;
        f[v][0]=rt;
        for(int j=1;j&lt;=5;++j)
        for(int k=1;k&lt;=5;++k) 
        if(Min(j,k)&lt;=edge[i].dis&amp;&amp;Max(j,k)&gt;=edge[i].dis) g[v][0][j][k]=1;
        for(int j=1;j&lt;temp;++j)
        {
            f[v][j]=f[f[v][j-1]][j-1];
            if(!f[v][j]) break;
            for(int q=1;q&lt;=5;++q)
                for(int p=1;p&lt;=5;++p)
                    for(int k=Min(p,q);k&lt;=Max(p,q);++k)
                        g[v][j][q][p]=Max(g[v][j][q][p],g[v][j-1][q][k]+g[f[v][j-1]][j-1][k][p]);//attention 
        }
        dfs(v,rt);
    }
}
void init(int x,int y)
{
    rev=cl=cr=0;
    if(dep[x]&lt;dep[y]) {swap(x,y);rev=1;}
    for(int i=temp-1;i&gt;=0;--i) if(dep[f[x][i]]&gt;=dep[y]) x=f[x][i],l[++cl]=i;
    if(x==y) return;
    for(int i=temp-1;i&gt;=0;--i) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i],l[++cl]=i,r[++cr]=i;
    l[++cl]=0; r[++cr]=0;
}
int DP(int x,int y,int cl,int cr,int l[],int r[])
{
    for(int i=1;i&lt;=cl;++i)
    {
        for(int j=1;j&lt;=5;++j)//之前是j 
            for(int k=j;k&lt;=5;++k)//现在是k 
                dp[0][i][k]=Max(dp[0][i][k],dp[0][i-1][j]+g[x][l[i]][j][k]);
        x=f[x][l[i]];
    }
    for(int i=1;i&lt;=cr;++i)//y相反 
    {
        for(int j=5;j&gt;=1;--j)//之前是j
            for(int k=j;k&gt;=1;--k)//现在是k
                dp[1][i][k]=Max(dp[1][i][k],dp[1][i-1][j]+g[y][r[i]][j][k]);
        y=f[y][r[i]];
    }
    int ans=0;
    for(int i=1;i&lt;=5;++i)
        for(int j=i;j&lt;=5;++j)
            ans=Max(ans,dp[0][cl][i]+dp[1][cr][j]);
    return ans;
}
int main()
{
    read(n);
    for(int i=1;i&lt;n;++i)
    {
        int x,y,z;
        read(x);read(y);read(z);
        add_edge(x,y,z);
        add_edge(y,x,z);
    }
    dfs(1,0);
    
    read(m);
    while(m--)
    {
        memset(dp,0,sizeof(dp));
        int x,y;
        read(x);read(y);
        init(x,y);
        printf("%d\n",rev ? DP(x,y,cr,cl,r,l) : DP(x,y,cl,cr,l,r));
    }
    return 0;
}</code></code></pre> 
</div> 
<p>转载于:https://www.cnblogs.com/Chtholly/p/11603677.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3635a7b5c87f7459c87dae953a996032/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android Studio获取开发版SHA1值和发布版SHA1值的史上最详细方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bf7dc4e1eea26595bd70b7a212376a25/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">springcloud学习笔记2：eureka</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>