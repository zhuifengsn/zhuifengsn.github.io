<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android中数据存储的几种方法 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android中数据存储的几种方法" />
<meta property="og:description" content="查看文章 Android中数据存储的几种方法 在Android中，可供选择的存储方式有 SharedPreferences、 文件存储、SQLite数据库方式、内容提供器（Content provider）和 网络 2010-05-20 23:12 一，Preferences Preferences是一个较轻量级的存储 数据的方法，具体使用方法： 在A中保存值： SharedPreferences.Editor sharedata = getSharedPreferences(&#34;data&#34;, 0).edit(); sharedata.putString(&#34;name&#34;,&#34;shenrenkui&#34;); sharedata.commit(); 在B中取值： SharedPreferences sharedata = getSharedPreferences(&#34;data&#34;, 0); String data = sharedata.getString(&#34;name&#34;, null); Log.i(TAG,&#34;data=&#34;&#43;data); 注意，Context.getSharedPreferences(String name,int type)的参数更我们在创建数据的时候的数据权限属性是一样的，存储和取值的过程这有点像HashMap但是比HashMap更具人性化，getXXX(Object key,Object defualtReturnValue),第二个参数是当你所要的key对应没有时候返回的值。这就省去了很多逻辑判断。。。。 二，Files 在 Android上面没有的File就是J2se中的纯种File了，可见 功能之强大，这里就算是走马观花地严重路过了。 //创建 文件 file = new File(FILE_PATH , FILE_NAME); file.createNewFile(); //打开文件file的OutputStream out = new FileOutputStream(file); String infoToWrite = &#34;纸上得来终觉浅，绝知此事要躬行&#34;; //将字符串转换成byte数组写入文件 out.write(infoToWrite.getBytes()); //关闭文件file的OutputStream out.close(); //打开文件file的InputStream in = new FileInputStream(file); //将文件内容全部读入到byte数组 int length = (int)file." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/b8bcda3fc27a197e4cf66d45201f5c87/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2010-08-30T22:56:00+08:00" />
<meta property="article:modified_time" content="2010-08-30T22:56:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android中数据存储的几种方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="width: 100%;"> 
 <table class="modth" style="width: 100%;" border="0" cellspacing="0" cellpadding="0"><tbody><tr><td class="modtl" width="7"> </td><td class="modtc"> 
     <div class="modhead"> 
      <span class="modtit">查看文章</span> 
     </div> </td><td class="modtc" align="right"> </td><td class="modtr" width="7"> </td></tr></tbody></table> 
 <div id="m_blog" class="modbox" style="overflow-x: hidden;"> 
  <div class="tit">
    Android中数据存储的几种方法  
   <table style="width: 100%; table-layout: fixed;" border="0"><tbody><tr><td> 
       <div id="blog_text" class="cnt">
         在Android中，可供选择的存储方式有 
        <a href="http://ajava.org/readbook/J2ME/androidkfysz/17348.html" rel="nofollow noopener noreferrer" target="_blank">SharedPreferences</a>、 
        <a href="http://ajava.org/readbook/J2ME/androidkfysz/17347.html" rel="nofollow noopener noreferrer" target="_blank">文件存储</a>、SQLite数据库方式、内容提供器（Content provider）和 
        <a href="http://ajava.org/readbook/J2ME/androidkfysz/17344.html" rel="nofollow noopener noreferrer" target="_blank">网络</a> 
       </div> </td></tr></tbody></table> 
  </div> 
  <div class="date">
    2010-05-20 23:12 
  </div> 
  <table style="width: 100%; table-layout: fixed;" border="0"><tbody><tr><td> 
      <div id="blog_text" class="cnt">
        一，Preferences 
       <br> 
       <br>Preferences是一个较轻量级的存储 
       <span class="t_tag">数据</span>的方法，具体使用方法： 
       <br> 
       <br>在A中保存值： 
       <br> 
       <br>SharedPreferences.Editor sharedata = getSharedPreferences("data", 0).edit(); 
       <br> 
       <br>   sharedata.putString("name","shenrenkui"); 
       <br> 
       <br>   sharedata.commit();   
       <br> 
       <br>在B中取值： 
       <br> 
       <br>SharedPreferences sharedata = getSharedPreferences("data", 0); 
       <br> 
       <br>String data = sharedata.getString("name", null); 
       <br> 
       <br>Log.i(TAG,"data="+data);   
       <br> 
       <br>注意，Context.getSharedPreferences(String name,int type)的参数更我们在创建数据的时候的数据权限属性是一样的，存储和取值的过程这有点像HashMap但是比HashMap更具人性化，getXXX(Object key,Object defualtReturnValue),第二个参数是当你所要的key对应没有时候返回的值。这就省去了很多逻辑判断。。。。 
       <br> 
       <br>二，Files 
       <br> 
       <br>在 
       <span class="t_tag">Android</span>上面没有的File就是J2se中的纯种File了，可见 
       <span class="t_tag">功能</span>之强大，这里就算是走马观花地严重路过了。 
       <br>//创建 
       <span class="t_tag">文件</span> 
       <br>         file = new File(FILE_PATH , FILE_NAME); 
       <br>         file.createNewFile(); 
       <br>         
       <br>         //打开文件file的OutputStream 
       <br>         out = new FileOutputStream(file); 
       <br>         String infoToWrite = "纸上得来终觉浅，绝知此事要躬行"; 
       <br>         //将字符串转换成byte数组写入文件 
       <br>         out.write(infoToWrite.getBytes()); 
       <br>         //关闭文件file的OutputStream 
       <br>         out.close(); 
       <br>         
       <br>         //打开文件file的InputStream 
       <br>         in = new FileInputStream(file); 
       <br>         //将文件内容全部读入到byte数组 
       <br>         int length = (int)file.length(); 
       <br>         byte[] temp = new byte[length]; 
       <br>         in.read(temp, 0, length); 
       <br>         //将byte数组用UTF-8编码并存入display字符串中 
       <br>         display =   EncodingUtils.getString(temp,TEXT_ENCODING); 
       <br>         //关闭文件file的InputStream 
       <br>         in.close(); 
       <br>       } catch (IOException e) { 
       <br>         //将出错信息打印到Logcat 
       <br>         Log.e(TAG, e.toString()); 
       <br>         this.finish(); 
       <br>       } 
       <br> 
       <br>//从 
       <span class="t_tag">资源</span>读取 
       <br> 
       <br>InputStream is=getResources().getRawResource(R.raw.文件名) 
       <br>三，Databases 
       <br> 
       <br>Android内嵌了功能比其他 
       <span class="t_tag">手机</span>操作 
       <span class="t_tag">系统</span>强大的关系型 
       <span class="t_tag">数据库</span>sqlite3,我们在大学时候学的SQL语句基本都可以使用，我们自己创建的数据可以用adb shell来操作。具体路径是/data/data/package_name/databases。如，这里演示一下进入com.android.providers.media包下面的操作。 
       <br> 
       <br>1，   adb shell 
       <br> 
       <br>2，   cd /data/data/com.android.providers.media/databases 
       <br> 
       <br>3，   ls(查看com.android.providers.media下面的数据库) 
       <br> 
       <br>4，   sqlite3 internal.db 
       <br> 
       <br>5，   .help---看看如何操作 
       <br> 
       <br>6，   .table列出internal数据中的表 
       <br> 
       <br>7，   select * from albums; 
       <br> 
       <br> 
       <br> 
       <br> 
       <br>DatabaseHelper mOpenHelper; 
       <br> 
       <br>private static final String DATABASE_NAME = "dbForTest.db"; 
       <br>private static final int DATABASE_VERSION = 1; 
       <br>private static final String TABLE_NAME = "diary"; 
       <br>private static final String TITLE = "title"; 
       <br>private static final String BODY = "body"; 
       <br> 
       <br>private static class DatabaseHelper extends SQLiteOpenHelper { 
       <br>   DatabaseHelper(Context context) { 
       <br>super(context, DATABASE_NAME, null, DATABASE_VERSION); 
       <br>   } 
       <br> 
       <br>   @Override 
       <br>   public void onCreate(SQLiteDatabase db) { 
       <br> 
       <br>String sql = "CREATE TABLE " + TABLE_NAME + " (" + TITLE 
       <br>    + " text not null, " + BODY + " text not null " + ");"; 
       <br>Log.i("haiyang:createDB=", sql); 
       <br>db.execSQL(sql); 
       <br> 
       <br>   } 
       <br> 
       <br>   @Override 
       <br>   public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { 
       <br>   } 
       <br>} 
       <br> 
       <br>/* 
       <br>   * 重新建立数据表 
       <br>   */ 
       <br>private void CreateTable() { 
       <br>   SQLiteDatabase db = mOpenHelper.getWritableDatabase(); 
       <br>   String sql = "CREATE TABLE " + TABLE_NAME + " (" + TITLE 
       <br>+ " text not null, " + BODY + " text not null " + ");"; 
       <br>   Log.i("haiyang:createDB=", sql); 
       <br> 
       <br>   try { 
       <br>db.execSQL("DROP TABLE IF EXISTS diary"); 
       <br>db.execSQL(sql); 
       <br>setTitle("数据表成功重建"); 
       <br>   } catch (SQLException e) { 
       <br>setTitle("数据表重建错误"); 
       <br>   } 
       <br>} 
       <br> 
       <br>/* 
       <br>   * 删除数据表 
       <br>   */ 
       <br>private void dropTable() { 
       <br>   SQLiteDatabase db = mOpenHelper.getWritableDatabase(); 
       <br>   String sql = "drop table " + TABLE_NAME; 
       <br>   try { 
       <br>db.execSQL(sql); 
       <br>setTitle("数据表成功删除：" + sql); 
       <br>   } catch (SQLException e) { 
       <br>setTitle("数据表删除错误"); 
       <br>   } 
       <br>} 
       <br> 
       <br>/* 
       <br>   * 插入两条数据 
       <br>   */ 
       <br>private void insertItem() { 
       <br>   SQLiteDatabase db = mOpenHelper.getWritableDatabase(); 
       <br>   String sql1 = "insert into " + TABLE_NAME + " (" + TITLE + ", " + BODY 
       <br>+ ") values('haiyang', 'android的发展真是迅速啊');"; 
       <br>   String sql2 = "insert into " + TABLE_NAME + " (" + TITLE + ", " + BODY 
       <br>+ ") values('icesky', 'android的发展真是迅速啊');"; 
       <br>   try { 
       <br>Log.i("haiyang:sql1=", sql1); 
       <br>Log.i("haiyang:sql2=", sql2); 
       <br>db.execSQL(sql1); 
       <br>db.execSQL(sql2); 
       <br>setTitle("插入两条数据成功"); 
       <br>   } catch (SQLException e) { 
       <br>setTitle("插入两条数据失败"); 
       <br>   } 
       <br>} 
       <br> 
       <br>/* 
       <br>   * 删除其中的一条数据 
       <br>   */ 
       <br>private void deleteItem() { 
       <br>   try { 
       <br>SQLiteDatabase db = mOpenHelper.getWritableDatabase(); 
       <br>db.delete(TABLE_NAME, " title = 'haiyang'", null); 
       <br>setTitle("删除title为haiyang的一条记录"); 
       <br>   } catch (SQLException e) { 
       <br> 
       <br>   } 
       <br> 
       <br>} 
       <br> 
       <br>/* 
       <br>   * 在屏幕的title区域显示当前数据表当中的数据的条数。 
       <br>   */ 
       <br>private void showItems() { 
       <br> 
       <br>   SQLiteDatabase db = mOpenHelper.getReadableDatabase(); 
       <br>   String col[] = { TITLE, BODY }; 
       <br>   Cursor cur = db.query(TABLE_NAME, col, null, null, null, null, null); 
       <br>   Integer num = cur.getCount(); 
       <br>   setTitle(Integer.toString(num) + " 条记录"); 
       <br>} 
       <br> 
       <br>四，Network 
       <br> 
       <br>这是借助Internet来存储我们要的数据，这是CS结构的存储方式，也是点一下名了。 
       <br> 
       <br> 
       <br>如何使用 Content Provider 
       <br> 
       <br>下边是 
       <span class="t_tag">用户</span>经常接触到的几个典型Content Provider 
       <span class="t_tag">应用</span>： 
       <br> 
       <br>* Content Provider Name : Intended Data 
       <br>* Browser : Browser bookmarks, Browser history, etc. 
       <br>* CallLog : Missed calls, Call datails, etc. 
       <br>* Contacts : Contact details 
       <br>* MediaStore : Media files such as audio, Video and Images 
       <br>* Settings : Device Settings and Preferences 
       <br> 
       <br>调用Content Provider资源的标准URI结构： 
       <br> 
       <br>&lt;standard_prefix&gt;://&lt;authority&gt;/&lt;data_path&gt;/&lt;id&gt; 
       <br> 
       <br>例如： 
       <br>1) 取得浏览器所有“书签”信息： content://browser/bookmarks 
       <br>2) 取得系统通讯录中的信息： content://contacts/people (如果取得某一个特定通讯记录，在路径URI的末端指定一个ID号：content://contacts/people/5 
       <br> 
       <br>简单的 
       <span class="t_tag">实例</span>片段： 
       <br> 
       <br>Uri allCalls = Uri.parse("content://call_log/calls"); 
       <br> 
       <br>Cursor c = managedQuery(allCalls, null, null, null, null); 
      </div> </td></tr></tbody></table> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8f0bce1ae135603d3cd0456353092e0a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">date命令的用法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/60d995c57f35dd74197af43fd60cbcca/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Prism之事件IEventAggregator</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>