<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySql重要知识梳理 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MySql重要知识梳理" />
<meta property="og:description" content="文章目录 一.索引1.索引概述2.索引优缺点3. 索引结构为什么InnoDB存储引擎选择使用B&#43;tree索引结构? 4.索引分类思考InnoDB主键索引的B&#43;tree高度为多高? 5. 索引语法1.索引语法2.sql性能分析1.SQL执行频率2.慢查询日志3.explain执行计划 3.索引使用规则1.最左前缀法则2.索引失效情况3.SQL提示4.覆盖索引&amp;回表查询5.前缀索引6.单列索引与联合索引7.索引设计原则 二.SQL优化1.插入优化2.主键优化1.页分裂2.页合并3.主键设计原则3.order by优化order by优化原则: 4.group by优化group by优化原则: 5.limit优化limit优化原则: 6.COUNT优化7.update优化 SQL优化总结 三.锁1.全局锁1.语法2.特点 2.表级锁介绍1.表锁2.元数据锁3.意向锁 3.行级锁介绍1.行锁数据演示 2.间隙锁&amp;临键锁数据演示 总结 四.InnoDB引擎1.概述2.MySQL的架构图1.内存结构2.磁盘结构3.后台线程 五.事务原理1.事务基础2.redo log2.undo log3.MVCC1.隐藏字段数据演示 2.undolog版本链1.介绍2.版本链3.readview4.原理分析1.RC隔离级别2.RR隔离级别 5.事务总结 一.索引 1.索引概述 索引(index)是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现查找算法，这种数据结构就是索引。
2.索引优缺点 优势劣势提高数据检索的效率,降低数据库的IO成本(提高查询速度)索引列也是要占用空间的。通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。(提高排序速度)索引大大提高了查询效率,同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低。(因为要重新维护索引结构) 3. 索引结构 索引InnoDBMyISAMMemoryB&#43;tree索引支持支持支持Hash索引不支持不支持支持R-tree索引不支持支持不支持Full-text5.6版本之后支持支持不支持 我们平时所说的索引,如果没有特别指明,都是指B&#43;树结构组织的索引。 mysqlB&#43;tree优化
Hash索引
Hash索引特点
1.Hash索引只能用于对等比较(=,in),不支持范围查询(between,&gt;,&lt;,…)
2.无法利用索引完成排序操作
3.查询效率高，通常只需要一次检索就可以了，效率通常要高于B&#43;tree索引
存储引擎支持 在MySQL中，支持hash索引的是Memory引擎,而InnoDB中具有自适应hash功能，hash索引是存储引擎根据B&#43;Tree索引在指定条件下自动构建的。 为什么InnoDB存储引擎选择使用B&#43;tree索引结构? 相对于二叉树,层级更少,搜索效率高；对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值对减少，指针跟着减少，要保存大量数据，只能增加树的高度，导致性能降低；相比Hash索引，B&#43;tree支持范围匹配以及排序操作； 4.索引分类 分类含义特点关键字主键索引针对与表中主键创建的索引默认自动创建，只能有一个PRIMARY唯一索引避免同一个表中某数据列中的值重复可以有多个UNIQUE常规索引快速定位特定数据可以有多个全文索引全文索引查找的是文本中的关键词,而不是比较索引中的值可以有多个FULLTEXT 在InnoDB存储引擎中,根据索引的存储形式，又可以分为以下两种:
分类含义特点聚集索引(Clustered Index)将数据存储与索引放到了一块,索引结构的叶子节点保存了行数据必须有,而且有一个二级索引(Secondary Index)将数据与索引分开存储,索引结构的叶子节点关联的是对应的主键可以存在多个 聚集索引选取规则:
如果存在主键,主键索引就是聚集索引。如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引。如果表没有主键，或没有合适的唯一索引，则InnoDDB会自动生成一个rowid作为隐藏的聚集索引。
思考InnoDB主键索引的B&#43;tree高度为多高? 由上看出来即使存储2000多万行的数据树的高度只有三层，可见检索效率是非常高效的。
5. 索引语法 1.索引语法 2.sql性能分析 1.SQL执行频率 MySQL客户端连接成功后，通过show[session|global] status命令可以提供服务器状态信息。通过如下指令,可以查看当前数据库的 INSERT 、UPDATE、DELETE、SELECT的访问频次:
SHOW GLOBAL STATUS LIKE &#39;Com_______&#39;; 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/457e69200ba3af52e303e28eb715b7f1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-20T20:33:23+08:00" />
<meta property="article:modified_time" content="2024-02-20T20:33:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySql重要知识梳理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-kimbie-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">一.索引</a></li><li><ul><li><a href="#1_2" rel="nofollow">1.索引概述</a></li><li><a href="#2_5" rel="nofollow">2.索引优缺点</a></li><li><a href="#3__22" rel="nofollow">3. 索引结构</a></li><li><ul><li><a href="#font_colorredInnoDBBtreefont_78" rel="nofollow"><font color="red">为什么InnoDB存储引擎选择使用B+tree索引结构?</font></a></li></ul> 
   </li><li><a href="#4_82" rel="nofollow">4.索引分类</a></li><li><ul><li><a href="#InnoDBBtree_141" rel="nofollow">思考InnoDB主键索引的B+tree高度为多高?</a></li></ul> 
   </li><li><a href="#5__144" rel="nofollow">5. 索引语法</a></li><li><ul><li><a href="#1_145" rel="nofollow">1.索引语法</a></li><li><a href="#2sql_147" rel="nofollow">2.sql性能分析</a></li><li><ul><li><a href="#1SQL_148" rel="nofollow">1.SQL执行频率</a></li><li><a href="#2_156" rel="nofollow">2.慢查询日志</a></li><li><a href="#3explain_202" rel="nofollow">3.explain执行计划</a></li></ul> 
    </li><li><a href="#3_230" rel="nofollow">3.索引使用规则</a></li><li><ul><li><a href="#1_231" rel="nofollow">1.最左前缀法则</a></li><li><a href="#2_244" rel="nofollow">2.索引失效情况</a></li><li><a href="#3SQL_260" rel="nofollow">3.SQL提示</a></li><li><a href="#4_263" rel="nofollow">4.覆盖索引&amp;回表查询</a></li><li><a href="#5_271" rel="nofollow">5.前缀索引</a></li><li><a href="#6_276" rel="nofollow">6.单列索引与联合索引</a></li><li><a href="#7_279" rel="nofollow">7.索引设计原则</a></li></ul> 
   </li></ul> 
  </li></ul> 
  </li><li><a href="#SQL_288" rel="nofollow">二.SQL优化</a></li><li><ul><li><a href="#1_289" rel="nofollow">1.插入优化</a></li><li><a href="#2_326" rel="nofollow">2.主键优化</a></li><li><ul><li><a href="#1_331" rel="nofollow">1.页分裂</a></li><li><a href="#2_335" rel="nofollow">2.页合并</a></li><li><a href="#3_341" rel="nofollow">3.主键设计原则</a></li><li><a href="#3order_by_347" rel="nofollow">3.order by优化</a></li><li><ul><li><a href="#order_by_353" rel="nofollow">order by优化原则:</a></li></ul> 
    </li><li><a href="#4group_by_361" rel="nofollow">4.group by优化</a></li><li><ul><li><a href="#group_by_374" rel="nofollow">group by优化原则:</a></li></ul> 
    </li><li><a href="#5limit_378" rel="nofollow">5.limit优化</a></li><li><ul><li><a href="#limit_385" rel="nofollow">limit优化原则:</a></li></ul> 
    </li><li><a href="#6COUNT_389" rel="nofollow">6.COUNT优化</a></li><li><a href="#7update_402" rel="nofollow">7.update优化</a></li></ul> 
   </li><li><a href="#SQL_425" rel="nofollow">SQL优化总结</a></li></ul> 
  </li><li><a href="#_428" rel="nofollow">三.锁</a></li><li><ul><li><a href="#1_438" rel="nofollow">1.全局锁</a></li><li><ul><li><a href="#1_445" rel="nofollow">1.语法</a></li><li><a href="#2_461" rel="nofollow">2.特点</a></li></ul> 
   </li><li><a href="#2_474" rel="nofollow">2.表级锁</a></li><li><ul><li><a href="#_475" rel="nofollow">介绍</a></li><li><a href="#1_482" rel="nofollow">1.表锁</a></li><li><a href="#2_499" rel="nofollow">2.元数据锁</a></li><li><a href="#3_515" rel="nofollow">3.意向锁</a></li></ul> 
   </li><li><a href="#3_544" rel="nofollow">3.行级锁</a></li><li><ul><li><a href="#_545" rel="nofollow">介绍</a></li><li><a href="#1_555" rel="nofollow">1.行锁</a></li><li><ul><li><a href="#_561" rel="nofollow">数据演示</a></li></ul> 
    </li><li><a href="#2_607" rel="nofollow">2.间隙锁&amp;临键锁</a></li><li><ul><li><a href="#_617" rel="nofollow">数据演示</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_639" rel="nofollow">总结</a></li></ul> 
  </li><li><a href="#InnoDB_645" rel="nofollow">四.InnoDB引擎</a></li><li><ul><li><a href="#1_646" rel="nofollow">1.概述</a></li><li><a href="#2MySQL_663" rel="nofollow">2.MySQL的架构图</a></li><li><ul><li><a href="#1_667" rel="nofollow">1.内存结构</a></li><li><a href="#2_705" rel="nofollow">2.磁盘结构</a></li><li><a href="#3_760" rel="nofollow">3.后台线程</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_786" rel="nofollow">五.事务原理</a></li><li><ul><li><a href="#1_787" rel="nofollow">1.事务基础</a></li><li><a href="#2redo_log_805" rel="nofollow">2.redo log</a></li><li><a href="#2undo_log_836" rel="nofollow">2.undo log</a></li><li><a href="#3MVCC_850" rel="nofollow">3.MVCC</a></li><li><ul><li><a href="#1_875" rel="nofollow">1.隐藏字段</a></li><li><ul><li><a href="#_879" rel="nofollow">数据演示</a></li></ul> 
    </li><li><a href="#2undolog_906" rel="nofollow">2.undolog版本链</a></li><li><ul><li><a href="#1_907" rel="nofollow">1.介绍</a></li><li><a href="#2_912" rel="nofollow">2.版本链</a></li><li><a href="#3readview_936" rel="nofollow">3.readview</a></li><li><a href="#4_947" rel="nofollow">4.原理分析</a></li><li><ul><li><a href="#1RC_948" rel="nofollow">1.RC隔离级别</a></li><li><a href="#2RR_958" rel="nofollow">2.RR隔离级别</a></li></ul> 
    </li></ul> 
   </li></ul> 
   </li><li><a href="#5_967" rel="nofollow">5.事务总结</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>一.索引</h2> 
<h3><a id="1_2"></a>1.索引概述</h3> 
<ul><li>索引(index)是帮助MySQL<font color="red">高效获取数据的数据结构(有序)。</font>在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现查找算法，这种数据结构就是索引。<br> <img src="https://images2.imgbox.com/2d/6f/1rQOn6yq_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="2_5"></a>2.索引优缺点</h3> 
<table border="1"><tbody><tr><td><font color="red">优势</font></td><td><font color="red">劣势</font></td></tr><tr><td>提高数据检索的效率,降低数据库的IO成本(提高查询速度)</td><td>索引列也是要占用空间的。</td></tr><tr><td>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。(提高排序速度)</td><td>索引大大提高了查询效率,同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低。(因为要重新维护索引结构)</td></tr></tbody></table> 
<h3><a id="3__22"></a>3. 索引结构</h3> 
<table border="1"><tbody><tr><td><font color="red">索引</font></td><td><font color="red">InnoDB</font></td><td><font color="red">MyISAM</font></td><td><font color="red">Memory</font></td></tr><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-tree索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本之后支持</td><td>支持</td><td>不支持</td></tr></tbody></table> 
<font color="red">我们平时所说的索引,如果没有特别指明,都是指B+树结构组织的索引。</font> 
<p><img src="https://images2.imgbox.com/f7/02/iYzPjitI_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f5/41/ENUjxsu4_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/32/7d/RcVjnTC4_o.png" alt="在这里插入图片描述"></p> 
<ul><li>mysqlB+tree优化<br> <img src="https://images2.imgbox.com/ef/7e/E1HC17gZ_o.png" alt="在这里插入图片描述"></li><li>Hash索引<br> <img src="https://images2.imgbox.com/c7/25/FLPvC3wW_o.png" alt="在这里插入图片描述"></li></ul> 
<hr> 
<p><strong>Hash索引特点</strong><br> 1.Hash索引只能用于对等比较(=,in),不支持范围查询(between,&gt;,&lt;,…)<br> 2.无法利用索引完成排序操作<br> 3.查询效率高，通常只需要一次检索就可以了，效率通常要高于B+tree索引</p> 
<hr> 存储引擎支持 在MySQL中，支持hash索引的是Memory引擎,而InnoDB中具有自适应hash功能，hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的。 
<hr> 
<h4><a id="font_colorredInnoDBBtreefont_78"></a><font color="red">为什么InnoDB存储引擎选择使用B+tree索引结构?</font></h4> 
<ul><li>相对于二叉树,层级更少,搜索效率高；</li><li>对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值对减少，指针跟着减少，要保存大量数据，只能增加树的高度，导致性能降低；</li><li>相比Hash索引，B+tree支持范围匹配以及排序操作；</li></ul> 
<h3><a id="4_82"></a>4.索引分类</h3> 
<table border="1"><tbody><tr><td><font color="red">分类</font></td><td><font color="red">含义</font></td><td><font color="red">特点</font></td><td><font color="red">关键字</font></td></tr><tr><td><font color="red">主键索引</font></td><td>针对与表中主键创建的索引</td><td>默认自动创建，只能有一个</td><td>PRIMARY</td></tr><tr><td><font color="red">唯一索引</font></td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td><font color="red">常规索引</font></td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td><font color="red">全文索引</font></td><td>全文索引查找的是文本中的关键词,而不是比较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table> 
<p><strong>在InnoDB存储引擎中,根据索引的存储形式，又可以分为以下两种:</strong></p> 
<table border="1"><tbody><tr><td><font color="red">分类</font></td><td><font color="red">含义</font></td><td><font color="red">特点</font></td></tr><tr><td><font color="red">聚集索引</font>(Clustered Index)</td><td>将数据存储与索引放到了一块,索引结构的叶子节点保存了行数据</td><td>必须有,而且有一个</td></tr><tr><td><font color="red">二级索引</font>(Secondary Index)</td><td>将数据与索引分开存储,索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table> 
<p><strong>聚集索引选取规则:</strong></p> 
<ul><li>如果存在主键,主键索引就是聚集索引。</li><li>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引。</li><li>如果表没有主键，或没有合适的唯一索引，则InnoDDB会自动生成一个rowid作为隐藏的聚集索引。<br> <img src="https://images2.imgbox.com/23/45/S8YyhLFJ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/05/dd/zPmu5ufJ_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="InnoDBBtree_141"></a>思考InnoDB主键索引的B+tree高度为多高?</h4> 
<p><img src="https://images2.imgbox.com/9d/4b/xdTiTQsx_o.png" alt="在这里插入图片描述"><br> <font color="red">由上看出来即使存储2000多万行的数据树的高度只有三层，可见检索效率是非常高效的。</font></p> 
<h3><a id="5__144"></a>5. 索引语法</h3> 
<h4><a id="1_145"></a>1.索引语法</h4> 
<p><img src="https://images2.imgbox.com/81/bb/izjzmZyS_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2sql_147"></a>2.sql性能分析</h4> 
<h5><a id="1SQL_148"></a>1.SQL执行频率</h5> 
<p>MySQL客户端连接成功后，通过show[session|global] status命令可以提供服务器状态信息。通过如下指令,可以查看当前数据库的 INSERT 、UPDATE、DELETE、SELECT的访问频次:</p> 
<pre><code class="prism language-sql"><span class="token keyword">SHOW</span> <span class="token keyword">GLOBAL</span> <span class="token keyword">STATUS</span> <span class="token operator">LIKE</span> <span class="token string">'Com_______'</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/de/ab/HekhDt99_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="2_156"></a>2.慢查询日志</h5> 
<ul><li>慢查询日志记录了所有执行时间超过参数(long_query_time,单位:秒,默认10秒)的所有SQL语句的日志。MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件(/etc/my.cnf)中配置如下信息:</li></ul> 
<p><strong>查看慢sql日志是否开启信息</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'slow_query_log'</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/ce/3d/F6L75Lyo_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/47/67/eYEOXpdG_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p><strong>profile详情</strong></p> 
<p>show profiles能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过having_profiling参数，能够看到当前MySQL是否支持profile操作:</p> 
<pre><code class="prism language-sql"><span class="token keyword">SELECT</span> @<span class="token variable">@have_profiling</span><span class="token punctuation">;</span>

</code></pre> 
<p><img src="https://images2.imgbox.com/94/74/uWn3aZAd_o.png" alt="在这里插入图片描述"><br> 默认profiling是关闭的,可以通过set语句在session/global级别开启profiling;</p> 
<pre><code class="prism language-sql"><span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'profiling'</span><span class="token punctuation">;</span>

</code></pre> 
<p><img src="https://images2.imgbox.com/55/67/l0qxqS3K_o.png" alt="在这里插入图片描述"><br> 开启命令</p> 
<pre><code class="prism language-sql"><span class="token keyword">set</span> profiling <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre> 
<p><font color="red">执行一系列的业务SQL的操作,可以通过如下指令查看指令的执行耗时</font></p> 
<pre><code class="prism language-sql"><span class="token comment">#查看每一条SQL的耗时基本情况</span>
<span class="token keyword">show</span> profiles<span class="token punctuation">;</span>
<span class="token comment">#查看指定query_id的SQL语句各个阶段的耗时情况</span>
<span class="token keyword">show</span> profile <span class="token keyword">for</span> query query_id
<span class="token comment">#查看指定query_id的SQL语句CPU的使用情况</span>
<span class="token keyword">show</span> profile cpu <span class="token keyword">for</span> query query_id
</code></pre> 
<h5><a id="3explain_202"></a>3.explain执行计划</h5> 
<p>explain或则desc命令获取MySQL如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和执行的顺序。<br> 语法:</p> 
<pre><code class="prism language-sql"><span class="token comment">#直接在select语句之前加上关键字exlain/desc</span>
<span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> 字段列表 <span class="token keyword">FROM</span> 表名 <span class="token keyword">WHERE</span> 条件<span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/32/60/1PO0etY1_o.png" alt="在这里插入图片描述"></p> 
<p><strong>explain执行计划各字段含义:</strong></p> 
<ul><li>Id<br> select 查询的序列号，表示查询中执行select子句或则是操作表的顺序(id相同,执行顺序从上到下；id不同,值越大，越先执行)。<br> <img src="https://images2.imgbox.com/06/3e/wHCbqnY5_o.png" alt="在这里插入图片描述"></li><li>select_type<br> 表示SELECT的类型，常见的取值有SIMPLE(简单表，即不使用表连接或则子查询)、PRIMARY（主查询，即外层的查询)、UNION（UNION中的第二个或则后面的查询语句）、SUBQUERY(SELECT/WHERE之后包括了子查询）等。</li><li><font color="red">type</font><br> <font color="red">表示连接类型,性能由好到差的连接类型为NULL，system、const、eq_ref、ref、range、index、all.</font></li><li>possible_key<br> 显示可能应用在这张表上的索引，一个或多个。</li><li>Key<br> 实际使用的索引，如果为NULL，则没有使用索引。</li><li>Key_len<br> 表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。</li><li>rows<br> MySQL认为必须要执行查询的行数,在innodb引擎的表中，是一个估计值,可能并不总是准确的。</li><li>filtered<br> 表示返回结果的行数占需读取行数的百分比，filtered的值越大越好。</li></ul> 
<h4><a id="3_230"></a>3.索引使用规则</h4> 
<h5><a id="1_231"></a>1.最左前缀法则</h5> 
<p>如果索引了多列(联合索引)，要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，<font color="red">索引将部分失效(后面的字段索引失效)</font>。</p> 
<ul><li>注意:如果多个索引列的话按照最左前缀描述需要从第一个索引列开始走索引，如果第一个复合索引没有被命中，后面的将不会走索引。</li><li>注意:如果索引列都被命中，但是顺序是乱的也会走复合索引。</li><li>注意:如果第一个索引列被命中，后面的索引列部分中断，索引列走的是复合索引的连续索引。</li></ul> 
<hr> 
<p><strong>范围查询</strong><br> 联合索引中，出现范围查询(&gt;,&lt;),<font color="red">范围查询右侧的列索引失效。</font><br> <img src="https://images2.imgbox.com/32/5c/Zgntk9n0_o.png" alt="在这里插入图片描述"><br> <font color="red">大于等于或则小于等于可以避免这种情况</font></p> 
<h5><a id="2_244"></a>2.索引失效情况</h5> 
<ul><li> <p>索引列运算<br> 不要在索引列上进行运算操作，<font color="red">索引将失效</font>。<br> <img src="https://images2.imgbox.com/51/a1/BH5sS0cV_o.png" alt="在这里插入图片描述"></p> </li><li> <p>字符串不加引号<br> 字符串类型字段使用时，不加引号，<font color="red">索引将失效</font>。<br> <img src="https://images2.imgbox.com/65/80/ZjXlX0Vm_o.png" alt="在这里插入图片描述"></p> </li><li> <p>模糊查询<br> 如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，<font color="red">索引将失效</font>。<br> <img src="https://images2.imgbox.com/d2/ee/C0fkJ0kP_o.png" alt="在这里插入图片描述"></p> </li><li> <p>or连接的条件<br> 用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。<br> <img src="https://images2.imgbox.com/69/8a/3dpZQEBJ_o.png" alt="在这里插入图片描述"></p> </li><li> <p>数据分布影响<br> 如果MySQL评估使用索引比全表更慢，则不使用索引。</p> </li></ul> 
<h5><a id="3SQL_260"></a>3.SQL提示</h5> 
<p>SQL提示,是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。<br> <img src="https://images2.imgbox.com/fa/94/2yHIyspI_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="4_263"></a>4.覆盖索引&amp;回表查询</h5> 
<ul><li>覆盖索引<br> 尽量使用覆盖索引(查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到)，减少select *。<br> <font color="red">知识贴士:<br> 1.using index condition:查找使用了索引,但是需要回表查询数据<br> 2.using where;using index:查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据<br> <br> <img src="https://images2.imgbox.com/ae/42/KZlIsXKn_o.png" alt="在这里插入图片描述"></font></li></ul> 
<h5><a id="5_271"></a>5.前缀索引</h5> 
<p>当字段类型为字符串(varchar,text等)时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。<br> <img src="https://images2.imgbox.com/b8/23/llIb3XLL_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/39/95/7lQM7XpF_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/03/18/UM0Xpc2e_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="6_276"></a>6.单列索引与联合索引</h5> 
<p>单列索引:一个索引只包含单个列<br> 联合索引:一个索引包括多个列</p> 
<h5><a id="7_279"></a>7.索引设计原则</h5> 
<ol><li>针对数据量大，且查询比较频繁的表建立索引。</li><li>针对于常作为查询条件(where)、排序(order by)、分组(group by)操作的字段建立索引。</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li><li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束他。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</li></ol> 
<h2><a id="SQL_288"></a>二.SQL优化</h2> 
<h3><a id="1_289"></a>1.插入优化</h3> 
<ul><li><strong>批量插入</strong></li></ul> 
<pre><code class="prism language-sql"><span class="token keyword">Insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'Tom'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'Cat'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'Jerry'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li><strong>手动提交事务</strong></li></ul> 
<pre><code class="prism language-sql"><span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'Tom'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'Cat'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'Jerry'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">'Tom'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">'Cat'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token string">'Jerry'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> tb_test <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token string">'Tom'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">'Cat'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token string">'Jerry'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">commit</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li><strong>主键顺序插入</strong><br> 主键顺序插入，性能要高于乱序插入。</li></ul> 
<pre><code class="prism language-sql">主键乱序插入 : <span class="token number">8</span> <span class="token number">1</span> <span class="token number">9</span> <span class="token number">21</span> <span class="token number">88</span> <span class="token number">2</span> <span class="token number">4</span> <span class="token number">15</span> <span class="token number">89</span> <span class="token number">5</span> <span class="token number">7</span> <span class="token number">3</span>
主键顺序插入 : <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token number">15</span> <span class="token number">21</span> <span class="token number">88</span> <span class="token number">89</span>
</code></pre> 
<ul><li><strong>大批量插入数据</strong><br> 如果一次性需要插入大批量数据(比如: 几百万的记录)，使用insert语句插入性能较低，此时可以使<br> 用MySQL数据库提供的load指令进行插入。</li></ul> 
<pre><code class="prism language-sql"><span class="token comment">-- 客户端连接服务端时，加上参数 -–local-infile</span>
mysql <span class="token comment">--local-infile -u root -p</span>
<span class="token comment">-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span>
<span class="token keyword">set</span> <span class="token keyword">global</span> local_infile <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token comment">-- 执行load指令将准备好的数据，加载到表结构中</span>
<span class="token keyword">load</span> <span class="token keyword">data</span> <span class="token keyword">local</span> <span class="token keyword">infile</span> <span class="token string">'/root/sql1.log'</span> <span class="token keyword">into</span> <span class="token keyword">table</span> tb_user <span class="token keyword">fields</span>
<span class="token keyword">terminated</span> <span class="token keyword">by</span> <span class="token string">','</span> <span class="token keyword">lines</span> <span class="token keyword">terminated</span> <span class="token keyword">by</span> <span class="token string">'\n'</span> <span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/d8/b1/WWZ3g7kN_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2_326"></a>2.主键优化</h3> 
<ul><li>数据组织方式<br> 在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为<br> <font color="red">索引组织表</font>（index organized table IOT).<br> <img src="https://images2.imgbox.com/51/ee/nTjrgQg3_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="1_331"></a>1.页分裂</h4> 
<p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据太大，会行溢出)，根据主键排列。<br> <img src="https://images2.imgbox.com/78/cd/nyRffU28_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/26/a4/y2pDNhjd_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_335"></a>2.页合并</h4> 
<p>当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记(flaged)为删除并且它的空间变得允许被其他记录声明使用。<br> 当页删除的记录达到MERGE_THRESHOLD（默认为页的50%)，InnoDB会开始寻找最靠前的页(前或后)看看是否可以将两个页合并以优化空间使用。<br> <img src="https://images2.imgbox.com/7e/52/toVrAY8R_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/c7/e3/ep5Ze8y2_o.png" alt="在这里插入图片描述"><br> <font color="red">MERGE_THRESHOLD:合并页的阈值,可以自己设置，在创建表或者创建索引时指定。</font></p> 
<h4><a id="3_341"></a>3.主键设计原则</h4> 
<ul><li>满足业务需求的情况下，尽量降低主键的长度。</li><li>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</li><li>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</li><li>业务操作时，避免对主键的修改。</li></ul> 
<h4><a id="3order_by_347"></a>3.order by优化</h4> 
<ol><li>Using filesort:通过表的索引或全表扫描，读取满足条件的数据行，然后再排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫FileSort排序。</li><li>Using index:通过有序索引顺序扫描直接返回有序数据，这种情况即为using index,不需要额外排序，操作效率高。<br> <img src="https://images2.imgbox.com/f2/18/NYglIuEt_o.png" alt="在这里插入图片描述"><br> <strong>如果按照age和phone进行联合索引，但是排序的时候不按照age和phone进行进行查询，违背最左前缀法则也会不走索引查询</strong></li></ol> 
<h5><a id="order_by_353"></a>order by优化原则:</h5> 
<font color="red"> A. 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。<br> B. 尽量使用覆盖索引,避免查询使用select *，进行回表查询。<br> C. 多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。<br> D. 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认256k)。</font> 
<br> 
<h4><a id="4group_by_361"></a>4.group by优化</h4> 
<p>下面这个图是没有创建索引的分组查询语句<br> <img src="https://images2.imgbox.com/0d/8a/tr6uIC6l_o.png" alt="在这里插入图片描述"><br> 创建一个联合索引<br> <img src="https://images2.imgbox.com/3c/9c/2J2BdqZf_o.png" alt="在这里插入图片描述"><br> 根据profession查询可以看到已经走索引<br> <img src="https://images2.imgbox.com/a5/f6/fBAsYySv_o.png" alt="在这里插入图片描述"><br> 根据age分组查询<br> <img src="https://images2.imgbox.com/2d/56/XGId7Pg6_o.png" alt="在这里插入图片描述"></p> 
<p><font color="red">如果仅仅根据age分组，就会出现 Using temporary ；而如果是 根据<br> profession,age两个字段同时分组，则不会出现 Using temporary。原因是因为对于分组操作，在联合索引中，也是符合最左前缀法则的。</font></p> 
<h5><a id="group_by_374"></a>group by优化原则:</h5> 
<p><font color="red">A. 在分组操作时，可以通过索引来提高效率。<br> B. 分组操作时，索引的使用也是满足最左前缀法则的。<br> </font></p> 
<h4><a id="5limit_378"></a>5.limit优化</h4> 
<p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。<br> <img src="https://images2.imgbox.com/a1/06/fXPVz4FK_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/98/b5/cnDJJ22m_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/36/08/sZ4k8QMo_o.png" alt="在这里插入图片描述"><br> <strong>因为，当在进行分页查询时，如果执行 limit 2000000,10 ，此时需要MySQL排序前2000010 记<br> 录，仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。</strong></p> 
<h5><a id="limit_385"></a>limit优化原则:</h5> 
<p><font color="red">优化思路: 一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</font><br> <img src="https://images2.imgbox.com/19/48/KJFXw0pj_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/50/ae/divMGCoj_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="6COUNT_389"></a>6.COUNT优化</h4> 
<ul><li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高； 但是如果是带条件的count，MyISAM也慢。</li><li>InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li></ul> 
<p>如果说要大幅度提升InnoDB表的count效率，主要的优化思路：自己计数(可以借助于redis这样的数据库进行,但是如果是带条件的count又比较麻烦了)。</p> 
<p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是NULL，累计值就加 1，否则不加，最后返回累计值。<br> 用法：count（*）、count（主键）、count（字段）、count（数字）</p> 
<p><img src="https://images2.imgbox.com/d0/2b/cCFMjQbl_o.png" alt="在这里插入图片描述"><br> <font color="red">按照效率排序的话，count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(<em>)，所以尽<br> 量使用 count(</em>)。<br> </font></p> 
<h4><a id="7update_402"></a>7.update优化</h4> 
<p>course表原始数据<br> <img src="https://images2.imgbox.com/87/12/vqUeV5nx_o.png" alt="在这里插入图片描述"><br> 在第一个cmd窗口开启事务并且对name为Spring的记录进行修改<br> <img src="https://images2.imgbox.com/91/1e/1J7eJNMr_o.png" alt="在这里插入图片描述"></p> 
<p>在第二个cmd窗口开启事务对name=Hadoop进行修改，发现出现阻塞<br> <img src="https://images2.imgbox.com/53/48/g3CBsao2_o.png" alt="在这里插入图片描述"></p> 
<p>第一个cmd窗口提交事务的时候第二个cmd窗口成功修改<br> <img src="https://images2.imgbox.com/f0/92/sdhZuhMi_o.png" alt="在这里插入图片描述"></p> 
<p>当我们开启多个事务，在执行上述的SQL时，我们发现行锁升级为了表锁。 导致该update语句的性能大大降低。</p> 
<hr> 查看索引结构发现name没有创建索引,对name创建索引 
<p><img src="https://images2.imgbox.com/a2/eb/ehTOSgkH_o.png" alt="在这里插入图片描述"><br> 然后在cmd执行命令发现不会把行锁升级为表锁<br> <img src="https://images2.imgbox.com/04/86/uASiEHrT_o.png" alt="在这里插入图片描述"><br> <font color="red">InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁升级为表锁 。</font></p> 
<h3><a id="SQL_425"></a>SQL优化总结</h3> 
<p><img src="https://images2.imgbox.com/cb/ef/lm3Qj2eY_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_428"></a>三.锁</h2> 
<p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、<br> RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有<br> 效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个<br> 角度来说，锁对数据库而言显得尤其重要，也更加复杂。<br> MySQL中的锁，按照锁的粒度分，分为以下三类：</p> 
<ul><li>全局锁：锁定数据库中的所有表。</li><li>表级锁：每次操作锁住整张表。</li><li>行级锁：每次操作锁住对应的行数据。</li></ul> 
<h3><a id="1_438"></a>1.全局锁</h3> 
<p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。<br> 其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。<br> 全局锁加锁之后的情景<br> <img src="https://images2.imgbox.com/a0/c9/tgEfYUpU_o.png" alt="在这里插入图片描述"><br> 对数据库进行进行逻辑备份之前，先对整个数据库加上全局锁，一旦加了全局锁之后，其他的DDL、DML全部都处于阻塞状态，但是可以执行DQL语句，也就是处于只读状态，而数据备份就是查询操作。<br> 那么数据在进行逻辑备份的过程中，数据库中的数据就是不会发生变化的，这样就保证了数据的一致性和完整性。</p> 
<h4><a id="1_445"></a>1.语法</h4> 
<p>1). 加全局锁</p> 
<pre><code class="prism language-sql">flush <span class="token keyword">tables</span> <span class="token keyword">with</span> <span class="token keyword">read</span> <span class="token keyword">lock</span> <span class="token punctuation">;</span>
</code></pre> 
<p>2). 数据备份</p> 
<pre><code class="prism language-sql">mysqldump <span class="token operator">-</span>uroot –pxxx 数据库<span class="token operator">&gt;</span> 导出的数据库名<span class="token punctuation">.</span><span class="token keyword">sql</span>
</code></pre> 
<p>3). 释放锁</p> 
<pre><code class="prism language-sql"><span class="token keyword">unlock</span> <span class="token keyword">tables</span> <span class="token punctuation">;</span>
</code></pre> 
<h4><a id="2_461"></a>2.特点</h4> 
<p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p> 
<ul><li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</li><li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</li></ul> 
<hr> 
<p><strong>在InnoDB引擎中，我们可以在备份时加上参数 --single-transaction 参数来完成不加锁的一致性数据备份。</strong></p> 
<pre><code class="prism language-sql">mysqldump <span class="token comment">--single-transaction -uroot –pxxx 数据库 &gt; 导出的数据库名.sql</span>

</code></pre> 
<h3><a id="2_474"></a>2.表级锁</h3> 
<h4><a id="_475"></a>介绍</h4> 
<p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。<br> 对于表级锁，主要分为以下三类：</p> 
<ul><li>表锁</li><li>元数据锁（meta data lock，MDL）</li><li>意向锁</li></ul> 
<h4><a id="1_482"></a>1.表锁</h4> 
<p>对于表锁，分为两类：</p> 
<ul><li>表共享读锁（read lock）</li><li>表独占写锁（write lock）<br> 语法：<br> 加锁：<strong>lock tables 表名… read/write。</strong><br> 释放锁：<strong>unlock tables / 客户端断开连接 。</strong><br> <img src="https://images2.imgbox.com/50/49/gCPiMwYY_o.png" alt="在这里插入图片描述"><br> 左侧为客户端一，对指定表加了写锁，会阻塞右侧客户端的读和写。<br> <img src="https://images2.imgbox.com/3c/16/V0iKlcwG_o.png" alt="在这里插入图片描述"><br> 左侧为客户端一，对指定表加了读锁，不会影响右侧客户端二的读，但是会阻塞右侧客户端的写。</li></ul> 
<p><img src="https://images2.imgbox.com/a4/f6/rDNyTyJf_o.png" alt="在这里插入图片描述"><br> <font color="red">结论: 读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</font><br> <img src="https://images2.imgbox.com/0b/35/g6e8eUgh_o.png" alt="在这里插入图片描述"><br> 释放锁另一个客户端可以成功写入成功</p> 
<h4><a id="2_499"></a>2.元数据锁</h4> 
<p>meta data lock , 元数据锁，简写MDL。<br> MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。<strong>为了避免DML与DDL冲突，保证读写的正确性。</strong><br> 这里的元数据，大家可以简单理解为就是一张表的表结构。 也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。<br> 在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)。<br> 常见的SQL操作时，所添加的元数据锁：<br> <img src="https://images2.imgbox.com/6a/af/sm0YvipI_o.png" alt="在这里插入图片描述"><br> <strong>查看元数据锁</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> object_type<span class="token punctuation">,</span>object_schema<span class="token punctuation">,</span>object_name<span class="token punctuation">,</span>lock_type<span class="token punctuation">,</span>lock_duration <span class="token keyword">from</span>
performance_schema<span class="token punctuation">.</span>metadata_locks <span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/30/47/EoF20Ni9_o.png" alt="在这里插入图片描述"><br> 当开启事务的时候执行查询和修改查看元数据锁发现共享读锁和共享写锁全部开启了。</p> 
<h4><a id="3_515"></a>3.意向锁</h4> 
<p>1). 介绍<br> 为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</p> 
<p><img src="https://images2.imgbox.com/e7/c6/3vX0qlyE_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/30/00/oBgLu6Oz_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/36/22/iVYkGxmQ_o.png" alt="在这里插入图片描述"></p> 
<ul><li><strong>意向共享锁(IS): 由语句select … lock in share mode添加 。 与 表锁共享锁<br> (read)兼容，与表锁排他锁(write)互斥。</strong></li><li><strong>意向排他锁(IX): 由insert、update、delete、select…for update添加 。<br> 与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。</strong></li></ul> 
<p><font color="red">一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</font></p> 
<p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p> 
<p><font color="red">select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from<br> performance_schema.data_locks;</font></p> 
<hr> 下面演示意向共享锁(IS)的加锁情况 
<p><strong>左侧客户端开启事务加入意向共享锁(IS),右侧可以加入表共享读锁,但是添加表共享写锁失败</strong><br> <img src="https://images2.imgbox.com/6a/ef/P8MhR299_o.png" alt="在这里插入图片描述"></p> 
<hr> 下面演示意向排他锁(IX)的加锁情况 
<p><strong>左侧客户端开启事务加入意向排他锁(IX),右侧不可以加入表共享读锁和写锁。</strong><br> <img src="https://images2.imgbox.com/9d/15/mqjOLG4k_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3_544"></a>3.行级锁</h3> 
<h4><a id="_545"></a>介绍</h4> 
<p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。<br> InnoDB的数据是基于<strong>索引组织</strong>的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：</p> 
<ul><li>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。<br> <img src="https://images2.imgbox.com/18/59/awtMTeHS_o.png" alt="在这里插入图片描述"></li><li>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</li></ul> 
<p><img src="https://images2.imgbox.com/a7/2e/W3YGrrJf_o.png" alt="在这里插入图片描述"></p> 
<ul><li>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。<br> <img src="https://images2.imgbox.com/db/6e/9EeGTzaZ_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="1_555"></a>1.行锁</h4> 
<p>InnoDB实现了以下两种类型的行锁：</p> 
<ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</li><li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。<br> <img src="https://images2.imgbox.com/55/94/SF7HqEyk_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/24/cf/j8OM8Cns_o.png" alt="在这里插入图片描述"></li></ul> 
<h5><a id="_561"></a>数据演示</h5> 
<p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p> 
<ul><li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</li><li>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时 就会升级为表锁</li></ul> 
<p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p> 
<pre><code class="prism language-sql"><span class="token keyword">select</span> object_schema<span class="token punctuation">,</span>object_name<span class="token punctuation">,</span>index_name<span class="token punctuation">,</span>lock_type<span class="token punctuation">,</span>lock_mode<span class="token punctuation">,</span>lock_data <span class="token keyword">from</span>
performance_schema<span class="token punctuation">.</span>data_locks<span class="token punctuation">;</span>
</code></pre> 
<p>数据准备</p> 
<pre><code class="prism language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>stu<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>
<span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
<span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
<span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span> <span class="token keyword">int</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> <span class="token operator">=</span> utf8mb4<span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>stu<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'tom'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>stu<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'cat'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>stu<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">'rose'</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>stu<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token string">'jetty'</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>stu<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">,</span> <span class="token string">'lily'</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>stu<span class="token punctuation">`</span></span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">,</span> <span class="token string">'luci'</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>1.普通的select语句，执行时，不会加锁。<br> <img src="https://images2.imgbox.com/3d/5a/fJmoEyuX_o.png" alt="在这里插入图片描述"><br> 2.select…lock in share mode，加共享锁，共享锁与共享锁之间兼容。</p> 
<p><img src="https://images2.imgbox.com/2a/02/J1iNzxMs_o.png" alt="在这里插入图片描述"><br> 3.共享锁与排他锁之间互斥。<br> <img src="https://images2.imgbox.com/68/36/GFR4rRQw_o.png" alt="在这里插入图片描述"><br> 客户端一获取的是id为1这行的共享锁，客户端二是可以获取id为3这行的排它锁的，因为不是同一行数据。 而如果客户端二想获取id为1这行的排他锁，会处于阻塞状态，以为共享锁与排他锁之间互斥。</p> 
<hr> 4.排它锁与排他锁之间互斥 
<p><img src="https://images2.imgbox.com/dd/21/kanAQyf2_o.png" alt="在这里插入图片描述"></p> 
<p>当客户端一，执行update语句，会为id为1的记录加排他锁； 客户端二，如果也执行update语句更<br> 新id为1的数据，也要为id为1的数据加排他锁，但是客户端二会处于阻塞状态，因为排他锁之间是互<br> 斥的。 直到客户端一，把事务提交了，才会把这一行的行锁释放，此时客户端二，解除阻塞。</p> 
<p>5.无索引行锁升级为表锁（不演示上面有例子）</p> 
<h4><a id="2_607"></a>2.间隙锁&amp;临键锁</h4> 
<p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜<br> 索和索引扫描，以<font color="red">防止幻读</font>。</p> 
<ul><li>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</li><li>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key<br> lock 退化为间隙锁。</li><li>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</li></ul> 
<p><font color="red">注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。<br> </font></p> 
<h5><a id="_617"></a>数据演示</h5> 
<ol><li>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</li></ol> 
<p><img src="https://images2.imgbox.com/d4/ef/Bcau3Aub_o.png" alt="在这里插入图片描述"><br> 2. 索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。</p> 
<p>介绍分析一下：<br> 我们知道InnoDB的B+树索引，叶子节点是有序的双向链表。 假如，我们要根据这个二级索引查询值为18的数据，并加上共享锁，我们是只锁定18这一行就可以了吗？ 并不是，因为是非唯一索引，这个结构中可能有多个18的存在，所以，在加锁时会继续往后找，找到一个不满足条件的值（当前案例中也就是29）。此时会对18加临键锁，并对29之前的间隙加锁。<br> <img src="https://images2.imgbox.com/e5/40/kzVXqjGV_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e3/e9/a0YxqVSR_o.png" alt="在这里插入图片描述"><br> 3.索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。<br> <img src="https://images2.imgbox.com/28/fa/92lDw1R8_o.png" alt="在这里插入图片描述"><br> 查询的条件为id&gt;=19，并添加共享锁。 此时我们可以根据数据库表中现有的数据，将数据分为三个部<br> 分：<br> [19]<br> (19,25]<br> (25,+∞]<br> 所以数据库数据在加锁是，就是将19加了行锁，25的临键锁（包含25及25之前的间隙），正无穷的临键锁(正无穷及之前的间隙)。</p> 
<hr> 
<h3><a id="_639"></a>总结</h3> 
<p><img src="https://images2.imgbox.com/c8/d9/TRl4UJOO_o.png" alt="请添加图片描述"></p> 
<h2><a id="InnoDB_645"></a>四.InnoDB引擎</h2> 
<h3><a id="1_646"></a>1.概述</h3> 
<p>InnoDB的逻辑存储结构如下图所示:<br> <img src="https://images2.imgbox.com/a7/5c/1yqYfEj5_o.png" alt="在这里插入图片描述"><br> 1). 表空间<br> 表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），<strong>一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。</strong><br> 2). 段<br> 段，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment），<strong>InnoDB是索引组织表</strong>，数据段就是B+树的叶子节点， 索引段即为B+树的非叶子节点。段用来管理多个Extent（区）。<br> 3). 区<br> 区，表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。<br> 4). 页<br> 页，是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。<br> 5). 行<br> 行，InnoDB 存储引擎数据是按行进行存放的。<br> 在行中，默认有两个隐藏字段：</p> 
<ul><li>Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。</li><li>Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul> 
<h3><a id="2MySQL_663"></a>2.MySQL的架构图</h3> 
<p>MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发<br> 中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。<br> <img src="https://images2.imgbox.com/ba/dd/4OgeRwsT_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="1_667"></a>1.内存结构</h4> 
<p><img src="https://images2.imgbox.com/ed/0e/16CRYZmv_o.png" alt="在这里插入图片描述"><br> 1). Buffer Pool<br> InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能<br> 弥补这两者之间的I/O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁<br> 盘I/O。在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及InnoDB的锁信息等等。缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。<br> 缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：<br> <strong>• free page：空闲page，未被使用。<br> • clean page：被使用page，数据没有被修改过。<br> • dirty page：脏页，被使用page，数据被修改过，也中数据与磁盘的数据产生了不一致。</strong></p> 
<p>2). Change Buffer<br> Change Buffer，更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page<br> 没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer<br> 中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。<br> Change Buffer的意义是什么呢?<br> 先来看一幅图，这个是二级索引的结构图：<br> <img src="https://images2.imgbox.com/67/3d/DlbpkVNx_o.png" alt="在这里插入图片描述"><br> 与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了<br> ChangeBuffer之后，我们可以在缓冲池中进行合并处理，<strong>减少磁盘IO</strong>。</p> 
<p>3). Adaptive Hash Index<br> 自适应hash索引，用于优化对Buffer Pool数据的查询。MySQL的innoDB引擎中虽然没有直接支持<br> hash索引，但是给我们提供了一个功能就是这个自适应hash索引。因为前面我们讲到过，hash索引在进行等值匹配时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。<br> InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。<br> <strong>自适应哈希索引，无需人工干预，是系统根据情况自动完成。</strong><br> <img src="https://images2.imgbox.com/d7/91/0eNp1QEl_o.png" alt="在这里插入图片描述"><br> 4). Log Buffer<br> Log Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log 、undo log），<br> 默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事<br> 务，增加日志缓冲区的大小可以节省磁盘 I/O。<br> 参数:<br> <strong>innodb_log_buffer_size：缓冲区大小</strong><br> <strong>innodb_flush_log_at_trx_commit：日志刷新到磁盘时机，取值主要包含以下三个：</strong><br> 1: 日志在每次事务提交时写入并刷新到磁盘，默认值。<br> 0: 每秒将日志写入并刷新到磁盘一次。<br> 2: 日志在每次事务提交后写入，并每秒刷新到磁盘一次。<br> <img src="https://images2.imgbox.com/7e/90/GNReudLU_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_705"></a>2.磁盘结构</h4> 
<p><img src="https://images2.imgbox.com/ab/4f/fQypimbq_o.png" alt="在这里插入图片描述"><br> 1). System Tablespace<br> 系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建<br> 的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等)<br> 参数：innodb_data_file_path<br> <img src="https://images2.imgbox.com/fe/aa/muWW7g0J_o.png" alt="在这里插入图片描述"><br> 系统表空间，默认的文件名叫 ibdata1。</p> 
<p>2). File-Per-Table Tablespaces<br> 如果开启了innodb_file_per_table开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索<br> 引 ，并存储在文件系统上的单个数据文件中。<br> 开关参数：innodb_file_per_table ，该参数默认开启。<br> <img src="https://images2.imgbox.com/2e/0e/65Tc4rRY_o.png" alt="在这里插入图片描述"><br> 那也就是说，我们没创建一个表，都会产生一个表空间文件，如图：<br> <img src="https://images2.imgbox.com/57/8f/yYpWsbcD_o.png" alt="在这里插入图片描述"><br> 3). General Tablespaces<br> 通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空<br> 间。<br> <strong>A. 创建表空间</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLESPACE</span> ts_name <span class="token keyword">ADD</span> DATAFILE <span class="token string">'file_name'</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> engine_name<span class="token punctuation">;</span>
</code></pre> 
<p>ts_name：表空间的名字<br> DATAFILE :数据文件的名字,以ibd结尾<br> ENGINE：存储引擎<br> eg:</p> 
<pre><code class="prism language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLESPACE</span> tablespaceTest <span class="token keyword">ADD</span> DATAFILE <span class="token string">'spaceTest.ibd'</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">innodb</span><span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/e5/a2/yOv6oCwb_o.png" alt="在这里插入图片描述"><br> <strong>B. 创建表时指定表空间</strong></p> 
<pre><code class="prism language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> xxx <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">TABLESPACE</span> ts_name<span class="token punctuation">;</span>
</code></pre> 
<p>4). Undo Tablespaces<br> 撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储undo log日志。<br> 5). Temporary Tablespaces<br> InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。<br> 6). Doublewrite Buffer Files<br> 双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件<br> 中，便于系统异常时恢复数据。<br> <img src="https://images2.imgbox.com/4b/b8/tEnRX1uK_o.png" alt="在这里插入图片描述"><br> 7). Redo Log<br> <strong>重做日志，是用来实现事务的持久性。</strong> 该日志文件由两部分组成：重做日志缓冲（redo log<br> buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所<br> 有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用。<br> 以循环方式写入重做日志文件，涉及两个文件：<br> <img src="https://images2.imgbox.com/0f/9a/eBNn8uRi_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p><img src="https://images2.imgbox.com/05/37/NL81HpRS_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3_760"></a>3.后台线程</h4> 
<p><img src="https://images2.imgbox.com/14/3c/36u6n1cr_o.png" alt="在这里插入图片描述"><br> 在InnoDB的后台线程中，分为4类，分别是：<strong>Master Thread 、IO Thread、Purge Thread、<br> Page Cleaner Thread。</strong><br> 1). Master Thread<br> 核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收 。</p> 
<p>2). IO Thread<br> 在InnoDB存储引擎中大量使用了AIO来处理IO请求, 这样可以极大地提高数据库的性能，而IO<br> Thread主要负责这些IO请求的回调。<br> <img src="https://images2.imgbox.com/80/13/vTTQNpfs_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-sql"> <span class="token keyword">show</span> <span class="token keyword">engine</span> <span class="token keyword">innodb</span> <span class="token keyword">status</span> \G<span class="token punctuation">;</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/f5/14/ZuPx8Nnq_o.png" alt="在这里插入图片描述"></p> 
<p>3). Purge Thread<br> 主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回<br> 收。</p> 
<p>4). Page Cleaner Thread<br> 协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻<br> 塞。</p> 
<h2><a id="_786"></a>五.事务原理</h2> 
<h3><a id="1_787"></a>1.事务基础</h3> 
<p>1). 事务<br> 事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系<br> 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。<br> 2). 特性<br> • 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。<br> • 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。<br> • 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环<br> 境下运行。<br> • 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。<br> 那实际上，我们研究事务的原理，就是研究MySQL的InnoDB引擎是如何保证事务的这四大特性的。<br> <img src="https://images2.imgbox.com/ad/bd/rzg5JjCA_o.png" alt="在这里插入图片描述"><br> <strong>而对于这四大特性，实际上分为两个部分。 其中的原子性、一致性、持久性，实际上是由InnoDB中的两份日志来保证的，一份是redo log日志，一份是undo log日志。 而隔离性是通过数据库的锁，<br> 加上MVCC来保证的。</strong></p> 
<p><img src="https://images2.imgbox.com/ad/33/e57EKpYE_o.png" alt="在这里插入图片描述"><br> 我们在讲解事务原理的时候，主要就是来研究一下redolog，undolog以及MVCC。</p> 
<h3><a id="2redo_log_805"></a>2.redo log</h3> 
<p><img src="https://images2.imgbox.com/8d/11/hPxgUJ0b_o.png" alt="在这里插入图片描述"></p> 
<p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。</p> 
<p>该日志文件由两部分组成：**重做日志缓冲（redo log buffer）以及重做日志文件（redo log<br> file）,前者是在内存中，后者在磁盘中。**当事务提交之后会把所有修改信息都存到该日志文件中, 用<br> 于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。</p> 
<p>如果没有redolog，可能会存在什么问题的？ 我们一起来分析一下</p> 
<p>我们知道，在InnoDB引擎中的内存结构中，主要的内存区域就是缓冲池，在缓冲池中缓存了很多的数<br> 据页。 当我们在一个事务中，执行多个增删改的操作时，InnoDB引擎会先操作缓冲池中的数据，如果缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中，然后将缓冲池中的数据修改，修改后的数据页我们称为<strong>脏页</strong>。 而脏页则会在一定的时机，通过后台线程刷新到磁盘中，从而保证缓冲区与磁盘的数据一致。 而缓冲区的脏页数据并不是实时刷新的，而是一段时间之后将缓冲区的数据刷新到磁盘中，假如刷新到磁盘的过程出错了，而提示给用户事务提交成功，而数据却没有持久化下来，这就出现问题了，没有保证事务的持久性。<br> <img src="https://images2.imgbox.com/f1/9d/zdEPIWga_o.png" alt="在这里插入图片描述"><br> 那么，如何解决上述的问题呢？ 在InnoDB中提供了一份日志 redo log，接下来我们再来分析一<br> 下，通过redolog如何解决这个问题。<br> <img src="https://images2.imgbox.com/e5/56/EvPG1E67_o.png" alt="在这里插入图片描述"><br> 有了redolog之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redo<br> log buffer中。在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中。</p> 
<p>过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据<br> 恢复，这样就保证了事务的持久性。 而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此<br> 时redolog就没有作用了，就可以删除了，所以存在的两个redolog文件是循环写的。</p> 
<p><strong>那为什么每一次提交事务，要刷新redo log 到磁盘中呢，而不是直接将buffer pool中的脏页刷新<br> 到磁盘呢 ?</strong></p> 
<p>因为在业务操作中，我们操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 而redo log在<br> 往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 这<br> 种先写日志的方式，称之为 WAL（Write-Ahead Logging）。</p> 
<h3><a id="2undo_log_836"></a>2.undo log</h3> 
<p><img src="https://images2.imgbox.com/20/3f/HPhS6DX4_o.png" alt="在这里插入图片描述"></p> 
<p>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : <strong>提供回滚(保证事务的原子性) 和<br> MVCC(多版本并发控制) 。</strong></p> 
<p>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo<br> log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的<br> update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p> 
<p>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些<br> 日志可能还用于MVCC。<br> Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment<br> 回滚段中，内部包含1024个undo log segment。</p> 
<h3><a id="3MVCC_850"></a>3.MVCC</h3> 
<p>1). 当前读<br> 读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加<br> 锁。对于我们日常的操作，如：select … lock in share mode(共享锁)，select …<br> for update、update、insert、delete(排他锁)都是一种当前读。<br> <img src="https://images2.imgbox.com/03/72/56E65kOi_o.png" alt="在这里插入图片描述"><br> 在测试中我们可以看到，即使是在默认的RR隔离级别下，事务A中依然可以读取到事务B最新提交的内容，因为在查询语句后面加上了 lock in share mode 共享锁，此时是当前读操作。当然，当我们<br> 加排他锁的时候，也是当前读操作。</p> 
<p>2). 快照读<br> 简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，<br> 不加锁，是非阻塞读。<br> • Read Committed：每次select，都生成一个快照读。<br> <strong>• Repeatable Read：开启事务后第一个select语句才是快照读的地方。</strong><br> • Serializable：快照读会退化为当前读。<br> <img src="https://images2.imgbox.com/bc/30/WDklOOR0_o.png" alt="在这里插入图片描述"></p> 
<p>在测试中,我们看到即使事务B提交了数据,事务A中也查询不到。 原因就是因为普通的select是快照<br> 读，而在当前默认的RR隔离级别下，开启事务后第一个select语句才是快照读的地方，后面执行相同<br> 的select语句都是从快照中获取数据，可能不是当前的最新数据，这样也就保证了可重复读。、</p> 
<p>3). MVCC<br> 全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，<br> 使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的<strong>三个隐式字段、undo log日志、readView。</strong></p> 
<h4><a id="1_875"></a>1.隐藏字段</h4> 
<p><img src="https://images2.imgbox.com/da/64/vKj5VUN6_o.png" alt="在这里插入图片描述"><br> 而上述的前两个字段是肯定会添加的， 是否添加最后一个字段DB_ROW_ID，得看当前表有没有主键，如果有主键，则不会添加该隐藏字段。</p> 
<h5><a id="_879"></a>数据演示</h5> 
<p>1). 查看有主键的表 stu<br> 进入服务器中的 /var/lib/mysql/或则windows系统中的data目录, 查看stu的表结构信息, 通过如下指令:</p> 
<pre><code class="prism language-sql">ibd2sdi stu<span class="token punctuation">.</span>ibd
</code></pre> 
<p>上面是linux里面的命令</p> 
<pre><code class="prism language-sql">ibd2sdi<span class="token punctuation">.</span>exe <span class="token string">"C:\ProgramData\MySQL\MySQL Server 8.0\Data\ts\stu.ibd"</span>
</code></pre> 
<p>上面是windows里面的命令需要先找到ibd2sdi.exe的目录位置<br> <img src="https://images2.imgbox.com/16/09/3h7PsUQm_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/c4/b7/qXkSUZRG_o.png" alt="在这里插入图片描述"></p> 
<p>查看到的表结构信息中，有一栏 columns，在其中我们会看到处理我们建表时指定的字段以外，还有<br> 额外的两个字段 分别是：<strong>DB_TRX_ID 、 DB_ROLL_PTR</strong> ，因为该表有主键，所以没有<strong>DB_ROW_ID</strong>隐藏字段。</p> 
<p>2). 查看没有主键的表 employee<br> 查看到的表结构信息中，有一栏 columns，在其中我们会看到处理我们建表时指定的字段以外，还有<br> 额外的三个字段 分别是：<strong>DB_TRX_ID 、 DB_ROLL_PTR 、DB_ROW_ID，因为employee表是没有指定主键的。</strong></p> 
<p><img src="https://images2.imgbox.com/8f/2b/7lyQz7EG_o.png" alt="在这里插入图片描述"><br> 查看到的表结构信息中，有一栏 columns，在其中我们会看到处理我们建表时指定的字段以外，还有<br> 额外的三个字段 分别是：DB_TRX_ID 、 DB_ROLL_PTR 、DB_ROW_ID，因为employee表是没有<br> 指定主键的。</p> 
<h4><a id="2undolog_906"></a>2.undolog版本链</h4> 
<h5><a id="1_907"></a>1.介绍</h5> 
<p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。<br> 当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。<br> 而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即<br> 被删除。</p> 
<h5><a id="2_912"></a>2.版本链</h5> 
<p><img src="https://images2.imgbox.com/ef/f3/uEQM4J7d_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-sql">DB_TRX_ID : 代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是
自增的。
DB_ROLL_PTR ： 由于这条数据是才插入的，没有被更新过，所以该字段值为<span class="token boolean">null</span>。

</code></pre> 
<p>然后，有四个并发事务同时在访问这张表。<br> <img src="https://images2.imgbox.com/2e/2b/u75xzV04_o.png" alt="在这里插入图片描述"><br> 当事务2执行第一条修改语句时，会记录undo log日志，记录数据变更之前的样子; 然后更新记录，<br> 并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。<br> <img src="https://images2.imgbox.com/b3/f5/YNK1Lu8E_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/9d/7a/BZaWsfKZ_o.png" alt="在这里插入图片描述"><br> 当事务3执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记<br> 录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。<br> <img src="https://images2.imgbox.com/22/0b/LM8LGv6v_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a9/12/tuRzM3tX_o.png" alt="在这里插入图片描述"><br> 当事务4执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记<br> 录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。<br> <img src="https://images2.imgbox.com/b4/b9/00q29399_o.png" alt="在这里插入图片描述"><br> <font color="red">最终我们发现，不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</font></p> 
<h5><a id="3readview_936"></a>3.readview</h5> 
<p>ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务<br> （未提交的）id。<br> ReadView中包含了四个核心字段：<br> <img src="https://images2.imgbox.com/f2/2b/DJC7RfHa_o.png" alt="在这里插入图片描述"><br> 而在readview中就规定了版本链数据的访问规则：<br> trx_id 代表当前undolog版本链对应事务ID。<br> <img src="https://images2.imgbox.com/49/1e/vGel3BcS_o.png" alt="在这里插入图片描述"><br> 不同的隔离级别，生成ReadView的时机不同：</p> 
<ul><li>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。</li><li>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</li></ul> 
<h5><a id="4_947"></a>4.原理分析</h5> 
<h6><a id="1RC_948"></a>1.RC隔离级别</h6> 
<p>RC隔离级别下，在事务中每一次执行快照读时生成ReadView。<br> 我们就来分析事务5中，两次快照读读取数据，是如何获取数据的?<br> 在事务5中，查询了两次id为30的记录，由于隔离级别为Read Committed，所以每一次进行快照读<br> 都会生成一个ReadView，那么两次生成的ReadView如下。<br> <img src="https://images2.imgbox.com/dd/4d/4c5mxmgb_o.png" alt="在这里插入图片描述"><br> 那么这两次快照读在获取数据时，就需要根据所生成的ReadView以及ReadView的版本链访问规则，<br> 到undolog版本链中匹配数据，最终决定此次快照读返回的数据。<br> <img src="https://images2.imgbox.com/3f/6b/wO1fEmeJ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/f0/18/tHCBXkYX_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="2RR_958"></a>2.RR隔离级别</h6> 
<p>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。 而RR 是可重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。<br> 那MySQL是如何做到可重复读的呢?<br> <img src="https://images2.imgbox.com/04/bd/6SR9JjLy_o.png" alt="在这里插入图片描述"></p> 
<p><font color="red">所以呢，MVCC的实现原理就是通过 InnoDB表的隐藏字段、UndoLog 版本链、ReadView来实现的。<br> 而MVCC + 锁，则实现了事务的隔离性。 而一致性则是由redolog 与 undolog保证。</font></p> 
<p><img src="https://images2.imgbox.com/82/4d/vuJD7tB9_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="5_967"></a>5.事务总结</h3> 
<p><strong>原子性:</strong> undo log。<br> <strong>一致性:</strong> undo log、redo log。<br> <strong>持久性:</strong> redo log。<br> <strong>隔离性:</strong> MVCC+锁。</p> 
<hr> 
<p><strong>undo log和 redo log的区别</strong><br> redo log记录的是数据页的物理变化，服务宕机可用来同步数据，而undo log不同，它主要记录的是逻辑日志，当事务回滚时，通过逆操作回复原来的数据，比如我们删除一条数据的时候，就会在undo log日志文件中新增一条delete语句，如果发生回滚就执行逆操作；</p> 
<p>redo log保证了事物的持久性,undo log保证了事物的原子性和一致性。</p> 
<hr> 
<p><strong>事务中的隔离性如何保证的呢?</strong></p> 
<p>锁:排他锁(如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁)<br> mvcc:多版本并发控制。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7e76f7547ec260e42dd73ee7e17c5cec/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL-基本使用，数据类型，简单操作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dfe95b36429ca88dcc7747dbdc5c7895/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">将yolov8权重文件转为onnx格式并在c#中使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>