<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>软件设计师提纲&#43;复习资料整理（上午题） - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="软件设计师提纲&#43;复习资料整理（上午题）" />
<meta property="og:description" content="文章目录 软件设计师考试大纲上午题（选择题）一、计算机组成原理考点：CPU结构组成考点：原码、反码、补码定点整数范围考点：浮点数表示考点：RISC和CISC计算机的区别考点：奇校验与偶校验考点：寻址方式考点：RAM、ROM、FLASH（闪存）考点：CPI与MIPS考点：流水线吞吐率计算考点：指令周期、机器周期、时钟周期 二、操作系统考点：中断方式考点：DMA考点：位示图考点：进程资源图考点：分页（物理地址计算）考点：信号量考点：多级索引结构 三、计算机网络考点：TCP/IP五层模型中各个协议内容（高频）考点：HTTP一次请求的过程考点：A类、B类、C类网络考点：几种常见命令及功能 四、网络信息安全考点：几种常见攻击方式考点：对称加密与非对称加密考点：计算机病毒的特性 五、法律方面考点：保护期限考点：知识产权人确定考点：侵权判定 六、软件工程考点：软件设计各个阶段考点：项目的活动图考点：进程前驱图考点：软件模型考点：模块的耦合类型考点：模块的内聚类型考点：白盒测试（路径覆盖与语句覆盖）考点：面向对象分析考点：类的设计原则考点：设计模式考点：ISO/IEC 9126软件质量模型考点：类的划分考点：UML类图考点：MTTF、MTTR、MTBF考点：V模型考点：嵌入式操作系统的特点考点：软件维护的特点考点：分布式数据库特点 七、程序语言基础考点：词法、语法、语义分析考点：调用函数，采用传值方式和传引用方式区别考点：编译与解释考点：有限自动机考点：并行系统与串行系统可靠度计算考点：算数表达式 八、数据结构考点：树考点：图的存储（邻接矩阵、邻接表）考点：广度优先与深度优先遍历考点：排序算法（复杂度）考点：算法设计策略 九、数据库考点：确定候选码考点：部分依赖、完全依赖、传递依赖考点：关系代数表达式考点：1NF、2NF、3NF考点：共享锁与排他锁考点：外连接考点：数据流图考点：外模式、模式和内模式 软件设计师考试大纲 考试科目
计算机与软件工程知识，考试时间为150分钟，笔试，选择题；软件设计，考试时间为150分钟，笔试，问答题。 考试范围
软件工程知识
计算机科学基础知识
1.1数制及其转换
◇ 二进制、八进制、十进制和十六进制等常用数制及其相互转换
1.2 计算机内数据的表示
◇ 数的表示（补码表示，整数和实数的表示，精度和溢出）
◇ 非数值表示（字符和汉字表示，声音表示、图像表示）
1.3算术运算和逻辑运算
◇ 计算机中的二进制数运算方法
◇ 逻辑代数的基本运算
1.4其他数学基础知识
◇ 常用数值计算
◇ 排列组合，概率论应用，应用统计（数据的统计分析）
◇编码基础
◇ 命题逻辑、谓词逻辑、形式逻辑的基础知识
◇ 运筹基本方法
计算机系统知识
2.1计算机硬件基础知识
2.1.1计算机系统的组成、体系结构分类及特性
◇ CPU、存储器的组成、性能和基本工作原理
◇ 常用I/O设备、通信设备的性能以及基本工作原理
◇ I/O接口的功能、类型和特性
◇ CISC/RISC，流水线操作，多处理机，并行处理
2.1.2存储系统
◇ 虚拟存储器基本工作原理，多级存储体系
◇ RAID类型和特性
2.1.3可靠性与系统性能评测基础知识
◇ 诊断与容错
◇ 系统可靠性分析评价
◇ 计算机系统性能评测方法
2.2计算机软件知识
2.2.1数据结构与算法知识
◇ 数组
◇ 链表" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/a35ab7201f5f03c869dac1412adf3ae6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-27T23:20:18+08:00" />
<meta property="article:modified_time" content="2022-05-27T23:20:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">软件设计师提纲&#43;复习资料整理（上午题）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_6" rel="nofollow">软件设计师考试大纲</a></li><li><a href="#_224" rel="nofollow">上午题（选择题）</a></li><li><a href="#_225" rel="nofollow">一、计算机组成原理</a></li><li><ul><li><a href="#CPU_230" rel="nofollow">考点：CPU结构组成</a></li><li><a href="#_254" rel="nofollow">考点：原码、反码、补码定点整数范围</a></li><li><a href="#_257" rel="nofollow">考点：浮点数表示</a></li><li><a href="#RISCCISC_274" rel="nofollow">考点：RISC和CISC计算机的区别</a></li><li><a href="#_282" rel="nofollow">考点：奇校验与偶校验</a></li><li><a href="#_289" rel="nofollow">考点：寻址方式</a></li><li><a href="#RAMROMFLASH_299" rel="nofollow">考点：RAM、ROM、FLASH（闪存）</a></li><li><a href="#CPIMIPS_313" rel="nofollow">考点：CPI与MIPS</a></li><li><a href="#_326" rel="nofollow">考点：流水线吞吐率计算</a></li><li><a href="#_330" rel="nofollow">考点：指令周期、机器周期、时钟周期</a></li></ul> 
  </li><li><a href="#_343" rel="nofollow">二、操作系统</a></li><li><ul><li><a href="#_345" rel="nofollow">考点：中断方式</a></li><li><a href="#DMA_351" rel="nofollow">考点：DMA</a></li><li><a href="#_359" rel="nofollow">考点：位示图</a></li><li><a href="#_371" rel="nofollow">考点：进程资源图</a></li><li><a href="#_391" rel="nofollow">考点：分页（物理地址计算）</a></li><li><a href="#_403" rel="nofollow">考点：信号量</a></li><li><a href="#_409" rel="nofollow">考点：多级索引结构</a></li></ul> 
  </li><li><a href="#_423" rel="nofollow">三、计算机网络</a></li><li><ul><li><a href="#TCPIP_424" rel="nofollow">考点：TCP/IP五层模型中各个协议内容（高频）</a></li><li><a href="#HTTP_444" rel="nofollow">考点：HTTP一次请求的过程</a></li><li><a href="#ABC_454" rel="nofollow">考点：A类、B类、C类网络</a></li><li><a href="#_472" rel="nofollow">考点：几种常见命令及功能</a></li></ul> 
  </li><li><a href="#_487" rel="nofollow">四、网络信息安全</a></li><li><ul><li><a href="#_488" rel="nofollow">考点：几种常见攻击方式</a></li><li><a href="#_498" rel="nofollow">考点：对称加密与非对称加密</a></li><li><a href="#_506" rel="nofollow">考点：计算机病毒的特性</a></li></ul> 
  </li><li><a href="#_509" rel="nofollow">五、法律方面</a></li><li><ul><li><a href="#_510" rel="nofollow">考点：保护期限</a></li><li><a href="#_512" rel="nofollow">考点：知识产权人确定</a></li><li><a href="#_516" rel="nofollow">考点：侵权判定</a></li></ul> 
  </li><li><a href="#_538" rel="nofollow">六、软件工程</a></li><li><ul><li><a href="#_539" rel="nofollow">考点：软件设计各个阶段</a></li><li><a href="#_548" rel="nofollow">考点：项目的活动图</a></li><li><a href="#_563" rel="nofollow">考点：进程前驱图</a></li><li><a href="#_571" rel="nofollow">考点：软件模型</a></li><li><a href="#_583" rel="nofollow">考点：模块的耦合类型</a></li><li><a href="#_596" rel="nofollow">考点：模块的内聚类型</a></li><li><a href="#_609" rel="nofollow">考点：白盒测试（路径覆盖与语句覆盖）</a></li><li><a href="#_622" rel="nofollow">考点：面向对象分析</a></li><li><a href="#_625" rel="nofollow">考点：类的设计原则</a></li><li><a href="#_637" rel="nofollow">考点：设计模式</a></li><li><a href="#ISOIEC_9126_654" rel="nofollow">考点：ISO/IEC 9126软件质量模型</a></li><li><a href="#_661" rel="nofollow">考点：类的划分</a></li><li><a href="#UML_669" rel="nofollow">考点：UML类图</a></li><li><a href="#MTTFMTTRMTBF_726" rel="nofollow">考点：MTTF、MTTR、MTBF</a></li><li><a href="#V_735" rel="nofollow">考点：V模型</a></li><li><a href="#_749" rel="nofollow">考点：嵌入式操作系统的特点</a></li><li><a href="#_756" rel="nofollow">考点：软件维护的特点</a></li><li><a href="#_762" rel="nofollow">考点：分布式数据库特点</a></li></ul> 
  </li><li><a href="#_771" rel="nofollow">七、程序语言基础</a></li><li><ul><li><a href="#_772" rel="nofollow">考点：词法、语法、语义分析</a></li><li><a href="#_781" rel="nofollow">考点：调用函数，采用传值方式和传引用方式区别</a></li><li><a href="#_793" rel="nofollow">考点：编译与解释</a></li><li><a href="#_798" rel="nofollow">考点：有限自动机</a></li><li><a href="#_809" rel="nofollow">考点：并行系统与串行系统可靠度计算</a></li><li><a href="#_813" rel="nofollow">考点：算数表达式</a></li></ul> 
  </li><li><a href="#_826" rel="nofollow">八、数据结构</a></li><li><ul><li><a href="#_827" rel="nofollow">考点：树</a></li><li><a href="#_841" rel="nofollow">考点：图的存储（邻接矩阵、邻接表）</a></li><li><a href="#_857" rel="nofollow">考点：广度优先与深度优先遍历</a></li><li><a href="#_873" rel="nofollow">考点：排序算法（复杂度）</a></li><li><a href="#_877" rel="nofollow">考点：算法设计策略</a></li></ul> 
  </li><li><a href="#_885" rel="nofollow">九、数据库</a></li><li><ul><li><a href="#_888" rel="nofollow">考点：确定候选码</a></li><li><a href="#_896" rel="nofollow">考点：部分依赖、完全依赖、传递依赖</a></li><li><a href="#_916" rel="nofollow">考点：关系代数表达式</a></li><li><a href="#1NF2NF3NF_951" rel="nofollow">考点：1NF、2NF、3NF</a></li><li><a href="#_966" rel="nofollow">考点：共享锁与排他锁</a></li><li><a href="#_971" rel="nofollow">考点：外连接</a></li><li><a href="#_977" rel="nofollow">考点：数据流图</a></li><li><a href="#_989" rel="nofollow">考点：外模式、模式和内模式</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_6"></a>软件设计师考试大纲</h2> 
<p><strong>考试科目</strong></p> 
<ol><li>计算机与软件工程知识，考试时间为150分钟，笔试，选择题；</li><li>软件设计，考试时间为150分钟，笔试，问答题。</li></ol> 
<p><strong>考试范围</strong><br> 软件工程知识</p> 
<ol><li>计算机科学基础知识<br> 1.1数制及其转换<br> ◇ 二进制、八进制、十进制和十六进制等常用数制及其相互转换<br> 1.2 计算机内数据的表示<br> ◇ 数的表示（补码表示，整数和实数的表示，精度和溢出）<br> ◇ 非数值表示（字符和汉字表示，声音表示、图像表示）<br> 1.3算术运算和逻辑运算<br> ◇ 计算机中的二进制数运算方法<br> ◇ 逻辑代数的基本运算<br> 1.4其他数学基础知识<br> ◇ 常用数值计算<br> ◇ 排列组合，概率论应用，应用统计（数据的统计分析）<br> ◇编码基础<br> ◇ 命题逻辑、谓词逻辑、形式逻辑的基础知识<br> ◇ 运筹基本方法<br> 计算机系统知识<br> 2.1计算机硬件基础知识<br> 2.1.1计算机系统的组成、体系结构分类及特性<br> ◇ CPU、存储器的组成、性能和基本工作原理<br> ◇ 常用I/O设备、通信设备的性能以及基本工作原理<br> ◇ I/O接口的功能、类型和特性<br> ◇ CISC/RISC，流水线操作，多处理机，并行处理<br> 2.1.2存储系统<br> ◇ 虚拟存储器基本工作原理，多级存储体系<br> ◇ RAID类型和特性<br> 2.1.3可靠性与系统性能评测基础知识<br> ◇ 诊断与容错<br> ◇ 系统可靠性分析评价<br> ◇ 计算机系统性能评测方法<br> 2.2计算机软件知识<br> 2.2.1数据结构与算法知识<br> ◇ 数组<br> ◇ 链表<br> ◇ 队列、栈<br> ◇ 树<br> ◇ 图的定义、存储和基本操作<br> ◇ 杂凑（Hash表）<br> ◇ 常用的排序算法、查找算法、数值计算、字符串处理、数据压缩算法、递归算法、图的相关算法<br> ◇ 算法描述和分析<br> 2.2.2 操作系统知识<br> ◇操作系统的内核<br> ◇ 处理机管理<br> ◇ 存储管理<br> ◇ 设备管理<br> ◇ 文件管理<br> ◇ 作业管理<br> ◇ 网络操作系统和嵌入式操作系统基础知识<br> ◇ 操作系统的配置<br> 2.2.3程序设计语言和语言处理程序知识<br> ◇ 汇编、编译、解释系统的基础知识和基本工作原理<br> ◇ 程序设计语言的基本成分（数据、运算、控制和传输），程序调用的实现机制<br> ◇ 各类程序设计语言的主要特点和适用情况<br> 2.2.4 数据库知识<br> ◇ 数据库模型（概念模式、外模式、内模式）<br> ◇ 数据模型，ER图，规范化<br> ◇ 数据操作<br> ◇ 数据库语言<br> ◇ 数据库管理系统的功能和特征<br> ◇ 数据库的控制功能<br> ◇ 数据仓库和分布式数据库基础知识<br> 2.3 计算机网络知识<br> ◇网络体系结构<br> ◇传输介质，传输技术，传输方法，传输控制<br> ◇常用网络设备和各类通信设备的特点<br> ◇Client-Server结构，Browser-Server结构<br> ◇LAN（拓扑，存取控制，组网，网间互连）<br> ◇Internet 和Intranet 基础知识以及应用<br> ◇网络软件<br> ◇网络管理，网络性能分析<br> 2.4 多媒体基础知识<br> ◇ 多媒体系统基础知识<br> ◇ 简单图形的绘制，图像文件的处理方法<br> ◇ 音频和视频信息的应用<br> ◇ 多媒体应用开发过程<br> 系统开发和运行<br> 3.1软件工程知识<br> ◇ 软件生存周期与软件生存周期模型<br> ◇ 软件开发方法<br> ◇ 软件开发项目管理<br> ◇ 软件开发工具与软件开发环境<br> 3.2 系统分析基础知识<br> ◇ 系统分析的主要步骤<br> ◇ 机构化分析方法<br> 3.3 系统设计基础知识<br> ◇ 概要设计与详细设计的基本任务<br> ◇ 系统设计的基本原理<br> ◇ 系统模块结构设计<br> ◇ 结构化设计方法<br> ◇ 面向数据结构的设计方法<br> ◇ 系统详细设计<br> 3.4 系统实施基础知识<br> ◇ 系统实施的基本内容<br> ◇ 程序设计方法<br> ◇ 程序设计的基本模块<br> ◇ 系统测试<br> ◇ 系统转换<br> 3.5 系统运行和维护基础知识<br> ◇ 系统可维护性的概念<br> ◇ 系统维护的类型<br> ◇ 系统评价的概念和类型<br> 3.6 软件质量管理基础知识<br> ◇ 软件质量特性（ISO/IEC 9126软件质量模型）<br> ◇ 软件质量保证<br> ◇ 软件复杂性的概念及度量方法（McCabe度量法）<br> ◇ 软件评审（设计质量评审、程序质量评审）<br> ◇ 软件容错技术<br> 3.7 软件过程改进基础知识<br> ◇ 软件能力成熟度模型CMM<br> ◇ 统一过程（UP）与极限编程（XP）的基本概念<br> 面向对象<br> ◇ 面向对象的基本概念<br> ◇ 面向对象分析与设计知识<br> ◇ 分析模式与设计模式知识<br> ◇ 面向对象程序设计知识<br> ◇ 面向对象数据库、分布式对象基础知识<br> 信息安全知识<br> ◇ 信息系统安全基础知识<br> ◇ 信息系统安全管理<br> ◇ 保障完整性与可用性的措施<br> ◇ 加密与解密机制基础知识<br> ◇ 风险管理（风险分析、风险类型、抗风险措施和内部控制）<br> ◇ 计算机安全相关的法律、法规基础知识<br> 标准化基础知识<br> ◇ 标准化意识，标准化组织机构，标准的内容、分类、代号与编号规定，标准制订过程<br> ◇ 国际标准、国家标准、行业标准、企业标准<br> ◇ 代码标准、文件格式标准、安全标准、互联网相关标准、软件开发规范和文档标准、基于构件的软件标准<br> 6.2 信息化基础知识<br> ◇ 全球信息化趋势、国家信息化战略、企业信息化战略和策略<br> ◇ 互联网相关的法律、法规<br> ◇ 个人信息保护规则<br> ◇远程教育、电子商务、电子政务等基础知识<br> ◇ 企业信息资源管理基础知识<br> 6.3知识产权基础知识<br> ◇ 保护知识产权有关的法律、法规<br> 计算机专业英语<br> ◇ 具有工程师所要求的英语阅读水平<br> ◇ 理解本领域的英语术语</li></ol> 
<p><strong>软件设计</strong><br> 外部设计<br> 1.1 理解系统需求说明<br> 1.2 准备进行系统开发<br> ◇ 选择开发方法、准备开发环境、制订开发计划<br> 1.3 设计系统功能<br> ◇ 选择系统结构<br> ◇ 设计各子系统的功能和接口<br> ◇ 设计安全性策略、需求和实现方法<br> ◇ 制订详细的工作流和数据流<br> 1.4 设计数据模型<br> ◇ 设计ER模型及其他数据模型<br> 1.5 编写外部设计文档<br> ◇ 系统配置图、各子系统关系图<br> ◇ 系统流程图、系统功能说明书<br> ◇ 输入输出规格说明、数据规格说明、用户手册框架<br> ◇ 设计系统测试要求<br> 1.6 外部设计的评审<br> 内部设计<br> 2.1 设计软件结构<br> ◇ 按构件分解，确定构件功能、规格以及构件之间的接口<br> ◇ 数据结构与算法设计<br> ◇ 采用中间件和工具<br> 2.2 设计输入输出<br> 2.3 设计物理数据<br> 2.4 构件的创建和重用<br> ◇ 创建构件、重用构件<br> ◇ 使用子程序库或类库<br> 2.5 编写内部设计文档<br> ◇ 构件划分图、构件间的接口、构件处理说明<br> ◇屏幕界面设计文档、报表设计文档、文件设计文档、数据库设计文档<br> 2.6 内部设计的评审<br> 数据库<br> ◇ 设计关系模式<br> ◇ 数据库语言（SQL）<br> ◇ 数据库访问<br> 程序设计<br> 4.1 模块划分<br> 4.2 编写程序设计文档<br> 4.3 程序设计评审<br> 5．系统实施<br> 5.1 配置计算机系统及环境<br> 5.2 选择合适的程序设计语言<br> 5.3 用C程序设计语言以及C++、Java中的任一种程序设计语言进行程序设计<br> 5.4 系统测试<br> ◇ 指导程序员进行模块测试，并进行验收<br> ◇ 准备系统集成测试环境和测试工具<br> ◇ 准备测试数据<br> ◇ 写出测试报告<br> 软件工程应用<br> 6.1 软件开发周期模型<br> 6.2 需求分析<br> 6.3 软件设计<br> ◇ 软件设计的基本原则<br> ◇ 软件设计方法<br> ◇ 程序设计（结构化程序设计、面向对象程序设计）<br> 6.4 软件测试的原则与方法<br> 6.5 软件质量（软件质量特性、软件质量控制）<br> 6.6 软件过程评估基本方法、软件能力成熟度评估基本方法<br> 6.7 软件开发环境和开发工具<br> 6.8 面向对象技术<br> ◇ 面向构件技术<br> ◇ 统一建模语言（UML）<br> ◇ 软件过程改进模型和方法<br> 6.9 网络环境软件技术<br> <font color="red">我针对这份大纲，结合往年的真题整理出了一些高频的考点，可供大家参考！</font></p> 
<hr> 
<p><code>软件设计师题目分为上午题和下午题，本章只整理上午题相关内容</code></p> 
<h2><a id="_224"></a>上午题（选择题）</h2> 
<h2><a id="_225"></a>一、计算机组成原理</h2> 
<p>计算机结构<br> <img src="https://images2.imgbox.com/05/d7/CRK3yhCd_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="CPU_230"></a>考点：CPU结构组成</h3> 
<p>（一）控制器<br> <strong>程序计数器PC</strong>：是用于存放下一条指令所在单元地址的地方，执行一条指令的时候，会将指令由内存取到（通过地址总线寻址）指令寄存器中，并且PC中的地址会自动加1</p> 
<p><strong>指令寄存器</strong>：临时放置从内存里面取得的程序指令的寄存器，用于存放<strong>当前</strong>从主存储器读出的正在执行的一条指令</p> 
<p><strong>地址寄存器</strong>：用来保存当前CPU所访问的内存单元的地址</p> 
<p><strong>指令译码器</strong>：从内存中取出的一条指令经数据总线送往指令寄存器中</p> 
<p>（二）运算器<br> <strong>通用寄存器</strong>：一般是指处理器最常使用的整数通用寄存器,可用于保存整数数据、地址等<br> <strong>状态寄存器</strong>：状态寄存器用来存放两类信息：一类是体现当前指令执行结果的各种状态信息（条件码），如有无进位（CF位）、有无溢出（OV位）、结果正负（SF位）、结果是否为零（ZF位）、奇偶标志位（P位）等；另一类是存放控制信息（PSW:程序状态字寄存器），如允许中断(IF位)、跟踪标志（TF位）等。<br> <strong>累加寄存器AC</strong>：通用寄存器，为ALU提供一个工作区，用在暂存数据<br> <img src="https://images2.imgbox.com/27/1c/R7pom1wl_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><strong>CPU控制器</strong>：控制整个CPU工作，它负责一次访问程序指令，进行指令译码，并协调其他设备</p> 
</blockquote> 
<blockquote> 
 <p><strong>CPU运算器</strong>：主要是用来进行数据运算加工的</p> 
</blockquote> 
<blockquote> 
 <p><strong>Cache(高速缓存)</strong>：是位于CPU和主存之间的一种存储器，速度高于主存，Cache保存的内容是CPU经常访问的数据，当CPU需要再次访问该部分数据时，就不用从主存中读取，节约了CPU的工作时间。Cache的内容是主存一部分内容的复本，当CPU访问主存时，访问的是主存的地址，因此需要采用一种“地址变换”的方式将主存地址“转换为”Cache地址，这种变换的方式是<strong>由计算机硬件自动完成</strong>的。</p> 
</blockquote> 
<h3><a id="_254"></a>考点：原码、反码、补码定点整数范围</h3> 
<p><img src="https://images2.imgbox.com/3f/9d/C3dqc0uD_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_257"></a>考点：浮点数表示</h3> 
<p>浮点数的表示：N = M*R^e<br> 其中，M为尾数，e是指数，R是基数<br> 它的组成部分：阶符、阶码、数符、尾数<br> <img src="https://images2.imgbox.com/58/30/i8oi8gw6_o.png" alt="在这里插入图片描述"><br> 阶码：常用补码或移码表示的定点整数（阶码的底一般为2）<br> 尾数：常用原码或补码表示的定点小数</p> 
<p>例题：若阶码以补码表示，尾数以原码表示，则100100000000001表示的浮点数是____。<br> <img src="https://images2.imgbox.com/32/39/cu167tnk_o.png" alt="在这里插入图片描述"><br> 按照题目给的位数，我们可以分别得出：<br> 阶符（1）：1表示该阶码是负数<br> 阶码（0001）：阶码是负数且以补码表示，所以阶码0001转换为原码为1111，是十进制的15<br> 数符（0）：表示尾数是正数<br> 尾数（0000000001）：尾数正的且以小数的表达形式是2^-10<br> <font color="red">因此该浮点数是2^-15 * 2^-10</font></p> 
<h3><a id="RISCCISC_274"></a>考点：RISC和CISC计算机的区别</h3> 
<table><thead><tr><th>指令系统类型</th><th>指令</th><th>寻址方式</th><th>实现方式</th><th>其他</th></tr></thead><tbody><tr><td>CISC（复杂指令集计算机）</td><td>数量多，使用频率差别大，可变长格式</td><td>支持多种</td><td>微程序控制技术</td><td></td></tr><tr><td>RISC（精简指令集计算机）</td><td>数量少，使用频率接近，定长格式，大部分为单周期指令，操作寄存器，只有Load/Store操作内存</td><td>支持方式少</td><td>增加了通用寄存器；硬布线逻辑控制为主，采用流水线</td><td>优化编译，有效支持高级语言</td></tr></tbody></table> 
<h3><a id="_282"></a>考点：奇校验与偶校验</h3> 
<p>奇校验：确保整个被传输的数据中“1”的个数是<strong>奇数个</strong>，如果数据序列中“1”的个数为奇数则填0，否则填“1”；</p> 
<p>偶校验：确保整个被传输的数据中“1”的个数是<strong>偶数个</strong>，如果数据序列中“1”的个数为偶数则填0，否则填“1”。</p> 
<p><strong>但是奇偶校验存在一个问题就是，只能检测错误但不能纠错。如果当多个数据位发生改变，那么奇(偶)校验位可能会出错，因为没有办法确定是哪一位出错，所以不能进行错误纠正。</strong></p> 
<h3><a id="_289"></a>考点：寻址方式</h3> 
<p>寻址方式是如何对指令中的地址字段进行解释，以获得操作数的方法或获得程序转移地址的方法。</p> 
<table><thead><tr><th>寻址方式</th><th>内容</th></tr></thead><tbody><tr><td>立即寻址</td><td>立即寻址的操作数就包含在指令中，取出指令时即可得到操作数，相较于直接寻址和寄存器寻址，立即寻址获取操作数的速度最快</td></tr><tr><td>直接寻址</td><td>直接寻址的操作数存放在内存单元中，指令中直接给出操作数所在存储单元的地址</td></tr><tr><td>寄存器寻址</td><td>寄存器寻址的操作数存放在寄存器中，指令中给出存放操作数的寄存器名，相较于直接寻址，在寄存器寻址方式中，指令在执行阶段不用访问主存，执行速度较快</td></tr></tbody></table> 
<p><strong>所以访问速度：立即寻址最快，寄存器寻址次之，直接寻址最慢</strong></p> 
<h3><a id="RAMROMFLASH_299"></a>考点：RAM、ROM、FLASH（闪存）</h3> 
<p><strong>（一）RAM</strong><br> <code>RAM</code> 随机存取存储器（英语：Random Access Memory，缩写：RAM），也叫主存，是与CPU直接交换数据的内部存储器。它可以随时读写（刷新时除外），而且速度很快，通常作为操作系统或其他正在运行中的程序的临时数据存储介质。RAM工作时可以随时从任何一个指定的地址写入（存入）或读出（取出）信息。它与ROM的最大区别是<strong>数据的易失性，即一旦断电所存储的数据将随之丢失</strong>。RAM在计算机和数字系统中用来暂时存储程序、数据和中间结果。</p> 
<p><code>SRAM</code> 是“static RAM(静态随机存储器)”的简称，之所以这样命名是因为当数据被存入其中后不会消失。</p> 
<p><code>DRAM</code> 动态随机存储器不同，DRAM <strong>必须在一定的时间内不停的刷新才能保持其中存储的数据</strong>。</p> 
<p><strong>（二）ROM</strong><br> <code>ROM</code> 只读存储器（Read-Only Memory，ROM），以非破坏性读出方式工作，只能读出无法写入信息。信息一旦写入后就固定下来，即使<strong>切断电源，信息也不会丢失</strong>，所以又称为固定存储器。</p> 
<p><strong>（三）FLASH（闪存）</strong><br> <code>FLASH</code>存储器又称闪存，它结合了ROM和RAM的长处，不仅具备电子可擦出可编程（EEPROM）的性能，还不会断电丢失数据同时可以快速读取数据 （NVRAM的优势），U盘和MP3里用的就是这种存储器。</p> 
<h3><a id="CPIMIPS_313"></a>考点：CPI与MIPS</h3> 
<ul><li>CPI（指令时钟周期数）是指CPU每执行一条指令所需的始终周期数。</li><li>MIPS（每秒百万级指令执行数量）单字长定点指令平均执行速度 Million Instructions PerSecond的缩写，每秒处理的百万级的机器语言指令数。这是衡量CPU速度的一个指标。</li></ul> 
<p><em>计算</em><br> 例题，某计算机系统的CPU主频为2.8GHz。某应用程序包括3类指令，各类指令的CPI（执行每条指令所需要的时钟周期数）及指令比例如下表所示。执行该应用程序时的平均CPI为（ ）；运算速度用MIPS表示，约为（ ）。<br> <img src="https://images2.imgbox.com/2f/a9/uMTh0uT4_o.png" alt="在这里插入图片描述"><br> <em>解析</em><br> <font color="red">平均CPI=4 * 35%+3 * 45%+6 * 20%=3.95≈4<br> CPU主频为2.8G，即CPU每秒可以产生2.8G=2.8*10^9个时钟信号；而通过上面我们知道每条指令平均需要4个时钟信号（即CPI=4），因此，每百万条指令需要 4 * 10 ^ 6个时钟信号；所以MIPS=（2.8 * 10^9）/（4 * 10^6）=700MIPS<br> </font></p> 
<h3><a id="_326"></a>考点：流水线吞吐率计算</h3> 
<p>n条指令耗时：一整条指令所需时间 +（指令条数-1）* 时间最长的指令的一段<br> 吞吐率 = 指令条数 / 一整条指令所需时间 +（指令条数-1）* 时间最长的指令的一段</p> 
<h3><a id="_330"></a>考点：指令周期、机器周期、时钟周期</h3> 
<blockquote> 
 <p>取出并执行一条指令所需要的时间称为<strong>指令周期</strong></p> 
</blockquote> 
<blockquote> 
 <p>完成一项基本操作（例如取指令、存储器读、存储器写）所需要的时间称为<strong>机器周期</strong></p> 
</blockquote> 
<blockquote> 
 <p>时钟脉冲的重复周期成为<strong>时钟周期</strong></p> 
</blockquote> 
<p>时钟周期也称为震荡周期，定义为时钟脉冲的倒数，是计算机中最基本，最小的时间单位。在一个时钟周期内，CPU仅完成一个最基本的动作。人们规定10纳秒为一个时钟周期，更小的时钟周期意味着更高的工作频率。计算机中执行指令的过程一般分为取指令，分析指令和执行指令的三个基本阶段。指令周期是执行一条指令所需要的时间，一般由若干个机器周期组成，是从取指令，分析指令到执行完所需的全部时间。指令不同，所需的机器周期数也不同，对于一些简单的单字节指令，在取指令周期中，指令取出到指令寄存器后，立即译码执行，不再需要其他的机器周期。对于一些比较复杂的指令，则需要两个或两个以上的机器周期。<br> <font color="red">总结：指令周期 &gt; 机器周期 &gt; 时钟周期</font></p> 
<h2><a id="_343"></a>二、操作系统</h2> 
<h3><a id="_345"></a>考点：中断方式</h3> 
<p>在中断方式下，当I/O系统与外设交换数据的时候，CPU可以处理其他任务，不需要等待整个过程完成，也就是说外设与CPU之间可以并行工作。中断方式完成数据输入输出的过程为：</p> 
<ol><li>I/O系统准备好以后，发出中断请求信号；</li><li>CPU收到信号，保存正在执行程序的现场，转入执行I/O中断服务程序，中断服务程序完成后，返回被打断的程序继续执行。可见，一次中断处理过程需要经历<strong>保存现场、中断处理、恢复现场。</strong></li></ol> 
<h3><a id="DMA_351"></a>考点：DMA</h3> 
<blockquote> 
 <p>概念：DMA方式也称为直接主存存取方式，其思想是：允许主存储器和I/O设备之间通过“DMA控制器”直接进行批量数据交换，除了在数据传输开始和结束时，整个过程无须CPU的干预</p> 
</blockquote> 
<p>特点</p> 
<ul><li>DMA传送方式是让存储器与外设、或外设与外设之间直接交换数据，<strong>不需要经过CPU的介入</strong></li><li>一个DMA传送只需要执行一个DMA周期，相当于一个总线读写周期</li></ul> 
<h3><a id="_359"></a>考点：位示图</h3> 
<p><img src="https://images2.imgbox.com/76/81/NuvaTIZt_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>位示图是利用二进制的一位来表示磁盘中的一个盘块的使用情况。当其值为“0”时，表示对应的盘块空闲；为“1”时，表示已经分配。有的系统把"0"作为盘块已分配的标记，把“1”作为空闲标志。(它们的本质上是相同的，都是用一位的两种状态标志空闲和已分配两种情况。)<strong>磁盘上的所有盘块都有一个二进制位与之对应，这样，由所有盘块所对应的位构成一个集合，称为位示图。</strong></p> 
</blockquote> 
<p>先来看一个题目<br> 某文件系统采用位示图记录磁盘的使用情况，若计算机系统的字长为64位，磁盘的容量为1024GB，物理块的大小为4MB，那么位示图的大小需要_____个字</p> 
<p>解析：<br> 给出了磁盘容量和物理块大小，我们就可以求得磁盘中一共有1024*1024/4个物理块。系统字长是64位，每一位对应文件存储器上的一个物理块。那么位示图就一个有1024 * 1024/4/64=<strong>4096</strong>个字</p> 
<h3><a id="_371"></a>考点：进程资源图</h3> 
<p><img src="https://images2.imgbox.com/25/b3/dPjwAKiA_o.png" alt="在这里插入图片描述"></p> 
<p><strong>如果一个图可完全简化，则不会产生死锁；如果一个图不可完全简化（即：图中还有“边”存在），则会产生死锁。这就是“死锁定理”。</strong></p> 
<p>案例原图：<br> <img src="https://images2.imgbox.com/15/27/MCqJC9EY_o.png" alt="在这里插入图片描述"><br> 如何简化呢？很简单<br> <font color="red">就是查看进程是否会被阻塞，如果非阻塞就消除与它相连的所有边，否则不消除</font></p> 
<p><strong>对P1进程</strong>：在原图中，P1进程需要请求一个R2资源，而R2原本有两个资源，分配给P2一个，还剩一个。所以可以满足P1的请求，P1不发生阻塞，可以消除与它相连的边，如下图所示<br> <img src="https://images2.imgbox.com/3a/28/RYso6Aee_o.png" alt="在这里插入图片描述"></p> 
<p><strong>对P2进程</strong>：在上图中，此时P1进程已经完成，释放完所有资源。P2要想R1申请一个资源，而R1原本有三个资源，已分配给P2一个，还剩两个。所以也可以满足P2的请求，P2不发生阻塞，可以消除与它相连的边，如下图所示<br> <img src="https://images2.imgbox.com/7b/e2/l6d5U7b0_o.png" alt="在这里插入图片描述"><br> 经上所述，这个案例中进程不会发生死锁，那么上面情况会发生死锁呢，我们看下面这个图<br> <img src="https://images2.imgbox.com/e1/6d/6sK56ub6_o.png" alt="在这里插入图片描述"><br> 按照之前的分析逻辑，我们会发现，就算P3进程执行完释放资源，P1进程申请依旧得不到满足，P2也是，它们都被阻塞，无法被唤醒，此时就发生了死锁（无法消除所有边）。</p> 
<h3><a id="_391"></a>考点：分页（物理地址计算）</h3> 
<p><img src="https://images2.imgbox.com/0f/d4/l8H7mDn1_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>如果题目给出页面大小为4K，即2^12B。说明页内偏移量占0~11位，页号占了12 ~ 31位。</p> 
</blockquote> 
<p>计算公式：<br> 页号 = 逻辑地址 / 页面长度 （取整）<br> 页内偏移量 = 逻辑地址 % 页面长度 （取余）<br> 物理地址=b * L + W = 块号 × 页面大小 + 页内偏移量</p> 
<h3><a id="_403"></a>考点：信号量</h3> 
<p>信号量（semaphore）的数据结构为一个值和一个指针。信号量的值与相应资源的使用情况有关。值大于0时表示当前<strong>可用资源的数量</strong>；值小于0时，其绝对值表示<strong>等待使用该资源的进程个数</strong>。指针指向等待该信号量的下一个进程。信号量的值仅能由PV操作来改变。</p> 
<p>（1）同步信号量，值为资源可以使用的个数，信号量小于0，则线程进行等待，信号量大于0，表示可用资源个数。初始值0.<br> （2）互斥信号量只有两个值0或1，0表示资源正在被占用，线程等待。1表示，资源没有被使用，线程可以进入。初始值为1</p> 
<h3><a id="_409"></a>考点：多级索引结构</h3> 
<p><img src="https://images2.imgbox.com/f9/2c/8KCmk2iP_o.png" alt="在这里插入图片描述"><br> 【例题】某文件系统采用多级索引结构，若磁盘块的大小为 1K 字节，每个块号需占 3 字节，那么采用二级索引时的文件最大长度为<font color="red">116281K</font> 字节。</p> 
<p>116281K是怎么算出来的呢？<br> 首先我们要知道这几个<code>概念</code></p> 
<ul><li><strong>直接索引</strong>：索引指向物理块（地址直接对应物理盘块存索引的内容）</li><li><strong>一级间接地址索引</strong>：索引节点指向的物理块用来存放地址项。</li><li><strong>二级间接地址索引</strong>：索引节点指向的物理块，存放的是一级索引。</li></ul> 
<p><font color="red">现在回到题目!</font><br> <font color="blue">题目告诉我们磁盘块(物理盘块)的大小为1K字节，每个块号占3个字节，那么我们就可以求出一级索引一共存了1K/3≈341个磁盘块。因为是采用二级索引，每一个磁盘块还可以指向341个磁盘块，一共有341*341=116281个磁盘块存二级索引文件，每个磁盘块1K字节，所以该二级索引文件最大长度为116281k字节。</font></p> 
<h2><a id="_423"></a>三、计算机网络</h2> 
<h3><a id="TCPIP_424"></a>考点：TCP/IP五层模型中各个协议内容（高频）</h3> 
<table><thead><tr><th>应用层</th><th>传输层</th><th>网络层</th><th>数据链路层</th><th>物理层</th></tr></thead><tbody><tr><td>FTP：文件传输协议。20为数据端口，21为控制端口</td><td>UDP：无连接、不可靠的传输层协议</td><td>ICMP：Internet控制报文协议。用于在IP主机、路由器之间传递控制消息</td><td>L2TP：第二层隧道协议。</td><td></td></tr><tr><td>TFTP：简单文件传输协议</td><td>TLS：传输层安全协议，用于在两个通信应用程序之间提供保密性和数据完整性</td><td>OSPF：开放式最短路径优先</td><td>PPP：点对点协议</td><td></td></tr><tr><td>SSH：安全远程登录协议</td><td>TCP：面向连接的、可靠的传输层协议</td><td>IP：网际互连协议</td><td>PPPoE：以太网上的点对点协议，是将点对点协议(PPP)封装在以太网(Ethernet)框架中的一种网络隧道协议。提供用户身份验证、用户管理以及数据加密等功能</td><td></td></tr><tr><td>HTTP：超文本传输协议，用于从WWW服务器传输超文本到本地浏览器的传输协议，是浏览器默认的应用层协议</td><td></td><td>ARP：地址解析协议。根据IP地址获取物理地址</td><td></td><td></td></tr><tr><td>SMTP：简单邮件传输协议，用于发送邮件，是电子邮件客户端向服务器发送邮件的协议 ，使用25端口</td><td></td><td>RARP：反向地址转换协议。将物理地址转换为IP地址</td><td></td><td></td></tr><tr><td>POP3：有据协议。用于从目的邮件服务器上读取邮件，使用110端口</td><td></td><td>IGMP:互联网组管理协议,用于IP主机向任一个直接相邻的路由器报告他们的组成员情况</td><td></td><td></td></tr><tr><td>MIME：多用途互联网邮件扩展类型。MIME消息能包含文本、图像、音频、视频等多媒体数据</td><td></td><td></td><td></td><td></td></tr><tr><td>Telnet：是Internet远程登录服务的标准协议和主要方式 ，使用23端口</td><td></td><td></td><td></td><td></td></tr><tr><td>DNS：域名系统。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</td><td></td><td></td><td></td><td></td></tr><tr><td>RIP：路由信息协议。是基于距离矢量算法的路由协议，利用跳数来作为计量标准</td><td></td><td></td><td></td><td></td></tr><tr><td>SNMP：简单网络管理协议</td><td></td><td></td><td></td><td></td></tr><tr><td>DHCP：动态主机配置协议</td><td></td><td></td><td></td><td></td></tr><tr><td>BGP：边界网关协议，构建在EGP的经验之上</td><td></td><td></td><td></td><td></td></tr><tr><td>IGP：内部网关协议</td><td></td><td></td><td></td><td></td></tr><tr><td>EGP：边界网关协议</td><td></td><td></td><td></td><td></td></tr></tbody></table> 
<p><img src="https://images2.imgbox.com/62/f2/U3TpZWhg_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="HTTP_444"></a>考点：HTTP一次请求的过程</h3> 
<ol><li>在浏览器中输入URL，并按下回车键</li><li>浏览器向DNS服务器发出域名解析请求并获得结果</li><li>根据目的的IP地址和端口号，与服务器建立TCP连接</li><li>浏览器向服务器发送数据请求</li><li>服务器将网页数据发送给浏览器</li><li>通信完成，断开TCP连接</li><li>浏览器解析收到的数据并显示</li></ol> 
<h3><a id="ABC_454"></a>考点：A类、B类、C类网络</h3> 
<p><mark>A类</mark><img src="https://images2.imgbox.com/a6/52/z1ioM6G7_o.png" alt="在这里插入图片描述"></p> 
<p><mark>B类</mark></p> 
<p><img src="https://images2.imgbox.com/26/a5/mSuwh2Ry_o.png" alt="在这里插入图片描述"></p> 
<p><mark>C类</mark><br> <img src="https://images2.imgbox.com/00/62/BU6qrYFc_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_472"></a>考点：几种常见命令及功能</h3> 
<table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>netstat</td><td>控制台命令，查看端口占用，是一个监控TCP/IP网络的工具，它可以显示路由表、实际网络连接以及每一个网络接口设备的状态信息</td></tr><tr><td>nslookup</td><td>用于查询DNS记录，查看域名解析是否正常，在网络故障的时候用来诊断网络问题</td></tr><tr><td>ping</td><td>可以检查网络是否连通</td></tr><tr><td>tracert</td><td>跟踪路由，用于确定IP数据包访问目标锁采取的路径。Tracert命令使用IP生存时间（TTL）字段和ICMP错误消息来确定从一个主机到网络上其他主机的路由</td></tr><tr><td>traceroute</td><td>可以利用ICMP协议跟踪并返回本机访问目标计算机时所经过的所有路由</td></tr><tr><td>ipconfig</td><td>帮助用户查看网络状况，如延迟、IP、主机信息、物理地址信息等。</td></tr><tr><td>ipconfig/all</td><td>查看<strong>详细</strong>IP的主机信息，DNS信息，物理地址信息，DHCP服务器信息等</td></tr><tr><td>ipconfig/renew</td><td>更新所有适配器</td></tr><tr><td>ipconfig/release</td><td>释放所有匹配的连接</td></tr></tbody></table> 
<h2><a id="_487"></a>四、网络信息安全</h2> 
<h3><a id="_488"></a>考点：几种常见攻击方式</h3> 
<table><thead><tr><th>方式</th><th>内容</th></tr></thead><tbody><tr><td>跨站脚本</td><td>通过Web应用的安全漏洞，向网页中嵌入恶意脚本代码，以盗取用户信息为主</td></tr><tr><td>拒绝服务攻击（DoS）</td><td>指攻击者向攻击对象发送大量请求，使得攻击对象不能继续提供服务</td></tr><tr><td>信息篡改</td><td>当入侵者将网络上传送的信息数据在传送中途修改，然后再发向目的地。</td></tr><tr><td>口令猜测</td><td>通过穷举方式搜索口令空间，逐一测试，得到口令，进而非法入侵系统。</td></tr><tr><td>SQL注入</td><td>通过SQL漏洞，把恶意SQL命令插入到页面请求查询字符串中，来达到欺骗服务器执行恶意SQL命令的行为，目标是为了获得数据库权限，从而非法获取数据</td></tr><tr><td>ARP攻击</td><td>当局域网内的计算机遭到ARP的攻击时，它就会持续地向局域网内所有的计算机及网络通信设备发送大量的ARP欺骗数据包，如果不及时处理，便会造成网络通道阻塞、网络设备的承载过重、网络的通讯质量不佳等情况</td></tr></tbody></table> 
<h3><a id="_498"></a>考点：对称加密与非对称加密</h3> 
<p>这里推荐一篇文章：<a href="https://blog.csdn.net/TheSkyLee/article/details/108699243">搞懂加密、数字签名、证书</a><br> 写的非常详细！！！<br> 这里就列举一下常见的几种加密算法</p> 
<table><thead><tr><th>对称加密</th><th>非对称加密</th><th>信息摘要</th></tr></thead><tbody><tr><td>DES、3DES、AES、RC-5、IDEA、RC4</td><td>RSA、Elgamal、ECC、背包算法、Rabin、D-H</td><td>MD5、SHA</td></tr></tbody></table> 
<h3><a id="_506"></a>考点：计算机病毒的特性</h3> 
<p>计算机病毒具有<code>隐蔽性</code>，<code>传染性</code>，<code>潜伏性</code>，<code>触发性</code>和<code>破坏性</code>等特性</p> 
<h2><a id="_509"></a>五、法律方面</h2> 
<h3><a id="_510"></a>考点：保护期限</h3> 
<p><img src="https://images2.imgbox.com/f2/0a/qnXL8IUu_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_512"></a>考点：知识产权人确定</h3> 
<p><img src="https://images2.imgbox.com/9e/f9/jbeWBxSO_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/fa/76/wuwXD9Na_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_516"></a>考点：侵权判定</h3> 
<p><img src="https://images2.imgbox.com/80/e1/sK2vnZUW_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e3/4d/5UOR6C7X_o.png" alt="在这里插入图片描述"></p> 
<p>往年一些考题涉及到的内容：<br> 著作权法</p> 
<ul><li>著作权法规定，作品完成之时就开始受到保护</li><li>著作权归属由委托人和受委托人通过合同约定。合同中未作明确约定的，著作权属于受托人</li><li>软件属于本职工作中明确的开发目标，单位享有著作权</li><li>甲公司购买了一款工具软件，甲公司向客户提供工具软件的复制品，该行为属于侵犯了著作权</li><li>我国保护计算机软件著作权的两个基本法律文件是《中华人民共和国著作权法》和《计算机软件保护条例》</li></ul> 
<p>商标权</p> 
<ul><li>商标权可以每10年无限续期</li></ul> 
<p>专利权</p> 
<ul><li>当有两人以上申请人分别就相同内容的就相同的计算机软件发明创造，向专利部门提出专利申请，先申请的获得该项专利的申请权</li><li>利用本单位的物质技术条件所完成的发明创造，单位与发明人或者设计人订有合同对申请专利的权利的归属作出约定的，从其约定</li></ul> 
<p>署名权</p> 
<ul><li>作者的署名权、修改权、保护作品完整权的保护期不受限制</li></ul> 
<h2><a id="_538"></a>六、软件工程</h2> 
<h3><a id="_539"></a>考点：软件设计各个阶段</h3> 
<table><thead><tr><th>阶段</th><th>内容</th></tr></thead><tbody><tr><td>需求分析</td><td>确定软件要完成的功能及非功能性要求</td></tr><tr><td>概念设计</td><td>将需求转换为软件的模块划分，<strong>确定模块功能与接口、调用关系等</strong></td></tr><tr><td>详细设计</td><td>将模块进行细化，得到详细的<strong>数据结构及算法</strong></td></tr><tr><td>编码</td><td>根据详细设计进行代码的编写，得到可运行的软件，并进行单元测试</td></tr></tbody></table> 
<h3><a id="_548"></a>考点：项目的活动图</h3> 
<p>一般会考察两个地方</p> 
<ul><li>项目完成的最少时间，即关键路径</li><li>活动xx最多可以晚xx天不会影响项目进度，即松弛时间</li></ul> 
<p>关键路径就是项目从开始到结束的最长路径<br> 松弛时间 = 关键路径 - 通过整个活动经过xx最长路径</p> 
<p><strong>例题</strong><br> 某软件项目的活动图如下图所示，其中顶点表示项目里程碑，连接顶点的边表示包含的活动，边上的数字表示活动的持续时间（天），则完成该项目的最少时间为（ ）天。活动BD最多可以晚开始（ ）天而不会影响整个项目的进度。<br> <img src="https://images2.imgbox.com/83/f7/dANOflRO_o.png" alt="在这里插入图片描述"><br> 解析：第一空就是求得关键路径，在图中找出最长路径，即ABDGIKL，累加得22。第二空求松弛路径，因为活动BD在关键路径上，所以松弛时间：22-22=0</p> 
<h3><a id="_563"></a>考点：进程前驱图</h3> 
<p><font color="red">只需要记住一个秘诀！</font><br> <img src="https://images2.imgbox.com/41/02/qpkWsRba_o.png" alt="在这里插入图片描述"><br> <font color="red">一个箭头两端，都有一对对应的PV操作。带有指向的是P操作，另一头是V操作。</font><br> 举个例子<br> <img src="https://images2.imgbox.com/92/91/ZoJ6eG8y_o.png" alt="在这里插入图片描述"><br> 至于具体是哪个信号量S，还需要根据题目给定的已知条件来判断。</p> 
<h3><a id="_571"></a>考点：软件模型</h3> 
<table><thead><tr><th>模型</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td>瀑布模型</td><td>其过程是从上一项活动接收该项活动的工作对象作为输入，利用这一输入实施该项活动应完成的内容给出该项活动的工作成果，并作为输出传给下一项活动。</td><td><strong>需求明确</strong>，或者需求很少变化，风险低</td></tr><tr><td>快速原型模型</td><td>原型模型能快速迅速地开发出一个让用户<strong>看得见</strong>的系统框架，可以用来支持用户界面设计。它所能完成的功能往往是最终产品能完成功能的一个子集。用途是获知用户的真正需求，一旦需求确定了，原型将被抛弃</td><td>适用于用户<strong>需求不清</strong>、需求经常变化的情况</td></tr><tr><td>增量模型</td><td>增量模型在各个阶段并不交付一个可运行的完整产品，而是交付满足客户需求的一个<strong>子集的可运行产品</strong>。整个产品被分解成若干个构件，开发人员逐个构件地交付产品，这样做的好处是软件开发可以较好地适应变化，客户可以不断地看到锁开发的软件，从而降低开发风险</td><td>希望系统能<strong>快速</strong>投入使用，系统功能可以在<strong>使用过程中不断改善</strong></td></tr><tr><td>螺旋模型</td><td>是瀑布模型与原型模型的结合，它将<strong>风险分析</strong>加入到了瀑布模型中，将开发过程划分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符</td><td>适用于大规模、复杂且具有<strong>高风险</strong>的项目</td></tr><tr><td>喷泉模型</td><td>是一种以<strong>用户需求为动力</strong>，以<strong>对象</strong>为驱动的模型，其特征是<strong>复用性好、开发过程无间隙、节省时间</strong></td><td>适合于<strong>面向对象</strong>的开发方法</td></tr><tr><td>敏捷方法</td><td>敏捷方法是逐渐流行起来的一款新型软件开发方法，以应对快速变化的需求。在敏捷开发中，软件项目的构建被分成<strong>多个子项目</strong>，各个子项目的成果都经过测试，具备<strong>集成</strong>和<strong>可运行</strong>的特征。换言之，就是把一个大项目分为多个相互联系，但也可以独立运行的小项目，并分别完成，在此过程中软件一直处于可使用转台</td><td>可以应对后期<strong>需求变化</strong></td></tr><tr><td>统一过程模型UP</td><td>统一过程（RUP/UP，Rational Unified Process）是一种以用例驱动、以体系结构为核心、迭代及增量的软件过程模型，由UML方法和工具支持，广泛应用于各类面向对象项目。</td><td>需求明确且很少变更的项目,如二次开发或升级型项目。”</td></tr></tbody></table> 
<h3><a id="_583"></a>考点：模块的耦合类型</h3> 
<table><thead><tr><th>耦合关系</th><th>内容</th></tr></thead><tbody><tr><td>内容耦合</td><td>内容耦合是最紧的耦合程度，一个模块直接访问另一模块的内容，或者通过非正常入口转入模块另一个模块内部，则称这两个模块为内容耦合。<strong>这种耦合是危险的。</strong></td></tr><tr><td>公共耦合</td><td>指模块通过公共数据环境中的<strong>全局数据结构、共享的通信区、内存的公共区等</strong>产生的耦合</td></tr><tr><td>外部耦合</td><td>一组模块都访问同一<strong>全局简单变量</strong>，而且不通过参数表传递该全局变量的信息，则称之为外部耦合。<strong>外部耦合和公共耦合很像，区别就是一个是简单变量，一个是复杂数据结构</strong>。</td></tr><tr><td>控制耦合</td><td>模块之间传递的不是数据信息，而是<strong>控制信息</strong>例如标志、开关量等，一个模块控制了另一个模块的功能。</td></tr><tr><td>标记耦合</td><td>调用模块和被调用模块之间传递<strong>数据结构</strong>而不是简单数据，同时也称作特征耦合。</td></tr><tr><td>数据耦合</td><td>调用模块和被调用模块之间只传递简单的数据项参数。相当于高级语言中的<strong>值传递</strong>。</td></tr><tr><td>非直接耦合</td><td>两个模块之间<strong>没有直接关系</strong>，它们之间的联系完全是通过主模块的控制和调用来实现的。耦合度最弱，模块独立性最强。</td></tr></tbody></table> 
<p><a href="https://blog.csdn.net/tu_wer/article/details/120875523?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E6%A8%A1%E5%9D%97%E8%80%A6%E5%90%88%E7%B1%BB%E5%9E%8B&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-120875523.nonecase&amp;spm=1018.2226.3001.4187">详情见这</a></p> 
<h3><a id="_596"></a>考点：模块的内聚类型</h3> 
<table><thead><tr><th>内聚关系</th><th>内容</th></tr></thead><tbody><tr><td>功能内聚</td><td>如果一个模块内所有处理元素完成一个，而且仅完成一个功能，则称为功能内聚。 功能内聚是最高程度的内聚。但在软件结构中，并不是每个模块都能设计成一个功能内聚模块。</td></tr><tr><td>顺序内聚</td><td>如果一个模块内处理元素和同一个功能密切相关，而且这些处理元素必须顺序执行，则称为顺序内聚。</td></tr><tr><td>通信内聚</td><td>模块内的所有处理元素都在同一数据结构上操作， 各处理使用相同的输入数据或参数相同的输出数据</td></tr><tr><td>过程内聚</td><td>如果一个模块内的处理元素是相关的，而且必须以特定的次序执行，称为过程内聚。 过程内聚与顺序内聚的区别是： 顺序内聚中是数据流从一个处理单元流到另一个处理单元，而过程内聚是控制流从一个动作流向另一个动作。</td></tr><tr><td>时间内聚</td><td>如果一个模块包含的任务必须在同一段时间内执行，称为时间内聚。也称为瞬时内聚。</td></tr><tr><td>逻辑内聚</td><td>如果模块完成的任务在逻辑上属于相同或相似的一类，称为逻辑内聚。</td></tr><tr><td>偶然内聚</td><td>如果一个模块由完成若干毫无关系的功能处理元素偶然组合在一起的，就叫偶然内聚。</td></tr></tbody></table> 
<h3><a id="_609"></a>考点：白盒测试（路径覆盖与语句覆盖）</h3> 
<table><thead><tr><th>路径覆盖</th><th>语句覆盖</th></tr></thead><tbody><tr><td>选取合适的用例，<strong>将图中所有可能执行路径都走一遍</strong></td><td>选择足够的测试用例，<strong>使得程序中每个语句至少都能被执行一次</strong></td></tr></tbody></table> 
<p>对于下面图例：<br> <img src="https://images2.imgbox.com/ba/27/wFimn7ii_o.png" alt="在这里插入图片描述"></p> 
<ul><li>如果要实现<code>语句覆盖</code>，那么只用设计一用例能通过路径ABCDEFG即可，因为这条路径满足每个语句至少都能被执行一次。</li><li>如果要实现<code>路径覆盖</code>，仅仅ABCDEFG是不够的，要使所有路径都被覆盖到，那么每个条件语句的Y/N情况都要分别考虑，比如ADG、ABCDG、ABCDEFG，这样才能将图中所有可能执行路径都走一遍</li></ul> 
<blockquote> 
 <p>采用McCabe度量法计算程序的环路复杂度 = 闭环数量 + 1</p> 
</blockquote> 
<h3><a id="_622"></a>考点：面向对象分析</h3> 
<p>面向对象分析包含5个活动：认定（识别）对象、组织对象、描述对象间的相互作用、确定对象的操作、定义对象的内部信息</p> 
<h3><a id="_625"></a>考点：类的设计原则</h3> 
<table><thead><tr><th>设计原则</th><th>内容</th></tr></thead><tbody><tr><td>开闭原则</td><td>指类对于功能扩展应该是开放的，对于修改应该是封闭的</td></tr><tr><td>里氏替换原则</td><td>即一个模块中如果使用了一个基类，那么这个基类应该可以被其子类替换，同时不会改变程序的正确性。总结就是<strong>子类必须能够替换他们的父类</strong></td></tr><tr><td>单一职责原则</td><td>指类的功能应该是尽量<strong>单一</strong>的。要修改一个类的时候，应该只因为一个原因</td></tr><tr><td>接口隔离原则</td><td>接口要尽量独立，不要把很多接口包在一个模块中，否则，当用户只需要某个接口时，就需要把很多不相关的接口导入进来，也就是“强迫”了用户依赖于人家不需要的接口</td></tr><tr><td>依赖反转原则</td><td>这个原则有两层含义，一是高级别模块不应该依赖于低级别模块，但都应该依赖于抽象；二是抽象不应该依赖于具体，但具体应该依赖于抽象</td></tr><tr><td>迪米特原则</td><td>迪米特法则又叫最少知识原则。如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</td></tr><tr><td>共同封闭</td><td>指因某一个同样的原因而需要修改的所有类，都应该封闭进同一个包中</td></tr><tr><td>共同重用</td><td>指一个包中的所有类应该是共同重用的，即如果重用了包中的一个类，那么就要重用包中的所有类</td></tr></tbody></table> 
<h3><a id="_637"></a>考点：设计模式</h3> 
<p><a href="https://blog.csdn.net/qq_25091281/article/details/123864304">23中设计模式图解</a></p> 
<table><thead><tr><th>创建者模式</th><th>结构型模式</th><th>行为型模式</th></tr></thead><tbody><tr><td>单例模式</td><td>代理模式</td><td>模板方法模式</td></tr><tr><td>工厂方法模式</td><td>适配器模式</td><td>策略模式</td></tr><tr><td>抽象工厂模式</td><td>装饰者模式</td><td>命令模式</td></tr><tr><td>原型模式</td><td>桥接模式</td><td>职责链模式</td></tr><tr><td>建造者模式</td><td>外观模式</td><td>状态模式</td></tr><tr><td></td><td>组合模式</td><td>观察者模式</td></tr><tr><td></td><td>享元模式</td><td>迭代器模式</td></tr><tr><td></td><td></td><td>访问者模式</td></tr><tr><td></td><td></td><td>备忘录模式</td></tr><tr><td></td><td></td><td>解释器模式</td></tr><tr><td></td><td></td><td>中介者模式</td></tr></tbody></table> 
<h3><a id="ISOIEC_9126_654"></a>考点：ISO/IEC 9126软件质量模型</h3> 
<table><thead><tr><th>功能性</th><th>可靠性</th><th>易用性</th><th>效率</th><th>维护性</th><th>可移植性</th></tr></thead><tbody><tr><td>适合性<br>准确性<br>互操作性<br>依从性<br>安全性</td><td>容错性<br>易恢复性<br>成熟性</td><td>易学性<br>易理解性<br>易操作性</td><td>时间特性<br>资源利用特性</td><td>易分析性<br>易改变性<br>稳定性<br>易测试性</td><td>适应性<br>易安装性<br>共存性<br>易替换性</td></tr></tbody></table> 
<p><a href="https://blog.csdn.net/weixin_44985880/article/details/115445079">内容详情</a></p> 
<h3><a id="_661"></a>考点：类的划分</h3> 
<p>类可以分为三种：实体类、接口类（边界类）、控制类</p> 
<table><thead><tr><th>类型</th><th>内容</th></tr></thead><tbody><tr><td>实体类</td><td>实体类的对象表示现实世界中真实的实体，如人、物等</td></tr><tr><td>接口类（边界类）</td><td>接口类的对象为用户提供一种与系统合作交互的方式，分为人和系统两大类，其中人的接口可以是显示屏、窗口、对话框等。系统接口涉及到把数据发送到其他系统，或者从其他系统接收数据</td></tr><tr><td>控制类</td><td>控制类的对象用来控制活动流，充当协调者</td></tr></tbody></table> 
<h3><a id="UML_669"></a>考点：UML类图</h3> 
<p>九种常见的UML类图总结：<a href="https://blog.csdn.net/qq_43530773/article/details/118250152">UML类图</a></p> 
<p>类与类之间关系的表达方式<br> <strong>（一）关联关系</strong><br> 关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。</p> 
<p>关联又可以分为单向关联，双向关联，自关联。</p> 
<p>1，单向关联<br> <img src="https://images2.imgbox.com/3b/17/pIWHeCTj_o.png" alt="在这里插入图片描述"></p> 
<p>在UML类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。</p> 
<p>2，双向关联<br> <img src="https://images2.imgbox.com/7f/e1/IvlDR0o0_o.png" alt="在这里插入图片描述"><br> 从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。</p> 
<p>在UML类图中，双向关联用一个不带箭头的直线表示。上图中在Customer类中维护一个List，表示一个顾客可以购买多个商品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。</p> 
<p>3，自关联</p> 
<p><img src="https://images2.imgbox.com/6d/ae/LB0vtbYC_o.png" alt="在这里插入图片描述"><br> 自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。</p> 
<p><strong>（二）聚合关系</strong><br> 聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。</p> 
<p>聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。</p> 
<p>在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。下图所示是大学和教师的关系图：<br> <img src="https://images2.imgbox.com/ee/03/uyC1XP6T_o.png" alt="在这里插入图片描述"><br> <strong>（三）组合关系</strong><br> 组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。</p> 
<p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。</p> 
<p>在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。下图所示是头和嘴的关系图：<br> <img src="https://images2.imgbox.com/20/f1/6E5r8gYU_o.png" alt="在这里插入图片描述"><br> <strong>（四）依赖关系</strong><br> 依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。</p> 
<p>在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是司机和汽车的关系图，司机驾驶汽车：<br> <img src="https://images2.imgbox.com/31/a3/mFWw8ocK_o.png" alt="在这里插入图片描述"><br> <strong>（五）继承关系</strong><br> 继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。</p> 
<p>在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下图所示：<br> <img src="https://images2.imgbox.com/a1/a3/28MYC6As_o.png" alt="在这里插入图片描述"><br> <strong>（六）实现关系</strong><br> 实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p> 
<p>在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如下图所示。<br> <img src="https://images2.imgbox.com/e7/e5/a8KKvBE1_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="MTTFMTTRMTBF_726"></a>考点：MTTF、MTTR、MTBF</h3> 
<ol><li>MTBF——全称是Mean Time Between Failure，即平均失效间隔。就是从新的产品在规定的工作环境条件下开始工作到出现第一个故障的时间的平均值。MTBF越长表示可靠性越高正确工作能力越强 。</li><li>MTTR——全称是Mean Time To Repair，即平均恢复时间。就是从出现故障到恢复中间的这段时间。MTTR越短表示易恢复性越好。</li><li>MTTF——全称是Mean Time To Failure，即平均无故障时间。系统平均能够正常运行多长时间，才发生一次故障。系统的可靠性越高，平均无故障时间越长。(MTTF=MTBF+MTTR)</li></ol> 
<blockquote> 
 <p>可靠性：MTTF /（1+MTTF）<br> 可用性：MTBF /（1+MTBF）<br> 可维护性：1 /（1+MTTR）</p> 
</blockquote> 
<h3><a id="V_735"></a>考点：V模型</h3> 
<blockquote> 
 <p>RAD（Rapid Application Development，快速应用开发）模型是软件开发过程中的一个重要模型，由于其模型构图形似字母V，所以又称软件测试的V模型。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/e6/3b/MP2EainQ_o.png" alt="在这里插入图片描述"><br> 在V模型中，有以下对应关系</p> 
<ul><li>需求分析 —— 验收测试</li><li>概要设计 —— 系统测试</li><li>详细设计 —— 集成测试</li><li>软件编码 —— 单元测试</li></ul> 
<p><font color="blue">但不管哪一阶段的测试，其测试的目标都来自需求分析！</font></p> 
<h3><a id="_749"></a>考点：嵌入式操作系统的特点</h3> 
<p><code>微型化</code>：从性能和成本角度考虑，希望占用的资源和系统代码量少。<br> <code>可定制</code>：从减少成本和缩短研发周期考虑，要求嵌入式操作系统能运行在不同的微处理器平台上，能针对硬件变化进行结构与功能上的配置，以满足不同应用的需求。<br> <code>实时性</code>：嵌入式操作系统主要应用于过程控制、数据采集、传输通信、多媒体信息及关键要害领填需要迅速响应的场合，所以对实时性要求较高。<br> <code>可靠性</code>：系统构件、模块和体系结构必须达到应有的可靠性，对关键要害应用还要提供容错和防故障措施。<br> <code>易移植性</code>：为了提高系统的易移植性，通常采用硬件抽象层和板级支持包的底层设计技术。</p> 
<h3><a id="_756"></a>考点：软件维护的特点</h3> 
<p><code>更正性</code>：由于系统测试不可能揭露系统存在的所有错误，因此在系统投入运行后频繁的实际应用过程中，就有可能暴露出系统内隐藏的错误。<br> <code>适应性维护</code>：适应性维护是为了使系统适应环境的变化而进行的维护工作。<br> <code>完善性维护</code>：在系统的使用过程中，用户往往要求扩充原有系统的功能，增加一些在软件需求规范书中没有规定的功能与性能特征，以及对处理效率和编写程序的改进。<br> <code>预防性维护</code>：系统维护工作不应总是被动地等待用户提出要求后才进行，应进行主动的预防性维护。即选择那些还有较长使用寿命，目前尚能正常运行，但可能将要发生变化或调整的系统进行维护，目的是通过预防性维护为未来的修改与调整奠定更好的基础。</p> 
<h3><a id="_762"></a>考点：分布式数据库特点</h3> 
<p>1)逻辑透明性(局部映像透明性):它是最低层次的透明性，该透明性提供数据到局部数据库的映像，即用户不必关心局部 DBMS 支持哪种数据模型、使用哪种数据操纵语言，数据模型和操纵语言的转换是由系统完成的。因此，局部映像透明性对异构型和同构异质的分布式数据库系统是非常重要的。</p> 
<p>2)位置透明性:用户不必知道所操作的数据放在何处，即数据分配到哪个或哪些站点存储对用户是透明的。因此，数据分片模式的改变，如把数据从一个站点转移到另一个站点将不会影响应用程序，因而应用程序不必改写。</p> 
<p>3)分片透明性:用户不必关心数据是如何分片，他们对数据的操作在全局关系上进行，即关心如何分片对用户是透明的，因此，当分片改变时应用程序可以不变。</p> 
<p>4)复制透明性:用户不用关心数据库在网络中的各个节点的复制情况，被复制的数据的更新都由系统自动完成。</p> 
<h2><a id="_771"></a>七、程序语言基础</h2> 
<h3><a id="_772"></a>考点：词法、语法、语义分析</h3> 
<table><thead><tr><th>阶段</th><th>任务</th></tr></thead><tbody><tr><td>词法分析</td><td>在输入源程序时对构成源程序的<strong>字符串进行扫描和分解，识别出一个个单词</strong>，删除无用的信息，并报告分析出来的错误。词法如关键字（保留字）、标识符、常数、运算符、分隔符 等。</td></tr><tr><td>语法分析</td><td>在词法分析的基础上，根据语言的语法规则将单词符号序列分解成各类语法单位。通过语法分析<strong>确定整个输入串是否构成一个语法上正确</strong>的程序，然后构造成一颗语法树。语法如“表达式”、“赋值”、“循环”，按语法规则分析检查每条语句是否有正确的逻辑结构。</td></tr><tr><td>语义分析</td><td>检查源程序是否存在语义错误，并收集类型信息供后面的代码生成阶段使用。主要有这三个方面：<strong>类型检查</strong>和自动类型转换、常量表达式的计算、运算符重载和函数重载</td></tr><tr><td>目标代码生成</td><td>目标代码生成是编译的最后一个阶段。目标代码生成器把语法分析后或优化后的中间代码变换成目标代码。</td></tr></tbody></table> 
<p>详情见百度百科：<a href="https://baike.baidu.com/item/%E7%BC%96%E8%AF%91/1258343" rel="nofollow">编译原理</a></p> 
<h3><a id="_781"></a>考点：调用函数，采用传值方式和传引用方式区别</h3> 
<p>实现函数调用时，形参具有独立的存储空间。</p> 
<ul><li>在传值方式下，将实参的值拷贝给形参</li><li>在传引用方式下，将实参的地址传给形参，也可简单理解为被调用函数中形参名实际成了实参的一个别名</li></ul> 
<p>如图所示：<br> <img src="https://images2.imgbox.com/b7/c9/UMFRaaGB_o.png" alt="在这里插入图片描述"><br> 在这张图中，调用函数f(1,x)执行时（第一个参数传值，第二个传引用）<br> 1、形参x的初始值为1，a的值为2（形参a指向main函数中的变量x）<br> 2、经过“x=2*a+1”,形参x的值变为了5，经过“a=x+3”，a的值变为8，而a实质上是main函数中x的别名，所以返回后x的值为8</p> 
<h3><a id="_793"></a>考点：编译与解释</h3> 
<p>在编译过程中：词法分析；语法分析；语义分析；目标代码生成是必须的，而代码优化和中间代码生成是可以不需要的。</p> 
<p>编译和与解释的区别在于：编译直接生成与<strong>源程序等价的目标程序</strong>，在机器上执行而编译器不需要参与执行，因此程序执行速度快；解释则生成<strong>中间代码或其等价形式</strong>，程序执行时需要解释器的参与，并且由解释器控制程序的执行，因此执行速度慢。</p> 
<h3><a id="_798"></a>考点：有限自动机</h3> 
<p><img src="https://images2.imgbox.com/50/9b/YyEyMPT5_o.png" alt="在这里插入图片描述"><br> 有限自动机上都会有一个<code>初态</code>和<code>终态</code>，每一个状态都都与其他状态有连线，<strong>连线上面的数字表示从一个状态输入n可以到达另一个状态</strong>。当此表初态走到终态，那<strong>一连串的数字代表的是能识别的输入</strong>。</p> 
<p>看如下例题：<br> <img src="https://images2.imgbox.com/21/cd/scJ4tGfK_o.png" alt="在这里插入图片描述"><br> 经过一一带入可知，只有依次输入0101可以从初态A到达终态C。</p> 
<blockquote> 
 <p><strong>确定的有限自动机DFA与不确定的有限自动机NFA的区别：</strong><br> 确定的有限自动机在任何一个状态，基于输入的字符都能完成一个确定的状态转换；不确定的有限自动机是指该状态机在任何一个状态，基于输入的字符都不能完成一个确定的状态转换，这里分两种情况：①对于一个输入，它有两个或更多状态可以转换；②存在E的情况，即没有任何字符输入的情况下，NFA可以从一个状态迁移到另一个状态。</p> 
</blockquote> 
<h3><a id="_809"></a>考点：并行系统与串行系统可靠度计算</h3> 
<ul><li>串行系统的可靠度：R=R1×R2×…Rn</li><li>并联系统的可靠度：R=1-(1-R1)×(1-R2)×…×(1-Rn)</li></ul> 
<h3><a id="_813"></a>考点：算数表达式</h3> 
<p>表达式有三种：<strong>前缀表达式、中缀表达式、后缀表达式</strong>。实际上分为前、中、后这里和树的变遍历方式——前中后序遍历是类似的。</p> 
<blockquote> 
 <p>前序遍历：按照 <strong>根 -&gt; 左孩子 -&gt; 右孩子</strong> 顺序遍历<br> 中序遍历：按照 <strong>左孩子 -&gt; 根 -&gt; 右孩子</strong> 顺序遍历<br> 后序遍历：按照 <strong>左孩子 -&gt; 右孩子 -&gt; 根</strong> 顺序遍历</p> 
</blockquote> 
<p>那么现在再看表达式就简单了。<br> <mark>比如：算数表达式 a*(b+c/d)-e的后缀式</mark><br> 第一步：先对表达式 a*(b+c/d)-e（中缀）构造一颗树<br> <img src="https://images2.imgbox.com/9f/81/CzLlydUd_o.png" alt="在这里插入图片描述"><br> 第二步：用后序遍历的方式来遍历这颗树<br> 结果为：a b c d / + * e -</p> 
<h2><a id="_826"></a>八、数据结构</h2> 
<h3><a id="_827"></a>考点：树</h3> 
<p><strong>1、二叉排序树、完全二叉树、线索二叉树和最优二叉树的概念</strong><br> 可以参考一下我以前写过的这篇文章：<a href="https://blog.csdn.net/weixin_51201930/article/details/124226093">二叉排序树、完全二叉树、线索二叉树、最优二叉树</a></p> 
<p><strong>2、先序遍历、中序遍历、后序遍历</strong><br> 其实这个非常简单，只需要记住遍历的顺序就行：</p> 
<blockquote> 
 <p>先序遍历：根 -&gt; 左 -&gt; 右 根节点先遍历，再到左孩子，最后右孩子<br> 中序遍历：左 -&gt; 中 -&gt; 右 左孩子先遍历，再到根结点，最后右孩子<br> 后序遍历：左 -&gt; 右 -&gt; 根 左孩子先遍历，再到右孩子，最后根结点</p> 
</blockquote> 
<p>实际上你会发现，先中后的意思，就是根是在什么时刻遍历，是最先，还是中时刻，还是最后呢，</p> 
<h3><a id="_841"></a>考点：图的存储（邻接矩阵、邻接表）</h3> 
<p><strong>1、邻接矩阵</strong><br> <img src="https://images2.imgbox.com/2e/25/JC5y9v4A_o.png" alt="在这里插入图片描述"></p> 
<p><code>邻接矩阵</code>的大小取决于图的节点数，例如图中有5个结点，那么邻接矩阵的大小就是5×5</p> 
<p><mark>那么邻接矩阵的数据是怎么由图转换过来的呢？</mark><br> 很简单，先给邻接矩阵编号，比如说（1,1）表示的就是第一行第一列的数据，为0，<font color="red">说明结点1和结点1之间没有连线。</font>同理，（1，2）为1，<font color="red">说明结点1和结点2有一条连线</font>，以此类推。</p> 
<p><strong>2、邻接表</strong><br> <img src="https://images2.imgbox.com/43/26/gRXmc72r_o.png" alt="在这里插入图片描述"><br> 邻接表会记录所有节点，每个节点能到达哪个节点，用链表的形式记录下来。如上图，与V1相邻的节点有V2，距离为6；V4，距离为1；V6，距离为50。在邻接表中就是以V1——26——41这样连接。</p> 
<p>邻接表先用一个数组记录每个节点，在用链表记录每个节点能到的顶点的情况。</p> 
<h3><a id="_857"></a>考点：广度优先与深度优先遍历</h3> 
<p><code>深度优先遍历</code>：对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次（二叉树的深度优先遍历比较特殊，可以细分为先序遍历，中序遍历，后序遍历）。</p> 
<p><code> 广度优先遍历</code>：又叫层次遍历从上往下对每一层依次访问，在每一层中，从左往右（也可以从右往左）访问节点，访问完一层就继续访问下一层，直到没有节点可以访问为止。</p> 
<p>分别深度优先和广度优先来得到图例这颗树的遍历次序</p> 
<p><img src="https://images2.imgbox.com/b9/9e/xB1Cq76p_o.png" alt="在这里插入图片描述"><br> 深度优先：<strong>一路走到底，路不通就换另一条路。</strong><br> 遍历顺序：ABDEFGC</p> 
<p>广度优先：<strong>对于每个结点每次先访问完它的邻结点，再往下走</strong><br> 遍历顺序：ABCDEFG</p> 
<h3><a id="_873"></a>考点：排序算法（复杂度）</h3> 
<p><img src="https://images2.imgbox.com/15/01/XCbOWWZj_o.png" alt="在这里插入图片描述"><br> <a href="https://blog.csdn.net/fly_thewind/article/details/51566294?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-4-51566294-blog-81257381.pc_relevant_antiscanv3&amp;spm=1001.2101.3001.4242.3&amp;utm_relevant_index=7">各种排序算法的时间复杂度和空间复杂度</a></p> 
<h3><a id="_877"></a>考点：算法设计策略</h3> 
<table><thead><tr><th>算法设计</th><th>特点</th></tr></thead><tbody><tr><td>分治</td><td>分治算法求出的子问题是互相独立的</td></tr><tr><td>贪心</td><td>总是做出在当前来说是最好的选择，而并不从整体上加以考虑，它所做的每步选择只是当前步骤的局部最优选择，但从整体来说不一定是最优的选择。</td></tr><tr><td>动态规划</td><td>具有最优子结构性质和重叠子问题性质</td></tr><tr><td>回溯</td><td>回溯法是一种选优搜索法，按选有条件向前搜索，以达到目标。但当搜索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择。类似于深度优先算法</td></tr></tbody></table> 
<h2><a id="_885"></a>九、数据库</h2> 
<h3><a id="_888"></a>考点：确定候选码</h3> 
<p>概念：通过一个（或一组）属性（即候选码）可以唯一地标识一个元组</p> 
<p><mark>怎么确定候选码呢？</mark><br> 比如在一个关系R（U，F），其中U={A,B,C,D,E,H}，F={A-&gt;B，B-&gt;DH，A-&gt;H，C-&gt;E}<br> <font color="blue">将依赖关系转换为有向图形式</font><br> <img src="https://images2.imgbox.com/61/d0/snmXVxzF_o.png" alt="在这里插入图片描述"><br> 我们会发现，只有（A，C）这个组合作为候选码（有向图起点）时，才能遍历整个有向图。而只靠A或只靠C作为候选键是无法遍历得到所有结点的。</p> 
<h3><a id="_896"></a>考点：部分依赖、完全依赖、传递依赖</h3> 
<p><strong>（一）部分函数依赖</strong><br> <img src="https://images2.imgbox.com/49/00/TTfd430O_o.png" alt="在这里插入图片描述"></p> 
<p>设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。</p> 
<p>例如：通过AB能得出C，通过A也能得出C，通过B也能得出C，那么说C部分依赖于AB。</p> 
<p><strong>（二）完全函数依赖</strong><br> 设X,Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全函数依赖于X。</p> 
<p>例如：通过AB能得出C，但是AB单独得不出C，那么说C完全依赖于AB.</p> 
<p><strong>（三）传递函数依赖</strong><br> <img src="https://images2.imgbox.com/86/f8/va8YLCEX_o.png" alt="在这里插入图片描述"></p> 
<p>设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X。</p> 
<p>例如：通过A得到B，通过B得到C，但是C得不到B，B得不到A，那么成C传递依赖于A</p> 
<h3><a id="_916"></a>考点：关系代数表达式</h3> 
<p>首先准备S1和S2两张表<br> <img src="https://images2.imgbox.com/f1/91/r4MOH9hC_o.png" alt="在这里插入图片描述"></p> 
<p><mark>1、并</mark><br> <code>并</code>符号为“∪”，它运算的结果是将两张表合并起来，并去除重复的内容。<br> <img src="https://images2.imgbox.com/f5/57/aS7I2J0h_o.png" alt="在这里插入图片描述"><br> <mark>2、交</mark></p> 
<p><code>交</code>符号为“∩”，它运算的结果是将两张表公共部门提取出来<br> <img src="https://images2.imgbox.com/13/39/Su7Q7pML_o.png" alt="在这里插入图片描述"><br> <mark>3、差</mark><br> <code>差</code>符号为“-”，它意思就是“我有的你没有”，什么意思呢？比如说S1-S2，表示的就是在S1表中有的内容在S2表中没有的内容。如下图所示<br> <img src="https://images2.imgbox.com/0a/6d/2ZpWZyXo_o.png" alt="在这里插入图片描述"><br> 这两行结果均只在S1中出现，在S2中没有</p> 
<p><mark>4、笛卡尔积</mark><br> <code>笛卡尔积</code>符号为“×”，它的运算是将两个集合中任意取出两个元素构成的组合的集合。有点像数学中(a+b)×(c+d)=ac+ad+bc+bd。也就是所有元素都要两两组合一次。<br> <img src="https://images2.imgbox.com/9f/b1/wgcn9s26_o.png" alt="在这里插入图片描述"><br> <mark>5、投影</mark><br> <code>投影</code>的符号是“π”，关系R上的投影是从R中选择出若干属性列组成新的关系，如下图所示，“πSno,Sname(S1)”，意思是得到在S1上投影出来的Sno和Sname两列数据，其他不需要投影的数据就不需要。类似于sql语句中的select Sno,Sname from S1;<br> <img src="https://images2.imgbox.com/e8/d8/AZKgvJ3k_o.png" alt="在这里插入图片描述"><br> <font color="red">“πSno,Sname(S1)” 还可以表示为 “π1,2(S1)”</font><br> <mark>6、选择</mark><br> 选择的符号是“σ”，代表着在关系R上选择出满足条件的元组。例如“σSno=No0003(S1)”意思是在S1表中选择满足Sno=No0003条件的记录。类似于sql语句中的select * from S1 where Sno =No0003<br> <img src="https://images2.imgbox.com/ee/30/1M5tkI0q_o.png" alt="在这里插入图片描述"><br> <font color="red">“σSno=No0003(S1)” 还可以表示为 “σ1=No0003(S1)”</font></p> 
<p><mark>7、连接</mark></p> 
<p><code>连接</code>的符号是“⋈”，意思是将多表进行连接，它与笛卡尔积的区别是，它会把需要连接的表都有的字段只保留一个。一般来说⋈下面会接上连接条件。<br> <img src="https://images2.imgbox.com/ee/51/wqnsFRDU_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="1NF2NF3NF_951"></a>考点：1NF、2NF、3NF</h3> 
<p><img src="https://images2.imgbox.com/fa/16/Kl2T9KLn_o.png" alt="在这里插入图片描述"></p> 
<p>（一）第一范式1NF</p> 
<blockquote> 
 <p>符合1NF的关系中的每个属性都不可再分。</p> 
</blockquote> 
<p>（二）第二范式2NF</p> 
<blockquote> 
 <p>消除了1NF非主属性对主属性的部分函数依赖。</p> 
</blockquote> 
<p>（三）第三范式3NF</p> 
<blockquote> 
 <p>消除了非主属性对码的传递函数依赖。</p> 
</blockquote> 
<h3><a id="_966"></a>考点：共享锁与排他锁</h3> 
<p><code>共享锁</code>：又称读锁或S锁。若事务T对数据加上共享锁，其他事务也只能对该数据加共享锁。</p> 
<p><code>排他锁</code>：又称写锁或X锁。若事务T对数据加上排他锁，其他事务不能再对该数据加任何锁，直至事务T释放加在数据上的锁。</p> 
<h3><a id="_971"></a>考点：外连接</h3> 
<p>左外连接：左表不加限制，保留左表的数据，匹配右表，右表没有匹配到的行中的列显示为null。<br> 右外连接：右表不加限制，保留右表的数据。匹配左表，左表没有匹配到的行中列显示为null。<br> 完全外连接：左右表都不加限制。即右外连接的结果为：左右表匹配的数据+左表没有匹配到的数据+右表没有匹配到的数据。</p> 
<h3><a id="_977"></a>考点：数据流图</h3> 
<p><code>数据流图</code>是结构化开发的一种工具，它描述了系统的输入数据流如何经过一系列的加工，逐步变换成系统的输出数据流，属于一种功能模型。数据流图的基本成分及图形表示法如下图所示。</p> 
<p><img src="https://images2.imgbox.com/03/92/YgJnEBb4_o.png" alt="在这里插入图片描述"><br> 这几个角色的概念：</p> 
<ul><li><code>数据流</code>：由一组固定成分的数据组成，表示数据的流向，每一个数据流都有一个定义明确的名字。</li><li><code>加工</code>：加工描述了输入数据流到输入数据流之间的变换，即输入数据流经过什么处理后编程输出数据流，每个加工都有一个名字和编号；</li><li><code>数据存储</code>：数据存储用来存储数据，每个数据存储都有一个定义明确的名字标识；</li><li><code>外部实体</code>：指存在于软件系统之外的人员或组织，它指出系统所需数据的发源地和系统所产生的数据的归属地，每个外部实体都有一个定义明确的名字标识。</li></ul> 
<h3><a id="_989"></a>考点：外模式、模式和内模式</h3> 
<p>一、模式（Schema）</p> 
<p>定义：也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</p> 
<p>理解： ① 一个数据库只有一个模式； ② 是数据库数据在逻辑级上的视图； ③ 数据库模式以某一种数据模型为基础； ④ 定义模式时不仅要定义数据的逻辑结构（如数据记录由哪些数据项构成，数据项的名字、类型、取值范围等），而且要定义与数据有关的安全性、完整性要求，定义这些数据之间的联系。</p> 
<p>二、外模式（External Schema）</p> 
<p>定义：也称子模式（Subschema）或用户模式，是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。</p> 
<p>理解： ① 一个数据库可以有多个外模式； ② 外模式就是用户视图； ③ 外模式是保证数据安全性的一个有力措施。</p> 
<p>三、内模式（Internal Schema）</p> 
<p>定义：也称存储模式（Storage Schema），它是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式（例如，记录的存储方式是顺序存储、按照B树结构存储还是按hash方法存储；索引按照什么方式组织；数据是否压缩存储，是否加密；数据的存储记录结构有何规定）。</p> 
<p>理解： ① 一个数据库只有一个内模式； ② 一个表可能由多个文件组成，如：数据文件、索引文件。 它是数据库管理系统(DBMS)对数据库中数据进行有效组织和管理的方法 其目的有： ① 为了减少数据冗余，实现数据共享； ② 为了提高存取效率，改善性能。</p> 
<blockquote> 
 <p>例题：数据库系统中的视图、存储文件和基本表分别对应数据库系统结构的<font color="blue">外模式、内模式和模式</font></p> 
</blockquote> 
<p><a href="https://blog.csdn.net/iteye_10730/article/details/82547848">原文链接</a></p> 
<hr> 
<p>由于时间关系，上午题资料整理只有这么多了，有待完善。文章内容大部分是笔记整理，若有侵权部分，请联系删除。</p> 
<p>部分参考内容：<br> 王勇，软件设计师课程；黑马，设计模式；王道，操作系统；湖科大，计算机网络；</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8a4e0925d5ff7089bd030c157e5fade4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">有哪些高含金量的编程竞赛？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eb48773e5888dc35bdb9f0c9cbbfc325/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">cpp——引用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>