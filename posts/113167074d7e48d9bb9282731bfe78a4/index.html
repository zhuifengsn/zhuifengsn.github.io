<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>mysql默认隔离级别为什么是可重复读，业务代码为什么设置为读已提交 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="mysql默认隔离级别为什么是可重复读，业务代码为什么设置为读已提交" />
<meta property="og:description" content="Mysql隔离级别为什么默认可重复读 这主要是由于历史原因造成的，mysql的主从复制是基于binlog复制的。
binlog的三种格式 1.statement:记录的是修改SQL语句
2.row：记录的是每行实际数据的变更
3.mixed：statement和row模式的混合
那Mysql在5.0及这个版本以前，binlog只支持STATEMENT这种格式！而这种格式在读已提交(Read Commited)这个隔离级别下主从复制是有bug的（主从不一致问题，就是在master上执行的顺序为先删后插！而此时binlog为STATEMENT格式，它记录的顺序为先插后删！从(slave)同步的是binglog，因此从机执行的顺序和主机不一致！就会出现主从不一致！），因此Mysql将可重复读(Repeatable Read)作为默认的隔离级别！
如何解决主从不一致问题？ 1.隔离级别设为可重复读(Repeatable Read),在该隔离级别下引入间隙锁。当Session 1执行delete语句时，会锁住间隙。那么，Ssession 2执行插入语句就会阻塞住！
2.将binglog的格式修改为row格式，此时是基于行的复制，自然就不会出现sql执行顺序不一样的问题！但是这个格式在mysql5.1版本开始才引入。因此由于历史原因，mysql将默认的隔离级别设为可重复读(Repeatable Read)，保证主从复制不出问题！
选择读已提交的原因 1.repeatable存在间隙锁会使死锁的概率增大；
2.在RR可重复读隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行；
在RR隔离级别下，走聚簇索引，进行全部扫描，最后会将整个表锁上；
在RC隔离级别下，其先走聚簇索引，进行全部扫描，但MySQL做了优化，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录放锁。
3.在RC隔离级别下，引入半一致性读(semi-consistent)特性增加了update操作的性能！
半一致性读就是，一个update语句，如果读到一行已经加锁的记录，此时InnoDB返回记录最近提交的版本，由MySQL上层判断此版本是否满足update的where条件。若满足(需要更新)，则MySQL会重新发起一次读操作，此时会读取行的最新版本(并加锁)！" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/113167074d7e48d9bb9282731bfe78a4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-10T16:18:30+08:00" />
<meta property="article:modified_time" content="2020-11-10T16:18:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">mysql默认隔离级别为什么是可重复读，业务代码为什么设置为读已提交</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Mysql_0"></a>Mysql隔离级别为什么默认可重复读</h3> 
<p>这主要是由于历史原因造成的，mysql的主从复制是基于binlog复制的。</p> 
<h4><a id="binlog_2"></a>binlog的三种格式</h4> 
<p>1.statement:记录的是修改SQL语句</p> 
<p>2.row：记录的是每行实际数据的变更</p> 
<p>3.mixed：statement和row模式的混合</p> 
<p>那Mysql在5.0及这个版本以前，binlog只支持STATEMENT这种格式！而这种格式在读已提交(Read Commited)这个隔离级别下主从复制是有bug的（主从不一致问题，就是在master上执行的顺序为先删后插！而此时binlog为STATEMENT格式，它记录的顺序为先插后删！从(slave)同步的是binglog，因此从机执行的顺序和主机不一致！就会出现主从不一致！），因此Mysql将可重复读(Repeatable Read)作为默认的隔离级别！</p> 
<h5><a id="_11"></a>如何解决主从不一致问题？</h5> 
<p>1.隔离级别设为可重复读(Repeatable Read),在该隔离级别下引入间隙锁。当Session 1执行delete语句时，会锁住间隙。那么，Ssession 2执行插入语句就会阻塞住！<br> 2.将binglog的格式修改为row格式，此时是基于行的复制，自然就不会出现sql执行顺序不一样的问题！但是这个格式在mysql5.1版本开始才引入。因此由于历史原因，mysql将默认的隔离级别设为可重复读(Repeatable Read)，保证主从复制不出问题！</p> 
<h3><a id="_15"></a>选择读已提交的原因</h3> 
<p>1.repeatable存在间隙锁会使死锁的概率增大；<br> 2.在RR可重复读隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行；<br> 在RR隔离级别下，走聚簇索引，进行全部扫描，最后会将整个表锁上；<br> 在RC隔离级别下，其先走聚簇索引，进行全部扫描，但MySQL做了优化，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录放锁。<br> 3.在RC隔离级别下，引入半一致性读(semi-consistent)特性增加了update操作的性能！</p> 
<p>半一致性读就是，一个update语句，如果读到一行已经加锁的记录，此时InnoDB返回记录最近提交的版本，由MySQL上层判断此版本是否满足update的where条件。若满足(需要更新)，则MySQL会重新发起一次读操作，此时会读取行的最新版本(并加锁)！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0711238cdbac4a448833982b8b4242b7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python 爬虫URL出现 ‘ascii‘ codec can‘t encode characters in position。。。问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0bb0eff301438daf9f83f1cc88e36e22/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">md5是什么_全民小视频视频修改md5有什么用6</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>