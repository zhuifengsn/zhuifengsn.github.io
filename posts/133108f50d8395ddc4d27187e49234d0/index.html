<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;的高精度减法 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;的高精度减法" />
<meta property="og:description" content="为什么需要高精度计算 对于 C&#43;&#43; 而言，最大的数据为 long long（64b，8位），对于超过 8B 的数据，C&#43;&#43; 没有对应的数据类型进行表示。所以我们需要知道高精度计算。更详细的解释，可以参考这个网页https://blog.csdn.net/justidle/article/details/104414459。
高精度减法计算原理 在读小学时，我们做减法都采用竖式方法，如图 1 所示。 这样，我们可以写出两个整数相减的算法。
我们就可以用 C&#43;&#43; 语言来模拟这个竖式减法的过程。我们可以考虑利用 C&#43;&#43; 的数组来存储对应数据，假设用数组 A 存储被减数 856 的每一位，具体来说就是 A1 存储个位 6，A2 存储十位 5，A3存储百位 8；类似数组 A 的结构，使用数组 B 存储减数 257；类似数组 A 的结构，使用数组 C 来存储对应的差 599。两数相加的结果就如图 2 所示。这样理论上来说，我们就可以计算无限大的数据。如上图 2 所示，下表表示对应的存储方式。
数组 A数组 B数组 C[0]679[1]559[2]825 总结：利用数组存储，突破存储的限制。每个位置存储 0 ~ 9 之间的数据。
高精度减法实现 思路 1、定义存储数组。
2、被减数和减数确认。由于减法可能出现负数。
3、读入数据到数组中。注意：保证被减数大于减数；倒序存放，也就是个位放在数组下标为 0 的地方。
4、从个位开始模拟竖式减法的过程，完成整个减法。
5、删除前导 0 。所谓前导零，就是出现类似这样数据 01234，这个 0 实际是不需要的。
6、输出减法的结果。倒序输出减法的结果数组 C，因为我们的个位是存储在下标为 0 的地方。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/133108f50d8395ddc4d27187e49234d0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-02-21T13:40:38+08:00" />
<meta property="article:modified_time" content="2020-02-21T13:40:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;的高精度减法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%AE%A1%E7%AE%97">为什么需要高精度计算</h2> 
<p style="text-indent:33px;">对于 C++ 而言，最大的数据为 long long（64b，8位），对于超过 8B 的数据，C++ 没有对应的数据类型进行表示。所以我们需要知道高精度计算。更详细的解释，可以参考这个网页<a href="https://blog.csdn.net/justidle/article/details/104414459">https://blog.csdn.net/justidle/article/details/104414459</a>。</p> 
<h2 id="%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95%E8%AE%A1%E7%AE%97%E5%8E%9F%E7%90%86">高精度减法计算原理</h2> 
<p style="text-indent:33px;">在读小学时，我们做减法都采用竖式方法，如图 1 所示。 这样，我们可以写出两个整数相减的算法。</p> 
<p><img alt="" height="311" src="https://images2.imgbox.com/91/b2/9QMcpGaA_o.png" width="1072"></p> 
<p style="text-indent:33px;">我们就可以用 C++ 语言来模拟这个竖式减法的过程。我们可以考虑利用 C++ 的数组来存储对应数据，假设用数组 A 存储被减数 856 的每一位，具体来说就是 A1 存储个位 6，A2 存储十位 5，A3存储百位 8；类似数组 A 的结构，使用数组 B 存储减数 257；类似数组 A 的结构，使用数组 C 来存储对应的差 599。两数相加的结果就如图 2 所示。这样理论上来说，我们就可以计算无限大的数据。如上图 2 所示，下表表示对应的存储方式。</p> 
<table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td> </td><td>数组 A</td><td>数组 B</td><td>数组 C</td></tr><tr><td>[0]</td><td>6</td><td>7</td><td>9</td></tr><tr><td>[1]</td><td>5</td><td>5</td><td>9</td></tr><tr><td>[2]</td><td>8</td><td>2</td><td>5</td></tr></tbody></table> 
<p>总结：利用数组存储，突破存储的限制。每个位置存储 0 ~ 9 之间的数据。</p> 
<h2 id="%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95">高精度减法实现</h2> 
<h3 id="%E6%80%9D%E8%B7%AF">思路</h3> 
<p>1、定义存储数组。</p> 
<p>2、被减数和减数确认。由于减法可能出现负数。</p> 
<p>3、读入数据到数组中。注意：保证被减数大于减数；倒序存放，也就是个位放在数组下标为 0 的地方。</p> 
<p>4、从个位开始模拟竖式减法的过程，完成整个减法。</p> 
<p>5、删除前导 0 。所谓前导零，就是出现类似这样数据 01234，这个 0 实际是不需要的。</p> 
<p>6、输出减法的结果。倒序输出减法的结果数组 C，因为我们的个位是存储在下标为 0 的地方。</p> 
<h3 id="%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E8%AF%B4%E6%98%8E">技术细节说明</h3> 
<h4 id="%E5%AE%9A%E4%B9%89%E5%AD%98%E5%82%A8%E6%95%B0%E7%BB%84">定义存储数组</h4> 
<p>根据题目的要求定义数组。这个部分代码如下：</p> 
<pre><code>const int MAXN = 1e5+4; //根据题目的最大值。+4为了防止A+B出现进位
char s1[MAXN] = {};//存储字符串
char s2[MAXN] = {};//存储字符串
char tmp[MAXN] = {};//交换用字符串
int a[MAXN] = {};//存储加数A
int b[MAXN] = {};//存储加数B
int c[MAXN] = {};//存储和B</code></pre> 
<h4>被减数和减数确认</h4> 
<p>由于减法可能出现负数，如 3-5=-2，我们在计算的时候，实际是使用 5-3=2，最后在结果前面添加负号。如果出现被减数小于减数的情况，要将两者颠倒。</p> 
<pre><code>    scanf("%s %s", s1, s2);//读入字符串
    int lena = strlen(s1);
    int lenb = strlen(s2);
    //判断最终的结果符号
    if ((lena&lt;lenb) || (lena==lenb &amp;&amp; strcmp(s1,s2)&lt;0)) {
        //被减数小于减数，结果为负数
        printf("-");
        //交换数据
        strcpy(tmp, s1);
        strcpy(s1, s2);
        strcpy(s2, tmp);
        //更新长度数据
        lena = strlen(s1);
        lenb = strlen(s2);
    }</code></pre> 
<h4>读入数据到数组</h4> 
<p>利用读入字符串的方法读入数据，再倒序写入到对应的数组中。这个部分代码如下：</p> 
<pre><code class="language-cpp">    //将字符串写入到数组A中
    for (int i=0; i&lt;lena; i++) {
        //倒序写入
        a[i] = s1[lena-i-1] - '0';
    }

    //将字符串写入到数组B中
    for (int i=0; i&lt;lenb; i++) {
        //倒序写入
        b[i] = s2[lenb-i-1] - '0';
    }</code></pre> 
<h4>模拟竖式减法</h4> 
<p>有两个技术细节：如何判断发生借位。这个部分代码如下：</p> 
<pre><code>    //模拟竖式减法
    for (int i=0; i&lt;lena; i++) {
        if (a[i]&lt;b[i]) {
            //有借位
            a[i+1]--;
            a[i] += 10;
        }
        c[i] = a[i] - b[i];
    }</code></pre> 
<h4>删除前导零</h4> 
<p>因为减法运算可能会出现最高位为零，所以我们需要判断是否需要删除前导零。这个部分代码如下：</p> 
<pre><code>    //删除前导零
    for (int i=lena-1; i&gt;=0; i--) {
        //因为我们是从索引 0 开始，所以最高位是保存在 len-1
        if (0==c[i] &amp;&amp; lena&gt;1) {
            //注意要有 lena&gt;1 这个条件。考虑特殊情况，加法结果为 00，我们实际要输出 0。
            lena--;
        } else {
            //第一个不是零的最高位，结束删除
            break;
        }
    }</code></pre> 
<h4>输出计算结果</h4> 
<p>采用倒序的方式输出，因为我们数据保存是倒序结构，也就是低位在前。</p> 
<pre><code>    //逆序打印输出
    for (int i=lena-1; i&gt;=0; i--) {
        printf("%d", c[i]);
    }
    printf("\n");    </code></pre> 
<h2>例题和 AC 代码</h2> 
<h3>题目</h3> 
<h4>题目链接</h4> 
<p>一本通 OJ：<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1169" rel="nofollow">http://ybt.ssoier.cn:8088/problem_show.php?pid=1169</a>。</p> 
<p>我自己 OJ：<a href="http://47.110.135.197/problem.php?id=1216" rel="nofollow">http://47.110.135.197/problem.php?id=1216</a>。</p> 
<h4>题目描述</h4> 
<p>求两个大的正整数相减的差。</p> 
<h4>输入</h4> 
<p>共 2 行，第 1 行是被减数 a，第 2 行是减数 b，不保证 a &gt; b。每个大整数不超过 10005 位。</p> 
<h4>输出</h4> 
<p>一行，即所求的差。</p> 
<h4>样例输入</h4> 
<pre><code>9999999999999999999999999999999999999
9999999999999</code></pre> 
<h4>样例输出</h4> 
<pre><code>9999999999999999999999990000000000000</code></pre> 
<h3>分析</h3> 
<p>题目告诉我们不超过 200 位，也就是 MAXN = 10005+4。</p> 
<h4>AC 代码</h4> 
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int MAXN = 1e4+4; //根据题目的最大值。+4为了防止A+B出现进位
char s1[MAXN] = {};//存储字符串
char s2[MAXN] = {};//存储字符串
char tmp[MAXN] = {};//交换用字符串
int a[MAXN] = {};//存储加数A
int b[MAXN] = {};//存储加数B
int c[MAXN] = {};//存储和B

int main() {
    scanf("%s %s", s1, s2);//读入字符串
    
    int lena = strlen(s1);
    int lenb = strlen(s2);
    //判断最终的结果符号
    if ((lena&lt;lenb) || (lena==lenb &amp;&amp; strcmp(s1,s2)&lt;0)) {
        //被减数小于减数，结果为负数
        printf("-");
        //交换数据
        strcpy(tmp, s1);
        strcpy(s1, s2);
        strcpy(s2, tmp);
        //更新长度数据
        lena = strlen(s1);
        lenb = strlen(s2);
    }
    
    //将字符串写入到数组A中
    for (int i=0; i&lt;lena; i++) {
        //倒序写入
        a[i] = s1[lena-i-1] - '0';
    }

    //将字符串写入到数组B中
    for (int i=0; i&lt;lenb; i++) {
        //倒序写入
        b[i] = s2[lenb-i-1] - '0';
    }

    //模拟竖式减法
    for (int i=0; i&lt;lena; i++) {
        if (a[i]&lt;b[i]) {
            //有借位
            a[i+1]--;
            a[i] += 10;
        }
        c[i] = a[i] - b[i];
    }

    //删除前导零
    for (int i=lena-1; i&gt;=0; i--) {
        //因为我们是从索引 0 开始，所以最高位是保存在 len-1
        if (0==c[i] &amp;&amp; lena&gt;1) {
            //注意要有 lena&gt;1 这个条件。考虑特殊情况，加法结果为 00，我们实际要输出 0。
            lena--;
        } else {
            //第一个不是零的最高位，结束删除
            break;
        }
    }

    //逆序打印输出
    for (int i=lena-1; i&gt;=0; i--) {
        printf("%d", c[i]);
    }
    printf("\n");
    
    return 0;
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/72a94e4da571cfbef5ae8eb9f02c5a4f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">删除排序数组中的重复项I</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/987ea68987cb2df4223221a8ed129b53/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">zookeeper-3.7.0源码环境搭建</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>