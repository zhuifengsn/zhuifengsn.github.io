<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;(12) 模板类、模板继承(严格模式和自由模式) - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;(12) 模板类、模板继承(严格模式和自由模式)" />
<meta property="og:description" content="文章目录 模版类1. 模版类2. 模版参数限制3. 模版继承3.1 严格模式3.2 自由模式 4. 模版类的模版函数5. 返回值类型带有模版 模版类 1. 模版类 #include &lt;iostream&gt; using namespace std; /* 当前 Person 类型，声明了连个模版分别对应 NameType 模版类型，名称可以看出，用于约束成员变量 name 的类型 AgeType 模版类型，名称可以看出，用于约束成员变量 age 的类型 模版类型充当数据类型占位符，在整个类中，成员变量，成员函数，构造函数都可以使用 */ template &lt;typename NameType, typename AgeType&gt; class Person { public: Person() {} Person(NameType name, AgeType age) : name(name), age(age) {} Person(const Person &amp; person) : name(person.name), age(person.age) {} ~Person() {} NameType getName() { return name; } void setName(NameType name) { this-&gt;name = name; } AgeType getAge() { return age; } void setAge(AgeType age) { this-&gt;age = age; } private: NameType name; AgeType age; }; int main(int argc, char const *argv[]) { /* Person 类型带有模版修饰，需要在使用之前明确模版对应的具体类型 模版具备数据类型支持的多样性，同时一旦确定模版类型，严格遵守数据类型一致化原则 Person 类型如何确定模版对应的具体数据类型 格式： 类名&lt;模版对应具体数据类型&gt; * 对象 = new 类型&lt;模版对应具体数据类型&gt;(." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/6d9dc4b30453ba0e12b30057f35a4a0e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-21T10:06:34+08:00" />
<meta property="article:modified_time" content="2024-02-21T10:06:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;(12) 模板类、模板继承(严格模式和自由模式)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><ul><li><a href="#_1" rel="nofollow">模版类</a></li><li><ul><li><a href="#1__3" rel="nofollow">1. 模版类</a></li><li><a href="#2__68" rel="nofollow">2. 模版参数限制</a></li><li><a href="#3__154" rel="nofollow">3. 模版继承</a></li><li><ul><li><a href="#31__156" rel="nofollow">3.1 严格模式</a></li><li><a href="#32__222" rel="nofollow">3.2 自由模式</a></li></ul> 
     </li><li><a href="#4__283" rel="nofollow">4. 模版类的模版函数</a></li><li><a href="#5__320" rel="nofollow">5. 返回值类型带有模版</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h4><a id="_1"></a>模版类</h4> 
<h5><a id="1__3"></a>1. 模版类</h5> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;

using namespace std;

/*
当前 Person 类型，声明了连个模版分别对应
    NameType 模版类型，名称可以看出，用于约束成员变量 name 的类型
    AgeType  模版类型，名称可以看出，用于约束成员变量 age 的类型

模版类型充当数据类型占位符，在整个类中，成员变量，成员函数，构造函数都可以使用
*/
template &lt;typename NameType, typename AgeType&gt;
class Person
{
public:
    Person() {}
    Person(NameType name, AgeType age) : name(name), age(age) {}
    Person(const Person &amp; person) : name(person.name), age(person.age) {}
    ~Person() {}

    NameType getName() { return name; }
    void setName(NameType name) { this-&gt;name = name; }

    AgeType getAge() { return age; }
    void setAge(AgeType age) { this-&gt;age = age; }

private:
    NameType name;
    AgeType age;
};

int main(int argc, char const *argv[])
{
    /*
    Person 类型带有模版修饰，需要在使用之前明确模版对应的具体类型
    模版具备数据类型支持的多样性，同时一旦确定模版类型，严格遵守数据类型一致化原则

    Person 类型如何确定模版对应的具体数据类型
    格式：
    类名&lt;模版对应具体数据类型&gt; * 对象 = new 类型&lt;模版对应具体数据类型&gt;(...);
        Person&lt;NameType, AgeType&gt;
    */

    // p1 明确告知编译器 NameType ==&gt; string AgeType ==&gt; int
    // 在后续的代码中，通过 p1 调用 Person 类内函数按照以上规则完成
    Person&lt;string, int&gt; *p1 = new Person&lt;string, int&gt;();

    p1-&gt;setName("布丁");
    p1-&gt;setAge(3);

    cout &lt;&lt; "Name : " &lt;&lt; p1-&gt;getName() &lt;&lt; ", Age : " &lt;&lt; p1-&gt;getAge() &lt;&lt; endl;

    Person&lt;string, int&gt; *p2 = new Person&lt;string, int&gt;("张三", 14);
    cout &lt;&lt; "Name : " &lt;&lt; p2-&gt;getName() &lt;&lt; ", Age : " &lt;&lt; p2-&gt;getAge() &lt;&lt; endl;

    delete p1;
    delete p2;

    return 0;
}
</code></pre> 
<h5><a id="2__68"></a>2. 模版参数限制</h5> 
<blockquote> 
 <p>双重限制</p> 
 <ul><li>限制外部类型</li><li>限制模版类型</li></ul> 
</blockquote> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;

using namespace std;

template &lt;typename DataType, typename MsgType&gt;
class Data
{
public:
    Data() {}
    Data(DataType value, MsgType msg) : value(value), msg(msg) {}
    Data(const Data &amp;data) : value(data.value), msg(data.msg) {}
    ~Data() {}

    DataType getValue() { return value; }
    void setValue(DataType value) { this-&gt;value = value; }

    MsgType getMsg() { return msg; }
    void setMsg(MsgType msg) { this-&gt;msg = msg; }

private:
    DataType value;
    MsgType msg;
};

/*
当前 test1 函数明确告知调用者，当前所需的参数为 Data
同时限制 Data 中对应的模版类型为 &lt;int, string&gt;
*/
void test1(Data&lt;int, string&gt; *data);

/*
当前 test1 函数明确告知调用者，当前所需的参数为 Data
同时限制 Data 中对应的模版类型为 &lt;double, string&gt;
*/
void test1(Data&lt;double, string&gt; *data);

int main(int argc, char const *argv[])
{
    /*
    双重限制
    */
    Data&lt;int, string&gt; *d1 = new Data&lt;int, string&gt;(10, "别困！");
    Data&lt;double, string&gt; *d2 = new Data&lt;double, string&gt;(3.14, "别困！！");
    Data&lt;char, string&gt; *d3 = new Data&lt;char, string&gt;('G', "遵守数据类型一致化原则");

    test1(d1);
    test1(d2);
    /*
    test1 函数重载操作，所需函数有两种情况
        Data&lt;int, string&gt; *
        Data&lt;double, string&gt; *

    并没有支持
        Data&lt;char, string&gt; * 考虑到双重限制，分别对应外部类型和模版类型
        因此 d3 无法作为函数 test1 的实际参数
        【注意】请遵守数据类型一致化原则
    */
    // test1(d3);

    delete d1;
    delete d2;
    delete d3;

    return 0;
}


void test1(Data&lt;int, string&gt; *data)
{
    cout &lt;&lt; "value : " &lt;&lt; data-&gt;getValue() &lt;&lt; ", Msg : " &lt;&lt; data-&gt;getMsg() &lt;&lt; endl;
}

void test1(Data&lt;double, string&gt; *data)
{
    cout &lt;&lt; "value : " &lt;&lt; data-&gt;getValue() &lt;&lt; ", Msg : " &lt;&lt; data-&gt;getMsg() &lt;&lt; endl;
}
</code></pre> 
<h5><a id="3__154"></a>3. 模版继承</h5> 
<h6><a id="31__156"></a>3.1 严格模式</h6> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;

using namespace std;

/*
类带有模版，同时有子类继承当前类
    1. 自由模式
        子类带有和父类同名声明模版
    2. 严格模式【当前模式】
        子类在继承父类时，直接指定模版的具体类型，不得修改
*/

/*
MyCompare 类
    1. 声明了模版
    2. 声明纯虚函数
    3. MyCompare 是一个抽象类
*/
template &lt;typename T&gt;
class MyCompare
{
public:
    // 纯虚函数，并且使用了类声明的模版
    virtual bool compare(T t1, T t2) = 0;
};
/*
IntCompare 类
    1. 继承了 MyCompare 抽象类
    2. 继承父类的过程中，同时限制了模版对应的具体类型
    3. IntCompare 类没有声明模版

IntCompare 目标是一个【实现类】
    1. 必须实现 Compare 函数
    2. 父类 MyCompare 已经明确限制模版对应的具体类型为 int 类型
    3. IntCompare 目标实现的函数
        bool compare(int t1, int t2)
*/
class IntCompare : public MyCompare&lt;int&gt;
{
public:
    bool compare(int t1, int t2)
    {
        return t1 &gt; t2;
    }
};

int main(int argc, char const *argv[])
{
    /*
    bool compare(long t1, long t2) {...}
        在明确 模版对应的类型为 int 类型，实现上面的函数
        实例化的过程中，会出现报错：
        纯虚拟 函数 "MyCompare&lt;T&gt;::compare [其中 T=int]" 没有强制替代项
    */
    IntCompare * ic = new IntCompare;

    cout &lt;&lt; "ret : " &lt;&lt; ic-&gt;compare(30, 20) &lt;&lt; endl; // 1
    cout &lt;&lt; "ret : " &lt;&lt; ic-&gt;compare(10, 20) &lt;&lt; endl; // 0

    return 0;
}
</code></pre> 
<h6><a id="32__222"></a>3.2 自由模式</h6> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;

using namespace std;

/*
类带有模版，同时有子类继承当前类
    1. 自由模式【当前模式】
        子类带有和父类同名声明模版
    2. 妻管严模式
        子类在继承父类时，直接指定模版的具体类型，不得修改
*/

/*
MyCompare 类
    1. 声明了模版
    2. 声明纯虚函数
    3. MyCompare 是一个抽象类
*/
template &lt;typename T&gt;
class BaseHandler
{
public:
    // 纯虚函数，并且使用了类名声明的模版
    virtual void handler(T t) = 0;
};

/*
MyHander 继承抽象类 BaseHandler，同时
    1. 声明和 BaseHandler 同名模版
    2. 当前模版类型尚未明确
    3. 必须实现 void hander(T t) 函数
*/
template &lt;typename T&gt;
class MyHandler : public BaseHandler&lt;T&gt;
{
public:
    void handler(T t)
    {
        cout &lt;&lt; "数据情况 : " &lt;&lt; t &lt;&lt; endl;
    }
};

int main(int argc, char const *argv[])
{
    // 实例化 MyHandler 类对象，需要指定模版对应的具体类型
    MyHandler&lt;string&gt; * m1 = new MyHandler&lt;string&gt;;
    m1-&gt;handler("零零零零");

    MyHandler&lt;int&gt; * m2 = new MyHandler&lt;int&gt;;
    m2-&gt;handler(14);

    delete m1;
    delete m2;

    return 0;
}
</code></pre> 
<h5><a id="4__283"></a>4. 模版类的模版函数</h5> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;

using namespace std;

template &lt;typename T&gt;
class Test
{
public:
    // 当前函数使用的模版为当前 Test 类声明的模版
    void handler(T t) { cout &lt;&lt; "value : " &lt;&lt; t &lt;&lt; endl; }

    /*
    模版类内的函数，期望可以自定义模版，使用的模版数据形式，约束与当前类不同
    */
    template &lt;typename T2&gt;
    void my(T2 t) { cout &lt;&lt; "value : " &lt;&lt; t &lt;&lt; endl; }
};

int main(int argc, char const *argv[])
{
    Test&lt;string&gt; * test = new Test&lt;string&gt;;

    test-&gt;handler("零零零零");

    /*
    my 函数对应的模版类型，由实际参数决定，并不是实例化 Test 类型决定
    */
    test-&gt;my(3.14);

    return 0;
}

</code></pre> 
<h5><a id="5__320"></a>5. 返回值类型带有模版</h5> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;

using namespace std;

/*
K ==&gt; Key   键
V ==&gt; Value 值
*/
template &lt;typename K, typename V&gt;
class Data
{
public:
    Data() {}
    Data(K key, V value) : key(key), value(value) {}
    Data(const Data &amp; data) : key(data.key), value(data.value) {}
    ~Data() {}

    K getKey() { return key; }
    void setKey(K key) { this-&gt;key = key; }

    V getValue() { return value; }
    void setValue(V value) { this-&gt;value = value; }

    /*
    友元函数中，重载运算符操作，使用的模版并不是 Data 声明的模版
    而是函数自定义模版，通过实际参数 Data 类型中的模版情况，
    限制当前函数的模版类型

    【满足注意 Data 类型展示数据操作】
    */
    template &lt;typename K1, typename V1&gt;
    friend ostream &amp; operator&lt;&lt;(ostream &amp; o, Data&lt;K1, V1&gt; * data);

private:
    K key;
    V value;
};

template &lt;typename K1, typename V1&gt;
ostream &amp; operator&lt;&lt;(ostream &amp; o, Data&lt;K1, V1&gt; * data)
{
    o &lt;&lt; "Key : " &lt;&lt; data-&gt;getKey() &lt;&lt; ", Value : " &lt;&lt; data-&gt;getValue();
    return o;
}

template &lt;typename K, typename V&gt;
Data&lt;K, V&gt; *getData(K key, V value);

int main(int argc, char const *argv[])
{
    string name = "MY";
    Data&lt;string, int&gt; * data = getData(name, 3);
    cout &lt;&lt; data &lt;&lt; endl;

    Data&lt;double, int&gt; * data1 = getData(6.18, 9999);
    cout &lt;&lt; data1 &lt;&lt; endl;

    delete data;
    delete data1;

    return 0;
}

/*
外部函数自定义模版，返回值是 Data 类型，同时
利用当前函数的实际参数对 Data 中模版数据进行
约束限制，模版具体数据情况根据参数具体数据类型确定！
*/
template &lt;typename K, typename V&gt;
Data&lt;K, V&gt; * getData(K key, V value)
{
    return new Data&lt;K, V&gt;(key, value);
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/53204eea5ccb06be143f6cce0fbda671/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python中嵌套自定义类型的JSON序列化与反序列化</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/96fb80a07f613f373f690b8dee126ef9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何使用Python读取文本文件并回答问题？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>