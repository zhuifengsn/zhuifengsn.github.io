<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构——链表OJ题 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构——链表OJ题" />
<meta property="og:description" content="目录
1.给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。
2.给定一个带有头结点 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。
3.变形题：找到链表中倒数第k个节点
4.经典题：将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
结语
个人主页：大耳朵土土垚-CSDN博客
所属专栏：数据结构学习笔记
1.给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 示例 1：
输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5] 解题思路：
创建指针遍历链表找到对应节点删除；
创建两个指针变量cur和pre用来记录，cur表示当前遍历的节点，pre表示上一个节点如图所示
不要忘了有两种情况，当第一个节点就是对应节点时需要将头指针head改变 ；
如果忘记第一种情况就会发现以下示例：
图中null就是指pre为空指针的情况；
以下是完整代码实现： struct ListNode { int val; struct ListNode* next; }; struct ListNode* removeElements(struct ListNode* head, int val) { struct ListNode* cur = head; struct ListNode* pre = NULL; while (cur) { if (cur-&gt;val == val)//找到val值相同的节点时 { if (pre == NULL)//如果是第一个节点，也就是图中第②种 { cur = head-&gt;next; free(head); head = cur; } else//其他情况 { pre-&gt;next = cur-&gt;next; free(cur); cur = pre-&gt;next; } } else//不相同时 { pre = cur; cur = cur-&gt;next; } } return head; } 另外一种思路：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/e909840096fa7715ea6a6af1ee17b8f7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-21T13:58:55+08:00" />
<meta property="article:modified_time" content="2024-02-21T13:58:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构——链表OJ题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>目录</strong></p> 
<p style="margin-left:0px;"> </p> 
<p style="margin-left:0px;"><a href="#1.%E7%BB%99%E4%BD%A0%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E8%8A%82%E7%82%B9%C2%A0head%C2%A0%E5%92%8C%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%C2%A0val%C2%A0%EF%BC%8C%E8%AF%B7%E4%BD%A0%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%89%80%E6%9C%89%E6%BB%A1%E8%B6%B3%C2%A0Node.val%20%3D%3D%20val%C2%A0%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%8C%E5%B9%B6%E8%BF%94%E5%9B%9E%C2%A0%E6%96%B0%E7%9A%84%E5%A4%B4%E8%8A%82%E7%82%B9%C2%A0%E3%80%82" rel="nofollow">1.给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。</a></p> 
<p style="margin-left:0px;"><a href="#2.%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%B8%A6%E6%9C%89%E5%A4%B4%E7%BB%93%E7%82%B9%20head%20%E7%9A%84%E9%9D%9E%E7%A9%BA%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%8C%E8%BF%94%E5%9B%9E%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9%E3%80%82%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%A4%E4%B8%AA%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9%EF%BC%8C%E5%88%99%E8%BF%94%E5%9B%9E%E7%AC%AC%E4%BA%8C%E4%B8%AA%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9%E3%80%82" rel="nofollow">2.给定一个带有头结点 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。</a></p> 
<p style="margin-left:0px;"><a href="#3.%E5%8F%98%E5%BD%A2%E9%A2%98%EF%BC%9A%E6%89%BE%E5%88%B0%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9" rel="nofollow">3.变形题：找到链表中倒数第k个节点</a></p> 
<p style="margin-left:0px;"><a href="#4.%E7%BB%8F%E5%85%B8%E9%A2%98%EF%BC%9A%E5%B0%86%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%B9%B6%E8%BF%94%E5%9B%9E%E3%80%82%E6%96%B0%E9%93%BE%E8%A1%A8%E6%98%AF%E9%80%9A%E8%BF%87%E6%8B%BC%E6%8E%A5%E7%BB%99%E5%AE%9A%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E7%BB%84%E6%88%90%E7%9A%84%E3%80%82" rel="nofollow">4.经典题：将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</a></p> 
<p style="margin-left:0px;"><a href="#%E7%BB%93%E8%AF%AD" rel="nofollow">结语</a></p> 
<hr> 
<p>个人主页：<a href="https://blog.csdn.net/Renswc?spm=1010.2135.3001.5421" title="大耳朵土土垚-CSDN博客">大耳朵土土垚-CSDN博客</a></p> 
<p>所属专栏：<a href="https://blog.csdn.net/renswc/category_12577739.html" title="数据结构学习笔记">数据结构学习笔记</a></p> 
<p> </p> 
<p style="text-align:center;"><img src="https://images2.imgbox.com/e0/12/Z9rZdkXm_o.jpg" alt="46ea021929244f569b734890b6cd428a.jpeg"></p> 
<h2>1.给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</h2> 
<p><strong>示例 1：</strong></p> 
<p> </p> 
<p><img src="https://images2.imgbox.com/f0/11/fE08DOqN_o.jpg" alt="df2d7ecde8b848737a0ca6ac7c9a636f.jpeg"></p> 
<pre><strong>输入：</strong>head = [1,2,6,3,4,5,6], val = 6
<strong>输出：</strong>[1,2,3,4,5]</pre> 
<p>解题思路：</p> 
<p>创建指针遍历链表找到对应节点删除；</p> 
<p>创建两个指针变量cur和pre用来记录，cur表示当前遍历的节点，pre表示上一个节点如图所示</p> 
<p><img src="https://images2.imgbox.com/39/2d/KIYzJvg1_o.jpg" alt="3ff9993adfbe4e01b999e8896e3cfead.jpeg"></p> 
<p>不要忘了有两种情况，当第一个节点就是对应节点时需要将头指针head改变 ；</p> 
<p>如果忘记第一种情况就会发现以下示例：</p> 
<p><img src="https://images2.imgbox.com/66/e9/8ZBlsFAR_o.png" alt="c99019dab9c3478ba86c08c1c69e7e20.png"></p> 
<p>图中null就是指pre为空指针的情况；</p> 
<p>以下是完整代码实现： </p> 
<blockquote> 
 <pre><code>struct ListNode {
    int val;
    struct ListNode* next;
};
struct ListNode* removeElements(struct ListNode* head, int val) {
    struct ListNode* cur = head;
    struct ListNode* pre = NULL;
    while (cur)
    {
        if (cur-&gt;val == val)//找到val值相同的节点时
        {
            if (pre == NULL)//如果是第一个节点，也就是图中第②种
            {
                cur = head-&gt;next;
                free(head);
                head = cur;
            }
            else//其他情况
            {
                pre-&gt;next = cur-&gt;next;
                free(cur);
                cur = pre-&gt;next;
            }
        }
        else//不相同时
        {
            pre = cur;
            cur = cur-&gt;next;
        }
    }
    return head;
}</code></pre> 
</blockquote> 
<p>另外一种思路：</p> 
<p>遍历链表，把不是val节点拿出来尾插，这里就不细讲有兴趣的可以打在评论区或私信我哦~</p> 
<p>代码如下：</p> 
<pre><code>struct ListNode {
    int val;
    struct ListNode* next;
    
};
struct ListNode* removeElements(struct ListNode* head, int val) {
    struct ListNode* cur = head;
    struct ListNode* newhead = NULL;
    struct ListNode* tail = NULL;
    while (cur)
    {
        if (cur-&gt;val != val)
        {
            if (newhead == NULL)
            {
                tail = cur;
                newhead = cur;
            }
            else
            {
                tail-&gt;next = cur;
                tail = tail-&gt;next;
            }
            cur = cur-&gt;next;
            tail-&gt;next = NULL;

        }
        else
        {
            struct ListNode* pos = cur;
            cur = cur-&gt;next;
            free(pos);
        }
    }

    return newhead;
}</code></pre> 
<p> </p> 
<h2>2.给定一个带有头结点 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。</h2> 
<p><img src="https://images2.imgbox.com/64/a4/Veamlye2_o.png" alt="9775a355d8e643a4a7f4a67e6cfa45c9.png"></p> 
<p>解题思路：</p> 
<p>给fast，slow两个指针，fast走两步，slow走一步 ,当fast走到尾时，slow恰好走到中间。</p> 
<pre><code>struct ListNode* middleNode(struct ListNode* head) {
    struct ListNode* fast = head, *slow = head;
    while(fast!=NULL&amp;&amp;fast-&gt;next != NULL)
    {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
    }
    return slow;
}</code></pre> 
<p> </p> 
<h2>3.变形题：找到链表中倒数第k个节点</h2> 
<p>解题思路：</p> 
<p>还是快慢指针，只要fast与slow之间距离为k，那么当fast走到终点时，slow所在的节点就是倒数第k个节点</p> 
<p><img src="https://images2.imgbox.com/28/5b/FTmyPgIO_o.png" alt="a95ccf2e02f7435f98a87be76bfadc3a.png"></p> 
<p> </p> 
<pre><code>struct ListNode* FindKthToTail(struct ListNode* pListHead, int k ) {
    // write code here
struct ListNode* fast = pListHead,*slow = pListHead;
 for(int i = 0; i &lt; k; i++)//先让fast走k步
    {
        if(fast == NULL)//如果k大于链表长度记得要及时返回哦
         return NULL;
        fast = fast-&gt;next;
    
    }
while(fast)
{
   
    fast = fast-&gt;next;
    slow = slow-&gt;next;
}
return slow;
}</code></pre> 
<p>先让fast走k步拉开距离，然后fast与slow一起走，当fast为空指针时，slow即为倒数第k个节点；</p> 
<p> </p> 
<p> </p> 
<h2>4.经典题：将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</h2> 
<p><img src="https://images2.imgbox.com/7b/b9/QNhPvmBh_o.png" alt="763a016ac41a448d98cb2ddc9ac61ccd.png"></p> 
<p>解题思路：</p> 
<p>    取小的尾插</p> 
<pre><code>struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {

    struct ListNode* head = NULL,*tail = NULL;
     if(list1 == NULL)//注意有链表为空的情况，直接返回另一个链表
        return list2;
    if(list2 == NULL)
        return list1;
    while(list1 &amp;&amp; list2)//注意这里是一个链表结束就都结束，所以两个都要为真用&amp;&amp;
    {
     if(list1-&gt;val &lt;= list2-&gt;val)
     {
         if(head == NULL)
         {
             head = tail = list1;
         }
         else
         {
             tail-&gt;next = list1;
             tail = tail-&gt;next;
         }
         list1= list1-&gt;next;
     }
     else
     {  if(head == NULL)
         {
             head = tail = list2;
         }
         else
         {
             tail-&gt;next = list2;
             tail = tail-&gt;next;
         }
         list2= list2-&gt;next;
     }
    }
    if(list1 == NULL)
    {
        tail-&gt;next = list2;
    }
    else
    {
        tail-&gt;next = list1;
    }
    return head;
}</code></pre> 
<p> 要注意当有链表为空的情况，以及取小结束后的情况；</p> 
<p> </p> 
<h2>结语</h2> 
<p>链表尾插，我们可以用一个tail指针来记录尾插后的节点，尾插直接在tail节点后即可，这样就不用每次尾插都循环遍历，大大减少了时间复杂度 ，提高了运行效率。大家如果有什么问题或者想法欢迎打在评论区或私信我哦~</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ae51bb45e21e7fe3beadcbf432c16312/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">小程序--事件处理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/452e26e321337f7ea25aeec99ca3932e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">有向图的邻接表和邻接矩阵</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>