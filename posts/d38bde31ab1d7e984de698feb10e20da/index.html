<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>为什么spring单例要使用三级缓存 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="为什么spring单例要使用三级缓存" />
<meta property="og:description" content="熟悉spring框架的同学应该都知道spring单例使用的三级缓存，简单回顾下哪三级缓存，源码类：DefaultSingletonBeanRegistry
一级缓存：singletonObjects二级缓存：earlySingletonObjects三级缓存：singletonFactories 直接使用一级缓存不可以吗？ 一级缓存，也就是直接将单例bean缓存至singletonObjects，去除其他缓存。设想下面这个场景
创建单例A初始化单例A（单例A强依赖单例B），注入单例B从工厂中获取单例B发现不存在，则创建创建单例B初始化单例B（单例B强依赖单例A），注入单例A从工厂中获取单例A发现不存在（因为正在创建中），则创建？？？？？？ 没错，问题来了，循环依赖，死循环，直接凉凉。
直接使用二级缓存不可以吗？ 对于直接使用一级缓存的问题已经暴露，如何解决？那么有同学就要问了，那我在创建单例A时就直接将单例A放入缓存中不可以吗？这样不就解决了循环依赖问题？是的，这样处理是可以的。但是我们如何判断从工厂中获取的一个单例初始化完成了？对单例的所有依赖注入的属性进行一次判空来判断？依赖注入的实例是否完成了初始化？使用工厂中的单例还要各种判空是不是很恶心？增加二级缓存岂不快哉
使用二级缓存：earlySingletonObjects&#43;singletonObjects
创建单例A单例A放入二级缓存：earlySingletonObjects初始化单例A（单例A强依赖单例B），注入单例B从工厂中获取单例B发现不存在，则创建创建单例B单例B放入二级缓存：earlySingletonObjects初始化单例B（单例B强依赖单例A），注入单例A从一级缓存singletonObjects获取单例A，存在则返回，不存在继续查询二级缓存：earlySingletonObjects，如果不存在则创建单例A（此时发现循环依赖抛出异常），但是看到前面已经缓存在二级缓存中注入单例A（可能是未完成初始化的单例A）完成初始化单例B完成，移除二级缓存中的单例B，缓存单例B至一级缓存，返回单例B注入单例B完成初始化单例A完成，移除二级缓存中的单例A，缓存单例A至一级缓存，返回单例A 可以看到我们之前的问题全部迎刃而解，只要从工厂中的一级缓存中获取的单例均是完成了初始化，并且依赖注入的实例也均是完成了初始化，只是如果是循环依赖场景，可能得到的依赖注入时未完成初始化的，即某些依赖注入属性可能为null，例如：@Value注入的一些值。
为什么spring单例要使用三级缓存？ 那么二级缓存已经解决了问题，为什么还要引入三级缓存呢？设想下，如果我想要在读取二级缓存：earlySingletonObjects对象时统一增加一些日志或者其他处理动作，如何解决？在读取earlySingletonObjects对象实例后，对实例进行回调某些接口方法？当然没问题，可以看到spring对于非单例bean也采用该方法来处理前置、后置动作的回调。
else if (mbd.isPrototype()) { // It&#39;s a prototype -&gt; create a new instance. Object prototypeInstance = null; try { beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); } finally { afterPrototypeCreation(beanName); } bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); } // getNonSingletonFactoryBeanForTypeCheck方法中也有同样对prototype类型bean的前后置回调处理代码 但是每次修改回调动作都要对所有读取earlySingletonObjects对象的地方进行修改，岂不是很恶心？每次增加一个读取earlySingletonObjects对象的动作都要记得加入相应的回调。是不是很容器遗漏和出错？那么如果我们缓存的是一个接口而不是一个单例对象问题是不是就解决了呢？只需要对接口增加对应的动作即可，例如：
合并bean定义后回调：MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition自定义决定使用哪个构造器构造bean：SmartInstantiationAwareBeanPostProcessor.determineCandidateConstructors创建bean前的属性值处理回调：InstantiationAwareBeanPostProcessor.postProcessPropertyValues创建bean前的处理回调：InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation创建bean后的处理回调：InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation二级缓存bean的处理回调：SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference断言特殊bean的bean类型，例如FactoryBean：SmartInstantiationAwareBeanPostProcessor.predictBeanType 对于循环依赖注入的未完成初始化的单例，如果有特殊需求，期望保证其一些属性的提前注入，可以通过该扩展对提前曝光的对象进行一些个性化定制的处理，例如：将@Value的值提前从Environment中获取并注入到提前曝光的对象。而不需要修改框架代码，只需要增加对应的接口实现即可
总结 循环依赖已经完全解决了吗？并没有，对于构造器注入的循环依赖时无法解决的，这个是无解的#-_-!!!二级缓存是为了解决属性字段级别的循环依赖注入问题三级缓存是为了增强框架的扩展性 Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;a&#39;: Unsatisfied dependency expressed through field &#39;b&#39;; nested exception is org." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/d38bde31ab1d7e984de698feb10e20da/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-26T16:13:01+08:00" />
<meta property="article:modified_time" content="2020-07-26T16:13:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">为什么spring单例要使用三级缓存</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>熟悉spring框架的同学应该都知道spring单例使用的三级缓存，简单回顾下哪三级缓存，源码类：DefaultSingletonBeanRegistry</p> 
<ol><li>一级缓存：singletonObjects</li><li>二级缓存：earlySingletonObjects</li><li>三级缓存：singletonFactories</li></ol> 
<h2><a id="_7"></a>直接使用一级缓存不可以吗？</h2> 
<p>一级缓存，也就是直接将单例bean缓存至singletonObjects，去除其他缓存。设想下面这个场景</p> 
<ol><li>创建单例A</li><li>初始化单例A（单例A强依赖单例B），注入单例B</li><li>从工厂中获取单例B发现不存在，则创建</li><li>创建单例B</li><li>初始化单例B（单例B强依赖单例A），注入单例A</li><li>从工厂中获取单例A发现不存在（因为正在创建中），则创建？？？？？？</li></ol> 
<p>没错，问题来了，循环依赖，死循环，直接凉凉。</p> 
<h2><a id="_18"></a>直接使用二级缓存不可以吗？</h2> 
<p>对于直接使用一级缓存的问题已经暴露，如何解决？那么有同学就要问了，那我在创建单例A时就直接将单例A放入缓存中不可以吗？这样不就解决了循环依赖问题？是的，这样处理是可以的。但是我们如何判断从工厂中获取的一个单例初始化完成了？对单例的所有依赖注入的属性进行一次判空来判断？依赖注入的实例是否完成了初始化？使用工厂中的单例还要各种判空是不是很恶心？增加二级缓存岂不快哉<br> 使用二级缓存：earlySingletonObjects+singletonObjects</p> 
<ol><li>创建单例A</li><li>单例A放入二级缓存：earlySingletonObjects</li><li>初始化单例A（单例A强依赖单例B），注入单例B</li><li>从工厂中获取单例B发现不存在，则创建</li><li>创建单例B</li><li>单例B放入二级缓存：earlySingletonObjects</li><li>初始化单例B（单例B强依赖单例A），注入单例A</li><li>从一级缓存singletonObjects获取单例A，存在则返回，不存在继续查询二级缓存：earlySingletonObjects，如果不存在则创建单例A（此时发现循环依赖抛出异常），但是看到前面已经缓存在二级缓存中</li><li>注入单例A（可能是未完成初始化的单例A）完成</li><li>初始化单例B完成，移除二级缓存中的单例B，缓存单例B至一级缓存，返回单例B</li><li>注入单例B完成</li><li>初始化单例A完成，移除二级缓存中的单例A，缓存单例A至一级缓存，返回单例A</li></ol> 
<p>可以看到我们之前的问题全部迎刃而解，只要从工厂中的一级缓存中获取的单例均是完成了初始化，并且依赖注入的实例也均是完成了初始化，只是如果是循环依赖场景，可能得到的依赖注入时未完成初始化的，即某些依赖注入属性可能为null，例如：@Value注入的一些值。</p> 
<h2><a id="spring_36"></a>为什么spring单例要使用三级缓存？</h2> 
<p>那么二级缓存已经解决了问题，为什么还要引入三级缓存呢？设想下，如果我想要在读取二级缓存：earlySingletonObjects对象时统一增加一些日志或者其他处理动作，如何解决？在读取earlySingletonObjects对象实例后，对实例进行回调某些接口方法？当然没问题，可以看到spring对于非单例bean也采用该方法来处理前置、后置动作的回调。</p> 
<pre><code class="prism language-java"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isPrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// It's a prototype -&gt; create a new instance.</span>
	<span class="token class-name">Object</span> prototypeInstance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">beforePrototypeCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
		prototypeInstance <span class="token operator">=</span> <span class="token function">createBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">afterPrototypeCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	bean <span class="token operator">=</span> <span class="token function">getObjectForBeanInstance</span><span class="token punctuation">(</span>prototypeInstance<span class="token punctuation">,</span> name<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// getNonSingletonFactoryBeanForTypeCheck方法中也有同样对prototype类型bean的前后置回调处理代码</span>
</code></pre> 
<p>但是每次修改回调动作都要对所有读取earlySingletonObjects对象的地方进行修改，岂不是很恶心？每次增加一个读取earlySingletonObjects对象的动作都要记得加入相应的回调。是不是很容器遗漏和出错？那么如果我们缓存的是一个接口而不是一个单例对象问题是不是就解决了呢？只需要对接口增加对应的动作即可，例如：</p> 
<ul><li>合并bean定义后回调：MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition</li><li>自定义决定使用哪个构造器构造bean：SmartInstantiationAwareBeanPostProcessor.determineCandidateConstructors</li><li>创建bean前的属性值处理回调：InstantiationAwareBeanPostProcessor.postProcessPropertyValues</li><li>创建bean前的处理回调：InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation</li><li>创建bean后的处理回调：InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation</li><li>二级缓存bean的处理回调：SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference</li><li>断言特殊bean的bean类型，例如FactoryBean：SmartInstantiationAwareBeanPostProcessor.predictBeanType</li></ul> 
<p>对于循环依赖注入的未完成初始化的单例，如果有特殊需求，期望保证其一些属性的提前注入，可以通过该扩展对提前曝光的对象进行一些个性化定制的处理，例如：将@Value的值提前从Environment中获取并注入到提前曝光的对象。而不需要修改框架代码，只需要增加对应的接口实现即可</p> 
<h2><a id="_64"></a>总结</h2> 
<ol><li>循环依赖已经完全解决了吗？并没有，对于构造器注入的循环依赖时无法解决的，这个是无解的#-_-!!!</li><li>二级缓存是为了解决属性字段级别的循环依赖注入问题</li><li>三级缓存是为了增强框架的扩展性</li></ol> 
<pre><code class="prism language-java"><span class="token class-name">Caused</span> by<span class="token operator">:</span> <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span></span>UnsatisfiedDependencyException</span><span class="token operator">:</span> <span class="token class-name">Error</span> creating bean <span class="token keyword">with</span> <span class="token namespace">name</span> <span class="token string">'a'</span><span class="token operator">:</span> <span class="token class-name">Unsatisfied</span> dependency expressed through field <span class="token string">'b'</span><span class="token punctuation">;</span> nested exception is <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span></span>UnsatisfiedDependencyException</span><span class="token operator">:</span> <span class="token class-name">Error</span> creating bean <span class="token keyword">with</span> <span class="token namespace">name</span> <span class="token string">'b'</span><span class="token operator">:</span> <span class="token class-name">Unsatisfied</span> dependency expressed through field <span class="token string">'a'</span><span class="token punctuation">;</span> nested exception is <span class="token class-name"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span></span>BeanCurrentlyInCreationException</span><span class="token operator">:</span> <span class="token class-name">Error</span> creating bean <span class="token keyword">with</span> <span class="token namespace">name</span> <span class="token string">'a'</span><span class="token operator">:</span> <span class="token class-name">Requested</span> bean is currently in creation<span class="token operator">:</span> <span class="token class-name">Is</span> there an unresolvable circular reference<span class="token operator">?</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b5b481265e7a0cd3782abf2cce10010e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[GCC]告警信息梳理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/738fcc6ef2f74f42456e998fae9535b7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">7. MySql高级之优化SQL步骤</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>