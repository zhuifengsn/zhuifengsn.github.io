<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>实验二 单链表的操作 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="实验二 单链表的操作" />
<meta property="og:description" content="1．实验性质：设计性实验
2．要求：
（1）编程实现单链表的以下基本操作：建立单链表，查找单链表，插入单链表，删除单链表。
（2）采用单链表结构编程实现：两个有序单链表的归并运算。
3．目的：
（1）掌握线性表的链式存储结构；
（2）掌握单链表及其基本操作的实现。
实验步骤 编写一个提示信息输入的函数，在main函数中调用提示信息。定义单链表函数体。单链表初始化。根据需要的内容编写相应的函数体。通过函数调用，将所需的内容展示出来。调整代码，尽可能向所需内容靠近。 实验记录 先定义一个单链表并进行初始化
#define OK 1 #define ERROR 0 using namespace std; typedef int ElemType; //定义数据类型，相当于给int取别名为ElemType typedef struct LNode //定义单链表 { ElemType data; struct LNode *next; }LNode,*LinkList; typedef int Status; //定义数据类型，相当于给int取别名为Status Status InitList(LinkList &amp;L) //单链表初始化 { L = new LNode; L-&gt;next=NULL; //头指针为空 return OK; } 1. 查找单链表
LinkList p; //定义一个新的指针p LNode *LocateElem(LinkList L,ElemType e) //查找单链表 { p=L-&gt;next; while(p &amp;&amp; p-&gt;data != e) p=p-&gt;next; cout &lt;&lt; e &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/38fdf94b41f5cebaa92fbf070f06c1d1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-20T11:02:42+08:00" />
<meta property="article:modified_time" content="2023-11-20T11:02:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">实验二 单链表的操作</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0;text-align:justify;"><span style="color:#000000;">1．<strong>实验性质</strong>：设计性实验</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">2．<strong>要求：</strong></span></p> 
<p style="margin-left:0;"><span style="color:#000000;">（1）编程实现单链表的以下基本操作：建立单链表，查找单链表，插入单链表，删除单链表。</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">（2）采用单链表结构编程实现：两个</span>有序<span style="color:#000000;">单链表的归并运算。</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">3．<strong>目的：</strong></span></p> 
<p style="margin-left:0;"><span style="color:#000000;">（1）掌握线性表的链式存储结构；</span></p> 
<p style="margin-left:0;"><span style="color:#000000;">（2）掌握单链表及其基本操作的实现。</span></p> 
<hr> 
<h4 id="%E5%AE%9E%E9%AA%8C%E6%AD%A5%E9%AA%A4" style="margin-left:0px;"><span style="color:#000000;">实验步骤</span></h4> 
<ol><li>编写一个提示信息输入的函数，在main函数中调用提示信息。</li><li>定义单链表函数体。</li><li>单链表初始化。</li><li>根据需要的内容编写相应的函数体。</li><li>通过函数调用，将所需的内容展示出来。</li><li>调整代码，尽可能向所需内容靠近。</li></ol> 
<h4 id="%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95" style="margin-left:0px;text-align:justify;">实验记录</h4> 
<p>先定义一个单链表并进行初始化</p> 
<pre><code class="language-cpp">#define OK 1
#define ERROR 0

using namespace std;

typedef int ElemType;                //定义数据类型，相当于给int取别名为ElemType
typedef struct LNode                 //定义单链表
{
    ElemType data;
    struct LNode *next;
}LNode,*LinkList;
typedef int Status;                  //定义数据类型，相当于给int取别名为Status

Status InitList(LinkList &amp;L)         //单链表初始化
{
    L = new LNode;
    L-&gt;next=NULL;                    //头指针为空
    return OK;
}</code></pre> 
<p> 1. 查找单链表</p> 
<pre><code class="language-cpp">LinkList p;    //定义一个新的指针p
LNode *LocateElem(LinkList L,ElemType e)    //查找单链表
{
    p=L-&gt;next;
    while(p &amp;&amp; p-&gt;data != e)
        p=p-&gt;next;
    cout &lt;&lt; e &lt;&lt; "的位置是" &lt;&lt; p &lt;&lt; endl;
    return p;
}</code></pre> 
<p>2.  插入单链表</p> 
<pre><code class="language-cpp">Status ListInsert(LinkList &amp;L,int i,ElemType e)   //插入
{
    int j;
    p=L;j=0;
    while(p &amp;&amp; (j&lt;i-1))
    {
        p=p-&gt;next;
        ++j;
    }
    if(!p || j&gt;i-1)
    {
        cout &lt;&lt; "插入位置错误，请重新输入" &lt;&lt; endl;
        return ERROR;
    }
    LinkList s;
    s=new LNode;
    s-&gt;data=e;
    s-&gt;next=p-&gt;next;
    p-&gt;next=s;
    return OK;
}</code></pre> 
<p>3.  删除单链表</p> 
<pre><code class="language-cpp">Status ListDelete(LinkList &amp;L,int i)           //删除
{
    int j;
    p=L;j=0;
    while((p-&gt;next) &amp;&amp; (j&lt;i-1))
    {
        p=p-&gt;next;
        ++j;
    }
    if(!(p-&gt;next) || j&gt;i-1)
    {
        cout &lt;&lt; "删除位置错误，请重新输入" &lt;&lt; endl;
        return ERROR;
    }
    LinkList q;
    q=p-&gt;next;
    p-&gt;next=q-&gt;next;
    delete q;
    return OK;
}</code></pre> 
<p>4. 单链表的合并并显示</p> 
<pre><code class="language-cpp">void MergeList_L(LinkList &amp;LA,LinkList &amp;LB,LinkList &amp;LC)    //单链表合并
{
    LinkList pa;
    LinkList pb;
    LinkList pc;
    pa=LA-&gt;next;pb=LB-&gt;next;
    LC=LA;
    pc=LC;
    while(pa &amp;&amp; pb)
    {
        if(pa-&gt;data &lt;= pb-&gt;data)
        {
            pc-&gt;next=pa;
            pc=pa;
            pa=pa-&gt;next;
        }
        else
        {
            pc-&gt;next=pb;
            pc=pb;
            pb=pb-&gt;next;
        }
    }
    pc-&gt;next=pa?pa:pb;
    delete LB;
}

void Display_List(LinkList L)                 //显示合并后单链表信息
{
    p=L-&gt;next;
    while(p)
    {
        cout &lt;&lt; p-&gt;data &lt;&lt; " ";
        p=p-&gt;next;
    }
    cout &lt;&lt; endl;
}</code></pre> 
<p>根据实验要求编写需要显示的信息函数</p> 
<pre><code class="language-cpp">void show()
{
    cout &lt;&lt; "1----在单链表指定位置插入元素" &lt;&lt; endl;
    cout &lt;&lt; "2----获取单链表中指定元素位置" &lt;&lt; endl;
    cout &lt;&lt; "3----删除单链表指定位置元素" &lt;&lt; endl;
    cout &lt;&lt; "4----两个有序单链表的归并" &lt;&lt; endl;
    cout &lt;&lt; "5----显示单链表" &lt;&lt; endl;
    cout &lt;&lt; "    退出，输入一个负数" &lt;&lt; endl;
}</code></pre> 
<p>根据实验要求编写main函数</p> 
<p></p> 
<pre><code class="language-cpp">int main()
{
    show();
    int n;
    LinkList LA;
    LinkList LB;
    LinkList LC;
    InitList(LA);
    InitList(LB);
    int i;
    ElemType e;

    while(1)   //这里因为合并要使用两个单链表，因此在查找和插入数据的地方
               //就直接进行了两个单链表的操作，可以根据自己的需要进行修改，原理一样
    {
        cout &lt;&lt; "请输入操作代码：";
        cin &gt;&gt; n;
        if(n==1)
        {
            cout &lt;&lt; "请输入LA要插入的位置和元素：";
            cin &gt;&gt; i &gt;&gt; e;
            ListInsert(LA,i,e);
            cout &lt;&lt; "请输入LB要插入的位置和元素：";
            cin &gt;&gt; i &gt;&gt; e;
            ListInsert(LB,i,e);
        }
        else if(n==2)
        {
            cout &lt;&lt; "请输入LA要获取的元素：";
            cin &gt;&gt; e;
            *LocateElem(LA,e);
            cout &lt;&lt; "请输入LB要获取的元素：";
            cin &gt;&gt; e;
            *LocateElem(LB,e);
        }
        else if(n==3)
        {
            cout &lt;&lt; "请输入LA要删除的元素位置：";
            cin &gt;&gt; i;
            ListDelete(LA,i);
            cout &lt;&lt; "请输入LB要删除的元素位置：";
            cin &gt;&gt; i;
            ListDelete(LB,i);
        }
        else if(n==4)
        {
            MergeList_L(LA,LB,LC);
            cout &lt;&lt; "两个有序单链表归并之后是：";
            Display_List(LC);
        }
        else if(n==5)
        {
            cout &lt;&lt; "The list of LA is:";
            Display_List(LA);
            cout &lt;&lt; "The list of LB is:";
            Display_List(LB);
        }
        else if(n&lt;0)
        {
            break;
        }

        else
            cout &lt;&lt; "输入有误，请重新输入" &lt;&lt; endl;
    }
}
</code></pre> 
<hr> 
<h4 id="%E5%AE%9E%E9%AA%8C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98">实验中遇到的问题</h4> 
<p style="margin-left:0;text-align:justify;">1. 单链表的显示很难实现，只能通过类似顺序表的方式按照出现的顺序进行显示出来。</p> 
<p style="margin-left:0;text-align:justify;">2. 单链表的存储位置是随机的，没有固定的位置来进行存储，在查找单链表元素的位置时没法直观的表示出来，显示出来的位置是一个地址。</p> 
<p style="margin-left:0;text-align:justify;">3. 插入单链表的代码因前后逻辑顺序的缘故导致错误调试了很久，最后发现是顺序错误。</p> 
<p style="margin-left:0;text-align:justify;">4. 删除单链表采用的是顺序位置，并不是采用的地址来删除。</p> 
<p style="margin-left:0;text-align:justify;">5. 两个有序单链表的归并只适用于有序单链表的合并实现，对于无序的单链表没有办法得到想要的结果。</p> 
<hr> 
<p><a href="https://blog.csdn.net/Stonesaul/article/details/124361104?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170044894416800192289529%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=170044894416800192289529&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-11-124361104-null-null.142%5Ev96%5Epc_search_result_base4&amp;utm_term=saulstone&amp;spm=1018.2226.3001.4449" title="【精选】实验一 顺序表的操作_顺序表实验总结和心得-CSDN博客">【精选】实验一 顺序表的操作_顺序表实验总结和心得-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/Stonesaul/article/details/127268098?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170044894416800192289529%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=170044894416800192289529&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-9-127268098-null-null.142%5Ev96%5Epc_search_result_base4&amp;utm_term=saulstone&amp;spm=1018.2226.3001.4449" title="实验三 栈和队列的操作_栈的操作实验_Saulstone的博客-CSDN博客">实验三 栈和队列的操作_栈的操作实验_Saulstone的博客-CSDN博客</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7d4df12cb15ee4dbf5857db17c241322/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">影视类短视频怎么做伪原创</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9a6becf4c143405874dc2a637d8511af/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SQL Server Count()函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>