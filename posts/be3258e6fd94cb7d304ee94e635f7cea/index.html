<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>哈夫曼编码C&#43;&#43;实现 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="哈夫曼编码C&#43;&#43;实现" />
<meta property="og:description" content="#include&lt;iostream&gt; #include&lt;iomanip&gt; using namespace std; #pragma warning (disable: 4996) 类型定义
typedef struct {//哈夫曼树 int weight;//权值 int lch, rch, parent;//左右孩子，父结点 }HTNode,*HuffmanTree; 二级指针建立一个哈夫曼编码表
typedef char** HuffmanCode; void CreatHuffmanTree(HuffmanTree&amp; HT, int n) { //构造哈夫曼树 if (n &lt;= 1)return; int m = 2 * n - 1;//数组2n-1个元素 HT = new HTNode[m &#43; 1];//0号不用 for (int i = 1; i &lt;= m; i&#43;&#43;) { //将2n-1个元素的lch，rch，parent设置为0 HT[i].lch = 0; HT[i].rch = 0; HT[i].parent = 0; } for (int i = 1; i &lt;= n; i&#43;&#43;) cin &gt;&gt; HT[i]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/be3258e6fd94cb7d304ee94e635f7cea/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-22T22:20:17+08:00" />
<meta property="article:modified_time" content="2021-11-22T22:20:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">哈夫曼编码C&#43;&#43;实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <pre><code>#include&lt;iostream&gt;
#include&lt;iomanip&gt;
using namespace std;
#pragma warning (disable: 4996)</code></pre> 
<p>类型定义</p> 
<pre><code>typedef struct {//哈夫曼树
	int weight;//权值
	int lch, rch, parent;//左右孩子，父结点
}HTNode,*HuffmanTree;</code></pre> 
<p>二级指针建立一个哈夫曼编码表</p> 
<pre><code>typedef char** HuffmanCode;</code></pre> 
<pre><code>void CreatHuffmanTree(HuffmanTree&amp; HT, int n) {
    //构造哈夫曼树
	if (n &lt;= 1)return;
	int m = 2 * n - 1;//数组2n-1个元素
	HT = new HTNode[m + 1];//0号不用
	for (int i = 1; i &lt;= m; i++) {
		//将2n-1个元素的lch，rch，parent设置为0
		HT[i].lch = 0; HT[i].rch = 0; HT[i].parent = 0;
	}
	for (int i = 1; i &lt;= n; i++)
		cin &gt;&gt; HT[i].weight;//输入前n个元素的weight
	//初始化结束
	//建立哈夫曼树
	for (int i = n + 1; i &lt;= m; i++) {
		//合并产生n-1个结点，构造哈夫曼树
		int s1, s2;
		Select(HT, i - 1, s1, s2);//找到i以前的最小的俩下标，用s1，s2返回
		HT[s1].parent = i;
		HT[s2].parent = i;
		//parent的初值为0，如果parent不为0，则说明已经构造成树了，可以用来Select函数判定
		HT[i].lch = s1;
		HT[i].rch = s2;
		HT[i].weight = HT[s1].weight + HT[s2].weight;
	}

}</code></pre> 
<p>Select函数是哈夫曼算法的重要过程，找到未成树的叶子结点的两个最小权值结点，并用s1，s2返回下标</p> 
<pre><code>void Select(HuffmanTree HT, int n, int&amp; s1, int&amp; s2) {
	s1 = s2 = 0;
	for (int i = 1; i &lt;= n; i++) {
		if (HT[i].parent == 0) {
			s1 = i;
			break;
		}

	}//找一个未归树的结点开始判断

	for (int i = 1; i &lt;= n; i++) {
		if (HT[i].parent == 0 &amp;&amp; HT[i].weight &lt; HT[s1].weight)
			s1 = i;
	}
	for (int i = 1; i &lt;= n; i++) {
		if (HT[i].parent == 0 &amp;&amp; i != s1) {//排除掉s1
			s2 = i;
			break;
		}
	}//找一个未归树的结点开始判断
	for (int i = 1; i &lt;= n; i++) {
		if (HT[i].parent == 0 &amp;&amp; HT[i].weight &lt; HT[s2].weight &amp;&amp; i != s1)//排除掉s1
			s2 = i;
	}
}</code></pre> 
<p>构造哈夫曼编码</p> 
<p>从叶子一步一步向上回溯，找到自己的parent，然后得到自己是左还是右孩子</p> 
<pre><code>void CreateHuffmanCode(HuffmanTree&amp;HT,HuffmanCode&amp;HC,int n) {
	//从叶子到根逆向求每个字符的哈夫曼编码，储存在编码表HC中
	HC = new char* [n + 1];//分配n个字符编码的头指针矢量，第0个不放
	char* cd = new char[n];
	cd[n - 1] = '\0';
	for (int i = 1; i &lt;= n; i++) {//i为初始为叶子，后面为当前回溯结
		int start = n - 1, c = i, f = HT[i].parent;
		while (f != 0) {
			--start;
			if (HT[f].lch == c)
				cd[start] = '0';//左0
			else cd[start] = '1';//右1
			c = f; f = HT[f].parent;
			//向上回溯一级
		}
		HC[i] = new char[n - start];//分配该编码所需要的空间
		strcpy(HC[i], &amp;cd[start]);//从start开始复制
	}
	delete cd;
}</code></pre> 
<p>打印哈夫曼树表，setw是#include&lt;iomanip&gt;里面的，用来方便输出</p> 
<pre><code>void PrintHuffman(HuffmanTree HT, int n) {
	cout &lt;&lt; "index weight parents lchild rchild" &lt;&lt; endl;
	cout &lt;&lt; left;
	for (int i = 1; i &lt;= 2 * n - 1; i++) {
		cout &lt;&lt; setw(6) &lt;&lt; i &lt;&lt; " ";
		cout &lt;&lt; setw(6) &lt;&lt; HT[i].weight &lt;&lt; " ";
		cout &lt;&lt; setw(6) &lt;&lt; HT[i].parent &lt;&lt; " ";
		cout &lt;&lt; setw(6) &lt;&lt; HT[i].lch &lt;&lt; " ";
		cout &lt;&lt; setw(6) &lt;&lt; HT[i].rch &lt;&lt; " " &lt;&lt; endl;
	}
}</code></pre> 
<p>打印编码表</p> 
<pre><code>void PrintHuffmancode(HuffmanCode&amp;HC,int n) {
	cout &lt;&lt; "每个叶子的哈夫曼编码为" &lt;&lt; endl;
	for (int i = 1; i &lt;= n; i++) {
		cout &lt;&lt; HC[i] &lt;&lt; endl;
	}
}</code></pre> 
<p>测试函数test01</p> 
<pre><code>void test01() {
	HuffmanTree HT;
	HuffmanCode HC;
	int n=0;
	cin &gt;&gt; n;

	CreatHuffmanTree(HT, n);
	PrintHuffman(HT, n);
	CreateHuffmanCode(HT, HC, n);
	PrintHuffmancode(HC, n);

	//7 40 30 15 5 4 3 3

}</code></pre> 
<p> 结果</p> 
<p><img alt="" height="644" src="https://images2.imgbox.com/45/95/bzAU80cX_o.png" width="1200"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5cad3aafd7fbbf9b933049251c3890e8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何用python读取超大文本文档</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c96dfcb45bd205a49b83af281a07464e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构实验：链表的插入与删除</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>