<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c&#43;&#43;类和对象(一) - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c&#43;&#43;类和对象(一)" />
<meta property="og:description" content="目录
面对过程与面向对象的认识 类的引入
类的定义
类的访问限定符及封装
访问限定符：
【访问限定符说明】
封装：
类的实例化
类对象的存储方式
this指针的引出
面对过程与面向对象的认识 c语言是面向过程的，关注的是过程，分析出求解问题的过程，通过函数调用逐步解决问题。
c&#43;&#43;是面向对象的，关注的是对象，讲一件事情拆分成不同的对象，靠对象之间的交互完成。
比如要实现一个外卖系统，用c语言写的话，会关注过程上怎样去实现它：上架商品、点外卖、派送、点评……。用c&#43;&#43;的话，就关注对象：商家、骑手、用户。然后把有关商家、骑手、用户的信息归纳到各自的类中。
类的引入 在c语言中，结构体中只能定义变量，不能定义函数。在c&#43;&#43;中，结构体不仅可以定义变量，而且还可以定义函数。
//c&#43;&#43;中struct可以定义变量跟函数 struct student { void Init(const char*name, const char* sex,int age) { strcpy(_name, name); strcpy(_sex, sex); _age = age; } void Print() { cout &lt;&lt; _name &lt;&lt; &#34; &#34; &lt;&lt; _sex &lt;&lt; &#34; &#34; &lt;&lt; _age &lt;&lt; endl; } char _name[20]; char _sex[3]; int _age; }; int main() { student s1; s1.Init(&#34;张三&#34;, &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/b29f217d84d796c3429d6aa0c4822256/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-16T18:57:59+08:00" />
<meta property="article:modified_time" content="2022-06-16T18:57:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c&#43;&#43;类和对象(一)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E9%9D%A2%E5%AF%B9%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%A4%E8%AF%86%C2%A0-toc" style="margin-left:0px;"><a href="#%E9%9D%A2%E5%AF%B9%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%A4%E8%AF%86%C2%A0" rel="nofollow">面对过程与面向对象的认识 </a></p> 
<p id="%E7%B1%BB%E7%9A%84%E5%BC%95%E5%85%A5-toc" style="margin-left:0px;"><a href="#%E7%B1%BB%E7%9A%84%E5%BC%95%E5%85%A5" rel="nofollow">类的引入</a></p> 
<p id="%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:0px;"><a href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">类的定义</a></p> 
<p id="%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6%E5%8F%8A%E5%B0%81%E8%A3%85-toc" style="margin-left:0px;"><a href="#%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6%E5%8F%8A%E5%B0%81%E8%A3%85" rel="nofollow">类的访问限定符及封装</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6%EF%BC%9A" rel="nofollow">        访问限定符：</a></p> 
<p id="%E3%80%90%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6%E8%AF%B4%E6%98%8E%E3%80%91-toc" style="margin-left:80px;"><a href="#%E3%80%90%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6%E8%AF%B4%E6%98%8E%E3%80%91" rel="nofollow">【访问限定符说明】</a></p> 
<p id="%E5%B0%81%E8%A3%85%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E5%B0%81%E8%A3%85%EF%BC%9A" rel="nofollow">封装：</a></p> 
<p id="%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96-toc" style="margin-left:0px;"><a href="#%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96" rel="nofollow">类的实例化</a></p> 
<p id="%C2%A0%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%C2%A0%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F" rel="nofollow"> 类对象的存储方式</a></p> 
<p id="this%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E5%87%BA-toc" style="margin-left:0px;"><a href="#this%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E5%87%BA" rel="nofollow">this指针的引出</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E9%9D%A2%E5%AF%B9%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%A4%E8%AF%86%C2%A0">面对过程与面向对象的认识 </h2> 
<p>        c语言是面向过程的，关注的是过程，分析出求解问题的过程，通过函数调用逐步解决问题。</p> 
<p>        c++是面向对象的，关注的是对象，讲一件事情拆分成不同的对象，靠对象之间的交互完成。</p> 
<p>        比如要实现一个外卖系统，用c语言写的话，会关注过程上怎样去实现它：上架商品、点外卖、派送、点评……。用c++的话，就关注对象：商家、骑手、用户。然后把有关商家、骑手、用户的信息归纳到各自的类中。</p> 
<p><img alt="" height="390" src="https://images2.imgbox.com/82/b0/wBHkJKPx_o.png" width="922"></p> 
<h2 id="%E7%B1%BB%E7%9A%84%E5%BC%95%E5%85%A5">类的引入</h2> 
<p>        在c语言中，结构体中只能定义变量，不能定义函数。在c++中，结构体不仅可以定义变量，而且还可以定义函数。</p> 
<pre><code>//c++中struct可以定义变量跟函数
struct student
{
	void Init(const char*name, const char* sex,int age)
	{
		strcpy(_name, name);
		strcpy(_sex, sex);
		_age = age;
	}

	void Print()
	{
		cout &lt;&lt; _name &lt;&lt; " " &lt;&lt; _sex &lt;&lt; " " &lt;&lt; _age &lt;&lt; endl;
	}

	char _name[20];
	char _sex[3];
	int _age;
};

int main()
{
	student s1;
	s1.Init("张三", "男", 20);
	s1.Print();

	return 0;
}</code></pre> 
<p>        上面结构体的定义，在c++中更喜欢用class来代替。</p> 
<h2 id="%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89">类的定义</h2> 
<blockquote> 
 <p>        class ClassName</p> 
 <p>        {<!-- --></p> 
 <p></p> 
 <p>                //这里面写成员函数和成员变量</p> 
 <p></p> 
 <p>        };       //后面必须要有分号</p> 
</blockquote> 
<p>        class为定义类的关键字，ClassName为类的名字，这个名字可以随便取，但也要注意命名规范，{}中为类的主体。</p> 
<pre><code>//创建一个叫studen的学生类
class student
{
public:
	void Init(const char*name, const char* sex,int age)
	{
		strcpy(_name, name);
		strcpy(_sex, sex);
		_age = age;
	}

	void Print()
	{
		cout &lt;&lt; _name &lt;&lt; " " &lt;&lt; _sex &lt;&lt; " " &lt;&lt; _age &lt;&lt; endl;
	}

private:
	char _name[20];
	char _sex[3];
	int _age;
};

int main()
{

	student s1;
	s1.Init("张三", "男", 20);
	s1.Print();

	return 0;
}</code></pre> 
<h2 id="%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6%E5%8F%8A%E5%B0%81%E8%A3%85">类的访问限定符及封装</h2> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%C2%A0%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6%EF%BC%9A">        访问限定符：</h3> 
<p>        <img alt="" height="212" src="https://images2.imgbox.com/76/db/INjUo2Rf_o.png" width="620"></p> 
<p>        c++的封装方式：是用类将对象的属性与方法结合在一块，让对象更加完善。通过访问限定符来选择一些接口提供给外部的用户使用，如要给外部访问的就设置成public，不想让外部访问的就设置成private。</p> 
<h4 id="%E3%80%90%E8%AE%BF%E9%97%AE%E9%99%90%E5%AE%9A%E7%AC%A6%E8%AF%B4%E6%98%8E%E3%80%91">【访问限定符说明】</h4> 
<blockquote> 
 <p>1. public修饰的成员在类外可以直接被访问<br> 2. protected和private修饰的成员在类外不能直接被访问(此阶段protected可以理解成跟private是类似的，到了继承才有区别)<br> 3. 访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止<br> 4. class的默认访问权限为private，struct的默认权限为public(因为struct要兼容c)</p> 
</blockquote> 
<p>注：使用private私有限定符，只是限制在类外不能访问，但在类内是可以访问的。就好比一把锁，锁住房门后，外面的人就不能进入房子里面了，但在房子里面的人是可以随便使用房子里面的东西的。</p> 
<h3 id="%E5%B0%81%E8%A3%85%EF%BC%9A">封装：</h3> 
<p>        封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。</p> 
<p>        封装是为了更好的管理，可以这样理解：我们是如何管理列车的呢？如果我们什么都不管的话，或许就会跟印度火车一样挂满人。</p> 
<p class="img-center"><img alt="" height="318" src="https://images2.imgbox.com/75/9c/DOJX4qFl_o.png" width="382"></p> 
<p> 于是我们就建立一个高铁站，把这些东西全部给封装起来。只开放售票通道，其他都不用知道。可以在网上购票完成后，通过安检后，进入候车处等待检票时间到，在检票机上刷身份证通过后即可进入。经过这几道程序后便能井然有序的乘坐列车。类也是一样的，不想让别人看到或使用类成员的话就可以用privare、protected把成员封装起来，只开放一些成员函数来对类中的成员进行合理的分配。因此封装本质上就是一种管理。</p> 
<h2 id="%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96">类的实例化</h2> 
<p>         用类创建一个对象的过程，称为类的实例化。</p> 
<p><img alt="" height="408" src="https://images2.imgbox.com/ec/75/F8uSIhJh_o.png" width="968"></p> 
<blockquote> 
 <p>        1、类只是一个模型一样的东西，定义出类有哪些成员，定义出的类并不会被分配实际的内存空间来存储它。（就像一张建筑图纸，并没有实际的占地空间，只是告诉我们有什么东西可以来建造一栋房子）。<br>         2. 一个类可以实例化出多个对象，实例化出的对象占用实际的物理空间来存储类成员变量。<br>        做个比方。类实例化出的对象就像在现实中使用建筑图纸建造出的房子，类就像是设计图，只设计出需要什么东西，但是并没有实体的建筑存在，实例化出的对象才能存储数据，占用物理空间。</p> 
</blockquote> 
<p><img alt="" height="432" src="https://images2.imgbox.com/37/01/sNiH8S1w_o.png" width="1156"></p> 
<pre><code>class student
{
public:
	void Init(char name[], char sex[], int age)
	{
		strcpy(_name, name);
		strcpy(_sex, sex);
		_age = age;
	}

	void Print()
	{
		cout &lt;&lt; _name &lt;&lt; " " &lt;&lt; _sex &lt;&lt; " " &lt;&lt; _age &lt;&lt; endl;
	}

	char _name[20];
	char _sex[3];
	int _age;
};

int main()
{
    //实例化出多个对象
	student s1;
	s1.Init("张三","男",20);

	student s2;
	s2.Init("李四", "男", 21);

	return 0;
}</code></pre> 
<h2 id="%C2%A0%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"> 类对象的存储方式</h2> 
<p>        先来看看类的大小是多少。</p> 
<pre><code>class A
{
public:

	void setA(char a, int b)
	{
		_a = a;
		_b = b;
	}

	void PrintA()
	{
		cout &lt;&lt; _a &lt;&lt; " " &lt;&lt; _b&lt;&lt;endl;
	}

private:
	char _a;
	int _b;
};</code></pre> 
<p>        类既有成员函数又有成员变量，一个类的大小是如何计算的呢？</p> 
<p><img alt="" height="203" src="https://images2.imgbox.com/4a/d7/ldNzICGT_o.png" width="569"></p> 
<p>         得出的结果是8，咦？一个类中有成员函数还有成员变量怎么实例化出的对象大小却只有8呢？</p> 
<p>        其实不难理解，对象中存放的只是成员变量，并没有存放成员函数，而是把成员函数另外放到公共代码区里的。调用成员函数的时候都是同一个函数。</p> 
<p class="img-center"><img alt="" height="363" src="https://images2.imgbox.com/6c/ef/igcl542X_o.png" width="575"></p> 
<p><img alt="" height="245" src="https://images2.imgbox.com/12/2b/OmDqebbH_o.png" width="858"></p> 
<p>          为什么不把成员函数跟成员变量放一起呢？试想一下每个对象的成员变量是不一样的，但成员函数却是一样的，如果按照此存储方式存储的话每实例化出一个对象就会存储一份相同的代码，岂不是会造成空间的浪费吗。</p> 
<p class="img-center"><img alt="" height="281" src="https://images2.imgbox.com/17/6a/oZyAsXtZ_o.png" width="491"></p> 
<h2 id="this%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E5%87%BA">this指针的引出</h2> 
<pre><code>class Date
{
public:
	void InitDate(int year, int month, int day)
	{
		_year = year;
		_month = month;
		_day = day;
	}

	void PirntDate()
	{
		cout &lt;&lt; _year &lt;&lt; " " &lt;&lt; _month &lt;&lt; " " &lt;&lt; _day &lt;&lt; endl;
	}
private:
	int _year;
	int _month;
	int _day;
};

int main()
{
	//this指针的引出
	Date d1;
	d1.InitDate(2022, 6, 14);
	d1.PirntDate();

	Date d2;
	d2.InitDate(2002, 6, 15);
	d2.PirntDate();

	return 0;
}</code></pre> 
<p>        竟然它们调用的是同一个函数，那为什么打印出来的东西却是不一样的呢？</p> 
<p><img alt="" height="281" src="https://images2.imgbox.com/c5/44/JjlmgBqG_o.png" width="811"></p> 
<p>         因为有一个this的隐含指针，C++编译器给每个“非静态的成员函数“增加了一个隐藏的指针参<br> 数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即不需要用户来传递，编译器会自动完成。</p> 
<p><img alt="" height="419" src="https://images2.imgbox.com/84/9e/mL4rolV8_o.png" width="723"></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2c87073371e501b27244548dfa4457e9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">什么是多态？多态的具体体现是？JAVA的动态绑定机制是？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/931b922a9589f8854c346450c011133b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">一文讲懂SQL聚合函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>