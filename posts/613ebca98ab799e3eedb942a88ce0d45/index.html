<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C#多线程编程实例实战 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C#多线程编程实例实战" />
<meta property="og:description" content="C#多线程编程实例实战&lt;?xml:namespace prefix = o ns = &#34;urn:schemas-microsoft-com:office:office&#34; /&gt; 单个写入程序/多个阅读程序在.Net类库中其实已经提供了实现，即System.Threading.ReaderWriterLock类。本文通过对常见的单个写入/多个阅读程序的分析来探索c#的多线程编程。 问题的提出 所谓单个写入程序/多个阅读程序的线程同步问题，是指任意数量的线程访问共享资源时，写入程序（线程）需要修改共享资源，而阅读程序（线程）需要读取数据。在这个同步问题中，很容易得到下面二个要求： 1） 当一个线程正在写入数据时，其他线程不能写，也不能读。 2） 当一个线程正在读入数据时，其他线程不能写，但能够读。 在数据库应用程序环境中经常遇到这样的问题。比如说，有n个最终用户，他们都要同时访问同一个数据库。其中有m个用户要将数据存入数据库，n-m个用户要读取数据库中的记录。 很显然，在这个环境中，我们不能让两个或两个以上的用户同时更新同一条记录，如果两个或两个以上的用户都试图同时修改同一记录，那么该记录中的信息就会被破坏。 我们也不让一个用户更新数据库记录的同时，让另一用户读取记录的内容。因为读取的记录很有可能同时包含了更新和没有更新的信息，也就是说这条记录是无效的记录。 实现分析 规定任一线程要对资源进行写或读操作前必须申请锁。根据操作的不同，分为阅读锁和写入锁，操作完成之后应释放相应的锁。将单个写入程序/多个阅读程序的要求改变一下，可以得到如下的形式： 一个线程申请阅读锁的成功条件是：当前没有活动的写入线程。 一个线程申请写入锁的成功条件是：当前没有任何活动（对锁而言）的线程。 因此，为了标志是否有活动的线程，以及是写入还是阅读线程，引入一个变量m_nActive，如果m_nActive &gt; 0，则表示当前活动阅读线程的数目，如果m_nActive=0，则表示没有任何活动线程，m_nActive &lt;0，表示当前有写入线程在活动，注意m_nActive&lt;0，时只能取-1的值，因为只允许有一个写入线程活动。 为了判断当前活动线程拥有的锁的类型，我们采用了线程局部存储技术（请参阅其它参考书籍），将线程与特殊标志位关联起来。 申请阅读锁的函数原型为：public void AcquireReaderLock( int millisecondsTimeout )，其中的参数为线程等待调度的时间。函数定义如下： public void AcquireReaderLock( int millisecondsTimeout ) { // m_mutext 很快可以得到，以便进入临界区 m_mutex.WaitOne( ); // 是否有写入线程存在 bool bExistingWriter = ( m_nActive &lt; 0 ); if( bExistingWriter ) { //等待阅读线程数目加1,当有锁释放时，根据此数目来调度线程 m_nWaitingReaders&#43;&#43;; } else { //当前活动线程加&lt;?xml:namespace prefix = st1 ns = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/613ebca98ab799e3eedb942a88ce0d45/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2009-09-18T22:39:20+08:00" />
<meta property="article:modified_time" content="2009-09-18T22:39:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C#多线程编程实例实战</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="artical-content-bak main-content editor-side-new"> 
 <div class="con editor-preview-side" id="result"> 
  <div class="MsoNormal" align="center"> 
   <strong><span style="color:#0080ff;font-size:14.5pt;" lang="en-us">C#</span></strong><strong><span style="font-family:'宋体';color:#0080ff;font-size:14.5pt;">多线程编程实例实战</span></strong><strong><span style="color:#0080ff;font-size:14.5pt;" lang="en-us">&lt;?xml:namespace prefix = o ns = "urn:schemas-microsoft-com:office:office" /&gt;</span></strong> 
   <p><strong></strong></p> 
   <strong></strong> 
  </div> 
  <div style="text-align:left;line-height:200%;" class="MsoNormal" align="left"> 
   <span style="line-height:200%;font-family:'宋体';font-size:12pt;">　　单个写入程序<span lang="en-us">/</span>多个阅读程序在<span lang="en-us">.Net</span>类库中其实已经提供了实现，即<span lang="en-us">System.Threading.ReaderWriterLock</span>类。本文通过对常见的单个写入<span lang="en-us">/</span>多个阅读程序的分析来探索<span lang="en-us">c#</span>的多线程编程。<span lang="en-us"> <br></span><b>问题的提出 </b><span lang="en-us"><br></span>　　 所谓单个写入程序<span lang="en-us">/</span>多个阅读程序的线程同步问题，是指任意数量的线程访问共享资源时，写入程序（线程）需要修改共享资源，而阅读程序（线程）需要读取数据。在这个同步问题中，很容易得到下面二个要求：<span lang="en-us"> <br></span>　　<span lang="en-us"> 1</span>） 当一个线程正在写入数据时，其他线程不能写，也不能读。<span lang="en-us"> <br></span>　　<span lang="en-us"> 2</span>） 当一个线程正在读入数据时，其他线程不能写，但能够读。<span lang="en-us"> <br></span>　　 在数据库应用程序环境中经常遇到这样的问题。比如说，有<span lang="en-us">n</span>个最终用户，他们都要同时访问同一个数据库。其中有<span lang="en-us">m</span>个用户要将数据存入数据库，<span lang="en-us">n-m</span>个用户要读取数据库中的记录。<span lang="en-us"> <br></span>　　 很显然，在这个环境中，我们不能让两个或两个以上的用户同时更新同一条记录，如果两个或两个以上的用户都试图同时修改同一记录，那么该记录中的信息就会被破坏。<span lang="en-us"> <br></span>　　 我们也不让一个用户更新数据库记录的同时，让另一用户读取记录的内容。因为读取的记录很有可能同时包含了更新和没有更新的信息，也就是说这条记录是无效的记录。<span lang="en-us"> <br></span><b>实现分析 </b><span lang="en-us"><br></span>　　 规定任一线程要对资源进行写或读操作前必须申请锁。根据操作的不同，分为阅读锁和写入锁，操作完成之后应释放相应的锁。将单个写入程序<span lang="en-us">/</span>多个阅读程序的要求改变一下，可以得到如下的形式：<span lang="en-us"> <br></span>　　 一个线程申请阅读锁的成功条件是：当前没有活动的写入线程。<span lang="en-us"> <br></span>　　 一个线程申请写入锁的成功条件是：当前没有任何活动（对锁而言）的线程。<span lang="en-us"> </span>　　 因此，为了标志是否有活动的线程，以及是写入还是阅读线程，引入一个变量<span lang="en-us">m_nActive</span>，如果<span lang="en-us">m_nActive &gt; 0</span>，则表示当前活动阅读线程的数目，如果<span lang="en-us">m_nActive=0</span>，则表示没有任何活动线程，<span lang="en-us">m_nActive &lt;0</span>，表示当前有写入线程在活动，注意<span lang="en-us">m_nActive&lt;0</span>，时只能取<span lang="en-us">-1</span>的值，因为只允许有一个写入线程活动。<span lang="en-us"> <br></span>　　 为了判断当前活动线程拥有的锁的类型，我们采用了线程局部存储技术（请参阅其它参考书籍），将线程与特殊标志位关联起来。<span lang="en-us"> <br></span>　　 申请阅读锁的函数原型为：<span lang="en-us">public void AcquireReaderLock( int millisecondsTimeout )</span>，其中的参数为线程等待调度的时间。函数定义如下：<span lang="en-us"> </span></span> 
   <p></p> 
  </div> 
  <table class="MsoNormalTable" border="0" cellpadding="0"><tbody><tr><td style="border-bottom:#ece9d8;border-left:#ece9d8;border-top:#ece9d8;border-right:#ece9d8;"> 
      <div style="text-align:left;line-height:150%;" class="MsoNormal" align="left"> 
       <span style="line-height:150%;font-family:'宋体';font-size:10pt;" lang="en-us"><font color="#0000ff">public void AcquireReaderLock( int millisecondsTimeout ) <br><br>{ <br><br>// m_mutext</font></span> 
       <span style="line-height:150%;font-family:'宋体';font-size:10pt;"><font color="#0000ff">很快可以得到，以便进入临界区</font><font color="#0000ff"><span lang="en-us"> <br><br>m_mutex.WaitOne( ); <br><br>// </span>是否有写入线程存在</font><font color="#0000ff"><span lang="en-us"> <br><br>bool bExistingWriter = ( m_nActive &lt; 0 ); <br><br>if( bExistingWriter ) <br><br>{ //</span>等待阅读线程数目加<span lang="en-us">1,</span>当有锁释放时，根据此数目来调度线程</font><font color="#0000ff"><span lang="en-us"> <br><br>m_nWaitingReaders++; <br><br>} <br><br>else <br><br>{ //</span>当前活动线程加&lt;?xml:namespace prefix = st1 ns = "urn:schemas-microsoft-com:office:smarttags" /&gt;<span lang="en-us">1 </span><br><br></font><font color="#0000ff"><span lang="en-us">m_nActive++; <br><br>} <br><br>m_mutex.ReleaseMutex(); <br><br>//</span>存储锁标志为</font><font color="#0000ff"><span lang="en-us">Reader <br><br>System.LocalDataStoreSlot slot = Thread.GetNamedDataSlot(m_strThreadSlotName); <br><br>object obj = Thread.GetData( slot ); <br><br>LockFlags flag = LockFlags.None; <br><br>if( obj != null ) <br><br>flag = (LockFlags)obj ; <br><br>if( flag == LockFlags.None ) <br><br>{ <br><br>Thread.SetData( slot, LockFlags.Reader ); <br><br>} <br>else <br>{ <br>Thread.SetData( slot, (LockFlags)((int)flag | (int)LockFlags.Reader ) ); <br>} <br>if( bExistingWriter ) <br>{ //</span>等待指定的时间</font><span lang="en-us"><font color="#0000ff"> <br>this.m_aeReaders.WaitOne( millisecondsTimeout, true ); <br>} <br>} </font></span></span> 
       <p></p> 
      </div></td></tr></tbody></table> 
  <div style="text-align:left;line-height:200%;" class="MsoNormal" align="left"> 
   <span style="line-height:200%;font-family:'宋体';font-size:12pt;" lang="en-us"><br></span> 
   <span style="line-height:200%;font-family:'宋体';font-size:12pt;">　　 它首先进入临界区（用以在多线程环境下保证活动线程数目的操作的正确性）判断当前活动线程的数目，如果有写线程<span lang="en-us">(m_nActive&lt;0)</span>存在，则等待指定的时间并且等待的阅读线程数目加<span lang="en-us">1</span>。如果当前活动线程是读线程<span lang="en-us">(m_nActive&gt;=0)</span>，则可以让读线程继续运行。<span lang="en-us"> <br></span>　　 申请写入锁的函数原型为：<span lang="en-us">public void AcquireWriterLock( int millisecondsTimeout )</span>，其中的参数为等待调度的时间。函数定义如下：<span lang="en-us"> </span></span> 
   <p></p> 
  </div> 
  <table class="MsoNormalTable" border="0" cellpadding="0"><tbody><tr><td style="border-bottom:#ece9d8;border-left:#ece9d8;border-top:#ece9d8;border-right:#ece9d8;"> 
      <div style="text-align:left;line-height:150%;" class="MsoNormal" align="left"> 
       <span style="line-height:150%;font-family:'宋体';font-size:10pt;" lang="en-us"><font color="#800080">public void AcquireWriterLock( int millisecondsTimeout ) <br><br>{ <br>// m_mutext</font></span> 
       <span style="line-height:150%;font-family:'宋体';font-size:10pt;"><font color="#800080">很快可以得到，以便进入临界区</font><font color="#800080"><span lang="en-us"> <br>m_mutex.WaitOne( ); <br>// </span>是否有活动线程存在</font><font color="#800080"><span lang="en-us"> <br>bool bNoActive = m_nActive == 0; <br>if( !bNoActive ) <br>{ <br>m_nWaitingWriters++; <br>} <br>else <br>{ <br>m_nActive--; <br>} <br>m_mutex.ReleaseMutex(); <br>//</span>存储线程锁标志</font><font color="#800080"><span lang="en-us"> <br>System.LocalDataStoreSlot slot = Thread.GetNamedDataSlot( "myReaderWriterLockDataSlot" ); <br><br>object obj = Thread.GetData( slot ); <br><br>LockFlags flag = LockFlags.None; <br><br>if( obj != null ) <br><br>flag = (LockFlags)Thread.GetData( slot ); <br><br>if( flag == LockFlags.None ) <br><br>{ <br><br>Thread.SetData( slot, LockFlags.Writer ); <br><br>} <br><br>else <br><br>{ <br><br>Thread.SetData( slot, (LockFlags)((int)flag | (int)LockFlags.Writer ) ); <br><br>} <br><br>//</span>如果有活动线程，等待指定的时间</font><span lang="en-us"><font color="#800080"> <br><br>if( !bNoActive ) <br><br>this.m_aeWriters.WaitOne( millisecondsTimeout, true ); <br><br>} </font></span></span> 
       <p></p> 
      </div></td></tr></tbody></table> 
  <div style="text-align:left;line-height:200%;" class="MsoNormal" align="left"> 
   <span style="line-height:200%;font-family:'宋体';font-size:12pt;" lang="en-us"><br></span> 
   <span style="line-height:200%;font-family:'宋体';font-size:12pt;">　　 它首先进入临界区判断当前活动线程的数目，如果当前有活动线程存在，不管是写线程还是读线程（<span lang="en-us">m_nActive</span>），线程将等待指定的时间并且等待的写入线程数目加<span lang="en-us">1</span>，否则线程拥有写的权限。<span lang="en-us"> <br><br></span>　　 释放阅读锁的函数原型为：<span lang="en-us">public void ReleaseReaderLock()</span>。函数定义如下：<span lang="en-us"> </span></span> 
   <p></p> 
  </div> 
  <table class="MsoNormalTable" border="0" cellpadding="0"><tbody><tr><td style="border-bottom:#ece9d8;border-left:#ece9d8;border-top:#ece9d8;border-right:#ece9d8;"> 
      <div style="text-align:left;line-height:150%;" class="MsoNormal" align="left"> 
       <span style="line-height:150%;font-family:'宋体';font-size:10pt;" lang="en-us"><font color="#0000ff">public void ReleaseReaderLock() <br><br>{ <br><br>System.LocalDataStoreSlot slot = Thread.GetNamedDataSlot(m_strThreadSlotName ); <br><br>LockFlags flag = (LockFlags)Thread.GetData( slot ); <br><br>if( flag == LockFlags.None ) <br><br>{ <br>return; <br><br>} <br><br>bool bReader = true; <br><br>switch( flag ) <br><br>{ <br><br>case LockFlags.None: <br><br>break; <br><br>case LockFlags.Writer: <br><br>bReader = false; <br><br>break; <br><br>} <br><br>if( !bReader ) <br><br>return; <br><br>Thread.SetData( slot, LockFlags.None ); <br><br>m_mutex.WaitOne(); <br><br>AutoResetEvent autoresetevent = null; <br><br>this.m_nActive --; <br><br>if( this.m_nActive == 0 ) <br><br>{ <br><br>if( this.m_nWaitingReaders &gt; 0 ) <br><br>{ <br><br>m_nActive ++ ; <br><br>m_nWaitingReaders --; <br><br>autoresetevent = this.m_aeReaders; <br><br>} <br><br>else if( this.m_nWaitingWriters &gt; 0) <br><br>{ <br><br>m_nWaitingWriters--; <br><br>m_nActive --; <br><br>autoresetevent = this.m_aeWriters ; <br><br>} <br><br>} <br><br>m_mutex.ReleaseMutex(); <br><br>if( autoresetevent != null ) <br><br>autoresetevent.Set(); <br><br>} </font></span> 
       <p></p> 
      </div></td></tr></tbody></table> 
  <span style="font-family:'宋体';font-size:12pt;" lang="en-us"><br></span> 
  <span style="font-family:'宋体';font-size:12pt;">　　 释放阅读锁时，首先判断当前线程是否拥有阅读锁（通过线程局部存储的标志），然后判断是否有等待的阅读线程，如果有，先将当前活动线程加<span lang="en-us">1</span>，等待阅读线程数目减<span lang="en-us">1</span>，然后置事件为有信号。如果没有等待的阅读线程，判断是否有等待的写入线程，如果有则活动线程数目减<span lang="en-us">1</span>，等待的写入线程数目减<span lang="en-us">1</span>。释放写入锁与释放阅读锁的过程基本一致，可以参看源代码。<span lang="en-us"> <br><br></span>　　 注意在程序中，释放锁时，只会唤醒一个阅读程序，这是因为使用<span lang="en-us">AutoResetEvent</span>的原历，读者可自行将其改成<span lang="en-us">ManualResetEvent</span>，同时唤醒多个阅读程序，此时应令<span lang="en-us">m_nActive</span>等于整个等待的阅读线程数目。<span lang="en-us"> <br><br> </span></span> 
  <div style="text-align:left;line-height:200%;" class="MsoNormal" align="left"> 
   <b><span style="line-height:200%;font-family:'宋体';font-size:12pt;">测试 </span></b> 
   <span style="line-height:200%;font-family:'宋体';font-size:12pt;" lang="en-us"><br></span> 
   <span style="line-height:200%;font-family:'宋体';font-size:12pt;"> 测试程序取自<span lang="en-us">.Net FrameSDK</span>中的一个例子，只是稍做修改。测试程序如下，<span lang="en-us"> </span></span> 
   <p></p> 
  </div> 
  <table class="MsoNormalTable" border="0" cellpadding="0"><tbody><tr><td style="border-bottom:#ece9d8;border-left:#ece9d8;border-top:#ece9d8;border-right:#ece9d8;"> 
      <div style="text-align:left;line-height:150%;" class="MsoNormal" align="left"> 
       <span style="line-height:150%;font-family:'宋体';font-size:10pt;" lang="en-us"><font color="#008b8b">using System; <br><br>using System.Threading; <br><br>using MyThreading; <br><br>class Resource { <br><br>myReaderWriterLock rwl = new myReaderWriterLock(); <br><br>public void Read(Int32 threadNum) </font></span> 
      </div> 
      <div style="text-align:left;line-height:150%;" class="MsoNormal" align="left"> 
       <span style="line-height:150%;font-family:'宋体';font-size:10pt;" lang="en-us"><font color="#008b8b">{ <br>rwl.AcquireReaderLock(Timeout.Infinite); <br>try </font></span> 
      </div> 
      <div style="text-align:left;line-height:150%;" class="MsoNormal" align="left"> 
       <span style="line-height:150%;font-family:'宋体';font-size:10pt;" lang="en-us"><font color="#008b8b">{ <br>Console.WriteLine("Start Resource reading (Thread={0})", threadNum); <br>Thread.Sleep(250); <br>Console.WriteLine("Stop Resource reading (Thread={0})", threadNum); </font></span> 
      </div> 
      <div style="text-align:left;line-height:150%;" class="MsoNormal" align="left"> 
       <span style="line-height:150%;font-family:'宋体';font-size:10pt;" lang="en-us"><font color="#008b8b">} <br><br>finally </font></span> 
      </div> 
      <div style="text-align:left;line-height:150%;" class="MsoNormal" align="left"> 
       <span style="line-height:150%;font-family:'宋体';font-size:10pt;" lang="en-us"><font color="#008b8b">{ <br>rwl.ReleaseReaderLock(); <br>} <br><br>} </font></span> 
      </div><span style="line-height:150%;font-family:'宋体';font-size:10pt;" lang="en-us"><font color="#008b8b"> </font></span> 
      <div style="text-align:left;line-height:150%;" class="MsoNormal" align="left"> 
       <br>public void Write(Int32 threadNum) 
      </div> 
      <div style="text-align:left;line-height:150%;" class="MsoNormal" align="left">
        { 
       <br>rwl.AcquireWriterLock(Timeout.Infinite); 
       <br>try 
      </div> 
      <div style="text-align:left;line-height:150%;" class="MsoNormal" align="left"> 
       <span style="line-height:150%;font-family:'宋体';font-size:10pt;" lang="en-us"><font color="#008b8b">{ <br>Console.WriteLine("Start Resource writing (Thread={0})", threadNum); <br>Thread.Sleep(750); <br>Console.WriteLine("Stop Resource writing (Thread={0})", threadNum); </font></span> 
      </div> 
      <div style="text-align:left;line-height:150%;" class="MsoNormal" align="left"> 
       <span style="line-height:150%;font-family:'宋体';font-size:10pt;" lang="en-us"><font color="#008b8b">} <br><br>finally </font></span> 
      </div> 
      <div style="text-align:left;line-height:150%;" class="MsoNormal" align="left"> 
       <span style="line-height:150%;font-family:'宋体';font-size:10pt;" lang="en-us"><font color="#008b8b">{ <br>rwl.ReleaseWriterLock(); <br>} <br><br>} <br><br>} <br><br>class App </font></span> 
      </div> 
      <div style="text-align:left;line-height:150%;" class="MsoNormal" align="left"> 
       <span style="line-height:150%;font-family:'宋体';font-size:10pt;" lang="en-us"><font color="#008b8b">{ <br>static Int32 numAsyncOps = 20; <br><br>static AutoResetEvent asyncOpsAreDone = new AutoResetEvent(false); <br><br>static Resource res = new Resource(); <br>public static void Main() </font></span> 
      </div> 
      <div style="text-align:left;line-height:150%;" class="MsoNormal" align="left"> 
       <span style="line-height:150%;font-family:'宋体';font-size:10pt;" lang="en-us"><font color="#008b8b">{ <br>for (Int32 threadNum = 0; threadNum &lt; 20; threadNum++) </font></span> 
      </div> 
      <div style="text-align:left;line-height:150%;" class="MsoNormal" align="left"> 
       <span style="line-height:150%;font-family:'宋体';font-size:10pt;" lang="en-us"><font color="#008b8b">{ <br>ThreadPool.QueueUserWorkItem(new WaitCallback(UpdateResource), threadNum); <br>} <br><br>asyncOpsAreDone.WaitOne(); <br><br>Console.WriteLine("All operations have completed."); <br><br>Console.ReadLine(); <br><br>} <br><br>// The callback method's signature MUST match that of a System.Threading.TimerCallback <br><br>// delegate (it takes an Object parameter and returns void) <br><br>static void UpdateResource(Object state) { <br><br>Int32 threadNum = (Int32) state; <br><br>if ((threadNum % 2) != 0) res.Read(threadNum); <br><br>else res.Write(threadNum); <br><br>if (Interlocked.Decrement(ref numAsyncOps) == 0) <br><br>asyncOpsAreDone.Set(); <br><br>} <br>} </font></span> 
       <p></p> 
      </div></td></tr></tbody></table> 
  <div class="MsoNormal"> 
   <span style="font-family:'宋体';font-size:12pt;" lang="en-us"><br></span> 
   <span style="font-family:'宋体';font-size:12pt;">　　 从测试结果中可以看出，可以满足单个写入程序<span lang="en-us">\</span>多个阅读程序的实现要求。</span> 
  </div> 
 </div> 
</div> 
<p>转载于:https://blog.51cto.com/qianshao/203183</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/35cc09c6ccb65c3feaeac7b2ef4f5063/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vnc的使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3530f201bbffd76fc3f3daaab2319a30/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">dicom学习笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>