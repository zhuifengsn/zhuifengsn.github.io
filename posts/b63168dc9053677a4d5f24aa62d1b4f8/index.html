<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Python入门教程】OpenCV库简介 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Python入门教程】OpenCV库简介" />
<meta property="og:description" content="1. OpenCV简介 Opencv（Open Source Computer Vision Library）是一个基于开源发行的跨平台计算机视觉库，它实现了图像处理和计算机视觉方面的很多通用算法，已成为计算机视觉领域最有力的研究工具。在这里我们要区分两个概念：图像处理和计算机视觉的区别：图像处理侧重于“处理”图像–如增强，还原，去噪，分割等等；而计算机视觉重点在于使用计算机来模拟人的视觉，因此模拟才是计算机视觉领域的最终目标。
OpenCV用C&#43;&#43;语言编写，它具有C &#43;&#43;，Python，Java和MATLAB接口，并支持Windows，Linux，Android和Mac OS， 如今也提供对于C#、Ch、Ruby，GO的支持
1.1 OpenCV发展历史
OpenCV于1999年由Intel建立，如今由Willow Garage公司提供支持。
OpenCV 0.X
1999年1月，CVL项目启动。主要目标是人机界面，能被UI调用的实时计算机视觉库，为Intel处理器做了特定优化。
2000年6月，第一个开源版本OpenCV alpha 3发布。
2000年12月，针对linux平台的OpenCV beta 1发布。
OpenCV 1.X
OpenCV 最初基于C语言开发，API也都是基于C的，面临内存管理、指针等C语言固有的麻烦。
2006年10月, 正式发布OpenCV 1.0版本，同时支持mac os系统和一些基础的机器学习方法，如神经网络、随机森林等，来完善对图像处理的支持。
2009年9月，OpenCV 1.2（beta2.0）发布。
OpenCV 2.X
当C&#43;&#43;流行起来，OpenCV 2.x发布，其尽量使用C&#43;&#43;而不是C，但是为了向前兼容，仍保留了对C API的支持。
2009年9月2.0 beta发布，主要使用CMake构建。
2010年3月：2.1发布
2010年12月6日，OpenCV 2.2发布
2011年8月，OpenCV 2.3发布。
2012年4月2日，发布OpenCV 2.4.
OpenCV 3.X
随着3.x的发布，1.x的C API将被淘汰不再被支持，以后C API可能通过C&#43;&#43;源代码自动生成。3.x与2.x不完全兼容，与2.x相比，主要的不同之处在于OpenCV 3.x 的大部分方法都使用了OpenCL加速。
2014年8月， 3.0 alpha发布，除大部分方法都使用OpenCL加速外，3.x默认包含以及使用IPP(一套跨平台的软件函数库)
2017年8月，发布3.3版本，OpenCV开始支持C&#43;&#43; 11构建，同时加强对神经网络的支持。
OpenCV 4.X
2018年10月4.0.0发布，OpenCV开始需要支持C&#43;&#43;11的编译器才能编译，同时对几百个基础函数使用&#34;wide universal intrinsics&#34;重写,极大改善了opencv处理图像的性能。
1.2 OpenCV应用领域
1、人机互动
2、物体识别" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/b63168dc9053677a4d5f24aa62d1b4f8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-12T11:52:53+08:00" />
<meta property="article:modified_time" content="2023-09-12T11:52:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Python入门教程】OpenCV库简介</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <div id="article_content"> 
  <div id="content_views"> 
   <h3 style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">1. OpenCV简介</span></span></span></h3> 
   <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">  Opencv（Open Source Computer Vision Library）是一个基于开源发行的跨平台计算机视觉库，它实现了图像处理和计算机视觉方面的很多通用算法，已成为计算机视觉领域最有力的研究工具。在这里我们要区分两个概念：图像处理和计算机视觉的区别：图像处理侧重于“处理”图像–如增强，还原，去噪，分割等等；而计算机视觉重点在于使用计算机来模拟人的视觉，因此模拟才是计算机视觉领域的最终目标。<br>   OpenCV用C++语言编写，它具有C ++，Python，Java和MATLAB接口，并支持Windows，Linux，Android和Mac OS， 如今也提供对于C#、Ch、Ruby，GO的支持</span></span></span></p> 
   <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a id="11_OpenCV_3"></a>1.1 OpenCV发展历史</span></span></span></p> 
   <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">  OpenCV于1999年由Intel建立，如今由Willow Garage公司提供支持。<br>   <strong>OpenCV 0.X</strong><br>   1999年1月，CVL项目启动。主要目标是人机界面，能被UI调用的实时计算机视觉库，为Intel处理器做了特定优化。<br>   2000年6月，第一个开源版本OpenCV alpha 3发布。<br>   2000年12月，针对linux平台的OpenCV beta 1发布。<br>   <strong>OpenCV 1.X</strong><br>   OpenCV 最初基于C语言开发，API也都是基于C的，面临内存管理、指针等C语言固有的麻烦。<br>   2006年10月, 正式发布OpenCV 1.0版本，同时支持mac os系统和一些基础的机器学习方法，如神经网络、随机森林等，来完善对图像处理的支持。<br>   2009年9月，OpenCV 1.2（beta2.0）发布。<br>   <strong>OpenCV 2.X</strong><br>   当C++流行起来，OpenCV 2.x发布，其尽量使用C++而不是C，但是为了向前兼容，仍保留了对C API的支持。<br>   2009年9月2.0 beta发布，主要使用CMake构建。<br>   2010年3月：2.1发布<br>   2010年12月6日，OpenCV 2.2发布<br>   2011年8月，OpenCV 2.3发布。<br>   2012年4月2日，发布OpenCV 2.4.<br>   <strong>OpenCV 3.X</strong><br>   随着3.x的发布，1.x的C API将被淘汰不再被支持，以后C API可能通过C++源代码自动生成。3.x与2.x不完全兼容，与2.x相比，主要的不同之处在于OpenCV 3.x 的大部分方法都使用了OpenCL加速。<br>   2014年8月， 3.0 alpha发布，除大部分方法都使用OpenCL加速外，3.x默认包含以及使用IPP(一套跨平台的软件函数库)<br>   2017年8月，发布3.3版本，OpenCV开始支持C++ 11构建，同时加强对神经网络的支持。<br>   <strong>OpenCV 4.X</strong><br>   2018年10月4.0.0发布，OpenCV开始需要支持C++11的编译器才能编译，同时对几百个基础函数使用"wide universal intrinsics"重写,极大改善了opencv处理图像的性能。</span></span></span></p> 
   <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a id="12_OpenCV_26"></a>1.2 OpenCV应用领域</span></span></span></p> 
   <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">  1、人机互动<br>   2、物体识别<br>   3、 图像分割<br>     图像分割就是把图像分成若干个特定的、具有独特性质的区域并提出感兴趣目标的技术和过程。</span></span></span></p> 
   <div> 
    <p class="img-center"><img alt="" src="https://images2.imgbox.com/79/f6/PapqeEwo_o.png" width="420"></p> 
   </div> 
   <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">  4、人脸识别<br>   5、动作识别<br>   6、 运动跟踪<br>   7、机器人<br>   8、运动分析<br>   9、机器视觉<br>   10、结构分析<br>   11、汽车安全驾驶</span></span></span></p> 
   <h3 style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a id="2_OpenCV_42"></a>2. OpenCV图像处理原理</span></span></span></h3> 
   <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">  一般的图像(模拟图像)不能直接用计算机来处理，必须先将图像转化为数字图像。把模拟图像分割成一个个像素，每个像素的亮度或灰度值用一个整数表示——<strong>图像的数字化</strong></span></span></span></p> 
   <div> 
    <p class="img-center"><img alt="" src="https://images2.imgbox.com/47/15/h8IessPp_o.png" width="420"></p> 
   </div> 
   <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a id="21__47"></a>2.1 灰度图像数字化</span></span></span></p> 
   <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">  所谓的数字化，其实就是化成同行同列的二维数组，而每个坐标存的就是相关的灰度值（0-255）(为什么是0-255？一个字节存放8bit，而图的储存一般都是以uint8类型存放，同时计算机时按照二进制存放数值，也就是2的8次方，也就是256）</span></span></span></p> 
   <div> 
    <p class="img-center"><img alt="" src="https://images2.imgbox.com/51/44/N5yx0l4c_o.png" width="400"></p> 
   </div> 
   <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><strong>实例：</strong></span></span></span></p> 
   <div> 
    <p class="img-center"><img alt="" src="https://images2.imgbox.com/4a/19/atzWp50q_o.png" width="500"></p> 
   </div> 
   <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"><strong>补充：色彩深度与灰阶</strong></span></span></span></p> 
   <div> 
    <table border="1" cellspacing="0"><thead><tr><th style="background-color:#eff3f5;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;">色彩深度</span></span></th><th style="background-color:#eff3f5;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;">灰阶</span></span></th></tr></thead><tbody><tr><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">色彩深度（Depth of Color），色彩深度又叫色彩位数。视频画面中红、绿、蓝三个颜色通道中每种颜色为N位，总的色彩位数则为3N，色彩深度也就是视频设备所能辨析的色彩范围。目前有18bit、24bit、30bit、36bit、42bit和48bit位等多种。24位色被称为真彩色，R、G、B各8bit，常说的8bit，色彩总数为1670万，如手机参数，多少万色素就这个概念。</span></span></span></td><td style="border-color:#dddddd;vertical-align:middle;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;">通常来说，液晶屏幕上人们肉眼所见的一个点，即一个像素，它是由红、绿、蓝（RGB）三原色组成的。每一个基色，其背后的光源都可以显现出不同的亮度级别。而灰阶代表了由最暗到最亮之间不同亮度的层次级别。把三基色每一个颜色从纯色（如纯红）不断变暗到黑的过程中的变化级别划分成为色彩的灰阶，并用数字表示，就是最常见的色彩存储原理。这中间层级越多，所能够呈现的画面效果也就越细腻。以8bit 为例，我们就称之为256灰阶。</span></span></span></td></tr></tbody></table> 
   </div> 
   <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a id="22__60"></a>2.2 彩色像数字化</span></span></span></p> 
   <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">  彩色像数字化原理同灰度图像数字化，只不过彩色图像为三通道图像且可以拆分成三张同等像素的灰度图，由下图可知，每三个BGR就组成了一张图片的一列。</span></span></span></p> 
   <div> 
    <p class="img-center"><img alt="" src="https://images2.imgbox.com/f7/4f/Ypme93ve_o.png" width="700"></p> 
   </div> 
   <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">  数字图像处理的实质就是通过对数字图像中像素数据的判断，依据处理或识别要求，最后<strong>逐个像素修改像素的灰度值</strong>。</span></span></span></p> 
   <h3 style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a id="3_OpenCV_67"></a>3. OpenCV常用操作</span></span></span></h3> 
   <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a id="31__68"></a>3.1 灰度化处理</span></span></span></p> 
   <pre class="has" style="margin-left:0;"><code class="language-prettyprint">&lt;span style="color:rgba(0, 0, 0, 0.75)"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span style="color:#000000"&gt;&lt;code class="language-python"&gt;&lt;span style="color:#5c6370"&gt;#读入原始图像&lt;/span&gt;
img&lt;span style="color:#669900"&gt;=&lt;/span&gt;cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;imread&lt;span style="color:#999999"&gt;(&lt;/span&gt;&lt;span style="color:#669900"&gt;'test.jpg'&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt;
&lt;span style="color:#5c6370"&gt;#灰度化处理&lt;/span&gt;
gray&lt;span style="color:#669900"&gt;=&lt;/span&gt;cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;cvtColor&lt;span style="color:#999999"&gt;(&lt;/span&gt;img&lt;span style="color:#999999"&gt;,&lt;/span&gt;cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;COLOR_BGR2GRAY&lt;span style="color:#999999"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
   <div> 
    <p class="img-center"><img alt="" src="https://images2.imgbox.com/75/c7/0xa9mj3Y_o.png" width="500"></p> 
   </div> 
   <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">  <strong>图片的灰度化</strong>：将一个像素点的三个颜色变量相等，R=G=B，此时该值称为灰度值，图片灰度化可以有效减少数字图片计算量</span></span></span></p> 
   <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a id="32__80"></a>3.2 二值化处理</span></span></span></p> 
   <pre class="has" style="margin-left:0;"><code class="language-prettyprint">&lt;span style="color:rgba(0, 0, 0, 0.75)"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span style="color:#000000"&gt;&lt;code class="language-python"&gt;&lt;span style="color:#5c6370"&gt;#二值化处理&lt;/span&gt;
ret&lt;span style="color:#999999"&gt;,&lt;/span&gt;im_fixed&lt;span style="color:#669900"&gt;=&lt;/span&gt;cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;threshold&lt;span style="color:#999999"&gt;(&lt;/span&gt;gray&lt;span style="color:#999999"&gt;,&lt;/span&gt;&lt;span style="color:#98c379"&gt;50&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt;&lt;span style="color:#98c379"&gt;255&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt;cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;THRESH_BINARY&lt;span style="color:#999999"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
   <div> 
    <p class="img-center"><img alt="" src="https://images2.imgbox.com/9c/17/fNs8ATEk_o.png" width="700"></p> 
   </div> 
   <span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;">  二值化处理：将一个像素点的值突出为0,255，使得图片呈现黑白两种颜色。在灰度图像中像素值在0~255,二值化后图像中像素值为0或255。</span></span> 
   <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">  CV_THRESH_BINARY, 表示如果当前像素点的灰度值大于阈值则将输出图像的对应位置像素值置为255，否则为0。在opencv常用的阈值处理函数除上述演示外还有四种，分别是<strong>THRESH_BINARY_INV、THRESH_TRUNC、THRESH_TOZERO、THRESH_TOZERO_INV</strong>。</span></span></span></p> 
   <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a id="33__90"></a>3.3 滤波</span></span></span></p> 
   <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">  滤波是根据原有图像的某个像素的周围像素来确定新的像素值，滤波器主要的作用是用来消去噪声的，消除图像中的不合理的像素点。</span></span></span></p> 
   <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a id="331__92"></a>3.3.1 均值滤波（通过求与单位矩阵做内积和的平均值做图像处理）</span></span></span></p> 
   <pre class="has" style="margin-left:0;"><code class="language-prettyprint">&lt;span style="color:rgba(0, 0, 0, 0.75)"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span style="color:#000000"&gt;&lt;code class="language-python"&gt;blur &lt;span style="color:#669900"&gt;=&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;blur&lt;span style="color:#999999"&gt;(&lt;/span&gt;img&lt;span style="color:#999999"&gt;,&lt;/span&gt;&lt;span style="color:#999999"&gt;(&lt;/span&gt;&lt;span style="color:#98c379"&gt;5&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt;&lt;span style="color:#98c379"&gt;5&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt; 
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
   <div> 
    <p class="img-center"><img alt="" src="https://images2.imgbox.com/44/91/uhKuoeEG_o.png" width="500"></p> 
   </div> 
   <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a id="332___98"></a>3.3.2 高斯滤波 （根据正态分布处理图像，越靠近中心点，值越接近）</span></span></span></p> 
   <pre class="has" style="margin-left:0;"><code class="language-prettyprint">&lt;span style="color:rgba(0, 0, 0, 0.75)"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span style="color:#000000"&gt;&lt;code class="language-python"&gt;blur &lt;span style="color:#669900"&gt;=&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;GaussianBlur&lt;span style="color:#999999"&gt;(&lt;/span&gt;img&lt;span style="color:#999999"&gt;,&lt;/span&gt;&lt;span style="color:#999999"&gt;(&lt;/span&gt;&lt;span style="color:#98c379"&gt;5&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt;&lt;span style="color:#98c379"&gt;5&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt;， &lt;span style="color:#98c379"&gt;0&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt; 
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
   <div> 
    <p class="img-center"><img alt="" src="https://images2.imgbox.com/52/ae/4H6N49po_o.png" width="500"></p> 
   </div> 
   <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a id="333___105"></a>3.3.3 中值滤波 （根据正态分布处理图像，越靠近中心点，值越接近）</span></span></span></p> 
   <pre class="has" style="margin-left:0;"><code class="language-prettyprint">&lt;span style="color:rgba(0, 0, 0, 0.75)"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span style="color:#000000"&gt;&lt;code class="language-python"&gt;blur &lt;span style="color:#669900"&gt;=&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;medianBlur&lt;span style="color:#999999"&gt;(&lt;/span&gt;img&lt;span style="color:#999999"&gt;,&lt;/span&gt;&lt;span style="color:#98c379"&gt;5&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt; 
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
  </div> 
 </div> 
</div> 
<div> 
 <div> 
  <p class="img-center"><img alt="" src="https://images2.imgbox.com/c0/8d/cYmYXHmh_o.png" width="500"></p> 
 </div> 
 <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a id="34__112"></a>3.4 边缘检测</span></span></span></p> 
 <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">  边缘检测是图像处理和计算机视觉中的基本问题，边缘检测的目的是标识数字图像中亮度变化明显的点。图像属性中的显著变化通常反映了属性的重要事件和变化。边缘检测是特征提取中的一个研究领域。<br>   图像边缘检测大幅度地减少了数据量，并且剔除了可以认为不相关的信息，保留了图像重要的结构属性。有许多方法用于边缘检测，它们的绝大部分可以划分为两类：基于查找一类和基于零穿越的一类。基于查找的方法通过寻找图像一阶导数中的最大值和最小值来检测边界，通常是将边界定位在梯度最大的方向。基于零穿越的方法通过寻找图像二阶导数零穿越来寻找边界，通常是Laplacian过零点或者非线性差分表示的过零点。<br>   滤波作为边缘检测的预处理通常是必要的，通常采用高斯滤波。</span></span></span></p> 
 <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a id="341__Sobel_116"></a>3.4.1 Sobel边缘检测算子</span></span></span></p> 
 <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">  Sobel边缘检测算法比较简单，实际应用中效率比canny边缘检测效率要高，但是边缘不如Canny检测的准确，但是很多实际应用的场合，sobel边缘却是首选，Sobel算子是高斯平滑与微分操作的结合体，所以其抗噪声能力很强，用途较多。尤其是效率要求较高，而对细纹理不太关系的时候。<br>   <strong>算子模板为：</strong></span></span></span></p> 
 <div> 
  <p class="img-center"><img alt="" src="https://images2.imgbox.com/7f/2e/SDn3Hvm2_o.png" width="200"></p> 
 </div> 
 <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">  Sobel算子是一种带有方向的过滤器，openCV中Sobel算子的函数为cv2.Sobel ()。</span></span></span></p> 
 <pre class="has" style="margin-left:0;"><code class="language-prettyprint">&lt;span style="color:rgba(0, 0, 0, 0.75)"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span style="color:#000000"&gt;&lt;code class="language-python"&gt;Sobel_x_or_y &lt;span style="color:#669900"&gt;=&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;Sobel&lt;span style="color:#999999"&gt;(&lt;/span&gt;src&lt;span style="color:#999999"&gt;,&lt;/span&gt; ddepth&lt;span style="color:#999999"&gt;,&lt;/span&gt; dx&lt;span style="color:#999999"&gt;,&lt;/span&gt; dy&lt;span style="color:#999999"&gt;,&lt;/span&gt; dst&lt;span style="color:#999999"&gt;,&lt;/span&gt; ksize&lt;span style="color:#999999"&gt;,&lt;/span&gt; scale&lt;span style="color:#999999"&gt;,&lt;/span&gt; delta&lt;span style="color:#999999"&gt;,&lt;/span&gt; borderType&lt;span style="color:#999999"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
 <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">  dst及dst之后的参数都是可选参数。<br>   第一个参数是传入的图像，第二个参数是图像的深度，dx和dy指的是求导的阶数，0表示这个方向上没有求导，所填的数一般为0、1、2。ksize是Sobel算子的大小，即卷积核的大小，必须为奇数1、3、5、7。如果ksize=-1，就演变成为3x3的Scharr算子，scale是缩放导数的比例常数，默认情况为没有伸缩系数。borderType是判断图像边界的模式，这个参数默认值为cv2.BORDER_DEFAULT。</span></span></span></p> 
 <pre class="has" style="margin-left:0;"><code class="language-prettyprint">&lt;span style="color:rgba(0, 0, 0, 0.75)"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span style="color:#000000"&gt;&lt;code class="language-python"&gt;&lt;span style="color:#5c6370"&gt;# Sobel边缘检测算子&lt;/span&gt;
img &lt;span style="color:#669900"&gt;=&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;imread&lt;span style="color:#999999"&gt;(&lt;/span&gt;&lt;span style="color:#669900"&gt;'img.jpg'&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#98c379"&gt;0&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt;
x &lt;span style="color:#669900"&gt;=&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;Sobel&lt;span style="color:#999999"&gt;(&lt;/span&gt;img&lt;span style="color:#999999"&gt;,&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;CV_16S&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#98c379"&gt;1&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#98c379"&gt;0&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt;
y &lt;span style="color:#669900"&gt;=&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;Sobel&lt;span style="color:#999999"&gt;(&lt;/span&gt;img&lt;span style="color:#999999"&gt;,&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;CV_16S&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#98c379"&gt;0&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#98c379"&gt;1&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt;
&lt;span style="color:#5c6370"&gt;# cv2.convertScaleAbs(src[, dst[, alpha[, beta]]])&lt;/span&gt;
&lt;span style="color:#5c6370"&gt;# 可选参数alpha是伸缩系数，beta是加到结果上的一个值，结果返回uint类型的图像&lt;/span&gt;
Scale_absX &lt;span style="color:#669900"&gt;=&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;convertScaleAbs&lt;span style="color:#999999"&gt;(&lt;/span&gt;x&lt;span style="color:#999999"&gt;)&lt;/span&gt;  &lt;span style="color:#5c6370"&gt;# convert 转换  scale 缩放&lt;/span&gt;
Scale_absY &lt;span style="color:#669900"&gt;=&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;convertScaleAbs&lt;span style="color:#999999"&gt;(&lt;/span&gt;y&lt;span style="color:#999999"&gt;)&lt;/span&gt;
result &lt;span style="color:#669900"&gt;=&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;addWeighted&lt;span style="color:#999999"&gt;(&lt;/span&gt;Scale_absX&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#98c379"&gt;0.5&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; Scale_absY&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#98c379"&gt;0.5&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#98c379"&gt;0&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt;
cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;imshow&lt;span style="color:#999999"&gt;(&lt;/span&gt;&lt;span style="color:#669900"&gt;'img'&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; img&lt;span style="color:#999999"&gt;)&lt;/span&gt;
cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;imshow&lt;span style="color:#999999"&gt;(&lt;/span&gt;&lt;span style="color:#669900"&gt;'Scale_absX'&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; Scale_absX&lt;span style="color:#999999"&gt;)&lt;/span&gt;
cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;imshow&lt;span style="color:#999999"&gt;(&lt;/span&gt;&lt;span style="color:#669900"&gt;'Scale_absY'&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; Scale_absY&lt;span style="color:#999999"&gt;)&lt;/span&gt;
cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;imshow&lt;span style="color:#999999"&gt;(&lt;/span&gt;&lt;span style="color:#669900"&gt;'result'&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; result&lt;span style="color:#999999"&gt;)&lt;/span&gt;
cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;waitKey&lt;span style="color:#999999"&gt;(&lt;/span&gt;&lt;span style="color:#98c379"&gt;0&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
 <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">  Sobel函数求完导数后会有负值，还有会大于255的值。而原图像是uint8，即8位无符号数，所以Sobel建立的图像位数不够，会有截断。因此要使用16位有符号的数据类型，即cv2.CV_16S。处理完图像后，再使用cv2.convertScaleAbs()函数将其转回原来的uint8格式，否则图像无法显示。<br>   Sobel算子是在两个方向计算的，最后还需要用cv2.addWeighted( )函数将其组合起来。</span></span></span></p> 
 <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">  其中alpha是第一幅图片中元素的权重，beta是第二个图像的权重，gamma是加到最后结果上的一个值。</span></span></span></p> 
 <div> 
  <p class="img-center"><img alt="" src="https://images2.imgbox.com/91/30/FuUyPmqa_o.png" width="400"></p> 
 </div> 
 <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a id="342__Scharr_153"></a>3.4.2 Scharr算子</span></span></span></p> 
 <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">  当Sobel（）函数的参数ksize=-1时，就演变成了3x3的Scharr算子。算子的模板为：</span></span></span></p> 
 <div> 
  <span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><img alt="" src="https://images2.imgbox.com/bf/d4/0EiEKLbn_o.png" width="200"></span></span> 
 </div> 
 <pre class="has" style="margin-left:0;"><code class="language-prettyprint">&lt;span style="color:rgba(0, 0, 0, 0.75)"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span style="color:#000000"&gt;&lt;code class="language-python"&gt;&lt;span style="color:#5c6370"&gt;# Scharr算子&lt;/span&gt;
img &lt;span style="color:#669900"&gt;=&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;imread&lt;span style="color:#999999"&gt;(&lt;/span&gt;&lt;span style="color:#669900"&gt;'img.jpg'&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#98c379"&gt;0&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt;
x &lt;span style="color:#669900"&gt;=&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;Sobel&lt;span style="color:#999999"&gt;(&lt;/span&gt;img&lt;span style="color:#999999"&gt;,&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;CV_16S&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#98c379"&gt;1&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#98c379"&gt;0&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; ksize&lt;span style="color:#669900"&gt;=&lt;/span&gt;&lt;span style="color:#669900"&gt;-&lt;/span&gt;&lt;span style="color:#98c379"&gt;1&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt;
y &lt;span style="color:#669900"&gt;=&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;Sobel&lt;span style="color:#999999"&gt;(&lt;/span&gt;img&lt;span style="color:#999999"&gt;,&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;CV_16S&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#98c379"&gt;0&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#98c379"&gt;1&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; ksize&lt;span style="color:#669900"&gt;=&lt;/span&gt;&lt;span style="color:#669900"&gt;-&lt;/span&gt;&lt;span style="color:#98c379"&gt;1&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt;
&lt;span style="color:#5c6370"&gt;# ksize=-1 Scharr算子&lt;/span&gt;
&lt;span style="color:#5c6370"&gt;# cv2.convertScaleAbs(src[, dst[, alpha[, beta]]])&lt;/span&gt;
&lt;span style="color:#5c6370"&gt;# 可选参数alpha是伸缩系数，beta是加到结果上的一个值，结果返回uint类型的图像&lt;/span&gt;
Scharr_absX &lt;span style="color:#669900"&gt;=&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;convertScaleAbs&lt;span style="color:#999999"&gt;(&lt;/span&gt;x&lt;span style="color:#999999"&gt;)&lt;/span&gt;  &lt;span style="color:#5c6370"&gt;# convert 转换  scale 缩放&lt;/span&gt;
Scharr_absY &lt;span style="color:#669900"&gt;=&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;convertScaleAbs&lt;span style="color:#999999"&gt;(&lt;/span&gt;y&lt;span style="color:#999999"&gt;)&lt;/span&gt;
result &lt;span style="color:#669900"&gt;=&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;addWeighted&lt;span style="color:#999999"&gt;(&lt;/span&gt;Scharr_absX&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#98c379"&gt;0.5&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; Scharr_absY&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#98c379"&gt;0.5&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#98c379"&gt;0&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt;
cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;imshow&lt;span style="color:#999999"&gt;(&lt;/span&gt;&lt;span style="color:#669900"&gt;'img'&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; img&lt;span style="color:#999999"&gt;)&lt;/span&gt;
cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;imshow&lt;span style="color:#999999"&gt;(&lt;/span&gt;&lt;span style="color:#669900"&gt;'Scharr_absX'&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; Scharr_absX&lt;span style="color:#999999"&gt;)&lt;/span&gt;
cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;imshow&lt;span style="color:#999999"&gt;(&lt;/span&gt;&lt;span style="color:#669900"&gt;'Scharr_absY'&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; Scharr_absY&lt;span style="color:#999999"&gt;)&lt;/span&gt;
cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;imshow&lt;span style="color:#999999"&gt;(&lt;/span&gt;&lt;span style="color:#669900"&gt;'result'&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; result&lt;span style="color:#999999"&gt;)&lt;/span&gt;
cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;waitKey&lt;span style="color:#999999"&gt;(&lt;/span&gt;&lt;span style="color:#98c379"&gt;0&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
 <div> 
  <p class="img-center"><img alt="" src="https://images2.imgbox.com/94/e6/L8Tzx52B_o.png" width="400"></p> 
 </div> 
 <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a id="343__Laplacian_176"></a>3.4.3 拉普拉斯（Laplacian）算子</span></span></span></p> 
 <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">  Laplacian函数实现的方法是先用Sobel算子计算二阶x和y导数，再求和。</span></span></span></p> 
 <div> 
  <span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><img alt="" src="https://images2.imgbox.com/2f/cc/AymHZJ7M_o.png" width="200"></span></span> 
 </div> 
 <pre class="has" style="margin-left:0;"><code class="language-prettyprint">&lt;span style="color:rgba(0, 0, 0, 0.75)"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span style="color:#000000"&gt;&lt;code class="language-python"&gt;laplacian &lt;span style="color:#669900"&gt;=&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;Laplacian&lt;span style="color:#999999"&gt;(&lt;/span&gt;src&lt;span style="color:#999999"&gt;,&lt;/span&gt; depth&lt;span style="color:#999999"&gt;,&lt;/span&gt; dst&lt;span style="color:#999999"&gt;,&lt;/span&gt; ksize&lt;span style="color:#999999"&gt;,&lt;/span&gt; scale&lt;span style="color:#999999"&gt;,&lt;/span&gt; delta&lt;span style="color:#999999"&gt;,&lt;/span&gt; borderType&lt;span style="color:#999999"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
 <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">  前两个参数是必选参数，其后是可选参数。第一个参数是需要处理的图像，第二个参数是图像的深度，-1表示采用的是原图像相同的深度，目标图像的深度必须大于等于原图像的深度；ksize参数是算子的大小，即卷积核的大小，必须为1,3,5,7。默认为1。scale是缩放导数的比例chan常数，默认情况下没有伸缩系数；borderType是判断图像边界的模式。这个参数默认值为cv2.BORDER_DEFAULT。</span></span></span></p> 
 <pre class="has" style="margin-left:0;"><code class="language-prettyprint">&lt;span style="color:rgba(0, 0, 0, 0.75)"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span style="color:#000000"&gt;&lt;code class="language-python"&gt;&lt;span style="color:#5c6370"&gt;# 拉普拉斯算子&lt;/span&gt;
img &lt;span style="color:#669900"&gt;=&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;imread&lt;span style="color:#999999"&gt;(&lt;/span&gt;&lt;span style="color:#669900"&gt;'img.jpg'&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#98c379"&gt;0&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt;
laplacian &lt;span style="color:#669900"&gt;=&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;Laplacian&lt;span style="color:#999999"&gt;(&lt;/span&gt;img&lt;span style="color:#999999"&gt;,&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;CV_16S&lt;span style="color:#999999"&gt;,&lt;/span&gt; ksize&lt;span style="color:#669900"&gt;=&lt;/span&gt;&lt;span style="color:#98c379"&gt;3&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt;
dst &lt;span style="color:#669900"&gt;=&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;convertScaleAbs&lt;span style="color:#999999"&gt;(&lt;/span&gt;laplacian&lt;span style="color:#999999"&gt;)&lt;/span&gt;
cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;imshow&lt;span style="color:#999999"&gt;(&lt;/span&gt;&lt;span style="color:#669900"&gt;'laplacian'&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; dst&lt;span style="color:#999999"&gt;)&lt;/span&gt;
cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;waitKey&lt;span style="color:#999999"&gt;(&lt;/span&gt;&lt;span style="color:#98c379"&gt;0&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt;
cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;destroyAllWindows&lt;span style="color:#999999"&gt;(&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
 <div> 
  <p class="img-center"><img alt="" src="https://images2.imgbox.com/f7/5e/N8NL9KWA_o.png" width="400"></p> 
 </div> 
 <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a id="344__Canny_197"></a>3.4.4 Canny算子</span></span></span></p> 
 <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">  根据对信噪比与定位乘积进行测度，得到最优化逼近算子。这就是Canny边缘检测算子。<br>   算法的基本步骤为：<br>   1.用高斯滤波器平滑图像；<br>   2.用一阶偏导的有限差分来计算梯度的幅值和方向；<br>   3.对梯度幅值进行非极大抑制；<br>   4.用双阈值算法检测和连接边缘。</span></span></span></p> 
 <pre class="has" style="margin-left:0;"><code class="language-prettyprint">&lt;span style="color:rgba(0, 0, 0, 0.75)"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span style="color:#000000"&gt;&lt;code class="language-python"&gt;canny &lt;span style="color:#669900"&gt;=&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;Canny&lt;span style="color:#999999"&gt;(&lt;/span&gt;image&lt;span style="color:#999999"&gt;,&lt;/span&gt; threshold1&lt;span style="color:#999999"&gt;,&lt;/span&gt; threshold2&lt;span style="color:#999999"&gt;,&lt;/span&gt; edges&lt;span style="color:#999999"&gt;,&lt;/span&gt; apertureSize&lt;span style="color:#999999"&gt;,&lt;/span&gt; L2gradient&lt;span style="color:#999999"&gt;)&lt;/span&gt; 
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
 <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">  第一个参数是需要处理的原图像单通道的灰度图，第二个参数是阈值1，第二个参数是阈值2，较大的阈值2用于检测图像中明显的边缘，但一般情况下检测的效果不会那么完美，边缘检测出来是断断续续的。所以这时候应用较小的第一个阈值来将这些间断的边缘连接起来。可选参数中aperaperturesize参数就是卷积核的大，而L2gradient参数就是一个布尔值，如果为true，则就使用更精确的L2范数进行计算（即两个方向的倒数的平方和再开方），否则使用L1范数（直接将两个方向导数的绝对值相加）。</span></span></span></p> 
 <pre class="has" style="margin-left:0;"><code class="language-prettyprint">&lt;span style="color:rgba(0, 0, 0, 0.75)"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span style="color:#000000"&gt;&lt;code class="language-python"&gt;&lt;span style="color:#5c6370"&gt;# canny算子&lt;/span&gt;
img &lt;span style="color:#669900"&gt;=&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;imread&lt;span style="color:#999999"&gt;(&lt;/span&gt;&lt;span style="color:#669900"&gt;'img.jpg'&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#98c379"&gt;0&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt;
blur &lt;span style="color:#669900"&gt;=&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;GaussianBlur&lt;span style="color:#999999"&gt;(&lt;/span&gt;img&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#999999"&gt;(&lt;/span&gt;&lt;span style="color:#98c379"&gt;3&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#98c379"&gt;3&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#98c379"&gt;0&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt;  &lt;span style="color:#5c6370"&gt;# 用高斯滤波处理原图像降噪&lt;/span&gt;
canny &lt;span style="color:#669900"&gt;=&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;Canny&lt;span style="color:#999999"&gt;(&lt;/span&gt;blur&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#98c379"&gt;50&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#98c379"&gt;150&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt;  &lt;span style="color:#5c6370"&gt;# 50是最小阈值,150是最大阈值&lt;/span&gt;
cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;imshow&lt;span style="color:#999999"&gt;(&lt;/span&gt;&lt;span style="color:#669900"&gt;'canny'&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; canny&lt;span style="color:#999999"&gt;)&lt;/span&gt;
cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;waitKey&lt;span style="color:#999999"&gt;(&lt;/span&gt;&lt;span style="color:#98c379"&gt;0&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt;
cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;destroyAllWindows&lt;span style="color:#999999"&gt;(&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
 <div> 
  <p class="img-center"><img alt="" src="https://images2.imgbox.com/2c/c9/H9PU8dgR_o.png" width="400"></p> 
 </div> 
 <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a id="35__222"></a>3.5 腐蚀和膨胀</span></span></span></p> 
 <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a id="351___223"></a>3.5.1 结构元素</span></span></span></p> 
 <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">  形态学处理的核心就是定义结构元素，在OpenCV中，可以使用其自带的getStructuringElement函数，也可以直接使用NumPy的ndarray来定义一个结构元素。</span></span></span></p> 
 <div> 
  <p class="img-center"><img alt="" src="https://images2.imgbox.com/28/8f/hLaYndvH_o.png" width="150"></p> 
 </div> 
 <span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;">   使用cv2.getStructuringElement(cv2.MORPH_CROSS,(3,3))可以定义上图的十字形结构，当然还可以定义椭圆/矩形等：</span></span> 
 <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">   椭圆：cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(3,3))<br>    矩形：cv2.getStructuringElement(cv2.MORPH_RECT,(3,3))</span></span></span></p> 
 <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a id="352___230"></a>3.5.2 腐蚀和膨胀</span></span></span></p> 
 <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">  腐蚀（取局部最小值）：腐蚀是原图中的高亮区域被蚕食，效果图拥有比原图更小的高亮区域。<br>   膨胀（取局部最大值）：膨胀就是对图像高亮部分进行“领域扩张”，效果图拥有比原图更大的高亮区域；<br>   <strong>方法：</strong></span></span></span></p> 
 <pre class="has" style="margin-left:0;"><code class="language-prettyprint">&lt;span style="color:rgba(0, 0, 0, 0.75)"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span style="color:#000000"&gt;&lt;code class="language-python"&gt;&lt;span style="color:#5c6370"&gt;# 腐蚀&lt;/span&gt;
cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;erode&lt;span style="color:#999999"&gt;(&lt;/span&gt;src&lt;span style="color:#999999"&gt;,&lt;/span&gt;                        &lt;span style="color:#5c6370"&gt;# 输入图像&lt;/span&gt;
	  kernel&lt;span style="color:#999999"&gt;,&lt;/span&gt;                         &lt;span style="color:#5c6370"&gt;# 卷积核&lt;/span&gt;
	  dst&lt;span style="color:#669900"&gt;=&lt;/span&gt;&lt;span style="color:#56b6c2"&gt;None&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt;                       &lt;span style="color:#5c6370"&gt;# 输出图&lt;/span&gt;
	  anchor&lt;span style="color:#669900"&gt;=&lt;/span&gt;&lt;span style="color:#56b6c2"&gt;None&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt;                    &lt;span style="color:#5c6370"&gt;# 结构元素的锚点位置，默认锚点位于结构元素中心&lt;/span&gt;
	  iterations&lt;span style="color:#669900"&gt;=&lt;/span&gt;&lt;span style="color:#56b6c2"&gt;None&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt;                &lt;span style="color:#5c6370"&gt;# 迭代次数，默认1&lt;/span&gt;
	  borderType&lt;span style="color:#669900"&gt;=&lt;/span&gt;&lt;span style="color:#56b6c2"&gt;None&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt;                &lt;span style="color:#5c6370"&gt;# 推断边缘类型&lt;/span&gt;
	  borderValue&lt;span style="color:#669900"&gt;=&lt;/span&gt;&lt;span style="color:#56b6c2"&gt;None&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt;               &lt;span style="color:#5c6370"&gt;# 边缘值&lt;/span&gt;
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
</div> 
<div> 
 <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;"># 膨胀<br> cv2.dilate(src, # 输入图像<br> kernel, # 卷积核<br> dst=None, # 输出图<br> anchor=None, # 结构元素的锚点位置，默认锚点位于结构元素中心<br> iterations=None, # 迭代次数，默认1<br> borderType=None, # 推断边缘类型<br> borderValue=None) # 边缘值</span></span></span></p> 
</div> 
<div> 
 <div></div> 
 <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">  <strong>运行代码：</strong></span></span></span></p> 
 <pre class="has" style="margin-left:0;"><code class="language-prettyprint">&lt;span style="color:rgba(0, 0, 0, 0.75)"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span style="color:#000000"&gt;&lt;code&gt;kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))
    eroded = cv2.erode(img, kernel)  # 腐蚀图像
    cv2.imshow('eroded.png', eroded)
    dilated = cv2.dilate(img, kernel)  # 膨胀图像
    cv2.imshow('canny.png', dilated)
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
 <div> 
  <p class="img-center"><img alt="" src="https://images2.imgbox.com/15/31/dxJRx9nQ_o.png" width="700"></p> 
 </div> 
 <p><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a id="353___263"></a>3.5.3 开运算与闭运算</span></span></span></p> 
 <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">  开运算：先腐蚀后膨胀，用于移除由图像噪音形成的斑点。<br>   闭运算：先膨胀后腐蚀，用来连接被误分为许多小块的对象；</span></span></span></p> 
 <h3 style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4f4f4f;"><a id="3_OpenCV_267"></a>3. OpenCV应用案例(照片更换背景)</span></span></span></h3> 
 <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">  <strong>原始图片</strong></span></span></span></p> 
 <div> 
  <p class="img-center"><img alt="" src="https://images2.imgbox.com/2b/82/F1luSW2w_o.png" width="150"></p> 
 </div> 
 <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">  <strong>图像缩放</strong></span></span></span></p> 
 <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">   适当缩放图片可以有效减少计算量</span></span></span></p> 
 <pre class="has" style="margin-left:0;"><code class="language-prettyprint">&lt;span style="color:rgba(0, 0, 0, 0.75)"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span style="color:#000000"&gt;&lt;code class="language-python"&gt;img &lt;span style="color:#669900"&gt;=&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;resize&lt;span style="color:#999999"&gt;(&lt;/span&gt;img&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#56b6c2"&gt;None&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; fx&lt;span style="color:#669900"&gt;=&lt;/span&gt;&lt;span style="color:#98c379"&gt;0.3&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; fy&lt;span style="color:#669900"&gt;=&lt;/span&gt;&lt;span style="color:#98c379"&gt;0.3&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt;
rows&lt;span style="color:#999999"&gt;,&lt;/span&gt; cols&lt;span style="color:#999999"&gt;,&lt;/span&gt; channels &lt;span style="color:#669900"&gt;=&lt;/span&gt; img&lt;span style="color:#999999"&gt;.&lt;/span&gt;shape
&lt;span style="color:#c678dd"&gt;print&lt;/span&gt;&lt;span style="color:#999999"&gt;(&lt;/span&gt;rows&lt;span style="color:#999999"&gt;,&lt;/span&gt; cols&lt;span style="color:#999999"&gt;,&lt;/span&gt; channels&lt;span style="color:#999999"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
 <div> 
  <span style="background-color:#ffffff;color:#4d4d4d;">   </span> 
  <strong>图片转换为HSV灰度图</strong> 
 </div> 
 <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">   转换为hsv灰度图更利于背景的识别</span></span></span></p> 
 <pre class="has" style="margin-left:0;"><code class="language-prettyprint">&lt;span style="color:rgba(0, 0, 0, 0.75)"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span style="color:#000000"&gt;&lt;code class="language-python"&gt;hsv &lt;span style="color:#669900"&gt;=&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;cvtColor&lt;span style="color:#999999"&gt;(&lt;/span&gt;img&lt;span style="color:#999999"&gt;,&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;COLOR_BGR2HSV&lt;span style="color:#999999"&gt;)&lt;/span&gt;
cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;imshow&lt;span style="color:#999999"&gt;(&lt;/span&gt;&lt;span style="color:#669900"&gt;'hsv'&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; hsv&lt;span style="color:#999999"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
 <div> 
  <p class="img-center"><img alt="" src="https://images2.imgbox.com/ea/af/OuW4PeqR_o.png" width="150"></p> 
 </div> 
 <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">   <strong>图片二值化处理</strong><br>    图片的二值化处理，可能会出现噪声（白点），有的图片显示的很明显，这就需要我们进行腐蚀或膨胀。</span></span></span></p> 
 <pre class="has" style="margin-left:0;"><code class="language-prettyprint">&lt;span style="color:rgba(0, 0, 0, 0.75)"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span style="color:#000000"&gt;&lt;code class="language-python"&gt;    lower_blue &lt;span style="color:#669900"&gt;=&lt;/span&gt; np&lt;span style="color:#999999"&gt;.&lt;/span&gt;array&lt;span style="color:#999999"&gt;(&lt;/span&gt;&lt;span style="color:#999999"&gt;[&lt;/span&gt;&lt;span style="color:#98c379"&gt;90&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#98c379"&gt;70&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#98c379"&gt;70&lt;/span&gt;&lt;span style="color:#999999"&gt;]&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt;
    upper_blue &lt;span style="color:#669900"&gt;=&lt;/span&gt; np&lt;span style="color:#999999"&gt;.&lt;/span&gt;array&lt;span style="color:#999999"&gt;(&lt;/span&gt;&lt;span style="color:#999999"&gt;[&lt;/span&gt;&lt;span style="color:#98c379"&gt;110&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#98c379"&gt;255&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#98c379"&gt;255&lt;/span&gt;&lt;span style="color:#999999"&gt;]&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt;
    mask &lt;span style="color:#669900"&gt;=&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;inRange&lt;span style="color:#999999"&gt;(&lt;/span&gt;hsv&lt;span style="color:#999999"&gt;,&lt;/span&gt; lower_blue&lt;span style="color:#999999"&gt;,&lt;/span&gt; upper_blue&lt;span style="color:#999999"&gt;)&lt;/span&gt;  &lt;span style="color:#5c6370"&gt;# 蓝色范围内变白，其余之外全部变黑&lt;/span&gt;
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
 <div> 
  <p class="img-center"><img alt="" src="https://images2.imgbox.com/20/cb/LvixyyD3_o.png" width="150"></p> 
 </div> 
 <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">   <strong>腐蚀膨胀</strong><br>    去除图片中的噪点</span></span></span></p> 
 <pre class="has" style="margin-left:0;"><code class="language-prettyprint">&lt;span style="color:rgba(0, 0, 0, 0.75)"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span style="color:#000000"&gt;&lt;code class="language-python"&gt;erode &lt;span style="color:#669900"&gt;=&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;erode&lt;span style="color:#999999"&gt;(&lt;/span&gt;mask&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#56b6c2"&gt;None&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; iterations&lt;span style="color:#669900"&gt;=&lt;/span&gt;&lt;span style="color:#98c379"&gt;1&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt; 
dilate &lt;span style="color:#669900"&gt;=&lt;/span&gt; cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;dilate&lt;span style="color:#999999"&gt;(&lt;/span&gt;mask&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#56b6c2"&gt;None&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; iterations&lt;span style="color:#669900"&gt;=&lt;/span&gt;&lt;span style="color:#98c379"&gt;1&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt; 
cv2&lt;span style="color:#999999"&gt;.&lt;/span&gt;imshow&lt;span style="color:#999999"&gt;(&lt;/span&gt;&lt;span style="color:#669900"&gt;'dilate'&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; dilate&lt;span style="color:#999999"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
 <div> 
  <p class="img-center"><img alt="" src="https://images2.imgbox.com/18/fa/aJ5yCKPj_o.png" width="150"></p> 
 </div> 
 <p style="margin-left:0;"><span style="color:rgba(0,0,0,.75);"><span style="background-color:#ffffff;"><span style="color:#4d4d4d;">   <strong>背景变换</strong><br> 遍历每个像素点，进行颜色的替换</span></span></span></p> 
 <pre class="has" style="margin-left:0;"><code class="language-prettyprint">&lt;span style="color:rgba(0, 0, 0, 0.75)"&gt;&lt;span style="background-color:#ffffff"&gt;&lt;span style="color:#000000"&gt;&lt;code class="language-python"&gt;&lt;span style="color:#c678dd"&gt;for&lt;/span&gt; i &lt;span style="color:#c678dd"&gt;in&lt;/span&gt; &lt;span style="color:#669900"&gt;range&lt;/span&gt;&lt;span style="color:#999999"&gt;(&lt;/span&gt;rows&lt;span style="color:#999999"&gt;)&lt;/span&gt;&lt;span style="color:#999999"&gt;:&lt;/span&gt;
  &lt;span style="color:#c678dd"&gt;for&lt;/span&gt; j &lt;span style="color:#c678dd"&gt;in&lt;/span&gt; &lt;span style="color:#669900"&gt;range&lt;/span&gt;&lt;span style="color:#999999"&gt;(&lt;/span&gt;cols&lt;span style="color:#999999"&gt;)&lt;/span&gt;&lt;span style="color:#999999"&gt;:&lt;/span&gt;
     &lt;span style="color:#c678dd"&gt;if&lt;/span&gt; dilate&lt;span style="color:#999999"&gt;[&lt;/span&gt;i&lt;span style="color:#999999"&gt;,&lt;/span&gt; j&lt;span style="color:#999999"&gt;]&lt;/span&gt; &lt;span style="color:#669900"&gt;==&lt;/span&gt; &lt;span style="color:#98c379"&gt;255&lt;/span&gt;&lt;span style="color:#999999"&gt;:&lt;/span&gt;  &lt;span style="color:#5c6370"&gt;# 像素点为255表示的是白色，此处将白色处的像素点替换为红色&lt;/span&gt;
           img&lt;span style="color:#999999"&gt;[&lt;/span&gt;i&lt;span style="color:#999999"&gt;,&lt;/span&gt; j&lt;span style="color:#999999"&gt;]&lt;/span&gt; &lt;span style="color:#669900"&gt;=&lt;/span&gt; &lt;span style="color:#999999"&gt;(&lt;/span&gt;&lt;span style="color:#98c379"&gt;0&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#98c379"&gt;0&lt;/span&gt;&lt;span style="color:#999999"&gt;,&lt;/span&gt; &lt;span style="color:#98c379"&gt;255&lt;/span&gt;&lt;span style="color:#999999"&gt;)&lt;/span&gt;  
&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;</code></pre> 
 <p style="margin-left:0;"></p> 
 <p class="img-center"><img alt="" height="206" src="https://images2.imgbox.com/da/89/7qyObBj7_o.png" width="150"></p> 
 <p style="margin-left:0;">————————————————</p> 
 <p style="margin-left:0;">版权声明：本文为CSDN博主「小小晓晓阳」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br> 原文链接：https://blog.csdn.net/bugang4663/article/details/111413850</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/46fdc3e9890d6cb608a8ab29fa69497b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">winform 调用webview2 用户没有安装运行时</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9c5268f1fdc906cc0163c0af5e449362/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">微信浏览器的h5使用文件上传导致页面闪退</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>