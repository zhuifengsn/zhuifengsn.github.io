<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>多项式加法（链表） - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="多项式加法（链表）" />
<meta property="og:description" content="笔者最近正在学习数据结构，碰到了这样一个问题——如何用链表实现多项式的加法？因书上仅给出了数组法的代码，所以笔者尝试自己解决这个问题。为此，笔者写本文来记录思考过程。
思路 一、创建合适的链表 a.分析 百度百科这样描述多项式——”在数学中，几个单项式的和，叫做多项式。”就像多项式由一个个单项式相加而成，链表也由一个个节点连接而成。只是，&#43;连接单项式，指针连接节点。
多项式：
链表：
因此，一个节点应该存放一个单项式：
b.代码 typedef struct Polynomial // 多项式 { int Coefficient; // 系数 int Exponent; // 指数 } Polynomial; typedef struct Node // 节点 { Polynomial Poly; struct Node* Next; } Node; typedef Node* List; // 多项式的项在链表中按指数由大到小排列 二、对链表进行操作 a.初始化节点 /* 参数：1个：待初始化的节点的指针 结果：节点中的系数和指数都初始化为0 */ void ZeroPolynomial(Node* Ptr) { if (Ptr != NULL) // 防止传入空指针 { Ptr-&gt;Poly.Coefficient = 0; // 系数初始化为0 Ptr-&gt;Poly.Exponent = 0; // 指数初始化为0 Ptr-&gt;Next = NULL; } } b." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/47997be45cc3297bfcf9b63b4336dc25/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-06T16:36:10+08:00" />
<meta property="article:modified_time" content="2023-01-06T16:36:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">多项式加法（链表）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <p style="">笔者最近正在学习数据结构，碰到了这样一个问题——如何用链表实现多项式的加法？因书上仅给出了数组法的代码，所以笔者尝试自己解决这个问题。为此，笔者写本文来记录思考过程。</p> 
 <hr> 
 <h2 style="">思路</h2> 
 <h3 style="">一、创建合适的链表</h3> 
 <h4 style="padding-left:1.4em;">a.分析</h4> 
 <p style="padding-left:1.4em;">百度百科这样描述多项式——”在数学中，几个单项式的和，叫做多项式。”就像多项式由一个个<span class="kdocs-fontSize" style="font-size:13pt;"><span class="kdocs-bold" style="font-weight:bold;">单项式</span></span>相加而成，链表也由一个个<span class="kdocs-fontSize" style="font-size:13pt;"><span class="kdocs-bold" style="font-weight:bold;">节点</span></span>连接而成。只是，<span class="kdocs-fontSize" style="font-size:15pt;"><span class="kdocs-bold" style="font-weight:bold;">+</span></span>连接单项式，<span class="kdocs-fontSize" style="font-size:13pt;"><span class="kdocs-bold" style="font-weight:bold;">指针</span></span>连接节点。</p> 
 <p style="padding-left:1.4em;">多项式：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="background-color:#F5F7F9;flex-direction:column;max-width:100%;display:flex;width:458;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:13.318777%;height:0;"> 
    <img src="https://images2.imgbox.com/07/40/UxcmtYrE_o.png" style="margin-left:;border:solid 1px #E4E4E4;display:block;width:100.0%;margin-top:-13.318777%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <p style="padding-left:1.4em;">链表：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="background-color:#F5F7F9;flex-direction:column;max-width:100%;display:flex;width:429;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:27.505827%;height:0;"> 
    <img src="https://images2.imgbox.com/05/63/rdZ9dV4p_o.png" style="margin-left:;border:solid 1px #E4E4E4;display:block;width:100.0%;margin-top:-27.505827%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-indent:1.4em;">因此，一个节点应该存放一个单项式：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="background-color:#F5F7F9;flex-direction:column;max-width:100%;display:flex;width:435;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:63.67816%;height:0;"> 
    <img src="https://images2.imgbox.com/57/24/9cGU0ngn_o.png" style="margin-left:;border:solid 1px #E4E4E4;display:block;width:100.0%;margin-top:-63.67816%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <h4 style="text-indent:1.4em;">b.代码</h4> 
 <pre class="kdocs-c-like"><code class="language-c-like">typedef struct Polynomial       // 多项式
{
    int Coefficient;            // 系数
    int Exponent;               // 指数
} Polynomial;
typedef struct Node             // 节点
{
    Polynomial Poly;
    struct Node* Next;
} Node;
typedef Node* List;             // 多项式的项在链表中按指数由大到小排列</code></pre> 
 <hr> 
 <h3 style="">二、对链表进行操作</h3> 
 <h4 style="text-indent:1.4em;">a.初始化节点</h4> 
 <pre class="kdocs-c-like"><code class="language-c-like">/*
    参数：1个：待初始化的节点的指针
    结果：节点中的系数和指数都初始化为0
*/
void ZeroPolynomial(Node* Ptr)
{
    if (Ptr != NULL)                       // 防止传入空指针
    {
        Ptr-&gt;Poly.Coefficient = 0;         // 系数初始化为0
        Ptr-&gt;Poly.Exponent = 0;            // 指数初始化为0
        Ptr-&gt;Next = NULL;
    }
}</code></pre> 
 <h4 style="text-indent:1.4em;">b.创建表头</h4> 
 <pre class="kdocs-c-like"><code class="language-c-like">/*
    参数：无
    结果：创建多项式的表头
    返回：若成功创建，返回表头指针；否则，返回NULL
*/
List CreateHeader(void)
{
    List Header;

    Header = (List)malloc(sizeof(Node));
    if (Header == NULL)
    {
        ferror("Wrong");
        return NULL;
    }

    ZeroPolynomial(Header);                 // 初始化表头

    return Header;
}</code></pre> 
 <h4 style="text-indent:1.4em;">c.创建节点</h4> 
 <pre class="kdocs-c-like"><code class="language-c-like">/*
    参数：1个：多项式的表头
    结果：在链表后创建一个节点，并初始化系数和指数为0
    返回：若成功创建，返回创建得节点的指针；否则，返回NULL
*/
Node* CreateNode(List Header)
{
    Node* Ptr, * Tmp;                      // Ptr -- 接收创建得节点的指针
                                           // Tmp -- 临时存放指针，用于寻找链表末尾
    Ptr = (Node*)malloc(sizeof(Node));
    if (Ptr == NULL)
    {
        ferror("Wrong");
        return NULL;
    }
    ZeroPolynomial(Ptr);                   // 初始化节点

    Tmp = Header;                          // 寻找链表末尾
    while (Tmp-&gt;Next != NULL)
        Tmp = Tmp-&gt;Next;

    Tmp-&gt;Next = Ptr;                       // 将创建得节点添加至链表末尾

    return Ptr;
}</code></pre> 
 <hr> 
 <h3 style="">三、多项式加法</h3> 
 <h4 style="text-indent:1.4em;">a.分析</h4> 
 <p style="text-indent:1.4em;">以这两个多项式作为例子</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="background-color:#F5F7F9;flex-direction:column;max-width:100%;display:flex;width:1139;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:33.2748%;height:0;"> 
    <img src="https://images2.imgbox.com/22/8c/qM5LHR8R_o.png" style="margin-left:;border:solid 1px #E4E4E4;display:block;width:100.0%;margin-top:-33.2748%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-indent:1.4em;padding-left:1.4em;">多项式加法遵从一个原则——指数相同，系数相加。由于是链表，我们需要一个一个节点比较指数大小。不过，可能会出现某一多项式先结束，即到达链表末尾。同时，我们还要考虑多项式1或2的指数是否与结果中的上一个单项式的指数相同，除了多项式1和2指数相同的情况。</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="background-color:#F5F7F9;flex-direction:column;max-width:100%;display:flex;width:1245;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:36.144577%;height:0;"> 
    <img src="https://images2.imgbox.com/99/e7/7kj4sH0o_o.png" style="margin-left:;border:solid 1px #E4E4E4;display:block;width:100.0%;margin-top:-36.144577%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <h4 style="text-indent:1.4em;">b.代码</h4> 
 <pre class="kdocs-c-like"><code class="language-c-like">/*
    参数：2个：多项式1的表头；多项式2的表头
    结果：将多项式1和多项式2相加，并存放在列表中，按指数由大到小排列
    返回：返回相加后的多形式的表头
*/
List AddPolynomial(List Header1, List Header2)
{
    List SumHeader;                           // 求和结果的表头
    Node* Tmp1, * Tmp2, * SumTmp;             // Tmp1 -- 接收多项式1的链表的指针；Tmp2 -- 接受多项式2的链表的指针
                                              // 接收结果的链表的指针
    SumHeader = CreateHeader();

    SumTmp = CreateNode(SumHeader);
    Tmp1 = Header1-&gt;Next;
    Tmp2 = Header2-&gt;Next;

/*
    三种情况：
        一、多项式1和多项式2都有余项 -- 1） 式1指数 &gt; 式2指数
                                      2） 式1指数 &lt; 式2指数
                                      3） 式1指数 = 式2指数（一定与现节点的指数相异）
        二、仅多项式1有余项
        三、仅多项式2有余项

    除 一/3）外，需进一步考虑式子的指数是否与现节点的指数相同 -- 相异：创建新的节点
                                                            相同：在原来的基础上相加
*/
    while (Tmp1 != NULL || Tmp2 != NULL)                                // 某一个多项式仍有余项
    {
    // 一、多项式1和多项式2都有余项
        if (Tmp1 != NULL &amp;&amp; Tmp2 != NULL)
        {
        // 1）式1指数 &gt; 式2指数
            if (Tmp1-&gt;Poly.Exponent &gt; Tmp2-&gt;Poly.Exponent)
            {
            // 考虑式子的指数是否与现节点的指数相同
                if (Tmp1-&gt;Poly.Exponent != SumTmp-&gt;Poly.Exponent)       // 相异
                {
                    SumTmp = CreateNode(SumHeader);                     // 创建新的节点
                    SumTmp-&gt;Poly.Coefficient = Tmp1-&gt;Poly.Coefficient;
                    SumTmp-&gt;Poly.Exponent = Tmp1-&gt;Poly.Exponent;
                }
                else                                                    // 相同
                    SumTmp-&gt;Poly.Coefficient += Tmp1-&gt;Poly.Coefficient;

                Tmp1 = Tmp1-&gt;Next;                                      // 多项式1的指针移至下一项
            }

        // 2）式1指数 &lt; 式2指数
            else if (Tmp1-&gt;Poly.Exponent &lt; Tmp2-&gt;Poly.Exponent)
            {
            // 考虑式子的指数是否与现节点的指数相同
                if (Tmp2-&gt;Poly.Exponent != SumTmp-&gt;Poly.Exponent)       // 相异
                {
                    SumTmp = CreateNode(SumHeader);
                    SumTmp-&gt;Poly.Coefficient = Tmp2-&gt;Poly.Coefficient;
                    SumTmp-&gt;Poly.Exponent = Tmp2-&gt;Poly.Exponent;
                }
                else                                                    // 相同
                    SumTmp-&gt;Poly.Coefficient += Tmp2-&gt;Poly.Coefficient;

                Tmp2 = Tmp2-&gt;Next;                                      // 多项式2的指针移至下一项
            }

        // 3）式1指数 = 式2指数（一定与现节点的指数相异）
            else if (Tmp1-&gt;Poly.Exponent == Tmp2-&gt;Poly.Exponent)
            {
                    SumTmp = CreateNode(SumHeader);                     // 创建新的节点
                    SumTmp-&gt;Poly.Coefficient = Tmp1-&gt;Poly.Coefficient + Tmp2-&gt;Poly.Coefficient;
                    SumTmp-&gt;Poly.Exponent = Tmp1-&gt;Poly.Exponent;

                    Tmp1 = Tmp1-&gt;Next;                                  // 多项式1和多项式2的指针移至下一项
                    Tmp2 = Tmp2-&gt;Next;
            }
        }

    // 二、仅多项式1有余项
        else if (Tmp1 != NULL &amp;&amp; Tmp2 == NULL)
        {
        // 考虑式子的指数是否与现节点的指数相同
            if (Tmp1-&gt;Poly.Exponent != SumTmp-&gt;Poly.Exponent)           // 相异
            {
                SumTmp = CreateNode(SumHeader);                         // 创建新的节点
                SumTmp-&gt;Poly.Coefficient = Tmp1-&gt;Poly.Coefficient;
                SumTmp-&gt;Poly.Exponent = Tmp1-&gt;Poly.Exponent;
            }
            else                                                        // 相同
                SumTmp-&gt;Poly.Coefficient += Tmp1-&gt;Poly.Coefficient;

            Tmp1 = Tmp1-&gt;Next;                                          // 多项式1的指针移至下一项
        }

    // 三、仅多项式2有余项
        else if (Tmp1 == NULL &amp;&amp; Tmp2 != NULL)
        {
        // 考虑式子的指数是否与现节点的指数相同
            if (Tmp2-&gt;Poly.Exponent != SumTmp-&gt;Poly.Exponent)           // 相异
            {
                SumTmp = CreateNode(SumHeader);                         // 创建新的节点
                SumTmp-&gt;Poly.Coefficient = Tmp2-&gt;Poly.Coefficient;
                SumTmp-&gt;Poly.Exponent = Tmp2-&gt;Poly.Exponent;
            }
            else                                                        // 相同
                SumTmp-&gt;Poly.Coefficient += Tmp2-&gt;Poly.Coefficient;

            Tmp2 = Tmp2-&gt;Next;                                          // 多项式2的指针移至下一项
        }
    }

    SumTmp = SumHeader-&gt;Next;                                           // 消除个别情况下多余的节点
    if (SumTmp-&gt;Next != NULL)
    {
        SumHeader-&gt;Next = SumTmp-&gt;Next;
        free(SumTmp);
    }

    return SumHeader;
}</code></pre> 
 <p style="text-indent:1.4em;"><span class="kdocs-bold" style="font-weight:bold;">注意</span>：部分情况可能会产生多余的节点1，即第一个节点，需要进行删除，即以下代码：</p> 
 <pre class="kdocs-c-like"><code class="language-c-like">    SumTmp = SumHeader-&gt;Next;                                           // 消除个别情况下多余的节点
    if (SumTmp-&gt;Next != NULL)
    {
        SumHeader-&gt;Next = SumTmp-&gt;Next;
        free(SumTmp);
    }</code></pre> 
 <p style="text-indent:1.4em;"><span class="kdocs-bold" style="font-weight:bold;">测试结果</span>：</p> 
 <div class="kdocs-line-container" style="display:flex;justify-content:center;"> 
  <div class="kdocs-img" style="background-color:#F5F7F9;flex-direction:column;max-width:100%;display:flex;width:484;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:123.96694%;height:0;"> 
    <img src="https://images2.imgbox.com/d6/93/BEjXhZs0_o.png" style="margin-left:;border:solid 1px #E4E4E4;display:block;width:100.0%;margin-top:-123.96694%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <hr> 
 <h3 style="">四、完整代码</h3> 
 <pre class="kdocs-c-like"><code class="language-c-like">/* List.h -- 链表头文件 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#ifndef LIST_H_
#define LIST_H_

typedef struct Polynomial       // 元素
{
    int Coefficient;            // 系数
    int Exponent;               // 指数
} Polynomial;
typedef struct Node             // 节点
{
    Polynomial Poly;
    struct Node* Next;
} Node;
typedef Node* List;             // 多项式的项在链表中按指数由大到小排列

List CreateHeader(void);                           // 创建多项式的表头
Node* CreateNode(List Header);                     // 创建一个节点
void ZeroPolynomial(Node* Ptr);                    // 使节点中的系数和指数的值都为0
List AddPolynomial(List Header1, List Header2);    // 两个多项式求和

#endif</code></pre> 
 <pre class="kdocs-c-like"><code class="language-c-like">/* List.c -- 操作链表得函数的定义 */
#include "List.h"

/*
    参数：1个：待初始化的节点的指针
    结果：节点中的系数和指数都初始化为0
*/
void ZeroPolynomial(Node* Ptr)
{
    if (Ptr != NULL)                       // 防止传入空指针
    {
        Ptr-&gt;Poly.Coefficient = 0;         // 系数初始化为0
        Ptr-&gt;Poly.Exponent = 0;            // 指数初始化为0
        Ptr-&gt;Next = NULL;
    }
}

/*
    参数：1个：多项式的表头
    结果：在链表后创建一个节点，并初始化系数和指数为0
    返回：若成功创建，返回创建得节点的指针；否则，返回NULL
*/
Node* CreateNode(List Header)
{
    Node* Ptr, * Tmp;                      // Ptr -- 接收创建得节点的指针
                                           // Tmp -- 临时存放指针，用于寻找链表末尾
    Ptr = (Node*)malloc(sizeof(Node));
    if (Ptr == NULL)
    {
        ferror("Wrong");
        return NULL;
    }
    ZeroPolynomial(Ptr);                   // 初始化节点

    Tmp = Header;                          // 寻找链表末尾
    while (Tmp-&gt;Next != NULL)
        Tmp = Tmp-&gt;Next;

    Tmp-&gt;Next = Ptr;                       // 将创建得节点添加至链表末尾

    return Ptr;
}

/*
    参数：无
    结果：创建多项式的表头
    返回：若成功创建，返回表头指针；否则，返回NULL
*/
List CreateHeader(void)
{
    List Header;

    Header = (List)malloc(sizeof(Node));
    if (Header == NULL)
    {
        ferror("Wrong");
        return NULL;
    }

    ZeroPolynomial(Header);                 // 初始化表头

    return Header;
}

/*
    参数：2个：多项式1的表头；多项式2的表头
    结果：将多项式1和多项式2相加，并存放在列表中，按指数由大到小排列
    返回：返回相加后的多形式的表头
*/
List AddPolynomial(List Header1, List Header2)
{
    List SumHeader;                           // 求和结果的表头
    Node* Tmp1, * Tmp2, * SumTmp;             // Tmp1 -- 接收多项式1的链表的指针；Tmp2 -- 接受多项式2的链表的指针
                                              // 接收结果的链表的指针
    SumHeader = CreateHeader();

    SumTmp = CreateNode(SumHeader);
    Tmp1 = Header1-&gt;Next;
    Tmp2 = Header2-&gt;Next;

/*
    三种情况：
        一、多项式1和多项式2都有余项 -- 1） 式1指数 &gt; 式2指数
                                      2） 式1指数 &lt; 式2指数
                                      3） 式1指数 = 式2指数（一定与现节点的指数相异）
        二、仅多项式1有余项
        三、仅多项式2有余项

    除 一/3）外，需进一步考虑式子的指数是否与现节点的指数相同 -- 相异：创建新的节点
                                                            相同：在原来的基础上相加
*/
    while (Tmp1 != NULL || Tmp2 != NULL)                                // 某一个多项式仍有余项
    {
    // 一、多项式1和多项式2都有余项
        if (Tmp1 != NULL &amp;&amp; Tmp2 != NULL)
        {
        // 1）式1指数 &gt; 式2指数
            if (Tmp1-&gt;Poly.Exponent &gt; Tmp2-&gt;Poly.Exponent)
            {
            // 考虑式子的指数是否与现节点的指数相同
                if (Tmp1-&gt;Poly.Exponent != SumTmp-&gt;Poly.Exponent)       // 相异
                {
                    SumTmp = CreateNode(SumHeader);                     // 创建新的节点
                    SumTmp-&gt;Poly.Coefficient = Tmp1-&gt;Poly.Coefficient;
                    SumTmp-&gt;Poly.Exponent = Tmp1-&gt;Poly.Exponent;
                }
                else                                                    // 相同
                    SumTmp-&gt;Poly.Coefficient += Tmp1-&gt;Poly.Coefficient;

                Tmp1 = Tmp1-&gt;Next;                                      // 多项式1的指针移至下一项
            }

        // 2）式1指数 &lt; 式2指数
            else if (Tmp1-&gt;Poly.Exponent &lt; Tmp2-&gt;Poly.Exponent)
            {
            // 考虑式子的指数是否与现节点的指数相同
                if (Tmp2-&gt;Poly.Exponent != SumTmp-&gt;Poly.Exponent)       // 相异
                {
                    SumTmp = CreateNode(SumHeader);
                    SumTmp-&gt;Poly.Coefficient = Tmp2-&gt;Poly.Coefficient;
                    SumTmp-&gt;Poly.Exponent = Tmp2-&gt;Poly.Exponent;
                }
                else                                                    // 相同
                    SumTmp-&gt;Poly.Coefficient += Tmp2-&gt;Poly.Coefficient;

                Tmp2 = Tmp2-&gt;Next;                                      // 多项式2的指针移至下一项
            }

        // 3）式1指数 = 式2指数（一定与现节点的指数相异）
            else if (Tmp1-&gt;Poly.Exponent == Tmp2-&gt;Poly.Exponent)
            {
                    SumTmp = CreateNode(SumHeader);                     // 创建新的节点
                    SumTmp-&gt;Poly.Coefficient = Tmp1-&gt;Poly.Coefficient + Tmp2-&gt;Poly.Coefficient;
                    SumTmp-&gt;Poly.Exponent = Tmp1-&gt;Poly.Exponent;

                    Tmp1 = Tmp1-&gt;Next;                                  // 多项式1和多项式2的指针移至下一项
                    Tmp2 = Tmp2-&gt;Next;
            }
        }

    // 二、仅多项式1有余项
        else if (Tmp1 != NULL &amp;&amp; Tmp2 == NULL)
        {
        // 考虑式子的指数是否与现节点的指数相同
            if (Tmp1-&gt;Poly.Exponent != SumTmp-&gt;Poly.Exponent)           // 相异
            {
                SumTmp = CreateNode(SumHeader);                         // 创建新的节点
                SumTmp-&gt;Poly.Coefficient = Tmp1-&gt;Poly.Coefficient;
                SumTmp-&gt;Poly.Exponent = Tmp1-&gt;Poly.Exponent;
            }
            else                                                        // 相同
                SumTmp-&gt;Poly.Coefficient += Tmp1-&gt;Poly.Coefficient;

            Tmp1 = Tmp1-&gt;Next;                                          // 多项式1的指针移至下一项
        }

    // 三、仅多项式2有余项
        else if (Tmp1 == NULL &amp;&amp; Tmp2 != NULL)
        {
        // 考虑式子的指数是否与现节点的指数相同
            if (Tmp2-&gt;Poly.Exponent != SumTmp-&gt;Poly.Exponent)           // 相异
            {
                SumTmp = CreateNode(SumHeader);                         // 创建新的节点
                SumTmp-&gt;Poly.Coefficient = Tmp2-&gt;Poly.Coefficient;
                SumTmp-&gt;Poly.Exponent = Tmp2-&gt;Poly.Exponent;
            }
            else                                                        // 相同
                SumTmp-&gt;Poly.Coefficient += Tmp2-&gt;Poly.Coefficient;

            Tmp2 = Tmp2-&gt;Next;                                          // 多项式2的指针移至下一项
        }
    }

    SumTmp = SumHeader-&gt;Next;                                           // 消除个别情况下多余的节点
    if (SumTmp-&gt;Next != NULL)
    {
        SumHeader-&gt;Next = SumTmp-&gt;Next;
        free(SumTmp);
    }

    return SumHeader;
}</code></pre> 
 <pre class="kdocs-c-like"><code class="language-c-like">/* Polynomial.c -- 测试程序 */
#include "List.h"

void Input(List Header)
{
    int coefficient, exponent;
    Node* ptr;

    ptr = CreateNode(Header);

    printf("Enter coefficient-&gt; ");
    scanf("%d", &amp;coefficient);
    getchar();
    printf("Enter exponent-&gt; ");
    scanf("%d", &amp;exponent);
    getchar();

    ptr-&gt;Poly.Coefficient = coefficient;
    ptr-&gt;Poly.Exponent = exponent;
}

void Output(List Header)
{
    Node* ptr;

    ptr = Header-&gt;Next;

    while (ptr != NULL)
    {
        printf("%dX^%d", ptr-&gt;Poly.Coefficient, ptr-&gt;Poly.Exponent);
        if ((ptr = ptr-&gt;Next) != NULL)
            printf(" + ");
    }
    putchar('\n');
}

void getch(char* ch)
{
    *ch = getchar();
    while (getchar() != '\n')
        continue;
}

int main()
{
    List Header1, Header2, SumHeader;
    char ch;

    Header1 = CreateHeader();
    Header2 = CreateHeader();

    printf("Enter the first polynomial (type n to exit).\ny/n-&gt; ");
    getch(&amp;ch);
    while (ch != 'n')
    {
        Input(Header1);
        printf("y/n-&gt; ");
        getch(&amp;ch);
    }

    printf("Enter the second polynomial (type n to exit).\ny/n-&gt; ");
    getch(&amp;ch);
    while (ch != 'n')
    {
        Input(Header2);
        printf("y/n-&gt; ");
        getch(&amp;ch);
    }

    SumHeader = AddPolynomial(Header1, Header2);

    Output(Header1);
    Output(Header2);
    Output(SumHeader);


    return 0;
}</code></pre> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2f3bef836bc32a5e1317cc9f9f3541b6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux树莓派开发——配置树莓派内核源码，内核编译，更换树莓派Linux内核</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/acec9e69cf8a551b797baa05e310b714/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue使用echarts很卡 &#39;requestAnimationFrame&#39; handler took 64ms</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>