<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;中函数返回引用，及问题 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;中函数返回引用，及问题" />
<meta property="og:description" content="目录
函数返回值 返回引用 （**）
C&#43;&#43;基础知识 - 函数返回引用深度解析
关于函数调用返回引用错误并且每次调用不一致的分析与解决
将引用作为函数返回值的格式、好处和规则
实用经验 45 禁止函数返回局部变量的引用
---------------------------------------------------------
（1）返回的是一个引用类型，也就是返回值是绑定在该临时变量上， 一旦该临时变量被销毁，就会导致返回的引用变量是一个不可预估的数值。
所以正确的做法是，将该函数的返回类型定义为一个const变量。
const TSize TComPointCloud::getNumPoint() const
{
return m_pos.size();
}
这样函数调用返回类型是一个变量，也就是将 该变量复制给 另外一个变量之后 被销毁，因为是复制，两个变量之间是相互独立的。
（2）如果一个函数返回的类型为引用，那么，
返回的引用会绑定到该函数的返回 return value; (变量value 就会绑定到 返回引用变量，一旦该返回变量value被销毁，那么，返回的引用 就会绑定到 被销毁的变量，这个值是不确定的，这也就是每次调用时都会看到不同结果的原因)
===================================
实用经验 45 禁止函数返回局部变量的引用 请谨记
函数返回时，保证返回数据超出函数范围后依然有效。像返回局部变量的引入就是不靠谱的事情。函数返回时，返回new生成的对象，同样不是一个可取的方法。因为这样的代码层次混乱，会让代码上层使用人员苦不堪言。 实用经验 45 禁止函数返回局部变量的引用_@一鸣惊人的博客-CSDN博客
将引用作为函数返回值的格式、好处和规则 格式： 类型标识符 &amp;函数名（形参列表及类型说明）{//函数体}
好处： 在内存中不产生返回值的副本（返回一个局部变量的引用是不可取的，因为随着局部变量生存周期的结束，相应的引用也会失效，产生runtime error）
注意： 不能返回局部变量的引用，局部变量会在函数返回后被销毁。不能返回函数内部new分配的内存的引用，虽然不存在局部变量的被动销毁问题，但是函数返回的引用只是作为一个临时变量出现，并没有被赋予一个实际的变量，导致引用所指向的空间无法释放。可以返回类成员的引用，但最好是const，主要原因是当对象的属性与某种业务规则相关联的时候，其赋值常常与某些其它属性或者对象的状态相关联，因此有必要将赋值操作封装在一个业务规则中，如果其它对象可以获得该属性的非常量引用（或指针），那么对于该属性的单纯赋值就会破坏业务规则的完整性。流操作符重载返回值申明为“引用”的作用：&lt;&lt;和&gt;&gt;常常希望被连续使用，因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选方案包括：返回一个流对象和返回一个流对象指针。返回一个流对象，程序必须重新构造一个新的流对象，两个&lt;&lt;操作符实际上是针对了不同对象；返回一个流对象指针，并不能连续使用&lt;&lt;操作符。返回一个流对象引用则是唯一选择。 转载于:https://www.cnblogs.com/yingl/p/5815554.html
关于函数调用返回引用错误并且每次调用不一致的分析与解决 引用与指针的区别 1.引用不能为空，不存在空引用，但是指针却可以存在空指针，这就意味着我们拿到一个引用时不需要判断引用是否为空，但是如果拿到的是一个指针，则需要判断指针是否为空之后再进行指针的进一步操作。
2、引用一旦建立，将一直效忠于他，不能再引用。
引用与变量的区别 1.如果将一个变量绑定到一个引用上，那么如果这个引用发生改变，它所指向的变量也会发生改变。（这点非常重要，特别是在函数调用时，经常将函数的形参设计为引用类型，来达到形参发生改变实参改变的目的）；
2.如果一个函数返回的类型为引用，那么，
返回的引用会绑定到该函数的返回 return value; (变量value 就会绑定到返回引用变量，一旦该返回变量value被销毁，那么返回的引用就会绑定到被销毁的变量，这个值是不确定的，这也就是每次调用时都会看到不同结果的原因)
例如：函数getNumPoint的主要功能是返回变量m_pos的长度，但是该函数最终返回的类型是const 引用类型。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/e77bf8873a57c2e18e282b59f361e2d6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-31T00:33:28+08:00" />
<meta property="article:modified_time" content="2023-07-31T00:33:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;中函数返回引用，及问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>目录</p> 
<p>函数返回值 返回引用 （**）</p> 
<p>C++基础知识 - 函数返回引用深度解析</p> 
<p>关于函数调用返回引用错误并且每次调用不一致的分析与解决</p> 
<p>将引用作为函数返回值的格式、好处和规则</p> 
<p>实用经验 45 禁止函数返回局部变量的引用</p> 
<p></p> 
<p>---------------------------------------------------------</p> 
<p></p> 
<h4>（1）返回的是一个引用类型，也就是<strong><span style="color:#fe2c24;">返回值是绑定在该临时变量上</span></strong>，</h4> 
<p>一旦该临时变量被销毁，就会导致返回的引用变量是一个不可预估的数值。<br> 所以正确的做法是，<strong>将该函数的返回类型定义为一个<span style="color:#ed7976;">const变量</span></strong>。</p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>const </strong></span><span style="color:#4da8ee;"><strong>TSize</strong></span> TComPointCloud::getNumPoint() const<br> {<!-- --><br>   return m_pos.size();<br> }</p> 
</blockquote> 
<p>这样函数调用返回类型是一个变量，也就是将 该变量<span style="color:#fe2c24;"><strong>复制给</strong></span><strong> 另外一个变量之<span style="color:#956fe7;">后</span><span style="color:#fe2c24;"> 被销毁</span></strong>，因为<span style="color:#fe2c24;"><strong>是复制</strong></span><span style="color:#be191c;">，两个变量之间是</span><span style="color:#ed7976;"><strong>相互独立</strong></span><span style="color:#be191c;">的。</span></p> 
<p></p> 
<p>（2）如果一个函数返回的类型为引用，那么，</p> 
<h3><strong><span style="color:#fe2c24;">返回的引用</span><span style="color:#956fe7;">会绑定到</span></strong>该函数的<span style="color:#ed7976;"><strong>返回 return </strong></span><span style="color:#fe2c24;"><strong>value</strong></span><span style="color:#ed7976;"><strong>;</strong></span></h3> 
<p>(<strong><span style="color:#be191c;">变量value</span></strong> 就会<span style="color:#956fe7;"><strong>绑定到</strong></span> <strong><span style="color:#fe2c24;">返回引用变量</span></strong>，<span style="color:#be191c;">一旦该返回变量value被销毁，那么，</span><span style="color:#fe2c24;"><strong>返回的引用 </strong></span><span style="color:#4da8ee;"><strong>就会绑定到</strong></span><span style="color:#fe2c24;"><strong> 被销毁的变量</strong></span><span style="color:#be191c;">，这个值是不确定的</span>，这也就是每次调用时都会看到不同结果的原因)</p> 
<p></p> 
<p>===================================</p> 
<p></p> 
<p></p> 
<h2 id="articleContentId"><span style="color:#4da8ee;">实用经验 45 禁止函数返回局部变量的引用</span></h2> 
<p><strong>请谨记</strong></p> 
<ul><li>函数返回时，保证返回数据超出函数范围后依然有效。像返回局部变量的引入就是不靠谱的事情。</li><li>函数返回时，<strong><span style="color:#ed7976;">返回new生成的对象，同样不是一个可取的</span></strong>方法。因为这样的<strong><span style="color:#fe2c24;">代码层次混乱</span></strong>，会让代码上层使用人员苦不堪言。</li></ul> 
<p><a href="https://liuguang.blog.csdn.net/article/details/118913831?spm=1001.2101.3001.6650.17&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-17-118913831-blog-108689853.235%5Ev38%5Epc_relevant_sort_base3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-17-118913831-blog-108689853.235%5Ev38%5Epc_relevant_sort_base3&amp;utm_relevant_index=18" rel="nofollow" title="实用经验 45 禁止函数返回局部变量的引用_@一鸣惊人的博客-CSDN博客">实用经验 45 禁止函数返回局部变量的引用_@一鸣惊人的博客-CSDN博客</a></p> 
<p></p> 
<p></p> 
<p></p> 
<h2><span style="color:#4da8ee;">将引用作为函数返回值的格式、好处和规则</span></h2> 
<h4>格式：</h4> 
<blockquote> 
 <p>类型标识符 &amp;函数名（形参列表及类型说明）{//函数体}</p> 
</blockquote> 
<h4>好处：</h4> 
<p>在内存中不产生返回值的副本（返回一个局部变量的引用是不可取的，因为随着局部变量生存周期的结束，相应的引用也会失效，产生runtime error）</p> 
<h4>注意：</h4> 
<ul><li>不能返回局部变量的引用，局部变量会在函数返回后被销毁。</li><li>不能返回函数内部new分配的内存的引用，虽然不存在局部变量的被动销毁问题，但是函数返回的引用只是作为一个临时变量出现，并没有被赋予一个实际的变量，导致引用所指向的空间无法释放。</li><li>可以返回类成员的引用，但最好是const，主要原因是当对象的属性与某种业务规则相关联的时候，其赋值常常与某些其它属性或者对象的状态相关联，因此有必要将赋值操作封装在一个业务规则中，如果其它对象可以获得该属性的非常量引用（或指针），那么对于该属性的单纯赋值就会破坏业务规则的完整性。</li><li>流操作符重载返回值申明为“引用”的作用：&lt;&lt;和&gt;&gt;常常希望被连续使用，因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选方案包括：返回一个流对象和返回一个流对象指针。返回一个流对象，程序必须重新构造一个新的流对象，两个&lt;&lt;操作符实际上是针对了不同对象；返回一个流对象指针，并不能连续使用&lt;&lt;操作符。返回一个流对象引用则是唯一选择。</li></ul> 
<p>转载于:https://www.cnblogs.com/yingl/p/5815554.html</p> 
<p></p> 
<p></p> 
<h2><span style="color:#4da8ee;">关于函数调用返回引用错误并且每次调用不一致的分析与解决</span></h2> 
<h4>引用与指针的区别</h4> 
<p>1.引用不能为空，不存在空引用，但是指针却可以存在空指针，这就意味着我们拿到一个引用时不需要判断引用是否为空，但是如果拿到的是一个指针，则需要判断指针是否为空之后再进行指针的进一步操作。</p> 
<p>2、引用一旦建立，将一直效忠于他，不能再引用。</p> 
<p></p> 
<h4>引用与变量的区别</h4> 
<p>1.如果将一个变量绑定到一个引用上，那么如果这个引用发生改变，它所指向的变量也会发生改变。（这点非常重要，特别是<span style="color:#be191c;">在函数调用时，经常将函数的形参设计为引用类型，来达到形参发生改变实参改变的目的</span>）；</p> 
<p>2.如果一个函数返回的类型为引用，那么，</p> 
<h3><strong><span style="color:#fe2c24;">返回的引用</span><span style="color:#956fe7;">会绑定到</span></strong>该函数的<span style="color:#ed7976;"><strong>返回 return </strong></span><span style="color:#fe2c24;"><strong>value</strong></span><span style="color:#ed7976;"><strong>;</strong></span></h3> 
<p>(变量value 就会绑定到返回引用变量，一旦该返回变量value被销毁，那么返回的引用就会绑定到被销毁的变量，这个值是不确定的，这也就是每次调用时都会看到不同结果的原因)</p> 
<p>例如：函数getNumPoint的主要功能是返回变量m_pos的长度，但是该函数最终返回的类型是const 引用类型。</p> 
<blockquote> 
 <p>const TSize&amp; TComPointCloud::getNumPoint() const<br> {<!-- --><br>   return m_pos.size();<br> }</p> 
</blockquote> 
<p>下面我们来分析一下这个函数错误的原因，该函数每次调用都会调用变量m_pos的一个内部函数size(),而该函数返回的变量是一个临时变量temp,该临时变量的有效域也就仅仅限制与函数getNumPoint作用域，也就是当函数getNumPoint调用return语句之后，<span style="color:#fe2c24;">该变量就会被销毁</span>，但是我们现在</p> 
<h3>返回的是一个引用类型，也就是<strong><span style="color:#fe2c24;">返回值是绑定在该临时变量上</span></strong>，</h3> 
<p>一旦该临时变量被销毁，就会导致返回的引用变量是一个不可预估的数值。<br> 所以正确的做法是，<strong>将该函数的返回类型定义为一个const变量</strong>。</p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>const </strong></span><span style="color:#4da8ee;"><strong>TSize</strong></span> TComPointCloud::getNumPoint() const<br> {<!-- --><br>   return m_pos.size();<br> }</p> 
</blockquote> 
<p>这样函数调用返回类型是一个变量，也就是将改变量<span style="color:#fe2c24;"><strong>复制给</strong></span>另外一个变量之<span style="color:#fe2c24;">后被销毁</span>，因为<span style="color:#be191c;">是复制，两个变量之间是相互独立的。</span></p> 
<p>————————————————<br> 版权声明：本文为CSDN博主「@眼里有星河」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br> 原文链接：https://blog.csdn.net/weixin_44312010/article/details/102767914</p> 
<p></p> 
<p></p> 
<h2><span style="color:#4da8ee;">函数返回值 返回引用</span></h2> 
<p> 先看看该链接讨论的问题作为热身。http://topic.csdn.net/u/20070616/13/2a6a1739-1a69-4829-a90f-fdb19a61e095.html</p> 
<p>函数返回值和返回引用是不同的</p> 
<p>函数返回值时会产生一个临时变量作为函数返回值的副本，而返回引用时不会产生值的副本。</p> 
<h3>既然是引用，那引用谁呢？</h3> 
<p>这个问题必须清楚，否则将无法理解返回引用到底是个什么概念。以下是几种引用情况：</p> 
<p></p> 
<h4>1，引用函数的参数，当然该参数也是一个引用</h4> 
<blockquote> 
 <p>     const string &amp;shorterString(const string &amp;<span style="color:#fe2c24;">s1</span>,const string &amp;<span style="color:#fe2c24;">s2</span>)<br>       {<!-- --><br>              return s1.size()&lt;s2.size()?<span style="color:#fe2c24;">s1:s2</span>;<br>       }</p> 
</blockquote> 
<p>      以上函数的返回值是引用类型。无论返回s1或是s2,调用函数和返回结果时，都没有复制这些string对象。简单的说，返回的引用是函数的参数s1或s2，同样s1和s2也是引用，而不是在函数体内产生的。函数体内局部对象是不能被因哟个的，因为函数调用完局部对象会被释放。</p> 
<p></p> 
<h4>2，千万不要返回局部对象的引用</h4> 
<blockquote> 
 <p>      const string &amp;mainip(const string &amp;s)<br>       {<!-- --><br>              string ret=s;<br>              return ret;<br>       }</p> 
</blockquote> 
<p>          当函数执行完毕，程序将释放分配给局部对象的存储空间。此时，对局部对象的引用就会指向不确定的内存。</p> 
<p></p> 
<p>3，在类的成员函数中，返回引用的类对象，当然不能是函数内定义的类对象（会释放掉），一般为this指向的对象，典型的例子是string类的赋值函数。</p> 
<p>[cpp]  view plain  copy</p> 
<blockquote> 
 <p>    <strong><span style="color:#ed7976;">String&amp;</span></strong> String::operator =(const String <span style="color:#ed7976;"><strong>&amp;str</strong></span>)  //注意与“+”比较，函数为什么要用引用呢？a=b=c，可以做为左值  <br>     {  <br>         if (this == &amp;str)  <br>         {  <br>             return *this;    <br>         }  <br>         delete [] m_string;  <br>         int len = strlen(str.m_string);  <br>         m_string = new char[len+1];  <br>         strcpy(m_string,str.m_string);  <br>         <strong>return <span style="color:#fe2c24;">*this</span>;  </strong><br>     }  </p> 
</blockquote> 
<p>这与sting类中的“+”运算符重载不一样。“+”运算符的重载不能返回引用，因为它返回的是在函数内定义的类对象，附上代码。</p> 
<p>[cpp]  view plain  copy</p> 
<blockquote> 
 <p>    String String::operator +(const String &amp;str)      <br>     {  <br>         String newstring;  <br>         if (!str.m_string)  <br>         {  <br>             newstring = *this;  <br>         }  <br>         else if (!m_string)  <br>         {  <br>             newstring = str;  <br>         }  <br>         else  <br>         {  <br>             int len = strlen(m_string)+strlen(str.m_string);  <br>             newstring.m_string = new char[len+1];  <br>             strcpy(newstring.m_string,m_string);  <br>             strcat(newstring.m_string,str.m_string);  <br>         }  <br>         return newstring;  <br>     }  </p> 
</blockquote> 
<p></p> 
<h4>4，引用返回左值（上例的=赋值也是如此，即a=b=c是可以的）</h4> 
<blockquote> 
 <p>      char &amp;get_val(string &amp;str,string::size_type ix)<br>       {<!-- --><br>              return str[ix];<br>       }</p> 
 <p>      使用语句调用:<br>        string s("123456");<br>        cout&lt;&lt;s&lt;&lt;endl;<br>        get_val(s,0)='a';<br>        cout&lt;&lt;s&lt;&lt;endl;</p> 
</blockquote> 
<p></p> 
<p>最后转上一段code作为总结。</p> 
<p>[cpp]  view plain  copy</p> 
<blockquote> 
 <p>    #include&lt;iostream&gt;  <br>     using namespace std;  <br>     string make_plural(size_t,const string&amp;,const string&amp;);  <br>     const string &amp;shorterString(const string &amp;,const string &amp;);  <br>     const string &amp;mainip(const string&amp;);  <br>     char &amp;get_val(string &amp;,string::size_type);  <br>     int main(void)  <br>     {  <br>         cout&lt;&lt;make_plural(1,"dog","s")&lt;&lt;endl;  <br>         cout&lt;&lt;make_plural(2,"dog","s")&lt;&lt;endl;  <br>           <br>         string string1="1234";  <br>         string string2="abc";  <br>         cout&lt;&lt;shorterString(string1,string2)&lt;&lt;endl;  <br>           <br>         cout&lt;&lt;mainip("jiajia")&lt;&lt;endl;  <br>           <br>           <br>         string s("123456");  <br>         cout&lt;&lt;s&lt;&lt;endl;  <br>         get_val(s,0)='a';  <br>           <br>         cout&lt;&lt;s&lt;&lt;endl;  <br>           <br>         getchar();  <br>         return 0;  <br>     }  <br>     //返回非引用   <br>     string make_plural(size_t i,const string &amp;word,const string &amp;ending)  <br>     {  <br>         return (i==1)?word:word+ending;  <br>     }  <br>     //返回引用   <br>     const string &amp;shorterString(const string &amp;s1,const string &amp;s2)  <br>     {  <br>         return s1.size()&lt;s2.size()?s1:s2;  <br>     }  <br>     //禁止返回局部对象的引用（我的dev c++ 没有报错，比较可怕）   <br>     const string &amp;mainip(const string &amp;s)  <br>     {  <br>         string ret=s;  <br>         return ret;  <br>     }  <br>     //引用返回左值  <br>     char &amp;get_val(string &amp;str,string::size_type ix)  <br>     {  <br>         return str[ix];  <br>     }  </p> 
 <p><br> //函数返回值//</p> 
</blockquote> 
<h3></h3> 
<h3>不带返回值的 return 语句只能用于返回类型为 void 的函数。</h3> 
<p>在返回类型为 void 的函数中，return 返回语句不是必需的，隐式的 return 发生在函数的最后一个语句完成时。</p> 
<p>一般情况下，返回类型是 void 的函数使用 return 语句是为了引起函数的强制结束，这种 return 的用法类似于循环结构中的 break 语句的作用。例如，可如下重写 swap 程序，使之在输入的两个数值相同时不执行任何工作：</p> 
<blockquote> 
 <p>  // ok: swap acts on references to its arguments<br>   void swap(int &amp;v1, int &amp;v2)<br>   {<!-- --><br>   // if values already the same, no need to swap, just return<br>   if (v1 == v2)<br>   return;<br>   // ok, have work to do<br>   int tmp = v2;<br>   v2 = v1;<br>   v1 = tmp;<br>   // no explicit return necessary<br>   }</p> 
</blockquote> 
<p>这个函数首先检查两个值是否相等，如果相等则退出函数；如果不相等，则交换这两个值，隐式的 return 发生在最后一个赋值语句后。</p> 
<p>返回类型为 void 的函数通常不能使用第二种形式的 return 语句，但是，它可以返回另一个返回类型同样是 void 的函数的调用结果：</p> 
<blockquote> 
 <p>  void do_swap(int &amp;v1, int &amp;v2)<br>   {<!-- --><br>   int tmp = v2;<br>   v2 = v1;<br>   v1 = tmp;<br>   // ok: void function doesn't need an explicit return<br>   }<br>   void swap(int &amp;v1, int &amp;v2)<br>   {<!-- --><br>   if (v1 == v2)<br>   return false; // error: void function cannot return a value<br>   return do_swap(v1, v2); // ok: returns call to a void function</p> 
 <p>  }</p> 
</blockquote> 
<p>返回任何其他表达式的尝试都会导致编译时的错误。</p> 
<p>返回类型不是 void 的函数必须返回一个值，但此规则有一个例外情况：允许主函数 main 没有返回值就可结束。如果程序控制执行到主函数 main 的最后一个语句都还没有返回，那么编译器会隐式地插入返回 0 的语句。</p> 
<p>关于主函数 main 返回的另一个特别之处在于如何处理它的返回值。可将主函数 main 返回的值视为状态指示器。返回 0 表示程序运行成功，其他大部分返回值则表示失败。非 0 返回值的意义因机器不同而不同，为了使返回值独立于机器，cstdlib 头文件定义了两个预处理变量，分别用于表示程序运行成功和失败：</p> 
<blockquote> 
 <p>  #include &lt;cstdlib&gt;<br>   int main()<br>   {<!-- --><br>   if (some_failure)<br>   return EXIT_FAILURE;<br>   else<br>   return EXIT_SUCCESS;<br>   }</p> 
</blockquote> 
<p>我们的代码不再需要使用那些依赖于机器的精确返回值。相应地，这些值都在 cstdlib 库中定义，我们的代码不需要做任何修改。</p> 
<p>函数的返回值用于初始化在调用函数处创建的临时对象。在求解表达式时，如果需要一个地方储存其运算结果，编译器会创建一个没有命名的对象，这就是临时对象。在英语中，C++ 程序员通常用 temporary 这个术语来代替 temporary object。</p> 
<p>用函数返回值初始化临时对象与用实参初始化形参的方法是一样的。如果返回类型不是引用，在调用函数的地方会将函数返回值复制给临时对象。当函数返回非引用类型时，其返回值既可以是局部对象，也可以是求解表达式的结果。</p> 
<p>例如，下面的程序提供了一个计数器、一个单词 word 和单词结束字符串 ending，当计数器的值大于 1 时，返回该单词的复数版本：</p> 
<p>  // return plural version of word if ctr isn't 1<br>   string make_plural(size_t ctr, const string &amp;word,<br>   const string &amp;ending)<br>   {<!-- --><br>   return (ctr == 1) ? word : word + ending;<br>   }</p> 
<p>这个函数要么返回其形参 word 的副本，要么返回一个未命名的临时 string 对象，这个临时对象是由字符串 word 和 ending 的相加而产生的。这两种情况下，return 都在调用该函数的地方复制了返回的 string 对象。</p> 
<p><br> 当函数返回引用类型时，没有复制返回值。相反，返回的是对象本身。例如，考虑下面的函数，此函数返回两个 string 类型形参中较短的那个字符串的引用：</p> 
<p>  // find longer of two strings<br>   const string &amp;shorterString(const string &amp;s1, const string &amp;s2)<br>   {<!-- --><br>   return s1.size() &lt; s2.size() ? s1 : s2;<br>   }</p> 
<p>形参和返回类型都是指向 const string 对象的引用，调用函数和返回结果时，都没有复制这些 string 对象。</p> 
<p>注意：千万不能返回局部变量的引用，同理，也不能返回指向局部变量的指针。</p> 
<p>当函数执行完毕时，将释放分配给局部对象的存储空间。此时，对局部对象的引用就会指向不确定的内存。考虑下面的程序：</p> 
<p>  // Disaster: Function returns a reference to a local object<br>   const string &amp;manip(const string&amp; s)<br>   {<!-- --><br>   string ret = s;<br>   // transform ret in some way<br>   return ret; // Wrong: Returning reference to a local object!<br>   }</p> 
<p>这个函数会在运行时出错，因为它返回了局部对象的引用。当函数执行完毕，字符串 ret 占用的储存空间被释放，函数返回值指向了对于这个程序来说不再有效的内存空间。</p> 
<p><br> 返回引用的函数返回一个左值。因此，这样的函数可用于任何要求使用左值的地方：</p> 
<p>  char &amp;get_val(string &amp;str, string::size_type ix)<br>   {<!-- --><br>   return str[ix];<br>   }<br>   int main()<br>   {<!-- --><br>   string s("a value");<br>   cout &lt;&lt; s &lt;&lt; endl; // prints a value<br>   get_val(s, 0) = 'A'; // changes s[0] to A</p> 
<p>  cout &lt;&lt; s &lt;&lt; endl; // prints A value<br>   return 0;<br>   }</p> 
<p>给函数返回值赋值可能让人惊讶，由于函数返回的是一个引用，因此这是正确的，该引用是被返回元素的同义词。</p> 
<p>如果不希望引用返回值被修改，返回值应该声明为 const：</p> 
<p>  const char &amp;get_val(...</p> 
<p><br> 传值和传址的区别</p> 
<p>传值时就是在内存中新开辟一个空间，将值赋给这个新开辟的空间，其生命周期为该函数调用结束时释放该空闲，计算结果不影响原调用数据内存空间的值。<br> 传址时同样新开辟一个空间，但不同的是将所用数据空间的内存地址存在新开辟的空间中，即指针，函数在数据处理过程中由于是指针，即对源数据进行操作，操作后结果影响原数据。</p> 
<p><br> 打个比喻，一个盒子里有一个苹果，传值就是把这个苹果复制成另外一个苹果给要传的对象，至于这个对象怎么弄复制的苹果跟原来的那个没关系，而传值则是把盒子给了这个对象，那么这个对象要把这里面的苹果怎么弄那这个苹果就要改变，</p> 
<p>  <a href="https://blog.csdn.net/lx627776548/article/details/52043921/" title="函数返回值 返回引用_函数返回值加引用_lx627776548的博客-CSDN博客">函数返回值 返回引用_函数返回值加引用_lx627776548的博客-CSDN博客</a></p> 
<p></p> 
<p></p> 
<p></p> 
<h2><span style="color:#4da8ee;">C++基础知识 - 函数返回引用深度解析</span></h2> 
<h3>C++引用使用时的难点：</h3> 
<ul><li>    当函数返回值为引用时, 若返回局部变量，不能成为其它引用的初始值，不能作为左值使用</li><li>    返回静态变量 或 全局变量的引用, 可成为其他引用的初始值, 也可以作为左值, 也可作为右值</li><li>    返回函数的普通形参作为引用, 不能作为其他引用的初始值, 不能作为左值使用</li><li>    返回函数的引用形参作为引用, 可成为其他引用的初始值, 也可以作为左值, 也可作为右值</li></ul> 
<blockquote> 
 <p>#include &lt;iostream&gt;<br> #include &lt;stdlib.h&gt;<br> #include &lt;stdio.h&gt;</p> 
 <p>using namespace std;</p> 
 <p><br> int demo1() {<!-- --><br>     int i = 0;<br>     //printf("i 的地址: %p, i=%d\n", &amp;i, i);</p> 
 <p>    return i;<br> }</p> 
 <p>int &amp;demo(int **addr) {<!-- --><br>     int i = 666;<br>     *addr = &amp;i;<br>     printf("i 的地址: %p, i=%d\n", &amp;i, i);</p> 
 <p>    return i;<br> }</p> 
 <p>int &amp;demo_static(int **addr) {<!-- --><br>     static int i = 666;<br>     *addr = &amp;i;<br>     printf("demo_static： i 的地址: %p, i=%d\n", &amp;i, i);</p> 
 <p>    return i;<br> }</p> 
 <p>//3. 函数返回形参(普通参数)当引用<br> int &amp;demo3(int var) {<!-- --><br>     var = 666;<br>     return var;<br> }</p> 
 <p>//4. 函数返回形参(引用)当引用<br> int &amp;demo4(int &amp;var) {<!-- --><br>     var = 666;<br>     return var;<br> }</p> 
 <p>int main(void) {<!-- --><br>     int *addr = NULL;<br>     int ret = demo(&amp;addr);</p> 
 <p>    </p> 
 <p>    //第一种情况  函数返回局部变量引用不能成为其它引用的初始值<br>     //int &amp;i1 = demo(&amp;addr);  <br>     //i1 = 888;<br>     //printf("addr: %p i1=%d\n", addr, i1);</p> 
 <p>    //demo(&amp;addr);<br>     //demo1();<br>     //printf("addr: %p i1=%d\n", addr, i1);</p> 
 <p>    </p> 
 <p>    //第二种情况 函数返回局部变量不能做为左值<br>     /*demo(&amp;addr) = 888;<br>     printf("1. addr: %p  value: %d\n", addr, *addr);<br>     demo1();<br>     printf("2. addr: %p  value: %d\n", addr, *addr);<br>     */</p> 
 <p>    </p> 
 <p>    //第三种情况  返回静态变量或全局变量可以成为左值或是其它引用的初始值<br>     //demo_static(&amp;addr) = 888;<br>     int &amp;i1 = demo_static(&amp;addr);<br>     i1 = 888;<br>     printf("1. addr: %p  value: %d\n", addr, *addr);<br>     demo1();<br>     printf("2. addr: %p  value: %d\n", addr, *addr);<br>     demo_static(&amp;addr);<br>       <br>     system("pause");<br>     return 0;<br> }</p> 
</blockquote> 
<p>————————————————<br> 版权声明：本文为CSDN博主「骆驼胡杨」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br> 原文链接：https://blog.csdn.net/qq_34606496/article/details/123363143</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1e342d2b67897162190f829c6948ae68/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">R语言进行因子分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4925e8bbf33847240a4047ba3f223f87/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">WindowsServer 离线安装Docker&amp;端口映射</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>