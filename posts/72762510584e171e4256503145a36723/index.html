<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker常用命令原理图 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker常用命令原理图" />
<meta property="og:description" content="docker常用命令原理图概览： （一）image layer（镜像层） 镜像可以看成是由多个镜像层叠加起来的一个文件系统，镜像层也可以简单理解为一个基本的镜像，而每个镜像层之间通过指针的形式进行叠加。
根据上图，镜像层的主要组成部分包括镜像层id，镜像层指针【指向父层】，元数据【layer metadata】包含了docker构建和运行的信息还有父层的层次信息。
只读层和读写层【top layer】的组成部分基本一致。同时读写层可以转换成只读层【docker commit操作实现】
（二）image（镜像）---【只读层的集合】 1、镜像是一堆只读层的统一视角，除了最底层没有指向外，每一层都指向它的父层，统一文件系统（union file system）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。而每一层都是不可写的，就是只读层。
（三）container（容器）---【一层读写层&#43;多层只读层】 1、容器和镜像的区别在于容器的最上面一层是读写层【top layer】，而这边并没有区分容器是否在运行。运行状态的容器【running container】即一个可读写的文件系统【静态容器】&#43;隔离的进程空间和其中的进程。
隔离的进程空间中的进程可以对该读写层进行增删改，其运行状态容器的进程操作都作用在该读写层上。每个容器只能有一个进程隔离空间。
（四）docker常用命令说明 1、标识说明 1）image---（统一只读文件系统） 2）静态容器【未运行的容器】---（统一可读写文件系统） 3）动态容器【running container】---（进程空间（包括进程）&#43;统一可读写文件系统） 2、命令说明 a）docker生命周期相关命令: 1）docker create &lt;image-id&gt; 即为只读文件系统添加一层可读写层【top layer】，生成可读写文件系统，该命令状态下容器为静态容器，并没有运行。
2）docker start（restart） &lt;container-id&gt; 【docker stop即为docker start的逆过程】 即为可读写文件系统添加一个进程空间【包括进程】，生成动态容器【running container】
3）docker run &lt;image-id&gt; docker run=docker create&#43;docker start
类似流程如下 ：
4）docker stop &lt;container-id&gt; 向运行的容器中发一个SIGTERM的信号，然后停止所有的进程。即为docker start的逆过程。
5）docker kill &lt;container-id&gt; docker kill向容器发送不友好的SIGKILL的信号，相当于快速强制关闭容器，与docker stop的区别在于docker stop是正常关闭，先发SIGTERM信号，清理进程，再发SIGKILL信号退出。
6）docker pause &lt;container-id&gt; 【docker unpause为逆过程】---比较少使用 暂停容器中的所有进程，使用cgroup的freezer顺序暂停容器里的所有进程，docker unpause为逆过程即恢复所有进程。比较少使用。
7）docker commit &lt;container-id&gt; 把容器的可读写层转化成只读层，即从容器状态【可读写文件系统】变为镜像状态【只读文件系统】，可理解为【固化】。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/72762510584e171e4256503145a36723/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-05-07T10:19:20+08:00" />
<meta property="article:modified_time" content="2017-05-07T10:19:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker常用命令原理图</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="Docker常用命令原理图-（一）imagelayer（镜像层）"></h3> 
<h3 id="Docker常用命令原理图-docker常用命令原理图概览：">docker常用命令原理图概览：</h3> 
<p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img alt="" src="https://images2.imgbox.com/4d/18/ZG4c7NG8_o.jpg" width="650" border="1"></span></p> 
<h3 id="Docker常用命令原理图-（一）imagelayer（镜像层）">（一）image layer（镜像层）</h3> 
<p>镜像可以看成是由多个镜像层叠加起来的一个文件系统，镜像层也可以简单理解为一个基本的镜像，而每个镜像层之间通过指针的形式进行叠加。</p> 
<p><span class="confluence-embedded-file-wrapper"><img alt="" src="https://images2.imgbox.com/9a/3b/umv1oJ9O_o.png"></span></p> 
<p>根据上图，镜像层的主要组成部分包括<span style="color:#ff00">镜像层id，镜像层指针【指向父层】，元数据【layer metadata】包含了docker构建和运行的信息还有父层的层次信息</span>。</p> 
<p>只读层和读写层【top layer】的组成部分基本一致。同时<span style="color:#ff00">读写层可以转换成只读层【docker commit操作实现】</span></p> 
<h3 id="Docker常用命令原理图-（二）image（镜像）---【只读层的集合】">（二）image（镜像）---【<span style="color:#ff00">只读层的集合</span>】</h3> 
<p>1、镜像是一堆只读层的统一视角，除了最底层没有指向外，每一层都指向它的父层，统一文件系统（union file system）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。而每一层都是不可写的，就是只读层。</p> 
<p><span class="confluence-embedded-file-wrapper"><img alt="" src="https://images2.imgbox.com/12/a5/q9jF3bzg_o.png"></span></p> 
<h3 id="Docker常用命令原理图-（三）container（容器）---【一层读写层+多层只读层】">（三）container（容器）---【<span style="color:#ff00">一层读写层+多层只读层</span>】</h3> 
<p>1、容器和镜像的区别在于容器的最上面一层是读写层【top layer】，而这边并没有区分容器是否在运行。<span style="color:#ff00">运行状态的容器【running container】即一个可读写的文件系统【静态容器】+隔离的进程空间和其中的进程。</span></p> 
<p> <img alt="" src="https://images2.imgbox.com/ee/21/102hMjCe_o.png"></p> 
<p>隔离的进程空间中的<span style="color:#ff00">进程可以对该读写层进行增删改，其运行状态容器的进程操作都作用在该读写层上</span>。每个容器只能有一个进程隔离空间。</p> 
<p><span class="confluence-embedded-file-wrapper"><img alt="" src="https://images2.imgbox.com/60/7d/6vyWKzia_o.png"></span></p> 
<h3 id="Docker常用命令原理图-（四）docker常用命令说明">（四）docker常用命令说明</h3> 
<h4 id="Docker常用命令原理图-1、标识说明">1、标识说明</h4> 
<h5 id="Docker常用命令原理图-1）image---（统一只读文件系统）">1）image---（<span style="color:#ff00">统一只读文件系统</span>）</h5> 
<p><span class="confluence-embedded-file-wrapper"><img alt="" src="https://images2.imgbox.com/9a/cc/KSA3g2Lb_o.png"></span></p> 
<h5 id="Docker常用命令原理图-2）静态容器【未运行的容器】---（统一可读写文件系统）">2）静态容器【未运行的容器】---（<span style="color:#ff00">统一可读写文件系统</span>）</h5> 
<div> 
 <img alt="" src="https://images2.imgbox.com/15/46/BsO8HciV_o.png"> 
</div> 
<h5 id="Docker常用命令原理图-3）动态容器【runningcontainer】---（进程空间（包括进程）+统一可读写文件系统）">3）动态容器【running container】---（<span style="color:#ff00">进程空间（包括进程）+统一可读写文件系统</span>）</h5> 
<p><span class="confluence-embedded-file-wrapper"><img src="https://images2.imgbox.com/29/20/1ytLlwgJ_o.png" alt=""><br> </span></p> 
<h4 id="Docker常用命令原理图-2、命令说明">2、命令说明</h4> 
<h5 id="Docker常用命令原理图-a）docker生命周期相关命令:">a）docker生命周期相关命令:</h5> 
<h6 id="Docker常用命令原理图-1）dockercreate&lt;image-id&gt;">1）docker create &lt;image-id&gt;</h6> 
<div> 
 <img src="https://images2.imgbox.com/8d/29/RsMAOXnU_o.png" alt=""> 
</div> 
<p>即<span style="color:#ff00">为只读文件系统添加一层可读写层【top layer】，生成可读写文件系统</span>，该命令状态下容器为静态容器，并没有运行。</p> 
<h6 id="Docker常用命令原理图-2）dockerstart（restart）&lt;container-id&gt;【dockerstop即为dockerstart的逆过程】"> 2）docker start（restart） &lt;container-id&gt;        【docker stop即为docker start的逆过程】</h6> 
<p><span class="confluence-embedded-file-wrapper"><img src="https://images2.imgbox.com/7f/4c/2us92K3p_o.png" alt=""></span></p> 
<p>即<span style="color:#ff00">为可读写文件系统添加一个进程空间【包括进程】，生成动态容器【running container】</span></p> 
<h6 id="Docker常用命令原理图-3）dockerrun&lt;image-id&gt;">3）docker run &lt;image-id&gt;</h6> 
<p><span class="confluence-embedded-file-wrapper"><img src="https://images2.imgbox.com/97/61/SU5apBz0_o.png" alt=""></span></p> 
<p><span style="color:#ff00">docker run=docker create+docker start</span></p> 
<p>类似流程如下 ：</p> 
<p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img src="https://images2.imgbox.com/20/9b/jxQWPSoA_o.png" alt="" width="700" border="1"></span></p> 
<h6 id="Docker常用命令原理图-4）dockerstop&lt;container-id&gt;">4）docker stop &lt;container-id&gt;</h6> 
<p><span class="confluence-embedded-file-wrapper"><img src="https://images2.imgbox.com/b5/74/9dY3BY6G_o.png" alt=""></span></p> 
<p>向运行的容器中发一个SIGTERM的信号，然后停止所有的进程。即为docker start的逆过程。</p> 
<h6 id="Docker常用命令原理图-5）dockerkill&lt;container-id&gt;">5）docker kill &lt;container-id&gt;</h6> 
<p><span class="confluence-embedded-file-wrapper"><span class="confluence-embedded-file-wrapper"><img src="https://images2.imgbox.com/57/ff/xIS13qpf_o.png" alt=""></span></span></p> 
<p>docker kill向容器发送不友好的SIGKILL的信号，相当于快速强制关闭容器，与docker stop的区别在于docker stop是正常关闭，先发SIGTERM信号，清理进程，再发SIGKILL信号退出。</p> 
<h6 id="Docker常用命令原理图-6）dockerpause&lt;container-id&gt;【dockerunpause为逆过程】---比较少使用">6）docker pause &lt;container-id&gt;    【docker unpause为逆过程】---比较少使用</h6> 
<p><span class="confluence-embedded-file-wrapper"><img src="https://images2.imgbox.com/22/54/nUgMcps8_o.png" alt=""></span></p> 
<p>暂停容器中的所有进程，使用cgroup的freezer顺序暂停容器里的所有进程，docker unpause为逆过程即恢复所有进程。比较少使用。</p> 
<h6 id="Docker常用命令原理图-7）dockercommit&lt;container-id&gt;">7）docker commit &lt;container-id&gt;</h6> 
<p><span class="confluence-embedded-file-wrapper"><img src="https://images2.imgbox.com/2b/0b/Y3bf3NIL_o.png" alt=""></span></p> 
<p><span class="confluence-embedded-file-wrapper"><img src="https://images2.imgbox.com/8b/b0/VVSnSPpc_o.png" alt=""></span></p> 
<p><span style="color:#ff00">把容器的可读写层转化成只读层，即从容器状态【可读写文件系统】变为镜像状态【只读文件系统】，可理解为【固化】</span>。</p> 
<h6 id="Docker常用命令原理图-8）dockerbuild">8）docker build</h6> 
<p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img src="https://images2.imgbox.com/97/84/zoB1Cqzi_o.png" alt=""></span></p> 
<p><span class="confluence-embedded-file-wrapper confluence-embedded-manual-size"><img src="https://images2.imgbox.com/de/07/mOwsqAjx_o.png" alt="" width="800" border="1"></span></p> 
<p><strong><span style="color:#ff00">docker build=docker run【运行容器】+【进程修改数据】+docker commit【固化数据】，不断循环直至生成所需镜像。</span></strong></p> 
<p><span style="color:#ff00">循环一次便会形成新的层（镜像）【原镜像层+已固化的可读写层】</span></p> 
<p>docker build 一般作用在dockerfile文件上。</p> 
<h5 id="Docker常用命令原理图-b）docker查询类命令：【查询对象：①image，②container，③image/container中的数据，④系统信息[容器数，镜像数及其他]】"> b）docker查询类命令：【查询对象：①image，②container，③image/container中的数据，④系统信息[容器数，镜像数及其他]】</h5> 
<h6 id="Docker常用命令原理图-1.1）dockerimages">1.1）docker images</h6> 
<p><span class="confluence-embedded-file-wrapper"><img src="https://images2.imgbox.com/4c/2e/rBXw4oMU_o.png" alt=""></span></p> 
<p>docker images 列出当前镜像【以顶层镜像id来表示整个完整镜像】，每个顶层镜像下面隐藏多个镜像层。</p> 
<h6 id="Docker常用命令原理图-1.2）dockerimages-a">1.2）docker images -a</h6> 
<p><span class="confluence-embedded-file-wrapper"><img src="https://images2.imgbox.com/67/f8/Um99rDih_o.png" alt=""></span></p> 
<p>docker images -a列出所有镜像层【排序以每个顶层镜像id为首后接该镜像下的所有镜像层】，依次列出每个镜像的所有镜像层。</p> 
<h6 id="Docker常用命令原理图-1.3）dockerhistory&lt;image-id&gt;">1.3）docker history &lt;image-id&gt;</h6> 
<p><span class="confluence-embedded-file-wrapper"><img src="https://images2.imgbox.com/74/60/L7nHjo9z_o.png" alt=""></span></p> 
<p>docker history 列出该镜像id下的所有历史镜像。</p> 
<h6 id="Docker常用命令原理图-2.1）dockerps">2.1）docker ps</h6> 
<p><span class="confluence-embedded-file-wrapper"><img src="https://images2.imgbox.com/4a/df/cN9ko3OA_o.png" alt=""></span></p> 
<p>列出所有运行的容器【running container】</p> 
<h6 id="Docker常用命令原理图-2.2）dockerps-a">2.2）docker ps -a </h6> 
<p><span class="confluence-embedded-file-wrapper"><img src="https://images2.imgbox.com/d7/2e/87ZmPrQp_o.png" alt=""></span></p> 
<p>列出所有容器，包括静态容器【未运行的容器】和动态容器【running container】</p> 
<h6 id="Docker常用命令原理图-3.1）dockerinspect&lt;container-id&gt;or&lt;image-id&gt;">3.1）docker inspect &lt;container-id&gt; or &lt;image-id&gt;</h6> 
<p><span class="confluence-embedded-file-wrapper"><img src="https://images2.imgbox.com/ef/23/77wgz79m_o.png" alt=""></span></p> 
<p>提取出容器或镜像最顶层的元数据。</p> 
<h6 id="Docker常用命令原理图-3.2）dockerinfo">3.2）docker info</h6> 
<p>显示 Docker 系统信息，包括镜像和容器数。</p> 
<h5 id="Docker常用命令原理图-c）docker操作类命令：">c）docker操作类命令：</h5> 
<h6 id="Docker常用命令原理图-1）dockerrm&lt;container-id&gt;">1）docker rm &lt;container-id&gt;</h6> 
<p><span class="confluence-embedded-file-wrapper"><img src="https://images2.imgbox.com/95/54/DdpT8A1S_o.png" alt=""></span></p> 
<p>docker rm会移除镜像，该命令只能对静态容器【非运行状态】进行操作。</p> 
<p>通过docker rm -f &lt;container-id&gt;的-f （force）参数可以强制删除运行状态的容器【running container】。</p> 
<h6 id="Docker常用命令原理图-2）dockerrmi&lt;image-id&gt;">2）docker rmi &lt;image-id&gt;</h6> 
<p><span class="confluence-embedded-file-wrapper"><img src="https://images2.imgbox.com/0c/38/fTRmUdOk_o.png" alt=""></span></p> 
<h6 id="Docker常用命令原理图-3）dockerexec&lt;running-container-id&gt;">3）docker exec &lt;running-container-id&gt;</h6> 
<p><span class="confluence-embedded-file-wrapper"><img src="https://images2.imgbox.com/b4/1e/LaUSZnVl_o.png" alt=""></span></p> 
<p>docker exec会在运行状态的容器中执行一个新的进程。</p> 
<h6 id="Docker常用命令原理图-4）dockerexport&lt;container-id&gt;">4）docker export &lt;container-id&gt;</h6> 
<p><span class="confluence-embedded-file-wrapper"><img src="https://images2.imgbox.com/7f/c3/efKdveUY_o.png" alt=""></span></p> 
<p>docker export命令创建一个tar文件，并且移除了元数据和不必要的层，将多个层整合成了一个层，只保存了当前统一视角看到的内容。</p> 
<p><br> </p> 
<p>参考文章：</p> 
<p>http://merrigrove.blogspot.jp/2015/10/visualizing-docker-containers-and-images.html  （需翻墙查阅）<br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a699470e397d741d475cb192c80f3543/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Oracle Database 12c新特性对企业影响的思考</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/296c2f829b2495729f71509cc3594dea/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C#中继承实现父类方法、重写、重载</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>