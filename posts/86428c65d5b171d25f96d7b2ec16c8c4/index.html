<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>输入前序&#43;中序or中序&#43;后序结合构造二叉树，并实现错误检测机制，最终实现可视化动态逐步建树，前中后序遍历二叉树。 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="输入前序&#43;中序or中序&#43;后序结合构造二叉树，并实现错误检测机制，最终实现可视化动态逐步建树，前中后序遍历二叉树。" />
<meta property="og:description" content="输入前序&#43;中序or中序&#43;后序结合构造二叉树，并实现错误检测机制，最终实现可视化动态逐步建树，前中后序遍历二叉树。 首先放一下我的成果：
拿到题目的一瞬间我有点小懵，但完整做下来之后发现just so so。废话不多说，下面开始。
设计理念是：
1，创建一个树的节点结构体，我们采用三叉链表实现。
2，创建一个二叉树类，以节点为数据成员，用它的成员函数实现各个功能（建树，遍历，输出等）
3，直接输入前中后序序列，我采用字符数组加流的实现模式（比较有意思）
4，最后就是各个功能的具体实现。
目录 **输入前序&#43;中序or中序&#43;后序结合构造二叉树，并实现错误检测机制，最终实现可视化动态逐步建树，前中后序遍历二叉树。** 二叉树类数据输入前序&#43;中序建树遍历输出可视化动态建树通过父指针寻找两个节点的公共父亲检错机制 二叉树类 //节点结构体 struct bintreenode { char data;//数据域 int depth;//树的节点高度 int depth1;//树的层数 bintreenode* leftchild, * rightchild, * parent; bintreenode(char x, int a = 0, int b = 0, bintreenode* p = NULL, bintreenode* q = NULL, bintreenode* r = NULL) :data(x),depth(a),depth1(b),leftchild(p), rightchild(q), parent(r) {}; }; //二叉树类的声明 class binarytree { public: bintreenode* root; binarytree(); bintreenode* creattreep(char* arrp, char* arrm, int size, bintreenode* p, double x0, double y0, double x, double y,int n);//前序中序建立二叉树 bintreenode* creattreel(char* arrm, char* arrl, int size, bintreenode* p, double x0, double y0, double x, double y);//中序后序建立二叉树 bintreenode* coparent(bintreenode* p, bintreenode* q); bintreenode* coparent1(char x, char y);//通过父指针获取公共父节点 int getdepth(bintreenode* p ); bintreenode* getdepth1(bintreenode* p);//获取深度 bintreenode* getx(bintreenode* p,char x); bintreenode* gety(bintreenode* p, char x);//获取节点 void preoder(bintreenode* p);//前序遍历 void inoder(bintreenode* p);//中序遍历 void postoder(bintreenode* p);//后序遍历 }; 数据输入 首先呢我们需要输入前中后序的序列，所以介绍一下我采用的流方法。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/86428c65d5b171d25f96d7b2ec16c8c4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-10-22T17:12:37+08:00" />
<meta property="article:modified_time" content="2020-10-22T17:12:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">输入前序&#43;中序or中序&#43;后序结合构造二叉树，并实现错误检测机制，最终实现可视化动态逐步建树，前中后序遍历二叉树。</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="or_0"></a><strong>输入前序+中序or中序+后序结合构造二叉树，并实现错误检测机制，最终实现可视化动态逐步建树，前中后序遍历二叉树。</strong></h3> 
<p>首先放一下我的成果：<br> <img src="https://images2.imgbox.com/11/02/Ip4FsixM_o.gif" alt="在这里插入图片描述"></p> 
<p>拿到题目的一瞬间我有点小懵，但完整做下来之后发现just so so。废话不多说，下面开始。</p> 
<p>设计理念是：<br> 1，创建一个树的节点结构体，我们采用三叉链表实现。<br> 2，创建一个二叉树类，以节点为数据成员，用它的成员函数实现各个功能（建树，遍历，输出等）<br> 3，直接输入前中后序序列，我采用字符数组加流的实现模式（比较有意思）<br> 4，最后就是各个功能的具体实现。</p> 
<p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><ul><li><a href="#or_0" rel="nofollow">**输入前序+中序or中序+后序结合构造二叉树，并实现错误检测机制，最终实现可视化动态逐步建树，前中后序遍历二叉树。**</a></li></ul> 
  </li><li><a href="#_13" rel="nofollow">二叉树类</a></li><li><a href="#_52" rel="nofollow">数据输入</a></li><li><a href="#_76" rel="nofollow">前序+中序建树</a></li><li><a href="#_126" rel="nofollow">遍历输出</a></li><li><a href="#_142" rel="nofollow">可视化动态建树</a></li><li><a href="#_156" rel="nofollow">通过父指针寻找两个节点的公共父亲</a></li><li><a href="#_173" rel="nofollow">检错机制</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_13"></a>二叉树类</h2> 
<pre><code class="prism language-cpp"><span class="token comment">//节点结构体</span>
<span class="token keyword">struct</span> bintreenode
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> data<span class="token punctuation">;</span><span class="token comment">//数据域</span>
	<span class="token keyword">int</span> depth<span class="token punctuation">;</span><span class="token comment">//树的节点高度</span>
	<span class="token keyword">int</span> depth1<span class="token punctuation">;</span><span class="token comment">//树的层数</span>
	bintreenode<span class="token operator">*</span> leftchild<span class="token punctuation">,</span> <span class="token operator">*</span> rightchild<span class="token punctuation">,</span> <span class="token operator">*</span> parent<span class="token punctuation">;</span>
	<span class="token function">bintreenode</span><span class="token punctuation">(</span><span class="token keyword">char</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> bintreenode<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> bintreenode<span class="token operator">*</span> q <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span>
		bintreenode<span class="token operator">*</span> r <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">data</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">depth</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">depth1</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">leftchild</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rightchild</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">parent</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<pre><code class="prism language-cpp"><span class="token comment">//二叉树类的声明</span>
<span class="token keyword">class</span> <span class="token class-name">binarytree</span>
<span class="token punctuation">{<!-- --></span>

<span class="token keyword">public</span><span class="token operator">:</span>
	bintreenode<span class="token operator">*</span> root<span class="token punctuation">;</span>

	<span class="token function">binarytree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	bintreenode<span class="token operator">*</span> <span class="token function">creattreep</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> arrp<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> arrm<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">,</span> bintreenode<span class="token operator">*</span> p<span class="token punctuation">,</span> <span class="token keyword">double</span> x0<span class="token punctuation">,</span> <span class="token keyword">double</span> y0<span class="token punctuation">,</span> <span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//前序中序建立二叉树</span>
	bintreenode<span class="token operator">*</span> <span class="token function">creattreel</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> arrm<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> arrl<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">,</span> bintreenode<span class="token operator">*</span> p<span class="token punctuation">,</span> <span class="token keyword">double</span> x0<span class="token punctuation">,</span> <span class="token keyword">double</span> y0<span class="token punctuation">,</span> <span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//中序后序建立二叉树</span>
	bintreenode<span class="token operator">*</span> <span class="token function">coparent</span><span class="token punctuation">(</span>bintreenode<span class="token operator">*</span> p<span class="token punctuation">,</span> bintreenode<span class="token operator">*</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
	bintreenode<span class="token operator">*</span> <span class="token function">coparent1</span><span class="token punctuation">(</span><span class="token keyword">char</span> x<span class="token punctuation">,</span> <span class="token keyword">char</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//通过父指针获取公共父节点</span>
	<span class="token keyword">int</span> <span class="token function">getdepth</span><span class="token punctuation">(</span>bintreenode<span class="token operator">*</span> p <span class="token punctuation">)</span><span class="token punctuation">;</span>
	bintreenode<span class="token operator">*</span> <span class="token function">getdepth1</span><span class="token punctuation">(</span>bintreenode<span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取深度</span>
	bintreenode<span class="token operator">*</span> <span class="token function">getx</span><span class="token punctuation">(</span>bintreenode<span class="token operator">*</span> p<span class="token punctuation">,</span><span class="token keyword">char</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	bintreenode<span class="token operator">*</span> <span class="token function">gety</span><span class="token punctuation">(</span>bintreenode<span class="token operator">*</span> p<span class="token punctuation">,</span> <span class="token keyword">char</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取节点</span>
	<span class="token keyword">void</span> <span class="token function">preoder</span><span class="token punctuation">(</span>bintreenode<span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//前序遍历</span>
	<span class="token keyword">void</span> <span class="token function">inoder</span><span class="token punctuation">(</span>bintreenode<span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//中序遍历</span>
	<span class="token keyword">void</span> <span class="token function">postoder</span><span class="token punctuation">(</span>bintreenode<span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//后序遍历</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="_52"></a>数据输入</h2> 
<p>首先呢我们需要输入前中后序的序列，所以介绍一下我采用的流方法。<br> 定义三个全局的字符数组，通过三个函数实现对他们的输入，然后在主函数中调用。<br> 函数的实现是关键，先贴代码再解释。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">cinarryp</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> a<span class="token punctuation">;</span>
	string s<span class="token punctuation">;</span>
	cin <span class="token operator">&gt;&gt;</span> s<span class="token punctuation">;</span>
	stringstream ss<span class="token punctuation">;</span>
	ss <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>ss <span class="token operator">&gt;&gt;</span> a<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		arrp<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">;</span>
		n<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//计数</span>
	<span class="token punctuation">}</span>
	ss<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>首先用string类型的对象来存储我们在控制台中从键盘输入的数据，调用stringstream库（一个非常好用的格式转换库），它作为一个流，相当于一个中转站，在我们将string对象的内容放进流中后，再从流中读取到我们想要的地方，它会自动进行格式转换（太太太棒了！！）并且它是一个一个对象进行读取（这是我觉得非常好用的地方）</p> 
<h2><a id="_76"></a>前序+中序建树</h2> 
<p>接下来是文章的核心部分了，最最关键的建树和可视化，依旧先上代码再解释</p> 
<pre><code class="prism language-cpp">bintreenode<span class="token operator">*</span> binarytree<span class="token operator">::</span><span class="token function">creattreep</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> arrp<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> arrm<span class="token punctuation">,</span><span class="token keyword">int</span> size<span class="token punctuation">,</span> bintreenode<span class="token operator">*</span> p<span class="token punctuation">,</span> <span class="token keyword">double</span> x0<span class="token punctuation">,</span> <span class="token keyword">double</span> y0<span class="token punctuation">,</span> <span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	bintreenode<span class="token operator">*</span> roottemp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">bintreenode</span><span class="token punctuation">(</span>arrp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">circle</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">setcolor</span><span class="token punctuation">(</span><span class="token function">EGERGB</span><span class="token punctuation">(</span><span class="token number">0xFF</span><span class="token punctuation">,</span> <span class="token number">0xFF</span><span class="token punctuation">,</span> <span class="token number">0x0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">outtextxy</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> roottemp<span class="token operator">-</span><span class="token operator">&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">0.1</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token function">line</span><span class="token punctuation">(</span>x0<span class="token punctuation">,</span> y0<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">0.1</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	p <span class="token operator">=</span> roottemp<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		root <span class="token operator">=</span> roottemp<span class="token punctuation">;</span>
		flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>arrm<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> arrp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			r <span class="token operator">=</span> i<span class="token punctuation">;</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	
	<span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> n <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> x1 <span class="token operator">=</span> x <span class="token operator">-</span> <span class="token number">400</span> <span class="token operator">/</span> t<span class="token punctuation">;</span>
	<span class="token keyword">int</span> x2 <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">400</span> <span class="token operator">/</span> t<span class="token punctuation">;</span>
	roottemp<span class="token operator">-</span><span class="token operator">&gt;</span>leftchild <span class="token operator">=</span> <span class="token function">creattreep</span><span class="token punctuation">(</span>arrp <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> arrm<span class="token punctuation">,</span> r<span class="token punctuation">,</span> p<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> x1<span class="token punctuation">,</span> <span class="token number">100.0</span> <span class="token operator">*</span> n<span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	roottemp<span class="token operator">-</span><span class="token operator">&gt;</span>rightchild <span class="token operator">=</span> <span class="token function">creattreep</span><span class="token punctuation">(</span>arrp <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> r<span class="token punctuation">,</span> arrm <span class="token operator">+</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> size <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> r<span class="token punctuation">,</span> p<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> <span class="token number">100.0</span> <span class="token operator">*</span> n<span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> roottemp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>你会发现我的函数里面有好多参数，不要着急，下面会介绍我的心路历程。<br> 首先是树最基本的递归建树了，只需要一个递归到头的终止判断和左右子树递归调用函数即可。<br> 其次因为不是简单的用单一序列建树，所以需要构思实现方法，下面介绍。<br> 举个栗子<br> <img src="https://images2.imgbox.com/34/f3/tcoan4ES_o.png" alt="在这里插入图片描述"><br> 结合我们学习的前中后序遍历，逆向思维去思考它，前序序列的第一个元素是根节点，在中序序列中找到根节点后，它的左边就是它的左子树，长度是中序序列根节点下标r，右边就是右子树，长度是n-r-1；接下来我们只需要往左右递归子树传递参数直到长度为0就ok了。大功告成！</p> 
<h2><a id="_126"></a>遍历输出</h2> 
<p>树建好了，我们就可以输出了啊，输出它的前中后序遍历结果去验证一下。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> binarytree<span class="token operator">::</span><span class="token function">preoder</span><span class="token punctuation">(</span>bintreenode<span class="token operator">*</span> p<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> p<span class="token operator">-</span><span class="token operator">&gt;</span>data<span class="token punctuation">;</span>
		<span class="token function">preoder</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>leftchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">preoder</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>rightchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>太过简单就不做解释了。</p> 
<h2><a id="_142"></a>可视化动态建树</h2> 
<p>接下来要实现可视化了！！老师让我们学会用EGE这个第三方库，第一次拿着它和它大眼瞪小眼，虽然知道它怎么用但是根本不知道怎么结合到我的代码里进行一步一步的实现建树啊。但是！睡觉的时候灵光一现：<br> 1，只要在递归代码里，每创建一个节点的同时画一个节点就ok了。调用EGE的circle（）函数。<br> 2，难点也是重中之重在位置坐标，这里用到树的深度建立，贴个图来解释一下<br> <img src="https://images2.imgbox.com/ff/47/2j4Qna8A_o.jpg" alt="在这里插入图片描述"><br> n是树的深度，要想对于节点更多的树，他们仍旧不交叉并且美观，对于不同深度的节点就应该有相比于其父节点不同的偏移量：<br> 第二层偏了200，是400/2；是2的1次方<br> 第三层偏了100，是400/4；是2的2次方<br> 第四层偏了50，是400/8；是2的3次方<br> 所以代码中我们用一个变量t来存偏移量，节点左右子女分别是它本身加减偏移量即可。</p> 
<p>3，这样节点都建立完了，可是树不能光有叶子，还得有茎啊，所以还要调用EGE的line（）函数，可是画线要从一个点到另一个点，所以还要增加参数，将它父节点的坐标继承下下来。<br> 4，这样树终于完整了，叶子和茎都有了，可是我要做动态建立啊！要一个一个蹦出来，EGE的delay（）用不了，我借用了sleep（）函数，真是人如其名，名如其功能，让你的电脑睡眠一小会就ok了！<br> 5，大大大大功告成！像开头那样子的！</p> 
<h2><a id="_156"></a>通过父指针寻找两个节点的公共父亲</h2> 
<pre><code class="prism language-cpp">bintreenode<span class="token operator">*</span> binarytree<span class="token operator">::</span><span class="token function">coparent</span><span class="token punctuation">(</span>bintreenode<span class="token operator">*</span> p<span class="token punctuation">,</span> bintreenode<span class="token operator">*</span> q<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>parent <span class="token operator">==</span> q<span class="token operator">-</span><span class="token operator">&gt;</span>parent<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"父节点是："</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> p<span class="token operator">-</span><span class="token operator">&gt;</span>parent<span class="token operator">-</span><span class="token operator">&gt;</span>data<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>depth1 <span class="token operator">&gt;</span> q<span class="token operator">-</span><span class="token operator">&gt;</span>depth1<span class="token punctuation">)</span> <span class="token function">coparent</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">&gt;</span>parent<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token function">coparent</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> q<span class="token operator">-</span><span class="token operator">&gt;</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>通过节点之间的层数进行考虑。</p> 
<h2><a id="_173"></a>检错机制</h2> 
<p>最后，做个简单的检错机制：<br> 依旧是递归实现的，想法是：<br> 1，当我们输入序列的元素个数都不相等时，肯定要输出错误了。<br> 2，当前序中的元素在中序中找不到时，也要输出错误。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">whethererror</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> arrp<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> arrm<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>nflag<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>arrp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">strlen</span><span class="token punctuation">(</span>arrm<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"error!"</span><span class="token punctuation">;</span>
			<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		nflag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
		<span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>arrp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> arrm<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				r <span class="token operator">=</span> i<span class="token punctuation">;</span>
				flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"error!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token function">whethererror</span><span class="token punctuation">(</span>arrp <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> arrm<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">whethererror</span><span class="token punctuation">(</span>arrp <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> r<span class="token punctuation">,</span> arrm <span class="token operator">+</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> size <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>中序+后序当然是同样道理，略作改动即可。</p> 
<p>最后的最后，感觉我太菜了，谢谢大噶伙！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1a663f37fcbc232a3abf8a94073501b8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构实验二 单链表的基本操作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/04151379dca402e53370029a22b98ebb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据降维的几种常见方法（PCA；FA；LDA；ICA等）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>