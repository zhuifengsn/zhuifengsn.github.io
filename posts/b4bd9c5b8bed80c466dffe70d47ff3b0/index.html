<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Google编程大赛入围赛750分真题(第五组) 之解法 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Google编程大赛入围赛750分真题(第五组) 之解法" />
<meta property="og:description" content="在CSDN首页看到 Google编程大赛入围赛750分真题 第五组之后，一时手痒，动手用C&#43;&#43;做了一个解决方案，写出来接受大家的批评，呵呵。 先贴上代码， ============================================================================= #pragma warning (disable : 4786) #include &lt;list&gt; #include &lt;vector&gt; #include &lt;iostream&gt; namespace S3{ const unsigned int MAX_COUNT = 1000000000; const unsigned int MAX_UINT = 0xFFFFFFFF; struct cell { char ch; int count[2]; }; class CGrid { typedef cell* LPCELL; public: CGrid() : m_RowCount(0), m_ColCount(0), m_ppCells(NULL) { } ~CGrid() { Clear(); } bool Initialize(const std::vector&lt;std::string&gt;&amp; grid) { Clear(); m_RowCount = grid.size(); if (m_RowCount &lt;= 0) { return false; } m_ColCount = grid[0]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/b4bd9c5b8bed80c466dffe70d47ff3b0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2005-12-16T15:53:00+08:00" />
<meta property="article:modified_time" content="2005-12-16T15:53:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Google编程大赛入围赛750分真题(第五组) 之解法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    在CSDN首页看到 
<a href="http://blog.csdn.net/cyp403/archive/2005/12/13/550942.aspx?Pending=true">Google编程大赛入围赛750分真题   第五组</a>之后，一时手痒，动手用C++做了一个解决方案，写出来接受大家的批评，呵呵。 
<br> 
<br>先贴上代码， 
<br>============================================================================= 
<br> 
<br>#pragma warning (disable : 4786) 
<br> 
<br>#include &lt;list&gt; 
<br>#include &lt;vector&gt; 
<br>#include &lt;iostream&gt; 
<br> 
<br> 
<span style="text-decoration: underline;"></span>namespace S3{ 
<br> 
<br>    const unsigned int MAX_COUNT = 1000000000; 
<br>    const unsigned int MAX_UINT = 0xFFFFFFFF; 
<br> 
<br>    struct cell 
<br>    { 
<br>        char ch; 
<br>        int count[2]; 
<br>    }; 
<br> 
<br>    class CGrid 
<br>    { 
<br>        typedef cell* LPCELL; 
<br> 
<br>    public: 
<br>        CGrid() : m_RowCount(0), m_ColCount(0), m_ppCells(NULL) { } 
<br>        ~CGrid() { Clear(); } 
<br> 
<br>        bool Initialize(const std::vector&lt;std::string&gt;&amp; grid) 
<br>        { 
<br>            Clear(); 
<br>            m_RowCount = grid.size(); 
<br>            if (m_RowCount &lt;= 0) 
<br>            { 
<br>                return false; 
<br>            } 
<br> 
<br>            m_ColCount = grid[0].size(); 
<br>            if (m_ColCount &lt;= 0) 
<br>            { 
<br>                return false; 
<br>            } 
<br> 
<br>            for (int i=0; i&lt;m_RowCount; i++) 
<br>            { 
<br>                if (grid[i].size() != m_ColCount) 
<br>                { 
<br>                    return false; 
<br>                } 
<br>            } 
<br> 
<br>            int nCount = m_RowCount * m_ColCount; 
<br>            m_ppCells = new LPCELL[nCount]; 
<br>            if (m_ppCells == NULL) 
<br>            { 
<br>                return false; 
<br>            } 
<br> 
<br>            for (i=0; i&lt;m_RowCount; i++) 
<br>            { 
<br>                for (int j=0; j&lt;m_ColCount; j++) 
<br>                { 
<br>                    LPCELL p = new cell; 
<br>                    m_ppCells[i * m_ColCount + j] = p; 
<br>                    p-&gt;ch = grid[i][j]; 
<br>                } 
<br>            } 
<br> 
<br>            return true; 
<br>        } 
<br> 
<br>        int CountPath(const std::string&amp; find) 
<br>        { 
<br>            int nLen = find.size(); 
<br>            if (nLen &lt;= 0) 
<br>            { 
<br>                return 0; 
<br>            } 
<br>            
<br>            const char* sz = find.c_str(); 
<br>            char* pos = (char*)(sz + nLen - 1); 
<br> 
<br>            int index = 0; 
<br>            while (pos &gt;= sz) 
<br>            { 
<br>                if (!Calculate(*pos, *(pos+1), index)) 
<br>                { 
<br>                    return -1; 
<br>                } 
<br>                pos--; 
<br>                index++; 
<br>            } 
<br> 
<br>            int sum = 0; 
<br>            for (int i=0; i&lt;m_RowCount * m_ColCount; i++) 
<br>            { 
<br>                if (m_ppCells[i]-&gt;ch == *sz) 
<br>                { 
<br>                    int t = m_ppCells[i]-&gt;count[(index-1)%2]; 
<br>                    if (sum &gt; MAX_COUNT || (MAX_COUNT &gt; sum &amp;&amp; MAX_COUNT - sum &lt; t)) 
<br>                    { 
<br>                        sum = -1; 
<br>                        break; 
<br>                    } 
<br>                    else 
<br>                    { 
<br>                        sum += t; 
<br>                    } 
<br>                } 
<br>            } 
<br> 
<br>            return sum; 
<br>        } 
<br> 
<br>    private: 
<br>        bool Calculate(char c1, char c2, int index) 
<br>        { 
<br>            if (c2 == '/0') 
<br>            { 
<br>                for (int i=0; i&lt;m_RowCount*m_ColCount; i++) 
<br>                { 
<br>                    if (m_ppCells[i]-&gt;ch == c1) 
<br>                    { 
<br>                        m_ppCells[i]-&gt;count[index] = 1; 
<br>                    } 
<br>                } 
<br>            } 
<br>            else 
<br>            { 
<br>                int seq = (index-1) % 2; 
<br>                for(int i=0; i&lt;m_RowCount; i++) 
<br>                { 
<br>                    for (int j=0; j&lt;m_ColCount; j++) 
<br>                    { 
<br>                        LPCELL p = GetCell(i, j); 
<br>                        if (p-&gt;ch == c1) 
<br>                        { 
<br>                            unsigned int count = 0; 
<br>                            for (int m=-1; m&lt;=1; m++) 
<br>                            { 
<br>                                for (int n=-1; n&lt;=1; n++) 
<br>                                { 
<br>                                    if (m != 0 || n != 0) 
<br>                                    { 
<br>                                        LPCELL q = GetCell(i+n, j+m); 
<br>                                        if (q != NULL &amp;&amp; q-&gt;ch == c2) 
<br>                                        { 
<br>                                            if (MAX_UINT - count &lt; q-&gt;count[seq]) 
<br>                                            { 
<br>                                                return false; 
<br>                                            } 
<br>                                            count += q-&gt;count[seq]; 
<br>                                        } 
<br>                                    } 
<br>                                } 
<br>                            } 
<br>                            p-&gt;count[index%2] = count; 
<br>                        } 
<br>                    } 
<br>                } 
<br>            } 
<br> 
<br>            return true; 
<br>        } 
<br> 
<br>        LPCELL GetCell(int row, int col) 
<br>        { 
<br>            if (row &lt; 0 || col &lt; 0) 
<br>            { 
<br>                return NULL; 
<br>            } 
<br>            
<br>            if (row &gt;= m_RowCount || col &gt;= m_ColCount) 
<br>            { 
<br>                return NULL; 
<br>            } 
<br> 
<br>            return m_ppCells[row * m_ColCount + col]; 
<br>        } 
<br> 
<br>        void Clear() 
<br>        { 
<br>            if (m_ppCells != NULL) 
<br>            { 
<br>                int nCount = m_RowCount * m_ColCount; 
<br>                for (int i=0; i&lt;nCount; i++) 
<br>                { 
<br>                    delete m_ppCells[i]; 
<br>                } 
<br>                delete[] m_ppCells; 
<br>                m_ppCells = NULL; 
<br>            } 
<br>            m_RowCount = 0; 
<br>            m_ColCount = 0; 
<br>        } 
<br> 
<br>    private: 
<br>        int m_RowCount; 
<br>        int m_ColCount; 
<br>        LPCELL* m_ppCells; 
<br>    }; 
<br> 
<br>    class WordPath 
<br>    { 
<br>    private: 
<br>        WordPath(); 
<br> 
<br>    public: 
<br>        static int countPath(const std::vector&lt;std::string&gt;&amp; grid, const std::string&amp; find) 
<br>        { 
<br>            CGrid gd; 
<br>            gd.Initialize(grid); 
<br>            return gd.CountPath(find); 
<br>        } 
<br>    }; 
<br> 
<br>    class TestHelp 
<br>    { 
<br>    private: 
<br>        TestHelp(); 
<br> 
<br>    public: 
<br>        static void Test(const std::vector&lt;std::string&gt;&amp; grid, const std::string&amp; find) 
<br>        { 
<br>            DisplayParameter(grid, find); 
<br>            std::cout &lt;&lt; "Returns: " &lt;&lt; WordPath::countPath(grid, find) &lt;&lt; std::endl &lt;&lt; std::endl; 
<br>        } 
<br> 
<br>        static void DisplayParameter(const std::vector&lt;std::string&gt;&amp; grid, const std::string&amp; find) 
<br>        { 
<br>            std::cout &lt;&lt; "Input grid:" &lt;&lt; std::endl; 
<br>            for (int i=0; i&lt;grid.size(); i++) 
<br>            { 
<br>                std::cout &lt;&lt; grid[i].c_str() &lt;&lt; std::endl; 
<br>            } 
<br>            std::cout &lt;&lt; "Find string: " &lt;&lt; find.c_str() &lt;&lt; std::endl; 
<br>        } 
<br>    }; 
<br> 
<br>    void Test0() 
<br>    { 
<br>        std::vector&lt;std::string&gt; vec; 
<br>        vec.push_back("ABC"); 
<br>        vec.push_back("FED"); 
<br>        vec.push_back("GHI"); 
<br> 
<br>        std::string find = "ABCDEFGHI"; 
<br> 
<br>        TestHelp::Test(vec, find); 
<br>    } 
<br> 
<br>    void Test1() 
<br>    { 
<br>        std::vector&lt;std::string&gt; vec; 
<br>        vec.push_back("ABC"); 
<br>        vec.push_back("FED"); 
<br>        vec.push_back("GAI"); 
<br> 
<br>        std::string find = "ABCDEA"; 
<br> 
<br>        TestHelp::Test(vec, find); 
<br>    } 
<br> 
<br>    void Test2() 
<br>    { 
<br>        std::vector&lt;std::string&gt; vec; 
<br>        vec.push_back("ABC"); 
<br>        vec.push_back("DEF"); 
<br>        vec.push_back("GHI"); 
<br> 
<br>        std::string find = "ABCD"; 
<br> 
<br>        TestHelp::Test(vec, find); 
<br>    } 
<br> 
<br>    void Test3() 
<br>    { 
<br>        std::vector&lt;std::string&gt; vec; 
<br>        vec.push_back("AA"); 
<br>        vec.push_back("AA"); 
<br> 
<br>        std::string find = "AAAA"; 
<br>        TestHelp::Test(vec, find); 
<br>    } 
<br> 
<br>    void Test4() 
<br>    { 
<br>        std::vector&lt;std::string&gt; vec; 
<br>        vec.push_back("ABABA"); 
<br>        vec.push_back("BABAB"); 
<br>        vec.push_back("ABABA"); 
<br>        vec.push_back("BABAB"); 
<br>        vec.push_back("ABABA"); 
<br>        
<br>        std::string find = "ABABABBA"; 
<br> 
<br>        TestHelp::Test(vec, find); 
<br>    } 
<br> 
<br>    void Test5() 
<br>    { 
<br>        std::vector&lt;std::string&gt; vec; 
<br>        vec.push_back("AAAAA"); 
<br>        vec.push_back("AAAAA"); 
<br>        vec.push_back("AAAAA"); 
<br>        vec.push_back("AAAAA"); 
<br>        vec.push_back("AAAAA"); 
<br>        
<br>        std::string find = "AAAAAAAAAAA"; 
<br> 
<br>        TestHelp::Test(vec, find); 
<br>    } 
<br> 
<br>    void Test6() 
<br>    { 
<br>        std::vector&lt;std::string&gt; vec; 
<br>        vec.push_back("AB"); 
<br>        vec.push_back("CD"); 
<br>        
<br>        std::string find = "AA"; 
<br> 
<br>        TestHelp::Test(vec, find); 
<br>    } 
<br> 
<br>    void Test() 
<br>    { 
<br>        Test0(); 
<br>        Test1(); 
<br>        Test2(); 
<br>        Test3(); 
<br>        Test4(); 
<br>        Test5(); 
<br>        Test6(); 
<br>    } 
<br>} 
<br> 
<br>int main(int argc, char* argv[]) 
<br>{ 
<br>    S3::Test(); 
<br>    return 0; 
<br>} 
<br> 
<br>================================================================================= 
<br> 
<br>简短的说明一下思路： 
<br> 
<br>算法是倒过查字符，为每个字符加权。 
<br>例如在 
<br> 
ABC<br>FED<br>GAI<br>中查找 
ABCDEA 
<br> 
<br>首先，得到最后一个字符A，我先把grid中是A的位置标上加权值1，如果不是A可不关心，得到 
<br> 
100<br>000<br>010<br>  
<br>然后在找E，并计算每个E周围的A的个数，将总个数设置为E的加权，得到 
<br> 
100<br>020<br>010<br>  
<br>再找D，并计算D周围E的加权之和，得到 
<br> 
100<br>022<br>010<br><br>依次类推, 最后得到<br>222<br>022<br>000<br><br>最后只要计算grid中所有A的加权和即可。<br><br> 
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cc738a10ade7732c2903deffb1111889/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">一段经典的c 分析9</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c70076398b00518c52f3365636bc8bc8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">错误unknown character &#39;0xa1&#39;</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>