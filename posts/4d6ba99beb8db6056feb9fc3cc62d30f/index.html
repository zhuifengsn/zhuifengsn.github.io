<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>计算机组成原理(全) - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="计算机组成原理(全)" />
<meta property="og:description" content="目录
第一章 概述
1.1 计算机系统结构
1.1.1 冯诺依曼（普林斯顿）结构
1.1.2 现代计算机
1.2 计算机各硬件组成
1.3 计算机硬件指标
第二章 总线
2.1 总线分类
2.1.1 片内总线
2.1.2 系统总线
2.1.3 通信总线
2.2 总线结构
2.2.1 单总线结构
2.2.2 双总线结构
2.2.3 三总线结构 2.2.4 多总线结构
2.3 总线判优控制***
2.3.1 链式查询
2.3.2 计数器定时查询
2.3.3 独立请求方式
2.4 总线通信控制
2.4.1 同步通信
2.4.2 异步通信
2.4.3 半同步通信***
2.4.4 分离式通信***
第三章 存储系统
3.1 主存储器
3.1.1 存储器分类
3.1.2 译码驱动方式
3.1.3 随机存储器与只读存储器
3.1.4 动态RAM刷新
3.2 存储器与CPU的连接
3.2.1 位扩展
3.2.2 字扩展" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/4d6ba99beb8db6056feb9fc3cc62d30f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-03T21:48:47+08:00" />
<meta property="article:modified_time" content="2023-12-03T21:48:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">计算机组成原理(全)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E7%AC%AC%E4%B8%80%E7%AB%A0%C2%A0%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><a href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%C2%A0%E6%A6%82%E8%BF%B0" rel="nofollow">第一章 概述</a></p> 
<p id="%E4%BA%8C%2C%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%2C%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%9A" rel="nofollow">1.1 计算机系统结构</a></p> 
<p id="2.1%20%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%EF%BC%88%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%EF%BC%89%E7%BB%93%E6%9E%84%EF%BC%9A-toc" style="margin-left:80px;"><a href="#2.1%20%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%EF%BC%88%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%EF%BC%89%E7%BB%93%E6%9E%84%EF%BC%9A" rel="nofollow">1.1.1 冯诺依曼（普林斯顿）结构</a></p> 
<p id="2.2%20%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA-toc" style="margin-left:80px;"><a href="#2.2%20%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA" rel="nofollow">1.1.2 现代计算机</a></p> 
<p id="%E4%B8%89%2C%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%84%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90-toc" style="margin-left:40px;"><a href="#%E4%B8%89%2C%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%84%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90" rel="nofollow">1.2 计算机各硬件组成</a></p> 
<p id="%E5%9B%9B%2C%C2%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E6%8C%87%E6%A0%87-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%2C%C2%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E6%8C%87%E6%A0%87" rel="nofollow">1.3 计算机硬件指标</a></p> 
<p id="%E7%AC%AC%E4%BA%8C%E7%AB%A0%C2%A0%E6%80%BB%E7%BA%BF-toc" style="margin-left:0px;"><a href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%C2%A0%E6%80%BB%E7%BA%BF" rel="nofollow">第二章 总线</a></p> 
<p id="2.1%20%E6%80%BB%E7%BA%BF%E5%88%86%E7%B1%BB-toc" style="margin-left:40px;"><a href="#2.1%20%E6%80%BB%E7%BA%BF%E5%88%86%E7%B1%BB" rel="nofollow">2.1 总线分类</a></p> 
<p id="1.1%E7%89%87%E5%86%85%E6%80%BB%E7%BA%BF-toc" style="margin-left:80px;"><a href="#1.1%E7%89%87%E5%86%85%E6%80%BB%E7%BA%BF" rel="nofollow">2.1.1 片内总线</a></p> 
<p id="1.2%C2%A0%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF-toc" style="margin-left:80px;"><a href="#1.2%C2%A0%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF" rel="nofollow">2.1.2 系统总线</a></p> 
<p id="1.3%C2%A0%E9%80%9A%E4%BF%A1%E6%80%BB%E7%BA%BF-toc" style="margin-left:80px;"><a href="#1.3%C2%A0%E9%80%9A%E4%BF%A1%E6%80%BB%E7%BA%BF" rel="nofollow">2.1.3 通信总线</a></p> 
<p id="%E4%BA%8C%2C%C2%A0%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%2C%C2%A0%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84" rel="nofollow">2.2 总线结构</a></p> 
<p id="2.1%20%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#2.1%20%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84" rel="nofollow">2.2.1 单总线结构</a></p> 
<p id="2.2%20%E5%8F%8C%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#2.2%20%E5%8F%8C%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84" rel="nofollow">2.2.2 双总线结构</a></p> 
<p id="2.3%20%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%C2%A0-toc" style="margin-left:80px;"><a href="#2.3%20%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%C2%A0" rel="nofollow">2.2.3 三总线结构 </a></p> 
<p id="%C2%A02.4%C2%A0%E5%A4%9A%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#%C2%A02.4%C2%A0%E5%A4%9A%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84" rel="nofollow">2.2.4 多总线结构</a></p> 
<p id="%E4%B8%89%2C%C2%A0%E6%80%BB%E7%BA%BF%E5%88%A4%E4%BC%98%E6%8E%A7%E5%88%B6-toc" style="margin-left:40px;"><a href="#%E4%B8%89%2C%C2%A0%E6%80%BB%E7%BA%BF%E5%88%A4%E4%BC%98%E6%8E%A7%E5%88%B6" rel="nofollow">2.3 总线判优控制***</a></p> 
<p id="3.1%C2%A0%E9%93%BE%E5%BC%8F%E6%9F%A5%E8%AF%A2-toc" style="margin-left:80px;"><a href="#3.1%C2%A0%E9%93%BE%E5%BC%8F%E6%9F%A5%E8%AF%A2" rel="nofollow">2.3.1 链式查询</a></p> 
<p id="3.2%C2%A0%E8%AE%A1%E6%95%B0%E5%99%A8%E5%AE%9A%E6%97%B6%E6%9F%A5%E8%AF%A2-toc" style="margin-left:80px;"><a href="#3.2%C2%A0%E8%AE%A1%E6%95%B0%E5%99%A8%E5%AE%9A%E6%97%B6%E6%9F%A5%E8%AF%A2" rel="nofollow">2.3.2 计数器定时查询</a></p> 
<p id="3.3%C2%A0%E7%8B%AC%E7%AB%8B%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#3.3%C2%A0%E7%8B%AC%E7%AB%8B%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F" rel="nofollow">2.3.3 独立请求方式</a></p> 
<p id="%E5%9B%9B%2C%20%E6%80%BB%E7%BA%BF%E9%80%9A%E4%BF%A1%E6%8E%A7%E5%88%B6-toc" style="margin-left:40px;"><a href="#%E5%9B%9B%2C%20%E6%80%BB%E7%BA%BF%E9%80%9A%E4%BF%A1%E6%8E%A7%E5%88%B6" rel="nofollow">2.4 总线通信控制</a></p> 
<p id="4.1%20%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%3A-toc" style="margin-left:80px;"><a href="#4.1%20%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%3A" rel="nofollow">2.4.1 同步通信</a></p> 
<p id="4.2%C2%A0%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1-toc" style="margin-left:80px;"><a href="#4.2%C2%A0%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1" rel="nofollow">2.4.2 异步通信</a></p> 
<p id="4.3%E5%8D%8A%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1-toc" style="margin-left:80px;"><a href="#4.3%E5%8D%8A%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1" rel="nofollow">2.4.3 半同步通信***</a></p> 
<p id="4.4%C2%A0%E5%88%86%E7%A6%BB%E5%BC%8F%E9%80%9A%E4%BF%A1-toc" style="margin-left:80px;"><a href="#4.4%C2%A0%E5%88%86%E7%A6%BB%E5%BC%8F%E9%80%9A%E4%BF%A1" rel="nofollow">2.4.4 分离式通信***</a></p> 
<p id="%E7%AC%AC%E4%B8%89%E7%AB%A0%C2%A0%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F-toc" style="margin-left:0px;"><a href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%C2%A0%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F" rel="nofollow">第三章 存储系统</a></p> 
<p id="%E4%BA%8C%E3%80%81%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8" rel="nofollow">3.1 主存储器</a></p> 
<p id="3.1.1%20%E5%AD%98%E5%82%A8%E5%99%A8%E5%88%86%E7%B1%BB-toc" style="margin-left:80px;"><a href="#3.1.1%20%E5%AD%98%E5%82%A8%E5%99%A8%E5%88%86%E7%B1%BB" rel="nofollow">3.1.1 存储器分类</a></p> 
<p id="2.3%C2%A0%E8%AF%91%E7%A0%81%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#2.3%C2%A0%E8%AF%91%E7%A0%81%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F" rel="nofollow">3.1.2 译码驱动方式</a></p> 
<p id="2.4%C2%A0%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8-toc" style="margin-left:80px;"><a href="#2.4%C2%A0%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8" rel="nofollow">3.1.3 随机存储器与只读存储器</a></p> 
<p id="2.4.4%C2%A0%E5%8A%A8%E6%80%81RAM%E5%88%B7%E6%96%B0-toc" style="margin-left:80px;"><a href="#2.4.4%C2%A0%E5%8A%A8%E6%80%81RAM%E5%88%B7%E6%96%B0" rel="nofollow">3.1.4 动态RAM刷新</a></p> 
<p id="2.6%C2%A0%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8ECPU%E7%9A%84%E8%BF%9E%E6%8E%A5-toc" style="margin-left:40px;"><a href="#2.6%C2%A0%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8ECPU%E7%9A%84%E8%BF%9E%E6%8E%A5" rel="nofollow">3.2 存储器与CPU的连接</a></p> 
<p id="2.6.1%C2%A0%E4%BD%8D%E6%89%A9%E5%B1%95-toc" style="margin-left:80px;"><a href="#2.6.1%C2%A0%E4%BD%8D%E6%89%A9%E5%B1%95" rel="nofollow">3.2.1 位扩展</a></p> 
<p id="2.6.2%C2%A0%E5%AD%97%E6%89%A9%E5%B1%95-toc" style="margin-left:80px;"><a href="#2.6.2%C2%A0%E5%AD%97%E6%89%A9%E5%B1%95" rel="nofollow">3.2.2 字扩展</a></p> 
<p id="2.6.2%C2%A0%E5%AD%97%E3%80%81%E4%BD%8D%E6%89%A9%E5%B1%95-toc" style="margin-left:80px;"><a href="#2.6.2%C2%A0%E5%AD%97%E3%80%81%E4%BD%8D%E6%89%A9%E5%B1%95" rel="nofollow">3.2.2 字、位扩展</a></p> 
<p id="2.7%C2%A0%E6%8F%90%E9%AB%98%E8%AE%BF%E5%AD%98%E9%80%9F%E5%BA%A6%E7%9A%84%E6%8E%AA%E6%96%BD-toc" style="margin-left:40px;"><a href="#2.7%C2%A0%E6%8F%90%E9%AB%98%E8%AE%BF%E5%AD%98%E9%80%9F%E5%BA%A6%E7%9A%84%E6%8E%AA%E6%96%BD" rel="nofollow">3.3 提高访存速度的措施</a></p> 
<p id="2.7.1%C2%A0%E5%8D%95%E4%BD%93%E5%A4%9A%E5%AD%97%E7%B3%BB%E7%BB%9F-toc" style="margin-left:80px;"><a href="#2.7.1%C2%A0%E5%8D%95%E4%BD%93%E5%A4%9A%E5%AD%97%E7%B3%BB%E7%BB%9F" rel="nofollow">3.3.1 单体多字系统 </a></p> 
<p id="2.7.2%C2%A0%E5%A4%9A%E4%BD%93%E5%B9%B6%E8%A1%8C%E7%B3%BB%E7%BB%9F-toc" style="margin-left:80px;"><a href="#2.7.2%C2%A0%E5%A4%9A%E4%BD%93%E5%B9%B6%E8%A1%8C%E7%B3%BB%E7%BB%9F" rel="nofollow">3.3.2 多体并行系统</a></p> 
<p id="3.4%C2%A0%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8-toc" style="margin-left:40px;"><a href="#3.4%C2%A0%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8" rel="nofollow">3.4 高速缓冲存储器</a></p> 
<p id="3.1%20Cache%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-toc" style="margin-left:80px;"><a href="#3.1%20Cache%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" rel="nofollow">3.4.1 Cache的工作原理</a></p> 
<p id="3.2.1%C2%A0%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84-toc" style="margin-left:80px;"><a href="#3.2.1%C2%A0%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84" rel="nofollow">3.2.2 直接映射</a></p> 
<p id="3.2.2%C2%A0%E5%85%A8%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84-toc" style="margin-left:80px;"><a href="#3.2.2%C2%A0%E5%85%A8%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84" rel="nofollow">3.2.3 全相联映射</a></p> 
<p id="3.2.3%C2%A0%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84-toc" style="margin-left:80px;"><a href="#3.2.3%C2%A0%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84" rel="nofollow">3.2.4 组相联映射</a></p> 
<p id="3.2.5%20Cache%E7%9A%84%E5%86%99%E7%AD%96%E7%95%A5%3A%C2%A0-toc" style="margin-left:80px;"><a href="#3.2.5%20Cache%E7%9A%84%E5%86%99%E7%AD%96%E7%95%A5%3A%C2%A0" rel="nofollow">3.2.5 Cache的写策略: </a></p> 
<p id="3.2.6%20Cache%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95-toc" style="margin-left:80px;"><a href="#3.2.6%20Cache%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95" rel="nofollow">3.2.6 Cache替换算法</a></p> 
<p id="3.5%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8(%E7%BB%93%E5%90%88%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)%C2%A0-toc" style="margin-left:40px;"><a href="#3.5%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%28%E7%BB%93%E5%90%88%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%29%C2%A0" rel="nofollow">3.5虚拟存储器(结合操作系统) </a></p> 
<p id="%E7%AC%AC%E5%9B%9B%E7%AB%A0%C2%A0%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F-toc" style="margin-left:0px;"><a href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%C2%A0%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F" rel="nofollow">第四章 输入输出系统</a></p> 
<p id="4.1%20I%2FO%E6%8E%A5%E5%8F%A3-toc" style="margin-left:40px;"><a href="#4.1%20I%2FO%E6%8E%A5%E5%8F%A3" rel="nofollow">4.1 I/O接口</a></p> 
<p id="4.2%20%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F-toc" style="margin-left:40px;"><a href="#4.2%20%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F" rel="nofollow">4.2 中断系统</a></p> 
<p id="1.1%C2%A0%E6%97%A9%E6%9C%9F%E9%98%B6%E6%AE%B5-toc" style="margin-left:40px;"><a href="#1.1%C2%A0%E6%97%A9%E6%9C%9F%E9%98%B6%E6%AE%B5" rel="nofollow">4.3 DMA方式</a></p> 
<p id="4.3.1%20DMA%E7%9A%84%E4%BC%A0%E9%80%81%E6%96%B9%E5%BC%8F%C2%A0-toc" style="margin-left:80px;"><a href="#4.3.1%20DMA%E7%9A%84%E4%BC%A0%E9%80%81%E6%96%B9%E5%BC%8F%C2%A0" rel="nofollow">4.3.1 DMA的传送方式 </a></p> 
<p id="3.3.5%20DMA%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#3.3.5%20DMA%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F" rel="nofollow">4.4.5 DMA接口与系统的连接方式***</a></p> 
<p id="3.3.6%20DMA%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B-toc" style="margin-left:80px;"><a href="#3.3.6%20DMA%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B" rel="nofollow">4.4.6 DMA接口类型***</a></p> 
<p id="%E7%AC%AC%E4%BA%94%E7%AB%A0%C2%A0%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97-toc" style="margin-left:0px;"><a href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%C2%A0%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97" rel="nofollow">第五章 数据的表示和运算</a></p> 
<p id="5.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%95%B0%E5%80%BC-toc" style="margin-left:40px;"><a href="#5.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%95%B0%E5%80%BC" rel="nofollow">5.1 计算机中的数值</a></p> 
<p id="5.2%C2%A0%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97-toc" style="margin-left:40px;"><a href="#5.2%C2%A0%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97" rel="nofollow">5.2 定点数的运算</a></p> 
<p id="2.1%C2%A0%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97-toc" style="margin-left:80px;"><a href="#2.1%C2%A0%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97" rel="nofollow"> 5.2.1 移位运算</a></p> 
<p id="2.2%C2%A0%E5%8A%A0%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97-toc" style="margin-left:80px;"><a href="#2.2%C2%A0%E5%8A%A0%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97" rel="nofollow">5.2.2 加减法运算</a></p> 
<p id="2.3%C2%A0%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97-toc" style="margin-left:80px;"><a href="#2.3%C2%A0%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97" rel="nofollow">5.2.3 乘法运算</a></p> 
<p id="2.4%C2%A0%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97-toc" style="margin-left:80px;"><a href="#2.4%C2%A0%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97" rel="nofollow">5.2.4 除法运算</a></p> 
<p id="5.3%C2%A0%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97-toc" style="margin-left:40px;"><a href="#5.3%C2%A0%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97" rel="nofollow">5.3 浮点数的运算</a></p> 
<p id="5.4%C2%A0%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83-toc" style="margin-left:40px;"><a href="#5.4%C2%A0%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83" rel="nofollow">5.4 算术逻辑单元</a></p> 
<p id="%E7%AC%AC%E5%85%AD%E7%AB%A0%C2%A0%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F-toc" style="margin-left:0px;"><a href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%C2%A0%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F" rel="nofollow">第六章 指令系统</a></p> 
<p id="6.1%20%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4-toc" style="margin-left:40px;"><a href="#6.1%20%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4" rel="nofollow">6.1 机器指令</a></p> 
<p id="1.4%C2%A0%E6%93%8D%E4%BD%9C%E6%95%B0%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#1.4%C2%A0%E6%93%8D%E4%BD%9C%E6%95%B0%E7%B1%BB%E5%9E%8B" rel="nofollow">6.2 指令的寻址方式</a></p> 
<p id="6.2.1%20%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80-toc" style="margin-left:80px;"><a href="#6.2.1%20%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80" rel="nofollow">6.2.1 指令寻址</a></p> 
<p id="6.2.2%C2%A0%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80-toc" style="margin-left:80px;"><a href="#6.2.2%C2%A0%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80" rel="nofollow">6.2.2 数据寻址</a></p> 
<p id="6.3%C2%A0%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA-toc" style="margin-left:40px;"><a href="#6.3%C2%A0%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA" rel="nofollow">6.3 程序的机器级代码表示</a></p> 
<p id="%E7%AC%AC%E4%B8%83%E7%AB%A0%C2%A0%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%C2%A0%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8" rel="nofollow">第七章 中央处理器</a></p> 
<p id="%E5%85%AD%E3%80%81%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E8%AE%BE%E8%AE%A1-toc" style="margin-left:40px;"><a href="#%E5%85%AD%E3%80%81%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E8%AE%BE%E8%AE%A1" rel="nofollow">7.1 指令周期</a></p> 
<p id="7.2%20CPU%E7%9A%84%E5%8A%9F%E8%83%BD%E5%8F%8A%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#7.2%20CPU%E7%9A%84%E5%8A%9F%E8%83%BD%E5%8F%8A%E7%BB%93%E6%9E%84" rel="nofollow">7.2 CPU的功能及结构</a></p> 
<p id="7.2.1%20%E9%80%9A%E8%B7%AF%E6%95%B0%E6%8D%AE-toc" style="margin-left:80px;"><a href="#7.2.1%20%E9%80%9A%E8%B7%AF%E6%95%B0%E6%8D%AE" rel="nofollow">7.2.1 通路数据</a></p> 
<p id="7.2.2%20%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8-toc" style="margin-left:80px;"><a href="#7.2.2%20%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8" rel="nofollow">7.2.2 多处理器</a></p> 
<p id="7.3%C2%A0%E6%8E%A7%E5%88%B6%E5%99%A8-toc" style="margin-left:40px;"><a href="#7.3%C2%A0%E6%8E%A7%E5%88%B6%E5%99%A8" rel="nofollow">7.3 控制器</a></p> 
<p id="7.3.1%20%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8%20(%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1)-toc" style="margin-left:80px;"><a href="#7.3.1%20%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8%20%28%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%29" rel="nofollow">7.3.1 硬布线控制器 (组合逻辑设计)</a></p> 
<p id="7.3.2%C2%A0%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8-toc" style="margin-left:80px;"><a href="#7.3.2%C2%A0%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8" rel="nofollow">7.3.2 微程序控制器</a></p> 
<p id="7.4%C2%A0%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF-toc" style="margin-left:40px;"><a href="#7.4%C2%A0%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF" rel="nofollow">7.4 指令流水线</a></p> 
<p id="7.4.1%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87-toc" style="margin-left:80px;"><a href="#7.4.1%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87" rel="nofollow">7.4.1流水线性能指标</a></p> 
<p id="7.4.2%20%E5%BD%B1%E5%93%8D%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%80%A7%E8%83%BD%E7%9A%84%E5%9B%A0%E7%B4%A0-toc" style="margin-left:80px;"><a href="#7.4.2%20%E5%BD%B1%E5%93%8D%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%80%A7%E8%83%BD%E7%9A%84%E5%9B%A0%E7%B4%A0" rel="nofollow">7.4.2 影响流水线性能的因素</a></p> 
<p id="7.4.3%C2%A0%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%B8%AD%E7%9A%84%E5%A4%9A%E5%8F%91%E6%8A%80%E6%9C%AF-toc" style="margin-left:80px;"><a href="#7.4.3%C2%A0%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%B8%AD%E7%9A%84%E5%A4%9A%E5%8F%91%E6%8A%80%E6%9C%AF" rel="nofollow">7.4.3 流水线中的多发技术</a></p> 
<p id="5.3%C2%A0%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F-toc" style="margin-left:40px;"><a href="#5.3%C2%A0%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F" rel="nofollow">7.5 控制方式</a></p> 
<p id="5.3.1%20%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#5.3.1%20%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F" rel="nofollow">7.5.1 同步控制方式</a></p> 
<p id="5.3.2%20%E5%BC%82%E6%AD%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#5.3.2%20%E5%BC%82%E6%AD%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F" rel="nofollow">7.5.2 异步控制方式</a></p> 
<p id="5.3.3%C2%A0%20%E8%81%94%E5%90%88%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#5.3.3%C2%A0%20%E8%81%94%E5%90%88%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F" rel="nofollow">7.5.3 联合控制方式</a></p> 
<p id="5.3.4%C2%A0%E4%BA%BA%E5%B7%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#5.3.4%C2%A0%E4%BA%BA%E5%B7%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F" rel="nofollow">7.5.4 人工控制方式</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 style="text-align:center;">第一章 概述</h2> 
<p id="%E4%B8%80%2C%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E5%8F%B2"><strong>计算机发展史***: </strong></p> 
<ul><li>第一代：<strong>电子管</strong>计算机（1946-1958）</li><li>第二代：<strong>晶体管</strong>计算机（1958-1964）</li><li>第三代：<strong>中小规模集成电路</strong>计算机（1964-1971）</li><li>第四代：<strong>大、超大规模集成电路</strong>计算机（1971年以后）</li></ul> 
<h3 id="%E4%BA%8C%2C%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%9A"><strong>1.1 计算机系统结构</strong></h3> 
<blockquote> 
 <p>        硬件+软件(系统软件+应用软件)</p> 
</blockquote> 
<p><strong>        第一台电子数字计算机：</strong>1946年美国宾夕法尼亚大学的<strong>ENIAC</strong></p> 
<h4 id="2.1%20%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%EF%BC%88%E6%99%AE%E6%9E%97%E6%96%AF%E9%A1%BF%EF%BC%89%E7%BB%93%E6%9E%84%EF%BC%9A"><strong>1.1.1 冯诺依曼（普林斯顿）结构</strong></h4> 
<blockquote> 
 <p>        <strong>以运算器为中心 </strong>(占用运算器的时间，不利于高效利用运算器)。最根本特征是采用<strong>存储程序</strong>原理。特点是指令和数据以同等地位位于存储器, 指令由操作码和地址码组成 </p> 
</blockquote> 
<p><strong>原理图: </strong></p> 
<p><img alt="" height="448" src="https://images2.imgbox.com/c1/7e/nv2LJUA6_o.png" width="779"></p> 
<h4 id="2.2%20%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA"><strong>1.1.2 现代计算机</strong></h4> 
<blockquote> 
 <p>        以存储器为中心。</p> 
</blockquote> 
<p><strong>原理图: </strong></p> 
<p><img alt="" height="397" src="https://images2.imgbox.com/ab/34/977kSt2B_o.png" width="895"></p> 
<p><strong> 计算机系统的层次结构图:</strong></p> 
<p><img alt="" height="438" src="https://images2.imgbox.com/e0/03/yNoR4Lwt_o.png" width="643"></p> 
<p id="2.3%C2%A0%E7%BF%BB%E8%AF%91%E7%A8%8B%E5%BA%8F%C2%A0"><strong>翻译程序: </strong></p> 
<p><strong>        编译程序: </strong>将源程序的全部语句一次全部翻译成机器语言程序,而后在执行。</p> 
<p><strong>        解释程序:</strong> 将源程序的一条语句翻译成对应机器语言的一条语句并立即执行, 接着翻译源程序的下一条语句, 重复执行的语句也会被重新翻译。</p> 
<p><strong>从C语言源程序到可执行文件:</strong></p> 
<p><img alt="" height="626" src="https://images2.imgbox.com/7b/f6/rB5qKyYO_o.png" width="1200"></p> 
<h3 id="%E4%B8%89%2C%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%84%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90"><strong>1.2 计算机各硬件组成</strong></h3> 
<p id="3.1%20%E8%BF%90%E7%AE%97%E5%99%A8"><strong>运算器: </strong></p> 
<ul><li>ACC: 累加寄存器</li><li>MQ: 乘商寄存器</li><li>X: 通用寄存器</li><li>ALU: 算术逻辑单元</li></ul> 
<p id="3.2%20%E6%8E%A7%E5%88%B6%E5%99%A8"><strong>控制器:</strong></p> 
<ul><li>CU: 控制单元</li><li>IR: 指令寄存器, 存放当前执行的指令</li><li>PC: 程序计数器, 存放下一条指令的地址</li></ul> 
<p id="3.3%20%E4%B8%BB%E5%AD%98"><strong>主存:</strong></p> 
<ul><li>MDR: 数据寄存器, 位数=存储字长</li><li>MAR: 地址寄存器, 位数=存储数量。与PC长度相等</li></ul> 
<p><strong>原理图:</strong></p> 
<p><img alt="" height="739" src="https://images2.imgbox.com/22/30/mrNJPQYL_o.png" width="1200"></p> 
<p><strong>        汇编程序员<span style="color:#fe2c24;">可见</span>：</strong>PSW(状态寄存器)、通用寄存器、PC、基址寄存器</p> 
<p>        <strong>兼容: </strong>指的是软硬件兼容(时间上向后兼容)</p> 
<h3 id="%E5%9B%9B%2C%C2%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E6%8C%87%E6%A0%87">1.3 计算机硬件指标</h3> 
<p><strong>        机器字长:</strong> CPU一次能处理数据的位数, 与通用寄存器位数和ALU相同。</p> 
<p><strong>        存储字长: </strong>MDR位数</p> 
<p>      <strong>  数据字长: </strong>数据总线一次能传送信息的位数</p> 
<p> <strong>       指令字长: </strong>一般为存储字长的整数倍, 若为2倍, 需要2次访存取一条指令。与IR寄存器有关</p> 
<p><strong>        存储容量: </strong>存储单元个数(2*MAR位数次方) x 存储字长(MDR)</p> 
<p>     <strong>   CPU主频(时钟频率): </strong>1/CPU时钟周期, 单位Hz。<span style="color:#fe2c24;"><strong>不会影响CPI, </strong></span>但可以加快指令执行速度</p> 
<p>   <strong>     CPI: </strong>执行一条指令所需时钟周期数</p> 
<p><strong>        执行一条指令耗时:</strong> CPI x CPU时钟周期</p> 
<p>      <strong>  CPU执行时间: </strong>(指令条数 x CPI ) / 主频</p> 
<p>       <strong> IPS: </strong>每秒执行多少条指令, 主频/平均CPI</p> 
<p>       <strong> FLOPS: </strong>每秒执行多少浮点运算 (K &gt; M &gt; G &gt; T &gt; P &gt; E &gt; Z, 换算:10^3)</p> 
<p><strong>时钟周期图: </strong></p> 
<p><img alt="" height="164" src="https://images2.imgbox.com/bd/75/lF5P6IJx_o.png" width="794"></p> 
<p><strong>博客参考:</strong> 计算机组成原理(唐朔飞)第三版</p> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/e1/71/yr2WvqHI_o.png" width="460"></p> 
<h2 id="%E7%AC%AC%E4%BA%8C%E7%AB%A0%C2%A0%E6%80%BB%E7%BA%BF" style="text-align:center;">第二章 总线</h2> 
<h3 id="2.1%20%E6%80%BB%E7%BA%BF%E5%88%86%E7%B1%BB" style="background-color:transparent;">2.1 总线分类</h3> 
<p>        <strong>总线带宽影响因素: </strong>总线宽度, 总线频率, 数据传输方式 (间接影响)。</p> 
<p>        <strong>数据通路: 包含异常和中断处理的电路。</strong></p> 
<h4 id="1.1%E7%89%87%E5%86%85%E6%80%BB%E7%BA%BF">2.1.1 片内总线</h4> 
<blockquote> 
 <p>      <strong>  芯片内部</strong>的总线。</p> 
</blockquote> 
<h4 id="1.2%C2%A0%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF">2.1.2 系统总线</h4> 
<blockquote> 
 <p>        CPU、主存、I/O设备等各大部件之间的信息传输线。按传输信息分为以下三种</p> 
</blockquote> 
<p><strong>        数据总线:</strong> <span style="color:#fe2c24;"><strong>双向传输</strong></span>总线, 位数与机器字长、存储字长有关。</p> 
<p><strong>        地址总线: </strong>指明CPU访问的存储单元或I/O端口的地址, <span style="color:#fe2c24;"><strong>单向传输</strong></span>, 位数与存储单元有关。</p> 
<p><strong>        控制总线: </strong>用来发出各种控制信号的传输线, <strong><span style="color:#fe2c24;">单向传输</span></strong>。</p> 
<h4 id="1.3%C2%A0%E9%80%9A%E4%BF%A1%E6%80%BB%E7%BA%BF">2.1.3 通信总线</h4> 
<blockquote> 
 <p>        用于计算机系统之间或其他系统之间的通信, 按传输方式分为以下两种</p> 
</blockquote> 
<p><strong>        串行通信:</strong> 数据在单条1位宽的传输线上, 一位一位按顺序传送, 适宜远距离传送。</p> 
<p><strong>        并行通信: </strong>多条并行1位宽的传输线上, 同时由源传送到目的地, 适宜短距离, 通常小于30m。</p> 
<h3 id="%E4%BA%8C%2C%C2%A0%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84">2.2 总线结构</h3> 
<h4 id="2.1%20%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84">2.2.1 单总线结构</h4> 
<p><strong>特点: </strong></p> 
<p>        1) 结构简单, 成本低, 易于接入新的设备。</p> 
<p>        2) 带宽低, 负载重, 多个部件只能争用唯一的总线。</p> 
<p><strong>单总线图:</strong></p> 
<p><img alt="" height="353" src="https://images2.imgbox.com/ef/dd/tjue1Ahn_o.png" width="839"></p> 
<h4 id="2.2%20%E5%8F%8C%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84">2.2.2 双总线结构</h4> 
<p><strong> 特点: </strong></p> 
<p>        1) 将较低速的I/O设备从单总线上分离出来</p> 
<p>        2) 需要增加通道等硬件设备 </p> 
<p><strong>双总线结构图: </strong></p> 
<p><img alt="" height="454" src="https://images2.imgbox.com/a5/bc/VkcRT8Me_o.png" width="793"></p> 
<h4 id="2.3%20%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%C2%A0"><strong>2.2.3 三总线结构</strong> </h4> 
<p><strong>特点:</strong></p> 
<p>        1) 提高了I/O设备的性能, 提高系统吞吐量</p> 
<p>        2) 系统工作效率较低</p> 
<p><strong>三总线结构图:</strong></p> 
<p><img alt="" height="396" src="https://images2.imgbox.com/ef/18/MUO4nhuI_o.png" width="707"></p> 
<h4 id="%C2%A02.4%C2%A0%E5%A4%9A%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84"><strong>2.2.4 多总线结构</strong></h4> 
<p><strong>多层PCI总线图:</strong></p> 
<p><img alt="" height="641" src="https://images2.imgbox.com/2d/e6/YVhGgQTp_o.png" width="1012"></p> 
<h3 id="%E4%B8%89%2C%C2%A0%E6%80%BB%E7%BA%BF%E5%88%A4%E4%BC%98%E6%8E%A7%E5%88%B6">2.3 总线判优控制***</h3> 
<p><strong>        主设备:</strong> 对总线有控制权,又称主模块。</p> 
<p><strong>        从设备: </strong>只能响应主设备发来的总线命令, 又称从模块。</p> 
<h4 id="3.1%C2%A0%E9%93%BE%E5%BC%8F%E6%9F%A5%E8%AF%A2">2.3.1 链式查询</h4> 
<blockquote> 
 <p>        总线同意信号BG是串行的从一个I/O接口到下一个I/O接口, 离主设备最近的设备有最高优先级, 易扩展, 但对电路故障敏感, 且优先级低的难以获得请求。</p> 
</blockquote> 
<p><strong>原理图:</strong></p> 
<p><img alt="" height="634" src="https://images2.imgbox.com/72/9b/wjNm1fl2_o.png" width="1083"></p> 
<h4 id="3.2%C2%A0%E8%AE%A1%E6%95%B0%E5%99%A8%E5%AE%9A%E6%97%B6%E6%9F%A5%E8%AF%A2">2.3.2 计数器定时查询</h4> 
<blockquote> 
 <p>        用 <img alt="log{ _{2}}^{}n" src="https://images2.imgbox.com/f1/e9/Wy3d7Muk_o.png">根地址线替换BG同意线, 当某个请求占用总线的设备地址与计数值一致时, 便获得总线使用权。 计数可从0开始, 也可从上一次计数开始。</p> 
</blockquote> 
<p><strong>原理图:</strong></p> 
<p><img alt="" height="283" src="https://images2.imgbox.com/aa/c7/MhPPuPm0_o.png" width="788"></p> 
<h4 id="3.3%C2%A0%E7%8B%AC%E7%AB%8B%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F">2.3.3 独立请求方式</h4> 
<blockquote> 
 <p>        每一台设备均有一对总线请求线BR和总线同意线BG, 特点是响应速度快, 优秀控制灵活, 但控制线多, 需要2n根线。</p> 
</blockquote> 
<p><strong>原理图:</strong></p> 
<p><img alt="" height="349" src="https://images2.imgbox.com/d1/5d/Z3rD6444_o.png" width="779"></p> 
<h3 id="%E5%9B%9B%2C%20%E6%80%BB%E7%BA%BF%E9%80%9A%E4%BF%A1%E6%8E%A7%E5%88%B6">2.4 总线通信控制</h3> 
<blockquote> 
 <p>        主要解决通信双方获知传输开始和传输结束, 及通信双方协调配合。有<strong>同步通信</strong>、<strong>异步通信</strong>、<strong>半同步通信</strong>、<strong>分离式通信</strong>四种方式。</p> 
</blockquote> 
<p><strong>总线周期的四个阶段:</strong></p> 
<p>       <strong> 1) 申请分配阶段: </strong>可细分为传输请求, 总线仲裁两个阶段</p> 
<p>     <strong>   2) 寻址阶段:</strong> 发出本次要访问从模块的地址及有关命令</p> 
<p>        <strong>3) 传输阶段: </strong>主从模块进行数据交换</p> 
<p>       <strong> 4) 结束阶段:</strong> 主模块有关信息从系统总线上撤除, 让出总线使用权</p> 
<h4 id="4.1%20%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%3A"><strong>2.4.1 同步通信</strong></h4> 
<blockquote> 
 <p>        通信双方由统一时标控制数据传送, 时标通常由CPU的总线控制部件发出。</p> 
</blockquote> 
<p><strong>示例图:</strong></p> 
<p><img alt="" height="480" src="https://images2.imgbox.com/98/6b/HcOxQwDn_o.png" width="928"></p> 
<p>    <strong>    特点: </strong>规定明确, 统一, 模块间的配合简单一致, 但必须按最慢速度的部件来设计公共时钟, 影响总线工作效率。 </p> 
<h4 id="4.2%C2%A0%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1"><strong>2.4.2 异步通信</strong></h4> 
<blockquote> 
 <p>        采用<strong>应答方式</strong>(握手方式), 主模块发出请求信号, 从模块反馈响应。根据应答方式可分以下三种类型</p> 
</blockquote> 
<p>   <strong>     不互锁方式: </strong>主模块发出请求信号, 不必等接受到从模块的回答信号, 而是经过一段时间, 便撤销请求信号, 从模块收到请求信号后, 发出回答信号, 经过一段时间撤销回答信号</p> 
<p><strong>        半互锁方式: </strong>主模块必须接受到模块回答信号再撤销请求信号, 从模块不等主模块撤销请求信号, 而是经过一段时间撤销回答信号。</p> 
<p><strong>        全互锁方式: </strong>主模块必须等从模块回答再撤销, 从模块必须等主模块撤销请求信号, 才撤销回答信号。 </p> 
<p><strong>原理图:</strong></p> 
<p><img alt="" height="472" src="https://images2.imgbox.com/4f/d6/3eQ7rW13_o.png" width="1128"></p> 
<h4 id="4.3%E5%8D%8A%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1">2.4.3 半同步通信***</h4> 
<blockquote> 
 <p>        通过增加一条<strong>WAIT</strong>线<strong>,</strong> 保留了<strong>同步通信</strong>的基本特点, 又像<strong>异步通信</strong>, 允许不同速度的模块和谐工作。与同步通信相比, 无需将周期设置为速度最慢的设备, 较慢的从设备可以通过WAIT信号增加等待周期。</p> 
</blockquote> 
<p><strong> 原理图:</strong></p> 
<p><img alt="" height="473" src="https://images2.imgbox.com/ac/9a/FnPijJHy_o.png" width="862"></p> 
<h4 id="4.4%C2%A0%E5%88%86%E7%A6%BB%E5%BC%8F%E9%80%9A%E4%BF%A1">2.4.4 分离式通信***</h4> 
<blockquote> 
 <p>        当从设备按照命令进行读数据的必要准备时, 总线属于空闲状态。为优化这一点, 将一个传输周期分解为两个子周期, 第一个子周期,主模块使用总线发送地址和命令后, 释放总线使用权; 第二个子周期由从设备准备好数据后申请使用总线使用权。</p> 
</blockquote> 
<p>       <strong> 特点: </strong>各模块欲占用总线必须提出申请, 各模块准备数据过程不占用总线, 总线被占用时都在有效工作, 但这种控制比较复杂, 普通微信计算机很少采用。</p> 
<p>五, 总线指标</p> 
<p><strong>        总线宽度:</strong> 指数据总线的根数</p> 
<p><strong>        总线带宽:</strong> 总线的数据传输速率(单位: MBps), 单位时间内总线传输数据的位数。</p> 
<h2 id="%E7%AC%AC%E4%B8%89%E7%AB%A0%C2%A0%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F" style="text-align:center;">第三章 存储系统</h2> 
<h3 id="%E4%BA%8C%E3%80%81%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8">3.1 主存储器</h3> 
<p id="2.1%C2%A0%E4%B8%BB%E5%AD%98%E7%9A%84%E6%8A%80%E6%9C%AF%E6%8C%87%E6%A0%87"><strong>主存的技术指标:</strong></p> 
<p><strong>        存储容量: </strong>存储单元个数(MAR) x 存储字长(MDR位数) ( 单位: b ) 。</p> 
<p><strong>        存储器带宽: </strong>即<strong>数据传输率=数据宽度/存储周期, </strong>单位时间内存储器存取的信息量 。</p> 
<p><strong>        存储时间:</strong> 启动一次存储操作(读/写)到完成该操作所需的全部时间。</p> 
<p><strong>        存取周期: </strong>存储器进行连续两次独立的存储器操作所需最小间隔时间, 通常存取周期大于存取时间。</p> 
<p><strong>存储周期图:</strong></p> 
<p><img alt="" height="248" src="https://images2.imgbox.com/37/20/g4lSTXXW_o.png" width="734"></p> 
<h4 id="3.1.1%20%E5%AD%98%E5%82%A8%E5%99%A8%E5%88%86%E7%B1%BB">3.1.1 存储器分类</h4> 
<p id="1.1%20%E6%8C%89%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8%E5%88%86%E7%B1%BB"><strong>按存储介质分类: </strong></p> 
<p>      <strong>  1) 半导体器件: </strong>体积小, 功耗低, 存取时间短。电源消失时, 信息也随机丢失(<strong>易失性存储器</strong>)。 </p> 
<p>     <strong>   2) 磁性材料: </strong>在金属或塑料表面涂一层磁性材料作为记录介质, <strong>非易失性存储器。</strong></p> 
<p>      <strong>  3) 光盘: </strong>应用激光在记录介质(磁光材料)上进行读/写的存储器,<strong> 非易失性存储器。</strong></p> 
<p id="1.2%C2%A0%E6%8C%89%E5%AD%98%E5%8F%96%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB"><strong>按存取方式分类:</strong></p> 
<p>       <strong> 1) 串行访问存储器: </strong>对存储体进行读/写操作时, 需按其物理位置的先后<strong>顺序寻找地址</strong>。</p> 
<p>      <strong>  2) 随机存储器(Random Access Memory): </strong>存储器的任何一个存储单元的内容都可以<strong>随机存取</strong>, 分<strong>静态RAM</strong>(触发器原理)和<strong>动态RAM</strong>(电容充放电原理), 存取时间与存储单元物理位置无关。</p> 
<p>        <strong>3) 只读存储器(Read Only Memory):</strong> 存储的内容<strong>只能读</strong>, 而不能重新写入的存储器, 通常存放固定不变的程序。</p> 
<p id="1.3%C2%A0%E6%8C%89%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%88%86%E7%B1%BB"><strong>按在计算机中的作用分类:</strong></p> 
<p>       <strong> 1) 主存储器: </strong>主要特点是可以与CPU直接交换信息, <strong>速度快</strong>, <strong>容量小</strong>, <strong>价格高。</strong></p> 
<p>       <strong> 2) 辅助存储器:</strong> 存放当前占时不用的程序和数据, 不能与CPU直接交换信息, <strong>速度慢</strong>, <strong>容量大</strong>,<strong> 价位低 。</strong></p> 
<p>      <strong>  3) 缓冲存储器:</strong> 用在两个速度不同的部件之间, 如CPU与主存间, 主存与辅助存储器之间。</p> 
<p><strong>存储器的层次结构图:</strong></p> 
<p><img alt="" height="546" src="https://images2.imgbox.com/56/d5/cL01YoWG_o.png" width="819"></p> 
<p><img alt="" height="315" src="https://images2.imgbox.com/dc/46/4QB1L51I_o.png" width="1054"></p> 
<p><strong>        备注: </strong>主存和cache之间的数据调动是由<strong>硬件</strong>自动完成的, 主存与辅存之间的数据调动是<strong>硬件和操作系统</strong>共同完成的。</p> 
<h4 id="2.3%C2%A0%E8%AF%91%E7%A0%81%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F">3.1.2 译码驱动方式</h4> 
<p><strong>线选法:</strong></p> 
<p><img alt="" height="789" src="https://images2.imgbox.com/ee/bd/3Htkogt0_o.png" width="1082"></p> 
<p><strong>        特点: </strong>一根字选择线直接连接一个存储单元, 只适用容量不大的存储芯片</p> 
<p><strong>行列译码器:</strong></p> 
<p><img alt="" height="531" src="https://images2.imgbox.com/07/0e/NYvtGG4K_o.png" width="1093"></p> 
<p>       <strong> 特点: </strong>对比线选法, 可以减少地址线, 如32*32根地址线可以连接1024个存储单元。</p> 
<p><strong>3/8 译码器:</strong></p> 
<p><img alt="" height="224" src="https://images2.imgbox.com/69/21/WuxCaVUM_o.png" width="701"></p> 
<p><strong>对比图:</strong></p> 
<p><img alt="" height="168" src="https://images2.imgbox.com/f7/e0/Qwl8fw6P_o.png" width="926"></p> 
<p><strong>芯片引脚题注意事项:</strong></p> 
<p>        1) 数据线</p> 
<p>        2) 地址线, DRAM采用地址复用技术, 地址线减半。</p> 
<p>        3) 读写控制线1根 或 2根</p> 
<p>        4) 片选线1根 或 行通选和列通选共两根(复用技术, DRAM采用)</p> 
<h4 id="2.4%C2%A0%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8">3.1.3 随机存储器与只读存储器</h4> 
<p id="2.4.1%C2%A0%E9%9D%99%E6%80%81RAM"><strong>        静态RAM: </strong>基于触发器工作原理存储信息, 电源掉电时, 原存信息丢失, 属<strong>易失性存储器</strong>。</p> 
<p id="2.4.2%C2%A0%E5%8A%A8%E6%80%81RAM">       <strong> 动态RAM: </strong>基于电容存储电荷的原理来寄存信息。若电容上存有足够多的电荷表示 "1''; 电容上无电荷表示存 "0" 属<strong>易失性存储器</strong>。电容上的电荷一般只能维持1-2ms, 因此必须在2ms内对所有存储单元恢复一次原状态, 即刷新。</p> 
<p id="2.4.3%C2%A0%E9%9D%99%E6%80%81RAM%E4%B8%8E%E5%8A%A8%E6%80%81RAM%E7%9A%84%E6%AF%94%E8%BE%83"><strong>静态RAM与动态RAM的比较:</strong></p> 
<p><img alt="" height="625" src="https://images2.imgbox.com/41/50/E3aYiyDm_o.png" width="1185"></p> 
<p><strong>只读存储器: </strong></p> 
<p><strong>        掩模ROM:</strong> 不可重写</p> 
<p><strong>        PROM: </strong>可以实现<strong>一次性编程</strong>的只读存储器, 依靠熔丝断和未断来区别所存信息是 "0" 或 "1" 。</p> 
<p><strong>        EPROM: </strong>一种<strong>可擦除可编程</strong>只读存储器。可进行多次重写</p> 
<p><strong>        Flash Memory: </strong>闪速存储器， 如U盘, 看进行多次快速擦除重写, 但<strong>写比读慢</strong></p> 
<p><strong>        SSD: </strong>固态硬盘, 集成度高, 功耗低, 价格贵</p> 
<h4 id="2.4.4%C2%A0%E5%8A%A8%E6%80%81RAM%E5%88%B7%E6%96%B0">3.1.4 动态RAM刷新</h4> 
<blockquote> 
 <p>        刷新的过程实质上是将原存信息<strong>先读出</strong>, 再由刷新放大器形成原信息<strong>重新写入</strong>的过程。一般取2ms为<strong>刷新周期</strong>或称<strong>再生周期</strong>。通常有三种方式刷新: <strong>集中刷新</strong>, <strong>分散刷新</strong>, <strong>异步刷新</strong>。</p> 
</blockquote> 
<p><strong>1) 集中刷新</strong></p> 
<p>        集中刷新是在规定的一个刷新周期内, 对全部存储单元集中一段时间逐行进行刷新, 刷新过程必须停止读/写操作。不能进行读/写操作的这段时间称为访存<strong> "死区"</strong>。</p> 
<p><strong>集中刷新时间分配示意图:</strong></p> 
<p><img alt="" height="615" src="https://images2.imgbox.com/1c/80/w9ZZugU0_o.png" width="937"></p> 
<p><strong>2) 分散刷新</strong></p> 
<p>        分散刷新是指对每行存储单元的刷新分散到每个存取周期内完成, 存取周期分读/写周期+刷新周期。这样不存在 <strong>"死区"</strong> , 但存取周期变长, 系统速度下降。</p> 
<p><strong>分散刷新时间分配示意图:</strong></p> 
<p><img alt="" height="731" src="https://images2.imgbox.com/19/db/EjHkE3BM_o.png" width="991"></p> 
<p><strong>3) 异步刷新</strong></p> 
<p>        异步刷新是前两种方式的结合, 既可以缩短 <strong>"死区"</strong> , 又充分利用最大刷新间隔2ms的特点。</p> 
<p><strong>异步刷新时间分配示意图:</strong></p> 
<p><img alt="" height="632" src="https://images2.imgbox.com/2e/39/BkbdU2Cd_o.png" width="949"></p> 
<h3 id="2.6%C2%A0%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8ECPU%E7%9A%84%E8%BF%9E%E6%8E%A5">3.2 存储器与CPU的连接</h3> 
<blockquote> 
 <p>        将若干存储芯片连在一起组成足够容量的存储器, 称为存储容量的扩展, 通常有<strong>位扩展</strong>和<strong>字扩展</strong>。</p> 
</blockquote> 
<h4 id="2.6.1%C2%A0%E4%BD%8D%E6%89%A9%E5%B1%95">3.2.1 位扩展</h4> 
<blockquote> 
 <p>        增加存储字长。</p> 
</blockquote> 
<p><strong>示意图:</strong></p> 
<p><img alt="" height="649" src="https://images2.imgbox.com/eb/87/Vg94twcT_o.png" width="920"></p> 
<h4 id="2.6.2%C2%A0%E5%AD%97%E6%89%A9%E5%B1%95">3.2.2 字扩展</h4> 
<blockquote> 
 <p>        增加存储器字的数量。</p> 
</blockquote> 
<p><strong>示意图:</strong></p> 
<p><img alt="" height="669" src="https://images2.imgbox.com/47/e6/enLyYnbP_o.png" width="965"></p> 
<h4 id="2.6.2%C2%A0%E5%AD%97%E3%80%81%E4%BD%8D%E6%89%A9%E5%B1%95">3.2.2 字、位扩展</h4> 
<blockquote> 
 <p>        既增加存储字的数量, 又增加存储字长。</p> 
</blockquote> 
<p><strong>示意图:</strong></p> 
<p><img alt="" height="699" src="https://images2.imgbox.com/9d/15/C8GuQZAH_o.png" width="1200"></p> 
<h3 id="2.7%C2%A0%E6%8F%90%E9%AB%98%E8%AE%BF%E5%AD%98%E9%80%9F%E5%BA%A6%E7%9A%84%E6%8E%AA%E6%96%BD">3.3 提高访存速度的措施</h3> 
<h4 id="2.7.1%C2%A0%E5%8D%95%E4%BD%93%E5%A4%9A%E5%AD%97%E7%B3%BB%E7%BB%9F">3.3.1 单体多字系统 </h4> 
<blockquote> 
 <p>        根据<strong>程序和数据</strong>在存储体内是<strong>连续存放</strong>的, 因此CPU也是连续访存取出信息的。通过增大存储器的带宽, 在一个周期内, 从同一地址取出多条指令, 可以提高系统速度。但遇到转移指令, 或操作数不能连续存放, 则效果不明显。</p> 
</blockquote> 
<p><strong>原理图:</strong></p> 
<p><img alt="" height="495" src="https://images2.imgbox.com/9c/d1/gbeZcxO4_o.png" width="1056"></p> 
<h4 id="2.7.2%C2%A0%E5%A4%9A%E4%BD%93%E5%B9%B6%E8%A1%8C%E7%B3%BB%E7%BB%9F">3.3.2 多体并行系统</h4> 
<blockquote> 
 <p>        采用多体模块组成的存储器。每个模块都有独立的读写控制电路等, 可并行工作。</p> 
</blockquote> 
<p><strong>高位交叉, 顺序编址示意图:</strong></p> 
<p><img alt="" height="575" src="https://images2.imgbox.com/00/bd/99al4q9p_o.png" width="960"></p> 
<p><strong>低位交叉编址的四体存储器: </strong></p> 
<p><img alt="" height="550" src="https://images2.imgbox.com/b4/4e/ye7GxEMf_o.png" width="937"></p> 
<h3 id="3.4%C2%A0%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8">3.4 高速缓冲存储器</h3> 
<blockquote> 
 <p>        基于<strong>程序的局部性原理</strong>, 提高系统效率。</p> 
</blockquote> 
<h4 id="3.1%20Cache%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">3.4.1 Cache的工作原理</h4> 
<p><strong>Cache - 主存存储空间的基本结构图:</strong></p> 
<p><img alt="" height="493" src="https://images2.imgbox.com/89/de/GFiCzaHD_o.png" width="831"></p> 
<p><strong>Cache的基本结构原理图:</strong></p> 
<p><img alt="" height="663" src="https://images2.imgbox.com/5e/6a/EcSnaIVI_o.png" width="1123"></p> 
<h4 id="3.2.1%C2%A0%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84"><strong>3.2.2 直接映射</strong></h4> 
<blockquote> 
 <p>       主存在Cache的位置=<strong>主存块号%Cache总快数</strong>。先根据行号找到对应Cache行, 而后比较标记位。缺点是不够灵活, 每个主存块只能固定某个对应的缓存块, 使缓存的存储空间得不到充分利用。</p> 
</blockquote> 
<p><strong>示意图:</strong></p> 
<p><img alt="" height="530" src="https://images2.imgbox.com/10/57/KX3cyc17_o.png" width="1061"></p> 
<p><strong>直接映射的地址结构:</strong></p> 
<p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/38/be/rKvrfYqU_o.png" width="468"></p> 
<h4 id="3.2.2%C2%A0%E5%85%A8%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84">3.2.3 全相联映射</h4> 
<blockquote> 
 <p>        全相联映射允许主存中的每一字块映射到Cache中的任何一块位置上, 方式灵活, 但标记位数增多, 且访问Cache时主存字块标记<strong>需要</strong>和Cache的<strong>全部标记位进行比较</strong>。</p> 
</blockquote> 
<p><strong>示意图: </strong></p> 
<p class="img-center"><img alt="" height="452" src="https://images2.imgbox.com/af/98/uerWc0mK_o.png" width="604"></p> 
<h4 id="3.2.3%C2%A0%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84">3.2.4 组相联映射</h4> 
<blockquote> 
 <p>        组相联映射是对直接映射和全相联映射的一种折中。所属分组=主存块号%分组数。</p> 
</blockquote> 
<p><strong>示意图: </strong></p> 
<p><img alt="" height="543" src="https://images2.imgbox.com/65/0f/dJCpPPGw_o.png" width="1055"></p> 
<p><strong>组相联映射地址结构:</strong></p> 
<p class="img-center"><img alt="" height="150" src="https://images2.imgbox.com/a7/ba/l30jPzyo_o.png" width="419"></p> 
<h4 id="3.2.5%20Cache%E7%9A%84%E5%86%99%E7%AD%96%E7%95%A5%3A%C2%A0">3.2.5 Cache的写策略: </h4> 
<p><strong>写命中时: </strong></p> 
<p>        <strong>全写法</strong><strong>: </strong>写操作时数据既写入Cache又写入主存, 但增加了访存次数。</p> 
<p>       <strong> 回写法</strong><strong>: </strong>即写操作时只把数据写入Cache而不写入主存, 当<strong>Cache数据被替换出去时才写回主存</strong>。可设置一个脏位, 表示被修改过才需写回主存。多次写操作只需一次写入内存, 但增加了Cache的复杂性。</p> 
<p><strong>写不命中时:</strong></p> 
<p>    <strong>    写分配法</strong><strong>:</strong> 加载主存中的块到Cache中, 而后更新这个Cache块, 一般配合回写法。</p> 
<p>    <strong>    写非分配法</strong><strong>: </strong>只写入主存, 不进行调块。通常配合全写法使用 。</p> 
<p><strong>备注:</strong></p> 
<p>    <strong>    多级Cache: </strong> 现代计算机中, 各级Cache之间使用写非分配法+全写法, Cache和主存中使用写回法+分配法。</p> 
<p>  <strong>      分离Cache结构: </strong>分离指令Cache和数据Cache, 充分利用指令和数据的不同局部性来优化性能。减少指令流水线的冲突。</p> 
<h4 id="3.2.6%20Cache%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95">3.2.6 Cache替换算法</h4> 
<p><strong>        1) 随机算法:</strong> 不需要算法位</p> 
<p><strong>        2) 先进先出算法: </strong>不需要算法位</p> 
<p>     <strong>   3) 近期最少使用算法(LRU): 2路时有一位LRU位, 4路时用2位LRU位。新装入</strong>的行计数器置为0, 其余全+1; <strong>命中时</strong>, 命中行清零, 比其低的计数器+1; <strong>未命中时</strong>且无空闲行, 则淘汰最高的行。</p> 
<p id="%E5%9B%9B%E3%80%81%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8">      <strong>  4) 最不经常使用算法:(LFU): </strong>为每个Cache块设置一个计数器, Cache满后, 替换计数器值最小的。曾经被经常访问的主存块在未来不一定会用到, 实际运行效果不好。</p> 
<p>        <strong>计算cache大小: </strong><span style="color:#fe2c24;">行数*(数据位+标记位+有效位+算法位(仅LRU有, 取组相联路数的对数)+脏位) </span></p> 
<h3 id="3.5%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8(%E7%BB%93%E5%90%88%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)%C2%A0">3.5虚拟存储器(结合操作系统) </h3> 
<p><strong>原理图: </strong></p> 
<p><img alt="" height="668" src="https://images2.imgbox.com/3b/68/a6xxrNGs_o.png" width="1200"></p> 
<h2 id="%E7%AC%AC%E5%9B%9B%E7%AB%A0%C2%A0%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F" style="text-align:center;">第四章 输入输出系统</h2> 
<p><strong>显示器相关参数:</strong></p> 
<p><strong>        分辨率: </strong>能表示的像素个数</p> 
<p><strong>        灰度级: </strong>灰度级越多, 图像层次越清楚, 如8位(256级)</p> 
<p><strong>        刷新频率:</strong> 单位时间内扫描整个屏幕内容的次数</p> 
<p><strong>        显示存储器(VRAM): </strong>存储容量由图像分辨率和灰度级决定</p> 
<p style="text-align:center;">VRAM容量=分辨率 x 灰度级位数</p> 
<p style="text-align:center;">VRAM带宽 = 分辨率 x 灰度级位数 x 帧数</p> 
<h3 id="4.1%20I%2FO%E6%8E%A5%E5%8F%A3">4.1 I/O接口 (设备控制器)</h3> 
<blockquote> 
 <p>        即I/O控制器, 是主机和外设之间的交接界面, 协调主机与外设之间的数据传输。</p> 
</blockquote> 
<p><strong>示例图:</strong></p> 
<p><img alt="" height="340" src="https://images2.imgbox.com/4f/75/ELty8a0H_o.png" width="858"></p> 
<p><strong>I/O接口的功能:</strong></p> 
<p>        1) 进行地址译码和设备选择</p> 
<p>        2) 实现主机和外设通信联络控制</p> 
<p>        3) 实现数据缓冲</p> 
<p>        4) 信号格式的转换</p> 
<p>        5) 传送控制命令和状态信息</p> 
<p><strong> I/O接口图:</strong></p> 
<p><img alt="" height="405" src="https://images2.imgbox.com/44/10/mZ1mzhie_o.png" width="922"></p> 
<p> <strong>       端口: </strong>接口电路中可以进行读写的存储器, 若干端口加上相应的控制逻辑才可以组成接口</p> 
<p><strong>接口与端口区别图:</strong></p> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/33/1c/HeJ7BldS_o.png" width="551"></p> 
<h3 id="4.2%20%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F">4.2 中断系统</h3> 
<p>   <strong>     中断请求: </strong>中断系统需对每个中断源设置中断请求标记触发器INTR, 当状态为"1"时, 表示中断源有请求。通过INTR线发出的是可屏蔽中断, 通过NMI线发出的是不可屏蔽中断。</p> 
<p><strong>示例图:</strong></p> 
<p><img alt="" height="218" src="https://images2.imgbox.com/69/bc/GuTC2q4z_o.png" width="1008"></p> 
<p>     <strong>   中断响应判优: </strong>通常通过硬件排队器实现, <strong>响应优先级</strong>在硬件线路上是固定的, <strong>处理优先级</strong>可以利用中断屏蔽技术动态调整。具体优先级如下:</p> 
<p>        1) 不可屏蔽中断 &gt; 内部异常 &gt; 可屏蔽中断</p> 
<p>        2) 内部异常中, 在关中断模式下也会被响应。硬件故障 &gt; 软件中断</p> 
<p>        3) DMA中断请求 &gt; I/O设备传送的中断请求</p> 
<p>        4) I/O 传送类中断里, 高数设备 &gt; 低速设备</p> 
<p>        5) 输入设备 &gt; 输出设备, 实时设备 &gt; 普通设备</p> 
<p><strong>示例图:</strong></p> 
<p><img alt="" height="371" src="https://images2.imgbox.com/52/78/WNe32nTu_o.png" width="1169"></p> 
<p><strong>中断屏蔽技术 (优先级: D&gt;A&gt;C&gt;B) 图:</strong></p> 
<p><img alt="" height="331" src="https://images2.imgbox.com/b9/0e/AhSynJKB_o.png" width="1200"></p> 
<p>        <strong>中断响应: </strong>由硬件直接实现, 称为中断隐指令, 并不是一条具体的指令, 本质是硬件一系列自动操作, 操作如下:</p> 
<p>        1) 关中断</p> 
<p>        2) 保存断点: 如<span style="color:#fe2c24;"><strong>PC, PSW的内容</strong></span>。(保存到栈中), 异常的断点是当前指令的地址, 中断的断点是下一条指令的地址。</p> 
<p>        3) 引出中断服务程序: 识别中断源, 将对应服务程序入口地址送入程序计数器PC中。有硬件向量法和软件查询法。</p> 
<p><strong>硬件向量法</strong><strong>示意图:</strong></p> 
<p><img alt="" height="564" src="https://images2.imgbox.com/9d/8d/bA3WAppx_o.png" width="1048"></p> 
<p><strong>中断服务程序处理过程:</strong></p> 
<p>        1) 保护现场和屏蔽字: <span style="color:#fe2c24;"><strong>保存通用寄存器和状态寄存器的内容</strong></span>。(保存到堆中)</p> 
<p>        2) 开中断(可多重中断)</p> 
<p>        3) 执行中断服务程序</p> 
<p>        4) 关中断(可多重中断)</p> 
<p>        5) 恢复现场和屏蔽字</p> 
<p>        6) 开中断, 中断返回: 中断服务程序的最后一条指令通常是一条中断返回指令。</p> 
<p><strong>示意图:</strong></p> 
<p><img alt="" height="663" src="https://images2.imgbox.com/d0/4f/Ec3SJXWb_o.png" width="1164"></p> 
<p><strong>中断响应条件:</strong></p> 
<p>        1) 中断源有中断请求</p> 
<p>        2) CPU允许中断, 即开中断 (异常和不可屏蔽中断不受此限制)</p> 
<p>        3) 对于外中断, CPU在<strong>每条指令执行阶段结束</strong>前向接口发出中断查询信号。 (异常不受此限制)</p> 
<p><strong>中断与异常:</strong></p> 
<p><strong>        中断: </strong>来自CPU外部, 与CPU执行指令无关的事件引起的中断。分为可屏蔽中断与不可屏蔽中断。中断不和任何指令相关联, 异常与指令相关。</p> 
<p><strong>        异常: </strong>分为硬件故障和程序性异常, 程序性异常也称软件中断, 可分为故障, 自陷, 终止。</p> 
<p>               <strong> 1) 故障: </strong>执行结束前被检测到的异常事件</p> 
<p>                <strong>2) 自陷: </strong>预先安排的一种 "异常" 事件, <strong>故障与自陷属于软件中断。</strong></p> 
<p>              <strong>  3) 终止:</strong> 发生了使计算机无法继续执行的硬件故障, 如控制器出错, 存储器校验错。<strong>终止与外中断属于硬件中断</strong>。</p> 
<p><strong>广义的中断类型:</strong><br><img alt="" height="623" src="https://images2.imgbox.com/29/0a/AaXScM5K_o.png" width="1200"></p> 
<p><strong>        中断响应时间: </strong>一条指令执行结束。</p> 
<h3 id="1.1%C2%A0%E6%97%A9%E6%9C%9F%E9%98%B6%E6%AE%B5">4.3 DMA方式</h3> 
<blockquote> 
 <p>        <strong>直接存储器(Direct Memory Access, DMA) </strong>技术使I/O设备与主存之间有一条直接数据通路, 可以直接与主存交换信息。实现了CPU和I/O设备并行工作, 但CPU要响应中断请求, 还不能真正做到并行工作。</p> 
</blockquote> 
<p><strong> DMA控制器图:</strong><img alt="" height="689" src="https://images2.imgbox.com/f1/9f/kq9fZxbK_o.png" width="1200"></p> 
<p><strong>DMA传送图:</strong></p> 
<p><img alt="" height="658" src="https://images2.imgbox.com/00/42/uhcDBIqT_o.png" width="1200"></p> 
<p id="3.3.4%C2%A0DMA%E6%8E%A5%E5%8F%A3%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><strong>DMA接口基本组成原理图:</strong></p> 
<p><img alt="" height="591" src="https://images2.imgbox.com/73/c0/IG4tsgH5_o.png" width="997"></p> 
<p><strong>        AR:</strong> 主存地址寄存器, 用于存放主存中需要交换数据的首地址, 每交换一次数据, AR+1</p> 
<p><strong>        WC: </strong>字计数器, 记录传送数据的总字数, 通常使用补码形式, 计数器为0时, 表示数据传送完成。</p> 
<p><strong>        BR: </strong>数据缓存寄存器, 用于暂存每次传送的数据。</p> 
<p><strong>        DAR: </strong>设备地址寄存器, 存放I/O设备的设备码或表示设备信息存储区的寻址信息。如磁盘数据所在的区号、盘面号和柱面号。</p> 
<p>     <strong>   DREQ:</strong> I/O设备向DMA接口提出申请。</p> 
<p>     <strong>   HRQ: </strong>向CPU发出总线使用权的请求信号。</p> 
<p>        <strong>HLDA: </strong>CPU发出的响应信号。</p> 
<p>       <strong> DACK:</strong> 通知I/O设备。</p> 
<p><strong>DMA方式与程序中断方式的比较:</strong></p> 
<table align="center" border="1" cellpadding="1" cellspacing="1"><tbody><tr><td></td><td>DMA方式</td><td>程序中断方式</td></tr><tr><td>传输方式</td><td>靠硬件传送</td><td>由程序来传送</td></tr><tr><td>保护现场</td><td>不需要中断现行程序</td><td>需要保护现场</td></tr><tr><td>响应</td><td>指令周期内任意存储周期结束时响应</td><td>指令执行结束才响应</td></tr><tr><td>软硬件</td><td>仅靠硬件控制传输数据</td><td>软硬结合</td></tr><tr><td>优先级</td><td colspan="2" rowspan="1">DMA方式 高于 中断方式</td></tr></tbody></table> 
<h4 id="4.3.1%20DMA%E7%9A%84%E4%BC%A0%E9%80%81%E6%96%B9%E5%BC%8F%C2%A0">4.3.1 DMA的传送方式 </h4> 
<p id="3.3.1%C2%A0%E5%81%9C%E6%AD%A2CPU%E8%AE%BF%E9%97%AE%E4%B8%BB%E5%AD%98"><strong>        1) 停止CPU访问主存:</strong> 由DMA接口向CPU发一个停止信号, 让出总线使用权。这种方式控制简单, 缺点是CPU基本处于不工作状态或保持原状态。</p> 
<p><strong>示意图:</strong></p> 
<p><img alt="" height="387" src="https://images2.imgbox.com/09/c5/i5X4nBxf_o.png" width="1039"></p> 
<p id="3.3.2%C2%A0%E5%91%A8%E6%9C%9F%E6%8C%AA%E7%94%A8">       <strong> 2) 周期挪用: </strong>DMA与CPU同时访问主存时, CPU总是将总线占有权让给DMA (I/O不立即访问主存可以丢失数据) , 一般为一个存取周期,  DMA的这种占有成为<strong>周期挪用</strong>或<strong>周期窃取</strong>。每挪用一个主存周期都需要申请、建立和归还总线控制权。</p> 
<p><strong>示意图:</strong></p> 
<p><img alt="" height="344" src="https://images2.imgbox.com/76/e5/eMxEcxLn_o.png" width="1200"></p> 
<p id="3.3.3%C2%A0DMA%E4%B8%8ECPU%E4%BA%A4%E6%9B%BF%E8%AE%BF%E9%97%AE"><strong>        3) DMA与CPU交替访问:</strong> 适用于CPU的工作周期比主存存取周期长的情况 (如: CPU工作周期是1.2us, 主存周期小于0.6us) 。 这种情况不需要总线使用权的申请、建立和归还。</p> 
<p><strong>示意图:</strong></p> 
<p><img alt="" height="487" src="https://images2.imgbox.com/c4/18/J8rb2wqX_o.png" width="1076"></p> 
<h4 id="3.3.5%20DMA%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F">4.4.5 DMA接口的连接方式***</h4> 
<blockquote> 
 <p>        主要有以下两种, 与总线判优类似。</p> 
</blockquote> 
<p>       <strong> 具有公共请求线的DMA: </strong>若干个DMA接口通过一条公用的DMA请求线先CPU申请总线控制权, 采用<strong>链式查询</strong>, 最前面的DMA优先级最高。  </p> 
<p><strong>示意图:</strong></p> 
<p><img alt="" height="560" src="https://images2.imgbox.com/9f/da/vk8O9eyI_o.png" width="1163"></p> 
<p><strong>        独立的DMA: </strong>每个DMA接口个有一对DMA请求线和响应线, <strong>由CPU的优先级判别机构裁</strong>决响应。</p> 
<p><strong>示意图:</strong></p> 
<p class="img-center"><img alt="" height="600" src="https://images2.imgbox.com/35/c9/FsxI0yNX_o.png" width="887"></p> 
<h4 id="3.3.6%20DMA%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B">4.4.6 DMA接口类型***</h4> 
<p><strong>        选择性DMA接口: </strong>物理上连接多个I/O设备, 逻辑上只允许连接一个设备, <strong>适用于数据传输率很高的设备</strong>。</p> 
<p><strong>逻辑框图:</strong></p> 
<p><img alt="" height="741" src="https://images2.imgbox.com/e2/66/DxtgOYej_o.png" width="1123"></p> 
<p>  <strong>      多路型DMA接口: </strong>物理上可以连接多个设备, 逻辑上也运行多个设备同时工作, 每个与DMA连接的I/O设备都有一套寄存器存放各自参数, 各个I/O设备采用字节交叉的方式与DMA接口进行数据传送,<strong>适用于同时为多个数据传输率低的I/O设备服务</strong>。</p> 
<p><strong>逻辑框图:</strong></p> 
<p class="img-center"><img alt="" height="358" src="https://images2.imgbox.com/55/d2/UJeW5yRy_o.png" width="715"></p> 
<p></p> 
<h2 id="%E7%AC%AC%E4%BA%94%E7%AB%A0%C2%A0%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97" style="text-align:center;">第五章 数据的表示和运算</h2> 
<h3 id="5.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%95%B0%E5%80%BC">5.1 计算机中的数值</h3> 
<blockquote> 
 <p>        有符号数与无符号数 (即没有符号的数) 不同, 区分正负；最高位用"0"表示正, "1" 表示负号。 </p> 
</blockquote> 
<p><strong>        机器数:</strong> 把符号"数字化"的数称为机器数。</p> 
<p>  <strong>      真值: </strong>带 "+" 或 "-" 符号的数称为真值。</p> 
<p>  <strong>      原码:</strong> 符号位"0"表示正数, "1"表示负数。数值位即真值的绝对值。 </p> 
<p><strong>        反码: </strong>通常用来作为原码求补码, 或补码求原码的中间过渡。正数反码是其正数本身。</p> 
<p><strong>        补码: </strong>可以将减法操作化作加法操作。正数的补码是其本身, 负数的补码可以看作对其原码<strong>除符号位外, 每位求反, 末位加1。特别地, [x]补 经过<span style="color:#fe2c24;">符号位和数值位按位取反+1</span> 得到[-x]补。</strong></p> 
<p>     <strong>   移码:</strong> 针对补码无法直接比较大小而引出的一种表示法, 即对补码加上一个<img alt="2^{n}" src="https://images2.imgbox.com/fe/da/lu66B7Cu_o.png"> , 即将最高位符号位取反。 </p> 
<p>       <strong> 除0: </strong>故障</p> 
<p><strong>各类机器数真值范围图:</strong></p> 
<p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/57/01/0eqgk2Ud_o.png" width="658"></p> 
<p><strong>移码与补码对照图:</strong></p> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/53/70/qMwRHDeq_o.png" width="439"></p> 
<p><strong>备注: </strong></p> 
<p><strong>        </strong>1) 十进制小数不一定都能用二进制表示。</p> 
<p>        2) 原码, 反码的表示在数轴上对称, 存在+0和-0；而补码, 移码的0是唯一的。</p> 
<p>        3) 移码和补码的符号位相反, 数值位相同</p> 
<p>        4) 负数的补码中, 数值部分越大, 真值越大(更靠近0), 多表示一个最小负数</p> 
<p>        5) 移码保持数据原有大小顺序, 移码大则真值大</p> 
<p><strong>大小端存储方式:</strong></p> 
<p><img alt="" height="289" src="https://images2.imgbox.com/ed/1e/xLJagZgk_o.png" width="1200"></p> 
<p><strong>边界对齐存储方式:</strong></p> 
<p>      <strong>  边界对齐特点: </strong>浪费了一些存储空间, 但提高指令和取数的速度。</p> 
<p>    <strong>    边界不对齐特点: </strong>可以充分利用存储空间, 但可能需要多次访存, 影响了指令执行效率。</p> 
<p><strong>原理图:</strong></p> 
<p><img alt="" height="511" src="https://images2.imgbox.com/e7/79/neyx0eXw_o.png" width="1200"></p> 
<h3 id="5.2%C2%A0%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97">5.2 定点数的运算</h3> 
<blockquote> 
 <p>    在计算机中, 小数点不用专门的器件表示, 而是按约定的方式标出, 即<strong>定点表示法</strong>和<strong>浮点表示法</strong>。</p> 
</blockquote> 
<p><strong>        定点表示法:</strong> 小数点位于数符和第一数值之间时, 机器内的数为<strong>纯小数</strong>; 当小数点位于数值位之后时, 机器内的数为<strong>纯整数</strong>。</p> 
<p><strong>定点数示意图:</strong></p> 
<p><img alt="" height="328" src="https://images2.imgbox.com/59/14/hr1EaYZy_o.png" width="934"></p> 
<h4 id="2.1%C2%A0%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97"> 5.2.1 移位运算</h4> 
<blockquote> 
 <p>        通过移位运算与加减法运算可实现乘除运算。</p> 
</blockquote> 
<p><strong>算术移位规则:</strong></p> 
<p><img alt="" height="310" src="https://images2.imgbox.com/16/c1/LBFuQ3PH_o.png" width="1031"></p> 
<h4 id="2.2%C2%A0%E5%8A%A0%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97">5.2.2 加减法运算</h4> 
<blockquote> 
 <p>        现代计算机中都采用补码做加减法运算。符号位一起参与运算。</p> 
</blockquote> 
<p><strong>基本公式:</strong></p> 
<p><img alt="" height="197" src="https://images2.imgbox.com/27/f1/3FAiBMsC_o.png" width="832"></p> 
<p><strong>溢出判断: </strong></p> 
<p><strong>方法一示意图:</strong></p> 
<p class="img-center"><img alt="" height="250" src="https://images2.imgbox.com/5b/8c/O8JBW4ol_o.png" width="461"></p> 
<p><strong>         方法二:</strong> 采用一位符号位, 根据<strong><span style="color:#fe2c24;">数据位进位C1与符号位进Cs位异或</span></strong>判断, 不同为溢出 </p> 
<p><strong>示意图: </strong></p> 
<p class="img-center"><img alt="" height="284" src="https://images2.imgbox.com/8b/14/fzGsbCLH_o.png" width="488"></p> 
<p><strong>        方法三: 采用双</strong>符号位, 符号位不同为溢出。(模4补码, 更容易检查加减法溢出问题)</p> 
<h4 id="2.3%C2%A0%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97">5.2.3 乘法运算</h4> 
<p><strong>原码乘法步骤:</strong></p> 
<p><strong>        1) 符号位与数值位分开求, 符号位采用异或</strong></p> 
<p>        1) 由乘数末位值确定被乘数是否与原部分积相加, 然后右移一位, 形成新的部分积, 同时乘数也右移一位, 空出最高位放部分积的最低位。<strong>重复n次</strong></p> 
<p><strong>示例图:</strong></p> 
<p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/73/6b/CznuZb8H_o.png" width="638"></p> 
<p><strong>补码乘法示例图: </strong>符号位参与运算, <strong>进行n+1累加, n次右移</strong>    </p> 
<p><img alt="" height="724" src="https://images2.imgbox.com/5f/f7/hvTE9oFX_o.png" width="1200"></p> 
<h4 id="2.4%C2%A0%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97">5.2.4 除法运算</h4> 
<p><strong>        恢复余数法</strong>: 相减后, 当余数为负时, 需要加上除数, 将其恢复成原来的余数。</p> 
<p><strong>原码恢复余数法示例图:</strong></p> 
<p><img alt="" height="580" src="https://images2.imgbox.com/e7/2d/UCnWjr1t_o.png" width="1200"></p> 
<p>  <strong>      加减交替法: </strong>可以认为是恢复余数法的一种改进算法。设余数为R, 除数为y, 则:</p> 
<p>                1) R&gt;0时, 上商"1", 再2R-y;</p> 
<p>                2) R&lt;0时, 上商"0", 先R+y, 再左移一位-y, 即2(R+y)-y=2R+y。</p> 
<p>                3) 商符由两个操作数的符号异或而得, 第n+1步余数为负时, 需要加上|y|得到正确余数</p> 
<p><strong>原码加减交替法示意图:</strong></p> 
<p><img alt="" height="734" src="https://images2.imgbox.com/86/22/BEapKObv_o.png" width="1200"></p> 
<p><strong>补码除法原理图:</strong></p> 
<p><img alt="" height="710" src="https://images2.imgbox.com/9c/f6/JgMN6fb2_o.png" width="1200"></p> 
<p><strong>原码除法与补码除法对比图:</strong></p> 
<p><img alt="" height="310" src="https://images2.imgbox.com/89/5f/Sft8cLmX_o.png" width="1200"></p> 
<h3 id="5.3%C2%A0%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97">5.3 浮点数的运算</h3> 
<p><strong>        浮点表示: </strong>小数点位置可以浮动的数。位数相同时,表示数值的范围比定点数大。将尾数最高位为1的浮点数称为规格化数, 此时精度最高。尾数是小数, 其位数n反映了浮点数的精度。</p> 
<p><strong>浮点数形式示意图:</strong></p> 
<p class="img-center"><img alt="" height="194" src="https://images2.imgbox.com/3f/93/fe3O9X1V_o.png" width="784"></p> 
<p><strong>规格化: </strong></p> 
<p><strong>        原码表示的尾数规格化:</strong> 尾数最高位数值必须是1</p> 
<p>     <strong>   补码表示的尾数规格化:</strong> 尾数最高数值位必须和尾数符号位相反</p> 
<p><strong>IEEE 754 标准:</strong></p> 
<p><img alt="" height="513" src="https://images2.imgbox.com/26/ad/GMyOGwrU_o.png" width="1200"></p> 
<p><strong>最大最小值的绝对值:</strong></p> 
<p><img alt="" height="153" src="https://images2.imgbox.com/28/f6/XGRCnY3f_o.png" width="1200"></p> 
<p><strong>全0全1阶码情况:</strong></p> 
<p>        全0阶码全0尾数: 正负零(机器零), 符号取决数符</p> 
<p>        全1阶码全0尾数: 正负无穷</p> 
<p><strong>浮点数加减运算步骤:</strong></p> 
<p>        1) 对阶: 小阶向大阶看齐</p> 
<p>        2) 尾数加减</p> 
<p>        3) 规格化</p> 
<p>        4) 舍入 (<span style="color:#fe2c24;"><strong>最简单</strong></span>的是处理方法是 <strong>截断法</strong>)</p> 
<p>        5) 判断溢出: 阶码溢出才算溢出</p> 
<p><strong>C语言中的类型转化:</strong></p> 
<p>     <strong>   int 转化 float : </strong>可能会精度缺失</p> 
<p>    <strong>    float转化int: </strong>可能会溢出或精度缺失</p> 
<h3 id="5.4%C2%A0%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83">5.4 算术逻辑单元</h3> 
<p><strong>逻辑门电路图:</strong></p> 
<p><img alt="" height="596" src="https://images2.imgbox.com/fc/96/y52X3uJw_o.png" width="1005"></p> 
<p><strong>一位全加器:</strong></p> 
<p><img alt="" height="405" src="https://images2.imgbox.com/f6/e7/rj62BDx2_o.png" width="1200"></p> 
<p><strong>并行进位加法器: </strong></p> 
<p><img alt="" height="464" src="https://images2.imgbox.com/a2/82/IhshThgm_o.png" width="1200"></p> 
<p><strong>带标志的加法器:</strong></p> 
<p><img alt="" height="523" src="https://images2.imgbox.com/d5/89/Eaz9ZdON_o.png" width="1200"></p> 
<p>        <strong>OF:</strong> 有符号数的加减运算是否发生了溢出, OF=1时, 说明有溢出。(次高进位异或最高位的进位) </p> 
<p>       <strong> SF: </strong>有符号数加减运算结果的正负性。SF=0时表示运算结果为正 (最高位生成)</p> 
<p>     <strong>   ZF:</strong> 加减运算结果是否为0, ZF=1表示运算结果为0 </p> 
<p>        <strong>CF: </strong>无符号数加减法运算是否发生了溢出, CF=1时说明发生了溢出 (Sub异或Cout)</p> 
<p><strong>多路选择器:</strong>  有k个输入, 控制信号的位数   <img alt="m\geq \left \lceil log_{2}^{k} \right \rceil bit" class="mathcode" src="https://images2.imgbox.com/5f/0f/iXNgLmEL_o.png"></p> 
<p><img alt="" height="483" src="https://images2.imgbox.com/ca/9e/Qrg8JtCD_o.png" width="906"></p> 
<p><strong>三态门图:</strong></p> 
<p class="img-center"><img alt="" height="270" src="https://images2.imgbox.com/6f/d6/r0AxnotX_o.png" width="329"></p> 
<p><strong> ALU框图:</strong></p> 
<p><img alt="" height="508" src="https://images2.imgbox.com/64/a2/tMnLRuCT_o.png" width="994"></p> 
<p>     <strong>   补码加减运算部件:</strong> Sub控制端为1时表示做减法, 实现 X+Y(取反)+1 = [X]补+[-Y]补</p> 
<h2 id="%E7%AC%AC%E5%85%AD%E7%AB%A0%C2%A0%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F" style="text-align:center;">第六章 指令系统</h2> 
<h3 id="6.1%20%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4">6.1 机器指令</h3> 
<blockquote> 
 <p>        机器语言由一条条语句构成, 习惯把每一条机器语言的语句称为<strong>机器指令</strong>, 将全部的机器指令的集合称为机器的<strong>指令系统</strong>。</p> 
</blockquote> 
<p><strong>        80-20规律: </strong>典型程序中80%的语句仅仅使用处理机中的20%的指令, 这些指令都属于简单指令。<br><strong>        RISC:</strong> 精简指令系统计算机 (Reduced Instruction Set Computer), 指令按边界对齐。</p> 
<p>     <strong>   CISC:</strong> 复杂指令系统计算机 (Complex Instruction Set Computer), 大多能实现软件兼容, 即高档机包含了低档机的全部指令。</p> 
<p><strong>RISC与CISC比较图:</strong></p> 
<p><img alt="" height="659" src="https://images2.imgbox.com/ee/93/dBkp7f7A_o.png" width="1200"></p> 
<p><strong>        指令集体系结构(ISA):</strong> 包括指令格式, 数据类型及格式, 操作数的存放方式, 程序可访问的寄存器个数, 位数和编号, 存储空间大小和编址方式, 寻址方式, 指令执行过程的控制方式等。 </p> 
<p><strong> 指令的一般格式图:</strong></p> 
<p class="img-center"><img alt="" height="350" src="https://images2.imgbox.com/0c/47/LgCxVm51_o.png" width="804"></p> 
<p><strong>按地址码数目分类: </strong></p> 
<p><strong>        四地址指令：</strong>该指令完成(A1)OP(A2) --&gt;A3的操作, 4个地址各占6位, 直接寻址范围为<img alt="2^{6}" src="https://images2.imgbox.com/52/be/RaJAjfv1_o.png">=64。共需访问4次存储器(取指令一次, 取两个操作数两次, 存放结果一次)。</p> 
<p><strong>        三地址指令: </strong>该指令完成(A1)OP(A2)--&gt;A3的操作, 程序中大多数指令是按顺序执行的, 后续指令的地址隐含在程序计数器PC中。3个地址字段各占8位, 寻址范围为<img alt="2^{8}" src="https://images2.imgbox.com/49/5f/c1rSIsLe_o.png">=256, 需要访问4次存储器。</p> 
<p>        <strong>二地址指令: </strong>该指令完成(A1)OP(A2)--&gt;A1 的操作, A1即代表原操作数, 也代表存放本次运算的结果地址。共需要4次访问存储器; 若为(A1)OP(A2)--&gt;ACC, 只需要两次访存。直接寻址范围为<img alt="2^{12}" src="https://images2.imgbox.com/ff/cf/7mHltn55_o.png">=4K。</p> 
<p><strong>        一地址指令</strong>: 可完成(ACC)OP(A1)--&gt;ACC的操作, 只需两次访存, 直接寻址范围为<img alt="2^{24}" src="https://images2.imgbox.com/d6/68/2aFJHWbu_o.png">=16M。</p> 
<p>   <strong>     零地址指令:</strong> 无地址码部分, 如空操作, 停机, 中断返回等指令, 或是操作数的地址隐含在堆栈指针SP中。</p> 
<p><strong>示意图:</strong></p> 
<p><img alt="" height="486" src="https://images2.imgbox.com/c1/f0/yyHkAGxt_o.png" width="838"></p> 
<p><strong>按操作码长度分类:</strong></p> 
<p> <strong>       1) 定长操作码: </strong>适用于字长较长的计算机以及RISC, 指令译码时间短。</p> 
<p>        <strong>2) 不定长操作码</strong>: 在字长较短的微型计算机中广泛使用, 会增加指令译码和分析的难度。</p> 
<p><strong>不定长操作码图:</strong></p> 
<p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/1b/8e/Jbw6jEDT_o.png" width="577"></p> 
<p id="1.3%C2%A0%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B"><strong>操作类型:</strong></p> 
<p><strong>        1) 数据传送: </strong>寄存器与存储单元, 存储单元与存储单元,, 寄存器与存储单元,之间的传送。</p> 
<p><strong>        2) 算术逻辑操作:</strong> 算术运算(加,减,乘,除等)与逻辑运算(与,或,非,异或等)。</p> 
<p>   <strong>     3) 移位: </strong>左移, 右移。</p> 
<p><strong>        4) 转移:</strong> 无条件转移, 条件转移, 调用与返回, 陷阱与陷阱指令。</p> 
<p>  <strong>      5) 输入输出：</strong>与I/O设备交互。</p> 
<p><strong>        6) 其他:</strong> 停机指令, 开中断指令等。</p> 
<h3 id="1.4%C2%A0%E6%93%8D%E4%BD%9C%E6%95%B0%E7%B1%BB%E5%9E%8B">6.2 指令的寻址方式</h3> 
<h4 id="6.2.1%20%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80"><strong>6.2.1 指令寻址</strong></h4> 
<blockquote> 
 <p>        分为顺序寻址与跳跃寻址, <strong>顺序寻址</strong>可以通过<strong>PC</strong>自动加<strong>"1个指令字长", </strong>形成下一条指令的地址; <strong>跳跃寻址</strong>通过转移类指令实现。</p> 
</blockquote> 
<p><strong>指令寻址方式示意图:</strong></p> 
<p><img alt="" height="360" src="https://images2.imgbox.com/03/54/snCdTZD0_o.png" width="743"></p> 
<h4 id="6.2.2%C2%A0%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80">6.2.2 数据寻址</h4> 
<blockquote> 
 <p>   数据寻址方式种类多, 在指令中需设一字段表明是哪一种寻址方式。</p> 
</blockquote> 
<p><strong>一地址指令的格式图:</strong></p> 
<p><img alt="" height="164" src="https://images2.imgbox.com/74/f1/040QsAUb_o.png" width="898"></p> 
<p><strong>        1) 立即寻址</strong>: 操作数本身设在指令字内, 即形式地址就是数据本身, 数据采用补码形式存放。</p> 
<p><img alt="" height="279" src="https://images2.imgbox.com/17/eb/bhlecP5Q_o.png" width="724"></p> 
<p><strong>        2) 直接寻址:</strong> 指令字中的形式地址A就是操作数的真实地址。</p> 
<p><img alt="" height="348" src="https://images2.imgbox.com/2c/7f/yLFk2n46_o.png" width="1001"></p> 
<p><strong>        3) 隐含寻址: </strong>不明显给出操作数的地址, 操作数的地址隐含在操作码或某个寄存器中。</p> 
<p><img alt="" height="559" src="https://images2.imgbox.com/03/5e/RAnDsW8O_o.png" width="1080"></p> 
<p><strong>        4) 间接寻址: </strong>形式地址是操作数的有效地址所在的存储单元地址。与直接寻址相比, 扩大了操作数的寻址范围, 但<strong>多次间接寻址时, 可用存储字首位来标记</strong>是否还需要继续访存寻址。</p> 
<p><img alt="" height="615" src="https://images2.imgbox.com/30/3e/8pmkgHWF_o.png" width="1168"></p> 
<p>     <strong>   5) 寄存器寻址: </strong>地址码字段直接给出了寄存器的编号, 无需访存, 减少执行时间。</p> 
<p class="img-center"><img alt="" height="368" src="https://images2.imgbox.com/39/52/hQF14LQ7_o.png" width="488"></p> 
<p>   <strong>     6) 寄存器间接寻址: </strong>比间接寻址少访存一次。</p> 
<p><img alt="" height="659" src="https://images2.imgbox.com/f6/f7/RWVYN0UK_o.png" width="1017"></p> 
<p><strong>        7) 基址寻址: </strong>需要设有寄存器BR, 可以扩大操作数的寻址范围。<strong>面向操作系统</strong>, 有<strong>利于多道程序设计, 便于编制浮动程序</strong>, 可由用户指定具体寄存器为基址寄存器。</p> 
<p><img alt="" height="514" src="https://images2.imgbox.com/0e/3c/8mAb4MlA_o.png" width="944"></p> 
<p><strong>        8) 变址寻址: </strong>与基址寻址极为相似, <strong>面向用户</strong>, 有效地址等于指令字的形式地址+变址寄存器IX, 处理数组问题时, 只需改变寄存器IX内容, 无需多条指令, <strong>适合编制循环程序</strong>。</p> 
<p><img alt="" height="523" src="https://images2.imgbox.com/ab/93/tKTVGj3o_o.png" width="926"></p> 
<p><strong>        9) 相对寻址: </strong>有效地址是程序计数器PC+形式地址。 位移量可正可负, 由补码表示, <strong>便于程序浮动, 广泛用于转移指令</strong>。</p> 
<p><img alt="" height="304" src="https://images2.imgbox.com/7f/34/yytiRvXl_o.png" width="745"></p> 
<p><strong>        10) 堆栈寻址:</strong> 要求计算机中设有堆栈, 操作数只能从栈顶中存或取, 堆栈寻址可视为一种隐含寻址, 操作数的地址总是被隐含在<strong>SP指针</strong>中。硬堆栈不访存, 软堆栈访存1次。</p> 
<p><img alt="" height="462" src="https://images2.imgbox.com/47/30/hJnL09gQ_o.png" width="1131"></p> 
<p><strong>对比图:</strong></p> 
<p><img alt="" height="655" src="https://images2.imgbox.com/25/ed/qY524v2I_o.png" width="1200"></p> 
<h3 id="6.3%C2%A0%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA">6.3 程序的机器级代码表示</h3> 
<p><strong>x86架构CPU中的寄存器图:</strong></p> 
<p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/bf/eb/TtoL6FVW_o.png" width="610"></p> 
<p><img alt="" height="315" src="https://images2.imgbox.com/19/51/1h9hBccN_o.png" width="779"><img alt="" height="320" src="https://images2.imgbox.com/e1/27/UQLFvnUU_o.png" width="809"></p> 
<p><strong>AT&amp;T格式与Inter格式对比图:</strong></p> 
<p><img alt="" height="768" src="https://images2.imgbox.com/55/70/U86rz6Mr_o.png" width="1200"></p> 
<p><strong>算术运算指令:</strong></p> 
<p><img alt="" height="673" src="https://images2.imgbox.com/87/9b/Icr1YU9s_o.png" width="1200"></p> 
<p><strong>逻辑运算指令:</strong></p> 
<p><img alt="" height="524" src="https://images2.imgbox.com/df/c9/gEXvA7uT_o.png" width="1200"></p> 
<p><strong>选择语句的机器级表示:</strong></p> 
<p><img alt="" height="541" src="https://images2.imgbox.com/ac/29/IHiLVx8C_o.png" width="1200"></p> 
<p><strong>循环语句的机器级表示:</strong></p> 
<p><img alt="" height="629" src="https://images2.imgbox.com/72/6c/a4c9dF7j_o.png" width="1200"></p> 
<p><strong>loop指令实现循环:</strong> </p> 
<p><img alt="" height="553" src="https://images2.imgbox.com/d4/b2/kWJBBjeu_o.png" width="1200"></p> 
<p><strong>函数调用的机器级表示:</strong></p> 
<p><img alt="" height="690" src="https://images2.imgbox.com/7b/33/p7a2BiEC_o.png" width="1200"></p> 
<p><strong>函数调用时:</strong></p> 
<p><img alt="" height="674" src="https://images2.imgbox.com/2e/4c/eKGHciNH_o.png" width="1200"></p> 
<p><strong>函数返回时:</strong></p> 
<p><img alt="" height="691" src="https://images2.imgbox.com/4a/57/GyoNNEjE_o.png" width="1200"></p> 
<p><strong>函数的传参与函数的局部变量:</strong></p> 
<p><img alt="" height="483" src="https://images2.imgbox.com/49/9a/C9EJ18ro_o.png" width="1200"></p> 
<p><strong>函数的返回值: </strong></p> 
<p><img alt="" height="661" src="https://images2.imgbox.com/7c/d0/nKu1SDCH_o.png" width="1183"></p> 
<p>   <strong>     push xxx :</strong> 先让esp减4, 在将xxx压入栈中</p> 
<p> <strong>       pop xxx: </strong>将栈顶元素出栈写入xxx中, 在让esp加4 </p> 
<h2 id="%E7%AC%AC%E4%B8%83%E7%AB%A0%C2%A0%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8" style="text-align:center;">第七章 中央处理器</h2> 
<h3 id="%E5%85%AD%E3%80%81%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E8%AE%BE%E8%AE%A1">7.1 指令周期</h3> 
<blockquote> 
 <p>        CPU从主存中每取出并执行一条指令所需的全部时间。 指令周期的不同阶段区分二进制数是指令还是数据。</p> 
</blockquote> 
<p><strong>        机器周期:</strong> 即CPU周期, 一个机器周期包含若干时钟周期, 一般为<strong>访存时间</strong></p> 
<p><strong>        时钟周期:</strong> 也称节拍, T周期, CPU时钟周期, CPU操作的基本单位</p> 
<p><strong>        存取周期: </strong>存储器进行连续两次独立的存储器操作所需最小间隔时间</p> 
<p><strong>各周期关系示意图:</strong></p> 
<p><img alt="" height="488" src="https://images2.imgbox.com/36/b1/JoqXpwHc_o.png" width="819"></p> 
<p><strong>不同指令的指令周期:</strong></p> 
<p><img alt="" height="618" src="https://images2.imgbox.com/74/92/Q14tjf3t_o.png" width="1200"></p> 
<p><strong> 指令流程图:</strong></p> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/07/de/3mlwgDf2_o.png" width="497"></p> 
<p><strong>取指周期数据流:</strong></p> 
<p><img alt="" height="615" src="https://images2.imgbox.com/d6/66/3x1BRVer_o.png" width="1142"></p> 
<p><strong>间址周期数据流:</strong></p> 
<p><img alt="" height="677" src="https://images2.imgbox.com/34/c7/eZOWUmeI_o.png" width="1040"></p> 
<p><strong>中断周期数据流:</strong></p> 
<p><img alt="" height="441" src="https://images2.imgbox.com/64/ad/PGJCrd44_o.png" width="821"></p> 
<p><strong>指令执行方案:</strong></p> 
<p><strong>        单指令周期: </strong>对所有指令选用相同的执行时间来完成, 指令之间串行执行</p> 
<p><strong>        多指令周期:</strong> 对不同类型指令选用不同个数的时钟周期, 指令之间串行执行</p> 
<p><strong>        流水线方案</strong></p> 
<h3 id="7.2%20CPU%E7%9A%84%E5%8A%9F%E8%83%BD%E5%8F%8A%E7%BB%93%E6%9E%84">7.2 CPU的功能及结构</h3> 
<p><strong>CPU功能:</strong></p> 
<p>        1) 指令控制</p> 
<p>        2) 操作控制</p> 
<p>        3) 时间控制</p> 
<p>        4) 数据加工</p> 
<p>        5) 中断处理</p> 
<p><strong>控制器的基本功能:</strong></p> 
<p>        1) 取指令</p> 
<p>        2) 分析指令</p> 
<p>        3) 执行指令</p> 
<p><strong>运算器:</strong></p> 
<p>        1) 算术逻辑单元</p> 
<p>        2) 暂存寄存器</p> 
<p>        3) 累加寄存器</p> 
<p>        4) 通用寄存器</p> 
<p>        5) 程序状态字寄存器</p> 
<p>        6) 移位器</p> 
<p>        7) 计数器</p> 
<p><strong>控制器:</strong></p> 
<p>        1) 程序计数器</p> 
<p>        2) 指令寄存器</p> 
<p>        3) 指令译码器</p> 
<p>        4) 存储器地址寄存器</p> 
<p>        5) 存储器数据寄存器</p> 
<p>        6) 时序系统</p> 
<p>        7) 微操作信号发生器</p> 
<p><strong>CPU基本结构图:</strong></p> 
<p><img alt="" height="624" src="https://images2.imgbox.com/bd/e9/gxlAWmRG_o.png" width="1200"></p> 
<h4 id="7.2.1%20%E9%80%9A%E8%B7%AF%E6%95%B0%E6%8D%AE"><strong>7.2.1 通路数据</strong></h4> 
<p><strong>        1) CPU内部单总线方式: </strong>ALU需要配合暂存器使用</p> 
<p><strong>示意图:</strong></p> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/85/21/rhrENMGS_o.png" width="263"></p> 
<p>       <strong> 2) CPU内部多总线方式: </strong>同时在多个总线上传送不同的数据</p> 
<p><strong>        3) 专用数据通路方式: </strong>性能较高, 但硬件量大</p> 
<p><strong>示意图:</strong></p> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/62/8f/pGhHoNE1_o.png" width="650"></p> 
<h4 id="7.2.2%20%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8">7.2.2 多处理器</h4> 
<p><strong>        单指令流单数据流(SISD)结构:</strong> 一个处理器和一个存储器, 一段时间内仅执行一条指令, 可采用指令流水线方式, 多模块交叉方式组织存储器</p> 
<p><strong>示意图:</strong></p> 
<p class="img-center"><img alt="" height="350" src="https://images2.imgbox.com/39/1f/Cg1hOnWi_o.png" width="566"></p> 
<p>     <strong>   单指令流多数据流(SIMD)结构: </strong>通常由一个指令控制部件, <span style="color:#fe2c24;"><strong>多个处理单元</strong></span>组成, 一个指令流同时对多个数据进行处理, 称为数据级并行技术, 使用for循环最有效, case或switch语句效率最低。向量处理器是SIMD的变体。</p> 
<p><strong>示意图:</strong></p> 
<p class="img-center"><img alt="" height="350" src="https://images2.imgbox.com/1e/20/1pQZW8SY_o.png" width="488"></p> 
<p><strong>向量处理器:</strong></p> 
<p><img alt="" height="409" src="https://images2.imgbox.com/3f/62/e2x5Mnin_o.png" width="993"></p> 
<p><strong>        多指令流单数据流(MISD)结构:</strong> 实际不存在</p> 
<p>      <strong>  多指令流多数据流(MIMD)结构: </strong>指同时执行多条指令分别处理多个不同数据, 分为多计算机系统和共享式存储多处理器(SMP)系统。</p> 
<p><strong>多计算机系统示意图:</strong></p> 
<p class="img-center"><img alt="" height="500" src="https://images2.imgbox.com/5d/d2/vePwTrLw_o.png" width="549"></p> 
<p><strong>多核处理器示意图:</strong></p> 
<p><img alt="" height="370" src="https://images2.imgbox.com/5d/d6/2ItguZh1_o.png" width="696"></p> 
<p><strong>硬件多线程的三种实现方式:</strong></p> 
<p><img alt="" height="433" src="https://images2.imgbox.com/05/1a/ZkCnX7DY_o.png" width="1200"></p> 
<p>        <strong>多核处理器: </strong>将多个处理单元集成到单个CPU, 每个处理单元称为一个核。属于共享内存的对称多处理器。</p> 
<p>      <strong>  共享内存多处理器(SMP):</strong> 多个处理器共享单一的地址空间。分为UMA和NUMA两种类型。</p> 
<p>      <strong>  统一存储访问UMA多处理器: </strong>处理器对所有存储单元的访问时间是大致相同的</p> 
<p>   <strong>     非统一存储访问NUMA多处理器: </strong>某些访存请求比其他的快</p> 
<h3 id="7.3%C2%A0%E6%8E%A7%E5%88%B6%E5%99%A8">7.3 控制器</h3> 
<h4 id="7.3.1%20%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8%20(%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1)">7.3.1 硬布线控制器 (组合逻辑设计)</h4> 
<p><strong>CU的输入信号来源图: </strong></p> 
<p><img alt="" height="521" src="https://images2.imgbox.com/a5/63/0ISJANr7_o.png" width="1165"></p> 
<p><strong>        备注:</strong> 控制单元还要接收来自系统总线(控制总线)的控制信号, 如中断请求, DMA请求</p> 
<p>        <strong>FE: </strong>取值周期 (标志触发器)</p> 
<p>       <strong> IND: </strong>间址周期</p> 
<p>      <strong>  EX:</strong> 执行周期</p> 
<p>        <strong>INT:</strong> 中断周期</p> 
<p><strong>硬布线控制单元设计步骤:</strong></p> 
<p>        1) 列出微操作命令的操作时间表</p> 
<p><strong>如取值周期示意图:</strong></p> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/11/fb/1o2bvjZm_o.png" width="629"></p> 
<p>        2) 进行微操作信号综合</p> 
<p><strong>如汇总M(MAR) --&gt; MDR 的操作时间表:</strong></p> 
<p><img alt="" height="606" src="https://images2.imgbox.com/4f/0c/jsvo3TnY_o.png" width="1200"></p> 
<p>        3) 画出微操作命令的逻辑图</p> 
<p><strong>如M(MAR) --&gt; MDR命令的逻辑图:</strong></p> 
<p><img alt="" height="664" src="https://images2.imgbox.com/96/d6/OqwVp5un_o.png" width="1200"></p> 
<h4 id="7.3.2%C2%A0%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8">7.3.2 微程序控制器</h4> 
<blockquote> 
 <p>        将一条<strong>机器指令</strong>编写成一个<strong>微程序</strong>, 每一个微程序包含若干条<strong>微指令</strong>, 每<strong>一条微指令</strong>对应一个或<strong>几个微操作命令</strong>。然后把这些微程序存到一个控制存储器中。</p> 
</blockquote> 
<p><strong>微指令格式:</strong></p> 
<p><strong>        水平型微指令: </strong>一条微指令能定义多个可并行的微命令; 微程序短, 执行速度快; 缺点是微指令长, 造成控存容量极大。</p> 
<p><strong>        垂直型微指令: </strong>一条微指令只能定义一个微命令; 微指令短, 简单, 规整, 便于编写微程序;  缺点是微程序长, 执行速度慢, 效率低。</p> 
<p><strong>        混合型微指令:</strong> 在垂直型的基础上增加一些不太复杂的并行操作。</p> 
<p><strong>微指令格式图:</strong></p> 
<p class="img-center"><img alt="" height="150" src="https://images2.imgbox.com/88/94/vCgI8pC7_o.png" width="517"></p> 
<p><strong>        微周期: </strong>执行一条微指令所需的时间, 通常为一个时钟周期</p> 
<p><strong>微程序控制单元的基本框图:</strong></p> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/8f/3c/qJKFcLMt_o.png" width="607"></p> 
<p><strong>        CMDR: </strong>微指令寄存器, 又称uIR, 存放微指令</p> 
<p><strong>        CMAR: </strong>微地址寄存器, 又称uPC, 存放微指令地址</p> 
<p>  <strong>      CM:</strong> 控制存储器</p> 
<p><strong>工作过程:</strong></p> 
<p>        1) 取指令: 取指微程序入口地址一般为CM的0号单元, 为公共操作, 机器开始运行时, 自动将取指微程序入口地址送入CMAR。</p> 
<p>        2) 译指: 由机器指令的操作码字段通过微地址形成部件产生该机器指令所对应的微程序入口地址, 并送入CMAR。</p> 
<p>        3) 从CM中逐条取出对应的微指令并执行</p> 
<p>        4) 执行完对应一条机器指令的一个微程序后, 回到取指微程序的入口地址, 重复 (1)。</p> 
<p id="6.3%C2%A0%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%9A%84%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><strong>微指令的编码方式:</strong></p> 
<p id="6.3.1%20%E7%9B%B4%E6%8E%A5%E7%BC%96%E7%A0%81"><strong>        1) 直接编码</strong>: 每一位代表一个微操作命令。</p> 
<p><strong>直接编码方式图:</strong></p> 
<p><img alt="" height="289" src="https://images2.imgbox.com/f9/d7/2pkyHL4U_o.png" width="984"></p> 
<p id="6.3.2%20%E5%AD%97%E6%AE%B5%E7%9B%B4%E6%8E%A5%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F"><strong>        2) 字段直接编码方式: </strong>将微指令的操作控制字段分成若干段, 将一组互斥的微操作命令存放在一个字段内(字段位数<span style="color:#fe2c24;"><strong>要考虑留出一个状态表示不操作</strong></span>)。执行速度稍微减慢。</p> 
<p><strong>字段直接编码图:</strong></p> 
<p><img alt="" height="427" src="https://images2.imgbox.com/4a/8a/xhgX6V6C_o.png" width="915"></p> 
<p id="6.3.3%20%E6%B7%B7%E5%90%88%E7%BC%96%E7%A0%81"><strong>        3) 字段间接编码</strong>: 又称隐式编码, 可进一步缩短微指令字长, 但削弱了微指令并行控制能力, 故通常作为字段直接编码方式的一种辅助手段。</p> 
<p><strong>示意图:</strong></p> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/d2/30/QKqFByAk_o.png" width="470"></p> 
<p id="6.4%C2%A0%E5%BE%AE%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BD%A2%E6%88%90"><strong>微指令序列地址的形成</strong></p> 
<p>        1) 直接由微指令的<strong>下地址字段</strong>指出</p> 
<p>        2) 根据机器指令的<strong>操作码</strong>形成</p> 
<p>        3) <strong>增量计数器</strong>: 即(CMAR) --&gt; CMAR</p> 
<p>        4) 根据各种<strong>标志</strong>决定微指令分支转移的地址</p> 
<p>        5) 由硬件产生<strong>微程序入口地址</strong>: 响应中断时</p> 
<p>        6) 通过测试网络</p> 
<p><strong>后续微指令地址形成方式的原理图:</strong></p> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/96/79/TikQgEU2_o.png" width="482"></p> 
<p>        <strong>断定法:  </strong>微指令格式中设置一个下地址字段, 由微指令下地址字段直接指出后继微指令地址。</p> 
<p><strong>微程序控制单元的设计步骤:</strong></p> 
<p><strong>        1) 写出对应机器指令的微操作命令及节拍安排</strong></p> 
<p><strong>如取指周期的微操作命令及节拍安排示意图:</strong></p> 
<p><img alt="" height="488" src="https://images2.imgbox.com/9a/45/3eaOTSdi_o.png" width="1200"></p> 
<p><strong>        2) 确定微指令格式:</strong> 确定微指令的<strong>编码方式</strong>, 以确定微指令的操作<strong>控制字段位数</strong>, 根据CM中存的<strong>微指令总数</strong>, 确定微指令的<strong>顺序控制字段的位数</strong>, 最后可确定微指令字长。</p> 
<p><strong>        3) 编写微指令码点: </strong>根据操作字段每一位代表的微操作命令, 编写每一条微指令的码点。</p> 
<h3 id="7.4%C2%A0%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF">7.4 指令流水线</h3> 
<blockquote> 
 <p>        类似与工厂的流水线。</p> 
</blockquote> 
<p><strong>指令的串行执行:</strong></p> 
<p><img alt="" height="151" src="https://images2.imgbox.com/7e/66/KiBpAtGI_o.png" width="1200"></p> 
<p><strong>指令的二级流水:</strong></p> 
<p><img alt="" height="275" src="https://images2.imgbox.com/a4/26/xqdH4eAc_o.png" width="1030"></p> 
<p><strong>指令的六级流水:</strong></p> 
<p><img alt="" height="618" src="https://images2.imgbox.com/73/21/zuN8AVxX_o.png" width="1200"></p> 
<p><strong>五段式指令流水线图:</strong></p> 
<p><img alt="" height="551" src="https://images2.imgbox.com/63/3a/RRfEuuS6_o.png" width="1075"></p> 
<h4 id="7.4.1%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><strong>7.4.1流水线性能指标</strong></h4> 
<p><strong>        1) 吞吐率:</strong> 指单位时间内流水线所完成的任务数量, 或是输出结果的数量。</p> 
<p><strong>理想的流水线时空图:</strong></p> 
<p><img alt="" height="683" src="https://images2.imgbox.com/9a/04/kaKlkJD8_o.png" width="1200"></p> 
<p><strong>        2) 加速比: </strong>同样的任务量, 不使用流水线与使用流水线所用的时间之比</p> 
<p><strong>理想状态下的流水线图: </strong></p> 
<p><img alt="" height="625" src="https://images2.imgbox.com/34/b7/zjI3BBxh_o.png" width="1200"></p> 
<p>        <strong> 3) 效率: </strong>流水线的设备利用率, 完成n个任务占用的时空区有效面积与总面积之比</p> 
<p><strong>示意图:</strong></p> 
<p><img alt="" height="358" src="https://images2.imgbox.com/b0/93/pP7WBusF_o.png" width="1016"></p> 
<h4 id="7.4.2%20%E5%BD%B1%E5%93%8D%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%80%A7%E8%83%BD%E7%9A%84%E5%9B%A0%E7%B4%A0">7.4.2 影响流水线性能的因素</h4> 
<p><strong>        1) 结构相关: </strong>不同指令争用同一功能部件产生资源冲突, 如访存冲突 (<strong>互斥</strong>)。</p> 
<p>       <strong> 解决方法: </strong></p> 
<p><strong>                </strong>1) 后一相关暂停一周期;</p> 
<p>                2) 资源重复配置</p> 
<p><strong>        2) 数据相关: </strong>读写先后顺序不同, 影响计算结果 (<strong>同步</strong>)。</p> 
<p>       <strong> 解决方法:</strong></p> 
<p>                1) 通过硬件阻塞(stall)或软件插入"NOP" 来延后冲突的相关指令的执行;</p> 
<p>                2) <strong>数据旁路技术: </strong>直接把前一条指令的ALU计算结果作为自己的输入数据</p> 
<p>                3) <strong>编译优化:</strong> 调整指令顺序</p> 
<p><strong>        3) 控制相关: </strong>由转移指令引起, 使流水线的连续流动被破坏 。</p> 
<p>        <strong>解决方法:</strong></p> 
<p>               <strong> 1) 静态预测:</strong> 总是预测条件不满足</p> 
<p>               <strong> 2) 动态预测: </strong>根据程序执行的历史情况, 进行动态预测调整, 准确率较高</p> 
<p>                3) 预取转移成功和不成功两个控制流方向的目标指令</p> 
<p>                4) 加快和提前形成条件码</p> 
<h4 id="7.4.3%C2%A0%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%B8%AD%E7%9A%84%E5%A4%9A%E5%8F%91%E6%8A%80%E6%9C%AF">7.4.3 流水线中的多发技术</h4> 
<p id="3.6.1%20%E8%B6%85%E6%A0%87%E9%87%8F%E6%8A%80%E6%9C%AF"><strong>        超标量技术</strong>: 指在每个时钟周期内可<strong>同时并发</strong>多条独立指令, 即以并行操作方式将两条或两条以上指令编译执行。<strong>需要配置多个功能部件</strong>。</p> 
<p><strong>超标量流水图:</strong></p> 
<p><img alt="" height="297" src="https://images2.imgbox.com/8e/f7/miQkhgHw_o.png" width="717"></p> 
<p id="3.6.2%20%E8%B6%85%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF"><strong>        超流水线技术: </strong> 将一些流水寄存器插入流水线段中, 好比流水线再分段。<strong>通过提高主频方式</strong></p> 
<p><strong>超流水线图:</strong></p> 
<p><img alt="" height="438" src="https://images2.imgbox.com/dc/2c/aHXV6nSq_o.png" width="998"></p> 
<p id="3.6.3%20%E8%B6%85%E9%95%BF%E6%8C%87%E4%BB%A4%E5%AD%97%E6%8A%80%E6%9C%AF"><strong>        超长指令字技术</strong>: 由编译程序挖掘指令间潜在的并行性, 将多条能并行操作的指令组成一条具有多个操作码字段的超长指令字。<strong>需要多个处理部件</strong></p> 
<p><strong>超长指令字图:</strong></p> 
<p><img alt="" height="290" src="https://images2.imgbox.com/9f/1d/pyI9ZvCV_o.png" width="692"></p> 
<h3 id="5.3%C2%A0%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F">7.5 控制方式</h3> 
<blockquote> 
 <p>        控制不同微操作序列所采用的时序控制方式称为<strong> CU</strong> 的控制方式。</p> 
</blockquote> 
<p id="5.3.1%20%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><strong>7.5.1 同步控制方式</strong></p> 
<blockquote> 
 <p><strong>         </strong>任何一条指令或微操作的执行都是事先确定的, 并且受统一基准时标的时序信号所控制的方式。</p> 
</blockquote> 
<p><strong>        1) 采用定长的机器周期:</strong> 一律以最长的微操作序列和最繁的微操作作为标准, 会造成时间上的浪费。</p> 
<p><strong>        2) 采用不定长的机器周期: </strong>把大多数微操作安排在一个较短的机器周期内完成, 对于复杂微操作, 采用延长机器周期或增加节拍的办法来解决 </p> 
<p><strong>延长机器周期示意图:</strong></p> 
<p><img alt="" height="309" src="https://images2.imgbox.com/6f/41/JICarqKx_o.png" width="1052"></p> 
<p><strong>        3) 采用中央控制和局部控制相结合的方法:</strong> 将机器的大部分指令安排在统一的, 较短的机器周期内完成, 称为中央控制, 将少数操作复杂的指令中的某些操作 (如: 乘除法和浮点运算) 采用局部控制方式来完成。</p> 
<p><strong>示意图:</strong></p> 
<p><img alt="" height="744" src="https://images2.imgbox.com/e8/d4/htPB9OQ5_o.png" width="1200"></p> 
<p id="5.3.2%20%E5%BC%82%E6%AD%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><strong>7.5.2 异步控制方式</strong></p> 
<blockquote> 
 <p>        不存在基准时标信号, 没有固定的周期节拍和严格的时钟同步, 由专门的应答线路控制, 即执行部件完成操作后发回 "回答" 信号,再开始新的微操作, 需要采用各种应答电路, 较同步控制方式复杂。</p> 
</blockquote> 
<p id="5.3.3%C2%A0%20%E8%81%94%E5%90%88%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><strong>7.5.3 联合控制方式</strong></p> 
<blockquote> 
 <p>        同步控制和异步控制相结合, 对各种不同指令的微操作实行大部分统一, 小部分区别对待的办法。</p> 
</blockquote> 
<p id="5.3.4%C2%A0%E4%BA%BA%E5%B7%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><strong>7.5.4 人工控制方式</strong></p> 
<blockquote> 
 <p>        为了调机和软件开发的需要, 在机器面板或内部设置一些开关或按键, 来达到人工控制的目的。</p> 
</blockquote> 
<p></p> 
<p><strong><span style="color:#fe2c24;">注: 以上部分图片来源王道计算机组成原理教材 </span></strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4fc630fd43d7171608872fc884907a04/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">kali liunx安装后的配置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d6494646d6a8afb1932051266b180ebd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">OpenCV介绍及安装</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>