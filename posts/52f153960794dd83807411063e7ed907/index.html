<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>PRISM基本知识 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="PRISM基本知识" />
<meta property="og:description" content="Prism框架是用于创建低耦合，易维护，易测试的应用的。最初由微软开发，后提交给开源社区由开源社区维护的开源项目。每个平台都有独立的版本。
Prism实现了一系列的设计模式，有助于编写well-structured和可维护的XAML应用程序，包括MVVM，依赖注入，命令，EventAggregator等。Prism的核心功能是方便的在不同平台共享代码。
1.Prism Key Concepts Modules. 模块是可以独立开发/测试/部署的功能包。
Module catalog. 在组合应用程序里(composite application)，模块可能需要在运行时加载。在Prism里，module catalog用于指定哪些模块需要被加载，以及按什么顺序加载。module catalog被ModuleManager和ModuleLoader组件使用。Prism允许使用不同的方式指定module catalog：代码，xaml，或者用配置文件指定。
Shell. shell是应用程序外壳，定义了应用程序的总体布局和结构，但它通常不知道确切的模块，它通常实现通用的服务和基础架构，具体的功能则是在具体的模块里面实现。shell还提供了顶层的窗口和视觉元素，然后它会嵌入由具体modules提供的不同的UI
View. 视图封装了应用程序的特定的功能或者功能区域，用于MVVM模式。MVVM将UI和显示逻辑&amp;数据分离，View用于封装UI，并定义用户交互行为，从而允许view独立于底层应用程序的功能进行更新和替换。view通过数据绑定与view model交互。
View models. 视图模型是封装应用的表现逻辑和状态的类，它是MVVM模式的一部分。View model封装了许多功能，为view中可以绑定的控件定义属性，命令和事件。
Models. 模型封装了应用程序的数据和业务逻辑，它是MVVM模式的一部分。model封装数据，相关的验证和业务规则，以确保数据的一致性和完整性。
Commands. 命令用于封装应用程序的功能，允许它们独立于应用程序的UI进行定义和测试。它们可以被定义成command objects或者view model中的command methods。(They can be defined as command objects or as command methods in the view model. ) Prism提供了DelegateCommand classs和CompositeCommand class，后者用于表示一起触发的命令集合。
Regions. 区域是应用程序UI(在shell上或者view内)上定义的逻辑占位符，用于显示view。Region允许对应用程序UI的布局进行更新，而不需要更改应用程序逻辑。许多通用控件都可以被用作region，运行view被自动的显示在它里面，比如ContentControl, ItemsControl, ListBox, TabControl. View可以自动的或者通过编程被显示在region里。Prism also provides support for implementing navigation with regions. Regions can be located by other components through the RegionManager component, which uses RegionAdapter and RegionBehavior components to coordinate the display of views within specific regions." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/52f153960794dd83807411063e7ed907/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-08-21T14:36:49+08:00" />
<meta property="article:modified_time" content="2017-08-21T14:36:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">PRISM基本知识</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><a href="http://prismlibrary.readthedocs.io/en/latest/" rel="nofollow">Prism</a>框架是用于创建低耦合，易维护，易测试的应用的。最初由微软开发，后提交给开源社区由开源社区维护的开源项目。每个平台都有独立的版本。</p> 
<p><a href="http://prismlibrary.readthedocs.io" rel="nofollow">Prism</a>实现了一系列的设计模式，有助于编写well-structured和可维护的XAML应用程序，包括MVVM，依赖注入，命令，EventAggregator等。Prism的核心功能是方便的在不同平台共享代码。</p> 
<h3 id="1prism-key-concepts">1.Prism Key Concepts</h3> 
<p><strong>Modules.</strong> 模块是可以独立开发/测试/部署的功能包。</p> 
<p><strong>Module catalog.</strong> 在组合应用程序里(composite application)，模块可能需要在运行时加载。在Prism里，module catalog用于指定哪些模块需要被加载，以及按什么顺序加载。module catalog被ModuleManager和ModuleLoader组件使用。Prism允许使用不同的方式指定module catalog：代码，xaml，或者用配置文件指定。</p> 
<p><strong>Shell.</strong> shell是应用程序外壳，定义了应用程序的总体布局和结构，但它通常不知道确切的模块，它通常实现通用的服务和基础架构，具体的功能则是在具体的模块里面实现。shell还提供了顶层的窗口和视觉元素，然后它会嵌入由具体modules提供的不同的UI</p> 
<p><strong>View.</strong> 视图封装了应用程序的特定的功能或者功能区域，用于MVVM模式。MVVM将UI和显示逻辑&amp;数据分离，View用于封装UI，并定义用户交互行为，从而允许view独立于底层应用程序的功能进行更新和替换。view通过数据绑定与view model交互。</p> 
<p><strong>View models.</strong> 视图模型是封装应用的表现逻辑和状态的类，它是MVVM模式的一部分。View model封装了许多功能，为view中可以绑定的控件定义属性，命令和事件。</p> 
<p><strong>Models.</strong> 模型封装了应用程序的数据和业务逻辑，它是MVVM模式的一部分。model封装数据，相关的验证和业务规则，以确保数据的一致性和完整性。</p> 
<p><strong>Commands.</strong> 命令用于封装应用程序的功能，允许它们独立于应用程序的UI进行定义和测试。它们可以被定义成command objects或者view model中的command methods。(They can be defined as command objects or as command methods in the view model. ) Prism提供了DelegateCommand classs和CompositeCommand class，后者用于表示一起触发的命令集合。</p> 
<p><strong>Regions.</strong> 区域是应用程序UI(在shell上或者view内)上定义的逻辑占位符，用于显示view。Region允许对应用程序UI的布局进行更新，而不需要更改应用程序逻辑。许多通用控件都可以被用作region，运行view被自动的显示在它里面，比如ContentControl, ItemsControl, ListBox, TabControl. View可以自动的或者通过编程被显示在region里。Prism also provides support for implementing navigation with regions. Regions can be located by other components through the RegionManager component, which uses RegionAdapter and RegionBehavior components to coordinate the display of views within specific regions.</p> 
<p><strong>Navigation.</strong> 导航是指应用程序把[用户与应用程序交互的结果]或者[应用程序内部状态的变化]同步到UI的过程。Prism提供了两种导航方式：基于状态的导航(state-based navigation)和视图切换导航(view-switching navigation).视图切换导航使用统一资源标识符（URI）为基础的导航机制与Prism region相结合，允许实现灵活的导航方案。</p> 
<p><strong>EventAggregator.</strong> 事件聚合。复合应用程序中的组件通常需要以松耦合的方式与应用程序中的其他组件和服务通信。为此，Prism提供了EventAggregator组件，它实现了一个pub-sub事件机制，从而允许组件发布事件和其它组件订阅这些事件不需要引用对方。EventAggregator通常用于运行定义于不同模块中的组件间的交互。</p> 
<p><strong>Dependency injection container.</strong> 依赖注入(DI)模式就是利用Prism允许管理组件间的依赖关系。依赖注入允许组件依赖关系在运行时执行，并支持可扩展性和可测性。Prism被设计成和Unity或MEF一起工作，或通过servicelocator和任何其他依赖注入容器一起工作。</p> 
<p><strong>Services.</strong> 服务是封装非UI相关功能的组件，如日志记录、异常管理和数据访问。服务可以由应用程序或在一个模块中定义。服务通常在依赖注入容器中注册，以便它们可以按需要定位或构建，并由依赖于它们的其他组件使用。</p> 
<p><strong>Controllers.</strong> 控制器是用来协调将要在应用程序UI的region中显示的view的构造和初始化的类。控制器封装决定哪个视图被显示的逻辑。该控制器将使用PRISM的视图切换导航机制，它提供了一种可扩展的基于URI的导航机制，用于协调区域内视图的构造和放置。程序控制器模式定义了一个抽象映射到这个责任(The Application Controller pattern defines an abstraction that maps to this responsibility.)。</p> 
<p><strong>Bootstrapper.</strong> 引导程序组件用于初始化Prism的各种组件和服务。它是用来初始化依赖注入容器来注册应用层组件和服务的。它也可以用来配置和初始化module catalog和shell’s view和view model or presenter。</p> 
<p><a href="http://prismlibrary.readthedocs.io/en/latest/Download-and-Setup-Prism/" rel="nofollow">Example</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/64f29be1fd2c7230f1f3786e82b92556/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">关于二维偏序的题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/47cd3263d34699b843ce0dc5a4e2dc5b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">动态运行时类型识别与显式转换</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>