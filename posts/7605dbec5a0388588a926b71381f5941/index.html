<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>shell脚本之工具 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="shell脚本之工具" />
<meta property="og:description" content="在学习了shell脚本的基本语法，命令，符号之后，接下来要看的就是shell脚本使用的所有工具了。
在shell脚本中，工具的使用简化了所要编写的代码。接下来就介绍几个shell下经常使用的工具。
1、sort
sort工具的常用语法就是将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，默认是升序。
sort工具常用的一些选项：
-r选项：将文件按降序排列；-u选项：它的作用很简单，就是在输出行中去除重复行；-n选项：以数值来排序；
-t选项：可以设定间隔符；-k选项：指定了间隔符之后，就可以用-k来指定列数进行排序；-f选项：会将小写字母都转换为大写字母来进行比较，亦即忽略大小写；-c选项：会检查文件是否已排好序，如果乱序，则输出第一个乱序的行的相关信息，最后返回1-C选项：会检查文件是否已排好序，如果乱序，不输出内容，仅返回1-b选项：会忽略每一行前面的所有空白部分，从第一个可见字符开始
2、uniq
uniq工具作用效果是为消除相邻的重复行，如果重复行不再相邻的位置，就不会消除，因此，uniq工具一般与sort工具联合使用。
uniq工具常用的一些选项：
-c选项: 显示输出中，在每行行首加上本行在文件中出现的次数。它可取代-u和-d选项。-d选项: 只显示重复行-u选项: 只显示文件中不重复的各行。 uniq工具的应用：求两个文件的交集、并集、补集。
3、paste
paste单词的字面意思是粘贴。该命令主要用来将多个文件的内容合并。paste工具按行将不同文件行信息放在一行。缺省情况下， paste连接时，用空格或tab键分隔新行中不同文本。
通常我们把一行称为一条文本记录，每一行有多少列由列分隔符决定；按照列分隔符可以将一行分为多个域；进行行列划分时，应该考虑两个因素：行分隔符和列分隔符；行分隔符一般有\n,列分隔符为空格，tab
paste工具的常用选项：
-d选项: 指定域分隔符; -s选项: 将每个文件合并成行而不是按行粘贴 - 确实是该命令的一个选项。对每一个（-），从标准输入中读一次数据。默认使用空格或者tab作域分隔符，该选项可以定制输出格式。 4、cut
cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。 如果不指定 File 参数，
cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。
-b选项 ：以字节为单位进行分割-c 选项：以字符为单位进行分割。 对于英文字符-c和-b差别不大，但对于汉字类的字符差别就出来了
。
用-c则会以字符为单位，输出正常；而-b只会以字节（8位二进制位）来计算，输出就是乱码。这里的字符，不是我们C当中的占有一个字节的字符！可以简单理解成，汉字是由多个字节组成的多字节字符！ -d 选项：自定义分隔符，默认为制表符。-f 选项：与-d一起使用，指定显示哪个区域。 5、xargs（***）
xargs命令是给其他命令传递参数的一个过滤器，也是组合多个命令的一个工具。它擅长将标准输入数据转换成命令行参数，xargs能够处理管道或者stdin并将其转换成特定命令的命令参数。xargs也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。xargs的默认命令是echo，空格是默认定界符。这意味着通过管道传递给xargs的输入将会包含换行和空白，不过通过xargs的处理，换行和空白将被空格取代。xargs是构建单行命令的重要组件之一。
xargs工具的使用：
默认是对文件进行格式化输出，将多行输入转成单行输出；-n选项:指定列数，并多行输出-d选项: 自定义一个域分隔符，将特定列打散，并指定格式输出 将格式化的字符串作为命令行参数传递给其他命令，组装完成批量任务。
xargs的一个选项-I，使用-I指定一个替换字符串{}，这个字符串在xargs扩展时会被替换掉，当-I与xargs结合使用，每一个参数命令都会被执行一次.
Ls / |xargs -I {} touch {}.log 创建ls下的所有文件并且以.log结尾
-print0 ：不再按照空格等字符作为文件名结束标志，而变成以NULL结尾。
-0：告诉xargs,给xargs传参的字符不以空格为结束标志
6、grep
grep工具的常用选项：
-V 显示不匹配的-r/R 递归方式搜索-q 安静模式匹配 -i 忽略大小写-n 显示匹配结果以及匹配结果的行号-o: 只输出文件中匹配到的部分 7、sed(*****)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/7605dbec5a0388588a926b71381f5941/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-07-12T16:10:02+08:00" />
<meta property="article:modified_time" content="2018-07-12T16:10:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">shell脚本之工具</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>        在学习了shell脚本的基本语法，命令，符号之后，接下来要看的就是shell脚本使用的所有工具了。</p> 
<p>        在shell脚本中，工具的使用简化了所要编写的代码。接下来就介绍几个shell下经常使用的工具。</p> 
<p><span style="font-size:16px;">   </span><span style="font-size:16px;"> <strong>1、sort</strong></span></p> 
<p>    sort工具的常用语法就是将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，默认是升序。</p> 
<p>    sort工具常用的一些选项：</p> 
<ul><li>-r选项：将文件按降序排列；</li><li>-u选项：它的作用很简单，就是在输出行中去除重复行；</li><li>-n选项：以数值来排序；</li><li><img src="https://images2.imgbox.com/84/cf/s5IRqN6E_o.png" alt=""></li><li><img src="https://images2.imgbox.com/54/fe/YClpUOGo_o.png" alt=""><br></li><li>-t选项：可以设定间隔符；</li><li>-k选项：指定了间隔符之后，就可以用-k来指定列数进行排序；</li><li><img src="https://images2.imgbox.com/78/4c/fNXmviDr_o.png" alt=""></li><li>-f选项：会将小写字母都转换为大写字母来进行比较，亦即忽略大小写；</li><li>-c选项：会检查文件是否已排好序，如果乱序，则输出第一个乱序的行的相关信息，最后返回1</li><li>-C选项：会检查文件是否已排好序，如果乱序，不输出内容，仅返回1</li><li>-b选项：会忽略每一行前面的所有空白部分，从第一个可见字符开始<br></li></ul> 
<p>  <img src="https://images2.imgbox.com/3d/78/8fp3PVis_o.png" alt=""></p> 
<p>   <span style="font-size:16px;"> <strong>2、uniq</strong></span></p> 
<p>    uniq工具作用效果是为消除相邻的重复行，如果重复行不再相邻的位置，就不会消除，因此，uniq工具一般与sort工具联合使用。</p> 
<p><img src="https://images2.imgbox.com/49/97/kUn2zpKK_o.png" alt=""><br></p> 
<p>    uniq工具常用的一些选项：</p> 
<ul><li>-c选项: 显示输出中，在每行行首加上本行在文件中出现的次数。它可取代-u和-d选项。</li><li>-d选项: 只显示重复行</li><li>-u选项: 只显示文件中不重复的各行。</li></ul> 
<p> <img src="https://images2.imgbox.com/58/22/l3Muy3yA_o.png" alt=""></p> 
<p>   <span style="color:#3366ff;">uniq工具的应用：求两个文件的交集、并集、补集。</span></p> 
<p><img src="https://images2.imgbox.com/e1/94/FaeS89D3_o.png" alt=""><br></p> 
<p><span style="font-size:16px;"> <strong>3、paste</strong></span></p> 
<p>      paste单词的字面意思是粘贴。该命令主要用来将多个文件的内容合并。<span style="color:#00cccc;">paste工具按行将不同文件行信息放在一行</span>。缺省情况下， paste连接时，用空格或tab键分隔新行中不同文本。</p> 
<p>      通常我们把<span style="color:#33cc00;">一行称为一条文本记录</span>，每一行有多少列由列分隔符决定；<span style="color:#33cc00;">按照列分隔符可以将一行分为多个域</span>；进行行列划分时，应该考虑两个因素：行分隔符和列分隔符；行分隔符一般有\n,列分隔符为空格，tab</p> 
<p>  <img src="https://images2.imgbox.com/b5/1d/ifYCBp1W_o.png" alt=""><br></p> 
<p>     paste工具的常用选项：</p> 
<ul><li>    -d选项: 指定域分隔符;</li><li>    -s选项: 将每个文件合并成行而不是按行粘贴</li></ul> 
<p>   <img src="https://images2.imgbox.com/91/3b/kkbwMT0E_o.png" alt=""></p> 
<p>   <img src="https://images2.imgbox.com/d4/4c/gGQVzEtN_o.png" alt=""><br></p>    - 确实是该命令的一个选项。对每一个（-），从标准输入中读一次数据。默认使用空格或者tab作域分隔符，该选项可以定制输出格式。 
<p><span style="font-size:16px;"> </span><span style="font-size:16px;"> <strong> 4、cut</strong></span></p> 
<p>     cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。 如果不指定 File 参数，<br>     cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。</p> 
<ul><li>-b选项 ：以字节为单位进行分割</li><li>-c 选项：以字符为单位进行分割。</li></ul> 
<p>     <img src="https://images2.imgbox.com/c5/0e/r8Ms642g_o.png" alt=""></p> 
<p>     对于英文字符-c和-b差别不大，但对于汉字类的字符差别就出来了</p> 
<p>      <img src="https://images2.imgbox.com/06/a0/7VCrG75e_o.png" alt="">。</p>     用-c则会以字符为单位，输出正常；而-b只会以字节（8位二进制位）来计算，输出就是乱码。这里的字符，不是我们C当中的占有一个字节的字符！可以简单理解成，汉字是由多个字节组成的多字节字符！ 
<br> 
<ul><li>-d 选项：自定义分隔符，默认为制表符。</li><li>-f 选项：与-d一起使用，指定显示哪个区域。</li></ul>     
<img src="https://images2.imgbox.com/38/e7/dV8V0Bb1_o.png" alt=""> 
<br> 
<p><strong><span style="font-size:16px;"> 5、<span style="color:rgb(255,0,0);">xargs（***）</span></span></strong></p> 
<p>      xargs命令是给其他命令传递参数的一个过滤器，也是组合多个命令的一个工具。它<span style="color:#ff0000;">擅长将标准输入数据转换成命令行参数，xargs能够处理管道或者stdin并将其转换成特定命令的命令参数</span>。<span style="color:#ff0000;">xargs也可以将单行或多行文本输入转换为其他格式</span>，例如多行变单行，单行变多行。xargs的默认命令是echo，空格是默认定界符。这意味着通过管道传递给xargs的输入将会包含换行和空白，不过通过xargs的处理，换行和空白将被空格取代。xargs是构建单行命令的重要组件之一。<br></p> 
<p>       xargs工具的使用：</p> 
<ul><li>默认是对文件进行格式化输出，将多行输入转成单行输出；</li><li>-n选项:指定列数，并多行输出</li><li>-d选项: 自定义一个域分隔符，将特定列打散，并指定格式输出</li></ul> 
<p>  <img src="https://images2.imgbox.com/96/1d/KQVpR2Em_o.png" alt=""></p> 
<p>     将格式化的字符串作为命令行参数传递给其他命令，组装完成批量任务。</p> 
<p><img src="https://images2.imgbox.com/b9/03/cwJW9dJz_o.png" alt=""><br></p> 
<p>      xargs的一个选项-I，使用-I指定一个替换字符串{}，这个字符串在xargs扩展时会被替换掉，当-I与xargs结合使用，每一个参数命令都会被执行一次.<br></p> 
<p>      <img src="https://images2.imgbox.com/44/b3/YU0usGDA_o.png" alt=""></p> 
<p>     Ls / |xargs -I {} touch {}.log   创建ls下的所有文件并且以.log结尾<br>    -print0 ：不再按照空格等字符作为文件名结束标志，而变成以NULL结尾。<br>    -0：告诉xargs,给xargs传参的字符不以空格为结束标志</p> 
<p align="justify">  <strong><span style="font-size:16px;"> 6、grep</span></strong></p> 
<p> grep工具的常用选项：</p> 
<ul><li>-V 显示不匹配的</li><li>-r/R  递归方式搜索</li><li>-q 安静模式匹配</li><li> -i  忽略大小写</li><li>-n 显示匹配结果以及匹配结果的行号</li><li>-o: 只输出文件中匹配到的部分</li></ul> 
<p align="justify"> <strong> <span style="font-size:16px;">7、<span style="color:rgb(255,0,0);">sed(*****)</span></span></strong></p> 
<p>       <span style="color:#00cccc;">sed是一种流编辑器，它是文本处理中功能很强大的工具</span>，能够完美的配合正则表达式使用，功能不同凡响。<span style="color:#00cccc;">处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space）</span>，<span style="color:#ff0000;">接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。</span></p> 
<p>       简单来说，<span style="color:#33cc00;">sed就是一个按行处理文件的文本编辑器。对每一行先进行正则匹配，再进行相应的处理，匹配失败就不用进行处理。</span></p>       sed默认按照Basic规范基本匹配！ 
<p>     （1）sed工具的命令格式</p> 
<ul><li>sed [options] 'command'  file(s)</li><li>sed [options]  -f  scriptfile  file(s)</li></ul> 
<p>     （2）基本使用</p> 
<ul><li>Sed   /pattern/p: 打印匹配pattern和不匹配的行  (/pattern/:正则表达式)</li><li>Sed  -n  /pattern/p: 打印匹配pattern的行 ,不显示未匹配的行</li></ul> 
<p align="justify">    <img src="https://images2.imgbox.com/d9/7a/Q6CXI32b_o.png" alt=""><br></p> 
<p align="justify">      在使用p命令需要注意,<span style="color:#00cccc;">sed是把待处理文件的内容连同处理结果一起输出到标准输出的,因此p命令表示除了把文件内容打印出来之外还额外打印一遍匹配pattern的行</span> ，要想只输出处理结果,应加上-n选项,这种用法相当于grep命令。</p> 
<ul><li>Sed   /pattern/d: 删除匹配pattern的行</li></ul> 
<p align="justify">    <img src="https://images2.imgbox.com/92/9e/UtQoELko_o.png" alt=""><br></p> 
<p align="justify">       <span style="color:#00cccc;">sed命令不会修改原文件,删除命令只表示某些行不打印输出,而不是从原文件中删去</span>。 如果要影响源文件，需要使用-i 选项。</p> 
<p align="justify">    <img src="https://images2.imgbox.com/fb/51/zx0iFsCG_o.png" alt=""><br></p> 
<ul><li> sed   /pattern/s/pattern1/pattern2/: 查找符合pattern的行,将该行第一个匹配pattern1的字符串替换为pattern2</li><li>sed   /pattern/s/pattern1/pattern2/g：查找符合pattern的行,将该行所有匹配pattern1的字符串替换为pattern2<br></li></ul>     
<img src="https://images2.imgbox.com/d8/12/RHRYILl5_o.png" alt=""> 
<p>       同样是替换，带g或者不带g有什么区别？<br></p> 
<p>    <img src="https://images2.imgbox.com/a7/ea/dYiVGfnB_o.png" alt=""><br></p> 
<p>    已匹配字符串标记&amp;，可以表示匹配pattern1之后的所有字符。子串匹配标记\1,\2...\n</p> 
<p>    \(..\) 用于匹配子串，对于匹配到的第一个子串就标记为\1，依此类推匹配到的第二个结果就是\2,我们通过对标签进行重组，从而完成数据逆置。</p> 
<ul><li>定址</li></ul>      定址用于决定对哪些行进行编辑。地址的形式可以是数字、正则表达式、或二者的结合。如果没有指定地址，sed将处理输入文件的所有行.     
<img src="https://images2.imgbox.com/36/d9/5n7ZGvZs_o.png" alt=""> 
<br> 
<p></p> 
<ul><li>    退出状态</li></ul> 
<p>    <img src="https://images2.imgbox.com/b0/fc/2lGd7nhI_o.png" alt=""><br></p> 
<p><span style="color:#00cccc;">      sed不像grep一样，不管是否找到指定的模式，它的退出状态都是0</span>。只有当命令存在语法错误时，sed的退出状态才不是0。<br></p> 
<p>  <span style="color:#00cccc;">    Sed 不能用if判断，而grep可以使用if判断退出码。</span></p> 
<p><span style="font-weight:700;"><span style="font-size:16px;">8、模式空间/保持空间</span></span></p> 
<p>         <span style="color:#00cccc;">sed在正常情况下，将处理的行读入模式空间（pattern space），脚本中的“sed-command（sed命令）”就一条接着一条进行处理，直到脚本执行完毕。然后该行被输出，模式（pattern space）被清空；接着，在重复执行刚才的动作，文件中的新的一行被读入，直到文件处理完毕。 一般情况下，数据的处理只使用模式空间（patternspace）</span>，按照如上的逻辑即可完成主要任务。但是某些时候，使用通过使用保持空间（hold space），还可以带来意想不到的效果。</p> 
<p><strong><span style="color:#33cc00;">模式空间</span></strong>：可以想成工程里面的流水线，数据直接在它上面进行处理。</p> 
<p><strong><span style="color:#33cc00;">保持空间</span></strong>：可以想象成仓库，我们在进行数据处理的时候，作为数据的暂存区域。（只能存储数据，而不能对数据进行处理和修改）</p> 
<p>正常情况下，如果不显示使用某些高级命令，保持空间不会使用到！</p> 
<p><span style="color:#ff0000;"><strong>sed高级命令</strong></span></p> 
<p></p> 
<ul><li>g: 将hold space中的内容拷贝到pattern space中，原来pattern space里的内容清除</li><li>G: 将hold space中的内容append到pattern space\n后</li><li>h: 将pattern space中的内容拷贝到hold space中，原来的hold space里的内容被清除</li><li>H：将pattern space中的内容append到hold space\n后</li><li>d: 删除pattern中的所有行，并读入下一新行到pattern中</li><li>D: 删除multiline pattern中的第一行，不读入下一行</li><li>x：交换保持空间和模式空间的内容</li><li>N：将下一行添加到pattern space中</li><li>n：读取下一行到pattern space</li></ul> 
<p>   测试用例：</p> 
<p>    1&gt;给每行结尾添加一行空行</p> 
<p>    2&gt;用sed模拟出tac的功能（倒序输出）</p> 
<p>   <img src="https://images2.imgbox.com/5b/24/mtg5NfCO_o.png" alt=""><br></p> 
<p>    3&gt;追加匹配行到文件尾</p> 
<p>    4&gt;行列转化</p> 
<p>   <img src="https://images2.imgbox.com/22/cd/Z49yk7TX_o.png" alt=""><br></p> 
<p>   5&gt;打印奇数行/偶数行<br></p> 
<p>   <img src="https://images2.imgbox.com/59/a3/gwG6JrYY_o.png" alt=""><br></p> 
<p>    6&gt;求1~100的求和</p> 
<p><img src="https://images2.imgbox.com/49/f4/QZLbhRci_o.png" alt=""><br></p> 
<p><strong><span style="font-size:16px;">9、<span style="color:#ff0000;">awk(*****)</span></span></strong></p> 
<p>      <span style="color:#00cccc;"> sed以行为单位处理文件,awk比sed强的地方在于不仅能以行为单位还能以列为单位处理文件</span>。<span style="color:#33cc00;">awk缺省的行分隔符是换行,缺省的列分隔符是连续的空格和Tab,但是行分隔符和列分隔符都可以自定义</span>,比如/etc/passwd文件的每一行有若干个字段,字段之间以:分隔,就可以重新定义awk的列分隔符为:并以列为单位处理这个文件。</p> 
<p>      行分隔符：记录分隔符<br>      列分隔符：域分隔符</p> 
<p>      awk实际上是一门很复杂的脚本语言,还有像C语言一样的分支和循环结构,但是基本用法和sed类似,awk命令行的基本形式为:</p> 
<p>    awk option 'script' file1 file2 ... awk option -f scriptfile file1 file2 ... </p> 
<p>       和sed一样,awk处理的文件既可以由标准输入重定向得到,也可以当命令行参数传入,编辑命令可以直接当命令行参数传入,也可以用-f参数指定一个脚本文件,编辑</p> 
<p>  命令的格式为:</p> 
<ul><li>/pattern/{actions}</li><li>condition{actions}</li></ul> 
<p>       和sed类似,pattern是正则表达式,actions是一系列操作。awk程序一行一行读出待处理文件,如果某一行与pattern匹配,或者满足condition条件,则执行相应的actions,如果一条awk命令只 有actions部分,则actions作用于待处理文件的每一行。</p> 
<p>         其实，awk有3个不同版本: awk、nawk和gawk，未作特别说明，一般指gawk，gawk 是 AWK 的 GNU 版本。</p> 
<p><strong>  awk定制输入输出分隔符</strong></p> 
<p>  awk默认按照空格作为分隔符，如果想定制分隔符，常用的方法是使用-F 选项  </p> 
<p>  echo "hello:world" | awk -F:  '{print $1}'  hello   以：为分隔符</p> 
<p>   -F 可以支持多种符号进行定制分隔符</p> 
<p>   测试用例：</p> 
<ul><li>awk '{print $0}' file    读取一条记录</li><li>awk '{print $1}' file     第一个域</li><li>awk '{print $2}' file     第二个域</li><li>awk '{print $NF}' file     最后一个域   $(NF-1)  倒数第二个域</li></ul> 
<p>   <strong>BEGIN&amp;END</strong></p> 
<p>       BEGIN和END,是awk中两个极具特色的表达式，可以用他们做文本处理之前的准备工作，之后的收尾工具，极具实用价值，</p> 
<p> 基本格式如下:</p> 
<ul><li>BEGIN{} /REG/{} END{}</li><li>BEGIN{} condition{} END{}</li></ul>      
<span style="color:#ff0000;">任何在BEGIN之后列出的操作（在{}内）将在awk开始扫描输入之前执行，而END之后列出的操作将在扫描完全部的输入之后执行。因此，通常使用BEGIN来显示变量和预置（初始化）变量，使用END来输出最终结果。</span>统计文本中，成绩及格的人数，这里awk中的变量，语法的使用要格外注意。全部类C！ 
<ul><li>echo "hello:world;hello#bit" | awk -F'[:;#]' '{print $1}'  hello</li><li>BEGIN &amp; END</li><li>BEGIN{} /REG/{} END{}</li><li>BEGIN{} condition{} END{}</li></ul>        
<span style="color:#ff0000;">BEGIN{} 里的内容是在所有的文本处理之前进行，END{}里面的内容是在所有的动作都完成之后才进行。两个都进行且只进行一次。</span> 
<ul><li>awk  ‘BEGIN{count=0;}$2&gt;=60{count++;}END{printf count}’ 统计合格人数</li></ul> 
<p><strong><span style="font-size:16px;">10、awk脚本</span></strong></p> 
<p>       awk出了上面的基本命令行的使用方式之外，还有awk脚本方式，不过基本写法与命令行相同，语法也是基本类C。</p>      通过awk脚本，统计产品的档次，85分以上，优。75～85，良。60～75，中。60分以下，差 
<p>     <img src="https://images2.imgbox.com/44/46/PXRdwhq2_o.png" alt=""><br></p> 
<p>  <strong> awk内置变量</strong><br></p> 
<p></p> 
<p></p> 
<ul><li>ARGC: 命令行参数个数</li><li>ENVIRON: 支持队列中系统环境变量的使用</li><li>FILENAME: awk浏览的文件名</li><li>FNR: 浏览文件的记录数</li><li><span style="color:#00cccc;">FS: 设置输入域分隔符，等价于命令行 -F选项</span></li><li><span style="color:#00cccc;">NF: 浏览记录的域的个数</span></li><li>NR: 已读的记录数</li><li><span style="color:#00cccc;">OFS: 输出域分隔符</span></li><li>ORS: 输出记录分隔符</li><li>RS: 控制记录分隔符</li></ul> 
<p></p> 
<p align="justify"><strong><span style="font-size:16px;">11、find</span></strong><br></p> 
<p>       find命令在目录结构中搜索文件，并执行指定的操作。<br></p> 
<p></p> 
<p>       find pathname -options [-print -exec -ok ...]  用于在文件树种查找文件，并作出相应的处理（可能访问磁盘）。</p> 
<p></p> 
<ul><li>pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。</li><li>-print： find命令将匹配的文件输出到标准输出。 其中print0 我们之前已经见过面了。</li><li>-exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为'command' {} \;，注意{}和\; 之间的空格。</li><li>-ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。</li></ul> 
<p>find工具的常见选项：</p> 
<p></p> 
<p></p> 
<ul><li><span style="background-color:rgb(255,255,255);"><span style="color:#00cccc;">-name: 按照文件名查找文件</span></span>。</li><li>-perm: 按照文件权限来查找文件。</li><li>-prune: 使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略。</li><li>-depth：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。</li><li>-user: 按照文件属主来查找文件。</li><li>-group: 按照文件所属的组来查找文件。</li><li>-nogroup: 查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在</li><li>-nouser: 查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在</li><li>-newer file1 ! -newer file2: 查找更改时间比文件file1新但比文件file2旧的文件</li><li>-type: 查找某一类型的文件，例如:<span style="color:#00cccc;">-b: 块设备文件。<br>                                                   -d: 目录。<br>                                                   -c: 字符设备文件。<br>                                                   -p: 管道文件。<br>                                                   -l: 符号链接文件。<br>                                                   -f: 普通文件。<br>                                                  -size n:[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计。</span></li></ul> 
<p>       Touch一个已经存在的文件，目录不会做修改，而touch一个新的文件，相当于更新了目录。</p> 
<ul><li>查看内存信息：cat /proc/meminfo</li><li>查看CPU信息：cat /proc/cpuinfo</li><li>查看硬盘挂载情况：df  -h </li></ul> 
<p><strong><span style="font-size:16px;">12、free</span></strong></p> 
<p>free 查看内存信息</p>-m 以MB为单位查看内存， -k以KB为单位 
<br> -/+ buffers/cache 中的used=mem:used-buffers-cached; 
<br>-/+ buffers/cache 中的free=mem:free+buffers+cached; 
<br>Swap分区：交换空间，一般为屋里空间大小的两倍，太大容易造成效率低下 
<br>读cach,写buffer 
<br>Buffers：缓冲区  
<br>Cached：将文件的属性cach起来 
<br>Wb 写入缓冲区 ，安全性不高 
<br> wt 写穿透 ，直接写入到硬盘。 
<br>Iostat -x   
<br>进程的d状态：表示硬盘的%util率为100% 
<br> 
<p><br></p> 
<p><br></p> 
<p><br></p> 
<p><br></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fd20486af90e47ae75e3852d8e1a7149/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java基础学习一java 基本规则</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e4d48f89283bd567083a9ddba496109f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">面试应答</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>