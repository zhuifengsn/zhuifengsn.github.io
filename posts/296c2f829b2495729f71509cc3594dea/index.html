<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C#中继承实现父类方法、重写、重载 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C#中继承实现父类方法、重写、重载" />
<meta property="og:description" content="C#中子类重写父类方法的几种情况，关键字：virtual、abstract、override、new。（此处不说abstract，以后补充）
virtual：不是必须被子类重写的方法，父类必须给出实现，子类可以重写（使用override，new，或无特殊标志的普通方法），也可以不重写该方法。
new：重写父类方法时，父类可以使用virtual，override，new之一声明，也可以是没有关键字的普通方法，运行时会根据引用类型选择调用父类还是子类方法，重写父类方法时，使用new关键字与使用没有关键字的普通方法的等效的，但是后者会给出编译警告。
继承： 继承是派生类（子类）去实现（重写&lt;override&gt;、重构&lt;new&gt;）基类（父类）的方法或属性。从而获取在派生类中要实现的功能。
子类调用父类构造方法，在父类中有个实现姓名和年龄的构造方法但是子类中也要实现这样的功能时，子类不用再次去写这个功能，只要去调用父类的功能即可。
#region public class Person { private string _name ; private int _age ; public Person(string name, int age)//父类的构造方法 { this._name = name;//获得参数的值 this._age = age; Console.WriteLine(&#34;您的姓名是{0},您的年龄是{1}.&#34;,this._name, this._age); } } public class Studnet : Person { private int _id; public Studnet(string name, int age, int IDCard):base(name, age)//子类构造方法继承父类构造方 //把接受到的name、age两个参数交给父类的构造方法去处理 { this._id = IDCard; Console.WriteLine(&#34;您的身份证号码为{0}&#34;, this._id); } } class Program { static void Main(string[] args)//主函数 { Studnet stu = new Studnet(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/296c2f829b2495729f71509cc3594dea/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-05-07T19:28:55+08:00" />
<meta property="article:modified_time" content="2017-05-07T19:28:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C#中继承实现父类方法、重写、重载</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:rgb(47,47,47); font-family:微软雅黑,宋体,黑体,Arial,Helvetica,sans-serif; font-size:16px; line-height:24px"> </span><span style="font-size:14px"><span style="color:rgb(47,47,47); font-family:微软雅黑,宋体,黑体,Arial,Helvetica,sans-serif; line-height:24px"></span><span style="color:rgb(47,47,47); font-family:微软雅黑,宋体,黑体,Arial,Helvetica,sans-serif; line-height:24px">C#中子类重写父类方法的几种情况，关键字：virtual、abstract、override、new。（此处不说abstract，以后补充）</span></span></p> 
<p><span style="color:rgb(47,47,47); font-family:微软雅黑,宋体,黑体,Arial,Helvetica,sans-serif; line-height:24px"><span style="font-size:14px">  virtual：不是必须被子类重写的方法，父类必须给出实现，子类可以重写（使用override，new，或无特殊标志的普通方法），也可以不重写该方法。</span></span></p> 
<p><span style="font-family:微软雅黑,宋体,黑体,Arial,Helvetica,sans-serif; font-size:14px; color:#2f2f2f"><span style="line-height:24px">  new：重写父类方法时，父类可以使用virtual，override，new之一声明，也可以是没有关键字的普通方法，运行时会根据引用类型选择调用父类还是子类方法，重写父类方法时，使用new关键字与使用没有关键字的普通方法的等效的，但是后者会给出编译警告。</span></span></p> 
<p><span style="font-family:微软雅黑,宋体,黑体,Arial,Helvetica,sans-serif; color:#2f2f2f"><span style="font-size:16px; line-height:24px"><br> </span></span></p> 
<h2><span style="font-family:微软雅黑,宋体,黑体,Arial,Helvetica,sans-serif; font-size:24px; color:#2f2f2f"><span style="line-height:24px"><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti">继承：</span></span></span></h2> 
<p><span style="font-weight:normal"><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti"><span style="font-size:24px">  </span><span style="font-size:14px">继承是派生类（</span></span><span style="font-size:14px; word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti">子类</span><span style="font-size:14px; word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti">）去实现（重写&lt;override&gt;、重构&lt;new&gt;）基类（</span><span style="font-size:14px; word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti">父类</span><span style="font-size:14px; word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti">）的方法或属性。从而获取在派生类中要实现的功能。</span></span></p> 
<p><span style="font-size:14px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti; line-height:25px">   子类调用父类构造方法，在父类中有个实现姓名和年龄的构造方法但是子类中也要实现这样的功能时，子类不用再次去写这个功能，只要去调用父类的功能即可。</span></p> 
<p><span style="font-family:微软雅黑,宋体,黑体,Arial,Helvetica,sans-serif; color:rgb(47,47,47)"><span style="line-height:24px"><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti"><span style="color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti; line-height:25px"></span></span></span></span></p> 
<pre><code class="language-csharp">#region 
    public class Person
    {
        private string _name ;
        private int _age ;
        public Person(string name, int age)//父类的构造方法 
        {
            this._name = name;//获得参数的值 
            this._age = age;
            Console.WriteLine("您的姓名是{0},您的年龄是{1}.",this._name, this._age);
        }

    }
    public class Studnet : Person
    {
        private int _id;
        public Studnet(string name, int age, int IDCard):base(name, age)//子类构造方法继承父类构造方 
                                                                 //把接受到的name、age两个参数交给父类的构造方法去处理 
        {
            this._id = IDCard;
            Console.WriteLine("您的身份证号码为{0}", this._id);
        }
    }


    class Program
    {
        static void Main(string[] args)//主函数 
        {
            Studnet stu = new Studnet("小王", 18, 340406);
            Console.ReadLine();
        }
    } 
    #endregion </code></pre> 
<span style="font-size:14px"><strong>  实现结果：</strong></span> 
<p></p> 
<p><span style="font-family:微软雅黑,宋体,黑体,Arial,Helvetica,sans-serif; color:#2f2f2f"><span style="line-height:24px"><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti"><span style="color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti; line-height:25px"><strong><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti"><span style="font-size:14px">  您的姓名是 小王,您的年龄是 18. <wbr></wbr><br>   您的身份证号码为 340406</span></span><span style="font-size:14px; word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti"> </span></strong></span></span></span></span></p> 
<p><span style="font-family:微软雅黑,宋体,黑体,Arial,Helvetica,sans-serif; color:#2f2f2f"><span style="line-height:24px"><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti"><span style="color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti; line-height:25px"><span style="color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti; line-height:25px"><span style="font-size:14px">  子类调用父类方法时，先执行父类的方法，再去执行子类的方法。</span></span><br> </span></span></span></span></p> 
<p><br> </p> 
<h2><span style="font-size:24px">重写：</span></h2> 
<p><span style="font-size:14px">  重写只是对方法里面的功能重新做了编写，并没有对方法的参数进行添加，改变，删除。重写是面向对象的概念</span></p> 
<p><span style="font-size:14px">  举例：重写Show方法</span></p> 
<p></p> 
<pre><code class="language-csharp">     public class Person 
     {
        public virtual void Show(string name, string school, string Class) 
         { 
             Console.WriteLine("我在{0}学习",Class); 
             Console.WriteLine("我叫{0}.我毕业与{1}",name,school); 
         } 
     } 

     public class Studnet : Person 
     {
         public override void Show(string name, string school, string Class) //重写了父类的ShowME方法 
         { 
             Console.WriteLine("姓名{0},毕业学校{1},曾读班级{2}",name,school,Class); 
         } 
     } 


    class Program 
     { 
         static void Main(string[] args)//主函数 
         {
             Studnet stu = new Studnet(); 
             stu.Show("小王","家里蹲大学","泡妹(1)班"); 
             Console.ReadLine(); 
         } 
     } 
    #endregion </code></pre> 
<strong><span style="font-size:14px">  实现结果：</span></strong> 
<p></p> 
<p><strong><span style="font-size:14px">  姓名小王，毕业学校家里蹲大学曾读班级lol最强王者班        <span style="color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti; line-height:25px">（没有运行父类中方法）</span></span></strong></p> 
<p><span style="font-family:微软雅黑,宋体,黑体,Arial,Helvetica,sans-serif; color:#2f2f2f"><span style="line-height:24px"><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti"><span style="color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti; line-height:25px"><span style="font-size:14px"><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti">  重写的父类方法时，必须指明被重写的方法是虚方法（<strong>virtual</strong></span><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti">关键字）。在子类重写父类方法时必须有重写关键字（</span><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti"><strong>override</strong></span><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti">）这样才能重写父类的方法</span></span><br> </span></span></span></span></p> 
<p><span style="font-family:微软雅黑,宋体,黑体,Arial,Helvetica,sans-serif; color:#2f2f2f"><span style="font-size:16px; line-height:24px"><span style="word-wrap:normal; word-break:normal; line-height:25px; font-size:14px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti"><span style="color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti; font-size:14px; line-height:25px"><span style="word-wrap:normal; word-break:normal; line-height:25px; font-size:14px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti"><br> </span></span></span></span></span></p> 
<h2><span style="font-family:微软雅黑,宋体,黑体,Arial,Helvetica,sans-serif; font-size:24px; color:#2f2f2f"><span style="line-height:24px"><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti"><span style="color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti; line-height:25px"><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti"><span style="color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti; line-height:25px">重载：</span></span></span></span></span></span></h2> 
<p><span style="font-family:微软雅黑,宋体,黑体,Arial,Helvetica,sans-serif; font-size:14px; color:#2f2f2f"><span style="line-height:24px"><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti"><span style="color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti; line-height:25px"><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti"><span style="color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti; line-height:25px"><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti">  重载除了方法名不能被改变为另外什么都能重新定义（方法作用域、返回类型、方法体、方法参数）</span><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti"> （当然也可以只改变部分内容比如只改变方法体，不改变参数）重载是面向过程的概念</span></span><br> </span></span></span></span></span></p> 
<p><span style="font-family:微软雅黑,宋体,黑体,Arial,Helvetica,sans-serif; font-size:14px; color:#2f2f2f"><span style="line-height:24px"><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti"><span style="color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti; line-height:25px"><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti">  重载Show方法</span></span></span></span></span></p> 
<p><span style="font-family:微软雅黑,宋体,黑体,Arial,Helvetica,sans-serif; font-size:14px; color:#2f2f2f"><span style="line-height:24px"><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti"><span style="color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti; line-height:25px"><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti">  测试1：</span></span></span></span></span></p> 
<p><span style="font-family:微软雅黑,宋体,黑体,Arial,Helvetica,sans-serif; color:#2f2f2f"><span style="line-height:24px"><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti"><span style="color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti; line-height:25px"><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti"></span></span></span></span></span></p> 
<pre><code class="language-csharp">#region 重载Show方法
    public class Person
    {
        public void Show()
        {            
            Console.WriteLine("我是父类的方法");
        }
    }

    public class Studnet : Person
    {        
        public new void Show( )//此处不写new会出现编译提示，但是不算出错。
        {
            Console.WriteLine("我是子类的方法");
        }
    }

    class Program
    {
        static void Main(string[] args)//主函数 
        {
            Studnet stu = new Studnet();
            stu.Show();
            Console.ReadLine();
        }
    } 
    #endregion </code></pre> 
<span style="color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti; line-height:25px"><strong><span style="font-size:18px">  实现结果：</span></strong></span> 
<p></p> 
<p><span style="font-family:微软雅黑,宋体,黑体,Arial,Helvetica,sans-serif; font-size:18px; color:#2f2f2f"><span style="line-height:24px"><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti"><span style="color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti; line-height:25px"><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti"><strong>  我是子类方法       （没有运行父类中方法）</strong></span></span></span></span></span></p> 
<p><span style="font-family:微软雅黑,宋体,黑体,Arial,Helvetica,sans-serif; font-size:14px; color:#2f2f2f"><span style="line-height:24px"><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti"><span style="color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti; line-height:25px"><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti">  测试2：</span></span></span></span></span></p> 
<p><span style="font-family:微软雅黑,宋体,黑体,Arial,Helvetica,sans-serif; color:#2f2f2f"><span style="line-height:24px"><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti"><span style="color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti; line-height:25px"><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti"></span></span></span></span></span></p> 
<pre><code class="language-csharp">#region 重载Show方法
    public class Person
    {
        public void Show(string name, string school, string Class)
        {
            Console.WriteLine("我在{0}学习", Class);
            Console.WriteLine("我叫{0}.我毕业与{1}", name, school);
        }        
    }

    public class Studnet : Person
    {
        public new void Show(string name)//这个子类重写父类方法，除了方法名没变其他都变了，再使用new会有编译提示，但不算出错，可以不写new了
        {
            Console.WriteLine("姓名{0}", name);
        }        
    }

    class Program
    {
        static void Main(string[] args)//主函数 
        {      
            Studnet stu = new Studnet();
            stu.Show("小王");
            Console.ReadLine();
        }
    } 
    #endregion </code></pre> 
<strong><span style="font-size:14px">  实现结果：</span></strong> 
<p></p> 
<p><span style="font-family:微软雅黑,宋体,黑体,Arial,Helvetica,sans-serif; color:#2f2f2f"><span style="line-height:24px"><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti"><span style="color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti; line-height:25px"><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti"><strong><span style="font-size:14px">  姓名小王  </span></strong><br> <br> <span style="font-size:14px"><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti">  子类重载父类方法，子类必须指定重载的关键字（<strong>new</strong>），而父类被重载的方法则可以不用关键字（<strong>virtual</strong>）。重载一个方法，是对一个方法重新进行了编写从方法的参数到方法体，唯独方法的名称没有进行改变。重载也可以对原来没有返回类型的方法（void），改变为有返回类型的方法。总体来讲，重载除了方法名不能被改变，另外什么都能重新定义（方法作用域、返回类型、方法体、方法参数）</span><span style="word-wrap:normal; word-break:normal; line-height:25px; color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti"> <wbr></wbr></span><br style="color:rgb(69,69,69); font-family:'Microsoft Yahei',微软雅黑,Tahoma,Arial,Helvetica,sTHeiti; line-height:25px"> </span><br> </span></span></span></span></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/72762510584e171e4256503145a36723/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Docker常用命令原理图</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ce2bec4ecc170764d23de5c09c0be7cc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mysql主从同步分库分表同步</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>