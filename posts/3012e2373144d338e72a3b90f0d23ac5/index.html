<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringBoot项目jar、war包启动解析 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringBoot项目jar、war包启动解析" />
<meta property="og:description" content="一、jar包和war包的区别 1.1 war包 war包是Java Web应用程序的一种打包方式符合Servlet标准，它是Web Archive的缩写，主要用于存储Web应用程序相关的文件，包括Java类文件、JSP、HTML、CSS、JavaScript、图片等资源文件。war包需要部署到web服务器中（Tomcat、Apache、IIS） 1.2 jar包 jar包是类的归档文件，主要用于存储Java类文件和相关资源文件。它通常被用于封装Java应用程序或Java类库，方便程序的部署和发布jar包可以被JVM直接加载和运行。 1.3 主要区别： jar包主要用于存储Java类文件和相关资源文件，而war包主要用于存储Web应用程序相关的文件。jar包可以被JVM直接加载和运行，而war包需要被Web服务器加载和运行。jar包通常用于封装Java应用程序或Java类库，而war包用于封装Java Web应用程序。 二、SpringBoot使用war包启动 war包启动：需要先启动外部的Web服务器，实现Servlet3.0规范中引导应用启动类，然后将war包放入Web服务器下，Web服务器通过回调引导应用启动类方法启动应用。
2.1 Servlet3.0规范中引导应用启动的说明 在Servlet容器（Tomcat、Jetty等）启动应用时，会扫描应用jar包中 ServletContainerInitializer 的实现类。框架必须在jar包的 META-INF/services 的文件夹中提供一个名为 javax.servlet.ServletContainerInitializer 的文件，文件内容要写明 ServletContainerInitializer 的实现类的全限定名。这个 ServletContainerInitializer 是一个接口，实现它的类必须实现一个方法：onStartUp可以在这个 ServletContainerInitializer 的实现类上标注 @HandlesTypes 注解，在应用启动的时候自行加载一些附加的类，这些类会以字节码的集合形式传入 onStartup 方法的第一个参数中。 public interface ServletContainerInitializer { void onStartup(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx) throws ServletException; } 复制代码 2.2 SpringBootServletInitializer的作用和原理 Spirng中SpringServletContainerInitializer实现了Servlet的规范
@HandlesTypes(WebApplicationInitializer.class) public class SpringServletContainerInitializer implements ServletContainerInitializer { @Override public void onStartup(Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext) throws ServletException { // SpringServletContainerInitializer会加载所有的WebApplicationInitializer类型的普通实现类 List&lt;WebApplicationInitializer&gt; initializers = new LinkedList&lt;WebApplicationInitializer&gt;(); if (webAppInitializerClasses !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/3012e2373144d338e72a3b90f0d23ac5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-18T15:16:11+08:00" />
<meta property="article:modified_time" content="2023-04-18T15:16:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringBoot项目jar、war包启动解析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、jar包和war包的区别</h2> 
<h3>1.1 war包</h3> 
<ol><li>war包是Java Web应用程序的一种打包方式符合Servlet标准，它是Web Archive的缩写，主要用于存储Web应用程序相关的文件，包括Java类文件、JSP、HTML、CSS、JavaScript、图片等资源文件。</li><li>war包需要部署到web服务器中（Tomcat、Apache、IIS）</li></ol> 
<h3>1.2 jar包</h3> 
<ol><li>jar包是<code>类的归档文件</code>，主要用于存储Java类文件和相关资源文件。它通常被用于封装Java应用程序或Java类库，方便程序的部署和发布</li><li>jar包可以被JVM直接加载和运行。</li></ol> 
<h3>1.3 主要区别：</h3> 
<ol><li>jar包主要用于存储Java类文件和相关资源文件，而war包主要用于存储Web应用程序相关的文件。</li><li>jar包可以被JVM直接加载和运行，而war包需要被Web服务器加载和运行。</li><li>jar包通常用于封装Java应用程序或Java类库，而war包用于封装Java Web应用程序。</li></ol> 
<h2>二、SpringBoot使用war包启动</h2> 
<p>war包启动：需要先启动外部的<code>Web服务器</code>，实现<code>Servlet3.0规范</code>中引导<code>应用启动类</code>，然后将war包放入Web服务器下，Web服务器通过回调引导应用启动类方法启动应用。</p> 
<h3>2.1 Servlet3.0规范中引导应用启动的说明</h3> 
<ul><li>在Servlet容器（Tomcat、Jetty等）启动应用时，会扫描应用jar包中 <code>ServletContainerInitializer</code> 的实现类。</li><li>框架必须在jar包的 <code>META-INF/services</code> 的文件夹中提供一个名为 <code>javax.servlet.ServletContainerInitializer</code> 的文件，文件内容要写明 <code>ServletContainerInitializer</code> 的实现类的全限定名。</li><li>这个 <code>ServletContainerInitializer</code> 是一个接口，实现它的类必须实现一个方法：<code>onStartUp</code></li><li>可以在这个 <code>ServletContainerInitializer</code> 的实现类上标注 <code>@HandlesTypes</code> 注解，在应用启动的时候自行加载一些附加的类，这些类会以字节码的集合形式传入 <code>onStartup</code> 方法的第一个参数中。</li></ul> 
<pre><code>public interface ServletContainerInitializer {
    void onStartup(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx) throws ServletException;
}
复制代码</code></pre> 
<h3>2.2 SpringBootServletInitializer的作用和原理</h3> 
<p>Spirng中SpringServletContainerInitializer实现了Servlet的规范</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a2/ac/XI5GyKjQ_o.png"></p> 
<pre><code>@HandlesTypes(WebApplicationInitializer.class)
public class SpringServletContainerInitializer implements ServletContainerInitializer {
    @Override
    public void onStartup(Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)
            throws ServletException {
        // SpringServletContainerInitializer会加载所有的WebApplicationInitializer类型的普通实现类

        List&lt;WebApplicationInitializer&gt; initializers = new LinkedList&lt;WebApplicationInitializer&gt;();

        if (webAppInitializerClasses != null) {
            for (Class&lt;?&gt; waiClass : webAppInitializerClasses) {
                // 如果不是接口，不是抽象类
                if (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp;
                        WebApplicationInitializer.class.isAssignableFrom(waiClass)) {
                    try {
                        // 创建该类的实例
                        initializers.add((WebApplicationInitializer) waiClass.newInstance());
                    }
                    catch (Throwable ex) {
                        throw new ServletException("Failed to instantiate WebApplicationInitializer class", ex);
                    }
                }
            }
        }

        if (initializers.isEmpty()) {
            servletContext.log("No Spring WebApplicationInitializer types detected on classpath");
            return;
        }

        servletContext.log(initializers.size() + " Spring WebApplicationInitializers detected on classpath");
        AnnotationAwareOrderComparator.sort(initializers);
        // 启动Web应用onStartup方法
        for (WebApplicationInitializer initializer : initializers) {
            initializer.onStartup(servletContext);
        }
    }
}
复制代码</code></pre> 
<p><code>@HandlesTypes</code>使用<code>BCEL</code>的<code>ClassParser</code>在<code>字节码</code>层面读取了/WEB-INF/classes和jar中class文件的超类名和实现的接口名，判断是否与记录的注解类名相同，若相同再通过<code>org.apache.catalina.util.Introspection</code>类加载为Class对象保存起来,最后传入onStartup方法参数中</p> 
<p>SpringServletContainerInitializer类上标注了<code>@HandlesTypes(WebApplicationInitializer.class)</code>，所以会导入<code>WebApplicationInitializer</code>实现类</p> 
<p>SpringBoot中<code>SpringBootServletInitializer</code>是<code>WebApplicationInitializer</code>的抽象类,实现了<code>onStartup</code>方法</p> 
<pre><code>@Override
public void onStartup(ServletContext servletContext) throws ServletException {
    // Logger initialization is deferred in case an ordered
    // LogServletContextInitializer is being used
    this.logger = LogFactory.getLog(getClass());
    // 创建 父IOC容器
    WebApplicationContext rootAppContext = createRootApplicationContext(servletContext);
    if (rootAppContext != null) {
        servletContext.addListener(new ContextLoaderListener(rootAppContext) {
            @Override
            public void contextInitialized(ServletContextEvent event) {
                // no-op because the application context is already initialized
            }
        });
    }
    else {
        this.logger.debug("No ContextLoaderListener registered, as " + "createRootApplicationContext() did not "
                + "return an application context");
    }
}
复制代码</code></pre> 
<p>创建父容器</p> 
<pre><code>protected WebApplicationContext createRootApplicationContext(ServletContext servletContext) {
    // 使用Builder机制，前面也介绍过
    SpringApplicationBuilder builder = createSpringApplicationBuilder();
    builder.main(getClass());
    ApplicationContext parent = getExistingRootWebApplicationContext(servletContext);
    if (parent != null) {
        this.logger.info("Root context already created (using as parent).");
        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null);
        builder.initializers(new ParentContextApplicationContextInitializer(parent));
    }
    // 设置Initializer
    builder.initializers(new ServletContextApplicationContextInitializer(servletContext));
    // 在这里设置了容器启动类：AnnotationConfigServletWebServerApplicationContext
    builder.contextClass(AnnotationConfigServletWebServerApplicationContext.class);
    // 【引导】多态进入子类（自己定义）的方法中
    builder = configure(builder);
    builder.listeners(new WebEnvironmentPropertySourceInitializer(servletContext));
    // builder.build()，创建SpringApplication
    SpringApplication application = builder.build();
    if (application.getAllSources().isEmpty()
            &amp;&amp; AnnotationUtils.findAnnotation(getClass(), Configuration.class) != null) {
        application.addPrimarySources(Collections.singleton(getClass()));
    }
    Assert.state(!application.getAllSources().isEmpty(),
            "No SpringApplication sources have been defined. Either override the "
                    + "configure method or add an @Configuration annotation");
    // Ensure error pages are registered
    if (this.registerErrorPageFilter) {
        application.addPrimarySources(Collections.singleton(ErrorPageFilterConfiguration.class));
    }
    // 启动SpringBoot应用
    return run(application);
}
复制代码</code></pre> 
<p>所以我们只需要<code>自定义类</code>继承<code>SpringBootServletInitializer</code>并实现<code>configure</code>方法告诉<code>启动类</code>所在的位置就可以实现SpringBoot自启动了</p> 
<p><strong>例如：</strong></p> 
<pre><code>public class MyInitializer extends SpringBootServletInitializer {
 
   @Override
   protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
      //MySpringBootApplication为SpingBoot启动类
      return application.sources(MySpringBootApplication.class);
   }
}
复制代码</code></pre> 
<h2>三、SpringBoot使用jar包启动</h2> 
<p>按照java官方文档规定，java -jar命令引导的具体启动类必须配置在MANIFEST.MF中的Main-class属性中，该值代表应用程序执行入口类也就是包含main方法的类。</p> 
<p>从MANIFEST.MF文件内容可以看到，Main-Class这个属性定义了org.springframework.boot.loader.JarLauncher，<code>JarLauncher</code>就是对应Jar文件的<code>启动器</code>。而我们项目的启动类<code>SpringBootDemoApplication</code>定义在Start-Class属性中，</p> 
<p>JarLauncher会将BOOT-INF/classes下的类文件和BOOT-INF/lib下依赖的jar加入到classpath下，然后调用META-INF/MANIFEST.MF文件Start-Class属性完成应用程序的启动。</p> 
<blockquote> 
 <p>关于 jar <strong>官方标准</strong>说明请移步</p> 
 <ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.oracle.com%2Fjavase%2F8%2Fdocs%2Ftechnotes%2Fguides%2Fjar%2Fjar.html%23Signed_JAR_File" rel="nofollow" title="JAR File Specification">JAR File Specification</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FJAR_%2528file_format%2529" rel="nofollow" title="JAR (file format)">JAR (file format)</a></li></ul> 
</blockquote> 
<p>SpringBoot的jar包，会有3个文件夹：</p> 
<ul><li>BOOT-INF：存放自己编写并编译好的 .class 文件和静态资源文件、配置文件等</li><li>META-INF：有一个 <code>MANIFEST.MF</code> 的文件</li><li>org：<code>spring-boot-loader</code> 的一些 .class 文件</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/91/87/YXOhnsqc_o.png"></p> 
<p><code>META-INF</code> 下面的 <code>MANIFEST.MF</code> 文件，里面的内容如下：</p> 
<pre><code>Manifest-Version: 1.0
Spring-Boot-Classpath-Index: BOOT-INF/classpath.idx
Implementation-Title: my-small-test
Implementation-Version: 1.0-SNAPSHOT
Spring-Boot-Layers-Index: BOOT-INF/layers.idx
Start-Class: com.small.test.SpringBootDemoApplication
Spring-Boot-Classes: BOOT-INF/classes/
Spring-Boot-Lib: BOOT-INF/lib/
Build-Jdk-Spec: 1.8
Spring-Boot-Version: 2.4.0
Created-By: Maven Jar Plugin 3.2.0
Main-Class: org.springframework.boot.loader.JarLauncher
复制代码</code></pre> 
<ul><li>在 <code>Start-Class</code> 中注明了 SpringBoot 的主启动类</li><li>在 <code>Main-Class</code> 中注明了一个类： <code>JarLauncher</code></li></ul> 
<pre><code>package org.springframework.boot.loader;

import java.io.IOException;
import java.util.jar.Attributes;
import java.util.jar.Manifest;
import org.springframework.boot.loader.archive.Archive;

public class JarLauncher extends ExecutableArchiveLauncher {
  private static final String DEFAULT_CLASSPATH_INDEX_LOCATION = "BOOT-INF/classpath.idx";
  
  static final Archive.EntryFilter NESTED_ARCHIVE_ENTRY_FILTER;
  
  static {
    NESTED_ARCHIVE_ENTRY_FILTER = (entry -&gt; entry.isDirectory() ? entry.getName().equals("BOOT-INF/classes/") : entry.getName().startsWith("BOOT-INF/lib/"));
  }
  
  public JarLauncher() {}
  
  protected JarLauncher(Archive archive) {
    super(archive);
  }
  
  protected ClassPathIndexFile getClassPathIndex(Archive archive) throws IOException {
    if (archive instanceof org.springframework.boot.loader.archive.ExplodedArchive) {
      String location = getClassPathIndexFileLocation(archive);
      return ClassPathIndexFile.loadIfPossible(archive.getUrl(), location);
    } 
    return super.getClassPathIndex(archive);
  }
  
  private String getClassPathIndexFileLocation(Archive archive) throws IOException {
    Manifest manifest = archive.getManifest();
    Attributes attributes = (manifest != null) ? manifest.getMainAttributes() : null;
    String location = (attributes != null) ? attributes.getValue("Spring-Boot-Classpath-Index") : null;
    return (location != null) ? location : "BOOT-INF/classpath.idx";
  }
  
  protected boolean isPostProcessingClassPathArchives() {
    return false;
  }
  
  protected boolean isSearchCandidate(Archive.Entry entry) {
    return entry.getName().startsWith("BOOT-INF/");
  }
  
  protected boolean isNestedArchive(Archive.Entry entry) {
    return NESTED_ARCHIVE_ENTRY_FILTER.matches(entry);
  }
 
  public static void main(String[] args) throws Exception {
    (new JarLauncher()).launch(args);
  }
}
复制代码</code></pre> 
<p>父类<code>Launcher#launch</code></p> 
<pre><code>  protected void launch(String[] args) throws Exception {
    if (!isExploded())
    //3.1 注册URL协议并清除应用缓存
    JarFile.registerUrlProtocolHandler(); 
    //3.2 设置类加载路径
    ClassLoader classLoader = createClassLoader(getClassPathArchivesIterator());
    String jarMode = System.getProperty("jarmode");
    String launchClass = (jarMode != null &amp;&amp; !jarMode.isEmpty()) ? "org.springframework.boot.loader.jarmode.JarModeLauncher" : getMainClass();
    //3.3 执行main方法
    launch(args, launchClass, classLoader);
  }
复制代码</code></pre> 
<h3>3.1 registerUrlProtocolHandler：注册URL协议并清除应用缓存</h3> 
<p>先设置当前系统的一个变量 <strong><code>java.protocol.handler.pkgs</code></strong>，而这个变量的作用，是设置 <code>URLStreamHandler</code> 实现类的包路径。</p> 
<p>之后要重置缓存，目的是清除之前启动的残留。</p> 
<pre><code>private static final String MANIFEST_NAME = "META-INF/MANIFEST.MF";

    private static final String PROTOCOL_HANDLER = "java.protocol.handler.pkgs";

    private static final String HANDLERS_PACKAGE = "org.springframework.boot.loader";

    public static void registerUrlProtocolHandler() {
        String handlers = System.getProperty(PROTOCOL_HANDLER, "");
        System.setProperty(PROTOCOL_HANDLER,
                ("".equals(handlers) ? HANDLERS_PACKAGE : handlers + "|" + HANDLERS_PACKAGE));
        resetCachedUrlHandlers();
    }

    // 重置任何缓存的处理程序，以防万一已经使用了jar协议。
// 我们通过尝试设置null URLStreamHandlerFactory来重置处理程序，除了清除处理程序缓存之外，它应该没有任何效果。
    private static void resetCachedUrlHandlers() {
        try {
            URL.setURLStreamHandlerFactory(null);
        }
        catch (Error ex) {
            // Ignore
        }
    }
复制代码</code></pre> 
<h3>3.2createClassLoader：设置类加载路径</h3> 
<pre><code> protected ClassLoader createClassLoader(Iterator&lt;Archive&gt; archives) throws Exception {
    List&lt;URL&gt; urls = new ArrayList&lt;&gt;(50);
    while (archives.hasNext())
      urls.add(((Archive)archives.next()).getUrl()); 
    return createClassLoader(urls.&lt;URL&gt;toArray(new URL[0]));
  }
复制代码</code></pre> 
<pre><code>  protected ClassLoader createClassLoader(URL[] urls) throws Exception {
    return new LaunchedURLClassLoader(isExploded(), getArchive(), urls, getClass().getClassLoader());
  }
复制代码</code></pre> 
<h3>3.3 <code>执行main方法</code></h3> 
<pre><code>  protected void launch(String[] args, String launchClass, ClassLoader classLoader) throws Exception {
    Thread.currentThread().setContextClassLoader(classLoader);
    createMainMethodRunner(launchClass, args, classLoader).run();
  }
  
复制代码</code></pre> 
<pre><code>  protected MainMethodRunner createMainMethodRunner(String mainClass, String[] args, ClassLoader classLoader) {
    return new MainMethodRunner(mainClass, args);
  }
复制代码</code></pre> 
<pre><code>package org.springframework.boot.loader;

import java.lang.reflect.Method;

public class MainMethodRunner {
  private final String mainClassName;
  
  private final String[] args;
  
  public MainMethodRunner(String mainClass, String[] args) {
    this.mainClassName = mainClass;
    this.args = (args != null) ? (String[])args.clone() : null;
  }
  
  public void run() throws Exception {
    Class&lt;?&gt; mainClass = Class.forName(this.mainClassName, false, Thread.currentThread().getContextClassLoader());
    //获取主启动类的main方法
    Method mainMethod = mainClass.getDeclaredMethod("main", new Class[] { String[].class });
    mainMethod.setAccessible(true);
    //执行main方法
    mainMethod.invoke((Object)null, new Object[] { this.args });
  }
}
复制代码</code></pre> 
<p>所以 <code>SpringBoot</code> 应用在开发期间只需要写 main 方法，引导启动即可。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6c1ae42186e4d8c870bef49ce447fe45/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">原地移除数组中的所有元素val</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6c97202d1faf3dccbc7475e23bc0d92d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Vue】Vue-route路由</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>