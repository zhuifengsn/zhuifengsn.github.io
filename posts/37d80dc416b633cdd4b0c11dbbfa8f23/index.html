<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Apifox中更新token的两种方式(手动、自动) - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Apifox中更新token的两种方式(手动、自动)" />
<meta property="og:description" content="Apifox 关于token的使用方式 前言，关于token的使用，仅做了简单的demo测试token效果。
1.手动登录获取token 顾名思义，因为只有登录之后才有token的信息，所以在调用其他接口前需要拥有token才能访问。
操作步骤 1)添加全局变量、参数 在右上角环境中配置详细信息：全局参数填写参数名以及默认值
{{token}}，并且在全局变量中也可以填写token值。优先级就很高了。
接着在全局变量中也填写对应的本地值。
2)在登录接口运行中添加后置操作 选择提取变量，将token填入，并且根据登录接口返回的数据结构获取对应的token。例如我这里就是data.token。
添加完毕后，就会把登录接口返回的token数据填充到全局变量和全局参数中。但至此还不能实现：登录过后，其他的接口都可以调用了。要执行第3步。
特别注意：后置操作不是在接口文档中保存的，所以获取token的后置操作要保存用例，下次运行用例才能将token填充到全局变量中去。
3)在项目概览中添加Auth 点击项目概览，下方有Auth，目前我使用过API Key 和 Bearer Token。效果都一样，也是将{{token}}填入就好了，这样就是动态的获取全局变量中的token。
4)测试效果 首先是不登录时，调用其他接口的返回状态：
因为之前登陆过，但是token过期了，所以会提示token过期的信息。然后再执行一次登录接口，再观察控制台结果：在控制台可以很清晰的看到全局变量重新填充了。
然后回到其他接口调用：没有发生拦截，成功的执行了接口。
2.自动获取token 自动获取token的方式相对手动获取来说也就是多了一步前置操作，意思就是在调用任意接口前，先执行一次登录接口将token填充到全局变量中，从而避免了token过期或需要手动调用登录接口再调用其他接口
操作步骤 1)新建公共脚本 在项目设置中添加公共脚本：
该脚本的主体就是pm.sendRequest()，意思就是调用一次登录接口，其参数也就是接口中所需要的参数，此处都是模拟数据，真实可按照数据库中的账户密码即可。
特别注意：其实不推荐这样写死的url和账户密码、文章末尾有一份比较标准的脚本，参考了官方文档。
2)在项目概览中添加前置操作 只要根据提示就可以把脚本给添加到前置操作中。保存后就可以测试结果了。
3)测试效果 目前接口任然处于一个token过期的状态，但这次不再手动调用登录接口了，而是直接再次运行此接口：
可以看到接口也运行成功，并没有拦截。此时，我们可以通过点击控制台的链接，发现此处就是默认执行了一次登录的接口，所以token也就不会存在过期、或不存在的情况了。
脚本模板 // body 里面的参数需要自己设置对应的 // 定义发送登录接口请求方法 function sendLoginRequest() { // 获取环境里的 前置URL // const baseUrl = pm.environment.get(&#39;BASE_URL&#39;); // 登录用户名，这里从环境变量 LOGIN_USERNAME 获取，也可以写死（但是不建议） // const username = pm.environment.get(&#39;LOGIN_USERNAME&#39;); // 登录用户名，这里从环境变量 LOGIN_PASSWORD 获取，也可以写死（但是不建议） // const password = pm." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/37d80dc416b633cdd4b0c11dbbfa8f23/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-06T17:07:33+08:00" />
<meta property="article:modified_time" content="2022-07-06T17:07:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Apifox中更新token的两种方式(手动、自动)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Apifox_token_0"></a>Apifox 关于token的使用方式</h3> 
<p>前言，关于token的使用，仅做了简单的demo测试token效果。</p> 
<h4><a id="1token_4"></a>1.手动登录获取token</h4> 
<p>顾名思义，因为只有登录之后才有token的信息，所以在调用其他接口前需要拥有token才能访问。</p> 
<h5><a id="_8"></a>操作步骤</h5> 
<h6><a id="1_10"></a>1)添加全局变量、参数</h6> 
<p>在右上角环境中配置详细信息：<strong>全局参数</strong>填写参数名以及默认值<br> <strong>{<!-- -->{token}}</strong>，并且在全局变量中也可以填写token值。优先级就很高了。<br> <img src="https://images2.imgbox.com/f1/f0/flq1qVDO_o.png" alt="在这里插入图片描述"><br> 接着在全局变量中也填写对应的本地值。</p> 
<h6><a id="2_17"></a>2)在登录接口运行中添加后置操作</h6> 
<p>选择提取变量，将token填入，并且根据登录接口返回的数据结构获取对应的token。<code>例如我这里就是data.token</code>。<br> <img src="https://images2.imgbox.com/4a/62/u4lH8bwZ_o.png" alt="在这里插入图片描述"><br> 添加完毕后，就会把登录接口返回的token数据填充到全局变量和全局参数中。但至此还不能实现：登录过后，其他的接口都可以调用了。要执行第3步。</p> 
<p><strong>特别注意</strong>：后置操作<strong>不是在接口文档中保存的</strong>，所以获取token的后置操作要<strong>保存用例</strong>，下次运行用例才能将token填充到全局变量中去。</p> 
<h6><a id="3Auth_25"></a>3)在项目概览中添加Auth</h6> 
<p>点击项目概览，下方有Auth，目前我使用过API Key 和 Bearer Token。效果都一样，也是将<code>{<!-- -->{token}}</code>填入就好了，这样就是动态的获取全局变量中的token。<br> <img src="https://images2.imgbox.com/43/20/rJlLnHgg_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="4_29"></a>4)测试效果</h6> 
<p>首先是不登录时，调用其他接口的返回状态：<br> <img src="https://images2.imgbox.com/9f/cb/qRpXZj37_o.png" alt="在这里插入图片描述"><br> 因为之前登陆过，但是token过期了，所以会提示token过期的信息。然后再执行一次登录接口，再观察控制台结果：在控制台可以很清晰的看到全局变量重新填充了。<br> <img src="https://images2.imgbox.com/35/99/ynxTvQal_o.png" alt="在这里插入图片描述"><br> 然后回到其他接口调用：没有发生拦截，成功的执行了接口。<br> <img src="https://images2.imgbox.com/2b/4b/ZQ5lJWpE_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2token_38"></a>2.自动获取token</h4> 
<p>自动获取token的方式相对手动获取来说也就是多了一步前置操作，意思就是在调用任意接口前，先执行一次登录接口将token填充到全局变量中，从而避免了token过期或需要手动调用登录接口再调用其他接口</p> 
<h4><a id="_42"></a>操作步骤</h4> 
<h6><a id="1_44"></a>1)新建公共脚本</h6> 
<p>在项目设置中添加公共脚本：</p> 
<p><img src="https://images2.imgbox.com/68/7e/nkQeEHZR_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/84/aa/5AJ9FIR5_o.png" alt="在这里插入图片描述"><br> 该脚本的主体就是<code>pm.sendRequest()</code>，意思就是调用一次登录接口，其参数也就是接口中所需要的参数，此处都是模拟数据，真实可按照数据库中的账户密码即可。</p> 
<p><strong>特别注意</strong>：其实不推荐这样写死的url和账户密码、文章末尾有一份比较标准的脚本，参考了<a href="https://www.apifox.cn/help/app/best-practices/auth/#%E5%85%AC%E5%85%B1%E8%84%9A%E6%9C%AC%E7%A4%BA%E4%BE%8B" rel="nofollow">官方文档</a>。</p> 
<h6><a id="2_54"></a>2)在项目概览中添加前置操作</h6> 
<p>只要根据提示就可以把脚本给添加到前置操作中。保存后就可以测试结果了。<br> <img src="https://images2.imgbox.com/7b/75/IEEdt9vm_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="3_58"></a>3)测试效果</h6> 
<p><img src="https://images2.imgbox.com/17/ad/XHl3s6jI_o.png" alt="在这里插入图片描述"><br> 目前接口任然处于一个token过期的状态，但这次不再手动调用登录接口了，而是直接再次运行此接口：<br> <img src="https://images2.imgbox.com/8f/cf/z94wlZuR_o.png" alt="在这里插入图片描述"></p> 
<p>可以看到接口也运行成功，并没有拦截。此时，我们可以通过点击控制台的链接，发现此处就是默认执行了一次登录的接口，所以token也就不会存在过期、或不存在的情况了。<br> <img src="https://images2.imgbox.com/dc/a0/gqvferCj_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_67"></a>脚本模板</h4> 
<pre><code class="prism language-javascript"><span class="token comment">//   body 里面的参数需要自己设置对应的</span>
<span class="token comment">// 定义发送登录接口请求方法</span>
<span class="token keyword">function</span> <span class="token function">sendLoginRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 获取环境里的 前置URL</span>
    <span class="token comment">// const baseUrl = pm.environment.get('BASE_URL');</span>
    <span class="token comment">// 登录用户名，这里从环境变量 LOGIN_USERNAME 获取，也可以写死（但是不建议）</span>
    <span class="token comment">// const username = pm.environment.get('LOGIN_USERNAME');</span>
    <span class="token comment">// 登录用户名，这里从环境变量 LOGIN_PASSWORD 获取，也可以写死（但是不建议）</span>
    <span class="token comment">// const password = pm.environment.get('LOGIN_PASSWORD');</span>
    <span class="token comment">// 构造一个 POST x-www-form-urlencoded 格式请求。这里需要改成你们实际登录接口的请求参数。</span>
    <span class="token keyword">const</span> loginRequest <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
        <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">'http://localhost:8888/customer/login'</span><span class="token punctuation">,</span>
        <span class="token literal-property property">method</span><span class="token operator">:</span> <span class="token string">'POST'</span><span class="token punctuation">,</span>
        <span class="token comment">// 若 body 为 x-www-form-urlencoded 格式，mode 为 'urlencoded'</span>
        <span class="token comment">// body: {<!-- --></span>
        <span class="token comment">//     mode: 'urlencoded',</span>
        <span class="token comment">//     urlencoded: [</span>
        <span class="token comment">//         { key: 'account', value: username },</span>
        <span class="token comment">//         { key: 'password', value: password }</span>
        <span class="token comment">//     ]</span>
        <span class="token comment">// }</span>
        <span class="token comment">// 若 body 为 form-data 格式，mode 为 'formdata'</span>
        <span class="token comment">// body: {<!-- --></span>
        <span class="token comment">//  mode: 'formdata',</span>
        <span class="token comment">//  formdata: [</span>
        <span class="token comment">//    { key: 'account', value: username },</span>
        <span class="token comment">//   { key: 'password', value: password }</span>
        <span class="token comment">//  ]</span>
        <span class="token comment">// }</span>
        <span class="token comment">// 若 body 为 raw 或 json 格式，mode 为 'raw'</span>
        <span class="token literal-property property">header</span><span class="token operator">:</span> <span class="token string">'Content-Type:application/json'</span><span class="token punctuation">,</span>
        <span class="token literal-property property">body</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
            <span class="token literal-property property">mode</span><span class="token operator">:</span> <span class="token string">'raw'</span><span class="token punctuation">,</span>
            <span class="token literal-property property">raw</span><span class="token operator">:</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>
                <span class="token punctuation">{<!-- --></span> 
                    <span class="token string-property property">"loginAccount"</span><span class="token operator">:</span><span class="token string">"lisi"</span><span class="token punctuation">,</span>
                    <span class="token string-property property">"password"</span><span class="token operator">:</span><span class="token string">"123456"</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">// 发送请求。 </span>
    <span class="token comment">// pm.sendrequest 参考文档: https://www.apifox.cn/help/app/scripts/api-references/pm-reference/#pm-sendrequest</span>
    pm<span class="token punctuation">.</span><span class="token function">sendRequest</span><span class="token punctuation">(</span>loginRequest<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> response</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 读取接口返回的 json 数据。</span>
            <span class="token comment">// 如果你的 token 信息是存放在 cookie 的，可以使用 res.cookies.get('token') 方式获取。 </span>
            <span class="token comment">// cookies 参考文档：https://www.apifox.cn/help/app/scripts/api-references/pm-reference/#pm-cookies</span>
            <span class="token keyword">const</span> res <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 将 accessToken 写入环境变量 ACCESS_TOKEN</span>
            pm<span class="token punctuation">.</span>globals<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'token'</span><span class="token punctuation">,</span> res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>token<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 获取全局变量里的 TOKEN</span>
<span class="token comment">// const token = pm.globals.get('token');</span>
<span class="token comment">// 获取环境变量里的 ACCESS_TOKEN_EXPIRES</span>
<span class="token comment">// const accessTokenExpires = pm.environment.get('ACCESS_TOKEN_EXPIRES');</span>
<span class="token comment">// 如 ACCESS_TOKEN 没有值，或 ACCESS_TOKEN_EXPIRES 已过期，则执行发送登录接口请求</span>
<span class="token comment">// if (!token) {<!-- --></span>
<span class="token comment">//    sendLoginRequest();</span>
<span class="token comment">// }</span>
<span class="token comment">//测试：不进行任何判断，调用其他接口前先调用登录接口</span>
<span class="token function">sendLoginRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ffbb0065c6c5af190b7014eeb1834f4b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">docker迁移Docker Root Dir数据目录</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dbaf4e6e3efca9473fd1606b3e5cf164/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何批量将 psd 转换为 png、jpeg、bmp、svg、webp 格式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>