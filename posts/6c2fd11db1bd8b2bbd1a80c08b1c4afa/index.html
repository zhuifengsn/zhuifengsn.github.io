<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言 程序的翻译 预处理 编译 汇编 链接 #define详解 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言 程序的翻译 预处理 编译 汇编 链接 #define详解" />
<meta property="og:description" content="1.程序的翻译环境和执行环境 执行环境：所在操作系统的平台 win10 win11 linux
翻译环境：MSVC gcc g&#43;&#43;
你的vs 2019 和2022 是集成开发环境把编辑器编译器全部给你集成到一块了，也就是所有的功能给你自动生成的，查看中间过程就有些困难，然而 Linux下就可以通过操作选项来一个个看到这些步骤，或者是用vs code这种编辑器配好win下的gcc就可以一步步的看到过程了。
2.翻译的过程 我们想要把一个.c文件变成一个.exe文件要经过一下过程
2.1 预处理 预处理主要干的活就是头文件展开，宏替换，去注释，条件编译。
在Linux的gcc下通过gcc -E hello.c -o hello.i 也就是开始翻译完成预处理就停下来再生成hello.i文件
预处理进行了宏替换 NUM被替换成了100，而且进行了头文件展开将你代码中调用的方法从你所在的头文件给你复制粘贴进来，然后你的注释也被去掉了，而且预处理之后还是语言
2.2编译 通过gcc -S hello.i -o hello.s开始翻译完成编译就停下来
这时候这是啥呢，他已经不是c语言了他是汇编语言，那我们的编译的过程也就是把刚刚那一份干净的纯C语言变成汇编语言。
2.3 汇编 虽然叫汇编可不是把c语言变成汇编语言，上一步已经做过了 这一步的命令行是 gcc -c hello.s -o hello.o
这里用vim看就是乱码了，那我们用这个格式化处理工具od 来查看一下
很明显发现这不是二进制吗，是的汇编的工作就是把汇编代码转换成二进制程序，但是这个是不可执行的这个以.o结尾文件叫做目标文件，那.o\文件运行不了说明还是少了一步
2.4 链接 直接gcc hello.o链接形成a.out文件./a.out就可以看见程序执行的结果了，这个printf（）；函数是你写的吗？不是的他是在c语言的库中。链接的作用就是把程序跟库文件相关联的过程。
3 运行环境 1. 程序必须载入内存中。在有操作系统的环境中：一般这个由操作系统完成。在独立的环境中，程序的载入必须由手工安排，也可能是通过可执行代码置入只读内存来完成。
2. 程序的执行便开始。接着便调用main函数
3. 开始执行程序代码。这个时候程序将使用一个运行时堆栈（stack），存储函数的局部变量和返回地址。程序同时也可以使用静态（static）内存，存储于静态内存中的变量在程序的整个执行过程一直保留他们的值。
4. 终止程序。正常终止main函数；也有可能是意外终止
4 预处理详解 4.1 预定义符号 __FILE__ //进行编译的源文件 __LINE__ //文件当前的行号 __DATE__ //文件被编译的日期 __TIME__ //文件被编译的时间 __STDC__ //如果编译器遵循ANSI C，其值为1，否则未定义 这里就能清晰的看到，被替换了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/6c2fd11db1bd8b2bbd1a80c08b1c4afa/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-11T18:15:46+08:00" />
<meta property="article:modified_time" content="2022-03-11T18:15:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言 程序的翻译 预处理 编译 汇编 链接 #define详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="1.%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BF%BB%E8%AF%91%E7%8E%AF%E5%A2%83%E5%92%8C%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83">1.程序的翻译环境和执行环境</h3> 
<p>执行环境：所在操作系统的平台 win10 win11 linux</p> 
<p>翻译环境：MSVC gcc g++</p> 
<p>你的vs 2019 和2022 是集成开发环境把编辑器编译器全部给你集成到一块了，也就是所有的功能给你自动生成的，查看中间过程就有些困难，然而 Linux下就可以通过操作选项来一个个看到这些步骤，或者是用vs code这种编辑器配好win下的gcc就可以一步步的看到过程了。</p> 
<h3 id="2.%E7%BF%BB%E8%AF%91%E7%9A%84%E8%BF%87%E7%A8%8B">2.翻译的过程</h3> 
<p>我们想要把一个.c文件变成一个.exe文件要经过一下过程</p> 
<h4>2.1 预处理</h4> 
<p>预处理主要干的活就是头文件展开，宏替换，去注释，条件编译。</p> 
<p>在Linux的gcc下通过gcc -E hello.c -o hello.i 也就是开始翻译完成预处理就停下来再生成hello.i文件</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0c/78/fRIosxXh_o.png"></p> 
<p> 预处理进行了宏替换 NUM被替换成了100，而且进行了头文件展开将你代码中调用的方法从你所在的头文件给你复制粘贴进来，然后你的注释也被去掉了，而且预处理之后还是语言</p> 
<h4>2.2编译</h4> 
<p>通过gcc -S hello.i -o hello.s开始翻译完成编译就停下来</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/53/e9/eRR9bQAm_o.png"></p> 
<p> 这时候这是啥呢，他已经不是c语言了他是汇编语言，那我们的编译的过程也就是把刚刚那一份干净的纯C语言变成汇编语言。</p> 
<h4>2.3 汇编</h4> 
<p>虽然叫汇编可不是把c语言变成汇编语言，上一步已经做过了 这一步的命令行是 gcc -c hello.s -o hello.o</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/8f/0a/YiXY30Dj_o.png"></p> 
<p>这里用vim看就是乱码了，那我们用这个格式化处理工具od 来查看一下</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/bb/65/JLZuysjM_o.png"></p> 
<p>很明显发现这不是二进制吗，是的汇编的工作就是把汇编代码转换成二进制程序，但是这个是不可执行的这个以.o结尾文件叫做目标文件，那.o\文件运行不了说明还是少了一步</p> 
<h4>2.4 链接</h4> 
<p>直接gcc hello.o链接形成a.out文件./a.out就可以看见程序执行的结果了，这个printf（）；函数是你写的吗？不是的他是在c语言的库中。链接的作用就是把程序跟库文件相关联的过程。</p> 
<h3>3 运行环境</h3> 
<p>1. 程序必须载入内存中。在有操作系统的环境中：一般这个由操作系统完成。在独立的环境中，程序的载入必须由手工安排，也可能是通过可执行代码置入只读内存来完成。<br> 2. 程序的执行便开始。接着便调用main函数</p> 
<p>3. 开始执行程序代码。这个时候程序将使用一个运行时堆栈（stack），存储函数的局部变量和返回地址。程序同时也可以使用静态（static）内存，存储于静态内存中的变量在程序的整个执行过程一直保留他们的值。<br> 4. 终止程序。正常终止main函数；也有可能是意外终止</p> 
<h3>4 预处理详解</h3> 
<h4>4.1 预定义符号</h4> 
<pre><code>__FILE__         //进行编译的源文件
__LINE__         //文件当前的行号
__DATE__         //文件被编译的日期
__TIME__         //文件被编译的时间
__STDC__         //如果编译器遵循ANSI C，其值为1，否则未定义</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ac/83/j7t7lK0M_o.png"><br>  </p> 
<p> 这里就能清晰的看到，被替换了。</p> 
<h4>4.2 #define</h4> 
<p>define 定义的标识符</p> 
<pre><code class="language-cpp">//语法
#define NAME stuff</code></pre> 
<p>举个例子</p> 
<pre><code class="language-cpp">#define MAX 1000
#define reg register //为 register这个关键字，创建一个简短的名字
#define do_forever for(;;) //用更形象的符号来替换一种实现
#define CASE break;case //在写case语句的时候自动把 break写上。
// 如果定义的 stuff过长，可以分成几行写，除了最后一行外，每行的后面都加一个反斜杠(续行符)。
#define DEBUG_PRINT printf("file:%s\tline:%d\t \
date:%s\ttime:%s\n" ,\
__FILE__,__LINE__ , \
__DATE__,__TIME__ )</code></pre> 
<p>那我们一般对于数字进行宏替换的时候要加；吗？</p> 
<p>比如</p> 
<pre><code class="language-cpp">#define MAX 1000;
#define MAX 1000</code></pre> 
<p>让我们gcc一下</p> 
<p style="text-align:center;"><img alt="" height="273" src="https://images2.imgbox.com/93/49/RAZy1MZP_o.png" width="286"></p> 
<p> 就很明显的看到了错误</p> 
<p>定义宏</p> 
<p>#define 机制包括了一个规定，允许把参数替换到文本中，这种实现通常称为宏。<br> 下面是宏的申明方式：<br> #define name( parament-list ) stuff其中的 parament-list 是一个由逗号隔开的符号表，它们可能出现在stuff中。<br> 注意：<br> 参数列表的左括号必须与name紧邻。如果两者之间有任何空白存在，参数列表就会被解释为stuff的一部分</p> 
<p>比如这个例子</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a2/75/xccPpJHY_o.png"><br>  </p> 
<p>我们原本想的是应该是11*11 结果是121 为啥是21呢，那就看看.i 文件看看到底宏替换哪块出问题了 </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1a/43/XQXywCq8_o.png"></p> 
<p> 原来是替换之后根据运算符号的先后顺序所以结果是21那么怎样去避免这个问题呢我们在宏定义的时候这样去做</p> 
<pre><code>#define sq(x) (x)*(x)</code></pre> 
<p>这次是避免了那要是出现这种情况呢</p> 
<p style="text-align:center;"><img alt="" height="291" src="https://images2.imgbox.com/44/fb/92gCPPO6_o.png" width="431"></p> 
<p> 不是按理来说应该是110吗咋变成1210了那我们再看看.i文件</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/44/7f/Y1RJlAOv_o.png"></p> 
<p> 跟刚刚一样的老问题还是顺序问题带来的那这次怎么办呢</p> 
<pre><code>#define sq(x) ((x)*(x))</code></pre> 
<p>带参宏就会有很多很多的问题在替换中提现到那只能尽可能的加（）来避免操作顺序带来的问题</p> 
<p>尽量不要使用这种带参数的</p> 
<p>替换规则<br> 1. 在调用宏时，首先对参数进行检查，看看是否包含任何由#define定义的符号。如果是，它们首先被替换。<br> 2. 替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值替换。<br> 3. 最后，再次对结果文件进行扫描，看看它是否包含任何由#define定义的符号。如果是，就重复上述处理过程。<br> 注意：<br> 1. 宏参数和#define 定义中可以出现其他#define定义的变量。但是对于宏，不能出现递归。<br> 2. 当预处理器搜索#define定义的符号的时候，字符串常量的内容并不被搜索。<br>  </p> 
<h4>4.3 #和##</h4> 
<p>我们知道临街字符串，具有自动连接的特性</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5e/e6/MJuiYnQG_o.png"></p> 
<p style="text-align:center;"><img alt="" height="293" src="https://images2.imgbox.com/9a/ba/ye2vlVwv_o.png" width="658"> </p> 
<p> 使用#把一个宏参数变成字符串</p> 
<p style="text-align:center;"><img alt="" height="265" src="https://images2.imgbox.com/49/00/uUeicL0u_o.png" width="623"></p> 
<p> 使用##可以把位于它两边的符号合成一个符号。</p> 
<p>比如这个例子</p> 
<p style="text-align:center;"><img alt="" height="351" src="https://images2.imgbox.com/b5/11/k9F1VLcU_o.png" width="521"></p> 
<p> 我的标识符x跟1就合体成x1了，我调用NUM就是x1</p> 
<h4>4.4带有副作用的宏</h4> 
<pre><code>x+1;//不带副作用 我x还是没有变
x++;//带有副作用 我x自增了结果变化了</code></pre> 
<p>有这个例子</p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#define MAX(a, b) ( (a) &gt; (b) ? (a) : (b) )
int main() {
	int x = 5;
	int y = 8;
	int z = MAX(x++, y++);
	printf("x=%d y=%d z=%d\n", x, y, z);
}</code></pre> 
<p>输出结果就是 6 10 9 因为我在max里面做了一次++ 我宏替换换的是整个 比完大小之后我又加了一次这就是副作用带来的影响。</p> 
<h4>4.5宏和函数的对比</h4> 
<p>举个例子吧，比如在做leetcode中老想追求双百，时间哪块想更快咋办呀，可以将小型运算换成宏，调用函数和从函数返回的代码肯比较慢，而且更为重要的是函数的参数必须声明为特定的类型。所以函数只能在类型合适的表达式上使用。反之这个宏怎可以适用于整形、长整型、浮点型等可以用于 &gt; 来比较的类型，宏是类型无关的！</p> 
<p>当然和宏相比函数也有劣势的地方：<br> 1. 每次使用宏的时候，一份宏定义的代码将插入到程序中。除非宏比较短，否则可能大幅度增加程序的长度。<br> 2. 宏是没法调试的。<br> 3. 宏由于类型无关，也就不够严谨。<br> 4. 宏可能会带来运算符优先级的问题，导致程容易出现错。<br> 宏有时候可以做函数做不到的事情。比如：宏的参数可以出现类型，但是函数做不到。</p> 
<h3>5 #undef</h3> 
<p>简而言之就是取消宏定义</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/94/84/KelBnJOZ_o.png"></p> 
<h3> 6 命令行编译</h3> 
<p>许多C 的编译器提供了一种能力，允许在命令行中定义符号。用于启动编译过程。</p> 
<p style="text-align:center;"><img alt="" height="259" src="https://images2.imgbox.com/45/26/HuadFgYX_o.png" width="457"></p> 
<p> 这条gcc a.c -DNUM=100 D也就是我们的 define对NUM进行宏定义</p> 
<h3> 7 条件编译</h3> 
<p>我们刚刚在预处理的时候说了那个时候会进行条件编译那这个是啥呢，其实也就是对代码进行截断比如我现在没有小月卡或者大月卡，我现在充钱了，给了这个程序一个动作，那大月卡用户可以有的资源也就可以拥有了，换个说法也就是调用那一段代码，那段代码是实现大月卡能干什么的方法。这一段被截断的代码现在就在我的总的代码里面了，一家游戏公司不可能专门为普通用户写一套代码，为大月卡写一套，在为小月卡用户写一套，这样的成本也太高了吧。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/78/72/n5IjGPUm_o.png"></p> 
<h3> 8 文件包含</h3> 
<p>我们已经知道#include 指令可以使另外一个文件被编译，就像他实际出现#include指令单地方一样。预处理先删除这条指令，并用包含文件的内容替换。这样一个源文件被包含10次，那就实际被编译10次！</p> 
<h4>8.1头文件包含的方式</h4> 
<p>” “这样包含自己定义的头文件 首先是在当前目录下寻找找不到再在库函数目录下寻找</p> 
<p>&lt;&gt;这样包含的头文件直接就在库函数目录下寻找</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/062a90bc30c504559f1ab1a7e448a9d7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Mybatis-Plus条件构造器的 “冷知识“</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7b4a2b0d0427642f7e916d9d0b1662cd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">二进制、八进制、十进制、十六进制带小数的转换</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>