<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【wpf】DataGrid的使用 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【wpf】DataGrid的使用" />
<meta property="og:description" content="DataGrid动态生成 简单方式 动态生成实现需要设置AutoGenerateColumns=&#34;True&#34;，
&lt;DataGrid Name=&#34;dataGrid&#34; AutoGenerateColumns=&#34;True&#34; /&gt;
后台dataGrid.ItemsSource = infoList;
infoList，就是一个类似Json的数组结构数据：
[ { &#34;columnChName&#34;: &#34;孔宽1&#34;, &#34;nominalDim&#34;: 17.28, &#34;tolMax&#34;: 0.02, &#34;tolMin&#34;: 0.02, &#34;usl&#34;: 17.3, &#34;lsl&#34;: 17.26 }, { &#34;columnChName&#34;: &#34;孔从中心偏移3&#34;, &#34;nominalDim&#34;: 17.28, &#34;tolMax&#34;: 0.02, &#34;tolMin&#34;: 0.02, &#34;usl&#34;: 17.3, &#34;lsl&#34;: 17.26 }, { &#34;columnChName&#34;: &#34;孔从中心偏移6&#34;, &#34;nominalDim&#34;: 17.28, &#34;tolMax&#34;: 0.02, &#34;tolMin&#34;: 0.02, &#34;usl&#34;: 17.3, &#34;lsl&#34;: 17.26 }, { &#34;columnChName&#34;: &#34;孔从中心偏移5&#34;, &#34;nominalDim&#34;: 13.84, &#34;tolMax&#34;: 0.05, &#34;tolMin&#34;: 0.05, &#34;usl&#34;: 13.89, &#34;lsl&#34;: 13.79 }, { &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/ba5a418d2f21e0a062bd7d6f5f19d863/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-28T21:01:27+08:00" />
<meta property="article:modified_time" content="2023-03-28T21:01:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【wpf】DataGrid的使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>DataGrid动态生成</h2> 
<h3>简单方式</h3> 
<p>动态生成实现需要设置AutoGenerateColumns="True"，</p> 
<p>&lt;DataGrid Name="dataGrid" AutoGenerateColumns="True" /&gt;</p> 
<p>后台dataGrid.ItemsSource = infoList;</p> 
<p>infoList，就是一个类似Json的数组结构数据：</p> 
<pre><code class="language-cs">[
                    {
                        "columnChName": "孔宽1",
                        "nominalDim": 17.28,
                        "tolMax": 0.02,
                        "tolMin": 0.02,
                        "usl": 17.3,
                        "lsl": 17.26
                    },
                    {
                        "columnChName": "孔从中心偏移3",
                        "nominalDim": 17.28,
                        "tolMax": 0.02,
                        "tolMin": 0.02,
                        "usl": 17.3,
                        "lsl": 17.26
                    },
                    {
                        "columnChName": "孔从中心偏移6",
                        "nominalDim": 17.28,
                        "tolMax": 0.02,
                        "tolMin": 0.02,
                        "usl": 17.3,
                        "lsl": 17.26
                    },
                    {
                        "columnChName": "孔从中心偏移5",
                        "nominalDim": 13.84,
                        "tolMax": 0.05,
                        "tolMin": 0.05,
                        "usl": 13.89,
                        "lsl": 13.79
                    },
                    {
                        "columnChName": "孔从中心偏移2",
                        "nominalDim": 13.84,
                        "tolMax": 0.05,
                        "tolMin": 0.05,
                        "usl": 13.89,
                        "lsl": 13.79
                    },
                    {
                        "columnChName": "孔长3",
                        "nominalDim": 52.94,
                        "tolMax": 0.02,
                        "tolMin": 0.02,
                        "usl": 52.96,
                        "lsl": 52.92
                    },
                    {
                        "columnChName": "孔从中心偏移7",
                        "nominalDim": 49.75,
                        "tolMax": 0.02,
                        "tolMin": 0.02,
                        "usl": 49.77,
                        "lsl": 49.73
                    }
                ]</code></pre> 
<p>固定不变的key会自动变成表格的列标题。</p> 
<p>那界面直接就会出现这样的结果，十分方便：</p> 
<p><img alt="" height="461" src="https://images2.imgbox.com/9b/0a/EYMwwtnP_o.png" width="941"></p> 
<h3>如果不想动态生成，要自己定义标题头，</h3> 
<p>首先需要 AutoGenerateColumns="False" ，然后：</p> 
<pre><code class="language-cs">&lt;Window&gt;
    &lt;Grid&gt;
        &lt;DataGrid ItemsSource="{Binding Customers}"&gt;
            &lt;DataGrid.Columns&gt;
                &lt;DataGridTextColumn Header="Name" Binding="{Binding Name}" /&gt;
                &lt;DataGridTextColumn Header="Age" Binding="{Binding Age}" /&gt;
                &lt;DataGridTextColumn Header="Address" Binding="{Binding Address}" /&gt;
            &lt;/DataGrid.Columns&gt;
        &lt;/DataGrid&gt;
    &lt;/Grid&gt;
&lt;/Window&gt;
</code></pre> 
<p>这样也是可以的~~~~</p> 
<p></p> 
<p></p> 
<p></p> 
<h3>通用的方式</h3> 
<p>这样的简单是简单，但是受到的数据格式的限制，而且无法对表格进行更精细的设置，下面介绍一下更通用的做法。</p> 
<h4>数据源DataTable</h4> 
<p>首先我们新建一个<strong>DataTable </strong>，DataTable dt = new DataTable(); 让 dt 作为我们<strong>DataGrid</strong>的数据源，好处是DataTable作为数据源之后，数据源的变换可以直接通知到界面（类似<strong>ObservableCollection</strong>）。</p> 
<h4>数据关联</h4> 
<p>将 <strong>DataGrid </strong>的数据源与 <strong>DataTable </strong>关联起来：</p> 
<pre><code class="language-cs">datagrid.ItemsSource = dt.AsDataView();</code></pre> 
<h4><strong>标题头部分构造（示例代码）</strong></h4> 
<pre><code class="language-cs">foreach (var item in _data_model.result.titleColumn)
{
    dt.Columns.Add(item.columnChName);
}
</code></pre> 
<h4>内容构造<strong>（示例代码）</strong></h4> 
<p><strong>添加一行的伪代码：</strong></p> 
<pre><code class="language-cs">//添加一行的伪代码
DataRow row = dt.NewRow();
foreach (var cd in (JsonObject)r.contentData)
{
    try
    {
        row[new_key] = cd.Value.ToString(); 
    }
    catch (ArgumentException ex)
    {
        logger.Info("ArgumentException：" + ex.Message);
    }

}
dt.Rows.Add(row);
</code></pre> 
<p>我们需要注意这里的new_key，必须是标题头中包含的内容，不然是会报ArgumentException的异常。<span style="color:#fe2c24;">new_key对应的就是一个列标题的内容</span>。</p> 
<p></p> 
<h3>如何动态的配置每个单元格</h3> 
<p>在阐述这个话题之前，我需要做一些铺垫。</p> 
<h4>1 DataGrid如何获取当前列数</h4> 
<pre><code class="language-cs">testDateGrid.Columns.Count</code></pre> 
<p> 还有一个方法，DataTable dt 是DataGrid的数据源，所以通过dt.Columns.Count获取到列数</p> 
<p></p> 
<h4>2 DataGrid如何获取当前行数</h4> 
<p> 之前一直找Rows这个属性，所以一直找不到如何获取行数，其实这里的Items就相当于Rows</p> 
<pre><code class="language-cs">testDateGrid.Items.Count</code></pre> 
<p>同理，DataTable dt 是DataGrid的数据源，所以通过 dt.Rows.Count可以获取到行数</p> 
<p></p> 
<h4>3 基于prism的事件时如何获取sender对象</h4> 
<pre><code class="language-XML">&lt;DataGrid  x:Name="testDateGrid" CanUserSortColumns="False"  &gt;
    &lt;i:Interaction.Triggers&gt;
        &lt;i:EventTrigger EventName="LoadingRow"&gt;
            &lt;prism:InvokeCommandAction Command="{Binding EventLoadingRow}"/&gt;
        &lt;/i:EventTrigger&gt;
        &lt;i:EventTrigger EventName="UnloadingRow"&gt;
            &lt;prism:InvokeCommandAction Command="{Binding EventUnloadingRow}"/&gt;
        &lt;/i:EventTrigger&gt;
    &lt;/i:Interaction.Triggers&gt;
&lt;/DataGrid&gt;
</code></pre> 
<p>这里为了实现MVVM我用prism的方式添加了两个事件LoadingRow，UnloadingRow。如果是普通的事件添加是自动传入sender的，也就是DataGrid对象本身。而通过prism的方式，只会传参数e。</p> 
<p>后台代码如下，这里只能传参数DataGridRowEventArgs：</p> 
<pre><code class="language-cs">public DelegateCommand&lt;DataGridRowEventArgs&gt; EventLoadingRow { get; set; }</code></pre> 
<p>不过我们有办法通过e来获取sender，不够稍微有点麻烦：</p> 
<pre><code class="language-cs">
testDateGrid = Tool.GetChildObjectWithName&lt;DataGrid&gt;((DependencyObject)e.OriginalSource, "testDateGrid");</code></pre> 
<p>"testDateGrid"这个是我在前台xaml中配置的名字，然后通过GetChildObjectWithName这个方法获取到DateGrid对象。方法的具体实现，我放到最后的 <strong>附录 </strong>中吧。</p> 
<p>有了DateGrid对象，如何获取DateGrid的每一行，以及每一行中的每个单元格呢？这里我们为DataGrid添加两个扩展方法，分别用来获取DataGridRow和DataGridCell：</p> 
<pre><code class="language-cs">namespace BaseLibrary.MyExtensions
{
    public static class DataGridExtensions
    {
        public static DataGridCell GetCell(this DataGrid grid, DataGridRow row, int columnIndex = 0)
        {
            if (row == null) return null;

            var presenter = Tools.Tool.GetChildObjectFirst&lt;DataGridCellsPresenter&gt;(row);
            if (presenter == null) return null;

            var cell = (DataGridCell)presenter.ItemContainerGenerator.ContainerFromIndex(columnIndex);
            if (cell != null) return cell;

            // now try to bring into view and retreive the cell
            grid.ScrollIntoView(row, grid.Columns[columnIndex]);
            cell = (DataGridCell)presenter.ItemContainerGenerator.ContainerFromIndex(columnIndex);

            return cell;
        }

        /// &lt;summary&gt;
        /// 获取DataGrid的行
        /// &lt;/summary&gt;
        /// &lt;param name="dataGrid"&gt;DataGrid控件&lt;/param&gt;
        /// &lt;param name="rowIndex"&gt;DataGrid行号&lt;/param&gt;
        /// &lt;returns&gt;指定的行号&lt;/returns&gt;
        public static DataGridRow GetRow(this DataGrid dataGrid, int rowIndex)
        {
            DataGridRow rowContainer = (DataGridRow)dataGrid.ItemContainerGenerator.ContainerFromIndex(rowIndex);
            if (rowContainer == null)
            {
                dataGrid.UpdateLayout();
                dataGrid.ScrollIntoView(dataGrid.Items[rowIndex]);
                rowContainer = (DataGridRow)dataGrid.ItemContainerGenerator.ContainerFromIndex(rowIndex);
            }
            return rowContainer;
        }

    }
}</code></pre> 
<p></p> 
<h4>4 事件LoadingRow</h4> 
<p>这里还有一个问题，testDateGrid中的Row我们是动态添加的，而且是通过变更数据源DataTable实现的，那我们需要一个事件：每添加一行之后就会触发。但是DateGrid并么有提供这样一个事件，只提供了LoadingRow，它在添加一行之前触发。这样的话，就没办法在事件中获取到当前新增的行对象。那边我们可以利用prism中的事件，利用LoadingRow构建 “<span style="color:#fe2c24;">LoadedRow</span>” 事件</p> 
<blockquote> 
 <p> 我接下来的操作会借助prism的事件，当然你可以替换成其他操作。prism的事件可参见博客：<a href="https://blog.csdn.net/songhuangong123/article/details/126478191#:~:text=%E5%8F%91%E5%B8%83-,%E3%80%90Prism%E7%B3%BB%E5%88%97%E3%80%91Prism%E4%BA%8B%E4%BB%B6%E8%81%9A%E5%90%88%E5%99%A8,-code%20bean" title="【Prism系列】Prism事件聚合器_code bean的博客-CSDN博客_prism 事件聚合器">【Prism系列】Prism事件聚合器_code bean的博客-CSDN博客_prism 事件聚合器</a></p> 
</blockquote> 
<pre><code class="language-cs">namespace BaseLibrary.MyEvent
{
    public class WaitEvent : PubSubEvent
    {
    }
}

//行增加事件
EventLoadingRow = new DelegateCommand&lt;DataGridRowEventArgs&gt;((e) =&gt; {
    _eventAggregator.GetEvent&lt;WaitEvent&gt;().Publish();
});

//确保在行增加之后发生：
_eventAggregator.GetEvent&lt;WaitEvent&gt;().Subscribe(() =&gt; {

//------省略代码
            
}, ThreadOption.UIThread);
</code></pre> 
<p>思路就是，在LoadingRow再发布一个事件，然后订阅这个事件的时候，使用ThreadOption.UIThread，这样就可以将 LoadingRow 变为 “<span style="color:#fe2c24;">LoadedRow</span>”</p> 
<h4>5 最后的设置</h4> 
<p>到这里，所以的准备工作就绪了，我得到了对象DateGrid testDateGrid，于是通过扩展方法GetRow就能得到行对象：</p> 
<pre><code class="language-cs">//获取每一行
var rowContainer = testDateGrid.GetRow(dtTest.Rows.Count - 1); </code></pre> 
<p>有了行对象，我们就能得到具体的cell：</p> 
<pre><code class="language-cs">// 根据每一行获取每一列
DataGridCell cell = testDateGrid.GetCell(rowContainer, i);</code></pre> 
<p>有了cell对象，我们就可以对每个cell进行设置：</p> 
<p>比如，设置某些cell不可编辑：cell.IsEnabled = false;</p> 
<p>比如，设置某些cell背景或者前景颜色：cell.Foreground = new SolidColorBrush(Colors.Green);</p> 
<blockquote> 
 <p>还有一点需要注意的是：这些设置会在表格排序后失效，所以我们一般需要禁用DateGrid的排序功能（将属性  CanUserSortColumns="False"）。</p> 
</blockquote> 
<h2></h2> 
<h2>DateGrid添加行自增序号</h2> 
<p>动态添加行的时候，如何给DateGrid添加行自增序号呢？这里我介绍一种简单的方法。</p> 
<p>记得之前，我给DateGrid添加了两个事件吗？LoadingRow 和 UnloadingRow。</p> 
<p>LoadingRow用于行数增加时，序号的递增。UnloadingRow用于行被删除时序号的重新排列：</p> 
<pre><code class="language-cs">//用于散出后的重新排序
EventUnloadingRow = new DelegateCommand&lt;DataGridRowEventArgs&gt;((e) =&gt; {
    if (testDateGrid.Items != null)
    {
        for (int i = 0; i &lt; testDateGrid.Items.Count; i++)
        {
            try
            {
                DataGridRow row = testDateGrid.ItemContainerGenerator.ContainerFromIndex(i) as DataGridRow;
                if (row != null)
                {
                    row.Header = $"[{ (i + 1)}]" ;
                }
            }
            catch { }
        }
    }
});

//行增加事件
EventLoadingRow = new DelegateCommand&lt;DataGridRowEventArgs&gt;((e) =&gt; {
    e.Row.Header = $"[{e.Row.GetIndex() + 1}]";
});
</code></pre> 
<h4>效果展示</h4> 
<p>过程中涉及动态的添加和删除，注意观察序号的变化：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/17/49/CWEu1waj_o.gif"></p> 
<p></p> 
<h2>2022年11月2日，内容更新</h2> 
<h3>如何实现Cell单元格的不可以编辑</h3> 
<p>需要要求有的cell可编辑，有个不可以，当获取到cell对象后，<strong>可直接这种cell.IsEnabled = false</strong></p> 
<p><strong>这样整个cell确实不可以编辑了，但是这样的话，整个cell不可用，会有一些副作用。</strong></p> 
<p><strong>比如，即使你设置了cell.ToolTip，也无法显示ToolTip提示了</strong>。</p> 
<p>你可能会想到isReadOnly属性，但整个数据本身就是只读的不可设置！（我TM也奇了怪了）</p> 
<p><span style="color:#fe2c24;"><strong>最后，发现有个属性能满足我的需求就是Focusable（cell.Focusable = false;）</strong></span></p> 
<p>既能实现不可编辑，又不妨碍ToolTip显示。</p> 
<p></p> 
<p>2022年12月30日，内容更新：</p> 
<h2>编辑单元格时获取单元格的行和列</h2> 
<p>CellEditEnding事件中，本来这样可以的：</p> 
<p>var d = sender as DataGrid;<br> int row_num = d.SelectedIndex;<br> int colum_num = e.Column.DisplayIndex;</p> 
<p><strong>但是，当DataGrid支持多选之后，SelectedIndex就永远为-1了</strong>（testDateGrid.SelectionMode = DataGridSelectionMode.Extended; //支持单元格多选）</p> 
<p>找了很多属性，发现就是没有此时行对应的属性！！！！！</p> 
<p>结果只能这样了：</p> 
<p><img alt="" height="508" src="https://images2.imgbox.com/b1/e6/8VZ5m8Nm_o.png" width="954"></p> 
<p> 就是新建行的时候把序号保存到row的Tag属性中！</p> 
<p>最后就变成在CellEditEnding事件中：</p> 
<p>int row_num = (int)e.Row.Tag;<br> int colum_num = e.Column.DisplayIndex;</p> 
<p></p> 
<p></p> 
<p></p> 
<h2>附录</h2> 
<pre><code class="language-cs">public class Tool
    {

        /// &lt;summary&gt;
        /// 根据类型查找子元素
        /// 调用形式：  List&lt;StackPanel&gt; initToolBarWeChatUserSp = GetChildObjects&lt;StackPanel&gt;(name, typeof(StackPanel));
        /// &lt;/summary&gt;
        /// &lt;typeparam name="T"&gt;查找类型&lt;/typeparam&gt;
        /// &lt;param name="obj"&gt;查询对象&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        static public List&lt;T&gt; GetChildObjects&lt;T&gt;(DependencyObject obj) where T : FrameworkElement
        {
            DependencyObject child = null;
            List&lt;T&gt; childList = new List&lt;T&gt;();
            
            Type typename = typeof(T);

            for (int i = 0; i &lt;= VisualTreeHelper.GetChildrenCount(obj) - 1; i++)
            {
                child = VisualTreeHelper.GetChild(obj, i);

                if (child is T &amp;&amp; (((T)child).GetType() == typename))
                {
                    childList.Add((T)child);
                }
                childList.AddRange(GetChildObjects&lt;T&gt;(child));
            }
            return childList;
        }


        static public T GetChildObjectFirst&lt;T&gt;(DependencyObject obj) where T : FrameworkElement
        {
            List&lt;T&gt; childList = new List&lt;T&gt;();

            childList = GetChildObjects&lt;T&gt;(obj);
            if (childList.Count &gt; 0)
            {
                return childList[0];
            }
            else
            {
                return null;
            }
            
        }



        /// &lt;summary&gt;
        /// 获取父可视对象中第一个指定类型的子可视对象
        /// &lt;/summary&gt;
        /// &lt;typeparam name="T"&gt;可视对象类型&lt;/typeparam&gt;
        /// &lt;param name="parent"&gt;父可视对象&lt;/param&gt;
        /// &lt;returns&gt;第一个指定类型的子可视对象&lt;/returns&gt;
        public static T GetVisualChild&lt;T&gt;(Visual parent) where T : Visual
        {
            T child = default(T);
            int numVisuals = VisualTreeHelper.GetChildrenCount(parent);
            for (int i = 0; i &lt; numVisuals; i++)
            {
                Visual v = (Visual)VisualTreeHelper.GetChild(parent, i);
                child = v as T;
                if (child == null)
                {
                    child = GetVisualChild&lt;T&gt;(v);
                }
                if (child != null)
                {
                    break;
                }
            }
            return child;
        }



        static public T GetChildObjectWithName&lt;T&gt;(DependencyObject obj, string name) where T : FrameworkElement
        {
            List&lt;T&gt; childList = new List&lt;T&gt;();

            childList = GetChildObjects&lt;T&gt;(obj);

            foreach (var item in childList)
            {
                if (item.Name == name)
                { 
                    return item;
                }
            }
            return null;
        }
    }</code></pre> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b8a1f5e3faa2d54a78d6010649099ad3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">新手学SpringCloud前需知道的5点</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/03842860cacfdce8dd67825bb00af75e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">批量删除多个 Word 文件中的多个关键字文字</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>