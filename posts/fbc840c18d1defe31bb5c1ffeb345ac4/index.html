<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Opencv中Mat类详细解读（学习笔记） - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Opencv中Mat类详细解读（学习笔记）" />
<meta property="og:description" content="基于windows10、vs2015、OpenCv4.1.0。
目录
1、Mat类简介
2、Mat类的构造与赋值
2.1、Mat类的构造
2.2、Mat类的赋值
3、Mat类支持的运算
3.1Mat类的加减乘除运算：
3.2两个Mat类矩阵的乘法运算
4、Mat类元素的读取
4.1多通道数据的存储
4.2Mat类常用属性和成员方法
4.3通过at读取Mat类单通道矩阵的元素
4.4通过at读取Mat类多通道矩阵的元素
4.5通过指针ptr读取Mat矩阵种的元素
4.6通过迭代器访问Mat类矩阵中的元素
1、Mat类简介 OpenCv提供了Mat类用来存储矩阵类型数据，包括向量、矩阵、图像等数据。Mat类分为分为矩阵头和指向存储数据的矩阵指针两部分。矩阵头包含矩阵的尺寸、存储方法、地址和引用次数。矩阵头是一个常数，绝大数情况下，矩阵头的大小远小于矩阵数据量的大小。
#include &lt;opencv2\opencv.hpp&gt; #include &lt;iostream&gt; using namespace std; using namespace cv; int main() { Mat a; a = imread(&#34;D:\\lena.jpg&#34;); //向a中赋值图像数据 Mat b = a;//只是复制了矩阵头和指向存储数据的指针（指向的是同一个矩阵数据） waitKey(); return 0; } 声明一个指定类型的Mat类：
Mat b = Mat_&lt;double&gt;(3, 3);//创建一个3*3的矩阵存放double类型数据 通过OpenCv数据类型创建Mat类
Mat a(640, 480, CV_8UC3)//创建一个640*480的3通道矩阵用于存放彩色图像 Mat a(3, 3, CV_8UC1);//创建一个3*3的8位无符号整数的单通道矩阵 Mat a(3, 3, CV_8U);//创建单通道矩阵，C1标识可以省略 2、Mat类的构造与赋值 2.1、Mat类的构造 默认构造函数
cv::Mat::Mat(); 这种构造方式，不需要传递任何参数，在后续给变量赋值的时候会自动判断矩阵的类型与大小，实现灵活的存储，常用于存储读取的图像数据和某个函数运算的输出结果。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/fbc840c18d1defe31bb5c1ffeb345ac4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-29T21:59:29+08:00" />
<meta property="article:modified_time" content="2021-12-29T21:59:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Opencv中Mat类详细解读（学习笔记）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>基于windows10、vs2015、OpenCv4.1.0。</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81Mat%E7%B1%BB%E7%AE%80%E4%BB%8B-toc" style="margin-left:0px;"><a href="#1%E3%80%81Mat%E7%B1%BB%E7%AE%80%E4%BB%8B" rel="nofollow">1、Mat类简介</a></p> 
<p id="2%E3%80%81Mat%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E8%B5%8B%E5%80%BC-toc" style="margin-left:0px;"><a href="#2%E3%80%81Mat%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E8%B5%8B%E5%80%BC" rel="nofollow">2、Mat类的构造与赋值</a></p> 
<p id="2.1%E3%80%81Mat%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0-toc" style="margin-left:40px;"><a href="#2.1%E3%80%81Mat%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0" rel="nofollow">2.1、Mat类的构造</a></p> 
<p id="2.2%E3%80%81Mat%E7%B1%BB%E7%9A%84%E8%B5%8B%E5%80%BC-toc" style="margin-left:40px;"><a href="#2.2%E3%80%81Mat%E7%B1%BB%E7%9A%84%E8%B5%8B%E5%80%BC" rel="nofollow">2.2、Mat类的赋值</a></p> 
<p id="3%E3%80%81Mat%E7%B1%BB%E6%94%AF%E6%8C%81%E7%9A%84%E8%BF%90%E7%AE%97-toc" style="margin-left:0px;"><a href="#3%E3%80%81Mat%E7%B1%BB%E6%94%AF%E6%8C%81%E7%9A%84%E8%BF%90%E7%AE%97" rel="nofollow">3、Mat类支持的运算</a></p> 
<p id="3.1Mat%E7%B1%BB%E7%9A%84%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E8%BF%90%E7%AE%97%EF%BC%9A-toc" style="margin-left:40px;"><a href="#3.1Mat%E7%B1%BB%E7%9A%84%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E8%BF%90%E7%AE%97%EF%BC%9A" rel="nofollow">3.1Mat类的加减乘除运算：</a></p> 
<p id="3.2%E4%B8%A4%E4%B8%AAMat%E7%B1%BB%E7%9F%A9%E9%98%B5%E7%9A%84%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97-toc" style="margin-left:40px;"><a href="#3.2%E4%B8%A4%E4%B8%AAMat%E7%B1%BB%E7%9F%A9%E9%98%B5%E7%9A%84%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97" rel="nofollow">3.2两个Mat类矩阵的乘法运算</a></p> 
<p id="4%E3%80%81Mat%E7%B1%BB%E5%85%83%E7%B4%A0%E7%9A%84%E8%AF%BB%E5%8F%96-toc" style="margin-left:0px;"><a href="#4%E3%80%81Mat%E7%B1%BB%E5%85%83%E7%B4%A0%E7%9A%84%E8%AF%BB%E5%8F%96" rel="nofollow">4、Mat类元素的读取</a></p> 
<p id="4.1%E5%A4%9A%E9%80%9A%E9%81%93%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8-toc" style="margin-left:40px;"><a href="#4.1%E5%A4%9A%E9%80%9A%E9%81%93%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8" rel="nofollow">4.1多通道数据的存储</a></p> 
<p id="%C2%A04.2Mat%E7%B1%BB%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E5%92%8C%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95-toc" style="margin-left:40px;"><a href="#%C2%A04.2Mat%E7%B1%BB%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E5%92%8C%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95" rel="nofollow"> 4.2Mat类常用属性和成员方法</a></p> 
<p id="4.3%E9%80%9A%E8%BF%87at%E8%AF%BB%E5%8F%96Mat%E7%B1%BB%E5%8D%95%E9%80%9A%E9%81%93%E7%9F%A9%E9%98%B5%E7%9A%84%E5%85%83%E7%B4%A0-toc" style="margin-left:40px;"><a href="#4.3%E9%80%9A%E8%BF%87at%E8%AF%BB%E5%8F%96Mat%E7%B1%BB%E5%8D%95%E9%80%9A%E9%81%93%E7%9F%A9%E9%98%B5%E7%9A%84%E5%85%83%E7%B4%A0" rel="nofollow">4.3通过at读取Mat类单通道矩阵的元素</a></p> 
<p id="4.4%E9%80%9A%E8%BF%87at%E8%AF%BB%E5%8F%96Mat%E7%B1%BB%E5%A4%9A%E9%80%9A%E9%81%93%E7%9F%A9%E9%98%B5%E7%9A%84%E5%85%83%E7%B4%A0-toc" style="margin-left:40px;"><a href="#4.4%E9%80%9A%E8%BF%87at%E8%AF%BB%E5%8F%96Mat%E7%B1%BB%E5%A4%9A%E9%80%9A%E9%81%93%E7%9F%A9%E9%98%B5%E7%9A%84%E5%85%83%E7%B4%A0" rel="nofollow">4.4通过at读取Mat类多通道矩阵的元素</a></p> 
<p id="4.5%E9%80%9A%E8%BF%87%E6%8C%87%E9%92%88ptr%E8%AF%BB%E5%8F%96Mat%E7%9F%A9%E9%98%B5%E7%A7%8D%E7%9A%84%E5%85%83%E7%B4%A0-toc" style="margin-left:40px;"><a href="#4.5%E9%80%9A%E8%BF%87%E6%8C%87%E9%92%88ptr%E8%AF%BB%E5%8F%96Mat%E7%9F%A9%E9%98%B5%E7%A7%8D%E7%9A%84%E5%85%83%E7%B4%A0" rel="nofollow">4.5通过指针ptr读取Mat矩阵种的元素</a></p> 
<p id="4.6%E9%80%9A%E8%BF%87%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BF%E9%97%AEMat%E7%B1%BB%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0-toc" style="margin-left:40px;"><a href="#4.6%E9%80%9A%E8%BF%87%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BF%E9%97%AEMat%E7%B1%BB%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0" rel="nofollow">4.6通过迭代器访问Mat类矩阵中的元素</a></p> 
<hr id="hr-toc"> 
<h2 id="1%E3%80%81Mat%E7%B1%BB%E7%AE%80%E4%BB%8B">1、Mat类简介</h2> 
<p>OpenCv提供了Mat类用来存储矩阵类型数据，包括向量、矩阵、图像等数据。Mat类分为分为矩阵头和指向存储数据的矩阵指针两部分。矩阵头包含矩阵的尺寸、存储方法、地址和引用次数。矩阵头是一个常数，绝大数情况下，矩阵头的大小远小于矩阵数据量的大小。</p> 
<pre><code>#include &lt;opencv2\opencv.hpp&gt;
#include &lt;iostream&gt;

using namespace std;
using namespace cv;

int main()
{
	Mat a;
	a = imread("D:\\lena.jpg"); //向a中赋值图像数据
	Mat b = a;//只是复制了矩阵头和指向存储数据的指针（指向的是同一个矩阵数据）
	waitKey();
	return 0;
}</code></pre> 
<p>声明一个指定类型的Mat类：</p> 
<pre><code>Mat b = Mat_&lt;double&gt;(3, 3);//创建一个3*3的矩阵存放double类型数据</code></pre> 
<p>通过OpenCv数据类型创建Mat类</p> 
<pre><code>Mat a(640, 480, CV_8UC3)//创建一个640*480的3通道矩阵用于存放彩色图像
Mat a(3, 3, CV_8UC1);//创建一个3*3的8位无符号整数的单通道矩阵
Mat a(3, 3, CV_8U);//创建单通道矩阵，C1标识可以省略</code></pre> 
<h2 id="2%E3%80%81Mat%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E8%B5%8B%E5%80%BC">2、Mat类的构造与赋值</h2> 
<h3 id="2.1%E3%80%81Mat%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0">2.1、Mat类的构造</h3> 
<p><span style="color:#fe2c24;"><strong>默认构造函数</strong></span></p> 
<pre><code>cv::Mat::Mat();</code></pre> 
<p> 这种构造方式，不需要传递任何参数，在后续给变量赋值的时候会自动判断矩阵的类型与大小，实现灵活的存储，常用于存储读取的图像数据和某个函数运算的输出结果。</p> 
<p><span style="color:#fe2c24;"><strong>根据输入矩阵尺寸和类型构造</strong></span></p> 
<pre><code>cv::Mat::Mat(int rows,int cols,int type)</code></pre> 
<p>其中rows:构造矩阵的行数；cols：矩阵的列数；type：矩阵存储的数据类型，例如CV_8UC1之类。</p> 
<p><span style="color:#fe2c24;"><strong>用Size（）结构构造Mat类。</strong></span></p> 
<pre><code>cv::Mat::Mat(Size size(), int type);</code></pre> 
<p>其中size：为二位数组变量尺寸，通过Size（cols，rows）进行赋值（<span style="color:#38d8f0;">列在前，行在后</span>）；type：矩阵存储的数据类型，例如CV_8UC1之类。</p> 
<p>示例：</p> 
<pre><code>cv::Mat a(Size(480,580), CV_8UC1);//构造一个行580，列480的单通道矩阵</code></pre> 
<p><span style="color:#fe2c24;"><strong>利用已有矩阵构造Mat类</strong></span></p> 
<pre><code>cv::Mat::Mat(const Mat &amp; a);</code></pre> 
<p>这种构造方式只是复制了Mat类的矩阵头，矩阵指针指向是同一个地址。（浅复制）</p> 
<p>若要深复制，可用</p> 
<pre><code>b = a.clone();</code></pre> 
<p><strong><span style="color:#fe2c24;">构造已有Mat的子类</span></strong></p> 
<pre><code>cv::Mat::Mat(const Mat &amp; a,const Range &amp; rowRange, const Range &amp; colRange=Range::all);</code></pre> 
<p>其中，m：已经构建完成的Mat；rowRange:在已有的矩阵中需要获取的行数范围，是一个Range变量，例如从第二行到第五行表示为Range(2,5);colRange也是一样，在已有的矩阵中需要获取的列数范围，是一个Range变量，例如从第二列到第五列表示为Range(2,5)省略时，所有的列都会被截取。（<span style="color:#be191c;">注意：这种方式构造的类与已有Mat类共享数据</span>。）</p> 
<p> 例如：</p> 
<pre><code>cv::Mat b(a, Range(2, 5), Range(1, 4));//从a中截取第二行到第五行，第一列到第四列的内容
cv::Mat b(a, Range(2, 5));//从a中截取第二行到第五行的内容</code></pre> 
<h3 id="2.2%E3%80%81Mat%E7%B1%BB%E7%9A%84%E8%B5%8B%E5%80%BC">2.2、Mat类的赋值</h3> 
<p><strong><span style="color:#fe2c24;">在构造时赋值</span></strong></p> 
<pre><code>cv::Mat::Mat(int rows, int cols, int type, const Scalar &amp; s)</code></pre> 
<p>其中rows：矩阵的行数； cols：矩阵的列数；type：存储数据的类型；s：给矩阵中每个橡树赋值的参数变量，例如Scalar（0，0，255）</p> 
<p>例如：</p> 
<pre><code>cv::Mat a(2, 2, CV_8UC3, cv::Scalar(0, 0, 255));//创建一个3通道矩阵，每个像素都是0，0，255
cv::Mat a(2, 2, CV_8UC2, cv::Scalar(0, 255));//创建一个2通道矩阵，每个像素都是0，255
cv::Mat a(2, 2, CV_8UC1, cv::Scalar(255));//创建一个单通道矩阵，每个像素都是255</code></pre> 
<p><span style="color:#fe2c24;"><strong> 枚举法赋值</strong></span>：</p> 
<pre><code>cv::Mat a= (cv::Mat_&lt;int&gt;(3,3)&lt;&lt;1,2,3,4,5,6,7,8,9);
cv::Mat a = (cv::Mat_&lt;double&gt;(2, 3) &lt;&lt; 1.0, 2.0, 3.0, 4.0, 5.0, 6.0);</code></pre> 
<p>第一行创建一个3*3的  矩阵，数据类型为int型，一行一行的存入。</p> 
<p><span style="color:#fe2c24;"><strong>循环法赋值：</strong></span></p> 
<pre><code>cv::Mat a = (cv::Mat_&lt;int&gt;(3, 3));//定义一个3*3的矩阵
for(int i = 0; i &lt; a.cols;i++) //矩阵行数循环
{
	for (int j; j &lt; a.cols; j++) //矩阵列数循环
	{
		a.at&lt;int&gt;(i, j) = i + j;
	}
}
</code></pre> 
<p><span style="color:#fe2c24;"><strong>利用类方法赋值示例：</strong></span></p> 
<pre><code>	cv::Mat a = cv::Mat::eye(3, 3, CV_8UC1);
	cv::Mat b = (cv::Mat_&lt;int&gt;(1, 3) &lt;&lt; 1, 2, 3);
	cv::Mat c = cv::Mat::diag(b);
	cv::Mat d = cv::Mat::ones(3, 3, CV_8UC1);
	cv::Mat e = cv::Mat::zeros(3, 2, CV_8UC3);</code></pre> 
<p>利用数组进行赋值：</p> 
<p></p> 
<h2 id="3%E3%80%81Mat%E7%B1%BB%E6%94%AF%E6%8C%81%E7%9A%84%E8%BF%90%E7%AE%97">3、Mat类支持的运算</h2> 
<h3 id="3.1Mat%E7%B1%BB%E7%9A%84%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E8%BF%90%E7%AE%97%EF%BC%9A"><span style="color:#fe2c24;"><strong>3.1Mat类的加减乘除运算：</strong></span></h3> 
<pre><code>cv::Mat a = (cv::Mat_&lt;int&gt;(3, 3) &lt;&lt; 1, 2, 3, 4, 5, 6, 7, 8, 9);
cv::Mat b = (cv::Mat_&lt;int&gt;(3, 3) &lt;&lt; 1, 2, 3, 4, 5, 6, 7, 8, 9);
cv::Mat c = (cv::Mat_&lt;double&gt;(3, 3) &lt;&lt; 1.0, 2.0, 3.0, 4.0,5.0, 6.0, 7.0, 8.0, 9.0);
cv::Mat d = (cv::Mat_&lt;double&gt;(3, 3) &lt;&lt; 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0);
cv::Mat e, f, g, h,i;
e = a + b;
f = c - d;
g = 2 * a;
h = d / 2.0;
i = a - 1;</code></pre> 
<p>当两个类进行加减运算时，需保证数据要一致，比如int和double类型数据的两个类不能进行加减运算。常数与Mat类变量运算，结果的数据类型保留Mat类变量的数据类型。</p> 
<h3 id="3.2%E4%B8%A4%E4%B8%AAMat%E7%B1%BB%E7%9F%A9%E9%98%B5%E7%9A%84%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97"><span style="color:#fe2c24;"><strong>3.2两个Mat类矩阵的乘法运算</strong></span></h3> 
<pre><code>cv::Mat a = (cv::Mat_&lt;int&gt;(3, 3) &lt;&lt; 1, 2, 3, 4, 5, 6, 7, 8, 9);
cv::Mat b = (cv::Mat_&lt;int&gt;(3, 3) &lt;&lt; 1, 2, 3, 4, 5, 6, 7, 8, 9);
cv::Mat c = (cv::Mat_&lt;double&gt;(3, 3) &lt;&lt; 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0);
cv::Mat d = (cv::Mat_&lt;double&gt;(3, 3) &lt;&lt; 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0);
cv::Mat e, f;
double k;
e = c*d;//数学乘积
k = a.dot(b);//内积
f=a.mul(b)//对应位乘积</code></pre> 
<h2 id="4%E3%80%81Mat%E7%B1%BB%E5%85%83%E7%B4%A0%E7%9A%84%E8%AF%BB%E5%8F%96">4、Mat类元素的读取</h2> 
<h3 id="4.1%E5%A4%9A%E9%80%9A%E9%81%93%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8"><span style="color:#fe2c24;"><strong>4.1多通道数据的存储</strong></span></h3> 
<p style="text-align:center;"><img alt="" height="253" src="https://images2.imgbox.com/ec/54/X8ckL1Lk_o.png" width="491"></p> 
<p style="text-align:center;">3通道3*3矩阵存储方式 </p> 
<p>先存储第一个元素的三个通道数据，再存储第二个元素三个通道数据。</p> 
<h3 id="%C2%A04.2Mat%E7%B1%BB%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E5%92%8C%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span style="color:#fe2c24;"><strong> 4.2Mat类常用属性和成员方法</strong></span></h3> 
<table border="1" cellpadding="1" cellspacing="1" style="width:443px;"><tbody><tr><td>属性</td><td style="width:252px;">作用</td></tr><tr><td>cols</td><td style="width:252px;">矩阵的列数</td></tr><tr><td>rows</td><td style="width:252px;">矩阵的行数</td></tr><tr><td>steps</td><td style="width:252px;">以字节为单位的有效宽度</td></tr><tr><td>dims</td><td style="width:252px;">矩阵的维度</td></tr><tr><td>成员方法</td><td style="width:252px;"></td></tr><tr><td>elemSize（）</td><td style="width:252px;">每个元素的字节数</td></tr><tr><td>total（）</td><td style="width:252px;">矩阵中元素的个数</td></tr><tr><td>channels（）</td><td style="width:252px;">矩阵的通道数</td></tr></tbody></table> 
<h3 id="4.3%E9%80%9A%E8%BF%87at%E8%AF%BB%E5%8F%96Mat%E7%B1%BB%E5%8D%95%E9%80%9A%E9%81%93%E7%9F%A9%E9%98%B5%E7%9A%84%E5%85%83%E7%B4%A0"><span style="color:#fe2c24;"><strong>4.3通过at读取Mat类</strong></span><span style="color:#1c7331;"><strong>单</strong></span><span style="color:#fe2c24;"><strong>通道矩阵的元素</strong></span></h3> 
<pre><code>	cv::Mat a = (cv::Mat_&lt;int&gt;(3, 3) &lt;&lt; 1, 2, 3, 4, 5, 6, 7, 8, 9);
	int b = a.at&lt;int&gt;(0, 0);</code></pre> 
<p>通过at读取元素需要跟上“&lt;数据类型&gt;”，类型不匹配则会报错。该方法以坐标的形式给出需要读取的元素坐标（行数，列数）。</p> 
<h3 id="4.4%E9%80%9A%E8%BF%87at%E8%AF%BB%E5%8F%96Mat%E7%B1%BB%E5%A4%9A%E9%80%9A%E9%81%93%E7%9F%A9%E9%98%B5%E7%9A%84%E5%85%83%E7%B4%A0"><strong><span style="color:#fe2c24;">4.4通过at读取Mat类</span><span style="color:#1c7331;">多</span></strong><span style="color:#fe2c24;"><strong>通道矩阵的元素</strong></span></h3> 
<p>因为单通道图像是一个二维矩阵，所以 a t方法的最后给出二维坐标即可访问对应位置元素。在OpenCv中，针对三通道，定义了，<span style="color:#1a439c;">cv::Vec3b、cv::Vec3s、cv::Vec3w、cv::Vec3d、cv::Vec3f、cv::Vec3i</span>共6种类型,其中数字表示通道数，最后一位是类型的缩写，b是uchar的缩写，s是short类型的缩写，w是ushort类型的缩写，d是double类型的缩写，f是float类型的缩写，i是int类型的缩写。</p> 
<p>举例说明：</p> 
<pre><code>	cv::Mat a(3,4,CV_8UC3,Scalar(2,0,255));
	cv::Vec3b b = a.at&lt;Vec3b&gt;(0, 0);
	int first = b[0];  //值为2
	int second = b.val[1];//值为0
	int third = b.val[2];//值为255</code></pre> 
<h3 id="4.5%E9%80%9A%E8%BF%87%E6%8C%87%E9%92%88ptr%E8%AF%BB%E5%8F%96Mat%E7%9F%A9%E9%98%B5%E7%A7%8D%E7%9A%84%E5%85%83%E7%B4%A0"><span style="color:#fe2c24;"><strong>4.5通过指针ptr读取Mat矩阵种的元素</strong></span></h3> 
<p>矩阵中每一行的每个元素都是挨着放的，如果能找到每一行元素的起始地址位置，那么读取矩阵中每一行不同位置的元素时将指针在起始位置向后移动若干位即可。</p> 
<pre><code>	cv::Mat a(3,4,CV_8UC3,Scalar(2,0,255));
	for (int i = 0; i &lt; a.rows;i++)
	{
		uchar *ptr = a.ptr&lt;uchar&gt;(i);
		for (int j = 0; j &lt; a.cols*a.channels(); j++)
		{
			cout &lt;&lt; (int)ptr[j] &lt;&lt; endl;
		}
	}</code></pre> 
<p>当读取第2行数据中第3个数据时，可直接用a.ptr&lt;uchar&gt;(1)[2]直接访问</p> 
<h3 id="4.6%E9%80%9A%E8%BF%87%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BF%E9%97%AEMat%E7%B1%BB%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0"><span style="color:#fe2c24;"><strong>4.6通过迭代器访问Mat类矩阵中的元素</strong></span></h3> 
<p> Mat类变量也是一个容器变量，故Mat类变量拥有迭代器，用于访问Mat变量中的数据，通过迭代器可以实现对矩阵中每一个元素的遍历。</p> 
<pre><code>	cv::Mat a = (cv::Mat_&lt;uchar&gt;(3, 3) &lt;&lt; 3, 4, 5, 1, 6, 7, 8, 0, 1);
	cv::MatIterator_&lt;uchar&gt; it = a.begin &lt; uchar &gt; ();
	cv::MatIterator_&lt;uchar&gt; it_end = a.end &lt; uchar &gt;();
	for (int i = 0;it!=it_end;it++)
	{
		cout &lt;&lt; (int)(*it) &lt;&lt; " ";
		if (++i%a.channels()==0)
		{
			cout &lt;&lt; endl;
		}

	}</code></pre> 
<p>Mat类的迭代器变量类型是cv::MatIterator_&lt; &gt;，在定义时同样需要在括号中声明数据的变量类型。Mat类迭代器的起始是Mat.begin&lt; &gt;()，结束是Mat.end&lt; &gt;()，与其他迭代器用法相同，通过“++”运算实现指针位置向下迭代，数据的读取方式是先读取第一个元素的每一个通道，之后再读取第二个元素的每一个通道，直到最后一个元素的最后一个通道。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3099c774fe8b87c39defd868da4fffd7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">dicom worklist、pacs环境搭建</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cb20a0e9be32712d27aed833f7fd8c1a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言如何跳出多重循环</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>