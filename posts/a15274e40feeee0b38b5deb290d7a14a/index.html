<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Nginx官方文档(五十)【ngx_google_perftools_module|ngx_stream_upstream_module】 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Nginx官方文档(五十)【ngx_google_perftools_module|ngx_stream_upstream_module】" />
<meta property="og:description" content="ngx_stream_ssl_preread_module 示例配置指令 ssl_preread 内嵌变量 ngx_stream_ssl_preread_module 模块（1.11.5）允许从 ClientHello 消息中提取信息，而不会终止 SSL/TLS，例如提取通过 SNI 请求的服务器名称。默认情况下不构建此模块，您可以在构建时使用 --with-stream_ssl_preread_module 配置参数启用此模块。
示例配置 map $ssl_preread_server_name $name { backend.example.com backend; default backend2; } upstream backend { server 192.168.0.1:12345; server 192.168.0.2:12345; } upstream backend2 { server 192.168.0.3:12345; server 192.168.0.4:12345; } server { listen 12346; proxy_pass $name; ssl_preread on; } 指令 google_perftools_profiles -说明语法ssl_preread on | off;默认ssl_preread off;上下文stream、server 启用在预读阶段 从 ClientHello 消息中提取信息。
内嵌变量 $ssl_preread_server_name
返回通过 SNI 请求的服务器名称
原文档 http://nginx.org/en/docs/ngx_google_perftools_module.html
ngx_stream_upstream_module 示例配置指令 upstreamserverzonestatehashleast_connleast_timerandomresolverresolver_timeout 内部变量 ngx_stream_upstream_module 模块（1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/a15274e40feeee0b38b5deb290d7a14a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-25T09:03:43+08:00" />
<meta property="article:modified_time" content="2020-09-25T09:03:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Nginx官方文档(五十)【ngx_google_perftools_module|ngx_stream_upstream_module】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="ngx_stream_ssl_preread_module_0"></a>ngx_stream_ssl_preread_module</h2> 
<ul><li><a href="#example_configuration" rel="nofollow">示例配置</a></li><li><a href="#directives" rel="nofollow">指令</a> 
  <ul><li><a href="#ssl_preread" rel="nofollow">ssl_preread</a></li></ul> </li><li><a href="#embedded_variables" rel="nofollow">内嵌变量</a></li></ul> 
<p><code>ngx_stream_ssl_preread_module</code> 模块（1.11.5）允许从 <a href="ClientHello" rel="nofollow">ClientHello</a> 消息中提取信息，而不会终止 SSL/TLS，例如提取通过 <a href="https://tools.ietf.org/html/rfc6066#section-3" rel="nofollow">SNI</a> 请求的服务器名称。默认情况下不构建此模块，您可以在构建时使用 <code>--with-stream_ssl_preread_module</code> 配置参数启用此模块。</p> 
<p><a id="example_configuration"></a></p> 
<h3><a id="_11"></a>示例配置</h3> 
<pre><code class="prism language-nginx">map $ssl_preread_server_name $name {
    backend.example.com      backend;
    default                  backend2;
}

upstream backend {
    server 192.168.0.1:12345;
    server 192.168.0.2:12345;
}

upstream backend2 {
    server 192.168.0.3:12345;
    server 192.168.0.4:12345;
}

server {
    listen      12346;
    proxy_pass  $name;
    ssl_preread on;
}
</code></pre> 
<p><a id="directives"></a></p> 
<h3><a id="_38"></a>指令</h3> 
<h4><a id="google_perftools_profiles_40"></a>google_perftools_profiles</h4> 
<table><thead><tr><th align="right">-</th><th>说明</th></tr></thead><tbody><tr><td align="right"><strong>语法</strong></td><td><strong>ssl_preread</strong> <code>on</code> | <code>off</code>;</td></tr><tr><td align="right"><strong>默认</strong></td><td>ssl_preread off;</td></tr><tr><td align="right"><strong>上下文</strong></td><td>stream、server</td></tr></tbody></table> 
<p>启用在<a href="stream_processing.md#preread_phase" rel="nofollow">预读阶段</a> 从 ClientHello 消息中提取信息。</p> 
<p><a id="embedded_variables"></a></p> 
<h3><a id="_52"></a>内嵌变量</h3> 
<ul><li> <p><code>$ssl_preread_server_name</code></p> <p>返回通过 SNI 请求的服务器名称</p> </li></ul> 
<h3><a id="_58"></a>原文档</h3> 
<p><a href="http://nginx.org/en/docs/ngx_google_perftools_module.html" rel="nofollow">http://nginx.org/en/docs/ngx_google_perftools_module.html</a></p> 
<hr> 
<h2><a id="ngx_stream_upstream_module_64"></a>ngx_stream_upstream_module</h2> 
<ul><li><a href="#example_configuration" rel="nofollow">示例配置</a></li><li><a href="#directives" rel="nofollow">指令</a> 
  <ul><li><a href="#upstream" rel="nofollow">upstream</a></li><li><a href="#server" rel="nofollow">server</a></li><li><a href="#zone" rel="nofollow">zone</a></li><li><a href="#state" rel="nofollow">state</a></li><li><a href="#hash" rel="nofollow">hash</a></li><li><a href="#least_conn" rel="nofollow">least_conn</a></li><li><a href="#least_time" rel="nofollow">least_time</a></li><li><a href="#random" rel="nofollow">random</a></li><li><a href="#resolver" rel="nofollow">resolver</a></li><li><a href="#resolver_timeout" rel="nofollow">resolver_timeout</a></li></ul> </li><li><a href="#embedded_variables" rel="nofollow">内部变量</a></li></ul> 
<p><code>ngx_stream_upstream_module</code> 模块（1.9.0）用于定义可以由 <a href="ngx_stream_proxy_module.md#proxy_pass" rel="nofollow">proxy_pass</a> 指令引用的服务器组。</p> 
<p><a id="example_configuration"></a></p> 
<h3><a id="_84"></a>示例配置</h3> 
<pre><code class="prism language-nginx">upstream backend {
    hash $remote_addr consistent;

    server backend1.example.com:12345  weight=5;
    server backend2.example.com:12345;
    server unix:/tmp/backend3;

    server backup1.example.com:12345   backup;
    server backup2.example.com:12345   backup;
}

server {
    listen 12346;
    proxy_pass backend;
}
</code></pre> 
<p>拥有定期运行<a href="ngx_stream_upstream_hc_module.md" rel="nofollow">健康检查</a>的动态可配置组为<a href="http://nginx.com/products/?_ga=2.130645319.99786210.1588592638-1615340879.1588592638" rel="nofollow">商业订阅</a>部分：</p> 
<pre><code class="prism language-nginx">resolver 10.0.0.1;

upstream dynamic {
    zone upstream_dynamic 64k;

    server backend1.example.com:12345 weight=5;
    server backend2.example.com:12345 fail_timeout=5s slow_start=30s;
    server 192.0.2.1:12345            max_fails=3;
    server backend3.example.com:12345 resolve;
    server backend4.example.com       service=http resolve;

    server backup1.example.com:12345  backup;
    server backup2.example.com:12345  backup;
}

server {
    listen 12346;
    proxy_pass dynamic;
    health_check;
}
</code></pre> 
<p><a id="directives"></a></p> 
<h3><a id="_131"></a>指令</h3> 
<h4><a id="upstream_133"></a>upstream</h4> 
<table><thead><tr><th align="right">-</th><th>说明</th></tr></thead><tbody><tr><td align="right"><strong>语法</strong></td><td><strong>upstream</strong> <code>name { ... }</code>;</td></tr><tr><td align="right"><strong>默认</strong></td><td>——</td></tr><tr><td align="right"><strong>上下文</strong></td><td>stream</td></tr></tbody></table> 
<p>定义一组服务器。服务器可以在不同的端口上监听。此外，可以将监听 TCP 和 UNIX 域套接字的服务器混合使用。</p> 
<p>示例：</p> 
<pre><code class="prism language-nginx">upstream backend {
    server backend1.example.com:12345 weight=5;
    server 127.0.0.1:12345            max_fails=3 fail_timeout=30s;
    server unix:/tmp/backend2;
    server backend3.example.com:12345 resolve;

    server backup1.example.com:12345  backup;
}
</code></pre> 
<p>默认使用加权轮询均衡算法在服务器间分配连接。在上面的示例中，每 7 个连接将如下分配：5 个连接转到 <code>backend1.example.com:12345</code>，一个连接到第二个和第三个服务器。如果在与服务器通信期间发生错误，则连接将被传递到下一个服务器，依此类推，直到尝试完所有正常运行的服务器为止。如果与所有服务器的通信都失败，则连接将关闭。</p> 
<h4><a id="server_158"></a>server</h4> 
<table><thead><tr><th align="right">-</th><th>说明</th></tr></thead><tbody><tr><td align="right"><strong>语法</strong></td><td><strong>server</strong> <code>address [parameters]</code>;</td></tr><tr><td align="right"><strong>默认</strong></td><td>——</td></tr><tr><td align="right"><strong>上下文</strong></td><td>upstream</td></tr></tbody></table> 
<p>定义服务器的地址（<code>address</code>）和其他参数。该地址可以指定为带有端口的域名或 IP 地址，也可以指定前缀为 <code>unix</code> 的 UNIX 域套接字路径。解析为多个 IP 地址的域名一次定义了多个服务器。</p> 
<p>可以定义以下参数：</p> 
<ul><li> <p><code>weight=number</code></p> <p>设置服务器的权重，默认情况下为 1。</p> </li><li> <p><code>max_conns=number</code></p> <p>限制到被代理服务器的最大同时连接数（1.11.5）。默认值为零，表示没有限制。如果服务器组未驻留在<a href="#zone" rel="nofollow">共享内存</a>中，则此限制在每个 worker 进程中均有效。</p> 
  <blockquote> 
   <p>在 1.11.5 版本之前，此参数作为<a href="http://nginx.com/products/?_ga=2.208745946.99786210.1588592638-1615340879.1588592638" rel="nofollow">商业订阅</a>部分。</p> 
  </blockquote> </li><li> <p><code>max_fails=number</code></p> <p>设置在 <code>fail_timeout</code> 参数设置的时间内与服务器通信的失败尝试次数，以便认定服务器在 <code>fail_timeout</code> 参数设置的时间内不可用。默认情况下，失败尝试的次数设置为 1。零值将禁用尝试记录。在这里，当与服务器正在建立连接中，失败尝试将是一个错误或超时。</p> </li><li> <p><code>fail_timeout=time</code></p> <p>设置</p> 
  <ul><li>在时间范围内与服务器通信的失败尝试达到指定次数，应将服务器视为不可用</li><li>服务器被视为不可用的时长</li></ul> <p>默认情况下，该参数设置为 10 秒。</p> </li><li> <p><code>backup</code></p> <p>将服务器标记为备用服务器。当主服务器不可用时，连接将传递到备用服务器。</p> 
  <blockquote> 
   <p>该参数不能与 <a href="#hash" rel="nofollow">hash</a> 和 <a href="#random" rel="nofollow">random</a> 负载均衡算法一起使用。</p> 
  </blockquote> </li><li> <p><code>down</code></p> <p>将服务器标记为永久不可用。</p> </li></ul> 
<p>此外，以下参数作为<a href="http://nginx.com/products/?_ga=2.134173126.99786210.1588592638-1615340879.1588592638" rel="nofollow">商业订阅</a>部分提供：</p> 
<ul><li> <p><code>resolve</code></p> <p>监视与服务器域名相对应的 IP 地址的更改，并自动修改 upstream 配置，而无需重新启动 nginx。服务器组必须驻留在<a href="#zone" rel="nofollow">共享内存</a>中。</p> <p>为了使此参数生效，必须在 <a href="ngx_stream_core_module.md#resolver" rel="nofollow">stream</a> 块或相应的 <a href="#resolver" rel="nofollow">upstream</a> 块中指定 <code>resolver</code> 指令。</p> </li><li> <p><code>service=name</code></p> <p>启用 DNS <a href="https://tools.ietf.org/html/rfc2782" rel="nofollow">SRV</a> 记录的解析并设置服务名称（1.9.13）。为了使此参数生效，必须为服务器指定 <a href="#resolve" rel="nofollow">resolve</a> 参数，并指定不带端口号的主机名。</p> <p>如果服务名称不包含点（<code>.</code>），则构造符合 <a href="https://tools.ietf.org/html/rfc2782" rel="nofollow">RFC</a> 的名称，并将 TCP 协议添加到服务前缀。例如，要查找 <code>_http._tcp.backend.example.com</code> SRV 记录，必须指定指令：</p> <p>如果服务名称包含一个或多个点（<code>.</code>），则通过将服务前缀和服务器名称结合在一起来构造名称。例如，要查找 <code>_http._tcp.backend.example.com</code> 和 <code>server1.backend.example.com</code> SRV 记录，必须指定指令：</p> <pre><code class="prism language-nginx">server backend.example.com service=_http._tcp resolve;
server example.com service=server1.backend resolve;
</code></pre> <p>最高优先级的 SRV 记录（具有相同的最低优先级值的记录）被解析为主服务器，其余的 SRV 记录被解析为备用服务器。如果为服务器指定了 <a href="#backup" rel="nofollow">backup</a> 参数，则将高优先级 SRV 记录解析为备用服务器，其余的 SRV 记录将被忽略。</p> </li><li> <p><code>slow_start=time</code></p> <p>设置当服务器从非健康状态转为健康状态或一段时间<a href="#fail_timeout" rel="nofollow">不可用</a>后转为可用状态，服务器将其权重从 0 恢复到原值的时间（<code>time</code>）。默认值为零，即禁用此功能。</p> 
  <blockquote> 
   <p>该参数不能与 <a href="#hash" rel="nofollow">hash</a> 和 <a href="#random" rel="nofollow">random</a> 负载均衡算法一起使用。</p> 
  </blockquote> </li></ul> 
<p>如果组中只有一台服务器，则将忽略 <code>max_fails</code>、<code>fail_timeout</code> 和 <code>slow_start</code> 参数，这样的服务器将永远不会被视为不可用。</p> 
<h4><a id="zone_234"></a>zone</h4> 
<table><thead><tr><th align="right">-</th><th>说明</th></tr></thead><tbody><tr><td align="right"><strong>语法</strong></td><td><strong>zone</strong> <code>name [size]</code>;</td></tr><tr><td align="right"><strong>默认</strong></td><td>——</td></tr><tr><td align="right"><strong>上下文</strong></td><td>upstream</td></tr></tbody></table> 
<p>定义共享内存区域的名称（<code>name</code>）和大小（<code>size</code>），以存储 worker 进程之间共享的组配置和运行时状态。多个组可共享同一区域。在这种情况下，仅指定一次大小就足够了。</p> 
<p>另外，在<a href="http://nginx.com/products/?_ga=2.171473384.99786210.1588592638-1615340879.1588592638" rel="nofollow">商业订阅</a>部分中，此类组允许更改组成员身份或修改特定服务器的设置，而无需重新启动 nginx。可通过 <a href="../http/ngx_http_api_module.md" rel="nofollow">API</a> 模块（1.13.3）访问该配置。</p> 
<blockquote> 
 <p>在 1.13.3 版本之前，只能访问特殊的 location 来通过 <a href="../http/ngx_http_upstream_conf_module.md#upstream_conf" rel="nofollow">upstream_conf</a> 处理。</p> 
</blockquote> 
<h4><a id="state_248"></a>state</h4> 
<table><thead><tr><th align="right">-</th><th>说明</th></tr></thead><tbody><tr><td align="right"><strong>语法</strong></td><td><strong>state</strong> <code>file</code>;</td></tr><tr><td align="right"><strong>默认</strong></td><td>——</td></tr><tr><td align="right"><strong>上下文</strong></td><td>upstream</td></tr><tr><td align="right"><strong>提示</strong></td><td>该指令在 1.9.7 版本中出现</td></tr></tbody></table> 
<p>指定一个文件用于保存动态可配置组的状态。</p> 
<p>示例：</p> 
<pre><code class="prism language-nginx">state /var/lib/nginx/state/servers.conf; # path for Linux
state /var/db/nginx/state/servers.conf;  # path for FreeBSD
</code></pre> 
<p>当前状态仅限于带有参数的服务器列表。解析配置时会读取该文件，并且每次更改 upstream 配置时都会<a href="../http/ngx_http_api_module.md#stream_upstreams_stream_upstream_name_servers_" rel="nofollow">更新</a>该文件。应避免直接更改文件内容。该指令不能与 <a href="#server" rel="nofollow">server</a> 指令一起使用。</p> 
<blockquote> 
 <p>在<a href="../../%E4%BB%8B%E7%BB%8D/%E6%8E%A7%E5%88%B6nginx.md#reconfiguration" rel="nofollow">配置重新加载</a>或<a href="../../%E4%BB%8B%E7%BB%8D/%E6%8E%A7%E5%88%B6nginx.md#upgrade" rel="nofollow">二进制升级</a>期间所做的更改可能会丢失。</p> 
</blockquote> 
<blockquote> 
 <p>该指令为<a href="http://nginx.com/products/?_ga=2.128922308.99786210.1588592638-1615340879.1588592638" rel="nofollow">商业订阅</a>部分。</p> 
</blockquote> 
<h4><a id="hash_272"></a>hash</h4> 
<table><thead><tr><th align="right">-</th><th>说明</th></tr></thead><tbody><tr><td align="right"><strong>语法</strong></td><td><strong>hash</strong> <code>key [consistent]</code>;</td></tr><tr><td align="right"><strong>默认</strong></td><td>——</td></tr><tr><td align="right"><strong>上下文</strong></td><td>upstream</td></tr></tbody></table> 
<p>指定服务器组的负载均衡算法，在该服务器组中，客户端——服务器的映射基于哈希键值（key/value）。key 可以包含文本、变量及其组合（1.11.2）。 用法示例：</p> 
<pre><code class="prism language-nginx">hash $remote_addr;
</code></pre> 
<p>请注意，从组中添加或删除服务器可能会导致大量 key 重新映射到其他服务器。该方法与 <a href="https://metacpan.org/pod/Cache::Memcached" rel="nofollow">Cache::Memcached</a> Perl 库兼容。</p> 
<p>如果指定了 <code>consistent</code> 参数，则将使用 <a href="https://www.metabrew.com/article/libketama-consistent-hashing-algo-memcached-clients" rel="nofollow">ketama</a> 一致性哈希算法。该方法可确保在将服务器添加到组中或从组中删除服务器时，只有很少的 key 被重新映射到不同的服务器。这有助于缓存服务器实现更高的缓存命中率。该方法与 <code>ketama_points</code> 参数设置为 160 的 <a href="https://metacpan.org/pod/Cache::Memcached::Fast" rel="nofollow">Cache::Memcached::Fast</a> Perl 库兼容。</p> 
<h4><a id="least_conn_290"></a>least_conn</h4> 
<table><thead><tr><th align="right">-</th><th>说明</th></tr></thead><tbody><tr><td align="right"><strong>语法</strong></td><td><strong>least_conn</strong>;</td></tr><tr><td align="right"><strong>默认</strong></td><td>——</td></tr><tr><td align="right"><strong>上下文</strong></td><td>upstream</td></tr></tbody></table> 
<p>指定组使用的负载均衡算法，其将连接传递到活动连接数最少的服务器，同时要考虑服务器的权重。如果有多个这样的服务器，则依次使用加权轮询均衡算法进行尝试。</p> 
<h4><a id="least_time_300"></a>least_time</h4> 
<table><thead><tr><th align="right">-</th><th>说明</th></tr></thead><tbody><tr><td align="right"><strong>语法</strong></td><td><strong>least_time</strong> <code>connect</code> | <code>first_byte</code> | <code>last_byte</code> <code>[inflight]</code>;</td></tr><tr><td align="right"><strong>默认</strong></td><td>——</td></tr><tr><td align="right"><strong>上下文</strong></td><td>upstream</td></tr></tbody></table> 
<p>指定组应使用的负载均衡算法，其将连接传递到平均时间最少且活动连接数最少的服务器，同时考虑服务器的权重。如果有多个这样的服务器，则依次使用加权轮询均衡算法进行尝试。</p> 
<p>如果指定了 <code>connect</code> 参数，则使用<a href="#var_upstream_connect_time" rel="nofollow">连接</a>到 upstream 服务器的时间。如果指定了 <code>first_byte</code> 变量，则使用接收数据的<a href="#var_upstream_first_byte_time" rel="nofollow">首字节</a>的时间。如果指定了 <code>last_byte</code>，则使用接收数据<a href="#var_upstream_session_time" rel="nofollow">尾字节</a>的时间。如果指定了 <code>inflight</code> 参数（1.11.6），还将考虑不完整连接。</p> 
<blockquote> 
 <p>在 1.11.6 版本之前，默认情况下会考虑不完整的连接。</p> 
</blockquote> 
<blockquote> 
 <p>该指令作为<a href="http://nginx.com/products/?_ga=2.162551156.99786210.1588592638-1615340879.1588592638" rel="nofollow">商业订阅</a>部分。</p> 
</blockquote> 
<h4><a id="random_316"></a>random</h4> 
<table><thead><tr><th align="right">-</th><th>说明</th></tr></thead><tbody><tr><td align="right"><strong>语法</strong></td><td><strong>random</strong> <code>[two [method]]</code>;</td></tr><tr><td align="right"><strong>默认</strong></td><td>——</td></tr><tr><td align="right"><strong>上下文</strong></td><td>upstream</td></tr><tr><td align="right"><strong>提示</strong></td><td>该指令在 1.15.1 版本中出现</td></tr></tbody></table> 
<p>指定组应使用的负载均衡算法，其将连接传递到随机选择的服务器，同时要考虑服务器的权重。</p> 
<p>可选的两个参数指示 nginx 随机选择<a href="https://homes.cs.washington.edu/~karlin/papers/balls.pdf" rel="nofollow">两个</a>服务器，然后使用指定的算法（<code>method</code>）选择一个服务器。默认方法是 <code>minimum_conn</code>，它将连接传递到活动连接数最少的服务器。</p> 
<p><code>minimum_time</code> 算法将连接传递到平均时间最少且活动连接数最少的服务器。如果指定了 <code>least_time=connect</code> 参数，则使用<a href="#var_upstream_connect_time" rel="nofollow">连接</a>到 upstream 服务器的时间。如果指定了 <code>least_time=first_byte</code> 参数，则使用接收数据的<a href="#var_upstream_first_byte_time" rel="nofollow">首字节</a>的时间。如果指定了 <code>least_time=last_byte</code>，如果指定了 <code>last_byte</code>，则使用接收数据<a href="#var_upstream_session_time" rel="nofollow">尾字节</a>的时间。</p> 
<blockquote> 
 <p><code>least_time</code> 算法是<a href="http://nginx.com/products/?_ga=2.200372710.99786210.1588592638-1615340879.1588592638" rel="nofollow">商业订阅</a>部分。</p> 
</blockquote> 
<h4><a id="resolver_333"></a>resolver</h4> 
<table><thead><tr><th align="right">-</th><th>说明</th></tr></thead><tbody><tr><td align="right"><strong>语法</strong></td><td><strong>resolver</strong> <code>address ... [valid=time] [ipv6=on\|off] [status_zone=zone]</code>;</td></tr><tr><td align="right"><strong>默认</strong></td><td>——</td></tr><tr><td align="right"><strong>上下文</strong></td><td>upstream</td></tr><tr><td align="right"><strong>提示</strong></td><td>该指令在 1.17.5 版本中出现</td></tr></tbody></table> 
<p>配置用于将 upstream 服务器的名称解析为地址的名称服务器，例如：</p> 
<pre><code class="prism language-nginx">resolver 127.0.0.1 [::1]:5353;
</code></pre> 
<p>可以将地址指定为域名或 IP 地址，配置一个可选端口。如果未指定端口，则使用 53 端口。以轮询算法查找名称服务器。</p> 
<p>默认情况下，nginx 在解析时将同时查找 IPv4 和 IPv6 地址。如果不需要查找 IPv6 地址，则可以指定 <code>ipv6=off</code> 参数。</p> 
<p>默认情况下，nginx 使用响应的 TTL 值缓存回复。可选的 <code>valid</code> 参数覆盖默认行为：</p> 
<pre><code class="prism language-nginx">resolver 127.0.0.1 [::1]:5353 valid=30s;
</code></pre> 
<blockquote> 
 <p>为防止 DNS 欺骗，建议在一个受到保护的可信本地网络中配置 DNS 服务器。</p> 
</blockquote> 
<p>可选的 <code>status_zone</code> 参数启用对指定区域中请求和响应的 DNS 服务器统计信息的<a href="../../http/ngx_http_api_module.md#resolvers_" rel="nofollow">收集</a>。</p> 
<blockquote> 
 <p>该指令为<a href="http://nginx.com/products/?_ga=2.175591914.99786210.1588592638-1615340879.1588592638" rel="nofollow">商业订阅</a>部分。</p> 
</blockquote> 
<h4><a id="resolver_timeout_364"></a>resolver_timeout</h4> 
<table><thead><tr><th align="right">-</th><th>说明</th></tr></thead><tbody><tr><td align="right"><strong>语法</strong></td><td><strong>resolver_timeout</strong> <code>time</code>;</td></tr><tr><td align="right"><strong>默认</strong></td><td>resolver_timeout 30s;</td></tr><tr><td align="right"><strong>上下文</strong></td><td>upstream</td></tr><tr><td align="right"><strong>提示</strong></td><td>该指令在 1.17.5 版本中出现</td></tr></tbody></table> 
<p>为名称解析设置一个超时时间，例如：</p> 
<pre><code class="prism language-nginx">resolver_timeout 5s;
</code></pre> 
<blockquote> 
 <p>该指令为<a href="http://nginx.com/products/?_ga=2.133192262.99786210.1588592638-1615340879.1588592638" rel="nofollow">商业订阅</a>部分。</p> 
</blockquote> 
<p><a id="embedded_variables"></a></p> 
<h3><a id="_383"></a>内部变量</h3> 
<p><code>ngx_stream_upstream_module</code> 模块支持以下内部变量：</p> 
<ul><li> <p><code>$upstream_addr</code></p> <p>保留 IP 地址和端口或 upstream 服务器的 UNIX 域套接字（1.11.4）路径。如果在代理过程中联系了多个服务器，则它们的地址用逗号分隔，例如 <code>192.168.1.1:12345, 192.168.1.2:12345, unix:/tmp/sock</code>。如果无法选择服务器，则该变量将保留服务器组的名称。</p> </li><li> <p><code>$upstream_bytes_received</code></p> <p>从 upstream 服务器收到的字节数（1.11.4）。来自多个连接的值使用逗号分隔，参考 <code>$upstream_addr</code> 变量中的地址。</p> </li><li> <p><code>$upstream_bytes_sent</code></p> <p>发送到 upstream 服务器的字节数（1.11.4）。来自多个连接的值使用逗号分隔，参考 <code>$upstream_addr</code> 变量中的地址。</p> </li><li> <p><code>$upstream_connect_time</code></p> <p>连接 upstream 服务器的时间（1.11.4），时间以毫秒为单位，以秒为单位。多个连接的时间用逗号分隔，参考 <code>$upstream_addr</code> 变量中的地址。</p> </li><li> <p><code>$upstream_first_byte_time</code></p> <p>接收数据的第一个字节的时间（1.11.4），时间以毫秒为单位，以秒为单位。多个连接的时间用逗号分隔，参考 <code>$upstream_addr</code> 变量中的地址。</p> </li><li> <p><code>$upstream_session_time</code></p> <p>会话持续时间，以毫秒为单位，以毫秒为单位（1.11.4）。多个连接的时间用逗号分隔，参考 <code>$upstream_addr</code> 变量中的地址。</p> </li></ul> 
<h3><a id="_411"></a>原文档</h3> 
<p><a href="http://nginx.org/en/docs/stream/ngx_stream_upstream_module.html" rel="nofollow">http://nginx.org/en/docs/stream/ngx_stream_upstream_module.html</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e3a66a845ee883a6d85f1acefd18f75a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Kubernetes K8S之kubectl命令详解及常用示例</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6cf23c932f8f03a654e9e6f5042fc120/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">简述http与https的区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>