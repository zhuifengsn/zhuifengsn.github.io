<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>poj 1062 昂贵的聘礼 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="poj 1062 昂贵的聘礼" />
<meta property="og:description" content="昂贵的聘礼
Time Limit: 1000MS Memory Limit: 10000KTotal Submissions: 64699 Accepted: 19696 Description
年轻的探险家来到了一个印第安部落里。在那里他和酋长的女儿相爱了，于是便向酋长去求亲。酋长要他用10000个金币作为聘礼才答应把女儿嫁给他。探险家拿不出这么多金币，便请求酋长降低要求。酋长说：&#34;嗯，如果你能够替我弄到大祭司的皮袄，我可以只要8000金币。如果你能够弄来他的水晶球，那么只要5000金币就行了。&#34;探险家就跑到大祭司那里，向他要求皮袄或水晶球，大祭司要他用金币来换，或者替他弄来其他的东西，他可以降低价格。探险家于是又跑到其他地方，其他人也提出了类似的要求，或者直接用金币换，或者找到其他东西就可以降低价格。不过探险家没必要用多样东西去换一样东西，因为不会得到更低的价格。探险家现在很需要你的帮忙，让他用最少的金币娶到自己的心上人。另外他要告诉你的是，在这个部落里，等级观念十分森严。地位差距超过一定限制的两个人之间不会进行任何形式的直接接触，包括交易。他是一个外来人，所以可以不受这些限制。但是如果他和某个地位较低的人进行了交易，地位较高的的人不会再和他交易，他们认为这样等于是间接接触，反过来也一样。因此你需要在考虑所有的情况以后给他提供一个最好的方案。
为了方便起见，我们把所有的物品从1开始进行编号，酋长的允诺也看作一个物品，并且编号总是1。每个物品都有对应的价格P，主人的地位等级L，以及一系列的替代品Ti和该替代品所对应的&#34;优惠&#34;Vi。如果两人地位等级差距超过了M，就不能&#34;间接交易&#34;。你必须根据这些数据来计算出探险家最少需要多少金币才能娶到酋长的女儿。
Input
输入第一行是两个整数M，N（1 &lt;= N &lt;= 100），依次表示地位等级差距限制和物品的总数。接下来按照编号从小到大依次给出了N个物品的描述。每个物品的描述开头是三个非负整数P、L、X（X &lt; N），依次表示该物品的价格、主人的地位等级和替代品总数。接下来X行每行包括两个整数T和V，分别表示替代品的编号和&#34;优惠价格&#34;。
Output
输出最少需要的金币数。
Sample Input
1 4 10000 3 2 2 8000 3 5000 1000 2 1 4 200 3000 2 1 4 200 50 2 0 Sample Output
5250 Source
浙江
老早看到的一道题，一直没有机会做，老经典题了。
可以把每个物品看做一个点，然而由于每个物品本身具有价值，因此我们引入点0，将物品本身的价值看做点0到该物品的价值。然后如果一个物品A可以换另一个物品B，则画一条A到B的边，最后计算点0到每个点的最短距离。（注意是谁到谁，如果弄不清楚最好画一个图再写）。
关于等级限制的问题，这里采用枚举的方法。限制是一条路中任意两个点等级差距不能超过m。然后我们每次列举当前最小等级minrank，然后去掉超出等级限制的点，最后直接跑迪杰特斯拉。
#include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;queue&gt; using namespace std; const int MAXN=120; const int inf=0x3f3f3f3f; int ma[MAXN][MAXN]; int price[MAXN],rk[MAXN]; int vis[MAXN]; void ini(int n){ memset(ma,0x3f,sizeof(ma)); for(int i=0;i&lt;=n;i&#43;&#43;){ ma[i][i]=0; } } int dji(int n){ int dis[MAXN]; memset(dis,0,sizeof(dis)); for(int i=0;i&lt;=n;i&#43;&#43;){ dis[i]=ma[0][i]; } vis[0]=1; for(int i=0;i&lt;n-1;i&#43;&#43;){ int u=-1,minn=inf; for(int j=0;j&lt;=n;j&#43;&#43;){ if(vis[j]==0&amp;&amp;minn&gt;dis[j]){ u=j;minn=dis[j]; } } vis[u]=1; for(int j=0;j&lt;=n;j&#43;&#43;){ if(vis[j]==0&amp;&amp;dis[j]&gt;dis[u]&#43;ma[u][j]){ dis[j]=dis[u]&#43;ma[u][j]; } } } return dis[1]; } int main(){ int m,n; scanf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/582796e902f49946d4acf10155189f25/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-14T21:50:03+08:00" />
<meta property="article:modified_time" content="2020-09-14T21:50:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">poj 1062 昂贵的聘礼</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>昂贵的聘礼</p> 
<table align="center"><tbody><tr><td><strong>Time Limit:</strong> 1000MS</td><td> </td><td><strong>Memory Limit:</strong> 10000K</td></tr><tr><td><strong>Total Submissions:</strong> 64699</td><td> </td><td><strong>Accepted:</strong> 19696</td></tr></tbody></table> 
<p>Description</p> 
<p>年轻的探险家来到了一个印第安部落里。在那里他和酋长的女儿相爱了，于是便向酋长去求亲。酋长要他用10000个金币作为聘礼才答应把女儿嫁给他。探险家拿不出这么多金币，便请求酋长降低要求。酋长说："嗯，如果你能够替我弄到大祭司的皮袄，我可以只要8000金币。如果你能够弄来他的水晶球，那么只要5000金币就行了。"探险家就跑到大祭司那里，向他要求皮袄或水晶球，大祭司要他用金币来换，或者替他弄来其他的东西，他可以降低价格。探险家于是又跑到其他地方，其他人也提出了类似的要求，或者直接用金币换，或者找到其他东西就可以降低价格。不过探险家没必要用多样东西去换一样东西，因为不会得到更低的价格。探险家现在很需要你的帮忙，让他用最少的金币娶到自己的心上人。另外他要告诉你的是，在这个部落里，等级观念十分森严。地位差距超过一定限制的两个人之间不会进行任何形式的直接接触，包括交易。他是一个外来人，所以可以不受这些限制。但是如果他和某个地位较低的人进行了交易，地位较高的的人不会再和他交易，他们认为这样等于是间接接触，反过来也一样。因此你需要在考虑所有的情况以后给他提供一个最好的方案。<br> 为了方便起见，我们把所有的物品从1开始进行编号，酋长的允诺也看作一个物品，并且编号总是1。每个物品都有对应的价格P，主人的地位等级L，以及一系列的替代品Ti和该替代品所对应的"优惠"Vi。如果两人地位等级差距超过了M，就不能"间接交易"。你必须根据这些数据来计算出探险家最少需要多少金币才能娶到酋长的女儿。</p> 
<p>Input</p> 
<p>输入第一行是两个整数M，N（1 &lt;= N &lt;= 100），依次表示地位等级差距限制和物品的总数。接下来按照编号从小到大依次给出了N个物品的描述。每个物品的描述开头是三个非负整数P、L、X（X &lt; N），依次表示该物品的价格、主人的地位等级和替代品总数。接下来X行每行包括两个整数T和V，分别表示替代品的编号和"优惠价格"。</p> 
<p>Output</p> 
<p>输出最少需要的金币数。</p> 
<p>Sample Input</p> 
<pre><code class="language-html hljs">1 4
10000 3 2
2 8000
3 5000
1000 2 1
4 200
3000 2 1
4 200
50 2 0
</code></pre> 
<p>Sample Output</p> 
<pre><code class="language-html hljs">5250</code></pre> 
<p>Source</p> 
<p><a href="http://poj.org/searchproblem?field=source&amp;key=%E6%B5%99%E6%B1%9F" rel="nofollow">浙江</a></p> 
<p>    老早看到的一道题，一直没有机会做，老经典题了。</p> 
<p>    可以把每个物品看做一个点，然而由于每个物品本身具有价值，因此我们引入点0，将物品本身的价值看做点0到该物品的价值。然后如果一个物品A可以换另一个物品B，则画一条A到B的边，最后计算点0到每个点的最短距离。（注意是谁到谁，如果弄不清楚最好画一个图再写）。</p> 
<p>    关于等级限制的问题，这里采用枚举的方法。限制是一条路中任意两个点等级差距不能超过m。然后我们每次列举当前最小等级minrank，然后去掉超出等级限制的点，最后直接跑迪杰特斯拉。</p> 
<p> </p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;queue&gt;
using namespace std;
const int MAXN=120;
const int inf=0x3f3f3f3f;
int ma[MAXN][MAXN];
int price[MAXN],rk[MAXN];
int vis[MAXN];

void ini(int n){
    memset(ma,0x3f,sizeof(ma));
    for(int i=0;i&lt;=n;i++){
        ma[i][i]=0;
    }
}


int dji(int n){
    int dis[MAXN];
    memset(dis,0,sizeof(dis));
    for(int i=0;i&lt;=n;i++){
        dis[i]=ma[0][i];
    }
    vis[0]=1;
    for(int i=0;i&lt;n-1;i++){
        int u=-1,minn=inf;
        for(int j=0;j&lt;=n;j++){
            if(vis[j]==0&amp;&amp;minn&gt;dis[j]){
                u=j;minn=dis[j];
            }
        }
        vis[u]=1;
        for(int j=0;j&lt;=n;j++){
            if(vis[j]==0&amp;&amp;dis[j]&gt;dis[u]+ma[u][j]){
                dis[j]=dis[u]+ma[u][j];
            }
        }
    }
    return dis[1];
}

int main(){
    int m,n;
    scanf("%d%d",&amp;m,&amp;n);
    ini(n);
    for(int i=1;i&lt;=n;i++){
        int a,b,c;
        scanf("%d%d%d",&amp;a,&amp;b,&amp;c);
        price[i]=a;
        ma[0][i]=a;
        rk[i]=b;
        for(int j=0;j&lt;c;j++){
            int id,pr;
            scanf("%d%d",&amp;id,&amp;pr);
//          from i to id cost pr
            ma[id][i]=pr;
        }
    }
    int ans=inf;
    // rk[i] is the least rank in the path
    for(int i=1;i&lt;=n;i++){
        int minrank=rk[i];
        memset(vis,0,sizeof(vis));
        if(!(rk[1]-minrank&gt;=0&amp;&amp;rk[1]-minrank&lt;=m)){
            continue;
        }
        for(int j=1;j&lt;=n;j++){
            if(rk[j]-minrank&gt;m||minrank&gt;rk[j]){
                vis[j]=1;
            }
        }
        ans=min(ans,dji(n));

    }
    printf("%d\n",ans);
    return 0;
}
</code></pre> 
<p>做了一些玄学优化（堆优化迪杰特斯拉+set去重），然后可能数据比较弱，结果并没有什么变化（摊手）</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
using namespace std;
const int MAXN=120;
const int inf=0x3f3f3f3f;
int ma[MAXN][MAXN];
int price[MAXN],rk[MAXN];
int vis[MAXN];

void ini(int n){
    memset(ma,0x3f,sizeof(ma));
    for(int i=0;i&lt;=n;i++){
        ma[i][i]=0;
    }
}

struct EdgePoint{
    int id,cost;
    EdgePoint(int id,int cost):id(id),cost(cost){}
    void se(int a,int b){
        id=a,cost=b;
    }
    bool operator &lt;(const EdgePoint&amp; a)const{
        return cost&gt;a.cost;
    }
};

int dji(int n){
    int dis[MAXN];
    memset(dis,0x3f,sizeof(dis));
    dis[0]=0;
    priority_queue&lt;EdgePoint&gt; pq;
    while(!pq.empty()){
        pq.pop();
    }
    pq.push(EdgePoint(0,0));
    while(!pq.empty()){
        EdgePoint now=pq.top();
        pq.pop();
        if(vis[now.id]==1) continue;
        vis[now.id]=1;
        for(int i=0;i&lt;=n;i++){
            if(vis[i]==0&amp;&amp;ma[now.id][i]+dis[now.id]&lt;dis[i]){
                dis[i]=dis[now.id]+ma[now.id][i];
                pq.push(EdgePoint(i,dis[i]));
            }
        }
    }
    return dis[1];
}

int main(){
    int m,n;
    scanf("%d%d",&amp;m,&amp;n);
    ini(n);
    for(int i=1;i&lt;=n;i++){
        int a,b,c;
        scanf("%d%d%d",&amp;a,&amp;b,&amp;c);
        price[i]=a;
        ma[0][i]=a;
        rk[i]=b;
        for(int j=0;j&lt;c;j++){
            int id,pr;
            scanf("%d%d",&amp;id,&amp;pr);
//          from id to i cost pr
            ma[id][i]=pr;
        }
    }
    int ans=inf;
    
    set&lt;int&gt; rkset;
    for(int i=1;i&lt;=n;i++){
        rkset.insert(rk[i]);
    }
    set&lt;int&gt;::iterator it;
    for(it=rkset.begin();it!=rkset.end();it++){
        int minrank=*it;
        memset(vis,0,sizeof(vis));
        if(!(rk[1]-minrank&gt;=0&amp;&amp;rk[1]-minrank&lt;=m)){
            continue;
        }
        for(int j=1;j&lt;=n;j++){
            if(rk[j]-minrank&gt;m||minrank&gt;rk[j]){
                vis[j]=1;
            }
        }
        ans=min(ans,dji(n));

    }
    printf("%d\n",ans);
    return 0;
}
</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/adb8983ba3a439675a43f80d872d25b5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">什么是数据库引擎</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ce05328d204004e539c253b762f80bd8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C# 委托调用带参的方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>