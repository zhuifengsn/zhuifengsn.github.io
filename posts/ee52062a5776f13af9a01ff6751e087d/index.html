<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>大概了解一下G1收集器 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="大概了解一下G1收集器" />
<meta property="og:description" content="在上一篇文章中（链接：大概了解一下CMS收集器）我们提到，CMS是一种主要针对旧生代对象进行回收的收集器。与CMS不同，G1号称“全功能的垃圾收集器”，对初生代内存和旧生代内存均进行管理。鉴于此，这里先简单插入介绍一下HotSpot虚拟机对于初生代内存的管理方式。
初生代内存管理 在HotSpot虚拟机中，初生代分为两个部分：Eden区和Survivor区，其中Survivor区又会被分为From区和To区，三者的比例通常为8：1：1。
初生代的对象并不会在一次GC后立刻被转移到旧生代，而是需要经过一定次数的初生代GC后才会晋升，这个次数我们可以称之为年龄。
将Survivor区划分为From和To的意图就很明显了，记得我们上文说到的“标记清除三兄贵”么，这不就是其中的标记复制算法嘛。
To区作为备用内存区From区中的对象会在GC中进行遍历标记，标记结束进入清除阶段后，对于存活的对象，如果没有达到年龄，就被复制到To区，如果达到要求的年龄，就晋升到旧生代。Eden区是创建新对象时默认的区域，也就是说Eden区中都是新创建的对象，之所以Eden区要比Survivor区大很多，也是基于一个假设：大部分新建对象的生命周期都很短，可以被很快回收。Eden区的对象如果在GC中存活下来，认为一定达不到晋升所需的年龄，因此不需要像From中的对象一样计算年龄，直接复制到To区。之后清空Eden区和From区。最后将From区和To区交换。
比如上图这种情况：
对象A和E在GC中存活下来，E没有达到要求的年龄，移动到To区，A是Eden区中的对象，直接移动到To区对象B和D没有在GC中存活下来，清除对象C在GC中存活下来，且达到要求的年龄，晋升到旧生代 移动后的情况如下：
最后将From和To交换：
G1（Garbage First） 在下面这两篇文章中我们已经介绍过分代GC中常用的一些概念（包括Region），本文就不再赘述。
分代GC前置概念（一）：Card Table 和 Remembered Set
分代GC前置概念（二）：TLAB
在G1中，内存仍然被分成初生代（包括Eden和Survivor）和旧生代，但与老的内存管理方式不同：
G1中每一部分的内存都是由多个Region组成的，因此只是逻辑上连续，并不需要物理上连续G1中每一部分的内存大小是不固定的，会动态调整G1中可以手动设置期望的GC时长，当然这只是个期望值，但G1会根据这个期望值动态的选择实际触发GC还是分配更多的空闲Region给当前代际G1还会根据设置的期望值，动态决定对哪些Region进行实际回收，以使效率最高用时最少，计算得到的Region集合，被称为CSet。 初生代GC（Young GC） g1源码之youngGC技术细节探究
当新创建小对象时默认将其分配在新生代的Eden区中（大对象在Humongous区，跟随旧生代处理，这里不讨论），当Eden没有足够空间时，G1会根据上文所说的期望时间与当前Region的使用情况，决定此时是给Eden区分配更多的可用Region还是触发一次Young GC：
Young GC只针对初生代进行Young GC是全程STW的Young GC的CSet包含所有初生代Region，也即整个初生代都在Young GC的回收范围内 Young GC几个主要过程：
STW——全程STW，没什么可说的。收集CSet——整个初生代区域。根扫描——从ROOT出发进行扫描。更新RSet——前文曾提到过，RSet的更新并不是实时的，因此在GC开始时，RSet可能并非最新，因此需要先将RSet更新到最新。扫描Rset——从RSet出发进行扫描。复制对象——将存活对象复制到对应的Region中（可能是Survivor，也可能是Old）。重构RSet——由于存活对象所在的Region发生了变化，需要对RSet进行重构。 混合GC（Mixed GC） Mixed GC 针对的目标既包括初生代也包括旧生代，但对于旧生代，G1只对其中的一部分进行回收，也即Mixed GC的CSet包括了所有初生代Region和部分旧生代Region，这也是为了尽量使G1的耗时满足用户手动设置的期望值。
Mixed GC的触发时机为旧生代内存占整堆达到一定比例时（IHOP——InitiatingHeapOccupancyPercent）。之所以Mixed GC不像Young GC一样在内存耗尽时才触发，是因为当达到IHOP时，并非立刻开始一个严格完整的GC过程，而仅仅是将Mixed GC切换到了激活状态。在这之后，仍然会进行Young GC，此时Young GC会承担起一部分与Mixed GC重合的工作，从而为Mixed GC分担耗时。
如上图所示，Mixed GC的过程基本可以分为如下阶段：
初始标记
当Mixed GC处于激活状态时，仍然会进行Young GC，以此来完成对初生代的处理当Mixed GC处于激活状态时，Young GC还会承担起对于与之相关的部分旧生代对象的标记工作，从而减少后续针对旧生代进行扫描的工作量由于Young GC是全程STW的，所以此阶段也为STW的 根扫描
扫描ROOT对旧生代的引用此过程可与业务线程并发此过程可以被新触发的Young GC打断 并发标记
扫描整个堆进行标记此过程可与业务线程并发此过程可以被新触发的Young GC打断 重标记
与CMS的重标记阶段作用一样，但是通过初始快照（SATB——Snapshot At The Beginning）机制实现。SATB简单理解为在GC开始时，根据对象内存地址进行粗略的划分，处于一定地址范围内的对象都被认为是本次需要关注的活跃对象，从而形成一份简单的内存快照。在上述的两个并发过程中，如果活跃对象的引用发生变化时，则进行记录。当并发标记结束后，对SATB记录的发生变化的对象进行重新标记。SATB关注的是引用断开，即基于“删除写屏障”机制。 此过程为STW的 清理" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/ee52062a5776f13af9a01ff6751e087d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-26T19:06:28+08:00" />
<meta property="article:modified_time" content="2024-02-26T19:06:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">大概了解一下G1收集器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>在上一篇文章中（<a href="https://blog.csdn.net/zhiai315/article/details/135775973">链接：大概了解一下CMS收集器</a>）我们提到，CMS是一种主要针对旧生代对象进行回收的收集器。与CMS不同，G1号称“全功能的垃圾收集器”，对初生代内存和旧生代内存均进行管理。鉴于此，这里先简单插入介绍一下HotSpot虚拟机对于初生代内存的管理方式。</p> 
<h2><a id="_1"></a>初生代内存管理</h2> 
<p>在HotSpot虚拟机中，初生代分为两个部分：Eden区和Survivor区，其中Survivor区又会被分为From区和To区，三者的比例通常为8：1：1。<br> <img src="https://images2.imgbox.com/a0/40/j1aRlD0d_o.png" alt="在这里插入图片描述"></p> 
<p>初生代的对象并不会在一次GC后立刻被转移到旧生代，而是需要经过一定次数的初生代GC后才会晋升，这个次数我们可以称之为年龄。</p> 
<p>将Survivor区划分为From和To的意图就很明显了，记得我们上文说到的“标记清除三兄贵”么，这不就是其中的标记复制算法嘛。</p> 
<ul><li>To区作为备用内存区</li><li>From区中的对象会在GC中进行遍历标记，标记结束进入清除阶段后，对于存活的对象，如果没有达到年龄，就被复制到To区，如果达到要求的年龄，就晋升到旧生代。</li><li>Eden区是创建新对象时默认的区域，也就是说Eden区中都是新创建的对象，之所以Eden区要比Survivor区大很多，也是基于一个假设：大部分新建对象的生命周期都很短，可以被很快回收。</li><li>Eden区的对象如果在GC中存活下来，认为一定达不到晋升所需的年龄，因此不需要像From中的对象一样计算年龄，直接复制到To区。</li><li>之后清空Eden区和From区。</li><li>最后将From区和To区交换。<br> <img src="https://images2.imgbox.com/3a/d6/660shjxr_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/97/92/bSWp4pe7_o.png" alt="在这里插入图片描述"></li></ul> 
<p>比如上图这种情况：</p> 
<ul><li>对象A和E在GC中存活下来，E没有达到要求的年龄，移动到To区，A是Eden区中的对象，直接移动到To区</li><li>对象B和D没有在GC中存活下来，清除</li><li>对象C在GC中存活下来，且达到要求的年龄，晋升到旧生代</li></ul> 
<p>移动后的情况如下：<br> <img src="https://images2.imgbox.com/a3/ae/vwML2MfD_o.png" alt="在这里插入图片描述"><br> 最后将From和To交换：<br> <img src="https://images2.imgbox.com/22/11/tNU4KhSp_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="G1Garbage_First_30"></a>G1（Garbage First）</h2> 
<p>在下面这两篇文章中我们已经介绍过分代GC中常用的一些概念（包括Region），本文就不再赘述。<br> <a href="https://blog.csdn.net/zhiai315/article/details/135751707">分代GC前置概念（一）：Card Table 和 Remembered Set</a><br> <a href="https://blog.csdn.net/zhiai315/article/details/135840668">分代GC前置概念（二）：TLAB</a></p> 
<p>在G1中，内存仍然被分成初生代（包括Eden和Survivor）和旧生代，但与老的内存管理方式不同：</p> 
<ul><li>G1中每一部分的内存都是由多个Region组成的，因此只是逻辑上连续，并不需要物理上连续</li><li>G1中每一部分的内存大小是不固定的，会动态调整</li><li>G1中可以手动设置期望的GC时长，当然这只是个期望值，但G1会根据这个期望值动态的选择实际触发GC还是分配更多的空闲Region给当前代际</li><li>G1还会根据设置的期望值，动态决定对哪些Region进行实际回收，以使效率最高用时最少，计算得到的Region集合，被称为CSet。</li></ul> 
<p><img src="https://images2.imgbox.com/8c/59/ZCZ3cVER_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="GCYoung_GC_44"></a>初生代GC（Young GC）</h3> 
<p><a href="https://www.jianshu.com/p/dd45a7ad8c96" rel="nofollow">g1源码之youngGC技术细节探究</a></p> 
<p>当新创建小对象时默认将其分配在新生代的Eden区中（大对象在Humongous区，跟随旧生代处理，这里不讨论），当Eden没有足够空间时，G1会根据上文所说的期望时间与当前Region的使用情况，决定此时是给Eden区分配更多的可用Region还是触发一次Young GC：</p> 
<ul><li>Young GC只针对初生代进行</li><li>Young GC是全程STW的</li><li>Young GC的CSet包含所有初生代Region，也即整个初生代都在Young GC的回收范围内</li></ul> 
<p>Young GC几个主要过程：</p> 
<ul><li>STW——全程STW，没什么可说的。</li><li>收集CSet——整个初生代区域。</li><li>根扫描——从ROOT出发进行扫描。</li><li>更新RSet——前文曾提到过，RSet的更新并不是实时的，因此在GC开始时，RSet可能并非最新，因此需要先将RSet更新到最新。</li><li>扫描Rset——从RSet出发进行扫描。</li><li>复制对象——将存活对象复制到对应的Region中（可能是Survivor，也可能是Old）。</li><li>重构RSet——由于存活对象所在的Region发生了变化，需要对RSet进行重构。</li></ul> 
<h3><a id="GCMixed_GC_64"></a>混合GC（Mixed GC）</h3> 
<p>Mixed GC 针对的目标既包括初生代也包括旧生代，但对于旧生代，G1只对其中的一部分进行回收，也即Mixed GC的CSet包括了所有初生代Region和部分旧生代Region，这也是为了尽量使G1的耗时满足用户手动设置的期望值。</p> 
<p>Mixed GC的触发时机为旧生代内存占整堆达到一定比例时（IHOP——InitiatingHeapOccupancyPercent）。之所以Mixed GC不像Young GC一样在内存耗尽时才触发，是因为当达到IHOP时，并非立刻开始一个严格完整的GC过程，而仅仅是将Mixed GC切换到了激活状态。在这之后，仍然会进行Young GC，此时Young GC会承担起一部分与Mixed GC重合的工作，从而为Mixed GC分担耗时。</p> 
<p><img src="https://images2.imgbox.com/32/72/uXqlLLea_o.png" alt="在这里插入图片描述"></p> 
<p>如上图所示，Mixed GC的过程基本可以分为如下阶段：</p> 
<p><strong>初始标记</strong></p> 
<ul><li>当Mixed GC处于激活状态时，仍然会进行Young GC，以此来完成对初生代的处理</li><li>当Mixed GC处于激活状态时，Young GC还会承担起对于与之相关的部分旧生代对象的标记工作，从而减少后续针对旧生代进行扫描的工作量</li><li>由于Young GC是全程STW的，所以此阶段也为STW的</li></ul> 
<p><strong>根扫描</strong></p> 
<ul><li>扫描ROOT对旧生代的引用</li><li>此过程可与业务线程并发</li><li>此过程可以被新触发的Young GC打断</li></ul> 
<p><strong>并发标记</strong></p> 
<ul><li>扫描整个堆进行标记</li><li>此过程可与业务线程并发</li><li>此过程可以被新触发的Young GC打断</li></ul> 
<p><strong>重标记</strong></p> 
<ul><li>与CMS的重标记阶段作用一样，但是通过初始快照（SATB——Snapshot At The Beginning）机制实现。</li><li>SATB简单理解为在GC开始时，根据对象内存地址进行粗略的划分，处于一定地址范围内的对象都被认为是本次需要关注的活跃对象，从而形成一份简单的内存快照。在上述的两个并发过程中，如果活跃对象的引用发生变化时，则进行记录。当并发标记结束后，对SATB记录的发生变化的对象进行重新标记。</li><li>SATB关注的是引用断开，即基于“删除写屏障”机制。 此过程为STW的</li></ul> 
<p><strong>清理</strong></p> 
<ul><li>计算Region的回收价值（STW）</li><li>清除RSet（STW）</li><li>按照回收价值对Region进行清理（并发执行）。</li></ul> 
<p><strong>复制</strong></p> 
<ul><li>将一些占用率过低的Region进行合并，对其中的对象进行复制/移动操作。</li><li>此过程为STW的</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0056470b2e00366c41c1e4e1ebfeca01/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【软件测试】--功能测试2--常用设计测试用例方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/99e0ef314025fd9960c9f5aff75e118e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">机器学习之特征缩放</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>