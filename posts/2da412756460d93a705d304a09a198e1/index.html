<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构—队列的顺序表示和实现--循环队列 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构—队列的顺序表示和实现--循环队列" />
<meta property="og:description" content="和顺序栈相类似，在队列的顺序存储结构中，除了用一组地址连续的存储单元依次存放从队列头到队列尾的元素之外，尚需附设两个整型变量 front和rear分别指示队列头元素及队列尾元素
1.队列的顺序表示
typedef struct { int *base; // 分配存储空间 int front; // 队头指针 int rear; // 队尾指针 }SqQueue; 为了在C语言中描述方便起见,在此约定：初始化创建空队列时，令font=rear=0，每当插入新的队列尾元索时，尾指针rear增1;每当删除队列头元素时，头指针 front增1。因此，在非空队列头指针始终指向队列头元素，而尾指针始终指向队列尾元素的下一个位置，如图： 假设当前队列分配的最大空间为6，则当队列处于图(d)所示的状态时不可再继续入新的队尾元素，否则会出现溢出现象，即因数组越界而导致程序的非法操作错误。事实上，此时队列的实际可用空间并未占满，所以这种现象称为“假溢出”。这是由“队尾入队，队头出队”这种受限制的操作造成的。怎样解决这种“假溢出”问题呢?一个较巧妙的办法是将顺序队列变为一个环状的空间，如图所示，称之为循环队列。 头、尾指针以及队列元素之间的关系不变，只是在循环队列中，头、尾指针“依环状增1”的操作可用“模”运算来实现。通过取模，头指针和尾指针就可以在顺序表空间内以头尾衔接的方式循环移动。 在图(a)中，队头元素是J5，在元素J6人队之前，在 Q.rear的值为5，当元素J6人队之，通过“模”运算，Q.rear=(Q.rear&#43;1)%6，得到 Q.rear的值为0，而不会出现图上图(d)的“假溢出”状态在图(b)中，J7、J8、J9、J10相继入队，则队列空间均被占满，此时头、尾指针相同。在图(c)中，若J5和J6相继从图(a)所示的队列中出队，使队列此时呈“空”的状态，头、尾指针的值也是相同的。由此可见,对于循环队列不能以头、尾指针的值是否相同来判别队列空间是“满”还是“空”。在这种情况下,如何区别队满还是队空呢?通常有以下2种处理方法。(1)少用一个元素空间，即队列空间大小为m时，有m-1个元素就认为是队满。这样判断队空的条件不变，即当头、尾指针的值相同时，则认为队空；而当尾指针在循环意义上加1后是等于头指针。则认为队满。因此，在循环队列中队空和队满的条件是: 队空的条件: Q.front = Q.rear队满的条件:(Q.rear&#43;1)% MAXQSIZE = Q.front如图(d)所示，当J7、J8、J9进入图(a)所示的队列后，(Q.rear&#43;1)% MAXQSIZE的值等于Q.front，此时认为队满。(2)另设一个标志位以区别队列是“空”还是“满”。 2.循环队列初始化
算法步骤 ①为队列分配一个最大容量为 MAXQSIZE的数组空间，base指向数组空间的首地址②头指针和尾指针置为零,表示队列为空。算法描述 int InitQueue(SqQueue &amp;Q) { Q.base = new int[MAXQSIZE]; //分配存储空间 if (!Q.base) return 0; // 存储空间分配失败 Q.front = Q.rear = 0; return 1; } 2.求队列长度
对于非循环队列，尾指针和头指针的差值便是队列长度，而对于循环队列，差值可能为负数所以需要将差值加上MAXQSIZE，然后与 MAXQSIZE求余。算法描述 int QueueLength(SqQueue Q) { return ((Q." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/2da412756460d93a705d304a09a198e1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-03T17:29:08+08:00" />
<meta property="article:modified_time" content="2019-07-03T17:29:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构—队列的顺序表示和实现--循环队列</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>和顺序栈相类似，在队列的顺序存储结构中，除了用一组地址连续的存储单元依次存放从队列头到队列尾的元素之外，尚需附设两个整型变量 front和rear分别指示队列头元素及队列尾元素</p> 
<p><strong>1.队列的顺序表示</strong></p> 
<pre class="has"><code class="language-cpp">typedef struct
{
	int *base;   // 分配存储空间 
	int front;   // 队头指针 
	int rear;   // 队尾指针 
}SqQueue;
</code></pre> 
<ul><li>为了在C语言中描述方便起见,在此约定：初始化创建空队列时，令<strong>font=rear=0</strong>，每当插入新的队列尾元索时，尾指针rear增1;每当删除队列头元素时，头指针 front增1。因此，<strong>在非空队列头指针始终指向队列头元素，而尾指针始终指向队列尾元素的下一个位置</strong>，如图：</li></ul> 
<p style="text-align:center;"><img alt="" class="has" height="203" src="https://images2.imgbox.com/28/aa/XY2jbIDT_o.png" width="603"></p> 
<ul><li>假设当前队列分配的最大空间为6，则当队列处于图(d)所示的状态时不可再继续入新的队尾元素，否则会出现溢出现象，即因数组越界而导致程序的非法操作错误。事实上，此时队列的实际可用空间并未占满，所以这种现象称为“假溢出”。这是由“<strong>队尾入队，队头出队</strong>”这种受限制的操作造成的。怎样解决这种“假溢出”问题呢?一个较巧妙的办法是将顺序队列变为一个环状的空间，如图所示，称之为<strong>循环队列</strong>。</li></ul> 
<p style="text-align:center;"><img alt="" class="has" height="150" src="https://images2.imgbox.com/d4/61/OzOZ3U8o_o.png" width="228"></p> 
<ul><li>头、尾指针以及队列元素之间的关系不变，只是在循环队列中，头、尾指针“依环状增1”的操作可用<strong>“模”</strong>运算来实现。通过取模，头指针和尾指针就可以在顺序表空间内以头尾衔接的方式循环移动。</li></ul> 
<p style="text-align:center;"><img alt="" class="has" height="167" src="https://images2.imgbox.com/e7/cf/d3WkaLYX_o.png" width="474"></p> 
<ul><li>在图(a)中，队头元素是J<img alt="" class="mathcode" src="https://images2.imgbox.com/77/67/oiYTJciC_o.png">5，在元素J6人队之前，在 Q.rear的值为5，当元素J6人队之，通过“模”运算，<strong>Q.rear=(Q.rear+1)%6</strong>，得到 Q.rear的值为0，而不会出现图上图(d)的“假溢出”状态</li><li>在图(b)中，J7、J8、J9、J10相继入队，则队列空间均被占满，此时头、尾指针相同。</li><li>在图(c)中，若J5和J6相继从图(a)所示的队列中出队，使队列此时呈“空”的状态，头、尾指针的值也是相同的。</li><li>由此可见,对于循环队列不能以头、尾指针的值是否相同来判别队列空间是“满”还是“空”。在这种情况下,如何区别队满还是队空呢?</li><li>通常有以下2种处理方法。</li><li>(1)少用一个元素空间，即队列空间大小为m时，有m-1个元素就认为是队满。这样判断队空的条件不变，即当头、尾指针的值相同时，则认为队空；而当尾指针在循环意义上加1后是等于头指针。则认为队满。因此，在循环队列中队空和队满的条件是: 
  <ul><li>队空的条件: <span style="color:#f33b45;"><strong>Q.front = Q.rear</strong></span></li><li>队满的条件:<span style="color:#f33b45;"><strong>(Q.rear+1)% MAXQSIZE = Q.front</strong></span></li><li>如图(d)所示，当J7、J8、J9进入图(a)所示的队列后，(Q.rear+1)% MAXQSIZE的值等于Q.front，此时认为队满。</li></ul></li><li>(2)另设一个标志位以区别队列是“空”还是“满”。</li></ul> 
<p><strong>2.循环队列初始化</strong></p> 
<ul><li>算法步骤 
  <ul><li>①为队列分配一个最大容量为 MAXQSIZE的数组空间，base指向数组空间的首地址</li><li>②头指针和尾指针置为零,表示队列为空。</li></ul></li><li>算法描述</li></ul> 
<pre class="has"><code class="language-cpp">int InitQueue(SqQueue &amp;Q) 
{
	Q.base = new int[MAXQSIZE];   //分配存储空间
	if (!Q.base) 
		return 0;     // 存储空间分配失败 
	Q.front = Q.rear = 0;
	
	return 1;
}</code></pre> 
<p><strong>2.求队列长度</strong></p> 
<ul><li>对于非循环队列，尾指针和头指针的差值便是队列长度，而对于循环队列，差值可能为负数所以需要将差值加上<strong>MAXQSIZE，</strong>然后与 <strong>MAXQSIZE</strong>求余。</li><li>算法描述</li></ul> 
<pre class="has"><code class="language-cpp">int QueueLength(SqQueue Q)
{
	return ((Q.rear - Q.front) + MAXQSIZE) % MAXQSIZE;
}</code></pre> 
<p><strong>3.入队</strong></p> 
<ul><li>人队操作是指在队尾插入一个新的元素。</li><li>算法步骤 
  <ul><li>①判断队列是否满，若满则返回ERROR。</li><li>②将新元素插入队尾。</li><li>③队尾指针加1。</li></ul></li><li>算法描述</li></ul> 
<pre class="has"><code class="language-cpp">int EnQueue(SqQueue &amp;Q, int e) 
{
	//首先判断队列是否已满
	if ((Q.rear + 1) % MAXQSIZE == Q.front) 
	{
		return 0;
	}
	Q.base[Q.rear] = e;  // 新元素插入队尾
	Q.rear = (Q.rear + 1) % MAXQSIZE;   // 队尾指针加1
	return 1;
}</code></pre> 
<p><strong>4.出队</strong></p> 
<ul><li>出队操作是将队头元素删除。</li><li>算法步骤 
  <ul><li>①判断队列是否为空，若空则返回 ERROR。</li><li>②保存队头元素。</li><li>③队头指针加1。</li></ul></li><li>算法描述</li></ul> 
<pre class="has"><code class="language-cpp">int DeQueue(SqQueue &amp;Q, int &amp;e) 
 {
	if (Q.front == Q.rear)
	{
		return 0;
	}
	e = Q.base[Q.front];  // 保存队头元素
	Q.front = (Q.front + 1) % MAXQSIZE;  // 队头指针加1
	
	return 1;
}</code></pre> 
<p><strong>5.取队头元素</strong></p> 
<ul><li>当队列非空时，此操作返回当前队头元素的值，队头指针保持不变。</li></ul> 
<pre class="has"><code class="language-cpp">int GetHead(SqQueue Q)// 返回Q的队头元素, 不修改队头指针
 {
	 if (Q.front != Q.rear)   // 队列非空
		 return Q.base[Q.front];  // 返回队头元素的值,队头指针不变
 }</code></pre> 
<p><strong>6.代码实现</strong></p> 
<ul><li><strong>main.cpp</strong></li></ul> 
<pre class="has"><code class="language-cpp">#include &lt;iostream&gt;

#define MAXQSIZE 100

using namespace std;

// 定义顺序队列
typedef struct 
{
	int *base;   //分配存储空间 
	int front;  //队头指针 
	int rear;  //队尾指针 
}SqQueue;


//初始化循环队列 
int InitQueue(SqQueue &amp;Q) 
{
	Q.base = new int[MAXQSIZE];   //分配存储空间
	if (!Q.base) 
		return 0;     // 存储空间分配失败 
	Q.front = Q.rear = 0;
	
	return 1;
}

// 求队列的长度
int QueueLength(SqQueue Q)
{
	return ((Q.rear - Q.front) + MAXQSIZE) % MAXQSIZE;
}


// 入队操作
int EnQueue(SqQueue &amp;Q, int e) 
{
	//首先判断队列是否已满
	if ((Q.rear + 1) % MAXQSIZE == Q.front) 
	{
		return 0;
	}
	Q.base[Q.rear] = e;  // 新元素插入队尾
	Q.rear = (Q.rear + 1) % MAXQSIZE;   // 队尾指针加1
	return 1;
}

//出队操作
 int DeQueue(SqQueue &amp;Q, int &amp;e) 
 {
	if (Q.front == Q.rear)
	{
		return 0;
	}
	e = Q.base[Q.front];  // 保存队头元素
	Q.front = (Q.front + 1) % MAXQSIZE;  // 队头指针加1
	
	return 1;
}

// 取队头元素
int GetHead(SqQueue Q)// 返回Q的队头元素, 不修改队头指针
 {
	 if (Q.front != Q.rear)   // 队列非空
		 return Q.base[Q.front];  // 返回队头元素的值,队头指针不变
 }
	 
//遍历队列
void TraveQueue(SqQueue Q) 
{
	int len = QueueLength(Q);
	for (int i = 0; i &lt; len; i++) 
	{
		int e;
		DeQueue(Q, e);
		printf("%d ", e);
	}
}

int main() 
{
	SqQueue Q;

	if (InitQueue(Q)) 
	{
		printf("队列初始化成功!\n");
	}
	else 
	{
		printf("队列初始化失败!\n");
	}
	printf("队列的初始长度是:%d\n", QueueLength(Q));

	// 入队
	int n;
	printf("请输入队元素的个数:");
	scanf("%d", &amp;n);
	for (int i = 0; i &lt; n; i++) 
	{
		int e;
		printf("请输入第%d个元素的值:", i + 1);
		scanf("%d", &amp;e);
		EnQueue(Q, e);
	}
	printf("队列的长度是:%d\n", QueueLength(Q));
	
	printf("遍历队列:");
	TraveQueue(Q);

	printf("\n队头元素:%d\n", GetHead(Q));

	// 出队
	for (int i = 0; i &lt; 2; i++)
	{
		int e;
		DeQueue(Q, e);
		printf("第%d个出队元素的值:%d\n", i + 1, e);
	}
	
	system("pause");
	
	return 0;
}</code></pre> 
<ul><li>运行结果</li></ul> 
<p><img alt="" class="has" height="235" src="https://images2.imgbox.com/2a/0d/SxmPAbrK_o.png" width="185"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e236326d2895e48dffb424fbd06e7310/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">学习Oracle Concepts-第6章 数据字典与动态性能视图</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/18c0dd2f99bc2acb4de75f6fcf61f50c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">我是如何自学python到找到工作经过</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>