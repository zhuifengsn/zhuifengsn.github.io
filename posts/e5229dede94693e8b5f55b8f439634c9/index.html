<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言K&amp;R圣经笔记 8.3 open,creat,close,unlink 8.4随机访问-lseek - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言K&amp;R圣经笔记 8.3 open,creat,close,unlink 8.4随机访问-lseek" />
<meta property="og:description" content="8.3 open, creat, close, unlink 除了标准输入、标准输出和标准错误之外，如果你要读写文件，就必须显式地打开它们。有两个系统调用做这件事，open 和 creat（末尾就是没有 e 的）。
open 非常像第七章讨论的 fopen，区别在于 open 不返回文件指针，而是返回文件描述符，后者仅仅是个 int 。如果发生任何错误，则 open 返回 -1。
#include &lt;fcntl.h&gt; int fd; int open(char *name, int flags, int perms); fd = open(name, flags, perms); 与 fopen 一样，name 参数是包含文件名的字符串。第二个 int 参数 flags 是用来指定如何打开文件的；主要的值有
O_RDONLY 只读
O_WRONLY 只写
O_RDWR 读写
在 System V UNIX 系统上，这些常量定义在 &lt;fcntl.h&gt; 中，而在伯克利（BSD）版本的系统上，它们定义在 &lt;sys/file.h&gt; 中。
若为了读取而打开已存在的文件，要写成
fd = open(name, O_RDONLY, 0); 接下来在介绍 open 的使用时，我们总是把参数 perms 的值设为 0。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/e5229dede94693e8b5f55b8f439634c9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-23T10:28:48+08:00" />
<meta property="article:modified_time" content="2024-02-23T10:28:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言K&amp;R圣经笔记 8.3 open,creat,close,unlink 8.4随机访问-lseek</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3></h3> 
<h3>8.3 open, creat, close, unlink</h3> 
<p>除了标准输入、标准输出和标准错误之外，如果你要读写文件，就必须显式地打开它们。有两个系统调用做这件事，open 和 creat（末尾就是没有 e 的）。</p> 
<p>open 非常像第七章讨论的 fopen，区别在于 open 不返回文件指针，而是返回文件描述符，后者仅仅是个 int 。如果发生任何错误，则 open 返回 -1。</p> 
<pre><code>#include &lt;fcntl.h&gt;

int fd;
int open(char *name, int flags, int perms);

fd = open(name, flags, perms);</code></pre> 
<p>与 fopen 一样，name 参数是包含文件名的字符串。第二个 int 参数 flags 是用来指定如何打开文件的；主要的值有</p> 
<blockquote> 
 <p>O_RDONLY     只读<br> O_WRONLY    只写<br> O_RDWR        读写</p> 
</blockquote> 
<p>在 System V UNIX 系统上，这些常量定义在 &lt;fcntl.h&gt; 中，而在伯克利（BSD）版本的系统上，它们定义在 &lt;sys/file.h&gt; 中。</p> 
<p>若为了读取而打开已存在的文件，要写成</p> 
<pre><code>fd = open(name, O_RDONLY, 0);</code></pre> 
<p>接下来在介绍 open 的使用时，我们总是把参数 perms 的值设为 0。</p> 
<p>试图 open 一个不存在的文件是错误的。creat 系统调用被用于创建新文件，或者重写旧文件。</p> 
<pre><code>int creat(char *name, int perms);

fd = creat(name, perms);</code></pre> 
<p>如果能够创建文件，则 creat 返回一个文件描述符，否则返回 -1。如果文件已存在，则 creat 将其大小截断成 0，这样就丢弃了文件之前的内容；creat 已存在的文件不是错误。</p> 
<p>如果文件不存在，则 creat 使用 perms 参数所指定的权限来创建文件。在 UNIX 系统中，有 9 个比特位的权限信息与文件关联，分别控制文件属主，属主所在的用户组，以及其他用户的读，写和执行。因此，可以很容易用一个三位的八进制数来指定权限。例如，0755指定属主有读、写和执行权限，用户组和其他用户有读和执行权限。</p> 
<p>这里以 UNIX 系统中用于拷贝文件的 cp 程序的一个简单版本为例。我们这个版本的 cp 只能拷贝一个文件，也不允许第二个参数为目录，还写死了文件权限，没有从原文件拷贝过来。</p> 
<p></p> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include "syscalls.h"
#define PERMS 0666    /* 属主，组和其他人都允许读和写 */

void error(char *, ...);

/* cp: 把 f1 拷贝到 f2 */
main(int argc, char *argv[])
{
    int f1, f2, n;
    char buf[BUFSIZE];

    if (argc != 3)
        error("Usage: cp from to");
    if ((f1 = open(argv[1], O_RDONLY，0))  == -1)
        error("cp: can't open %s", argv[1]);
    if ((f2 = creat(argv[2], PERMS)) == -1)
        error("cp: can't create %s, mode %03o", argv[2], PERMS);
    while ((n = read(f1, buf, BUFSIZ)) &gt; 0)
        if (write(f2, buf, n) != n)
            error("cp: write error on file %s", argv[2]);
    return 0;
}</code></pre> 
<p>这个程序使用固定权限 0666 来创建输出的文件。使用后面 8.6 节所述的 stat 系统调用，我们可以确定已存在文件的权限，并将同样的权限赋给要拷贝的文件。</p> 
<p>注意 error 函数调用方式很像 printf，也有一个可变参数列表。下面 error 的实现代码说明了如何使用 printf 家族的另一个成员。标准库函数 vprintf 与 printf 类似，区别在于可变参数列表被换成了单个参数，且这个参数已经使用 va_start 宏初始化过了。类似的，vfprintf 和 vsprintf 对应 fprintf 和 sprintf。</p> 
<pre><code class="hljs">#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;

/* error：打印错误信息并结束程序 */
void error(char *fmt, ...)
{
    va_list args;

    va_start(args, fmt);
    fprintf(stderr, "error: ");
    vfprintf(stderr, fmt, args);
    fprintf(stderr, "\n");
    va_end(args);
    exit(1);
}</code></pre> 
<p></p> 
<p>一个程序能够同时打开的文件数量会有限制（通常大概是20）。因此，任何想要处理很多文件的程序必须准备好重用文件描述符。函数 close(int fd) 将文件描述符与一个打开文件之间的关联断开，并释放文件描述符以供其他文件使用；它对应标准库中的 fclose，区别在于不进行缓冲刷新。通过 exit 退出程序，或者从 main 程序退出，会关闭所有已打开的文件。</p> 
<p>函数 unlink(char *name) 从文件系统中删除文件 name。它对应标准库函数 remove。</p> 
<p>练习8-1、重写第七章的 cat 程序，使用 read、write、open 和 close，而不是它们对应的标准库函数。做试验来确定这两个版本的相对执行速度。</p> 
<h3></h3> 
<h3>8.4 随机访问-lseek</h3> 
<p><br> 输入和输出通常是按顺序的：每次 read 和 write 都正好发生在上一次读写的文件位置之后。不过若有需要，文件可以按任意顺序来读写。系统调用 lseek 提供了一种在文件中移动，但不读取或写入任何数据的方式：</p> 
<pre><code>long lseek(int fd, long offset, int origin);</code></pre> 
<p>lseek 把文件描述符为 fd 的文件的当前位置设为由 origin 所指定的 offset 偏移位置。后续的读写会从该位置开始。origin 可以是 0、1、2，分别表示 offset 偏移量从文件开头，或从当前位置，或从文件末尾计算。例如，要从文件末尾添加（UNIX shell 中的 &gt;&gt; 重定向，或者 fopen 的 "a"），则在写文件之前要移到文件末尾：</p> 
<pre><code>lseek(fd, 0L, 2);</code></pre> 
<p>要回到文件开头（“倒回”）：</p> 
<pre><code>lseek(fd, 0L, 0);</code></pre> 
<p>注意参数 0L；如果 lseek 正确声明的话，也能写成 (long) 0 或 仅一个 0。</p> 
<p>有了 lseek，就可能把文件当作一个大数组来对待，代价是访问较慢。例如，下面的函数从文件<br> 的任意位置读取任意数量的字节。它返回读到的数量，若出错则返回 -1。</p> 
<pre><code class="hljs">#include "syscalls.h"

/* get：从pos位置读取n个字节 */
int get(int fd, long pos, char *buf, int n)
{
    if (lseek(fd, pos, 0) &gt;= 0)    /* 移动到pos位置 */
        return read(fd, buf, n);
    else
        return -1;
}</code></pre> 
<p>lseek 的返回值是一个 long，给出了文件的新位置，若出错则返回 -1。标准库函数 fseek 与 lseek 类似 ，区别在于它的第一个参数是 FILE *，且在出错时返回非0。</p> 
<h3><br>  </h3>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b299ad8972aad2e221607ad676da390d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HarmonyOS-ArkTS卡片运行机制和相关模块</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ec003c55486c5f5441498c2cf4b87f75/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">.Net 8.0 新的变化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>