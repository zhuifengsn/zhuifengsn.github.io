<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java8强大的新特性 —— “Stream API” - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java8强大的新特性 —— “Stream API”" />
<meta property="og:description" content="一、什么是Stream API？ Java Stream API是Java 8中引入的一个重要功能，它允许开发者以声明性方式处理数据集合，使代码更加简洁、可读性更好，同时还提供了并行操作的能力，从而能够更有效地利用多核处理器。
Stream API的核心概念是Stream，它是处理数据的一种抽象方式。Stream可以看作是数据流，它可以从数据源获取数据，然后通过一系列的处理步骤，将数据转换或过滤成所需的结果。这个处理过程是声明性的，意味着开发者只需要关注数据的处理逻辑，而不必关心具体的实现细节。
Stream API的优点主要表现在以下几个方面：
简洁的代码：使用Stream API可以让代码更加简洁，因为许多复杂的操作都可以通过一条简单的Stream表达式来实现。例如，要过滤出一个列表中的偶数并求平方，使用传统的Java代码可能需要多行代码来实现，而使用Stream API只需要一条简单的链式调用即可。易于阅读和理解：Stream API的代码结构清晰，易于阅读和理解。通过链式调用，可以很清楚地看到数据的处理过程和结果。并行操作：Stream API支持并行操作，这意味着可以同时处理多个数据项，从而充分利用多核处理器的能力。这有助于提高程序的执行效率。函数式编程风格：Stream API引入了函数式编程的思想，允许开发者使用高阶函数和lambda表达式来处理数据。这使得代码更加灵活和可重用。 Stream到底是什么呢？为什么要使用Stream API？
是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。 “集合讲的是存储数据，Stream讲的是计算数据！”实际开发中，项目中多数数据源都来自于Mysql，Oracle等。但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据就需要Java层面去处理。Stream能帮我们更高效率处理数据计算。 并行流
并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。相比较串行的流，并行的流可以很大程度上提高程序的执行效率。Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与顺序流之间进行切换。 注意：
Stream 自己不会存储元素。Stream 不会改变源对象。相反，它的方法都会返回一个持有结果的新Stream。Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。 Java IO 流和 Stream API的关系？
Java IO 流主要用于文件的读写操作，它以字节流和字符流为基础，分别用于处理字节数据和字符数据。IO 流提供了一种顺序访问数据的方式，可以从输入流中读取数据，或者将数据写入输出流。它以一种同步的方式进行操作，适用于处理大规模的数据。Stream API是一种用于处理集合数据的高级抽象概念，它提供了一种流式处理的方式，能够对集合中的元素进行过滤、映射、排序、归约等操作。Stream API的目的是为了提供一种更加简洁、灵活和并行的集合操作方式。与传统的集合操作方式相比，Stream API的优势在于可以通过链式调用方法，以一种声明性的方式对集合进行处理。因此，Java IO 流和 Stream API是两种不同的数据处理方式，它们没有直接的关系。但是，它们可以相互配合使用，例如使用IO 流读取文件数据，然后使用Stream API对数据进行处理和分析 二、Stream 操作的三个步骤 创建Stream
一个数据源（如：集合、数组），获取一个流
中间操作
一个中间操作链，对数据源的数据进行处理。
终止操作(终端操作)
一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用
说明Stream 操作是延迟执行的。一次性的。（执行终止操作时才执行中间操作）
图示：
1. 创建Stream 1.1 方式一：通过集合 Java8 中的 Collection 接口被扩展，提供了两个获取流的方法" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/5aba5e21864c1ad52808aed556d5e8f9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-06T23:07:22+08:00" />
<meta property="article:modified_time" content="2023-11-06T23:07:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java8强大的新特性 —— “Stream API”</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Stream_API_0"></a>一、什么是Stream API？</h2> 
<p>Java Stream API是<mark>Java 8</mark>中引入的一个重要功能，它允许开发者以声明性方式处理数据集合，使代码更加简洁、可读性更好，同时还提供了并行操作的能力，从而能够更有效地利用多核处理器。</p> 
<p>Stream API的核心概念是Stream，它是处理数据的一种抽象方式。Stream可以看作是数据流，它可以从数据源获取数据，然后通过一系列的处理步骤，将数据转换或过滤成所需的结果。这个处理过程是声明性的，意味着开发者只需要关注数据的处理逻辑，而不必关心具体的实现细节。</p> 
<p><strong>Stream API的优点主要表现在以下几个方面：</strong></p> 
<ol><li>简洁的代码：使用Stream API可以让代码更加简洁，因为许多复杂的操作都可以通过一条简单的Stream表达式来实现。例如，要过滤出一个列表中的偶数并求平方，使用传统的Java代码可能需要多行代码来实现，而使用Stream API只需要一条简单的链式调用即可。</li><li>易于阅读和理解：Stream API的代码结构清晰，易于阅读和理解。通过链式调用，可以很清楚地看到数据的处理过程和结果。</li><li>并行操作：Stream API支持并行操作，这意味着可以同时处理多个数据项，从而充分利用多核处理器的能力。这有助于提高程序的执行效率。</li><li>函数式编程风格：Stream API引入了函数式编程的思想，允许开发者使用高阶函数和lambda表达式来处理数据。这使得代码更加灵活和可重用。</li></ol> 
<p><strong>Stream到底是什么呢？为什么要使用Stream API？</strong></p> 
<ul><li>是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。 <strong>“集合讲的是存储数据，Stream讲的是计算数据！”</strong></li><li>实际开发中，项目中多数数据源都来自于Mysql，Oracle等。但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据就需要Java层面去处理。Stream能帮我们更高效率处理数据计算。</li></ul> 
<p><strong>并行流</strong></p> 
<ul><li><strong>并行流</strong>就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。相比较串行的流，并行的流可以很大程度上提高程序的执行效率。</li><li>Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过 <code>parallel()</code> 与 <code>sequential() </code>在并行流与顺序流之间进行切换。</li></ul> 
<p><strong>注意：</strong></p> 
<ol><li>Stream 自己不会存储元素。</li><li>Stream 不会改变源对象。相反，它的方法都会返回一个持有结果的新Stream。</li><li>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li></ol> 
<hr> 
<p><strong>Java IO 流和 Stream API的关系？</strong></p> 
<ul><li>Java IO 流主要用于文件的读写操作，它以字节流和字符流为基础，分别用于处理字节数据和字符数据。IO 流提供了一种顺序访问数据的方式，可以从输入流中读取数据，或者将数据写入输出流。它以一种同步的方式进行操作，适用于处理大规模的数据。</li><li>Stream API是一种用于处理集合数据的高级抽象概念，它提供了一种流式处理的方式，能够对集合中的元素进行过滤、映射、排序、归约等操作。Stream API的目的是为了提供一种更加简洁、灵活和并行的集合操作方式。与传统的集合操作方式相比，Stream API的优势在于可以通过链式调用方法，以一种声明性的方式对集合进行处理。</li><li>因此，Java IO 流和 Stream API是两种不同的数据处理方式，它们没有直接的关系。但是，它们可以相互配合使用，例如<mark>使用IO 流读取文件数据</mark>，然后<mark>使用Stream API对数据进行处理和分析</mark></li></ul> 
<h2><a id="Stream__36"></a>二、Stream 操作的三个步骤</h2> 
<ol><li> <p><strong>创建Stream</strong><br> 一个数据源（如：集合、数组），获取一个流</p> </li><li> <p><strong>中间操作</strong><br> 一个中间操作链，对数据源的数据进行处理。</p> </li><li> <p><strong>终止操作(终端操作)</strong><br> 一旦执行终止操作，<strong>就执行中间操作链</strong>，并产生结果。之后，不会再被使用</p> 
  <blockquote> 
   <p>说明Stream 操作是延迟执行的。一次性的。（执行终止操作时才执行中间操作）</p> 
  </blockquote> </li></ol> 
<p>图示：</p> 
<p><img src="https://images2.imgbox.com/aa/9e/8Dwv6VRH_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="1_Stream_54"></a>1. 创建Stream</h3> 
<h4><a id="11__56"></a>1.1 <strong>方式一：通过集合</strong></h4> 
<p>Java8 中的 <strong>Collection</strong> 接口被扩展，提供了两个获取流的方法</p> 
<ol><li> <p><code>default Stream&lt;E&gt; stream()</code> : <strong>返回一个顺序流</strong></p> 
  <blockquote> 
   <p>顺序流，即操作时会按集合的顺序处理数据。</p> 
  </blockquote> </li><li> <p><code>default Stream&lt;E&gt; parallelStream()</code> : <strong>返回一个并行流</strong></p> 
  <blockquote> 
   <p>并行流，即操作时将集合分成多个块，同时处理多个块的数据。</p> 
  </blockquote> </li></ol> 
<h4><a id="12__69"></a>1.2 方式<strong>二：通过数组</strong></h4> 
<p>Java8 中的 <strong>Arrays</strong> 的静态方法 stream() 可以获取数组流：</p> 
<ul><li><code>static &lt;T&gt; Stream&lt;T&gt; stream(T[] array)</code>: <strong>返回一个流</strong></li></ul> 
<p>重载形式，能够处理对应基本类型的数组：</p> 
<ul><li><code>public static IntStream stream(int[] array)</code></li><li><code>public static LongStream stream(long[] array)</code></li><li><code>public static DoubleStream stream(double[] array)</code></li></ul> 
<h4><a id="13_Streamof_81"></a>1.3 <strong>方式三：通过Stream的of()</strong></h4> 
<p>可以调用Stream类静态方法 of(), 通过显示值创建一个流。它可以接收任意数量的参数。</p> 
<ul><li><code>public static&lt;T&gt; Stream&lt;T&gt; of(T... values)</code> : <strong>返回一个流</strong></li></ul> 
<h4><a id="14__87"></a>1.4 <strong>方式四：创建无限流</strong></h4> 
<p>可以使用静态方法 <code>Stream.iterate() </code>和 <code>Stream.generate()</code>, 创建无限流。</p> 
<ul><li><strong>迭代</strong>、<br> <code>public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</code></li><li><strong>生成</strong><br> <code>public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s) </code></li></ul> 
<pre><code class="prism language-java"><span class="token comment">// 方式四：创建无限流</span>
<span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 迭代</span>
    <span class="token comment">// public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</span>
    <span class="token comment">//seed：初始值。</span>
    <span class="token comment">//遍历前10个偶数</span>
    <span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stream <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">iterate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> x <span class="token operator">-&gt;</span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    stream<span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 生成</span>
    <span class="token comment">// public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</span>
    <span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Double</span><span class="token punctuation">&gt;</span></span> stream1 <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token operator">::</span><span class="token function">random</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    stream1<span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="2__113"></a>2. 中间操作</h3> 
<p>多个<strong>中间操作</strong>可以连接起来形成一个<strong>流水线</strong>，除非流水线上触发终止操作，否则<strong>中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”</strong> 。</p> 
<p><mark>通过</mark>​<mark>Stream</mark>​<mark>的方法进行的：</mark></p> 
<h4><a id="21__119"></a>2.1 筛选与切片</h4> 
<table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>filter(Predicate p)</td><td>接收 Lambda ， 从流中排除某些元素</td></tr><tr><td>distinct()</td><td>筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</td></tr><tr><td>limit(long maxSize)</td><td>截断流，使其元素不超过给定数量</td></tr><tr><td>skip(long n)</td><td>跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补</td></tr></tbody></table> 
<p>代码演示：</p> 
<pre><code class="prism language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"john"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"jame"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"mike"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> stream <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//筛选</span>
stream<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>e <span class="token operator">-&gt;</span> e<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"m"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//去重</span>
stream<span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token comment">//因为每个方法都返回一个新的Stream，所以可以形成一个中间操作链</span>
stream<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>e <span class="token operator">-&gt;</span> e<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"m"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="22_Map_147"></a>2.2 映射（Map）</h4> 
<table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><strong>map(Function f)</strong></td><td>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</td></tr><tr><td>mapToDouble(ToDoubleFunction f)</td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。</td></tr><tr><td>mapToInt(ToIntFunction f)</td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 IntStream。</td></tr><tr><td>mapToLong(ToLongFunction f)</td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream。</td></tr><tr><td><strong>flatMap(Function f)</strong></td><td>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</td></tr></tbody></table> 
<p>代码演示：</p> 
<pre><code class="prism language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"aa"</span><span class="token punctuation">,</span> <span class="token string">"bb"</span><span class="token punctuation">,</span> <span class="token string">"cc"</span><span class="token punctuation">,</span> <span class="token string">"dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>str <span class="token operator">-&gt;</span> str<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将Stream中每个元素映射成新的元素，结果返回新的Stream。</span>
</code></pre> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>stream<span class="token punctuation">.</span></span><span class="token class-name">Stream</span></span><span class="token punctuation">;</span>

<span class="token comment">/**
 * 比较 map(Function f)和flatMap(Function f)
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"aa"</span><span class="token punctuation">,</span> <span class="token string">"bb"</span><span class="token punctuation">,</span> <span class="token string">"cc"</span><span class="token punctuation">,</span> <span class="token string">"dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//map(Function f)</span>
        <span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Stream</span><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> streamStream <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Test</span><span class="token operator">::</span><span class="token function">fromStringToStream</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回的是一个由Stream元素构成的Stream。类似于List集合的add()方法add一个List元素。</span>
        <span class="token comment">//输出所有元素，遍历流，还要遍历流中的流</span>
        streamStream<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>s <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
            s<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//flatMap(Function f)</span>
        <span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">&gt;</span></span> characterStream <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token class-name">Test</span><span class="token operator">::</span><span class="token function">fromStringToStream</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Stream中的Stream元素被平铺开了。类似于List中的addAll()方法。</span>
        <span class="token comment">//输出所有元素</span>
        characterStream<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//将字符串中的多个字符构成的集合转换为对应的Stream的实例</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">&gt;</span></span> <span class="token function">fromStringToStream</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Character</span> c <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="23__198"></a>2.3 排序</h4> 
<table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>sorted()</td><td>产生一个新流，其中按自然顺序排序（元素要实现Comparable接口）</td></tr><tr><td>sorted(Comparator com)</td><td>产生一个新流，其中按比较器顺序排序</td></tr></tbody></table> 
<h3><a id="3__205"></a>3. 终止操作</h3> 
<p>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void 。</p> 
<p><strong>流进行了终止操作后，不能再次使用</strong>。</p> 
<p><mark>也是通过Stream的方法实现：</mark></p> 
<h4><a id="31__213"></a>3.1 匹配与查找</h4> 
<table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>boolean allMatch(Predicate p)</td><td>检查是否匹配所有元素</td></tr><tr><td>boolean anyMatch(Predicate p)</td><td>检查是否至少匹配一个元素</td></tr><tr><td>boolean noneMatch(Predicate p)</td><td>检查是否没有匹配所有元素</td></tr><tr><td>Optional findFirst()</td><td>返回第一个元素</td></tr><tr><td>Optional findAny()</td><td>返回当前流中的任意元素</td></tr><tr><td>long count()</td><td>返回流中元素总数</td></tr><tr><td>Optional max(Comparator c)</td><td>返回流中最大值</td></tr><tr><td>Optional min(Comparator c)</td><td>返回流中最小值</td></tr><tr><td>void forEach(Consumer c)</td><td><strong>内部迭代</strong>(使用 Collection 接口需要用户去做迭代，称为<strong>外部迭代</strong>。<br>相反，Stream API 使用内部迭代——它帮你把迭代做了)</td></tr></tbody></table> 
<p>代码演示：</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">EmployeeData</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>

<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span> employees <span class="token operator">=</span> <span class="token class-name">EmployeeData</span><span class="token punctuation">.</span><span class="token function">getEmployees</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//allMatch(Predicate p)检查是否匹配所有元素</span>
<span class="token comment">//练习：是否所有的员工的年龄都大于18</span>
<span class="token keyword">boolean</span> allMatch <span class="token operator">=</span> employees<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">allMatch</span><span class="token punctuation">(</span>e <span class="token operator">-&gt;</span> e<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//anyMatch(Predicate p)检查是否至少匹配一个元素</span>
<span class="token comment">//练习：是否存在员工的工资大于 10000</span>
<span class="token keyword">boolean</span> anyMatch <span class="token operator">=</span> employees<span class="token punctuation">.</span>stream<span class="token punctuation">.</span><span class="token function">anyMatch</span><span class="token punctuation">(</span>e <span class="token operator">-&gt;</span> e<span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//noneMatch(Predicate p)检查是否没有匹配所有元素</span>
<span class="token comment">//练习：是否存在员工姓“雷”</span>
<span class="token keyword">boolean</span> noneMatch <span class="token operator">=</span> employees<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">noneMatch</span><span class="token punctuation">(</span>e <span class="token operator">-&gt;</span> e<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"雷"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//findFirst()返回第一个元素</span>
<span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span> employee <span class="token operator">=</span> employees<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  

<span class="token comment">//findAny()返回当前流中的任意元素</span>
<span class="token comment">//count()返回流中元素总数</span>

<span class="token comment">//max(Comparator c)返回流中最大值</span>
<span class="token comment">//练习：返回最高的工资</span>
<span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Double</span><span class="token punctuation">&gt;</span></span> maxSalary <span class="token operator">=</span> employees<span class="token punctuation">.</span>stream<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>e <span class="token operator">-&gt;</span> e<span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token class-name">Double</span><span class="token operator">::</span><span class="token function">compare</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                            
<span class="token comment">//min(Comparator c)返回流中最小值</span>
<span class="token comment">//练习：返回最低工资的员工</span>
<span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span> employee <span class="token operator">=</span> emloyees<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token class-name">Double</span><span class="token operator">::</span><span class="token function">compare</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//forEach 内部迭代</span>
employees<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="32_reduce_264"></a>3.2 归约（reduce）</h4> 
<table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>reduce(T iden, BinaryOperator b)</td><td>可以将流中元素反复结合起来，得到一个值。返回 T</td></tr><tr><td>reduce(BinaryOperator b)</td><td>可以将流中元素反复结合起来，得到一个值。返回 Optional</td></tr></tbody></table> 
<p>备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名。</p> 
<p>代码演示：</p> 
<pre><code class="prism language-java"><span class="token comment">//reduce(T iden, BinaryOperator b)可以将流中元素反复结合起来，得到一个值。返回 T</span>
<span class="token comment">//练习：计算1~10的自然数的和</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span> sum <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">sum</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//reduce(BinaryOperator b)可以将流中元素反复结合起来，得到一个值。返回 Optional&lt;T&gt;</span>
<span class="token comment">//练习：计算公司所有员工工资的总和</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span> employees <span class="token operator">=</span> <span class="token class-name">EmployeeData</span><span class="token punctuation">.</span><span class="token function">getEmployees</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Double</span> sum <span class="token operator">=</span> employees<span class="token punctuation">.</span>stream<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Employee</span><span class="token operator">::</span><span class="token function">getSalary</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token class-name">Double</span><span class="token operator">::</span><span class="token function">sum</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="33__287"></a>3.3 收集</h4> 
<table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>collect(Collector c)</td><td>将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法</td></tr></tbody></table> 
<p>Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、Map)。<br> 代码演示：</p> 
<pre><code class="prism language-java"><span class="token comment">//练习：查找工资大于6000的员工，结果返回一个List或Set</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span> employees <span class="token operator">=</span> <span class="token class-name">EmployeeData</span><span class="token punctuation">.</span><span class="token function">getEmployees</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> employees<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>e <span class="token operator">-&gt;</span> e<span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">6000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Iterable接口有forEach方法</span>
</code></pre> 
<p>另外， <strong>Collectors</strong> 工具类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：</p> 
<table><thead><tr><th>方法名</th><th>返回类型</th><th>作用</th></tr></thead><tbody><tr><td><strong>toList</strong></td><td>List</td><td>把流中元素收集到List</td></tr><tr><td><strong>toSet</strong></td><td>Set</td><td>把流中元素收集到Set</td></tr><tr><td><strong>toCollection</strong></td><td>Collection</td><td>把流中元素收集到创建的集合</td></tr><tr><td>counting</td><td>Long</td><td>计算流中元素的个数</td></tr><tr><td>summingInt</td><td>Integer</td><td>对流中元素的整数属性求和</td></tr><tr><td>averagingInt</td><td>Double</td><td>计算流中元素Integer属性的平均值</td></tr><tr><td>summarizingInt</td><td>IntSummaryStatistics</td><td>收集流中Integer属性的统计值。如：平均值</td></tr><tr><td>joining</td><td>String</td><td>连接流中每个字符串</td></tr><tr><td>maxBy</td><td>Optional</td><td>根据比较器选择最大值</td></tr><tr><td>minBy</td><td>Optional</td><td>根据比较器选择最小值</td></tr><tr><td>reducing</td><td>归约产生的类型</td><td>从一个作为累加器的初始值开始，利用BinaryOperator与流中元素逐个结合，从而归约成单个值</td></tr><tr><td>collectingAndThen</td><td>转换函数返回的类型</td><td>包裹另一个收集器，对其结果转换函数</td></tr><tr><td>groupingBy</td><td>Map&lt;K, List&gt;</td><td>根据某属性值对流分组，属性为K，结果为V</td></tr><tr><td>partitioningBy</td><td>Map&lt;Boolean,List&gt;</td><td>根据true或false进行分区</td></tr></tbody></table>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2a720fc21688ad1d7d0800655475297e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">窗口函数ROW_NUMBER、RANK、DENSE_RANK</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a83e23e4921b1bbda5a68b6eebb477f8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【java学习笔记2】数组-移除元素</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>