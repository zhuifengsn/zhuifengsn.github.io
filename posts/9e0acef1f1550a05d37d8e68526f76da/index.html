<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c&#43;&#43;类和对象(二) - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c&#43;&#43;类和对象(二)" />
<meta property="og:description" content="类有6个默认成员函数 如果一个类什么成员都没有，称为空类。空类中什么都没有吗，并不是的，任何一个类在我们不写的情况下会自动生成以下6个默认成员函数。
class Date
{
}；
1、构造函数 概念：构造函数是用来初始化的。
class Date { public: void InitDate(int year, int month, int day) { _year = year; _month = month; _day = day; } void PrintDate() { cout &lt;&lt; _year &lt;&lt; &#34;-&#34; &lt;&lt; _month &lt;&lt; &#34;-&#34; &lt;&lt; _day &lt;&lt; endl; } private: int _year; int _month; int _day; }; int main() { Date d1; d1.InitDate(2022, 6, 15); d1.PrintDate(); return 0; } 在日常的操作中，大家都会或多或少的忘记去初始化了，然后去访问它就会出现随机值或者会出现崩溃。我们想一下，在c语言的时候实现一个Stack的数据结构，如果忘记去初始化的话，在一个随机的指针中去插入一个数据，这就是野指针了。
忘记初始化是正常的事，那有没有什么办法是可以来让它自动来初始化的呢？答案是有的。构造函数就是来解决这种问题的。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/9e0acef1f1550a05d37d8e68526f76da/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-05T21:05:26+08:00" />
<meta property="article:modified_time" content="2022-10-05T21:05:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c&#43;&#43;类和对象(二)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>类有6个默认成员函数</h2> 
<p>        如果一个类什么成员都没有，称为空类。空类中什么都没有吗，并不是的，任何一个类在我们不写的情况下会自动生成以下6个默认成员函数。</p> 
<blockquote> 
 <p>class Date</p> 
 <p>{<!-- --></p> 
 <p>}；</p> 
</blockquote> 
<p class="img-center"><img alt="" height="328" src="https://images2.imgbox.com/45/df/BTGjfgzC_o.png" width="974"></p> 
<h2>1、构造函数</h2> 
<p>        概念：构造函数是用来初始化的。</p> 
<pre><code>class Date
{
public:
	void InitDate(int year, int month, int day)
	{
		_year = year;
		_month = month;
		_day = day;
	}
	void PrintDate()
	{
		cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl;
	}
private:
	int _year;
	int _month;
	int _day;
};

int main()
{
	Date d1;
	d1.InitDate(2022, 6, 15);
	d1.PrintDate();

	return 0;
}</code></pre> 
<p>        在日常的操作中，大家都会或多或少的忘记去初始化了，然后去访问它就会出现随机值或者会出现崩溃。我们想一下，在c语言的时候实现一个Stack的数据结构，如果忘记去初始化的话，在一个随机的指针中去插入一个数据，这就是野指针了。</p> 
<p class="img-center"><img alt="" height="273" src="https://images2.imgbox.com/23/e2/VxH0Fnyc_o.png" width="652"></p> 
<p>         忘记初始化是正常的事，那有没有什么办法是可以来让它自动来初始化的呢？答案是有的。构造函数就是来解决这种问题的。</p> 
<h3>1.1构造函数特性</h3> 
<blockquote> 
 <p>        构造函数是一个特殊的成员函数，名字与类名相同,创建类类型对象时由编译器自动调用，保证每个数据成员都有 一个合适的初始值，并且在对象的生命周期内只调用一次。</p> 
 <p>   特征如下：</p> 
 <p>        1. 函数名与类名相同。<br>         2. 无返回值。<br>         3. 对象实例化时编译器自动调用对应的构造函数。<br>         4. 构造函数可以重载</p> 
</blockquote> 
<pre><code>class Date
{
public:
    //构造函数:初始化
	Date(int year=0, int month=0, int day=0)
	{
		_year = year;
		_month = month;
		_day = day;
	}

	void PrintDate()
	{
		cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl;
	}
private:
	int _year;
	int _month;
	int _day;
};

int main()
{
	Date d1;    //会自动调用构造函数
	d1.PrintDate();

	return 0;
}</code></pre> 
<p><img alt="" height="205" src="https://images2.imgbox.com/79/59/Pey2ULaJ_o.png" width="754"></p> 
<p>         如果类中没有显式定义构造函数，则C++编译器会自动生成一个无参的默认构造函数，一旦用户显式定义编译器将不再生成。</p> 
<p><img alt="" height="524" src="https://images2.imgbox.com/c5/85/hbAuxVA3_o.png" width="777"></p> 
<p>        为什么会是随机值呢？是这样的，c++会把类型分为内置类型、自定义类型。内置类型就是语法上已经定义好了的类型如：int/char等等。自定义类型：使用class、struct自己定义的类型。默认生成的构造函数对于内置类型成员变量不作处理，对自定义类型成员变量才会处理。看看下面的程序，就会发现编译器生成默认的构造函数是去自定类型成员_t调用的它的默认成员函数。</p> 
<p><img alt="" height="812" src="https://images2.imgbox.com/1c/04/etoC1P79_o.png" width="974"></p> 
<blockquote> 
 <p>总结：</p> 
 <p>        如果一个类中的成员全是自定义类型，就会自动生成默认构造函数。如果有内置类型的成员就得自己实现构造函数了。</p> 
</blockquote> 
<h2>2.析构函数</h2> 
<h3>  2.1概念：</h3> 
<p>        析构函数：与构造函数相反，析构函数不是用来完成对象的销毁。而是对象在销毁的时候会自动调用析构函数来完成类的一些资源清洗工作。在数据结构中实现一个动态顺序表，有顺序表的初始化就有顺序表的销毁，而这个顺序表的销毁是用来干什么的呢：是用来释放掉动态开辟的内存空间以及一系列的置空置零。因为经常会忘记释放动态开辟的内存空间，从而导致内存泄漏，所以就有了析构函数来防止这种情况，在对象生命周期结束的时候就会自动调用析构函数来完成一系列的动态内存空间销毁等。</p> 
<h3>  2.2特征：</h3> 
<blockquote> 
 <p>1. 析构函数名是在类名前加上字符 <span style="color:#fe2c24;">~</span><br> 2. 无参数无返回值。<br> 3. 一个类有且只有一个析构函数。若未显式定义，系统会自动生成默认的析构函数(这里的自动生成上面有涉及，同理)。<br> 4. 对象生命周期结束时，C++编译器会自动调用析构函数。</p> 
</blockquote> 
<pre><code>class SeqList
{
public:
	//构造函数：初始化
	SeqList(int capacity = 10)
	{
		_data = new int[10];
		_capacity = capacity;
		_sz = 0;
	}

	//析构函数：清理资源
	~SeqList()
	{
		delete _data;	//释放动态开辟的空间
		_capacity = 0;
		_sz = 0;
	}

private:
	int* _data;
	int _capacity;
	int _sz;
};

int main()
{
	//出了作用域生命周期结束就会自动调用析构函数来进行资源清洗
	if (1)
	{
		SeqList s1;
	}

	return 0;
}</code></pre> 
<blockquote> 
 <p><span style="color:#fe2c24;">补充：如存在多个对象时，谁先调出析构函数？跟栈结构一样，后进先出。后实例化的对象先调出析构函数。</span></p> 
</blockquote> 
<p><img alt="" height="239" src="https://images2.imgbox.com/ac/d2/iibdvMf2_o.png" width="719"></p> 
<h2><strong> 3.拷贝构造函数</strong></h2> 
<h3><strong>    3.1概念：</strong></h3> 
<p><strong>           </strong>拷贝构造函数：就是把之前创建好了的同一类对象用来初始化新创建的对象。</p> 
<h3>    3.2特征：</h3> 
<blockquote> 
 <p>1. 拷贝构造函数是构造函数的一种。<br> 2. 拷贝构造函数的参数只有一个且必须使用引用传参，使用传值方式会引发无穷递归调用。</p> 
</blockquote> 
<pre><code>class Date
{
public:
	Date(int year = 0, int month = 0, int day = 0)
	{
		_year = year;
		_month = month;
		_day = day;
	}

    //拷贝构造函数：必须使用引用传参，否则无限递归
	Date(const Date&amp; d)
	{	
		_year = d._year;
		_month = d._month;
		_day = d._day;
	}

private:
	int _year;
	int _month;
	int _day;
};

int main()
{
	Date d1(2022,6,17);

	//把已创建好了的对象d1初始化要新创建的对象d2，叫拷贝构造
	Date d2(d1);

	return 0;
}</code></pre> 
<p>        为什么拷贝构造函数使用传值传参会出现无穷递归呢?</p> 
<p><img alt="" height="482" src="https://images2.imgbox.com/b0/35/Wf2n00YX_o.png" width="1127"></p> 
<p>        如果类中没有显式定义拷贝构造函数的话，且类中成员都是内置类型，编译器会生成默认的拷贝构造函数。生成的默认拷贝构造函数对于内置类型的成员会完成值拷贝、浅拷贝。而对于自定义类型会去调用拷贝构造函数。</p> 
<p><img alt="" height="676" src="https://images2.imgbox.com/79/09/iprfWGv4_o.png" width="787"></p> 
<h2>4.赋值运算符重载:operator</h2> 
<h3>    4.1运算符重载</h3> 
<p>        C++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数，也具有其返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。</p> 
<blockquote> 
 <p>函数名字为：关键字operator后面接需要重载的运算符符号。</p> 
 <p>函数原型：返回值类型 operator操作符(参数列表)</p> 
</blockquote> 
<h4>    4.2注意：</h4> 
<blockquote> 
 <ol><li>不能通过连接其他符号来创建新的操作符：比如operator@</li><li>重载操作符必须有一个类类型或者枚举类型的操作数</li><li>用于内置类型的操作符，其含义不能改变，例如：内置的整型+，不 能改变其含义</li><li>作为类成员的重载函数时，其形参看起来比操作数数目少1成员函数的</li><li>操作符有一个默认的形参this，限定为第一个形参</li><li>.* 、:: 、sizeof 、?: 、. 注意以上5个运算符不能重载。</li></ol> 
</blockquote> 
<p>        如果我们想用d1和d2进行比较大小的话，会怎么样呢？</p> 
<p><img alt="" height="513" src="https://images2.imgbox.com/05/26/trMtGyZD_o.png" width="1200"></p> 
<p>         既然自定义类型不支持使用运算符来比较的话，比较大小是不是就没办法了，其实不然，是有个办法能很好的解决的。为了自定义类型可以使用各种运算符，运算符重载operator出现了。</p> 
<pre><code>class Date
{
public:
	Date(int year = 0, int month = 0, int day = 0)
	{
		_year = year;
		_month = month;
		_day = day;
	}

	//运算符重载
	bool operator&gt;(const Date&amp; d1)  //编译器会处理成这样:bool operator&gt;(Date* const this,const Date&amp; d)
	{
		//不是说自定义类型不能使用运算符的吗，但类中的成员是内置类型的啊，所以是可以使用的。
		if (_year &gt; d._year
			|| _year == d._year &amp;&amp; _month &gt; d._month
			|| _year == d._year &amp;&amp; _month == d._month &amp;&amp; _day &gt; d._day)
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	bool operator==(const Date&amp;d)
	{
		return _year == d._year 
			&amp;&amp; _month == d._month 
			&amp;&amp; _day == d._day;
	}

	void PrintDate()
	{
		cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl;
	}
private:
	int _year;
	int _month;
	int _day;
};

int main()
{
	Date d1(2022, 6, 19);
	Date d2(2022, 6, 20);

	if (d1 &gt; d2) //编译器会处理成这样：if(d1.operator(&amp;d1,d2))
	{
		cout &lt;&lt; "d1 &gt; d2" &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; "d1 &lt; d2" &lt;&lt; endl;
	}

	return 0;
}</code></pre> 
<h3>4.3赋值运算符重载</h3> 
<blockquote> 
 <p>赋值运算符主要有四点：<br> 1. 参数类型<br> 2. 返回值<br> 3. 检测是否自己给自己赋值<br> 4. 返回*this<br> 5. 一个类如果没有显式定义赋值运算符重载，编译器也会生成一个，完成对象按字节序的值拷贝。</p> 
</blockquote> 
<pre><code>class Date
{
public:
	Date(int year = 0, int month = 0, int day = 0)
	{
		_year = year;
		_month = month;
		_day = day;
	}

	//赋值重载
	Date&amp; operator=(const Date&amp;d)
	{
		_year = d._year;
		_month = d._month;
		_day = d._day;

		return *this;
	}

	void PrintDate()
	{
		cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl;
	}
private:
	int _year;
	int _month;
	int _day;
};

int main()
{
	Date d1(2022, 6, 19);
	Date d2(d1); //拷贝构造：一个已经存在了的对象d1去初始化另一个要创建的对象d2

	Date d3;
	d3 = d1;  //赋值重载:两个已经存在了的对象之间赋值

	return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1335e5997cdaa8636cb3fd5106da408a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux：chmod -R 777 *含义</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b44e9ee9c19d9671b4bbe358d46902e7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">简述&amp;&amp;和&amp;的区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>