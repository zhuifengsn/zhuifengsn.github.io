<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】类和对象（4）类的六个默认成员函数 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【C&#43;&#43;】类和对象（4）类的六个默认成员函数" />
<meta property="og:description" content="一、类的六个默认成员函数 下面是一个Date类，但是它类中什么成员也没有，这就是空类。但是它虽然看起来什么都没有，实际上不是的，在我们什么都不写的情况下，它会自动生成六个默认的成员函数。如图所示的构造函数、析构函数、拷贝构造函数、赋值重载函数、普通对象取地址函数、const对象取地址函数这六个函数，就算我们自己不写，也会默认生成。
class Date {}; 二、构造函数 构造函数虽然名字是构造，但是其实它并不是构造了对象，而是完成了对象的初始化。我们以Date类为例：
class Date { public: void Print() { cout &lt;&lt; _year &lt;&lt; &#34;-&#34; &lt;&lt; _month &lt;&lt; &#34;-&#34; &lt;&lt; _day &lt;&lt; endl; } void Init(int year, int month, int day) { _year = year; _month = month; _day = day; } private://封装起来不允许随便修改 int _year;//年 //用_区分成员变量和参数 int _month;//月 int _day;//日 }; int main() { Date d1; d1.Init(2018, 11, 11);//用Init函数初始化来间接修改值 d1.Print(); Date d2; d2.Init(2019, 2, 4); d2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/135e0755f759f4245f4507492128ea66/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-01-11T19:41:10+08:00" />
<meta property="article:modified_time" content="2019-01-11T19:41:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】类和对象（4）类的六个默认成员函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、类的六个默认成员函数</h3> 
<p style="text-indent:50px;">下面是一个Date类，但是它类中什么成员也没有，这就是空类。但是它虽然看起来什么都没有，实际上不是的，在我们什么都不写的情况下，它会自动生成六个默认的成员函数。如图所示的<strong>构造函数、析构函数、拷贝构造函数、赋值重载函数、普通对象取地址函数、const对象取地址函数</strong>这六个函数，就算我们自己不写，也会默认生成。</p> 
<pre class="has"><code class="language-cpp">class Date {};</code></pre> 
<p><img alt="" class="has" height="322" src="https://images2.imgbox.com/f2/91/Nj3IjBQC_o.png" width="877"></p> 
<h3> </h3> 
<h3>二、构造函数 </h3> 
<p style="text-indent:50px;">构造函数虽然名字是构造，但是其实它并不是构造了对象，而是完成了对象的初始化。我们以Date类为例：</p> 
<pre class="has"><code class="language-cpp">class Date
{
public:
	void Print()
	{
		cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl;
	}
	void Init(int year, int month, int day)
	{
		_year = year;
		_month = month;
		_day = day;
			}
private://封装起来不允许随便修改
	int _year;//年   //用_区分成员变量和参数
	int _month;//月
	int _day;//日
};

int main()
{
	Date d1;
	d1.Init(2018, 11, 11);//用Init函数初始化来间接修改值
	d1.Print();

	Date d2;
	d2.Init(2019, 2, 4);
	d2.Print();

	system("pause");
	return 0;
}</code></pre> 
<p style="text-indent:50px;">这是之前写的一个简单的Date类，可以通过 <strong>Init 函数 </strong>给对象初始化设置内容，但是如果每次创建对象都调用该方法设置信息，未免有点麻烦，那能否在对象创建时，就将信息设置进去呢？所以说C++就给出了<strong>构造函数。</strong></p> 
<p style="text-indent:50px;"><strong>构造函数</strong>是一个特殊的成员函数，<strong>名字与类名相同,创建类类型对象时由编译器自动调用</strong>，保证每个数据成员<br> 都有 一个合适的初始值，并且在<strong>对象的生命周期内只调用一次。</strong></p> 
<p style="text-indent:50px;"> </p> 
<h4><strong>构造函数的特性</strong></h4> 
<p style="text-indent:50px;">1.函数名与类名相同</p> 
<p style="text-indent:50px;">2.无返回值</p> 
<p style="text-indent:50px;">3. 对象实例化时编译器<strong>自动调用</strong>对应的构造函数。</p> 
<pre class="has"><code class="language-cpp">class Date
{
public:
	Date()
	{
		_year = 2018;
		_month = 11;
		_day = 18;
	}
};</code></pre> 
<p style="text-indent:50px;">4. 构造函数可以重载。</p> 
<pre class="has"><code class="language-cpp">class Date
{
public:
	Date()
	{
		_year = 2018;
		_month = 11;
		_day = 18;
	}
	Date(int year, int month, int day)
	{
		_year = year;
		_month = month;
		_day = day;
	}
};

int main()
{
	Date d1;//无参调用默认构造函数
    //Date d1();错误，无参调用不能带括号
	d1.Print();

	Date d2(2019, 1, 1);//带参调用自定义构造函数
	d2.Print();

	system("pause");
	return 0;
}</code></pre> 
<p style="text-indent:50px;">5. 如果类中没有显式定义构造函数，则C++编译器会自动生成一个无参的默认构造函数，一旦用户显式定义编译器将不再生成。</p> 
<p style="text-indent:50px;">6. 无参的构造函数和全缺省的构造函数都称为默认构造函数，并且<strong>默认构造函数只能有一个</strong>。注意：<strong>无参构造函数、全缺省构造函数、我们没写编译器默认生成的构造函数，都可以认为是默认成员函数。</strong></p> 
<p style="text-indent:50px;">如下，有两个默认构造函数，就会引起调用歧义。</p> 
<pre class="has"><code class="language-cpp">// 默认构造函数
class Date
{
public:
    Date()
{
    _year = 1900 ;
    _month = 1 ;
    _day = 1;
}
   Date (int year = 1900, int month = 1, int day = 1)
{
    _year = year;
    _month = month;
    _day = day;
}
private :
    int _year ;
    int _month ;
    int _day ;
};

void Test()
{
   Date d1;
}</code></pre> 
<p style="text-indent:50px;">7.C++把类型分成内置类型(基本类型)和自定义类型。内置类型就是语法已经定义好的类型：如int/char...，自定义类型就是我们使用class/struct/union自己定义的类型。<strong>默认的构造函数并不是一点卵用都没有，针对自定义类型它会进行初始化，调用它的默认成员函数，而对于内置类型（基本类型）来说，它并不会初始化，所以我们看到的是随机值。</strong></p> 
<pre class="has"><code class="language-cpp">class Time
{
public:
	Time()
	{
		cout &lt;&lt; "Time()" &lt;&lt; endl;
		_hour = _minute = _second = 0;
	}
private:
	int _hour;
	int _minute;
	int _second;
};

class Date
{
public:
	void Print()
	{
		cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl;
	}
	
private:

	//1.基本类型/内置类型
	int _year;
	int _month;
	int _day;

	//2.自定义类型
	Time _t;
};</code></pre> 
<h3> </h3> 
<h3>三、析构函数</h3> 
<p style="text-indent:50px;">与构造函数功能相反，析构函数<strong>不是完成对象的销毁</strong>，<strong>局部对象销毁工作是由编译器完成</strong>的。而<br><strong>对象在销毁时会自动调用析构函数</strong>，<strong>完成类的一些资源清理工作</strong>。</p> 
<p style="text-indent:0;"> </p> 
<h4>析构函数的特性</h4> 
<p style="text-indent:50px;">1. 析构函数名是在类名前加上字符 ~。</p> 
<p style="text-indent:50px;">2. 无参数无返回值。没有重载版本。</p> 
<p style="text-indent:50px;">3. 一个类有且只有一个析构函数。如果不写，系统会自动生成默认的析构函数。</p> 
<p style="text-indent:50px;">4. 对象生命周期结束时，C++编译系统系统自动调用析构函数。</p> 
<pre class="has"><code class="language-cpp">class SeqList
{
public:
	SeqList(size_t capacity=10)
	{
		_a = (int*)malloc(10 * sizeof(int));
		_size = 0;
		_capacity = capacity;
	}

	~SeqList()
	{
		free(_a);//释放堆上的空间
		_a = nullptr;//指针置为空
		_size = _capacity = 0;
	}

private:
	int *_a;
	size_t _size;
	size_t _capacity;
};

int main()
{
	SeqList s1;
	system("pause");
	return 0;
}</code></pre> 
<p style="text-indent:50px;">5.编译器生成的默认析构函数，<strong>会对自定类型成员调用它的析构函数。</strong></p> 
<pre class="has"><code class="language-cpp">class String
{
public:
	String(const char* str = "jack")
	{
		_str = (char*)malloc(strlen(str) + 1);
		strcpy(_str, str);
	}
	~String()
	{
		cout &lt;&lt; "~String()" &lt;&lt; endl;
		free(_str);
		system("pause");
	}
private:
	char* _str;
};

class Person
{
private:
	String _name;
	int _age;
};

int main()
{
	Person p;
	return 0;
}</code></pre> 
<h3> </h3> 
<h3>四、拷贝构造函数</h3> 
<p style="text-indent:50px;">现实生活中，一模一样的两个人我们成为双胞胎，那么类的对象在构造时候能不能创建一个与一个对象一模一样的新对象呢？</p> 
<p style="text-indent:50px;"><strong>拷贝构造函数</strong>只有单个形参，该形参是对本类类型对象的引用(一般常用const修饰)，在用已存在的类类型对象创建新对象时由编译器自动调用。</p> 
<h4>拷贝构造函数的特性</h4> 
<p style="text-indent:50px;">1. 拷贝构造函数<strong>是构造函数的一个重载形式</strong>。</p> 
<p style="text-indent:50px;">2. 拷贝构造函数的<strong>参数只有一个且必须使用引用传参</strong>，<strong>使用传值方式会引发无穷递归调用</strong>。</p> 
<pre class="has"><code class="language-cpp">class Date
{
public:
	Date(int year = 1900, int month = 1, int day = 1)
	{
		_year = year;
		_month = month;
		_day = day;
	}
	Date(const Date&amp; d)
	{
		_year = d._year;
		_month = d._month;
		_day = d._day;
	}
	void Print()
	{
		cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl;
	}
private:
	int _year;
	int _month;
	int _day;
};

int main()
{
	Date d1(2018,11,11);
	d1.Print();

	Date d2(d1);
	d2.Print();

	system("pause");
	return 0;
}</code></pre> 
<p style="text-indent:0;"><img alt="" class="has" height="354" src="https://images2.imgbox.com/38/3d/3lb6NtTR_o.png" width="885"></p> 
<p style="text-indent:50px;"> </p> 
<p style="text-indent:50px;">3. <strong>若未显示定义，系统生成默认的拷贝构造函数</strong>。 默认的拷贝构造函数对象<strong>按内存存储按字节序</strong>完成拷<br> 贝，这种拷贝我们叫做<strong>浅拷贝，或者值拷贝</strong>。</p> 
<pre class="has"><code class="language-cpp">class Date
{
public:
	Date(int year = 1900, int month = 1, int day = 1)
	{
		_year = year;
		_month = month;
		_day = day;
	}
	void Print()
	{
		cout &lt;&lt; _year &lt;&lt; "-" &lt;&lt; _month &lt;&lt; "-" &lt;&lt; _day &lt;&lt; endl;
	}
private:
	int _year;
	int _month;
	int _day;
};

int main()
{
	Date d1(2018,11,11);
	d1.Print();

	Date d2(d1);//默认拷贝构造
	d2.Print();

	system("pause");
	return 0;
}</code></pre> 
<p style="text-indent:50px;"> </p> 
<h3>五、赋值运算符重载</h3> 
<p style="text-indent:50px;">在说赋值运算符重载之前我们先了解下运算符重载。</p> 
<h4>运算符重载</h4> 
<p style="text-indent:50px;"><strong>C++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数</strong>，也具有其返回值类<br> 型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。</p> 
<p style="text-indent:50px;">函数名字为：关键字<strong>operator后面接需要重载的运算符符号</strong>。</p> 
<p style="text-indent:50px;">函数原型：<strong>返回值类型 operator操作符(参数列表)。</strong></p> 
<p style="text-indent:0;"><strong>注意：</strong></p> 
<p style="text-indent:50px;">1&gt;不能通过连接其他符号来创建新的操作符：比如operator@</p> 
<p style="text-indent:50px;">2&gt;重载操作符必须有一个类类型或者枚举类型的操作数</p> 
<p style="text-indent:50px;">3&gt;用于内置类型的操作符，其含义不能改变，例如：内置的整型+，不 能改变其含义</p> 
<p style="text-indent:50px;">4&gt;作为类成员的重载函数时，其形参看起来比操作数数目少1成员函数的操作符有一个默认的形参this，限定为第一个形参</p> 
<p style="text-indent:50px;">5&gt;<strong> .* </strong>、<strong>::</strong> 、<strong>sizeof</strong> 、<strong>?: </strong>、<strong>. </strong>注意以上5个运算符不能重载</p> 
<p style="text-indent:50px;"> </p> 
<p style="text-indent:0;">这里会发现运算符重载成全局的就需要成员变量是共有的，为了保证封装性可以重载成成员函数。</p> 
<pre class="has"><code class="language-cpp">// 全局的operator==
class Date
{
public:
Date(int year = 1900, int month = 1, int day = 1)
{
   _year = year;
   _month = month;
   _day = day;
}
//private:
   int _year;
   int _month;
   int _day;
};
// 这里会发现运算符重载成全局的就需要成员变量是共有的
// 为了保证封装性可以重载成成员函数。
bool operator==(const Date&amp; d1, const Date&amp; d2)
{
   return d1._year == d2._year;
       &amp;&amp; d1._month == d2._month
       &amp;&amp; d1._day == d2._day;
}
void Test ()
{
   Date d1(2018, 9, 26);
   Date d2(2018, 9, 27);
   cout&lt;&lt;(d1 == d2)&lt;&lt;endl;
   cout&lt;&lt;operator==(d1,d2)&lt;&lt;endl;
}</code></pre> 
<p><strong>bool operator==(Date* this, const Date&amp; d2)</strong><br> 这里需要注意的是，左操作数是隐含指针this指向的调用函数的对象，所以只用写一个参数。</p> 
<pre class="has"><code class="language-cpp">class Date
{
public:
Date(int year = 1900, int month = 1, int day = 1)
{
   _year = year;
   _month = month;
   _day = day;
}
// bool operator==(Date* this, const Date&amp; d2)
// 这里需要注意的是，左操作数是this指向的调用函数的对象
bool operator==(const Date&amp; d2)
{
      return _year == d2._year;
          &amp;&amp; _month == d2._month
          &amp;&amp; _day == d2._day;
}
private:
   int _year;
   int _month;
   int _day;
};
void Test ()
{
   Date d1(2018, 9, 26);
   Date d2(2018, 9, 27);
   cout&lt;&lt;d1.operator==(d2)&lt;&lt;endl;
   cout&lt;&lt;(d1 == d2)&lt;&lt;endl;
}</code></pre> 
<h4>赋值运算符重载</h4> 
<pre class="has"><code class="language-cpp">class Date
{
public :
Date(int year = 1900, int month = 1, int day = 1)
{
   _year = year;
   _month = month;
   _day = day;
}
Date (const Date&amp; d)
{
   _year = d._year;
   _month = d._month;
   _day = d._day;
}
Date&amp; operator=(const Date&amp; d)
{
   if(this != &amp;d)
     {
       _year = d._year;
       _month = d._month;
       _day = d._day;
     }
}
private:
   int _year ;
   int _month ;
   int _day ;
};</code></pre> 
<p style="text-indent:0;">赋值运算符主要有四点：</p> 
<p style="text-indent:50px;">1. 参数类型</p> 
<p style="text-indent:50px;">2. 返回值</p> 
<p style="text-indent:50px;">3. 检测是否自己给自己赋值</p> 
<p style="text-indent:50px;">4. 返回*this</p> 
<p style="text-indent:50px;">5. 一个类如果没有显式定义赋值运算符重载，编译器也会生成一个，完成对象按字节序的值拷贝。</p> 
<pre class="has"><code class="language-cpp">class Date
{
public:
	Date(int year = 1900, int month = 1, int day = 1)
	{
		_year = year;
		_month = month;
		_day = day;
	}
private:
	int _year;
	int _month;
	int _day;
};
int main()
{
	Date d1;
	Date d2(2018,10,1);
	// 这里d1调用的编译器生成operator=完成拷贝，d2和d1的值也是一样的。
	d1 = d2;
	system("pause");
	return 0;
}</code></pre> 
<p style="text-indent:50px;">编译器生成的默认赋值重载函数已经可以完成字节序的值拷贝了，但是有的还是要我们自己去实现，就是深拷贝。这个后边的帖子会总结，到时候会连接过来。</p> 
<p style="text-indent:50px;"> </p> 
<h3>六、const成员</h3> 
<h4> const修饰类的成员函数</h4> 
<p style="text-indent:50px;">将<strong>const修饰的类成员函数</strong>称之为<strong>const成员函数</strong>，const修饰类成员函数，<strong>实际修饰该成员函数隐含的this<br> 指针</strong>，表明在<strong>该成员函数中不能对类的任何成员进行修改</strong>。</p> 
<p style="text-indent:50px;"> </p> 
<p style="text-indent:0;"><strong>注意：</strong></p> 
<p style="text-indent:50px;"><strong>const对象可以调用其他的const函数；</strong></p> 
<p style="text-indent:50px;"><strong>非const对象可以调用非const成员函数和const成员函数；</strong></p> 
<p style="text-indent:50px;"><strong>const成员函数内可以调用其他的const成员函数；</strong></p> 
<p style="text-indent:50px;"><strong>非const成员函数内可以调用其他的const成员函数和非const成员函数；</strong></p> 
<p style="text-indent:50px;"> </p> 
<h3>七、取地址及const取地址操作符重载</h3> 
<p style="text-indent:50px;">这两个默认成员函数一般不用重新定义 ，编译器默认会生成。</p> 
<pre class="has"><code class="language-cpp">class Date
{
public :
Date* operator&amp;()
{
   return this ;
}
const Date* operator&amp;()const
{
   return this ;
}
private :
   int _year ; // 年
   int _month ; // 月
   int _day ; // 日
};</code></pre> 
<p style="text-indent:50px;">这两个运算符一般也不需要重载，使用编译器生成的默认取地址的重载即可，只有特殊情况，才需要重载，比<br> 如想让别人获取到指定的内容！</p> 
<p style="text-indent:50px;"> </p> 
<p style="text-indent:50px;"> </p> 
<p style="text-indent:50px;"> </p> 
<p style="text-indent:50px;"> </p> 
<p style="text-indent:50px;"> </p> 
<p style="text-indent:50px;"> </p> 
<p style="text-indent:50px;"> </p> 
<p style="text-indent:50px;"> </p> 
<p style="text-indent:50px;"> </p> 
<p style="text-indent:50px;"> </p> 
<p style="text-indent:50px;"> </p> 
<p style="text-indent:50px;"> </p> 
<p style="text-indent:50px;"> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/56e73cb7fdcc33c8715456ce4bec3d85/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何调优sql</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/459dba8dadb1db0d4027445ba68c5265/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">视频伪原创的常见方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>