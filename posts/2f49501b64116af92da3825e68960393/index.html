<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>TEST 和 TEST_F 区别 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="TEST 和 TEST_F 区别" />
<meta property="og:description" content="#include &lt;gtest/gtest.h&gt;
int Factorial( int n )
{
if(n==2) return 100; //故意出个错，嘻嘻
return n&lt;=0? 1 : n*Factorial(n - 1);
}
//用TEST做简单测试
TEST(TestFactorial, ZeroInput) //第一个参数是测试用例名，第二个参数是测试名：随后的测试结果将以&#34;测试用例名.测试名&#34;的形式给出
{
EXPECT_EQ(1, Factorial(0)); //EXPECT_EQ稍候再说，现在只要知道它是测试两个数据是否相等的就行了。
}
TEST(TestFactorial, OtherInput)
{
EXPECT_EQ(1, Factorial(1));
EXPECT_EQ(2, Factorial(2));
EXPECT_EQ(6, Factorial(3));
EXPECT_EQ(40320, Factorial(8));
}
int main(int argc, char* argv[])
{
testing::InitGoogleTest(&amp;argc,argv); //用来处理Test相关的命令行开关，如果不关注也可不加
RUN_ALL_TESTS(); //看函数名就知道干啥了
std::cin.get(); //只是让它暂停而已，不然一闪就没了
return 0;
}
2.多个测试场景需要相同数据配置的情况，用 TEST_F
//用TEST_F做同配置的系列测试 typedef std::basic_string&lt;TCHAR&gt; tstring; struct FooTest : testing::Test { //这里定义要测试的东东 tstring strExe; //可以利用构造、析构来初始化一些参数 FooTest() {} virtual ~FooTest() {} //如果构造、析构还不能满足你，还有下面两个虚拟函数 virtual void SetUp() { // 在构造后调用 strExe." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/2f49501b64116af92da3825e68960393/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-11-20T16:50:02+08:00" />
<meta property="article:modified_time" content="2016-11-20T16:50:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">TEST 和 TEST_F 区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>#include &lt;gtest/gtest.h&gt;</p> 
<p><br>  int Factorial( int n )<br>  {<!-- --><br>   <span style="white-space:pre">      </span>if(n==2) return 100; //故意出个错，嘻嘻<br>  <span style="white-space:pre"></span>            return n&lt;=0? 1 : n*Factorial(n - 1);<br>  }</p> 
<p><br>  //用TEST做简单测试<br>  TEST(TestFactorial, ZeroInput) //第一个参数是测试用例名，第二个参数是测试名：随后的测试结果将以"测试用例名.测试名"的形式给出<br>  {<!-- --><br>        EXPECT_EQ(1, Factorial(0));  //EXPECT_EQ稍候再说，现在只要知道它是测试两个数据是否相等的就行了。<br>  }</p> 
<p> TEST(TestFactorial, OtherInput)<br>  {<!-- --><br>         EXPECT_EQ(1, Factorial(1));<br>   <span style="white-space:pre"></span> <span style="white-space:pre">     </span>EXPECT_EQ(2, Factorial(2));<br>   <span style="white-space:pre">      </span><span style="white-space:pre"></span>EXPECT_EQ(6, Factorial(3));<br>   <span style="white-space:pre">      </span><span style="white-space:pre"></span>EXPECT_EQ(40320, Factorial(8));<br>  }</p> 
<p> int main(int argc, char* argv[])<br>  {<!-- --><br>        <span style="white-space:pre"> </span>testing::InitGoogleTest(&amp;argc,argv); //用来处理Test相关的命令行开关，如果不关注也可不加<br>  <span style="white-space:pre">       </span>RUN_ALL_TESTS();  //看函数名就知道干啥了<br>          <span style="white-space:pre"></span>std::cin.get();   //只是让它暂停而已，不然一闪就没了<br>          <span style="white-space:pre"></span>return 0;<br>  }</p> 
<p>2.多个测试场景需要相同数据配置的情况，用 TEST_F</p> 
<p>//用TEST_F做同配置的系列测试  <br> typedef std::basic_string&lt;TCHAR&gt; tstring;  <br> struct FooTest : testing::Test {  <br>   //这里定义要测试的东东  <br>    tstring strExe;  <br>   //可以利用构造、析构来初始化一些参数  <br>    FooTest() {}  <br>   virtual ~FooTest() {}  <br>  <br> //如果构造、析构还不能满足你，还有下面两个虚拟函数  <br> virtual void SetUp() {  <br>   // 在构造后调用  <br>    strExe.resize(MAX_PATH);  <br>    GetModuleFileName(NULL, &amp;strExe[0], MAX_PATH);  <br> }  <br>  <br> virtual void TearDown() { }   // 在析构前调用  <br> };  <br>  <br> tstring getfilename(const tstring &amp;full)  //偶写的从完整路径里取出文件名的函数(路径分隔符假定为'\\')  <br> {  <br> <span style="white-space:pre"></span>      return full.substr(full.rfind(_T('\\')));  <br> }  <br>  <br> tstring getpath(const tstring &amp;full)   //偶写的从完整路径里取出路径名的函数(Windows路径)  <br> {  <br> <span style="white-space:pre"></span>      return full.substr(0, full.rfind(_T('\\')));  <br> }  <br>  <br> TEST_F(FooTest, Test_GFN) //测试getfilename函数  <br> {  <br> <span style="white-space:pre"></span>      EXPECT_STREQ(_T("Projectexe"), getfilename(strExe).c_str());  <br> }  <br>  <br> TEST_F(FooTest, Test_GP) //测试getpath函数  <br> {  <br> <span style="white-space:pre"></span>      EXPECT_STREQ(_T("D:\\Code\\libs\\google\\gtest-1\\BCC_SPC\\bcc\\ex"), getpath(strExe).c_str());  <br> }  <br>  <br> int main(int argc, TCHAR* argv[])  //主函数还是一样地  <br> {  <br> <span style="white-space:pre"></span>      testing::InitGoogleTest(&amp;argc,argv);  <br> <span style="white-space:pre"></span>      RUN_ALL_TESTS();  <br>       std::cin.get();  <br>       return 0;  <br> } </p> 
<p></p> 
<p>快速入门:<br> Google提供了两种断言形式，一种以ASSERT_开头，另一种以EXPECT_开头，它们的区别是ASSERT_*一旦失败立马退出，而EXPECT_还能继续下去。</p> 
<p>断言列表:</p> 
<p>真假条件测试:</p> 
<p><br> 致命断言 非致命断言 验证条件<br> ASSERT_TRUE(condition ); EXPECT_TRUE(condition ); condition 为真<br> ASSERT_FALSE(condition ); EXPECT_FALSE(condition ); condition 为假</p> 
<p>数据对比测试:</p> 
<p><br> 致命断言 非致命断言 验证条件<br> ASSERT_EQ(期望值 , 实际值 ); EXPECT_EQ(期望值 , 实际值 ); 期望值 == 实际值<br> ASSERT_NE(val1 , val2 ); EXPECT_NE(val1 , val2 ); val1 != val2<br> ASSERT_LT(val1 , val2 ); EXPECT_LT(val1 , val2 ); val1 &lt; val2<br> ASSERT_LE(val1 , val2 ); EXPECT_LE(val1 , val2 ); val1 &lt;= val2<br> ASSERT_GT(val1 , val2 ); EXPECT_GT(val1 , val2 ); val1 &gt; val2<br> ASSERT_GE(val1 , val2 ); EXPECT_GE(val1 , val2 ); val1 &gt;= val2</p> 
<p>字符串(针对C形式的字符串，即char*或wchar_t*)对比测试:</p> 
<p><br> 致命断言 非致命断言 验证条件<br> ASSERT_STREQ(expected_str , actual_str ); EXPECT_STREQ(expected_str , actual_str ); 两个C字符串有相同的内容<br> ASSERT_STRNE(str1 , str2 ); EXPECT_STRNE(str1 , str2 ); 两个C字符串有不同的内容<br> ASSERT_STRCASEEQ(expected_str , actual_str ); EXPECT_STRCASEEQ(expected_str , actual_str ); 两个C字符串有相同的内容，忽略大小写<br> ASSERT_STRCASENE(str1 , str2 ); EXPECT_STRCASENE(str1 , str2 ); 两个C字符串有不同的内容，忽略大小写</p> 
<p><br> TEST宏:</p> 
<p>TEST宏的作用是创建一个简单测试，它定义了一个测试函数，在这个函数里可以使用任何C++代码并使用上面提供的断言来进行检查。</p> 
<p>TEST的第一个 参数是测试用例名，第二个 参数是测试用例中某项测试的名称。一个测试用例可以包含任意数量的独立测试。这两个参数组成了一个测试的全称。</p> 
<p>就前面的例子来说：</p> 
<p>我们要测试这个函数：int Factorial(int n); // 返回n的阶乘</p> 
<p>我们的测试用例是：测试输入0的情况，测试输入其它数据的情况，于是就有了:</p> 
<p>TEST(TestFactorial, ZeroInput) //第一个参数是测试用例名，第二个参数是测试名：随后的测试结果将以"测试用例名.测试名"的形式给出<br> {<!-- --><br> <span style="white-space:pre"></span>      EXPECT_EQ(1, Factorial(0));   //EXPECT_EQ稍候再说，现在只要知道它是测试两个数据是否相等的就行了。<br> }<br>  </p> 
<p>TEST(TestFactorial, OtherInput)<br> {<!-- --><br> <span style="white-space:pre"></span>      EXPECT_EQ(1, Factorial(1));<br> <span style="white-space:pre"></span>      EXPECT_EQ(2, Factorial(2));<br> <span style="white-space:pre"></span>      EXPECT_EQ(6, Factorial(3));<br> <span style="white-space:pre"></span>      EXPECT_EQ(40320, Factorial(8));<br> }</p> 
<p><br> Google Test根据测试用例来分组收集测试结果，因此，逻辑相关的测试应该在同一测试用例中；换句话说，它们的TEST（）的第一个参数应该是一样的。在上面的例子中，我们有两个测试，ZeroInput和OtherInput，它们都属于同一个测试用例TestFactorial。</p> 
<p><br> TEST_F宏:</p> 
<p>TEST_F宏用于在多个测试中使用同样的数据配置,所以它又叫：测试夹具（Test Fixtures）</p> 
<p>如果我们的多个测试要使用相同的数据(如前例中，我们的Test_GFN和Test_GP都使用程序自身的完整文件名来测试)，就可以采用一个测试夹具。</p> 
<p>要创建测试固件，只需：</p> 
<p>创建一个类继承自testing::Test。将其中的成员声明为protected:或是public:，因为我们想要从子类中存取夹具成员。<br> 在该类中声明测试中所要使用到的数据。<br> 如果需要，编写一个默认构造函数或者SetUp()函数来为每个测试准备对象。<br> 如果需要，编写一个析构函数或者TearDown()函数来释放你在SetUp()函数中申请的资源。<br> 如果需要，定义你的测试所需要共享的子程序。<br> 当我们要使用固件时，使用TEST_F()替换掉TEST()，它允许我们存取测试固件中的对象和子程序：</p> 
<p>TEST_F(test_case_name, test_name) {<!-- --><br> ... test body ...<br> }</p> 
<p>与TEST()一样，第一个参数是测试用例的名称，但对TEST_F()来说，这个名称必须与测试夹具类的名称一样。</p> 
<p>对于TEST_F()中定义的每个 测试，Google Test将会：</p> 
<p>创建一个全新的测试夹具<br> 通过SetUp()初始化它，<br> 运行测试<br> 调用TearDown()来进行清理工作<br> 删除测试夹具。<br> 注意，同一测试用例中，不同的测试拥有不同的测试夹具。Google Test不会对多个测试重用一个测试夹具，测试对测试夹具的改动并不会影响到其他测试。</p> 
<p><br> 调用测试</p> 
<p>TEST()和TEST_F()向Google Test隐式注册它们的测试。因此，与很多其他的C++测试框架不同，你不需要为了运行你定义的测试而将它们全部再列出来一次。</p> 
<p>在定义好测试后，你可以通过RUN_ALL_TESTS()来运行它们，如果所有测试成功，该函数返回0，否则会返回1.注意RUN_ALL_TESTS()会运行你链接到的所有测试——它们可以来自不同的测试用例，甚至是来自不同的文件。</p> 
<p>当被调用时，RUN_ALL_TESTS()宏会：</p> 
<p>保存所有的Google Test标志。<br> 为一个测试创建测试夹具对象。<br> 调用SetUp()初始化它。<br> 在固件对象上运行测试。<br> 调用TearDown()清理夹具。<br> 删除固件。<br> 恢复所有Google Test标志的状态。<br> 重复上诉步骤，直到所有测试完成。<br> 此外，如果第二步时，测试夹具的构造函数产生一个致命错误，继续执行3至5部显然没有必要，所以它们会被跳过。与之相似，如果第3部产生致命错误，第4部也会被跳过。</p> 
<p>重要：你不能忽略掉RUN_ALL_TESTS()的返回值，否则gcc会报一个编译错误。这样设计的理由是自动化测试服务会根据测试退出返回码来决定一个测试是否通过，而不是根据其stdout/stderr输出；因此你的main()函数必须返回RUN_ALL_TESTS()的值。</p> 
<p>而且，你应该只调用RUN_ALL_TESTS()一次。多次调用该函数会与Google Test的一些高阶特性（如线程安全死亡测试thread-safe death tests）冲突，因而是不被支持的。</p> 
<p><br> 编写 main() 函数</p> 
<p>你可以从下面这个模板开始:</p> 
<p>#include "this/package/foo.h"<br> #include &lt;gtest/gtest.h&gt;<br> namespace {<!-- --><br> // 测试Foo类的测试固件<br> class FooTest : public testing::Test {<!-- --><br> protected :<br>    // You can remove any or all of the following functions if its body<br>    // is empty.<br>    FooTest() {<!-- --><br>      // You can do set-up work for each test here.<br>    }<br>    virtual ~FooTest() {<!-- --><br>      // You can do clean-up work that doesn't throw exceptions here.<br>    }<br>    // If the constructor and destructor are not enough for setting up<br>    // and cleaning up each test, you can define the following methods:<br>    virtual void SetUp() {<!-- --><br>      // Code here will be called immediately after the constructor (right<br>      // before each test).<br>    }<br>    virtual void TearDown() {<!-- --><br>      // Code here will be called immediately after each test (right<br>      // before the destructor).<br>    }<br>    // Objects declared here can be used by all tests in the test case for Foo.<br> };<br> // Tests that the Foo::Bar() method does Abc.<br> TEST_F(FooTest, MethodBarDoesAbc) {<!-- --><br>    const string input_filepath = "this/package/testdata/myinputfile.dat" ;<br>    const string output_filepath = "this/package/testdata/myoutputfile.dat" ;<br>    Foo f;<br>    EXPECT_EQ(0, f.Bar(input_filepath, output_filepath));<br> }<br> // Tests that Foo does Xyz.<br> TEST_F(FooTest, DoesXyz) {<!-- --><br>    // Exercises the Xyz feature of Foo.<br> }<br> }   // namespace<br> int main( int argc, char **argv) {<!-- --><br>       testing::InitGoogleTest(&amp;argc, argv);<br>        return RUN_ALL_TESTS();<br> }</p> 
<p><br> testing::InitGoogleTest() 函数负责解析命令行传入的Google Test标志，并删除所有它可以处理的标志。这使得用户可以通过各种不同的标志控制一个测试程序的行为。关于这一点我们会在GTestAdvanced中讲到。你必须在调用RUN_ALL_TESTS()之前调用该函数，否则就无法正确地初始化标示。</p> 
<p>在Windows上InitGoogleTest()可以支持宽字符串，所以它也可以被用在以UNICODE模式编译的程序中。</p> 
<br> 
<p><br> </p> 
<p><br> </p> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3ab39a4f1c2518c65eda1443a61e921b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">常量指针和指针常量</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/224ddd51198804c06b06f57ee5776b61/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mysql的主从同步和分库分表</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>