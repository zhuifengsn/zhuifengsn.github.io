<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>openCV图像处理常用算法总结 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="openCV图像处理常用算法总结" />
<meta property="og:description" content="一、直方图和滤波器 1、直方图：在灰度图中，每个点的像素范围为 0~255 ，密度是具有该值的图像像素数量。
2、色彩均衡：色彩均衡的目的是获得分布更加均匀的直方图。其结果将会导致图像的对比度增加。
3、LUT色彩空间转换表：生成一个256个元素的矩阵，取得要从源空间变换到目标色彩空间的变换函数f(x)。从0到255，对每个数字带入到f(x)中，将得到的结果存入到矩阵中对应的位置。然后，对要处理的图像使用这个表就可以将全部色彩元素对应到相应的色彩空间，这样节省了大量的计算性能。
4、滤波器：这里滤波器我们可以理解为一个矩阵，将这个矩阵在对应的图像上滑过与图像上的每个点做点积运算（这个过程叫做卷积），即对图像进行了处理。滤波器主要分为两种：去噪声滤波器、边缘检测滤波器
1、去噪声滤波器：代表 高斯滤波器、均值滤波器、中值滤波器
高斯滤波器：高斯滤波器是一种线性滤波器，其卷积模板中的系数随着与模板中心的距离增大而减小，相比于均值滤波器，高斯滤波器对整个图像模糊程度较小，能够有效抑制噪声，平滑图像。
均值滤波器：使用相邻像素的平均值来代替原来的像素值，采用线性的方式，对整个图像起到平滑的作用，但也破坏了图像的细节信息，使得图像变得模糊。
中值滤波器：中值滤波器采用非线性的方式，使用卷积模板的中值来代替像素值，适用于处理椒盐噪声。
2、边缘检测滤波器（算子和滤波器的关系点这里查看）
sobel滤波器：Sobel算子是典型的基于一阶导数的边缘检测算子，是离散型的差分算子。
Roberts算子：Roberts边缘算子是一个2x2的模板，采用的是对角方向相邻的两个像素之差。从图像处理的实际效果来看，边缘定位较准，对噪声敏感。适用于边缘明显且噪声较少的图像分割。
Canny算子：该算子功能比前面几种都要好，但是它实现起来较为麻烦，Canny算子是一个具有滤波，增强，检测的多阶段的优化算子，在进行处理前，Canny算子先利用高斯平滑滤波器来平滑图像以除去噪声，Canny分割算法采用一阶偏导的有限差分来计算梯度幅值和方向，在处理过程中，Canny算子还将经过一个非极大值抑制的过程，最后Canny算子还采用两个阈值来连接边缘。
二、光学检查、对象分割、检测 1、背景去除算法
①减法 R = L - I：先取一张背景图，然后用包含检测目标的图与背景图做差，剩下的即为检测目标
②除法 R = 255 * (1 - (I / L))：方法同上不过运算时改用除法。
（注：如果无法获取背景，通常我们可以将原图采用图像大小的核的模糊方法，来获取背景）
2、二值化：即将图片分成色彩只有0和255的图像，一般用于灰度图。
3、连通组件：用于分割和识别二进制图像（二值化后的图像），如果两个像素具有相同的值并且他们是邻居则把他们连起来，有四连通、八连通两种形式。
4、查找轮廓：利用像素颜色深度等高线查找轮廓。
三、检测面部部位与覆盖面具 1、haar级联：一个基于haar特征的级联分类器，它是一组弱分类器的串联。（CascadeClassifier OpenCV中的类）
2、积分图像：简单来说就是以原点到各点所构成的矩形的面积做加减运算，从而得到所需要的计算区域的方法。这种方法因为计算公式固定不会受到图像放大或缩小的影响。
四、视频监控、背景建模、形态学操作 1、帧差分：计算当前帧与前一帧之间，以及当前帧与下一帧之间的绝对差值。然后采用这些帧差异并应用按位AND运算符。这一步运算将会突出显示图像中的移动部分。这种方法的主要问题是检测均匀着色的对象它只能检测均匀着色对象的边缘，原因是该对象的很大一部分有这非常低的像素差异。另外一个问题是无法检测对象是否朝相机运动或者远离相机运动。
2、高斯混合法：再每一帧图像的连续收集中每个部分将逐渐成为背景的一部分。如果场景是静态的，则模型会自行调整以确保背景模型被更新。
3、侵蚀：通过剥离图像中所有形状的边界层从而使形状变细的操作。
4、膨胀：通过向图像中所有的形状添加边界层来使形状变粗的操作。
5、形态开口：先侵蚀后膨胀
6、形态闭合：先膨胀后侵蚀
7、获取边界：获取膨胀和侵蚀之间的差异来获取
8、礼貌变换：输入图像与形态开口之间的差异。
9、黑帽变换：形态闭合与输入图像之间的差异。
五、对象跟踪 HSV：一种色彩空间，H色值，S饱和度，V明度
meanshift：当我们希望追踪一个感兴趣区域（ROI）时，在这个区域，我们根据颜色直方图选择若干点，并计算空间图心，如果图心位于该区域中心我们就知道这个对象没有移动，如果图心不在这个区域中心，我们就知道这个对象在某个方向移动了。它的问题是不允许改变边界框的大小。
CAMShift：在meanshift的基础上可以使边界适应对象的大小。选择好对象以后计算该对象的直方图反投影（一种识别图像与直方图模型匹配程度的方法）并提取所有信息。a、计算特定对象的直方图模型。b、使用这个模型在图像中找到该事物。 兴趣点：在计算机视觉中也被称为特征点，或者特征。兴趣点基本上是图像中唯一检测到的到东西。
Harris角点检测：要确定一块区域是否有一个角点，考虑所有的相邻区域并计算所有相邻区域的强度差异。如果在所有方向的差异都很大，那么我们就知道该区域有一个角点。
流光跟踪：稠密流光跟踪（Lucas-Kanade）、稀疏流光跟踪（Farneback）（算法详解）
图片来源：
https://zhuanlan.zhihu.com/p/111142437
https://zhuanlan.zhihu.com/p/56728333" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/79f3bcbe29b7c9906899367558cdacbf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-05-05T15:11:57+08:00" />
<meta property="article:modified_time" content="2020-05-05T15:11:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">openCV图像处理常用算法总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、直方图和滤波器</h3> 
<p><strong>1、直方图：</strong>在灰度图中，每个点的像素范围为 0~255 ，密度是具有该值的图像像素数量。</p> 
<p><img alt="" height="258" src="https://images2.imgbox.com/30/3d/Sqd2sSiW_o.png" width="633"></p> 
<p><strong>2、色彩均衡：</strong>色彩均衡的目的是获得分布更加均匀的直方图。其结果将会导致图像的对比度增加。</p> 
<p><img alt="" height="180" src="https://images2.imgbox.com/89/ce/XN6NPEFY_o.png" width="529"></p> 
<p>3、LUT色彩空间转换表：生成一个256个元素的矩阵，取得要从源空间变换到目标色彩空间的变换函数f(x)。从0到255，对每个数字带入到f(x)中，将得到的结果存入到矩阵中对应的位置。然后，对要处理的图像使用这个表就可以将全部色彩元素对应到相应的色彩空间，这样节省了大量的计算性能。</p> 
<p>4、滤波器：这里滤波器我们可以理解为一个矩阵，将这个矩阵在对应的图像上滑过与图像上的每个点做点积运算（这个过程叫做卷积），即对图像进行了处理。滤波器主要分为两种：去噪声滤波器、边缘检测滤波器</p> 
<p>1、去噪声滤波器：代表 高斯滤波器、均值滤波器、中值滤波器</p> 
<p><strong>高斯滤波器：</strong>高斯滤波器是一种线性滤波器，其卷积模板中的系数随着与模板中心的距离增大而减小，相比于均值滤波器，高斯滤波器对整个图像模糊程度较小，能够有效抑制噪声，平滑图像。</p> 
<p><strong>均值滤波器</strong>：使用相邻像素的平均值来代替原来的像素值，采用线性的方式，对整个图像起到平滑的作用，<strong>但也破坏了图像的细节信息，使得图像变得模糊。</strong></p> 
<p><strong>中值滤波器：</strong>中值滤波器采用非线性的方式，使用卷积模板的中值来代替像素值，适用于处理椒盐噪声。</p> 
<p>2、边缘检测滤波器（<a href="https://blog.csdn.net/xiaohaier8593/article/details/104418404/">算子和滤波器的关系点这里查看</a>）</p> 
<p><strong>sobel滤波器：</strong>Sobel算子是典型的基于一阶导数的边缘检测算子，是离散型的差分算子。</p> 
<p><img alt="" height="130" src="https://images2.imgbox.com/f6/3c/bgL1pz6O_o.png" width="378"></p> 
<p><strong>Roberts算子：</strong>Roberts边缘算子是一个2x2的模板，采用的是对角方向相邻的两个像素之差。从图像处理的实际效果来看，边缘定位较准，对噪声敏感。适用于边缘明显且噪声较少的图像分割。</p> 
<p><img alt="" height="82" src="https://images2.imgbox.com/6b/6d/QlYCAX6E_o.png" width="239"></p> 
<p><strong>Canny算子</strong>：该算子功能比前面几种都要好，但是它实现起来较为麻烦，Canny算子是一个具有滤波，增强，检测的多阶段的优化算子，在进行处理前，Canny算子先利用高斯平滑滤波器来平滑图像以除去噪声，Canny分割算法采用一阶偏导的有限差分来计算梯度幅值和方向，在处理过程中，Canny算子还将经过一个非极大值抑制的过程，最后Canny算子还采用两个阈值来连接边缘。</p> 
<p> </p> 
<h3>二、光学检查、对象分割、检测</h3> 
<p><strong>1、背景去除算法</strong></p> 
<p>①减法 R = L - I：先取一张背景图，然后用包含检测目标的图与背景图做差，剩下的即为检测目标</p> 
<p>②除法 R = 255 * (1 - (I / L))：方法同上不过运算时改用除法。</p> 
<p>（注：如果无法获取背景，通常我们可以将原图采用图像大小的核的模糊方法，来获取背景）</p> 
<p><strong>2、二值化：</strong>即将图片分成色彩只有0和255的图像，一般用于灰度图。</p> 
<p><strong>3、连通组件：</strong>用于分割和识别二进制图像（二值化后的图像），如果两个像素具有相同的值并且他们是邻居则把他们连起来，有四连通、八连通两种形式。</p> 
<p><strong>4、查找轮廓：</strong>利用像素颜色深度等高线查找轮廓。</p> 
<p> </p> 
<h3>三、检测面部部位与覆盖面具</h3> 
<p><strong>1、haar级联：</strong>一个基于haar特征的级联分类器，它是一组弱分类器的串联。（CascadeClassifier OpenCV中的类）</p> 
<p><strong>2、积分图像：</strong>简单来说就是以原点到各点所构成的矩形的面积做加减运算，从而得到所需要的计算区域的方法。这种方法因为计算公式固定不会受到图像放大或缩小的影响。</p> 
<p> </p> 
<h3>四、视频监控、背景建模、形态学操作</h3> 
<p><strong>1、帧差分</strong>：计算当前帧与前一帧之间，以及当前帧与下一帧之间的绝对差值。然后采用这些帧差异并应用按位AND运算符。这一步运算将会突出显示图像中的移动部分。这种方法的主要问题是检测均匀着色的对象它只能检测均匀着色对象的边缘，原因是该对象的很大一部分有这非常低的像素差异。另外一个问题是无法检测对象是否朝相机运动或者远离相机运动。</p> 
<p><strong>2、高斯混合法：</strong>再每一帧图像的连续收集中每个部分将逐渐成为背景的一部分。如果场景是静态的，则模型会自行调整以确保背景模型被更新。</p> 
<p><strong>3、侵蚀：</strong>通过剥离图像中所有形状的边界层从而使形状<strong>变细</strong>的操作。</p> 
<p><strong>4、膨胀：</strong>通过向图像中所有的形状添加边界层来使形状<strong>变粗</strong>的操作。</p> 
<p><strong>5、形态开口</strong>：先侵蚀后膨胀</p> 
<p><strong>6、形态闭合</strong>：先膨胀后侵蚀</p> 
<p><strong>7、获取边界：</strong>获取膨胀和侵蚀之间的差异来获取</p> 
<p><strong>8、礼貌变换：</strong>输入图像与形态开口之间的差异。</p> 
<p><strong>9、黑帽变换：</strong>形态闭合与输入图像之间的差异。</p> 
<p> </p> 
<h3>五、对象跟踪</h3> 
<p><strong>HSV：</strong>一种色彩空间，H色值，S饱和度，V明度</p> 
<p><strong>meanshift：</strong>当我们希望追踪一个感兴趣区域（ROI）时，在这个区域，我们根据颜色直方图选择若干点，并计算空间图心，如果图心位于该区域中心我们就知道这个对象没有移动，如果图心不在这个区域中心，我们就知道这个对象在某个方向移动了。它的问题是不允许改变边界框的大小。</p> 
<p><strong>CAMShift：</strong>在meanshift的基础上可以使边界适应对象的大小。选择好对象以后计算该对象的直方图反投影（一种识别图像与直方图模型匹配程度的方法）并提取所有信息。a、计算特定对象的直方图模型。b、使用这个模型在图像中找到该事物。 </p> 
<p><strong>兴趣点：</strong>在计算机视觉中也被称为特征点，或者特征。兴趣点基本上是图像中唯一检测到的到东西。</p> 
<p><strong>Harris角点检测：</strong>要确定一块区域是否有一个角点，考虑所有的相邻区域并计算所有相邻区域的强度差异。如果在所有方向的差异都很大，那么我们就知道该区域有一个角点。</p> 
<p><strong>流光跟踪：</strong>稠密流光跟踪（Lucas-Kanade）、稀疏流光跟踪（Farneback）（<a href="https://zhuanlan.zhihu.com/p/74460341" rel="nofollow">算法详解</a>）</p> 
<p><img alt="" height="134" src="https://images2.imgbox.com/2d/e2/IW5K9Yqo_o.png" width="399"></p> 
<p><img alt="" height="124" src="https://images2.imgbox.com/74/13/hgL2WAxc_o.png" width="265"></p> 
<p><img alt="" height="74" src="https://images2.imgbox.com/14/05/Jkt8txFd_o.png" width="244"></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>图片来源：</p> 
<p><a href="https://zhuanlan.zhihu.com/p/111142437" rel="nofollow">https://zhuanlan.zhihu.com/p/111142437</a></p> 
<p><a href="https://zhuanlan.zhihu.com/p/56728333" rel="nofollow">https://zhuanlan.zhihu.com/p/56728333</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2c98c0dba3619f8b365e55e4952842e0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Spring Cloud Feign】超时重试总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6728e20e43bdb24592fa6814252675eb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">贴一个我觉得在b站上很好的c&#43;&#43;课程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>