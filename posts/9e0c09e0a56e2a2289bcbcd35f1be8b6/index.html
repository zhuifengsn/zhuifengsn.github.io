<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于单链表的多项式问题 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基于单链表的多项式问题" />
<meta property="og:description" content="上学期的东西了，不想再去细究思路了，直接贴代码，注释很详细
#pragma once #include&lt;iostream&gt; using namespace std; class LinkNode { public: float coef;//系数 int expn;//指数 LinkNode *link;//指向后继的指针域 LinkNode *plink;//指向前驱的指针域 public: LinkNode(); LinkNode(float co,int ex); ~LinkNode(); friend istream&amp; operator&gt;&gt; (istream&amp; input,LinkNode&amp; L);//输入重载 friend ostream&amp; operator&lt;&lt; (ostream&amp; output,LinkNode&amp; L);//输出重载 //friend operator= () }; #include&#34;LinkNode.h&#34; #include&lt;iostream&gt; using namespace std; LinkNode::LinkNode() { expn = -1; } LinkNode::LinkNode(float co,int ex) { coef = co; expn = ex; link = NULL; plink = NULL; } LinkNode::~LinkNode() {} //istream&amp; operator&gt;&gt; (istream&amp; input,LinkNode&amp; L) //{ //input&gt; //} ostream&amp; operator&lt;&lt; (ostream&amp; output,LinkNode&amp; L) { if(L." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/9e0c09e0a56e2a2289bcbcd35f1be8b6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-03-23T23:20:53+08:00" />
<meta property="article:modified_time" content="2013-03-23T23:20:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于单链表的多项式问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-size:18px">上学期的东西了，不想再去细究思路了，直接贴代码，注释很详细</span></p> 
<p><span style="font-size:18px"></span></p> 
<pre><code class="language-cpp">#pragma once
#include&lt;iostream&gt;
using namespace std;
class LinkNode
{
public:
	float coef;//系数
	int expn;//指数
	LinkNode *link;//指向后继的指针域
	LinkNode *plink;//指向前驱的指针域
public:
	LinkNode();
	LinkNode(float co,int ex);
	~LinkNode();
	friend istream&amp; operator&gt;&gt; (istream&amp; input,LinkNode&amp; L);//输入重载
	friend ostream&amp; operator&lt;&lt; (ostream&amp; output,LinkNode&amp; L);//输出重载
	//friend operator= ()
};

</code></pre> 
<pre><code class="language-cpp">#include"LinkNode.h"
#include&lt;iostream&gt;
using namespace std;
LinkNode::LinkNode()
{
	expn = -1;
}
LinkNode::LinkNode(float co,int ex)
{
	coef = co;
	expn = ex;
	link = NULL;
	plink = NULL;
}
LinkNode::~LinkNode()
{}
//istream&amp; operator&gt;&gt; (istream&amp; input,LinkNode&amp; L)
//{
	//input&gt;
//}
ostream&amp; operator&lt;&lt; (ostream&amp; output,LinkNode&amp; L)
{
	if(L.coef &gt; 0)
		output&lt;&lt;"+";
	output&lt;&lt;L.coef;
	if(L.expn &gt; 0)
		output&lt;&lt;"^"&lt;&lt;L.expn;
	return output;
}</code></pre> 
<pre><code class="language-cpp">#pragma once
#include"LinkNode.h"
#include&lt;iostream&gt;
using namespace std;
class Polynomial
{
protected:
	LinkNode *first;//依旧首指针
	LinkNode *rear;
public:
	Polynomial();
	Polynomial(LinkNode * fir);//复制函数而定义的构造函数
	Polynomial(Polynomial &amp;P);//深复制
	~Polynomial();
	void makeEmpty();
	void input();//输入
	void output();//输出
	void Sort();//指数升序排序
	int Length();//返回元素个数
	void Settle();//整理多项式 包括合并 与排序
	LinkNode * GetHead();
	LinkNode *Getrear();
	void reverse_order();
	friend istream&amp; operator&gt;&gt; (istream&amp; input,Polynomial &amp;P);//重载输入流
	friend ostream&amp; operator&lt;&lt; (ostream&amp; output,Polynomial &amp;P);//重载输出流
	friend Polynomial operator+ (Polynomial &amp;P1,Polynomial &amp;P2);//友元便于操作与不收类函数的限制
	friend Polynomial operator- (Polynomial &amp;P1,Polynomial &amp;P2);
	friend Polynomial operator* (Polynomial &amp;P1,Polynomial &amp;P2);
	void operator= (Polynomial &amp;P);
};
</code></pre> 
<br> 
<pre><code class="language-cpp">#include"Polynomial.h"
#include&lt;iostream&gt;
using namespace std;
Polynomial::Polynomial()
{
	first = new LinkNode;//开辟头结点，初始化指数域为-1
	rear = first;
}
Polynomial::Polynomial(LinkNode * fir)
{
	first = new LinkNode;
	first-&gt;link = fir;//在头结点的后面接上一串
}
Polynomial::Polynomial(Polynomial &amp;P)
{
	LinkNode *srcptr = P.GetHead();
	if(srcptr == NULL)
		exit(1);
	LinkNode *destptr = first = new LinkNode;//初始化当前多项式
	LinkNode *newNode;
	float current_coef;//用于记录当前系数
	int current_expn;//记录当前指数
	while(srcptr-&gt;link != NULL)
	{
		current_coef = srcptr-&gt;link-&gt;coef;
		current_expn = srcptr-&gt;link-&gt;expn;

		newNode = new LinkNode(current_coef,current_expn);
		destptr-&gt;link = newNode;

		srcptr = srcptr-&gt;link;
		destptr = destptr-&gt;link;
	}
}

Polynomial::~Polynomial()
{
	//makeEmpty();//是在不懂为什么不行 先注释掉
}
void Polynomial::makeEmpty()
{
	LinkNode * del;
	while(first-&gt;link != NULL)//如果为空表则头结点的指针域为NULL不会执行循环
	{
		del = first-&gt;link ;//不为空表第一次循环的情况下，把第1个结点的指针赋给了del指针
		first-&gt;link = del-&gt;link ;//把当前要删除的结点的后面一个节点接在头结点指针域上, 在最后循环结束之前最后结点的NULL赋给了first-&gt;link,所以会跳出
		delete del ;
	}
}

istream&amp; operator&gt;&gt; (istream&amp; input,Polynomial &amp;P)
{
	LinkNode *last = P.GetHead();//头指针赋值一份
	LinkNode *newNode;
	float current_coef;//用于记录当前系数
	int current_expn;//记录当前指数
	input&gt;&gt;current_coef&gt;&gt;current_expn;
	while(current_coef != 0)
	{
		newNode = new LinkNode(current_coef,current_expn);
		last-&gt;link = newNode;
		newNode-&gt;plink = last;
		last = last-&gt;link;

		input&gt;&gt;current_coef&gt;&gt;current_expn;
	}
	P.rear = last;
	P.Sort();//输入完毕后开始合并 并排序默认升序
	P.Settle();//在排序后直接合并同类项
	return input;

}

ostream&amp; operator&lt;&lt; (ostream&amp; output,Polynomial &amp;P)
{
	LinkNode *current = P.GetHead()-&gt;link;
	while(current != NULL)
	{
		cout&lt;&lt;*current;
		current = current-&gt;link;
	}

	return output;
}
void Polynomial::Sort()//指数升序排序
{

	LinkNode  *current1,*current2 ;
	for(current1=first-&gt;link;current1!=NULL;current1=current1-&gt;link)
	{
		for(current2=current1-&gt;link;current2!=NULL;current2=current2-&gt;link)
		{
			if(current1-&gt;expn &gt; current2-&gt;expn)
			{
				int expn_temp;//指数临时存储变量
				expn_temp = current1-&gt;expn;
				current1-&gt;expn = current2-&gt;expn;
				current2-&gt;expn = expn_temp;
				float coef_temp;//系数临时存储变量
				coef_temp = current1-&gt;coef;
				current1-&gt;coef = current2-&gt;coef;
				current2-&gt;coef = coef_temp;
			}
		}
	}
}

int Polynomial::Length()
{
	LinkNode * current = first ;
	int elemnum = 0;
	while(current-&gt;link != NULL)//如果头结点指针域为NULL则不执行循环直接返回0值
	{
		current = current-&gt;link ;
		elemnum++;
	}
	return elemnum;
}
LinkNode * Polynomial::GetHead()
{
	return first;
}
LinkNode * Polynomial::Getrear()
{
	return rear;
}
void Polynomial::reverse_order()
{
	int elemnum = Length();//调用求长度函数 获取多项式的元素个数
	LinkNode *current1 = first-&gt;link; //首端
	LinkNode *current2 = rear;//尾端 开始逆置
	for(int idx = 0; idx &lt; elemnum/2 ;idx++)
	{
		int expn_temp;//指数临时存储变量
		expn_temp = current1-&gt;expn;
		current1-&gt;expn = current2-&gt;expn;
		current2-&gt;expn = expn_temp;

		float coef_temp;//系数临时存储变量
		coef_temp = current1-&gt;coef;
		current1-&gt;coef = current2-&gt;coef;
		current2-&gt;coef = coef_temp;
		current1 = current1-&gt;link;
		current2 = current2-&gt;plink;
	}
}

Polynomial operator+ (Polynomial &amp;P1,Polynomial &amp;P2)
{
	P1.Sort(); P2.Sort();//先对两个多项式进行指数升序排序,便于后面的合并
	LinkNode *current1 = P1.GetHead() -&gt;link;//获取两个头指针
	LinkNode *current2 = P2.GetHead() -&gt;link;
	LinkNode *current3;//用于循环跳出后的指针承接
	LinkNode *newNode;//每次重新开辟结点
	LinkNode *last,*pol;//用于记录最后相加结果的头指针,最后要以他为参数返回一个Polynomial类
	last = pol = new LinkNode;

	float coef_elem;
	int expn_elem;
	while(current1!=NULL &amp;&amp; current2!=NULL)//在两个指针都不为空的时候进行指数比较,否则跳出
	{
		if(current1-&gt;expn &lt; current2-&gt;expn)
		{
			coef_elem = current1-&gt;coef;
			expn_elem = current1-&gt;expn;
			newNode = new LinkNode(coef_elem,expn_elem);

			last-&gt;link = newNode;//新开辟的结点连接在last的后面
			last = last-&gt;link;

			current1 = current1-&gt;link;
			continue;
		}
		if(current1-&gt;expn &gt; current2-&gt;expn)
		{
			coef_elem = current2-&gt;coef;
			expn_elem = current2-&gt;expn;
			newNode = new LinkNode(coef_elem,expn_elem);

			last-&gt;link = newNode;//新开辟的结点连接在last的后面
			last = last-&gt;link;

			current2 = current2-&gt;link;
			continue;
		}
		if(current1-&gt;expn == current2-&gt;expn)//当比较到两个指数相同时候
		{
			if(current1-&gt;coef + current2-&gt;coef == 0)//系数相加为0 则两指针都后移
			{
				current1 = current1-&gt;link;
				current2 = current2-&gt;link;
				continue;//如果在指数相等的情况下系数相加为0则两个指针全都后移一位 直接调相下一次循环比较
			}
			if(current1-&gt;coef + current2-&gt;coef != 0)//如果不等于0 则指定一个加到另一个上 也都后移
			{
				coef_elem = current1-&gt;coef + current2-&gt;coef;//系数相加
				expn_elem = current1-&gt;expn;
		    	newNode = new LinkNode(coef_elem,expn_elem);

			    last-&gt;link = newNode;//新开辟的结点连接在last的后面
			    last = last-&gt;link;

			    current1 = current1-&gt;link;//两个指针都后移一位
				current2 = current2-&gt;link;
				continue;
			}
		}
	}
	if(current1==NULL &amp;&amp; current2==NULL)//如果循环跳出时 可能是都结束了则直接返回多项式避免了后面的操作
	{
		return Polynomial(pol-&gt;link);
	}
	//跳出循环进入NULL判断
	current3 = ((current1 == NULL) ? current2 : current1);
	while(current3 != NULL)
	{
		coef_elem = current3-&gt;coef;
		expn_elem = current3-&gt;expn;

		newNode = new LinkNode(coef_elem,expn_elem);
		last-&gt;link = newNode;//新开辟的结点连接在last的后面
		last = last-&gt;link;
		current3 = current3-&gt;link;
	}
	return Polynomial(pol-&gt;link);//最正常情况下的返回
}
void Polynomial::operator= (Polynomial &amp;P)
{
	//makeEmpty();
	LinkNode *srcptr = P.GetHead();
	if(srcptr == NULL)
		exit(1);
	LinkNode *destptr = first;//初始化当前多项式
	LinkNode *newNode;
	float current_coef;//用于记录当前系数
	int current_expn;//记录当前指数
	while(srcptr-&gt;link != NULL)
	{
		current_coef = srcptr-&gt;link-&gt;coef;
		current_expn = srcptr-&gt;link-&gt;expn;

		newNode = new LinkNode(current_coef,current_expn);
		destptr-&gt;link = newNode;

		srcptr = srcptr-&gt;link;
		destptr = destptr-&gt;link;
	}
}

void Polynomial::Settle()
{
	LinkNode *current1,*current2;//在默认升序排序后的合并同类项
	LinkNode *del;
	for(current1=first-&gt;link;current1-&gt;link!=NULL;current1=current1-&gt;link)//循环终止条件是关键 外层只需进行到倒数第二个
	{//外层开始从第一个开始循环
		current2 = current1-&gt;link;//把后一个的指针赋给2
		for(; ;)
		{//这里的死循环是为了解决 合并后 指针后一问题
			if(current2-&gt;expn != current1-&gt;expn)//只要条件成立 说明可以跳出内层死循环 外层开始下一次循环
				break;
			if(current2-&gt;expn == current1-&gt;expn)
			{//2始终在1的后面，确保这一点非常有利于写合并于删除算法
				current1-&gt;coef = current1-&gt;coef + current2-&gt;coef;//系数相加
				del = current2;
				current1-&gt;link = del-&gt;link;
				delete del;
				current2 = current1-&gt;link;
				if(current2 == NULL)//此步骤 是合并算法的最后一步判断标准
					return ;
			}
		}
	}
}

Polynomial operator* (Polynomial &amp;P1,Polynomial &amp;P2)
{
	P1.Sort();P1.Settle();//分别合并同类项 减少运算次数
	P2.Sort();P2.Settle();
	LinkNode *current1 = P1.GetHead()-&gt;link;
	LinkNode *last,*pol;
	LinkNode *newNode;
	last = pol = new LinkNode;//开辟新头结点 用于承接相乘之后的多项式
	float elem_coef;
	int elem_expn;
	for(; current1 != NULL; current1 =current1-&gt;link)
	{
		LinkNode *current2 = P2.GetHead()-&gt;link;//每次外层循环开始都需要把内层指针置为首指针
		for(; current2 != NULL; current2 = current2-&gt;link)
		{
			elem_coef = (current1-&gt;coef) * (current2-&gt;coef);//系数相乘
			elem_expn = (current1-&gt;expn) + (current2-&gt;expn);//指数相加
			newNode = new LinkNode(elem_coef,elem_expn);//每一次相乘的结果做成结点
			last-&gt;link = newNode;//接在pol的后面
			last = last-&gt;link;//last指针后移
		}
	}
	Polynomial POL(pol-&gt;link);//生成一个多项式
	POL.Sort();POL.Settle();//合并同类项
	return POL;//返回一个多项式对象
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e3998c1f92c45d66b6447304c3441a26/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Wi-Fi直连</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a5e7fccd5895a124a6c9f3b9d59470b9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">WPF界面加载显示数据库表中内容</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>