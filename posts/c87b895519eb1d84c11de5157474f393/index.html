<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>洛谷题解——P1443：马的遍历 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="洛谷题解——P1443：马的遍历" />
<meta property="og:description" content="题目相关 题目链接 洛谷，https://www.luogu.com.cn/problem/P1443。
题目描述 有一个 n*m 的棋盘 (1 &lt; n, m &lt;= 400)，在某个点上有一个马，要求你计算出马到达棋盘上任意一个点最少要走几步？
输入格式 一行四个数据，棋盘的大小和马的坐标。
输出格式 一个 n*m 的矩阵，代表马到达某个点最少要走几步（左对齐，宽 5 格，不能到达则输出 -1）。
输入样例 3 3 1 1 输出样例 0 3 2 3 -1 1 2 1 4 题目分析 题意分析 告诉我们一个棋盘大小为 n*m，再告诉我们一个起点坐标 x,y。要求我们算出到棋盘所有点最少要走几步。
从最少这个字可以看出，本题可以考虑使用 BFS 来实现。
样例数据分析 根据样例输入，我们知道棋盘大小为 3*3，开始位置为 1,1。注意，本题开始的不是零。下面我们来绘制一下到各个点需要的最少步数。我们知道不管国际象棋还是中国象棋，马都是走“日”字。如下图所示：
也就是说，马的可能走法有 8 种。可以参考如下定义方式：
//坐标定义 typedef struct _POS { int x, y; } POS; //马所有移动方式定义 const POS moves[] = {{1,-2}, {2,-1},{2,1},{1,2},{-1,2},{-2,1},{-2,-1},{-1,-2}}; 1,1 点 就是自己，自然不需要移动已经到了，也就是说输出 0。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/c87b895519eb1d84c11de5157474f393/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-10T10:49:52+08:00" />
<meta property="article:modified_time" content="2020-03-10T10:49:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">洛谷题解——P1443：马的遍历</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>题目相关</h2> 
<h3><a name="t1"></a>题目链接</h3> 
<p>洛谷，<a href="https://www.luogu.com.cn/problem/P1443" rel="nofollow">https://www.luogu.com.cn/problem/P1443</a>。</p> 
<h3>题目描述</h3> 
<p>有一个 n*m 的棋盘 (1 &lt; n, m &lt;= 400)，在某个点上有一个马，要求你计算出马到达棋盘上任意一个点最少要走几步？</p> 
<h3>输入格式</h3> 
<p>一行四个数据，棋盘的大小和马的坐标。</p> 
<h3>输出格式</h3> 
<p>一个 n*m 的矩阵，代表马到达某个点最少要走几步（左对齐，宽 5 格，不能到达则输出 -1）。</p> 
<h3>输入样例</h3> 
<pre><code>3 3 1 1</code></pre> 
<h3>输出样例</h3> 
<pre><code>0    3    2    
3    -1   1    
2    1    4    </code></pre> 
<h2>题目分析</h2> 
<h3><a name="t9"></a>题意分析</h3> 
<p>告诉我们一个棋盘大小为 n*m，再告诉我们一个起点坐标 x,y。要求我们算出到棋盘所有点最少要走几步。</p> 
<p>从最少这个字可以看出，本题可以考虑使用 BFS 来实现。</p> 
<h3>样例数据分析</h3> 
<p>根据样例输入，我们知道棋盘大小为 3*3，开始位置为 1,1。注意，本题开始的不是零。下面我们来绘制一下到各个点需要的最少步数。我们知道不管国际象棋还是中国象棋，马都是走“日”字。如下图所示：</p> 
<p><img alt="" height="211" src="https://images2.imgbox.com/6d/a0/bZWjM6Ys_o.png" width="265"></p> 
<p>也就是说，马的可能走法有 8 种。可以参考如下定义方式：</p> 
<pre><code>//坐标定义
typedef struct _POS {
    int x, y;
} POS;

//马所有移动方式定义
const POS moves[] = {<!-- -->{1,-2}, {2,-1},{2,1},{1,2},{-1,2},{-2,1},{-2,-1},{-1,-2}};</code></pre> 
<h4>1,1 点</h4> 
<p>就是自己，自然不需要移动已经到了，也就是说输出 0。</p> 
<h4>2,1 点</h4> 
<p>从 1,1 出发要到 2,1 ，移动的方法如下图所示：1,1 -&gt; 3,2 -&gt; 1,3 -&gt; 2,1，这样一共走了 3 次。</p> 
<p><img alt="" height="75" src="https://images2.imgbox.com/fe/d7/vN5azQa7_o.png" width="75"></p> 
<h4>3,1 点</h4> 
<p>从 1,1 出发要到 3,1 ，移动的方法如下图所示：1,1 -&gt; 2,3 -&gt; 3,1，这样一共走了 2 次。</p> 
<p><img alt="" height="75" src="https://images2.imgbox.com/1c/83/O0G1hOPk_o.png" width="75"></p> 
<h4>1,2 点</h4> 
<p>从 1,1 出发要到 1,2 ，移动的方法如下图所示：1,1 -&gt; 2,3 -&gt; 3,1 -&gt; 1,2，这样一共走了 3 次。</p> 
<p><img alt="" height="75" src="https://images2.imgbox.com/ec/34/NlTe7qxX_o.png" width="76"></p> 
<h4>2,2 点</h4> 
<p>从 1,1 出发要到 2,2 ，不管怎么走都没法走到，这样输出 -1。</p> 
<h4>3,2 点</h4> 
<p>从 1,1 出发要到 3,2 ，移动的方法如下图所示：1,1 -&gt; 3,2，这样一共走了 1 次。</p> 
<p><img alt="" height="75" src="https://images2.imgbox.com/da/00/FrWWuPZK_o.png" width="76"></p> 
<h4>1,3 点</h4> 
<p>从 1,1 出发要到 1,3 ，移动的方法如下图所示：1,1 -&gt; 3,2 -&gt; 1,3，这样一共走了 2 次。</p> 
<p><img alt="" height="76" src="https://images2.imgbox.com/58/a8/skqm1uxe_o.png" width="76"></p> 
<h4>2,3 点</h4> 
<p>从 1,1 出发要到 2,3 ，移动的方法如下图所示：1,1 -&gt; 2,3，这样一共走了 1 次。</p> 
<p><img alt="" height="76" src="https://images2.imgbox.com/c1/5c/s7EZIT5f_o.png" width="76"></p> 
<h4>3,3 点</h4> 
<p>从 1,1 出发要到 3,3 ，移动的方法如下图所示：1,1 -&gt; 3,2 -&gt; 1,3 -&gt; 2,1 -&gt; 3,3，这样一共走了 4 次。</p> 
<p><img alt="" height="75" src="https://images2.imgbox.com/4c/8e/jjvxTKpr_o.png" width="76"></p> 
<p>从上面分析可知，最终的输出结果为：</p> 
<pre><code>0    3    2    
3    -1   1    
2    1    4    </code></pre> 
<p>因此，只需要使用 BFS 遍历 n*m 棋盘的所有点，记录每个点到起点的距离即可。</p> 
<h3>编程思路</h3> 
<p>从上面的数据分析中，我们可以得出，本题是一个 BFS 的模板题。</p> 
<p>1、读入数据。</p> 
<p>2、从指定起点开始使用 BFS 遍历矩阵，记录所有位置到起点的距离。</p> 
<p>3、输出距离。</p> 
<h3>AC 参考代码</h3> 
<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;

const int MAXN = 4e2+2;
struct MAZE {
	int row, col;
	int x1, y1;
	bool visit[MAXN][MAXN];//
	int  dis[MAXN][MAXN]; 
};

struct POS {
	int x, y;
};

void bfs(MAZE &amp;maze) {
	//压入起点
	POS cur;
	cur.x = maze.x1;
	cur.y = maze.y1;
	maze.dis[maze.x1][maze.y1] = 0;
	maze.visit[maze.x1][maze.y1]=true;
	
	std::queue&lt;POS&gt; q;
	q.push(cur);
	
	POS next;
	const POS move[] = {<!-- -->{1,-2},{2,-1},{2,1},{1,2},{-1,2},{-2,1},{-2,-1},{-1,-2}};//移动方法 
	
	int i;
	while (q.empty() != true) {
		//遍历
		cur = q.front();
		q.pop();
		
		//开始移动
		for (i=0; i&lt;8; i++) {
			next.x = cur.x+move[i].x;
			next.y = cur.y+move[i].y;
			
			//判断是否可以移动 
			if (next.x&gt;=1&amp;&amp;next.x&lt;=maze.row&amp;&amp;next.y&gt;=1&amp;&amp;next.y&lt;=maze.col&amp;&amp;maze.visit[next.x][next.y]==false) {
				maze.dis[next.x][next.y] = maze.dis[cur.x][cur.y] + 1;
				maze.visit[next.x][next.y]=true;
				q.push(next);
			}
		}
	}
}

int main() {
	//freopen("4.out", "w", stdout);
	MAZE maze = {};
	
	scanf("%d %d %d %d", &amp;maze.row, &amp;maze.col, &amp;maze.x1, &amp;maze.y1);
	
        memset((void*)maze.dis, -1, sizeof(maze.dis));//将起点到所有点距离设置为-1
	bfs(maze);
	
	int i, j;
	for (i=1; i&lt;=maze.row; i++) {
		for (j=1; j&lt;=maze.col; j++) {
			printf("%-5d", maze.dis[i][j]);
		}
		printf("\n");
	}
	//fclose(stdout);
	
	return 0;
} </code></pre> 
<h4>程序解读</h4> 
<p>1、由于题目输出有格式要求，即左对齐，宽 5 格。因此使用 printf 比较简单。代码如下：</p> 
<pre><code>printf("%-5d", xxxxxx);</code></pre> 
<p>其中 - 表示左对齐，5 表示占位格数。</p> 
<p>2、关于无法到达点距离问题。这个问题有两个解决方法。</p> 
<p>方案一：开始的时候，将所有点到起点的距离设置为 -1。通过 BFS 遍历一次棋盘后，所有不能到达的位置距离自然不会变化。代码如下：</p> 
<pre><code>memset((void*)maze.dis, -1, sizeof(maze.dis));</code></pre> 
<p>方案二：输出的时候配合 vis 矩阵，所有距离为 0 的点，如果 vis[i][j] 对应的值为 false，说明无法访问到，输出 -1 即可。代码如下：</p> 
<pre><code>for (i=1; i&lt;=maze.row; i++) {
    for (j=1; j&lt;=maze.col; j++) {
        if (false == maze.vis[i][j]) {
            //需要排除起点
            if (i==maze.x1 &amp;&amp; j==maze.y1) {
                //起点
                printf("%-5d", 0);
            } else {
                printf("%-5d", -1);
            }
        } else {
            printf("%-5d", maze.dis[i][j]);
        }
    }
    printf("\n");
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8d10c500c4ff0826306b0d16c08ef5ff/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Sql Server如何彻底清除字符串里的普通空格以及特殊的空格</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/231c505bf834f416bf72a91244360f24/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">(K8S实践2)Pod常用操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>