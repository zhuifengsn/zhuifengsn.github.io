<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2023年Redis面试题（持续更新） - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2023年Redis面试题（持续更新）" />
<meta property="og:description" content="目录 1 redis基础redis 中的数据类型有哪些为什么说redis能够快速执行 2 Redis中的五种数据结构string (字符串)list (列表)set (集合)hash (哈希)zset (有序集合) 3 Redis的持久化Redis 的持久化机制Redis 持久化方案的建议Redis 持久化方案的优缺点 4 缓存穿透、缓存击穿、缓存雪崩解决方案缓存穿透缓存击穿缓存雪崩 5 Redis 的集群模式主从复制哨兵模式 6 Redis分布式锁使用过Redis分布式锁么，它是什么回事？红锁 7 一些问题内存淘汰机制Redis 和 Mysql 的数据不一致怎么办Redis常见性能问题和解决方案：mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？项目中有没有用Redis事务布隆过滤器redis 跳表原理一致性hash算法 8 参考 1 redis基础 redis 中的数据类型有哪些 Redis 有 5 种基础数据结构，分别为：string (字符串)、list (列表)、set (集合)、hash (哈希) 和 zset (有序集合)。
Redis 的列表相当于 Java 语言里面的 LinkedList，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)，这点让人非常意外。 当列表弹出了最后一个元素之后，该数据结构自动被删除，内存被回收。
Redis 的哈希相当于 Java 语言里面的 HashMap，它是无序字典。内部实现结构上同 Java 的 HashMap 也是一致的，同样的数组 &#43; 链表二维结构。第一维 hash 的数组位置碰撞时，就会将碰撞的元素使用链表串接起来。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/abac7b32cd2e0e01c55aa48c79ec7714/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-16T11:12:14+08:00" />
<meta property="article:modified_time" content="2023-05-16T11:12:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2023年Redis面试题（持续更新）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#1_redis_2" rel="nofollow">1 redis基础</a></li><li><ul><li><a href="#redis__3" rel="nofollow">redis 中的数据类型有哪些</a></li><li><a href="#redis_15" rel="nofollow">为什么说redis能够快速执行</a></li></ul> 
  </li><li><a href="#2_Redis_23" rel="nofollow">2 Redis中的五种数据结构</a></li><li><ul><li><a href="#string__25" rel="nofollow">string (字符串)</a></li><li><a href="#list__46" rel="nofollow">list (列表)</a></li><li><a href="#set__74" rel="nofollow">set (集合)</a></li><li><a href="#hash__80" rel="nofollow">hash (哈希)</a></li><li><a href="#zset__89" rel="nofollow">zset (有序集合)</a></li></ul> 
  </li><li><a href="#3_Redis_117" rel="nofollow">3 Redis的持久化</a></li><li><ul><li><a href="#Redis__119" rel="nofollow">Redis 的持久化机制</a></li><li><a href="#Redis__133" rel="nofollow">Redis 持久化方案的建议</a></li><li><a href="#Redis__141" rel="nofollow">Redis 持久化方案的优缺点</a></li></ul> 
  </li><li><a href="#4__153" rel="nofollow">4 缓存穿透、缓存击穿、缓存雪崩解决方案</a></li><li><ul><li><a href="#_155" rel="nofollow">缓存穿透</a></li><li><a href="#_165" rel="nofollow">缓存击穿</a></li><li><a href="#_175" rel="nofollow">缓存雪崩</a></li></ul> 
  </li><li><a href="#5_Redis__184" rel="nofollow">5 Redis 的集群模式</a></li><li><ul><li><a href="#_186" rel="nofollow">主从复制</a></li><li><a href="#_192" rel="nofollow">哨兵模式</a></li></ul> 
  </li><li><a href="#6_Redis_212" rel="nofollow">6 Redis分布式锁</a></li><li><ul><li><a href="#Redis_214" rel="nofollow">使用过Redis分布式锁么，它是什么回事？</a></li><li><a href="#_220" rel="nofollow">红锁</a></li></ul> 
  </li><li><a href="#7__231" rel="nofollow">7 一些问题</a></li><li><ul><li><a href="#_232" rel="nofollow">内存淘汰机制</a></li><li><a href="#Redis__Mysql__242" rel="nofollow">Redis 和 Mysql 的数据不一致怎么办</a></li><li><a href="#Redis_268" rel="nofollow">Redis常见性能问题和解决方案：</a></li><li><a href="#mySQL2000wredis20wredis_280" rel="nofollow">mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据</a></li><li><a href="#Redis1key10wkey_301" rel="nofollow">Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？</a></li><li><a href="#Redis_304" rel="nofollow">项目中有没有用Redis事务</a></li><li><a href="#_308" rel="nofollow">布隆过滤器</a></li><li><a href="#redis__311" rel="nofollow">redis 跳表原理</a></li><li><a href="#hash_314" rel="nofollow">一致性hash算法</a></li></ul> 
  </li><li><a href="#8__317" rel="nofollow">8 参考</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1_redis_2"></a>1 redis基础</h2> 
<h3><a id="redis__3"></a>redis 中的数据类型有哪些</h3> 
<p>Redis 有 5 种基础数据结构，分别为：string (字符串)、list (列表)、set (集合)、hash (哈希) 和 zset (有序集合)。</p> 
<p>Redis 的列表相当于 Java 语言里面的 LinkedList，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)，这点让人非常意外。 当列表弹出了最后一个元素之后，该数据结构自动被删除，内存被回收。</p> 
<p>Redis 的哈希相当于 Java 语言里面的 HashMap，它是无序字典。内部实现结构上同 Java 的 HashMap 也是一致的，同样的数组 + 链表二维结构。第一维 hash 的数组位置碰撞时，就会将碰撞的元素使用链表串接起来。</p> 
<p>Redis 的集合相当于 Java 语言里面的 HashSet，它内部的键值对是无序的唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值NULL。 当集合中最后一个元素移除之后，数据结构自动删除，内存被回收。</p> 
<p>zset 类似于 Java 的 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权重。</p> 
<h3><a id="redis_15"></a>为什么说redis能够快速执行</h3> 
<p>i. 绝大部分请求是纯粹的内存操作（非常快速）</p> 
<p>ii. 采用单线程,避免了不必要的上下文切换和竞争条件</p> 
<p>iii. 非阻塞IO - IO多路复用</p> 
<h2><a id="2_Redis_23"></a>2 Redis中的五种数据结构</h2> 
<h3><a id="string__25"></a>string (字符串)</h3> 
<p>redis是使用C语言开发，但C中并没有字符串类型，只能使用指针或符数组的形式表示一个字符串，所以redis设计了一种简单动态字符串(SDS[Simple Dynamic String])作为底实现：</p> 
<p>定义SDS对象，此对象中包含三个属性：</p> 
<ul><li>len buf中已经占有的长度(表示此字符串的实际长度)</li><li>free buf中未使用的缓冲区长度</li><li>buf[] 实际保存字符串数据的地方</li></ul> 
<p>所以取字符串的长度的时间复杂度为O(1)，另，buf[]中依然采用了C语言的以\0结尾可以直接使用C语言的部分标准C字符串库函数。</p> 
<p>空间分配原则：当len小于IMB（1024*1024）时增加字符串分配空间大小为原来的2倍，当len大于等于1M时每次分配 额外多分配1M的空间。</p> 
<p>由此可以得出以下特性：</p> 
<ul><li>redis为字符分配空间的次数是小于等于字符串的长度N，而原C语言中的分配原则必为N。降低了分配次数提高了追加速度，代价就是多占用一些内存空间，且这些空间不会自动释放。</li><li>二进制安全的</li><li>高效的计算字符串长度(时间复杂度为O(1))</li><li>高效的追加字符串操作。</li></ul> 
<h3><a id="list__46"></a>list (列表)</h3> 
<p>redis对键表的结构支持使得它在键值存储的世界中独树一帜，一个列表结构可以有序地存储多个字符串，拥有例如：lpush lpop rpush rpop等等操作命令。在3.2版本之前，列表是使用ziplist和linkedlist实现的，在这些老版本中，当列表对象同时满足以下两个条件时，列表对象使用ziplist编码：</p> 
<ul><li>列表对象保存的所有字符串元素的长度都小于64字节</li><li>列表对象保存的元素数量小于512个</li></ul> 
<p>当有任一条件 不满足时将会进行一次转码，使用linkedlist。</p> 
<p>而在3.2版本之后，重新引入了一个quicklist的数据结构，列表的底层都是由quicklist实现的，它结合了ziplist和linkedlist的优点。按照原文的解释这种数据结构是【A doubly linked list of ziplists】意思就是一个由ziplist组成的双向链表。那么这两种数据结构怎么样结合的呢？</p> 
<p><strong>ziplist的结构</strong></p> 
<p>由表头和N个entry节点和压缩列表尾部标识符zlend组成的一个连续的内存块。然后通过一系列的编码规则，提高内存的利用率，主要用于存储整数和比较短的字符串。可以看出在插入和删除元素的时候，都需要对内存进行一次扩展或缩减，还要进行部分数据的移动操作，这样会造成更新效率低下的情况。</p> 
<p>这篇文章对ziplist的结构讲的还是比较详细的：</p> 
<p><a href="https://blog.csdn.net/yellowriver007/article/details/79021049">https://blog.csdn.net/yellowriver007/article/details/79021049</a></p> 
<p><strong>linkedlist的结构</strong></p> 
<p>意思为一个双向链表，和普通的链表定义相同，每个entry包含向前向后的指针，当插入或删除元素的时候，只需要对此元素前后指针操作即可。所以插入和删除效率很高。但查询的效率却是O(n)[n为元素的个数]。</p> 
<p>了解了上面的这两种数据结构，我们再来看看上面说的“ziplist组成的双向链表”是什么意思？实际上，它整体宏观上就是一个链表结构，只不过每个节点都是以压缩列表ziplist的结构保存着数据，而每个ziplist又可以包含多个entry。也可以说一个quicklist节点保存的是一片数据，而不是一个数据。总结：</p> 
<ul><li>整体上quicklist就是一个双向链表结构，和普通的链表操作一样，插入删除效率很高，但查询的效率却是O(n)。不过，这样的链表访问两端的元素的时间复杂度却是O(1)。所以，对list的操作多数都是poll和push。</li><li>每个quicklist节点就是一个ziplist，具备压缩列表的特性。</li></ul> 
<h3><a id="set__74"></a>set (集合)</h3> 
<p>redis的集合和列表都可以存储多个字符串，它们之间的不同在于，列表可以存储多个相同的字符串，而集合则通过使用散列表（hashtable）来保证自已存储的每个字符串都是各不相同的(这些散列表只有键，但没有与键相关联的值)，redis中的集合是无序的。还可能存在另一种集合，那就是intset，它是用于存储整数的有序集合，里面存放同一类型的整数。共有三种整数：int16_t、int32_t、int64_t。查找的时间复杂度为O(logN)，但是插入的时候，有可能会涉及到升级（比如：原来是int16_t的集合，当插入int32_t的整数的时候就会为每个元素升级为int32_t）这时候会对内存重新分配，所以此时的时间复杂度就是O(N)级别的了。注意：intset只支持升级不支持降级操作。</p> 
<p>intset在redis.conf中也有一个配置参数set-max-intset-entries默认值为512。表示如果entry的个数小于此值，则可以编码成REDIS_ENCODING_INTSET类型存储，节约内存。否则采用dict的形式存储。</p> 
<h3><a id="hash__80"></a>hash (哈希)</h3> 
<p>hash底层的数据结构实现有两种：</p> 
<ul><li>一种是ziplist，上面已经提到过。当存储的数据超过配置的阀值时就是转用hashtable的结构。这种转换比较消耗性能，所以应该尽量避免这种转换操作。同时满足以下两个条件时才会使用这种结构： 
  <ul><li>当键的个数小于hash-max-ziplist-entries（默认512）</li><li>当所有值都小于hash-max-ziplist-value（默认64）</li></ul> </li><li>另一种就是hashtable。这种结构的时间复杂度为O(1)，但是会消耗比较多的内存空间。</li></ul> 
<h3><a id="zset__89"></a>zset (有序集合)</h3> 
<p>有序集合和散列一样，都用于存储键值对：有序集合的键被称为成员（member),每个成员都是各不相同的。有序集合的值则被称为分值（score），分值必须为浮点数。有序集合是redis里面唯一一个既可以根据成员访问元素(这一点和散列一样),又可以根据分值以及分值的排列顺序访问元素的结构。它的存储方式也有两种：</p> 
<ul><li>是ziplist结构。</li></ul> 
<p>与上面的hash中的ziplist类似，member和score顺序存放并按score的顺序排列</p> 
<ul><li>另一种是skiplist与dict的结合。</li></ul> 
<p>skiplist是一种跳跃表结构，用于有序集合中快速查找，大多数情况下它的效率与平衡树差不多，但比平衡树实现简单。redis的作者对普通的跳跃表进行了修改，包括添加span\tail\backward指针、score的值可重复这些设计，从而实现排序功能和反向遍历的功能。</p> 
<p>一般跳跃表的实现，主要包含以下几个部分：</p> 
<ul><li><code>表头（head）</code>：指向头节点</li><li><code>表尾（tail）</code>：指向尾节点</li><li><code>节点（node）</code>：实际保存的元素节点，每个节点可以有多层，层数是在创建此节点的时候随机生成的一个数值，而且每一层都是一个指向后面某个节点的指针。</li><li><code>层（level）</code>：目前表内节点的最大层数</li><li><code>长度（length）</code>：节点的数量。</li></ul> 
<p>跳跃表的遍历总是从高层开始，然后随着元素值范围的缩小，慢慢降低到低层。</p> 
<p><img src="https://images2.imgbox.com/f6/bd/fQfewtIK_o.png" alt="https://img-blog.csdnimg.cn/2018111315442185.png"></p> 
<p>跳跃表的实现原理可以参考：<a href="https://blog.csdn.net/Acceptedxukai/article/details/17333673">https://blog.csdn.net/Acceptedxukai/article/details/17333673</a></p> 
<p>前面也说了，有序列表是使用skiplist和dict结合实现的，skiplist用来保障有序性和访问查找性能，dict就用来存储元素信息，并且dict的访问时间复杂度为O(1)。</p> 
<h2><a id="3_Redis_117"></a>3 Redis的持久化</h2> 
<h3><a id="Redis__119"></a>Redis 的持久化机制</h3> 
<p><strong>RDB持久化</strong></p> 
<p>RDB持久化即通过创建快照（压缩的二进制文件）的方式进行持久化，保存某个时间点的全量数据。RDB持久化是Redis默认的持久化方式。RDB持久化的触发包括手动触发与自动触发两种方式。</p> 
<p><strong>AOF持久化</strong></p> 
<p>AOF（Append-Only-File）持久化即记录所有变更数据库状态的指令，以append的形式追加保存到AOF文件中。在服务器下次启动时，就可以通过载入和执行AOF文件中保存的命令，来还原服务器关闭前的数据库状态。</p> 
<p><strong>RDB、AOF混合持久化</strong></p> 
<p>Redis从4.0版开始支持RDB与AOF的混合持久化方案。首先由RDB定期完成内存快照的备份，然后再由AOF完成两次RDB之间的数据备份，由这两部分共同构成持久化文件。该方案的优点是充分利用了RDB加载快、备份文件小及AOF尽可能不丢数据的特性。缺点是兼容性差，一旦开启了混合持久化，在4.0之前的版本都不识别该持久化文件，同时由于前部分是RDB格式，阅读性较低。</p> 
<h3><a id="Redis__133"></a>Redis 持久化方案的建议</h3> 
<p>如果Redis只是用来做缓存服务器，比如数据库查询数据后缓存，那可以不用考虑持久化，因为缓存服务失效还能再从数据库获取恢复。</p> 
<p>如果你要想提供很高的数据保障性，那么建议你同时使用两种持久化方式。如果你可以接受灾难带来的几分钟的数据丢失，那么可以仅使用RDB。</p> 
<p>通常的设计思路是利用主从复制机制来弥补持久化时性能上的影响。即Master上RDB、AOF都不做，保证Master的读写性能，而Slave上则同时开启RDB和AOF（或4.0以上版本的混合持久化方式）来进行持久化，保证数据的安全性。</p> 
<h3><a id="Redis__141"></a>Redis 持久化方案的优缺点</h3> 
<p><strong>RDB持久化</strong></p> 
<p>优点：RDB文件紧凑，体积小，网络传输快，适合全量复制；恢复速度比AOF快很多。当然，与AOF相比，RDB最重要的优点之一是对性能的影响相对较小。</p> 
<p>缺点：RDB文件的致命缺点在于其数据快照的持久化方式决定了必然做不到实时持久化，而在数据越来越重要的今天，数据的大量丢失很多时候是无法接受的，因此AOF持久化成为主流。此外，RDB文件需要满足特定格式，兼容性差（如老版本的Redis不兼容新版本的RDB文件）。</p> 
<p><strong>AOF持久化</strong></p> 
<p>与RDB持久化相对应，AOF的优点在于支持秒级持久化、兼容性好，缺点是文件大、恢复速度慢、对性能影响大。</p> 
<h2><a id="4__153"></a>4 缓存穿透、缓存击穿、缓存雪崩解决方案</h2> 
<h3><a id="_155"></a>缓存穿透</h3> 
<p>指查询一个一定不存在的数据，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到 DB 去查询，可能导致 DB 挂掉。</p> 
<p>解决方案：</p> 
<p>i. 查询返回的数据为空，仍把这个空结果进行缓存，但过期时间会比较短</p> 
<p>ii. 布隆过滤器：将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对 DB 的查询。</p> 
<h3><a id="_165"></a>缓存击穿</h3> 
<p>对于设置了过期时间的 key，缓存在某个时间点过期的时候，恰好这时间点对这个 Key 有大量的并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把 DB 压垮。</p> 
<p>解决方案：</p> 
<p>i. 使用互斥锁：当缓存失效时，不立即去 load db，先使用如 Redis 的 setnx 去设置一个互斥锁，当操作成功返回时再进行 load db 的操作并回设缓存，否则重试 get 缓存的方法。</p> 
<p>ii 永远不过期：物理不过期，但逻辑过期（后台异步线程去刷新）。</p> 
<h3><a id="_175"></a>缓存雪崩</h3> 
<p>设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到 DB， DB 瞬时压力过重雪崩。与缓存击穿的区别：雪崩是很多 key，击穿是某一个key 缓存。</p> 
<p>解决方案：</p> 
<p>将缓存失效时间分散开，比如可以在原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p> 
<h2><a id="5_Redis__184"></a>5 Redis 的集群模式</h2> 
<h3><a id="_186"></a>主从复制</h3> 
<p>当<strong>从数据库启动时，会向主数据库发送sync命令，主数据库接收到sync后开始在后台保存快照rdb，在</strong>保存快照期间收到的命令缓存起来，当快照完成时，主数据库会将快照和缓存的命令一块发送给从**。复制初始化结束。 之后，主每收到1个命令就同步发送给从。 当出现断开重连后，2.8之后的版本会将断线期间的命令传给重数据库。增量复制</p> 
<p>主从复制是乐观复制，当客户端发送写执行给主，主执行完立即将结果返回客户端，并异步的把命令发送给从，从而不影响性能。也可以设置至少同步给多少个从主才可写。 无硬盘复制:如果硬盘效率低将会影响复制性能，2.8之后可以设置无硬盘复制，repl-diskless-sync yes</p> 
<h3><a id="_192"></a>哨兵模式</h3> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Hzcc1bJo-1613794914158)(https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3e8c3ce5-a43d-45f0-a384-90ecc42dbaff/Untitled.png)]</p> 
<p>哨兵的作用：</p> 
<p>1、监控redis主、从数据库是否正常运行</p> 
<p>2、主出现故障自动将从数据库转换为主数据库。</p> 
<p><strong>哨兵的核心知识</strong></p> 
<p>1、哨兵至少需要 3 个实例，来保证自己的健壮性。</p> 
<p>2、哨兵 + redis 主从的部署架构，是<strong>不保证数据零丢失</strong>的，只能保证 redis 集群的高可用性。</p> 
<p>3、对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</p> 
<p>4、配置哨兵监控一个系统时，<strong>只需要配置其监控主数据库即可</strong>，哨兵会自动发现所有复制该主数据库的从数据库。</p> 
<h2><a id="6_Redis_212"></a>6 Redis分布式锁</h2> 
<h3><a id="Redis_214"></a>使用过Redis分布式锁么，它是什么回事？</h3> 
<p>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。</p> 
<p>如果在setnx之后执行expire之前进程意外crash或者要重启维护了，这个锁就永远得不到释放了，使用set指令把setnx和expire合成一条指令来用</p> 
<h3><a id="_220"></a>红锁</h3> 
<p>用Redis中的多个master实例，来获取锁，只有大多数实例获取到了锁，才算是获取成功。具体的红锁算法分为以下五步：</p> 
<ol><li>获取当前的时间（单位是毫秒）。</li><li>使用相同的key和随机值在N个节点上请求锁。这里获取锁的尝试时间要远远小于锁的超时时间，防止某个masterDown了，我们还在不断的获取锁，而被阻塞过长的时间。</li><li>只有在大多数节点上获取到了锁，而且总的获取时间小于锁的超时时间的情况下，认为锁获取成功了。</li><li>如果锁获取成功了，锁的超时时间就是最初的锁超时时间进去获取锁的总耗时时间。</li><li>如果锁获取失败了，不管是因为获取成功的节点的数目没有过半，还是因为获取锁的耗时超过了锁的释放时间，都会将已经设置了key的master上的key删除。</li></ol> 
<h2><a id="7__231"></a>7 一些问题</h2> 
<h3><a id="_232"></a>内存淘汰机制</h3> 
<p>redis 内存淘汰机制有以下几个：</p> 
<ul><li>noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。</li><li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。</li><li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。</li><li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）。</li><li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。</li><li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。</li></ul> 
<h3><a id="Redis__Mysql__242"></a>Redis 和 Mysql 的数据不一致怎么办</h3> 
<p>采用延时双删策略</p> 
<ol><li>第二个删redis。如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。</li><li>第一个删redis。如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。</li></ol> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">use</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> data<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    redis<span class="token punctuation">.</span><span class="token function">delKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    db<span class="token punctuation">.</span><span class="token function">updateData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">800</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    redis<span class="token punctuation">.</span><span class="token function">delKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>（1）先淘汰缓存</p> 
<p>（2）再写数据库（这两步和原来一样）</p> 
<p>（3）休眠800ms，再次淘汰缓存</p> 
<p>这么做，可以将800ms内所造成的缓存脏数据，再次删除。</p> 
<p><a href="https://kuaibao.qq.com/s/20200529A0F7AQ00?refer=spider_push" rel="nofollow"></a></p> 
<h3><a id="Redis_268"></a>Redis常见性能问题和解决方案：</h3> 
<p>i. Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件；(Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照;AOF文件过大会影响Master重启的恢复速度)</p> 
<p>ii. 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次</p> 
<p>iii. 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内</p> 
<p>iv. 尽量避免在压力很大的主库上增加从库</p> 
<p>v. 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3…；这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。</p> 
<h3><a id="mySQL2000wredis20wredis_280"></a>mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据</h3> 
<p><code>volatile-lru</code>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p> 
<p><code>volatile-ttl</code>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</p> 
<p><code>volatile-random</code>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</p> 
<p><code>allkeys-lru</code>：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</p> 
<p><code>allkeys-random</code>：从数据集（server.db[i].dict）中任意选择数据淘汰</p> 
<p><code>no-enviction（驱逐）</code>：禁止驱逐数据</p> 
<p>注意这里的6种机制，volatile和allkeys规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据，后面的lru、ttl以及random是三种不同的淘汰策略，再加上一种no-enviction永不回收的策略。</p> 
<p>使用策略规则：</p> 
<p>1、如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru</p> 
<p>2、如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random</p> 
<h3><a id="Redis1key10wkey_301"></a>Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？</h3> 
<p>使用keys指令可以扫出指定模式的key列表。对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p> 
<h3><a id="Redis_304"></a>项目中有没有用Redis事务</h3> 
<p>采用的是Redis Cluster集群架构，不同的key是有可能分配在不同的Redis节点上的，在这种情况下Redis的事务机制是不生效的。其次，Redis事务不支持回滚操作，所以基本不用！</p> 
<h3><a id="_308"></a>布隆过滤器</h3> 
<p><a href="https://zhuanlan.zhihu.com/p/94433082" rel="nofollow">5 分钟搞懂布隆过滤器，亿级数据过滤算法你值得拥有！</a></p> 
<h3><a id="redis__311"></a>redis 跳表原理</h3> 
<p><a href="https://cloud.tencent.com/developer/article/1539038" rel="nofollow">一文彻底搞懂跳表的时间复杂度、实现原理以及应用场景</a></p> 
<h3><a id="hash_314"></a>一致性hash算法</h3> 
<p><a href="https://www.jianshu.com/p/528ce5cd7e8f" rel="nofollow">一致性Hash原理与实现</a></p> 
<h2><a id="8__317"></a>8 参考</h2> 
<p>可能没记全，如果有拉下的，请提醒后续补上</p> 
<p><a href="https://blog.csdn.net/bird73/article/details/79792548">https://blog.csdn.net/bird73/article/details/79792548</a></p> 
<p><a href="https://www.cnblogs.com/spec-dog/p/12466276.html" rel="nofollow">https://www.cnblogs.com/spec-dog/p/12466276.html</a></p> 
<p><a href="https://blog.csdn.net/xpsallwell/article/details/84030285">https://blog.csdn.net/xpsallwell/article/details/84030285</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e449277236cdc396970867888150fba4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">互联网公司mysql采用读已提交的隔离级别原因(详细)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b25333d6d5bad72766b9f5187651e4a7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">WPF Dispatcher使用invoke，程序进入死锁</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>