<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; 第五周 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43; 第五周" />
<meta property="og:description" content="类和动态内存分配 动态内存和类 C&#43;&#43; 使用 new 和 delete 运算符来动态内存分配。遗憾的是，在类中使用这些运算符将导致许多新的编程问题。这时，析构函数是必不可少的，有时候还必须重载运算符。
新的存储类型静态类成员.
下面是一个示例：
// strngbad.h #include&lt;iostream&gt; #ifnedf STRNGBAD_H_ #define STRNGBAD_H_ class StringBad { private: char * str; int len; static int num; public: StringBad(const char * s); StringBad(); ~StringBad(); // friend function friend std::ostream &amp; operator&lt;&lt;(str:ostream &amp; os, const StringBad &amp; st); }; #endif 静态类成员有一个特点：无论创建了多少对象，程序都只创建一个静态类变量副本。也就是说，类的所有对象共享同一个静态成员，这对于所有类对象都具有相同值的类私有数据是非常方便。
// strngbad.cpp #include&lt;cstring&gt; #include &#34;strngbad.h&#34; using std::cout; int String::num = 0; // class methods StringBad::StringBad(const char * s) { len = std::strlen(s); str = new char[len &#43; 1]; std::strcpy(str,s); num&#43;&#43;; cout &lt;&lt; num &lt;&lt;&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/e5fe6f764797609010014a13b3963c25/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-28T14:48:23+08:00" />
<meta property="article:modified_time" content="2022-01-28T14:48:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; 第五周</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>类和动态内存分配</h2> 
<h4>动态内存和类</h4> 
<p>       C++ 使用 new 和 delete  运算符来动态内存分配。遗憾的是，在类中使用这些运算符将导致许多新的编程问题。这时，<strong>析构函数是必不可少的，有时候还必须重载运算符。</strong></p> 
<p>       新的存储类型静态类成员.</p> 
<p>       下面是一个示例：</p> 
<pre><code>// strngbad.h
#include&lt;iostream&gt;
#ifnedf STRNGBAD_H_
#define STRNGBAD_H_
class StringBad
{
	private:
		char * str;
		int len;
		static int num;
	public:
		StringBad(const char * s);
		StringBad();
		~StringBad();
	// friend function
	    friend std::ostream &amp; operator&lt;&lt;(str:ostream &amp; os,
		                    const StringBad &amp; st);
};
#endif</code></pre> 
<p>       静态类成员有一个特点：<strong>无论创建了多少对象，程序都只创建一个静态类变量副本</strong>。也就是说，类的所有对象共享同一个静态成员，这对于所有类对象都具有相同值的类私有数据是非常方便。</p> 
<pre><code>// strngbad.cpp
#include&lt;cstring&gt;
#include "strngbad.h"
using std::cout;

int String::num = 0;

// class methods
StringBad::StringBad(const char * s)
{
	len = std::strlen(s);
	str = new char[len + 1];
	std::strcpy(str,s);
	num++;
	cout &lt;&lt; num &lt;&lt;": \"" &lt;&lt;str
	     &lt;&lt; "\" object created\n";
}

StringBad::StringBad()
{
	len = 4;
	str = new char[4];
	std::strcpy(str,"C++");
	num++;
	cout &lt;&lt; num &lt;&lt;": \"" &lt;&lt;str
	     &lt;&lt; "\" default object created\n";
}

StringBad::~StringBad()
{
	cout &lt;&lt; "\"" &lt;&lt; str &lt;&lt; "\" objcet deleted, ";
	--num;
	cout &lt;&lt; num &lt;&lt; " left\n";
	delete [] str;
}

std:ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const StringBad &amp; st)
{
	os &lt;&lt; st.str;
	return os;
}</code></pre> 
<p>       注意：<strong>不能在类声明中初始化静态成员变量，这是因为声明描述了如何分配内存，但并不分配内存 . 但如果静态成员是 const 或枚举型，则可以在类声明中初始化.</strong></p> 
<p><strong>       </strong>另外，在<strong>构造函数</strong>中使用<strong>new</strong>时，必须在相应的<strong>析构函数</strong>中使用<strong>delete</strong>。</p> 
<p></p> 
<p></p> 
<h3>特殊成员函数</h3> 
<h4><strong>（1）默认构造函数</strong></h4> 
<p><strong>       </strong>如果没有提供任何构造函数，C++ 将创建默认构造函数。例如，假如定义了一个 Klunk 类，但没有提供任何构造函数，编译器将提供下述默认构造函数：</p> 
<pre><code>Klunk::Klunk()
{
}
// 一个不接受参数，不执行操作的构造函数

Klunk lunk; </code></pre> 
<p>       <strong>默认构造函数使 lunk 类似于一个常规的自动变量，它的值在初始化时未知的。</strong></p> 
<p><strong>       如果定义了构造函数，C++将不会定义默认构造函数。如果希望在创建对象时不显式地对它进行初始化，则必须显式定义默认构造函数。它没有任何参数，但可以用来设定特定的值：</strong></p> 
<pre><code>Klunk::Klunk()
{
	Klunk_ct = 0;
	...
}
</code></pre> 
<p><strong>       带参数的构造函数也可以是默认构造函数，只要所有参数都有默认值。</strong>例如，Klunk 类可以包含下述内联构造函数：</p> 
<pre><code>Klunk(int n = 0) 
{
    Klunk_ct = n;
}</code></pre> 
<p>       <strong>但只能有一个默认构造函数。</strong></p> 
<p></p> 
<p><strong>（2）默认析构函数</strong></p> 
<h4><strong>（3）复制构造函数</strong></h4> 
<p><strong>       复制构造函数用于将一个对象复制到新创建的对象中。它用于初始化过程中（包括按值传递参数），</strong>而不是常规的赋值过程中<strong>。其原型如下：</strong></p> 
<pre><code>Class_name(const Class_name &amp;);</code></pre> 
<p>       对于复制构造函数需要知道两点： 何时调用  ， 有何功能 .</p> 
<p><strong>       何时调用：</strong></p> 
<p><strong>       新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用。</strong>很多情况下都可能发生，最常见的情况是<strong>将新对象显式地初始化为现有的对象</strong>。以下四种声明都将调用复制构造函数：</p> 
<pre><code>StringBad ditto(motto);
StringBad metoo = motto;
StringBad also = StringBad(motto);
StringBad * pStringBad = new StringBad(motto);</code></pre> 
<p></p> 
<p>     <strong>  有何功能：</strong></p> 
<p>       默认的复制构造函数逐个复制<strong>非静态成员</strong>（成员复制也被称为浅复制），<strong>复制的是成员的值。</strong></p> 
<p>下述语句：</p> 
<pre><code>StringBad sailor = sports;

// 与下面的代码等效
StringBad sailor;
sailor.str = sports.str;
sailor.len = sports.len;
// 由于私有成员无法访问，因此这三行代码不能通过编译</code></pre> 
<p>       如果<strong>成员本身就是类对象，则将使用这个类的复制构造函数来复制成员对象。静态成员不受影响，因为他们属于整个类，而不是各个对象。</strong></p> 
<p><strong>       注意：如果类中包含了使用 new 初始化的指针成员，应当定义一个复制构造函数，以复制指向的数据，而不是指针，这被称为深度复制。复制的另一种形式（成员复制或浅复制）只是复制指针值。浅复制仅浅浅地复制指针信息，而不会深入挖掘以复制指针引用的结构 </strong></p> 
<p></p> 
<h4><strong>（4）赋值运算符</strong></h4> 
<p><strong>       赋值运算符只能由类成员函数来重载它.</strong></p> 
<p>       对于由于默认赋值运算符不合适而导致的问题，解决方法是提供赋值运算符（进行深度复制）定义。其实现与复制构造函数相似，但也有一些差别。</p> 
<p>       1.由于目标对象可能引用了以前分配的数据，所以函数应使用delete[ ] 来释放这些数据.</p> 
<p>       2.函数应当避免将对象赋值给自身；否则，给对象重新赋值前，释放内存操作可能删除对象的内容.</p> 
<p>       3.函数返回一个指向调用对象的引用.</p> 
<p></p> 
<pre><code>StringBad &amp; StringBad::operator = (const StringBad &amp; st)
{
	if (this == &amp;st)
	{
		return *this;
	}
	delete [] str;
	len = st.len;
	str = new char [len + 1];
	std::strcpy(str, st.str);
	return *this;
}</code></pre> 
<p></p> 
<p></p> 
<h3>在构造函数中使用 new 时应注意的事项</h3> 
<p>       1. 如果在构造函数中使用new来初始化指针成员，则应在析构函数中使用delete.</p> 
<p>       2. new 和 delete 必须相互兼容，<strong>new 对应于delete，new [ ] 对应于 delete [ ]</strong> .</p> 
<p>       3. 如果有多个构造函数，则必须以相同的方式使用new，要么都带 [ ] , 要么都不带。因为<strong>只有一个析构函数，所有的析构函数都必须与他兼容</strong>。然而，<strong>可以在一个构造函数中使用new 初始化指针，而在另一个构造函数中将指针初始化为空，这是因为delete 可以用于空指针.</strong></p> 
<p></p> 
<p></p> 
<h2>有关返回对象的说明</h2> 
<h3>返回指向 const 对象的引用</h3> 
<p>       <strong>如果函数返回(通过调用对象的方法或将对象作为参数)传递给它的对象，可以通过返回引用来提高效率</strong>。例如，要编写函数 Max（），它返回两个Vector对象中较大的一个。该函数将以下面的方式被使用：</p> 
<pre><code>Vector force1(50,60);
Vector force2(10,70);
Vector max;
max = Max(force1,force2);
</code></pre> 
<p>以下两种实现都是可行的：</p> 
<pre><code>// version1
Vector Max(const Vector &amp; v1, const Vector &amp; v2)
{
	if(v1.magval() &gt; v2.magval)
	{
		return v1;
	}
	else{
		return v2;
	}
}

// version2
const Vector &amp; Max(const Vector &amp; v1, const Vector &amp; v2)
{
	if(v1.magval() &gt; v2.magval)
	{
		return v1;
	}
	else{
		return v2;
	}
}

</code></pre> 
<p>       首先，<strong>返回对象将调用复制构造函数，而返回引用不会</strong>。所以第二个实现效率更高。其次，<strong>引用指向的对象应该在调用函数指向时存在。</strong></p> 
<p></p> 
<h3>返回指向非 const 对象的引用</h3> 
<p>       两种常见的返回非 const 对象情形是，重载赋值运算符以及重载与 cout 一起使用的 &lt;&lt; 运算符。</p> 
<p></p> 
<h3>返回对象</h3> 
<p>       如果被返回的对象是被调用函数中的局部对象，则我们就不能够返回指针引用。当控制权毁掉调用函数时，引用已经不存在了。所以在这种情况下，我们应该放回对象而不是引用。</p> 
<p></p> 
<h3>返回 const 对象</h3> 
<p>假如我们直接返回一个对象，那么我们可能会在程序中遇到一些容易令人误解的语句</p> 
<pre><code>net = v1 + v2;
v1 + v2 = net;
cout&lt;&lt;(v1 + v2 = net).getLength();</code></pre> 
<p><br> 当我们返回了const类型的对象，我们能够阻止令人生畏的后两句的出现.<br>  </p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7b09fc222ee22bae3ee950cd6bf064fe/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MFC界面背景颜色（改暗黑系列）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d35bedcfb19f195df13293bbdc1baa76/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">洛谷上的 AtCoder 水(难)题(C&#43;&#43;)【第一到五题】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>