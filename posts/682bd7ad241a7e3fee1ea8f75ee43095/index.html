<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>51单片机矩阵键盘扫描及使用方法 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="51单片机矩阵键盘扫描及使用方法" />
<meta property="og:description" content="一、矩阵键盘简介 矩阵键盘，也称矩阵按键，是为了节约单片机IO口占用所引入的一种外设。
（图片截取至普中A2开发板原理图）
（图片截取至普中A2开发板实物图）
我们知道，一个独立按键需要1个IO口。但是如果我们需要大量的按键，则需要大量的IO口，但是单片机现有的IO口并不能很好的满足，所以引入矩阵键盘。
二、矩阵键盘扫描原理 从独立按键到矩阵按键 1.独立按键回顾
上图的矩阵键盘共16个按键（4行×4列），先回到原来的一个独立按键分析。
首先分析独立按键的原理图连接方式（如上图），以按键K1为例，按键K1一端连接到单片机的P3.1口，另一端接地（GND）。当按键K1被按下时，GND直接就连到P3.1。所以当K1被按下时，P3.1口为低电平。我们只需要判断P3.1口是否为低电平，即可判断K1是否被按下。
2.矩阵按键扫描思路
先分析矩阵按键的IO连线，有以下特征：
P17~P14这四个IO口连接了每一行矩阵键盘P13~P10这四个IO口连接了每一列矩阵键盘 矩阵键盘扫描共有两种扫描方式：
逐行扫描逐列扫描 先分析逐行扫描，根据键盘被按下时,IO口为低电平这个特性。我们可以这样检测第一行：
给除第一行之外的其他行给高电平，防止其影响我们接下来的低电平检测给第一行送低电平0依次检测每一列的IO口电平（P13~P10），当出现低电平时，说明第一行的这一列的这个按键就被按下。 结合下图很好理解：
要检测第一行，给其他行赋值高电平。假设S2被按下了，那么P17的低电平会顺着绿色路线通到S2的另一端IO口（P12），只要检测出P12为低电平，那么就可以得出结论：K2被按下
按照这个思路，继续依次检测其他行即可。
总结：
按行扫描 给第1到第4行要扫描的行置0，其余行置1。然后对每一列进行读取，读出低电平的列则可以判断该行该列的按键被按下。
IO口电平（P17~P14：每行对应IO的口）检测的行若第K列IO口测出低电平0 1 1 1一第一行第K列被按下 1 0 1 1
二第二行第K列被按下1 1 0 1三第三行第K列被按下1 1 1 0四第四行第K列被按下 按列扫描的结果类似：
IO口电平（P13~P10：每行对应IO的口）检测的列若第K行IO口测出低电平0 1 1 1一第K行第一列被按下 1 0 1 1
二第K行第二列被按下1 1 0 1三第K行第三列被按下1 1 1 0四第K行第四列被按下 三、编程验证 1、先给出一些引脚定义
#include &lt;REGX52.H&gt; #define uchar unsigned char #define uint unsigned int #define led P0 //IO口位选 sbit wei1=P2^2; sbit wei2=P2^3; sbit wei3=P2^4; //定义行引脚 sbit hang1=P1^7; sbit hang2=P1^6; sbit hang3=P1^5; sbit hang4=P1^4; //定义列引脚 sbit lie1=P1^3; sbit lie2=P1^2; sbit lie3=P1^1; sbit lie4=P1^0; 2、按行扫描代码：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/682bd7ad241a7e3fee1ea8f75ee43095/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-01T22:25:15+08:00" />
<meta property="article:modified_time" content="2022-04-01T22:25:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">51单片机矩阵键盘扫描及使用方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、矩阵键盘简介</h2> 
<p><span style="color:#fe2c24;">        <strong>矩阵键盘</strong></span>，也称矩阵按键，是为了节约单片机IO口占用所引入的一种外设。</p> 
<p style="text-align:center;"><img alt="" height="397" src="https://images2.imgbox.com/4f/5b/Rjc5A2UC_o.jpg" width="391"></p> 
<p style="text-align:center;">（图片截取至普中A2开发板原理图）</p> 
<p></p> 
<p class="img-center"><img alt="" height="321" src="https://images2.imgbox.com/50/65/Lz3LNxu6_o.jpg" width="440"></p> 
<p style="text-align:center;">（图片截取至普中A2开发板实物图）</p> 
<p></p> 
<p>        我们知道，一个独立按键需要1个IO口。但是如果我们需要大量的按键，则需要大量的IO口，但是单片机现有的IO口并不能很好的满足，所以引入矩阵键盘。</p> 
<h2>二、矩阵键盘扫描原理</h2> 
<p><span style="background-color:#ffd900;">从独立按键到矩阵按键   </span> </p> 
<p><strong>1.独立按键回顾</strong></p> 
<p>    上图的矩阵键盘共16个按键（4行×4列），先回到原来的一个独立按键分析。</p> 
<p style="text-align:center;"><img alt="" height="308" src="https://images2.imgbox.com/da/87/IqfAoIdi_o.jpg" width="527"></p> 
<p style="text-align:center;"></p> 
<p> 首先分析独立按键的原理图连接方式（如上图），以按键K1为例，按键K1一端连接到单片机的P3.1口，另一端接地（GND）。当按键K1被按下时，GND直接就连到P3.1。所以当K1被按下时，P3.1口为低电平。<strong>我们只需要判断P3.1口是否为低电平，即可判断K1是否被按下。</strong></p> 
<p></p> 
<p><strong>2.矩阵按键扫描思路</strong></p> 
<p class="img-center"><img alt="" height="434" src="https://images2.imgbox.com/e5/56/nvDrVmfr_o.jpg" width="426"></p> 
<p>先分析矩阵按键的IO连线，有以下特征：</p> 
<ol><li>P17~P14这四个IO口连接了每一<strong><span style="color:#956fe7;">行</span></strong>矩阵键盘</li><li>P13~P10这四个IO口连接了每一<span style="color:#956fe7;"><strong>列</strong></span>矩阵键盘</li></ol> 
<p>矩阵键盘扫描共有两种扫描方式：</p> 
<ul><li>逐行扫描</li><li>逐列扫描</li></ul> 
<p>先分析<span style="background-color:#ff9900;">逐行扫描</span>，<strong>根据键盘被按下时,IO口为低电平这个特性。</strong>我们可以这样检测第一行：</p> 
<ol><li>给除第一行之外的其他行给高电平，防止其影响我们接下来的低电平检测</li><li>给第一行送低电平0</li><li>依次检测每一列的IO口电平（P13~P10），当出现低电平时，说明第一行的这一列的这个按键就被按下。</li></ol> 
<p>结合下图很好理解：</p> 
<p class="img-center"><img alt="" height="366" src="https://images2.imgbox.com/c3/9f/k6xfCh4j_o.jpg" width="360"></p> 
<p style="text-align:center;">           要检测第一行，给其他行赋值高电平。假设S2被按下了，那么P17的低电平会顺着绿色路线通到S2的另一端IO口（P12），<span style="background-color:#a2e043;">只要检测出P12为低电平</span>，那么就可以得出结论：K2被按下</p> 
<p><strong>按照这个思路，继续依次检测其他行即可。</strong></p> 
<p></p> 
<p><strong>总结：</strong></p> 
<p>       <strong>按行扫描</strong> 给第1到第4行要扫描的行置0，其余行置1。然后对每一列进行读取，读出低电平的列则可以判断该行该列的按键被按下。</p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="text-align:center;width:279px;"><strong>IO口电平</strong>（P17~P14：每行对应IO的口）</td><td style="text-align:center;width:219px;"><strong>检测的行</strong></td><td style="text-align:center;width:219px;">若第K列IO口测出低电平</td></tr><tr><td style="text-align:center;width:279px;">0 1 1 1</td><td style="text-align:center;width:219px;">一</td><td style="text-align:center;width:219px;">第一行第K列被按下</td></tr><tr><td style="width:279px;"> <p style="text-align:center;">1 0 1 1</p> </td><td style="text-align:center;width:219px;">二</td><td style="text-align:center;width:219px;">第二行第K列被按下</td></tr><tr><td style="text-align:center;width:279px;">1 1 0 1</td><td style="text-align:center;width:219px;">三</td><td style="text-align:center;width:219px;">第三行第K列被按下</td></tr><tr><td style="text-align:center;width:279px;">1 1 1 0</td><td style="text-align:center;width:219px;">四</td><td style="text-align:center;width:219px;">第四行第K列被按下</td></tr></tbody></table> 
<p><strong>按列扫描</strong>的结果类似：</p> 
<table align="center" border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="text-align:center;width:279px;"><strong>IO口电平</strong>（P13~P10：每行对应IO的口）</td><td style="text-align:center;width:219px;"><strong>检测的列</strong></td><td style="text-align:center;width:219px;">若第K行IO口测出低电平</td></tr><tr><td style="text-align:center;width:279px;">0 1 1 1</td><td style="text-align:center;width:219px;">一</td><td style="text-align:center;width:219px;">第K行第一列被按下</td></tr><tr><td style="width:279px;"> <p style="text-align:center;">1 0 1 1</p> </td><td style="text-align:center;width:219px;">二</td><td style="text-align:center;width:219px;">第K行第二列被按下</td></tr><tr><td style="text-align:center;width:279px;">1 1 0 1</td><td style="text-align:center;width:219px;">三</td><td style="text-align:center;width:219px;">第K行第三列被按下</td></tr><tr><td style="text-align:center;width:279px;">1 1 1 0</td><td style="text-align:center;width:219px;">四</td><td style="text-align:center;width:219px;">第K行第四列被按下</td></tr></tbody></table> 
<p></p> 
<h2>三、编程验证</h2> 
<p><span style="color:#fe2c24;">1、先给出一些引脚定义</span></p> 
<pre><code class="language-cpp">#include &lt;REGX52.H&gt;

#define uchar unsigned char 
#define uint unsigned int 
#define led P0

//IO口位选
sbit wei1=P2^2;
sbit wei2=P2^3;
sbit wei3=P2^4;

//定义行引脚
sbit hang1=P1^7;
sbit hang2=P1^6;
sbit hang3=P1^5;
sbit hang4=P1^4;

//定义列引脚
sbit lie1=P1^3;
sbit lie2=P1^2;
sbit lie3=P1^1;
sbit lie4=P1^0;</code></pre> 
<p><span style="color:#fe2c24;">2、按行扫描代码：</span></p> 
<pre><code class="language-cpp">	
    //扫描第一行的各列
    P1|=0xff;//IO口全部初始化为高电平
	hang1=0;//第一行设置为低电平
	if(lie1==0)//检测第一列是否为低电平（按键是否被按下）
	{
		Delay10ms();//延时消抖
		if(lie1==0)
		{
			while(lie1==0);
			key=1;//确认被按下，保存键值
		}
	}
    
//下面依次扫描第二、三和第四列，方法类似

    if(lie2==0)
	{
		Delay10ms();
		if(lie2==0)
		{
			while(lie2==0);
			key=2;
		}
	}
	
	
		if(lie3==0)
	{
		Delay10ms();
		if(lie3==0)
		{
			while(lie3==0);
			key=3;
		}
	}
	
		if(lie4==0)
	{
		Delay10ms();
		if(lie4==0)
		{
			while(lie4==0);
			key=4;
		}
	}</code></pre> 
<p>第二行，第三行、第四行扫描的方法类似</p> 
<blockquote> 
 <p>只需把 if 判断改成对应的行，键值改为对应的键值即可</p> 
</blockquote> 
<p>3.总代码</p> 
<pre><code class="language-cpp">#include &lt;REGX52.H&gt;
#include &lt;math.h&gt;

#define uchar unsigned char 
#define uint unsigned int 
#define led P0

sbit wei1=P2^2;
sbit wei2=P2^3;
sbit wei3=P2^4;

sbit hang1=P1^7;
sbit hang2=P1^6;
sbit hang3=P1^5;
sbit hang4=P1^4;


sbit lie1=P1^3;
sbit lie2=P1^2;
sbit lie3=P1^1;
sbit lie4=P1^0;


void play(int a);
void Delay10ms();
int scan();


uchar code smg[17]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,
0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71,0x00};

int key=0;
int x;

void main()
{
	

	while(1)
	{
		play(scan());
	}
	
}


void play(int a)
{
	x=a;
	wei1=0;
	wei2=0;
	wei3=0;
  
	led=smg[x];
	Delay10ms();


}

int scan()
{
	
	P1|=0xff;
	hang1=0;
	if(lie1==0)
	{
		Delay10ms();
		if(lie1==0)
		{
			while(lie1==0);
			key=1;
		}
	}
	
		if(lie2==0)
	{
		Delay10ms();
		if(lie2==0)
		{
			while(lie2==0);
			key=2;
		}
	}
	
	
		if(lie3==0)
	{
		Delay10ms();
		if(lie3==0)
		{
			while(lie3==0);
			key=3;
		}
	}
	
		if(lie4==0)
	{
		Delay10ms();
		if(lie4==0)
		{
			while(lie4==0);
			key=4;
		}
	}
	
	
	P1|=0xff;
	hang2=0;
		if(lie1==0)
	{
		Delay10ms();
		if(lie1==0)
		{
			while(lie1==0);
			key=5;
		}
	}
	
		if(lie2==0)
	{
		Delay10ms();
		if(lie2==0)
		{
			while(lie2==0);
			key=6;
		}
	}
	
	
		if(lie3==0)
	{
		Delay10ms();
		if(lie3==0)
		{
			while(lie3==0);
			key=7;
		}
	}
	
		if(lie4==0)
	{
		Delay10ms();
		if(lie4==0)
		{
			while(lie4==0);
			key=8;
		}
	}
	
	P1|=0xff;
	hang3=0;
	
		if(lie1==0)
	{
		Delay10ms();
		if(lie1==0)
		{
			while(lie1==0);
			key=9;
		}
	}
	
		if(lie2==0)
	{
		Delay10ms();
		if(lie2==0)
		{
			while(lie2==0);
			key=10;
		}
	}
	
	
		if(lie3==0)
	{
		Delay10ms();
		if(lie3==0)
		{
			while(lie3==0);
			key=11;
		}
	}
	
		if(lie4==0)
	{
		Delay10ms();
		if(lie4==0)
		{
			while(lie4==0);
			key=12;
		}
	}

	
	P1|=0xff;
	hang4=0;
	
		if(lie1==0)
	{
		Delay10ms();
		if(lie1==0)
		{
			while(lie1==0);
			key=13;
		}
	}
	
		if(lie2==0)
	{
		Delay10ms();
		if(lie2==0)
		{
			while(lie2==0);
			key=14;
		}
	}
	
	
		if(lie3==0)
	{
		Delay10ms();
		if(lie3==0)
		{
			while(lie3==0);
			key=15;
		}
	}
	
		if(lie4==0)
	{
		Delay10ms();
		if(lie4==0)
		{
			while(lie4==0);
			key=0;
		}
	}

	
	return key;
}


void Delay10ms()		//@11.0592MHz
{
	unsigned char i, j;

	i = 18;
	j = 235;
	do
	{
		while (--j);
	} while (--i);
}</code></pre> 
<h2>四、课后作业（矩阵键盘计算器）</h2> 
<p><strong>题目：请你利用矩阵按键和数码管来设计一个计算器，能够实现简单的四则整数运算和清零操作</strong></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/625aff1b216a56a8574068e4a89d73c2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Oracle种批量导出CVS文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c23d42b222948036de8a937b45566265/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">strstr函数——一个字符串是否是另一个字符串的子串</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>