<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c语言指针 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c语言指针" />
<meta property="og:description" content="前面学了那么多 基本都会涉及到指针的知识 那今天 我们正式来学习c语言的魅力之一 指针
正如我们所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用 &amp; 运算符访问的地址，它表示了在内存中的一个地址我们来看一段代码：
#include &lt;stdio.h&gt; int main () { int var_runoob = 10; int *p; // 定义指针变量 p = &amp;var_runoob; printf(&#34;var_runoob 变量的地址： %p\n&#34;, p); printf(&#34;var_runoob 变量： %d\n&#34;, *p); return 0; } 运行结果：
大家带着这个问题 输出 p 和输出*p的区别以及为什么？我们来学习指针
目录
一指针
1.1 概述
1.2如何使用指针
1.3 指针的算术运算
1.3.1递增一个指针
1.3.2指针的递减
1.3.3指针的比较
1.4指针数组
1.5指向指针的指针
1.6传递指针给函数
一指针 1.1 概述 ：指针也就是内存地址，指针变量是用来存放内存地址的变量。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明
基本格式：
type *var_name; 在这里，type 是指针的基类型，它必须是一个有效的 C 数据类型，var_name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明
int *ip; /* 一个整型的指针 */ double *dp; /* 一个 double 型的指针 */ float *fp; /* 一个浮点型的指针 */ char *ch; /* 一个字符型的指针 */ 所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/69e5da7fd72939474701ae112ef33fc7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-18T13:34:28+08:00" />
<meta property="article:modified_time" content="2024-02-18T13:34:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c语言指针</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p>前面学了那么多 基本都会涉及到指针的知识 那今天 我们正式来学习c语言的魅力之一 指针</p> 
<p>正如我们所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用 &amp; 运算符访问的地址，它表示了在内存中的一个地址我们来看一段代码：</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
int main ()
{
    int var_runoob = 10;
    int *p;              // 定义指针变量
    p = &amp;var_runoob;
 
   printf("var_runoob 变量的地址： %p\n", p);
   printf("var_runoob 变量： %d\n", *p);
   return 0;
}</code></pre> 
<p>运行结果：<img alt="" height="97" src="https://images2.imgbox.com/2c/0d/0Gnlum7o_o.png" width="568"></p> 
<p>大家带着这个问题 输出 p 和输出*p的区别以及为什么？我们来学习指针</p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E6%8C%87%E9%92%88-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E6%8C%87%E9%92%88" rel="nofollow">一指针</a></p> 
<p id="1.1%20%E6%A6%82%E8%BF%B0-toc" style="margin-left:40px;"><a href="#1.1%20%E6%A6%82%E8%BF%B0" rel="nofollow">1.1 概述</a></p> 
<p id="1.2%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88-toc" style="margin-left:40px;"><a href="#1.2%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88" rel="nofollow">1.2如何使用指针</a></p> 
<p id="1.3%20%E6%8C%87%E9%92%88%E7%9A%84%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97-toc" style="margin-left:40px;"><a href="#1.3%20%E6%8C%87%E9%92%88%E7%9A%84%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97" rel="nofollow">1.3 指针的算术运算</a></p> 
<p id="1.3.1%E9%80%92%E5%A2%9E%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88-toc" style="margin-left:80px;"><a href="#1.3.1%E9%80%92%E5%A2%9E%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88" rel="nofollow">1.3.1递增一个指针</a></p> 
<p id="1.3.2%E6%8C%87%E9%92%88%E7%9A%84%E9%80%92%E5%87%8F-toc" style="margin-left:80px;"><a href="#1.3.2%E6%8C%87%E9%92%88%E7%9A%84%E9%80%92%E5%87%8F" rel="nofollow">1.3.2指针的递减</a></p> 
<p id="1.3.3%E6%8C%87%E9%92%88%E7%9A%84%E6%AF%94%E8%BE%83-toc" style="margin-left:80px;"><a href="#1.3.3%E6%8C%87%E9%92%88%E7%9A%84%E6%AF%94%E8%BE%83" rel="nofollow">1.3.3指针的比较</a></p> 
<p id="1.4%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#1.4%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84" rel="nofollow">1.4指针数组</a></p> 
<p id="1.5%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88-toc" style="margin-left:40px;"><a href="#1.5%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88" rel="nofollow">1.5指向指针的指针</a></p> 
<p id="1.6%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E7%BB%99%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#1.6%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E7%BB%99%E5%87%BD%E6%95%B0" rel="nofollow">1.6传递指针给函数</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E6%8C%87%E9%92%88">一指针</h2> 
<h3 id="1.1%20%E6%A6%82%E8%BF%B0">1.1 概述</h3> 
<p>：指针也就是内存地址，指针变量是用来存放内存地址的变量。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明</p> 
<p>基本格式：</p> 
<pre><code class="language-cs">type *var_name;
</code></pre> 
<p>在这里，<strong>type</strong> 是指针的基类型，它必须是一个有效的 C 数据类型，<strong>var_name</strong> 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明</p> 
<pre><code class="language-cs">int    *ip;    /* 一个整型的指针 */
double *dp;    /* 一个 double 型的指针 */
float  *fp;    /* 一个浮点型的指针 */
char   *ch;    /* 一个字符型的指针 */</code></pre> 
<p>所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。</p> 
<p>不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同</p> 
<h3 id="1.2%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88">1.2如何使用指针</h3> 
<p>概述：使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值</p> 
<p>示例：</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
int main ()
{
   int  var = 20;   /* 实际变量的声明 */
   int  *ip;        /* 指针变量的声明 */
 
   ip = &amp;var;  /* 在指针变量中存储 var 的地址 */
 
   printf("var 变量的地址: %p\n", &amp;var  );
 
   /* 在指针变量中存储的地址 */
   printf("ip 变量存储的地址: %p\n", ip );
 
   /* 使用指针访问值 */
   printf("*ip 变量的值: %d\n", *ip );
 
   return 0;
}</code></pre> 
<p>运行结果：<img alt="" height="116" src="https://images2.imgbox.com/d4/d8/gyKSfOM3_o.png" width="592"></p> 
<p>所以我们根据定义来解决我们上述的问题</p> 
<p>什么是指针 指针是地址</p> 
<p>什么是指针变量  是存放地址的变量 </p> 
<p>我们重看定义 int* ip； 其中 int* 是指针类型 ip是变量的名字</p> 
<p><span style="color:#fe2c24;">我们可以这样理解 ip里面存放的是地址 *ip是将地址里面的内容进行解引用（即将地址转换为值）</span></p> 
<p>所以我们在本节刚刚开始的代码 我们输出 p是地址 输出*p是变量的值</p> 
<p>然后看上面的代码输出是不是就很简单了 什么时候输出的是地址 什么时候输出的是变量的值</p> 
<p>1.3 NULL指针</p> 
<p>在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为<strong>空</strong>指针。</p> 
<p>NULL 指针是一个定义在标准库中的值为零的常量</p> 
<p>代码：为什么要这样说呢 因为当你定义了一个指针 却没指向一个地址 会变成一个野指针</p> 
<p>野指针：野指针就是指向的内存地址是未知的(随机的，不正确的，没有明确限制的)</p> 
<p>那为什么会有野指针呢？</p> 
<p>1 <strong>指针未初始化</strong>：指针变量刚被创建时不会自动成为NULL指针，它的缺省值是<strong>随机</strong>的，<strong>它所指的空间是随机的。</strong></p> 
<p>2 <strong>指针越界访问</strong>：指针指向的范围超出了合理范围，或者调用函数时返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放 </p> 
<p>3 <strong>指针释放后未置空</strong>：有时指针在free或delete后未赋值 NULL，便会使人以为是合法的。其实它们只是把指针所指的内存给释放掉，但并<strong>没有把指针本身忘记</strong>。此时指针指向的就是<strong>无效内存</strong>。释放后的指针应立即将指针置为NULL，防止产生“野指针</p> 
<p>我们一定要避免野指针的存在</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
 
int main ()
{
   int  *ptr = NULL;
 
   printf("ptr 的地址是 %p\n", ptr  );
 
   return 0;
}</code></pre> 
<h3 id="1.3%20%E6%8C%87%E9%92%88%E7%9A%84%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97">1.3 指针的算术运算</h3> 
<p>概述：C 指针是一个用数值表示的地址。因此，您可以对指针执行算术运算。可以对指针进行四种算术运算：++、--、+、-。</p> 
<p>假设 <strong>ptr</strong> 是一个指向地址 1000 的整型指针，是一个 32 位的整数，让我们对该指针执行下列的算术运算</p> 
<pre><code class="language-cs">ptr++
</code></pre> 
<p>在执行完上述的运算之后，<strong>ptr</strong> 将指向位置 1004，因为 ptr 每增加一次，它都将指向下一个整数位置，即当前位置往后移 4 字节。这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置。如果 <strong>ptr</strong> 指向一个地址为 1000 的字符，上面的运算会导致指针指向位置 1001，因为下一个字符位置是在 1001。</p> 
<p>我们概括一下：</p> 
<ul><li>指针的每一次递增，它其实会指向下一个元素的存储单元。</li><li>指针的每一次递减，它都会指向前一个元素的存储单元。</li><li>指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节</li></ul> 
<p>这里 我们联想到之前的数组 </p> 
<h4 id="1.3.1%E9%80%92%E5%A2%9E%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88">1.3.1递增一个指针</h4> 
<p>我们喜欢在程序中使用指针代替数组，因为变量指针可以递增，而数组不能递增，数组可以看成一个指针常量。下面的程序递增变量指针，以便顺序访问数组中的每一个元素</p> 
<p>示例：</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
const int MAX = 3;
int main ()
{
   int  var[] = {10, 100, 200};
   int  i, *ptr;
 
   /* 指针中的数组地址 */
   ptr = var;
   for ( i = 0; i &lt; MAX; i++)
   {
 
      printf("存储地址：var[%d] = %p\n", i, ptr );
      printf("存储值：var[%d] = %d\n", i, *ptr );
 
      /* 指向下一个位置 */
      ptr++;
   }
   return 0;
}</code></pre> 
<p>运行结果：<img alt="" height="162" src="https://images2.imgbox.com/c4/c7/mFZXmWQm_o.png" width="588"></p> 
<p>可以看到我们通过对指针的++来遍历了数组</p> 
<p>分析一下 这个语句 在之前我们说过数组名是数组的首地址 所以我们将数组的首地址赋值给指针ptr</p> 
<p>然后我们通过解引用prt的地址（也就是数组的首地址）可以得到数组的首元素的值</p> 
<p>然后通过指针++的特征 可以遍历数组 完成 输出数组每个元素的地址值和元素值</p> 
<pre><code class="language-cs">   /* 指针中的数组地址 */
   ptr = var;</code></pre> 
<p>再来分析一下：      ptr++; </p> 
<p> 指针的++指向下一个元素的存储单元，因为数组的物理地址的连续的 所以下一个元素就是数组的下一个元素</p> 
<p>同样的指针可以++ 自然也可以--</p> 
<h4 id="1.3.2%E6%8C%87%E9%92%88%E7%9A%84%E9%80%92%E5%87%8F">1.3.2指针的递减</h4> 
<p>同样地，对指针进行递减运算，即把值减去其数据类型的字节数</p> 
<p>我们来看一下示例代码：</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
 
const int MAX = 3;
 
int main ()
{
   int  var[] = {10, 100, 200};
   int  i, *ptr;
 
   /* 指针中最后一个元素的地址 */
   ptr = &amp;var[MAX-1];
   for ( i = MAX; i &gt; 0; i--)
   {
 
      printf("存储地址：var[%d] = %p\n", i-1, ptr );
      printf("存储值：var[%d] = %d\n", i-1, *ptr );
 
      /* 指向下一个位置 */
      ptr--;
   }
   return 0;
}</code></pre> 
<p>运行结果就不带大家运行了 同理我们接着再来分析一下关键语句</p> 
<pre><code class="language-cs">ptr = &amp;var[MAX-1];</code></pre> 
<p>将数组的最后一个元素的地址赋值给指针ptr 其中&amp;是取地址</p> 
<pre><code class="language-cs">      /* 指向下一个位置 */
      ptr--;</code></pre> 
<p> 指针的--指向上一个元素的存储单元，因为数组的物理地址的连续的 所以上一个元素就是数组的上一个元素</p> 
<p>这里大家好好的思考一下 prt 和*ptr</p> 
<p>这里给大家补充一道题：</p> 
<p>代码：我们先来回顾一下数组名的不同使用地方代表了什么？</p> 
<p>前面我们说个 数组名是数组的首地址 但是在俩个地方除外 </p> 
<p>1 是sizeof（数组名）：这里数组名代表了整个数组</p> 
<p>2 &amp;数组名 ：这里数组名也是代表了整个数组</p> 
<p>所以我们来看代码 先是   </p> 
<pre><code class="language-cs">/*声明一个指针 指向数组a的下一个4个字节大小的地址*/  
 int* ptr =(int*)(&amp;a+1);</code></pre> 
<p> 所以 *（ptr-1）：就是数组的最后一个元素</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
int main ()
{
   int a[5]={1,2,3,4,5};
   int* ptr =(int*)(&amp;a+1);
   printf("%d %d\n",*(a+1),*(ptr-1));
   return 0;
}</code></pre> 
<p></p> 
<h4 id="1.3.3%E6%8C%87%E9%92%88%E7%9A%84%E6%AF%94%E8%BE%83">1.3.3指针的比较</h4> 
<p>概述：指针可以用关系运算符进行比较，如 ==、&lt; 和 &gt;。如果 p1 和 p2 指向两个相关的变量，比如同一个数组中的不同元素，则可对 p1 和 p2 进行大小比较</p> 
<p>其实指针的比较就是比较指针指向的变量的大小 并不是单纯的去比较俩个指针的大小</p> 
<p>比如我们指针指向的是数组的时候 比较指针的大小就是比较俩个数组元素的大小</p> 
<p>来看一下代码：</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
 
const int MAX = 3;
 
int main ()
{
   int  var[] = {10, 100, 200};
   int  i, *ptr;
 
   /* 指针中第一个元素的地址 */
   ptr = var;
   i = 0;
   while ( ptr &lt;= &amp;var[MAX - 1] )
   {
 
      printf("存储地址：var[%d] = %p\n", i, ptr );
      printf("存储值：var[%d] = %d\n", i, *ptr );
 
      /* 指向上一个位置 */
      ptr++;
      i++;
   }
   return 0;
}</code></pre> 
<p>这里我们要注意 <span style="color:#fe2c24;">这个语句是比较数组元素地址的大小 </span>因为数组是一块连续的内存 所以数组的最后一个元素在这一块内存的尾端 是大于前面数组的地址的</p> 
<pre><code class="language-cs"> ptr &lt;= &amp;var[MAX - 1]</code></pre> 
<p>那我们想通过指针比较数组元素的大小怎么比呢？</p> 
<p>示例：</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
int main ()
{
   int  var[] = {10, 100, 200};
   int  *ptr;
 
   /* 指针中的数组地址 */
   ptr = var;
   if(*ptr&lt;*(ptr+1))
   {
    printf("储存地址:%p\n",ptr);
    printf("储存值:%d\n",*ptr);
   }
   return 0;
}</code></pre> 
<p>运行结果：<img alt="" height="99" src="https://images2.imgbox.com/ec/89/O7itqO4g_o.png" width="584"></p> 
<p>注意通过指针访问数组的时候一定是*（prt+1），而不是 *prt +1 那如果你不小心敲错了</p> 
<p>我们来看一下 会输出什么？</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
int main ()
{
   int  var[] = {10, 100, 200};
   int  *ptr;
 
   /* 指针中的数组地址 */
   ptr = var;
   printf("error=%d\n",*ptr+1);
   return 0;
}</code></pre> 
<p>运行结果：<img alt="" height="75" src="https://images2.imgbox.com/56/6e/rFq4fKcr_o.png" width="580"></p> 
<p>是11 实际上输出的结果是 *ptr的值加1 </p> 
<p>虽然不会报错 但是无法达到我们想要的效果</p> 
<p></p> 
<h3 id="1.4%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84">1.4指针数组</h3> 
<p>概述：C 指针数组是一个数组，其中的每个元素都是指向某种数据类型的指针。</p> 
<p>指针数组存储了一组指针，每个指针可以指向不同的数据对象。</p> 
<p>指针数组通常用于处理多个数据对象，例如字符串数组或其他复杂数据结构的数组</p> 
<p><span style="color:#fe2c24;">简单来说指针数组还是个数组 只是数组的元素是指针而已 指针的类型由数组的类型决定</span></p> 
<p>基本格式：</p> 
<pre><code class="language-cs">type* name[len];</code></pre> 
<p>type*是指针数组的类型 name为指针数组的名字，len是数组的长度</p> 
<p>示例：</p> 
<pre><code class="language-cs">int *ptr[MAX];
</code></pre> 
<p> 我们来通过代码来看</p> 
<p>关键语句分析：ptr[i] = &amp;var[i]; /* 赋值为整数的地址 */</p> 
<p>将var数组元素的地址 赋值给ptr数组 因为ptr数组是指针数组 可以通过地址来解引用地址的内容</p> 
<p>即数组元素的值</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
 
const int MAX = 3;
 
int main ()
{
   int  var[] = {10, 100, 200};
   int i, *ptr[MAX];
 
   for ( i = 0; i &lt; MAX; i++)
   {
      ptr[i] = &amp;var[i]; /* 赋值为整数的地址 */
   }
   for ( i = 0; i &lt; MAX; i++)
   {
      printf("Value of var[%d] = %d\n", i, *ptr[i] );
   }
   return 0;
}</code></pre> 
<p>再看一个简单实例，我们首先声明了一个包含三个整数指针的指针数组 ptrArray，然后，我们将这些指针分别指向不同的整数变量 num1、num2 和 num3，最后，我们使用指针数组访问这些整数变量的值</p> 
<p>代码：</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
int main ()
{
   int* ptrarray[3];
   int num1=1,num2=2,num3=3;
   ptrarray[0]=&amp;num1;
   ptrarray[1]=&amp;num2;
   ptrarray[2]=&amp;num3;
   for(int i=0;i&lt;3;i++)
   {
      printf("ptrarray[i]=%d\n",*ptrarray[i]);
   }
   return 0;
}</code></pre> 
<h3 id="1.5%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88">1.5指向指针的指针</h3> 
<p>概述：指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置</p> 
<p>一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号</p> 
<p>示例：</p> 
<pre><code class="language-cs">int **var;
</code></pre> 
<p>我们来看一下示例代码：</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
 
int main ()
{
   int  V;
   int  *Pt1;
   int  **Pt2;
 
   V = 100;
 
   /* 获取 V 的地址 */
   Pt1 = &amp;V;
 
   /* 使用运算符 &amp; 获取 Pt1 的地址 */
   Pt2 = &amp;Pt1;
 
   /* 使用 pptr 获取值 */
   printf("var = %d\n", V );
   printf("Pt1 = %p\n", Pt1 );
   printf("*Pt1 = %d\n", *Pt1 );
    printf("Pt2 = %p\n", Pt2 );
   printf("**Pt2 = %d\n", **Pt2);
 
   return 0;
}</code></pre> 
<p>运行结果：<img alt="" height="151" src="https://images2.imgbox.com/6e/2c/XbHboB4L_o.png" width="572"></p> 
<h3 id="1.6%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E7%BB%99%E5%87%BD%E6%95%B0">1.6传递指针给函数</h3> 
<p>概述：C 语言允许传递指针给函数，只需要简单地声明函数参数为指针类型即可</p> 
<p>示例：</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
int max(int* p1,int* p2)
{
   if(*p1&gt;*p2)
   {
      return *p1;
   }
   else
   {
      return *p2;
   }
}
int main ()
{
   int a=1,b=2;
   printf("max=%d\n",max(&amp;a,&amp;b));
   return 0;
}</code></pre> 
<p>运行结果：<img alt="" height="103" src="https://images2.imgbox.com/ab/55/dxZCiKFu_o.png" width="611"></p> 
<p> 同样数组名也可以当实参传递给指针形参</p> 
<p>代码：</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
int max(int* p1)
{
   if(*p1&gt;*(p1+1))
   {
      return *p1;
   }
   else
   {
      return *(p1+1);
   }
}
int main ()
{
   int a[2]={1,2};
   printf("max=%d\n",max(a));
   return 0;
}</code></pre> 
<p>1.7从函数返回指针</p> 
<p>概述：，C 允许从函数返回指针，即函数的返回值是指针类型 所以 函数的类型也必须是指针</p> 
<p>基本格式：</p> 
<pre><code class="language-cs">int * myFunction()
{
.
.
.
}
</code></pre> 
<p>示例：</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
int* max(int* p1)
{
   if(*p1&gt;*(p1+1))
   {
      return p1;
   }
   else
   {
      return (p1+1);
   }
}
int main ()
{
   int a[2]={1,2};
   int* ptr;
   ptr=max(a);
   printf("%d\n",*(ptr-1));
   return 0;
}</code></pre> 
<p>这里指针的内容就结束了简单来说指针就是地址 我们通过对这个地址进行解引用 得到这个地址代表的值 </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1a207a2710b1567545587ab80e27e5bd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C#开源免费的Windows右键菜单管理工具</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b7bb92c4099525ebb4469a9e79291cd6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">NNLM - 神经网络语言模型 | 高效的单词预测工具</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>