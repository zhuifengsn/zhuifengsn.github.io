<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>生产环境部署与协同开发 Docker - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="生产环境部署与协同开发 Docker" />
<meta property="og:description" content="一、Docker介绍和安装 1.1 什么是docker Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。
logo解释：
标志是一头鲸鱼携带着一堆容器。它正在向您发送这些信息的途中。Docker直译过来是码头工人，然而Docker给人的第一感觉是容器，容器技术英译为Linux Container， Container的直译有集装箱，容器两个意思。
什么是&#34;集装箱技术&#34; 我们都知道码头里的集装箱是运载货物用的，它是一种按规格标准化的钢制箱子。集装箱的特色，在于其格式划一，并可以层层重叠， 集装箱与集装箱之间互不影响于是乎，IT领域借鉴了这一理念，大家就在想，有没有可能大家 只需要关注程序本身?
我们都知道码头里的集装箱是运载货物用的，它是一种按规格标准化的钢制箱子。集装箱的特色， 「在于其格式划一，并可以层层重叠， 集装箱与集装箱之间互不影响」
Docker是一个开源的应用容器引擎，开发者可以打包他们的应用及依赖到一个可移植的容器中，发布到流行的Linux机器上，也可实现虚拟化。
重心：
Docker其实就是可以打包程序和运行环境，把环境和程序一起发布的容器。
1.2 为什么要使用Docker Docker容器虚拟化的好处 开发者需要能方便高效构建应用，并且任何时间任何地点都可以获取。就比如我在本地将jdk和tomcat打包直接放到阿里云平台上，就不需要在阿里云上配置环境了。这样可以节省时间和降低风险，提高开发效率。
Docker在开发和运维中的优势 对开发和运维( DevOps)人员来说，可能最梦寐以求的就是一次性地创建或配置，可以在任意环境、任意时间让应用正常地运行。而Docker恰恰是可以实现这一终极目标的瑞士军刀。
优势：
更快速的交付和部署更高效的资源利用更轻松的迁移和扩展更简单的更新管理 Docker与虚拟机比较 作为一种轻量级的虚拟化方式，Docker在运行应用上跟传统的虚拟机方式相比具有显著优势。
特性容器虚拟机启动速度秒级分钟级磁盘使用一般为MB一般为GB性能接近原生弱于系统支持量单机支持上千个容器一般几十个隔离性完全隔离完全隔离 1.3 虚拟化与Docker 虚拟化技术是一个通用的概念,在不同领域有不同的理解。在计算领域，一般指的是计算虚拟化或通常说的服务器虚拟化。
简单的说，「虚拟化」，顾名思义，就是「虚拟」的，是「假」的，是形而上的，是观念上、逻辑上的划分。
举栗说明
假设你现在手头上有一套房子，并且你要把它给租出去，租金的市场价是2000元/月。那么有没有办法把它租得更贵，获得6000元的租金呢？你想到了两个办法：
找一个不差钱的傻X租户，让他每月交6000元，但是这种人不大好找。 把房子拆成4个小房子租给4个单身狗，租金为1500元/人/月。 这些房子其实就是一些电脑资源，例如服务器啊、内存啊、网络啊等等。虚拟化技术就是将一套房子划分为4个功能完善的小房子，提高资源的使用效率。
虚拟化分类：
完全虚拟化（VMware）硬件辅助虚拟化部分虚拟化超虚拟机化操作系统虚拟化 (docker) 什么是物理机 什么是虚拟机 什么是Docker 1.4 Docker的核心概念 Docker技术的三大核心概念，分别是：
镜像（Image）容器 (Container)仓库 (Repository) Docker镜像 当我们使用 Docker 运行一个应用程序的时候，我们需要首先定义一个 Docker 镜像。Docker 镜像是一个只读模板，包含运行应用程序所需的所有内容，例如代码、库文件、运行环境等等。也可以把它看作是一个容易复制和分享的“快照”。
Docker 镜像是由一个或多个文件系统层构成，每个文件系统层都包含着一个应用程序运行所需的不同部分。例如一个镜像可能包含操作系统，另一个镜像可能只包含 Django 应用程序及其依赖项。这些文件系统层会形成一个完整镜像，供 Docker 环境使用。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/aded3c50da4fad9cdc0d931cb5843c8d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-10T09:47:54+08:00" />
<meta property="article:modified_time" content="2023-06-10T09:47:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">生产环境部署与协同开发 Docker</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、Docker介绍和安装</h2> 
<h3>1.1 什么是docker</h3> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/f3/36/RENKaEUT_o.png" width="983"></p> 
<p> Docker 是一个开源的应用容器引擎，基于 <a href="https://www.runoob.com/go/go-tutorial.html" rel="nofollow" title="Go 语言">Go 语言</a> 并遵从 Apache2.0 协议开源。</p> 
<blockquote> 
 <p><strong>logo解释：</strong></p> 
 <p>标志是一头鲸鱼携带着一堆容器。它正在向您发送这些信息的途中。Docker直译过来是码头工人，然而Docker给人的第一感觉是容器，容器技术英译为Linux Container， Container的直译有集装箱，容器两个意思。</p> 
</blockquote> 
<h4 id="什么是集装箱技术">什么是"集装箱技术"</h4> 
<p>我们都知道码头里的集装箱是运载货物用的，它是一种按规格标准化的钢制箱子。集装箱的特色，在于其格式划一，并可以层层重叠， 集装箱与集装箱之间互不影响于是乎，IT领域借鉴了这一理念，大家就在想，有没有可能大家 只需要关注程序本身?</p> 
<p>我们都知道码头里的集装箱是运载货物用的，它是一种按规格标准化的钢制箱子。集装箱的特色， <strong>「在于其格式划一，并可以层层重叠， 集装箱与集装箱之间互不影响」</strong></p> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/1d/d2/NqqUrLw3_o.png" width="934"></p> 
<p></p> 
<p>Docker是一个开源的应用容器引擎，开发者可以打包他们的应用及依赖到一个可移植的容器中，发布到流行的Linux机器上，也可实现虚拟化。</p> 
<p class="img-center"><img alt="" height="369" src="https://images2.imgbox.com/d8/dd/N1Tpk8w7_o.png" width="634"></p> 
<blockquote> 
 <p></p> 
 <p><strong>重心：</strong></p> 
 <p>Docker其实就是可以打包程序和运行环境，把环境和程序一起发布的容器。</p> 
</blockquote> 
<h3>1.2 为什么要使用Docker</h3> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/53/41/3OkRCO3u_o.png" width="1026"></p> 
<h4 id="docker容器虚拟化的好处">Docker容器虚拟化的好处</h4> 
<p>开发者需要能方便高效构建应用，并且任何时间任何地点都可以获取。就比如我在本地将jdk和tomcat打包直接放到阿里云平台上，就不需要在阿里云上配置环境了。这样可以节省时间和降低风险，提高开发效率。</p> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/6c/16/kP6DUTzp_o.png" width="980"></p> 
<p></p> 
<h4 id="docker在开发和运维中的优势">Docker在开发和运维中的优势</h4> 
<p>对开发和运维( DevOps)人员来说，可能最梦寐以求的就是一次性地创建或配置，可以在任意环境、任意时间让应用正常地运行。而Docker恰恰是可以实现这一终极目标的瑞士军刀。</p> 
<blockquote> 
 <p><strong>优势：</strong></p> 
 <ul><li>更快速的交付和部署</li><li>更高效的资源利用</li><li>更轻松的迁移和扩展</li><li>更简单的更新管理</li></ul> 
</blockquote> 
<h4 id="docker与虚拟机比较">Docker与虚拟机比较</h4> 
<p>作为一种轻量级的虚拟化方式，Docker在运行应用上跟传统的虚拟机方式相比具有显著优势。</p> 
<table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动速度</td><td>秒级</td><td>分钟级</td></tr><tr><td>磁盘使用</td><td>一般为MB</td><td>一般为GB</td></tr><tr><td>性能</td><td>接近原生</td><td>弱于</td></tr><tr><td>系统支持量</td><td>单机支持上千个容器</td><td>一般几十个</td></tr><tr><td>隔离性</td><td>完全隔离</td><td>完全隔离</td></tr></tbody></table> 
<h3>1.3 虚拟化与Docker</h3> 
<p class="img-center"><img alt="" height="375" src="https://images2.imgbox.com/01/6b/LoGwYbfj_o.png" width="1073"></p> 
<p> 虚拟化技术是一个通用的概念,在不同领域有不同的理解。在计算领域，一般指的是计算虚拟化或通常说的服务器虚拟化。</p> 
<p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/0f/d5/KPlxndev_o.png" width="359"></p> 
<p>简单的说，「虚拟化」，顾名思义，就是「虚拟」的，是「假」的，是形而上的，是观念上、逻辑上的划分。</p> 
<p></p> 
<p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/89/98/CIinHY27_o.png" width="346"></p> 
<p></p> 
<p><strong>举栗说明</strong></p> 
<p>假设你现在手头上有一套房子，并且你要把它给租出去，租金的市场价是2000元/月。那么有没有办法把它租得更贵，获得6000元的租金呢？你想到了两个办法：</p> 
<ol><li>找一个不差钱的傻X租户，让他每月交6000元，但是这种人不大好找。 </li><li>把房子拆成4个小房子租给4个单身狗，租金为1500元/人/月。</li></ol> 
<p></p> 
<p class="img-center"><img alt="" height="200" src="https://images2.imgbox.com/f4/68/CTTmzHSq_o.png" width="357"></p> 
<p> 这些房子其实就是一些电脑资源，例如服务器啊、内存啊、网络啊等等。虚拟化技术就是将一套房子划分为4个功能完善的小房子，提高资源的使用效率。</p> 
<blockquote> 
 <p><strong>虚拟化分类：</strong></p> 
 <ul><li>完全虚拟化（VMware）</li><li>硬件辅助虚拟化</li><li>部分虚拟化</li><li>超虚拟机化</li><li>操作系统虚拟化 (docker)</li></ul> 
</blockquote> 
<h4><strong>什么是物理机</strong></h4> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/f6/ce/p0nlytsy_o.png" width="826"></p> 
<h4> <strong>什么是虚拟机</strong></h4> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/eb/b9/4pDNHYxw_o.png" width="885"></p> 
<h4> <strong>什么是Docker</strong></h4> 
<p><img alt="" height="400" src="https://images2.imgbox.com/b8/da/5lFCH0Lq_o.png" width="964"></p> 
<h3> 1.4 Docker的核心概念</h3> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/a9/4b/awOrVtga_o.png" width="1050"></p> 
<p><strong>Docker技术的三大核心概念，分别是：</strong></p> 
<ul><li>镜像（Image）</li><li>容器 (Container)</li><li>仓库 (Repository)</li></ul> 
<h4>Docker镜像</h4> 
<p>当我们使用 Docker 运行一个应用程序的时候，我们需要首先定义一个 Docker 镜像。Docker 镜像是一个只读模板，包含运行应用程序所需的所有内容，例如代码、库文件、运行环境等等。也可以把它看作是一个容易复制和分享的“快照”。<br> Docker 镜像是由一个或多个文件系统层构成，每个文件系统层都包含着一个应用程序运行所需的不同部分。例如一个镜像可能包含操作系统，另一个镜像可能只包含 Django 应用程序及其依赖项。这些文件系统层会形成一个完整镜像，供 Docker 环境使用。</p> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/6a/ff/zIywNuLS_o.png" width="839"></p> 
<p></p> 
<h4>镜像从何而来</h4> 
<ul><li>从Docker Hub下载 maven-&gt; 中央仓库</li><li>通过Docker file自己创建出来</li></ul> 
<h4 id="docker容器">Docker容器</h4> 
<p>相对于镜像，容器包含的内容要比镜像更丰富，容器除了有镜像的内容之外，还具有独立的文件系统、运行时状态和网络栈等信息。 具体来说，一个镜像只是一个只读的文件系统，其中包含了应用程序运行所需的各种文件和依赖，而容器则是一个可运行的实例，它在启动时会从镜像创建并启动，它有自己的文件系统、进程空间、网络和运行时状态，容器中的文件系统是可写的，并且可以在容器运行时随意修改。另外，容器还有独立的网络和环境变量等上下文信息。 因此，镜像和容器虽然有相似之处，但它们的作用不同，具有不同的特性和功能。镜像是一种打包和分发应用程序的标准格式，是一种“静态”的概念，而容器则是镜像的“动态”实例，是真正运行应用程序的载体。容器是镜像的运行时状态，拥有更完整的运行环境和更强的动态交互能力。</p> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/ed/ce/atq6S8PA_o.png" width="787"></p> 
<blockquote> 
 <p></p> 
 <p><strong>注意：</strong></p> 
 <p>容器和镜像一样，也是若干层的叠加，唯一区别是所有只读层的最上面一层，是一层可读可写层，可以记住这个简单的公式：容器 = 容器镜像 + 可读可写层</p> 
</blockquote> 
<h4 id="docker仓库">Docker仓库</h4> 
<p>      Docker 仓库是一个集中存储、管理和分享 Docker 镜像的平台。它可以供开发者或组织存储和分享创建的 Docker 镜像，并可用作构建、测试和部署应用程序的中心化仓库。在 Docker 架构中，一个 Docker 镜像由多个层次组成的文件系统构成。而 Docker 仓库是用于存储这些 Docker 镜像的平台，并且支持创建私有或公共镜像。<br>       Docker 仓库分为两类：公共仓库和私有仓库。最著名的是公共 Docker Hub 仓库，它是基于互联网上的 Docker 镜像的公共服务，使得全球的开发者可以轻松地分享和获取 Docker 镜像资源，并且通过命令行很容易地访问公共仓库中的镜像。除此之外，Docker 还允许用户创建私有仓库，可以通过企业内部网络，来实现对项目特定的镜像访问和使用。私有仓库提供了更高的安全性和控制级别，让团队内部可以在不向公众公开应用和环境的情况下，更好地管理 Docker 镜像。<br>        总的来说，Docker 仓库是构建一个完整的 Docker 生态系统中非常重要的一环，可以方便地存储和共享 Docker 镜像，提高开发效率和部署速度。<br>  </p> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/68/00/jCUiAmCv_o.png" width="622"></p> 
<p></p> 
<blockquote> 
 <p><strong>注意：</strong></p> 
 <p>Docker利用仓库管理镜像的设计理念与Maven非常相似</p> 
</blockquote> 
<p>咱们再来理解docker的两句口号就更好理解了</p> 
<ul><li><strong>「Build, Ship and Run (搭建，发送，运行)」</strong></li><li><strong>「Build once，Run anywhere (搭建一次，到处运行)」</strong></li></ul> 
<p></p> 
<h3>1.5 Docker安装</h3> 
<h4 id="系统环境">1、系统环境</h4> 
<table><thead><tr><th>序号</th><th>软件</th><th>版本</th></tr></thead><tbody><tr><td>1</td><td>Centos</td><td>7.5</td></tr><tr><td>2</td><td>Linux内核</td><td>3.8之上</td></tr></tbody></table> 
<blockquote> 
 <p>解释：</p> 
 <p>CentOS是一款基于Linux操作系统的免费、开源、企业级的操作系统，它是由Red Hat Enterprise Linux源代码编译而来的。CentOS具有可靠的性能、稳定性和安全性，因此被广泛应用于服务器和企业级应用。CentOS提供了许多功能性强大的服务和软件，比如Web服务器、数据库服务器、邮件服务器等。CentOS的开发和维护由社区志愿者组成的开发团队进行。</p> 
 <p>CentOS是一个基于Linux内核的操作系统，它是开源的且免费。</p> 
 <p></p> 
 <p>Linux是一个开放源代码的操作系统内核，更像是其他许多操作系统的“底层”。以下是CentOS和Linux之间的区别：</p> 
 <ol><li> <p>CentOS是一种Linux操作系统，但Linux并不一定是由CentOS提供。Linux是一个底层内核，而CentOS是基于这个内核的衍生操作系统。</p> </li><li> <p>CentOS是免费的，而其他一些Linux发行版可能需要支付许可费用。</p> </li><li> <p>CentOS是由社区管理和支持的，而Linux由一个大型社区和几个大公司支持和开发。</p> </li><li> <p>CentOS通常在企业环境中应用得更广泛，而Linux则更广泛地应用于许多设备和场景（例如， Android手机、智能电视、路由器、计算机等）。</p> </li></ol> 
 <p>总的来说，CentOS和Linux都是可靠和可定制的操作系统，具有广泛的应用领域。差异在于CentOS是一种特定的 Linux 发行版，而 Linux 更像是一个底层内核。</p> 
 <p></p> 
</blockquote> 
<p></p> 
<h4>2、关闭防火墙</h4> 
<pre><code>systemctl stop firewalld
</code></pre> 
<h4>3、关闭selinux</h4> 
<pre><code>vim /etc/selinux/config
SELINUX=disabled
</code></pre> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/12/bd/Y1Sdm4I1_o.png" width="891"></p> 
<h4>4、安装docker引擎</h4> 
<pre><code>yum install -y  docker
</code></pre> 
<h4>5、启动docker</h4> 
<pre><code>systemctl start docker
</code></pre> 
<h4>6、设置docker自启动</h4> 
<pre><code>systemctl enable docker
</code></pre> 
<h4>7、测试是否安装成功</h4> 
<pre><code>docker run hello-world
</code></pre> 
<p class="img-center"><img alt="" height="100" src="https://images2.imgbox.com/27/89/tXLOTlnN_o.png" width="507"></p> 
<p></p> 
<h2> 二、Docker核心命令</h2> 
<h3>2.1 镜像命令</h3> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/0f/c4/uXcO1YcM_o.png" width="1069"></p> 
<p>Docker运行容器前需要本地存在对应的镜像，如果镜像不存在本地，Docker会尝试先从默认镜像仓库下载（默认使用Docker Hub公共注册服务器中的仓库)，用户也可以通过配置，使用自定义的镜像仓库。</p> 
<h4 id="镜像下载"><strong>镜像下载</strong></h4> 
<p>镜像是Docker运行容器的前提。</p> 
<p><strong>语法格式：</strong></p> 
<pre><code>docker pull 镜像名字:[tag]</code></pre> 
<pre><code>docker pull centos   #下载最新的centos版本
</code></pre> 
<blockquote> 
 <p><strong>注意：</strong></p> 
 <p>如果不指定tag，则下载Docker Hub公共注册服务器中仓库的最新版本。</p> 
</blockquote> 
<h4 id="查看镜像-1"><strong>查看镜像</strong></h4> 
<p>列出本地主机上已有的镜像。</p> 
<pre><code>[root@localhost ~]# docker images</code></pre> 
<p><img alt="" height="351" src="https://images2.imgbox.com/1b/5a/TbtqytO8_o.png" width="1200"></p> 
<h4> <strong>镜像搜索</strong></h4> 
<p>搜索远端仓库中共享的镜像,默认搜索Docker Hub官方仓库中的镜像。</p> 
<pre><code>docker search  [镜像名字]
</code></pre> 
<h4 id="删除镜像"><strong>删除镜像</strong></h4> 
<pre><code>docker rmi  -f  源名字
docker rmi  -f image id
</code></pre> 
<h3>2.2 容器命令</h3> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/2b/db/9z1VPHw1_o.png" width="899"></p> 
<p> 当我们有了镜像，才可以创建容器, 创建一个centos容器来学习</p> 
<h4>创建容器（create -it命令）</h4> 
<p>Docker的容器十分轻量级，用户可以随时创建或者删除容器。容器的创建依赖镜像。</p> 
<pre><code>docker create -it 镜像名字
</code></pre> 
<p><img alt="" height="348" src="https://images2.imgbox.com/59/62/L4fCd986_o.png" width="1200"></p> 
<blockquote> 
 <p></p> 
 <p><strong>注意：</strong></p> 
 <p>使用docker create命令新建的容器处于停止状态，可以使用docker start命令来启动它。</p> 
 <p></p> 
</blockquote> 
<h4>列出容器 （ps 命令）</h4> 
<pre><code>docker ps
</code></pre> 
<blockquote> 
 <p><strong>参数：</strong></p> 
 <ul><li>-a: 显示未启动容器</li><li>-q：返回容器id号</li></ul> 
</blockquote> 
<p><img alt="" height="183" src="https://images2.imgbox.com/17/02/dmp5GXzz_o.png" width="1200"></p> 
<h4> 开启容器（start命令）</h4> 
<pre><code>docker start 容器id（或者是容器id前两位）
</code></pre> 
<h4 id="新建并启动容器">新建并启动容器（run命令）</h4> 
<p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（ stopped)的容器重新启动。所需要的命令主要为docker run，等价于先执行docker create命令,再执行docker start命令。</p> 
<pre><code>docker run 镜像名字 /bin/echo '启动时显示的信息'
</code></pre> 
<p><img alt="" height="111" src="https://images2.imgbox.com/51/0d/LB3z9BRA_o.png" width="1200"></p> 
<blockquote> 
 <p> 注意：这样创建的容器在输出信息后就销毁了。</p> 
</blockquote> 
<blockquote> 
 <p><strong>Docker在后台运行的标准操作包括:</strong></p> 
 <ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载。</li><li>利用镜像创建并启动一个容器。</li><li>分配一个文件系统,并在只读的镜像层外面挂载一层可读写层。</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去。</li><li>从地址池配置一个IP地址给容器。</li><li>执行用户指定的应用程序。</li><li>执行完毕后容器被终止。</li></ul> 
</blockquote> 
<p></p> 
<h4 id="守护态运行">守护态运行</h4> 
<p>更多的时候，需要让Docker容器在后台以守护态（Daemonized)形式运行。用户可以通过添加-d参数来实现。</p> 
<pre><code>docker run -d 镜像名字 /bin/sh -c  "while true; do echo hello world ;sleep 1 ;done"
</code></pre> 
<p>下面命令则启动一个bash端，运行用户交互：</p> 
<pre><code>docker run -t -i 镜像名字  /bin/bash
</code></pre> 
<h4 id="终止容器">终止容器（stop命令）</h4> 
<pre><code>docker stop 容器id
</code></pre> 
<p>处于终止状态的容器，可以通过docker start命令来重新启动:</p> 
<pre><code>docker start 容器id</code></pre> 
<p>此外，docker restart命令会将一个运行态的容器终止，然后再重新启动</p> 
<pre><code>docker restart 容器id
</code></pre> 
<h4 id="进入容器">进入容器（<strong>exec命令</strong>）</h4> 
<pre><code>docker exec -it 容器id  /bin/bash
</code></pre> 
<blockquote> 
 <p>注意：</p> 
 <p>进入容器的前提是容器是开着的。容器与外面的环境是完全隔离的，容器内的目录有些可能会和外面的目录相同。</p> 
</blockquote> 
<p><img alt="" height="132" src="https://images2.imgbox.com/d2/07/MCJ422Uo_o.png" width="1200"></p> 
<h4>退出容器</h4> 
<pre><code>#如果docker容器在启动的时候没有加 -d 参数
exit # 会直接停止同期并退出
Ctrt + p + q # 容器不停止 并退出
</code></pre> 
<h4 id="删除容器">删除容器（rm命令）</h4> 
<pre><code>docker rm 容器id
</code></pre> 
<blockquote> 
 <p><strong>参数：</strong></p> 
 <ul><li>-f, --force=false强行终止并删除一个运行中的容器。</li><li>-l, --link=false删除容器的连接,但保留容器。</li><li>-V,--volumes=false删除容器挂载的数据卷</li></ul> 
</blockquote> 
<h3 id="退出">2.3 其他命令</h3> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/81/3d/onQ0MAWo_o.png" width="689"></p> 
<h4 id="查看日志">查看日志</h4> 
<pre><code>docker logs [参数] 容器id
</code></pre> 
<blockquote> 
 <p></p> 
 <p>参数：</p> 
 <ul><li>-f, --follow 跟踪实时日志</li><li>--since string 显示自某个timestamp之后的日志，或相对时间，如42m（即42分钟）</li><li>--tail string 从日志末尾显示多少行日志， 默认是all</li><li>-t, --timestamps 显示时间戳</li><li>--until string 显示自某个timestamp之前的日志，或相对时间，如42m（即42分钟）</li></ul> 
</blockquote> 
<h4 id="查看容器里面的进程">查看docker容器里面的进程</h4> 
<pre><code>docker top 容器id
</code></pre> 
<h4 id="从容器拷贝文件到主机上">从容器拷贝文件到主机上</h4> 
<pre><code>docker cp 容器id：容器内文件路径   目录路径
</code></pre> 
<p><img alt="" height="435" src="https://images2.imgbox.com/37/b0/2mjPj6Li_o.png" width="1200"></p> 
<p></p> 
<h2>三、Docker实战</h2> 
<h3>3.1 Docker容器配置Java环境</h3> 
<p class="img-center"><img alt="" height="374" src="https://images2.imgbox.com/dd/fe/pbtFfdOU_o.png" width="1075"></p> 
<h4> 查看JDK镜像</h4> 
<pre><code>docker  search  openjdk:8
</code></pre> 
<h4>下载JDK镜像</h4> 
<pre><code>docker  pull  openjdk:8
</code></pre> 
<h4>创建并查看JDK容器</h4> 
<pre><code>docker run   openjdk:8 java -version
</code></pre> 
<h3>3.2 Docker安装Tomcat</h3> 
<p class="img-center"><img alt="" height="349" src="https://images2.imgbox.com/9c/d5/NVCavLZ0_o.png" width="1065"></p> 
<h4 id="查看tomcat-镜像">查看tomcat 镜像</h4> 
<pre><code>docker search docker.io/tomee
</code></pre> 
<h4 id="下载tomcat镜像">下载tomcat镜像</h4> 
<pre><code>docker pull docker.io/tomee</code></pre> 
<h4 id="启动tomcat容器">创建并启动tomcat容器</h4> 
<pre><code> docker run -d --name mytomcat -p 9090:8080 docker.io/tomee
</code></pre> 
<blockquote> 
 <p><strong>注意：</strong></p> 
 <ul><li>-p 映射端口 宿主机端口号:容器内应用端口</li><li>-P 随机端口</li></ul> 
</blockquote> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/bc/e2/gWavvtF3_o.png" width="376"></p> 
<blockquote> 
 <p>注意：这里的宿主机指的是CentOS操作系统。</p> 
</blockquote> 
<h4> 浏览器访问tomcat容器</h4> 
<p>开启tomcat容器</p> 
<pre><code>docker start 82</code></pre> 
<p>查看并关闭防火墙</p> 
<pre><code>firewall-cmd --state  #查看防火墙状态
systemctl stop firewalld.service   #关闭防火墙

</code></pre> 
<p>访问</p> 
<pre><code>http://192.168.66.100:9090</code></pre> 
<h3>3.3 Docker配置Mysql数据库</h3> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/c6/f2/df7LpzrP_o.png" width="1059"></p> 
<h4 id="查看镜像-2"><strong>查看镜像</strong></h4> 
<pre><code>docker search mysql:5.7
</code></pre> 
<h4> 下载镜像</h4> 
<pre><code>docker pull mysql:5.7
</code></pre> 
<h4 id="启动镜像">创建容器并启动</h4> 
<pre><code>docker run --name mysql -d  -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456  mysql:5.7
</code></pre> 
<blockquote> 
 <p><strong>参数：</strong></p> 
 <ul><li>-p 我们以后使用3307 端口来访问mysql 为了防止黑客攻击</li><li>-e 配置环境变量<br> MYSQL_ROOT_PASSWORD 设置容器内mysql root 密码</li></ul> 
</blockquote> 
<h4>进入mysql容器</h4> 
<pre><code>[root@localhost ~]# docker exec -it 43 /bin/bash
bash-4.2# mysql -uroot -p
</code></pre> 
<h2>四、Docker数据管理</h2> 
<h3>4.1 数据卷</h3> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/df/7c/kh9lDDj0_o.png" width="807"></p> 
<h4 id="思考-1">思考</h4> 
<ul><li>Docker容器删除后，在容器中产生的数据还在吗？不在了。</li></ul> 
<p class="img-center"><img alt="" height="257" src="https://images2.imgbox.com/05/17/qwTHNDK5_o.png" width="427"></p> 
<ul><li>Docker容器和外部机器可以直接交换文件吗？不能。</li></ul> 
<p></p> 
<p class="img-center"><img alt="" height="288" src="https://images2.imgbox.com/c7/8f/SsG50cuT_o.png" width="706"></p> 
<ul><li>容器之间能进行数据交互？能，但是要通过数据卷</li></ul> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/c6/40/HkELo1x7_o.png" width="389"></p> 
<p></p> 
<h4> 什么是容器数据卷</h4> 
<ul><li>数据卷是宿主机中的一个目录或文件。</li><li>当容器目录和数据卷目录绑定后，对方修改会立即同步。</li><li>一个数据卷可以同时被多个容器同时挂载。</li><li>一个容器也可以被挂载多个数据卷。</li></ul> 
<blockquote> 
 <p>Docker中的数据可以存储在类似于虚拟机磁盘的介质中，在Docker中称为数据卷（Data Volume）</p> 
</blockquote> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/69/01/rqRIBtbH_o.png" width="407"></p> 
<h4>数据卷作用</h4> 
<ul><li>容器数据持久化。</li><li>外部机器和容器间接通信。</li><li>容器之间数据交换。</li></ul> 
<blockquote> 
 <p>一句话： 卷技术就是为了实现数据的持久化和同步操作，容器间也是数据共享。</p> 
</blockquote> 
<p></p> 
<h3>4.2 配置数据卷</h3> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/83/64/cDTQvznA_o.png" width="1039"></p> 
<p></p> 
<pre><code>docker run  -v 宿主机目录(文件):容器内目录(文件)
</code></pre> 
<blockquote> 
 <p><strong>注意事项</strong></p> 
 <ol><li>目录必须是绝对路径</li><li>如果目录不存在则会自动创建</li><li>一个容器可以挂载到多个数据卷上</li></ol> 
</blockquote> 
<h4>示例：将tomcat容器挂载到数据卷上</h4> 
<pre><code>docker run -d --name mytomcat -p 8080:8080 -v /opt/webapps:/usr/local/tomcat/webapps tomcat
</code></pre> 
<h3>4.3 容器数据卷Volume</h3> 
<p class="img-center"><img alt="" height="343" src="https://images2.imgbox.com/e9/b3/rCbAHth8_o.png" width="1052"></p> 
<h4> Volume基本使用</h4> 
<blockquote> 
 <p><strong>参数：</strong> </p> 
 <p>create      # 创建数据卷 </p> 
 <p>inspect     #查看数据卷元数据 </p> 
 <p>ls             #查看数据卷列表 </p> 
 <p>prune       #删除所有未使用的卷 </p> 
 <p>rm           #删除数据卷</p> 
</blockquote> 
<h4>创建一个自定义数据卷</h4> 
<p class="img-center"><img alt="" height="92" src="https://images2.imgbox.com/9c/6d/yRuaXKyz_o.png" width="1200"></p> 
<h4> 查看所有数据卷</h4> 
<p class="img-center"><img alt="" height="227" src="https://images2.imgbox.com/70/ee/3wdHzmLY_o.png" width="1200"></p> 
<h4>查看指定数据卷etc-tomcat-vol详情信息</h4> 
<p class="img-center"><img alt="" height="497" src="https://images2.imgbox.com/c2/8e/B7Yn37o9_o.png" width="1200"></p> 
<h4> 删除数据卷</h4> 
<p><img alt="" height="265" src="https://images2.imgbox.com/4b/ba/YdpCOmrx_o.png" width="1200"></p> 
<h4> 使用指定卷容器</h4> 
<pre><code>docker run -d -it --name=edc-tomcat -p 8080:8080 -v edc-tomcat-vol:/usr/local/tomcat/webapps tomcat
</code></pre> 
<blockquote> 
 <p><strong>注意：</strong></p> 
 <p>-v代表挂载数据卷，这里使用自定数据卷edc-tomcat-vol，并且将数据卷挂载到/usr/local/tomcat/webapps 。如果没有通过-v指定，那么Docker会默认帮我们创建匿名数据卷进行映射和挂载。</p> 
</blockquote> 
<h3>4.4 Mysql数据持久化</h3> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/01/3f/Z6oGmuoj_o.png" width="789"></p> 
<p></p> 
<h2>五、Dockerfile</h2> 
<h3> 5.1 什么是Dockerfile</h3> 
<p><img alt="" height="353" src="https://images2.imgbox.com/0d/1d/h8eMW6F2_o.png" width="1063"></p> 
<p> Dockerfile是一个文本格式的配置文件，用户可以使用Dockerfile快速创建自定义的镜像。</p> 
<h4 id="基本结构">基本结构</h4> 
<p>Dockerfile由一行行命令语句组成，并且支持以#开头的注释行。一般而言，Dockerfile分为四部分:基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。</p> 
<p>例如：</p> 
<pre><code>##  Dockerfile文件格式 
# 1、第一行必须指定 基础镜像信息（dockerhub上下载的，也就是依赖环境）
FROM java:8
# 2、维护者信息
MAINTAINER baizhan  baizhan@163.com
# 3、镜像操作指令（这里下载了tomcatjar包）
RUN  echo "wget https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.55/bin/apache-tomcat-9.0.55.tar.gz"
run tar -zxvf apache-tomcat-9.0.55.tar.gz -C /usr/local
# 4、容器启动执行指令
CMD /usr/local/tomcat/bin/catalina.sh
</code></pre> 
<blockquote> 
 <p><strong>Dockerfile 四部分说明：</strong></p> 
 <ul><li>一开始必须要指明所基于的镜像名称, 关键字是FROM, 这是必须的.</li><li>接下来是维护者信息关键字是MAINTAINER, 非必须, 但良好的习惯有利于后期的职责明确.</li><li>后面是镜像操作指令, 如RUN等, 每执行一条RUN命令,镜像添加新的一层.</li><li>最后是CMD指令,来指明运行容器时的操作命令.</li></ul> 
</blockquote> 
<h3>5.2 构建镜像</h3> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/b2/18/udp0Lfsh_o.png" width="988"></p> 
<p>1、在一个空白的文本文件, 命名为Dockerfile</p> 
<pre><code>vim  Dockerfile
</code></pre> 
<blockquote> 
 <p> 注意文件名称必须为Dockerfile</p> 
</blockquote> 
<p>2、编写Dockerfile文件内容 </p> 
<p><img alt="" height="215" src="https://images2.imgbox.com/d3/c1/iI9VlHDe_o.png" width="1076"></p> 
<p>3、构建镜像</p> 
<pre><code>docker build -t 镜像名字（自定义）:版本（自定义）.
</code></pre> 
<blockquote> 
 <p>注意</p> 
 <p>. 代表Dockerfile文件在当前路径,也就是将dockerfile文件放在当前路径。自定义名称必须小写。</p> 
</blockquote> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/2e/d4/dTc6exQ7_o.png" width="901"></p> 
<p> 4、查看镜像</p> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/03/f4/tdfterLd_o.png" width="1154"></p> 
<p> 5、创建镜像容器并运行</p> 
<p><img alt="" height="96" src="https://images2.imgbox.com/f0/b5/4oEbpZ6S_o.png" width="1033"></p> 
<blockquote> 
 <p> 使用run指令创建的容器在执行完指令后容器就销毁了/</p> 
</blockquote> 
<p></p> 
<h3>5.3 常见的13种指令（上）</h3> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/82/f4/OOAhQJIG_o.png" width="1016"></p> 
<p></p> 
<h4 id="from">FROM</h4> 
<p>指定基础镜像，必须为第一个命令。</p> 
<pre><code>FROM &lt;image&gt;　　
FROM &lt;image&gt;:&lt;tag&gt;　　
</code></pre> 
<blockquote> 
 <p><strong>注意：</strong></p> 
 <p>tag或digest是可选的，如果不使用这两个值时，会使用latest版本的基础镜像</p> 
</blockquote> 
<h4> MAINTAINER</h4> 
<p>维护者信息</p> 
<pre><code>MAINTAINER &lt;name&gt;
</code></pre> 
<h4 id="workdir">WORKDIR</h4> 
<p>工作目录，类似于cd命令</p> 
<pre><code>WORKDIR /usr/workdir
</code></pre> 
<blockquote> 
 <p>WORKDIR /a (这时工作目录为/a)</p> 
 <p>WORKDIR b (这时工作目录为/a/b)</p> 
 <p>WORKDIR c (这时工作目录为/a/b/c)</p> 
</blockquote> 
<h4 id="run">RUN</h4> 
<p>构建镜像时执行的命令</p> 
<pre><code># 1. shell执行
格式 RUN &lt;command&gt;
# 2. exec执行
格式 RUN ["executable", "param1", "param2"]
</code></pre> 
<blockquote> 
 <p><strong>注意：</strong></p> 
 <p>RUN指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定--no-cache参数，如：docker build --no-cache</p> 
</blockquote> 
<h4 id="add">ADD</h4> 
<p>将本地文件添加到容器中，tar类型文件会自动解压(网络压缩资源不会被解压)，可以访问网络资源，类似wget。</p> 
<pre><code> ADD &lt;src&gt;... &lt;dest&gt;  
 ADD ["&lt;src&gt;",... "&lt;dest&gt;"] 用于支持包含空格的路径示例：  
</code></pre> 
<blockquote> 
 <p>示例：</p> 
 <p>1、添加所有以"hom"开头的文件</p> 
 <pre><code>ADD hom* /mydir/ </code></pre> 
 <p>2、? 替代一个单字符,例如："home.txt"</p> 
 <pre><code>ADD hom?.txt /mydir/   
</code></pre> 
 <p>3、添加 "test" 到 WORKDIR/relativeDir/</p> 
 <pre><code>ADD test relativeDir
</code></pre> 
 <p>4、添加 "test" 到 /absoluteDir/</p> 
 <pre><code>ADD test /absoluteDir/
</code></pre> 
 <p></p> 
</blockquote> 
<h4 id="copy">COPY</h4> 
<p>功能类似ADD，但是是不会自动解压文件，也不能访问网络资源。</p> 
<pre><code>COPY &lt;源路径&gt;  &lt;目标路径&gt;
</code></pre> 
<h4 id="cmd">CMD</h4> 
<p>构建容器后调用，也就是在容器启动时才进行调用。指定这个容器启动的时候要运行的命令只有最后一个会生效可被替换。</p> 
<pre><code>CMD指令与RUN指令相似，也具有两种格式：
1. shell格式：CMD &lt;命令&gt;
2. exec格式： CMD ["可执行文件", "参数1", "参数2", …]
</code></pre> 
<blockquote> 
 <p>注意： CMD不同于RUN，CMD用于指定在容器启动时所要执行的命令，而RUN用于指定镜像构建时所要执行的命令。</p> 
</blockquote> 
<p></p> 
<h3>5.4  常见的13种指令下</h3> 
<p class="img-center"><img alt="" height="400" src="https://images2.imgbox.com/95/a4/regJWAzK_o.png" width="1027"></p> 
<p></p> 
<h4 id="entrypoint">ENTRYPOINT</h4> 
<p>配置容器，使其可执行化。配合CMD可省去"application"，只使用参数。</p> 
<p>指定容器启动的要运行的命令，可以追加命令</p> 
<pre><code>ENTRYPOINT ["executable", "param1", "param2"] 
ENTRYPOINT command param1 param2 (shell内部命令)
</code></pre> 
<p>示例：</p> 
<pre><code>ENTRYPOINT ["top", "-b"]
</code></pre> 
<blockquote> 
 <p><strong>注意：</strong></p> 
 <p>ENTRYPOINT与CMD非常类似，不同的是通过docker run执行的命令不会覆盖ENTRYPOINT，而docker run命令中指定的任何参数，都会被当做参数再次传递给ENTRYPOINT。Dockerfile中只允许有一个ENTRYPOINT命令，多指定时会覆盖前面的设置，而只执行最后的ENTRYPOINT指令。</p> 
</blockquote> 
<h4 id="env">ENV</h4> 
<p>这个指令非常简单，就是用于设置环境变量而已，无论是接下来的指令，还是在容器中运行的程序，都可以使用这里定义的环境变量。</p> 
<pre><code>ENV &lt;key&gt;=&lt;value&gt;
</code></pre> 
<p>示例：</p> 
<pre><code>ENV JAVA_HOME=/usr/local/jdk1.7.0_79
ENV PATH=$JAVA_HOME/bin:$PATH
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/94629c8b3d634cda703c6c51679512fd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">OpenCV Mat类基本操作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4a8dcc0936480a07ed965d934bd70325/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux操作系统下图书管理系统的实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>