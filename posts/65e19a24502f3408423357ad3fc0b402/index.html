<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【嵌入式学习笔记-02】什么是库文件，静态库的制作和使用，动态库的制作和使用，动态库的动态加载 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【嵌入式学习笔记-02】什么是库文件，静态库的制作和使用，动态库的制作和使用，动态库的动态加载" />
<meta property="og:description" content="【嵌入式学习笔记-02】什么是库文件，静态库的制作和使用，动态库的制作和使用，动态库的动态加载
文章目录 什么是库文件？编程模型的发展什么是库文件？ 静态库的制作和使用动态库的制作和使用动态库的动态加载 什么是库文件？ 编程模型的发展 单一模型： 将程序中所有功能全部实现于一个单一的源文件内部。编译时间长，不易于维护和升级不易于协作开发。 分离模型 将程序中的不同功能模块划分到不同的源文件中。缩短编译时间，易于维护和升级，易于协作开发。 对多个目标文件的管理比较麻烦 将多个目标文件统一整理合成为一个文件便于使用和管理，于是就有了库文件。 什么是库文件？ 为何要把一个程序分成多个源文件，并由每个源文件编译生成独立的目标文件? 化整为零、易于维护、便于协作。 为何要把多个目标文件合并成一个库文件? 集零为整、方便使用、易于复用。 可以简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类。 库文件一般指计算机上的一类文件，分两种，一种是静态库，另一种是动态库。 静态库的制作和使用 静态库的本质就是将多个目标文件打包成一个文件
链接静态库的过程就是将库中被调用的代码复制到调用模块中
静态库的拓展名是 .a 例: libxxx.a
以构建数学库为例，静态库的构建顺序如下：
1、编辑库的实现代码和接口声明：
计算模块：calc.h、calc.c
显示模块：show.h、show.c
接口文件：math.h
2、编译成目标文件
gcc -c calc.c
gcc -c show.c
3、打包成静态库
ar -r libmath.a calc.o show.o
ar 命令
ar[选项] &lt;静态库文件&gt; &lt;目标文件列表&gt;
-r 将目标插入到静态库中，已存在则更新
-q 将目标文件追加到静态库尾
-d 从静态库中删除目标文件
-t 列表显示静态库中的目标文件
-x 将静态库展开为目标文件 编辑库的使用代码
main.c 编译并链接静态库
直接链接静态库
gcc main.c libmath.a
用-l指定库名，用-L指定库路径
gcc mian.c -lmath -L." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/65e19a24502f3408423357ad3fc0b402/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-15T22:06:48+08:00" />
<meta property="article:modified_time" content="2024-01-15T22:06:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【嵌入式学习笔记-02】什么是库文件，静态库的制作和使用，动态库的制作和使用，动态库的动态加载</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><em><strong>【嵌入式学习笔记-02】什么是库文件，静态库的制作和使用，动态库的制作和使用，动态库的动态加载</strong></em></p> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_3" rel="nofollow">什么是库文件？</a></li><li><ul><li><a href="#_5" rel="nofollow">编程模型的发展</a></li><li><a href="#_22" rel="nofollow">什么是库文件？</a></li></ul> 
  </li><li><a href="#_31" rel="nofollow">静态库的制作和使用</a></li><li><a href="#_92" rel="nofollow">动态库的制作和使用</a></li><li><a href="#_148" rel="nofollow">动态库的动态加载</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_3"></a>什么是库文件？</h2> 
<h3><a id="_5"></a>编程模型的发展</h3> 
<ul><li>单一模型： 
  <ul><li>将程序中所有功能全部实现于一个单一的源文件内部。编译时间长，不易于维护和升级不易于协作开发。</li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/78/09/F1Km8rzF_o.png" alt="image-20240103204445924"></p> 
<ul><li>分离模型 
  <ul><li>将程序中的不同功能模块划分到不同的源文件中。缩短编译时间，易于维护和升级，易于协作开发。</li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/23/7c/VFYREQ7P_o.png" alt="image-20240103204611398"></p> 
<ul><li>对多个目标文件的管理比较麻烦 
  <ul><li>将多个目标文件统一整理合成为一个文件便于使用和管理，于是就有了库文件。</li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/6f/58/O4UL8TR3_o.png" alt="image-20240103204735103"></p> 
<h3><a id="_22"></a>什么是库文件？</h3> 
<ul><li>为何要把一个程序分成多个源文件，并由每个源文件编译生成独立的目标文件? 
  <ul><li>化整为零、易于维护、便于协作。</li></ul> </li><li>为何要把多个目标文件合并成一个库文件? 
  <ul><li>集零为整、方便使用、易于复用。</li></ul> </li><li>可以简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量、函数或类。 
  <ul><li>库文件一般指计算机上的一类文件，分两种，一种是静态库，另一种是动态库。</li></ul> </li></ul> 
<h2><a id="_31"></a>静态库的制作和使用</h2> 
<ul><li> <p>静态库的本质就是将多个目标文件打包成一个文件</p> </li><li> <p>链接静态库的过程就是将库中被调用的代码复制到调用模块中</p> </li><li> <p>静态库的拓展名是 .a 例: libxxx.a</p> <p><img src="https://images2.imgbox.com/6f/cb/2ZMRkujA_o.png" alt="image-20240107221233826"></p> </li><li> <p>以构建数学库为例，静态库的构建顺序如下：</p> 
  <ul><li> <p>1、编辑库的实现代码和接口声明：</p> <p>计算模块：calc.h、calc.c</p> <p>显示模块：show.h、show.c</p> <p>接口文件：math.h</p> </li><li> <p>2、编译成目标文件</p> <p><code>gcc -c calc.c</code></p> <p><code>gcc -c show.c</code></p> </li><li> <p>3、打包成静态库</p> <p>ar -r libmath.a calc.o show.o</p> </li></ul> </li><li> <p>ar 命令</p> 
  <ul><li><code>ar[选项] &lt;静态库文件&gt; &lt;目标文件列表&gt;</code><br> -r 将目标插入到静态库中，已存在则更新<br> -q 将目标文件追加到静态库尾<br> -d 从静态库中删除目标文件<br> -t 列表显示静态库中的目标文件<br> -x 将静态库展开为目标文件</li></ul> </li><li> <p>编辑库的使用代码</p> 
  <ul><li>main.c</li></ul> </li><li> <p>编译并链接静态库</p> 
  <ul><li> <p>直接链接静态库</p> <p><code>gcc main.c libmath.a</code></p> </li><li> <p>用-l指定库名，用-L指定库路径</p> <p><code>gcc mian.c -lmath -L.</code></p> </li></ul> </li><li> <p>用-l指定库名，用LIBRARY PATH环境变量指定库路径</p> 
  <ul><li> <p>export LIBRARY PATH=$LIBRARY_PATH:</p> </li><li> <p>gcc main.c -lmath</p> </li></ul> </li></ul> 
<h2><a id="_92"></a>动态库的制作和使用</h2> 
<ul><li>动态库和静态库不同，链接动态库不需要将被调用的函数代码复制到包含调用代码的可执行文件中，相反链接器会在调用语句处嵌入一段指令，在该程序执行到这段指令时，会加载该动态库并寻找被调用函数的入口地址并执行之。</li><li>如果动态库中的代码同时为多个进程所用，动态库在内存的实例仅需一份，为所有使用该库的进程所共享，因此动态库亦称共享库。</li><li>动态库的拓展名是 .so 例如libxxx.so。</li><li>链接动态库过程</li></ul> 
<p><img src="https://images2.imgbox.com/1f/3b/XZ8sKnKo_o.png" alt="image-20240110213858364"></p> 
<ul><li> <p>以构建数学库为例，动态库的构建顺序如下：</p> 
  <ul><li>1、编辑库的实现代码和接口声明：<br> 计算模块: calc.h、calc.c<br> 显示模块: show.h、show.c<br> 接口文件: math.h</li><li>2、编译成目标文件<br> <code>gcc -c -fpic calc.c</code><br> <code>gcc -c -fpic show.c</code></li><li>3、打包成动态库<br> <code>gcc -shared calc.o show.o -o libmath.so</code></li></ul> </li><li> <p>编译链接也可以合并成一步完成。</p> 
  <ul><li><code>gcc -shared -fpic calc.c show.c -o libmath.so</code></li></ul> </li><li> <p>PIC(Position Independent Code，位置无关代码)。</p> 
  <ul><li>调用代码通过相对地址标识调用代码的位置，模块中的指令与该模块被加载到内存中的位置无关</li></ul> </li><li> <p>-fPIC:大模式，生成代码比较大，运行速度比较慢，所有平台都支持</p> </li><li> <p>-fpic:小模式，生成代码比较小，运行速度比较快，仅部分平台支持</p> </li><li> <p>编辑库的使用代码</p> 
  <ul><li>main.c</li></ul> </li><li> <p>编译并链接动态库</p> 
  <ul><li> <p>直接链接动态库</p> <p>`gcc main.c libmath.so</p> </li><li> <p>用-l指定库名，用-L指定库路径</p> <p><code>gcc mian.c -lmath -L.</code></p> </li></ul> </li><li> <p>用-l指定库名，用LIBRARY PATH环境变量指定库路径</p> 
  <ul><li>export LIBRARY PATH=$LIBRARY_PATH:</li><li>gcc main.c -lmath</li></ul> </li><li> <p>运行时需要保证LD LIBRARY PATH环境变量中包含共享库所在的路径用以告知链接器在运行时链接动态。</p> 
  <ul><li>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.</li></ul> </li><li> <p>在可执行程序的链接阶段，并不将所调用函数的二进制代码复制到可执行程序中，而只是将该函数在共享库中的地址嵌入到调用模块中，因此运行时需要依赖共享库。</p> </li></ul> 
<h2><a id="_148"></a>动态库的动态加载</h2> 
<ul><li> <p>在程序执行的过程中，开发人员可以动态加载共享库 (什么时候用什么时候加载)，这样可以提高内存的利用效率。</p> </li><li> <p>在程序中动态加载共享库需要调用一组特殊的函数，它们被声明于一个专门的头文件中，并在一个独立的库中予以实现。</p> </li><li> <p>使用这组函数需要包含此头文件，并链接该库</p> 
  <ul><li>#include&lt;dlfcn.h&gt;</li><li>-ldl</li></ul> </li><li> <p><code>void* dlopen(char const* filename, int flag)</code></p> 
  <ul><li> <p>功能:将共享库载入内存并获得其访问句柄</p> </li><li> <p>参数:</p> <p>filename 动态库路径，若只给文件名不带目录，则根据LD LIBRARY PATH环境变量的值搜索动态库</p> <p>flag 加载方式，可取以下值<br> RTLD LAZY - 延迟加载，使用动态库中的符号时才真的加载进内存。</p> <p>​ RTLD NOW - 立即加载。</p> </li><li> <p>返回值: 成功返回动态库的访问句柄，失败返回NULL。</p> </li><li> <p>句柄: 句柄唯一地标识了系统内核所维护的共享库对象，将作为后续函数调用的参数</p> </li></ul> </li><li> <p><code>void* dlsym(void* handle, char const* symbol);</code></p> 
  <ul><li> <p>功能:从已被加载的动态库中获取特定名称的符号地址</p> </li><li> <p>参数: handle 动态库访问句柄</p> <p>​ symbol 符号名</p> </li><li> <p>返回值: 成功返回给定符号的地址，失败返回NULL。</p> </li><li> <p>该函数所返回的指针为void*类型，需要造型为与实际目标类型相一致的指针，才能使用。</p> </li></ul> </li><li> <p><code>int dlclose(void* handle)</code></p> 
  <ul><li>功能:从内存中卸载动态库</li><li>参数: handle 动态库句柄</li><li>返回值: 返回值: 成功返回0,失败返回非0.</li><li>所卸载的共享库未必会真的从内存中立即消失，因为其他程序可能还需要使用该库</li><li>只有所有使用该库的程序都显示或隐式地卸载了该库，该库所占用的内存空间才会真正得到释放</li><li>无论所卸载的共享库是否真正被释放，传递给dlclose函数的句柄都会在该函数成功返回后立即失效</li></ul> </li><li> <p><code>char* dlerror(void)</code></p> 
  <ul><li>功能:获取在加载、使用和卸载共享库过程中所发生的错误</li><li>返回值: 有错误则返回指向错误信息字符串的指针，否则返回NULL。</li></ul> </li><li> <p>辅助工具</p> 
  <ul><li> <p>查看符号表: nm</p> 
    <ul><li>列出目标文件、可执行程序、静态库、或共享库中的符号</li><li>例: nm libmath.a</li></ul> </li><li> <p>查看依赖: ldd</p> 
    <ul><li>查看可执行文件或者共享库所依赖的共享库</li><li>例: ldd a.out</li></ul> </li></ul> </li></ul> 
<p>加载、使用和卸载共享库过程中所发生的错误</p> 
<ul><li> <p>返回值: 有错误则返回指向错误信息字符串的指针，否则返回NULL。</p> </li><li> <p>辅助工具</p> 
  <ul><li> <p>查看符号表: nm</p> 
    <ul><li>列出目标文件、可执行程序、静态库、或共享库中的符号</li><li>例: nm libmath.a</li></ul> </li><li> <p>查看依赖: ldd</p> 
    <ul><li>查看可执行文件或者共享库所依赖的共享库</li><li>例: ldd a.out</li></ul> </li></ul> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d1a9e5de0456e21be170475cf8cd4cc7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">企业网 SSL VPN 史诗级配置-华为ensp毕设实验</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/313cdd86320891a9ed3fca27451491ec/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Go语言学习1-基础入门</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>