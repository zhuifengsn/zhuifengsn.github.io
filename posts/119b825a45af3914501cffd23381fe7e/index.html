<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构实验 实验二 一元多项式相加 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构实验 实验二 一元多项式相加" />
<meta property="og:description" content="一、【实验目的】
1、了解链式存储结构的基本知识；
2、掌握算法思想和数据结构的描述；
3、结合一元多项式相加的运算规则。
二、【实验内容】
结合书上第41页的例子，采用链式存储结构，将两个线性链表表示的一元多项式相加，并输出。此一元多项式遵循多项式相加运算规则：对于两个一元多项式中存在指数相同的项时，其对应系数相加。合并后系数和为零时，删除“和多项式”中此项；合并后系数和不为零时，则构成“和多项式”中的一项。对于两个一元多项式中存在的指数不相同的项，则分别复抄到“和多项式”中去，原多项式保持不变。
三、【实验步骤与要求】
1、实验前的准备
（1）了解C语言的基本概念；
（2）了解C语言的基本段落。
2、上机操作
（1）了解链式存储结构的基本知识；
（2）掌握算法思想和数据结构的描述；
（3）掌握一元多项式相加的运算规则。
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define INFEASIBLE -1 #define OVERFLOW -2 #define LIST_INIT_SIZE 100 typedef int Status; //Status是函数的类型，其值是函数结果代码 struct node{ //项结点 float coeff; //系数coefficient int expn; //指数exponent }; typedef struct Polynomial{ //多项式 struct node elem; //多项式元素 struct Polynomial *next; //指向下一个多项式的结构体指针 }*PolyList; //创建一元多项式链表 void CreatePolyn(PolyList *ha,int n) { float coe; //coe表示系数 int exp; //x2表示指数 PolyList p; //创建临时多项式链表 *ha=NULL; //首先为空时ha指向空 while(n--){ scanf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/119b825a45af3914501cffd23381fe7e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-02-27T10:18:40+08:00" />
<meta property="article:modified_time" content="2019-02-27T10:18:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构实验 实验二 一元多项式相加</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0cm;"><strong>一、【实验目的】</strong></p> 
<p style="margin-left:0cm;">1、了解链式存储结构的基本知识；</p> 
<p style="margin-left:0cm;">2、掌握算法思想和数据结构的描述；</p> 
<p style="margin-left:0cm;">3、结合一元多项式相加的运算规则。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong>二、【实验内容】</strong></p> 
<p style="margin-left:0cm;">结合书上第41页的例子，采用链式存储结构，将两个线性链表表示的一元多项式相加，并输出。此一元多项式遵循多项式相加运算规则：对于两个一元多项式中存在指数相同的项时，其对应系数相加。合并后系数和为零时，删除“和多项式”中此项；合并后系数和不为零时，则构成“和多项式”中的一项。对于两个一元多项式中存在的指数不相同的项，则分别复抄到“和多项式”中去，原多项式保持不变。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"><strong>三、【实验步骤与要求】</strong></p> 
<p style="margin-left:0cm;">1、实验前的准备</p> 
<p style="margin-left:0cm;">（1）了解C语言的基本概念；</p> 
<p style="margin-left:0cm;">（2）了解C语言的基本段落。</p> 
<p style="margin-left:0cm;">2、上机操作</p> 
<p style="margin-left:0cm;">（1）了解链式存储结构的基本知识；</p> 
<p style="margin-left:0cm;">（2）掌握算法思想和数据结构的描述；</p> 
<p style="margin-left:0cm;">（3）掌握一元多项式相加的运算规则。</p> 
<p style="margin-left:0cm;"> </p> 
<pre class="has"><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#define TRUE            1
#define FALSE           0
#define OK              1
#define ERROR           0
#define INFEASIBLE      -1
#define OVERFLOW        -2
#define LIST_INIT_SIZE  100
typedef int Status;         //Status是函数的类型，其值是函数结果代码
struct node{            //项结点
    float   coeff;      //系数coefficient
    int     expn;       //指数exponent
};

typedef struct Polynomial{      //多项式
    struct node  elem;          //多项式元素
    struct Polynomial *next;    //指向下一个多项式的结构体指针
}*PolyList;

//创建一元多项式链表
void CreatePolyn(PolyList *ha,int n)
{
    float coe;          //coe表示系数
    int   exp;          //x2表示指数
    PolyList p;         //创建临时多项式链表
    *ha=NULL;           //首先为空时ha指向空

    while(n--){
        scanf("%f%d",&amp;coe,&amp;exp);
        p=(PolyList)malloc(sizeof(struct Polynomial));  //创建多项式
        p-&gt;elem.coeff=coe;                              //赋值新项的系数
        p-&gt;elem.expn=exp;                               //赋值新项的指数
        p-&gt;next=*ha;        //新项p指向*ha项，链的建立
        *ha=p;              //指针的赋值，使得*ha始终指向新创建的项
    }
}

//输出一元多项式
void ShowSqList(PolyList ha)
{
    if(ha==NULL)
        printf("F(x)=0");
    else
    {
        printf("多项式F(x)=%.0fX^(%d)",ha-&gt;elem.coeff,ha-&gt;elem.expn);
        ha=ha-&gt;next;    //下一个
        while(ha!=NULL)
        {
            if(ha-&gt;elem.coeff&gt;0)
                printf("+");
            printf("%.0fX^(%d)",ha-&gt;elem.coeff,ha-&gt;elem.expn);
            ha=ha-&gt;next;//下一个
        }
    }
    printf("\n");
}

//冒泡排序链表
void SortPolyn(PolyList head,int n)
{
    int i,j;
    struct node temp;   //建立临时比较项变量
    PolyList p1,p2;     //用两个差位多项式指针比较前后指数大小
    for(p1=head,i=0;i&lt;n-1;i++,p1=p1-&gt;next)
        for(p2=p1-&gt;next,j=0;j&lt;n-i-1;j++,p2=p2-&gt;next)
            if(p1-&gt;elem.expn &lt; p2-&gt;elem.expn) //按指数从大到小排序
            {
                temp=p2-&gt;elem;                //交换项元素，指针遍历不动
                p2-&gt;elem=p1-&gt;elem;
                p1-&gt;elem=temp;
            }
}

//多项式相加
PolyList add(PolyList ha,PolyList hb)   //对已排序的多项式ha,hb进行相加
{
    int t=0;            //t为系数和
    int polynsize=0;    //hc总项数
    PolyList p,hc=NULL; //多项式p,hc hc为返回值
    while(ha&amp;&amp;hb)       //ha,hb同时不为空
    {
    if(ha-&gt;elem.expn==hb-&gt;elem.expn)
    {//两指数相同时，系数相加
        t=ha-&gt;elem.coeff+hb-&gt;elem.coeff;
        if(t)
        {//系数和不为零，则插入和多项式hc链表中
            p=(PolyList)malloc(sizeof(struct Polynomial));  //新建项
            p-&gt;elem.coeff=t;            //把系数和赋给新项系数p-&gt;elem.coeff
            p-&gt;elem.expn=ha-&gt;elem.expn; //把指数赋给新项指数p-&gt;elem.expn
            p-&gt;next=hc;                 //新项p指向hc项，链的建立
            hc=p;                       //指针的赋值，使hc始终指向新创建的项

            ha=ha-&gt;next;        //遍历ha的单次操作
            hb=hb-&gt;next;        //遍历hb的单次操作
            polynsize++;    //完成本次后hc总项数++
        }
        else
        {//系数和为零，则ha、hb结点后移
            ha=ha-&gt;next;    //遍历ha的单次操作
            hb=hb-&gt;next;    //遍历hb的单次操作
        }
    }
    else if(ha-&gt;elem.expn&gt;hb-&gt;elem.expn)
    {//ha的指数大则先行插入hc
        p=(PolyList)malloc(sizeof(struct Polynomial));  //新建项
        p-&gt;elem=ha-&gt;elem;   //把ha项元素赋给新项
        p-&gt;next=hc;         //新项p指向hc项，链的建立
        hc=p;               //指针的赋值，使得hc始终指向新创建的项

        ha=ha-&gt;next;    //遍历ha的单次操作
        polynsize++;    //完成本次后hc总项数++
    }
    else
    {//hb的指数大则先行插入hc
        p=(PolyList)malloc(sizeof(struct Polynomial));
        p-&gt;elem=hb-&gt;elem;   //把ha项元素赋给新项
        p-&gt;next=hc;         //新项p指向hc项，链的建立
        hc=p;               //指针的赋值，使得hc始终指向新创建的项

        hb=hb-&gt;next;    //遍历hb的单次操作
        polynsize++;    //完成本次后hc总项数++
    }
    }
    while(ha)
    {//ha不为空，则将当前ha剩余项全部插入hc
        p=(PolyList)malloc(sizeof(struct Polynomial));  //新建项
        p-&gt;elem=ha-&gt;elem;   //把ha项元素赋给新项
        p-&gt;next=hc;         //新项p指向hc项，链的建立
        hc=p;               //指针的赋值，使得hc始终指向新创建的项

        ha=ha-&gt;next;    //遍历ha的单次操作
        polynsize++;    //完成本次后hc总项数++
    }
    while(hb)
    {//hb不为空，则将当前hb剩余项全部插入hc
    p=(PolyList)malloc(sizeof(struct Polynomial));      //新建项
    p-&gt;elem=hb-&gt;elem;       //把hb项元素赋给新项
    p-&gt;next=hc;             //新项p指向hc项，链的建立
    hc=p;                   //指针的赋值，使得hc始终指向新创建的项

    hb=hb-&gt;next;        //遍历ha的单次操作
    polynsize++;        //完成本次后hc总项数++
    }
    SortPolyn(hc,polynsize);//排序hc
return hc;
}

int main ()
{
    PolyList ha,hb,hc;      //多项式ha,hb,hc
    int m,n;                //多项式ha,hb的项数

    scanf("%d",&amp;m);CreatePolyn(&amp;ha,m);      //输入并创建ha
    scanf("%d",&amp;n);CreatePolyn(&amp;hb,n);      //输入并创建hb
    printf("\n");

    printf("原始两个多项式\n");             //输出原始多项式
    ShowSqList(ha);ShowSqList(hb);          //后入先出
    printf("\n");

    SortPolyn(ha,m);SortPolyn(hb,n);    //排序ha,hb
    printf("按指数从高到低排序后两个多项式\n");
    ShowSqList(ha);ShowSqList(hb);
    printf("\n");

    hc=add(ha,hb);                  //多项式相加
    printf("和多项式\n");
    ShowSqList(hc);                 //输出和多项式hc
    printf("两个多项式\n");
    ShowSqList(ha);ShowSqList(hb);  //输出原多项式(已排序)
return 0;
}

/*
测试数据
第一行ha的项数
第二行为第i项对应系数与指数,i++,i从1开始
第三行hb的项数
第四行为第i项对应系数与指数,i++,i从1开始
3
1 3 2 2 4 1
4
2 2 5 1 -1 3 6 6
*/
</code></pre> 
<p style="margin-left:0cm;"> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/38ed742f2a54d412acee2d2025e2a9d9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SQL函数之聚合函数（求和，平均值，最大值，最小值，统计，取不重，取重）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d39670f9d5d01e56af4477592893b526/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构实验 实验3 二叉树的遍历</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>