<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构——栈 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构——栈" />
<meta property="og:description" content="栈的概念 栈：是一个种特殊的线性表，只允许在固定的一端进行插入与删除元素的操作。在进行数据插入一端称为栈顶，进行删除操作的另一端成称栈底。栈中不含任何数据元素的时候称为空栈。栈中的元素遵守后进先出的原则。也叫先进后出。
举个例子：栈在我们的生活中的应用是经常见到的。我们大家在小时候应该都会玩过玩具枪，玩具枪里面的弹夹大家都不陌生吧，一颗一颗的子弹压入弹夹中，最后压入的子弹是最先被发射出来的。
在软件应用中，也是非常普遍的。比如我们在用浏览器浏览东西时，不管什么浏览器都会有一个“返回键”，点击后会按照你访问的顺序逆序后退。有时候我们在浏览一些东西的时候会弹出一个弹窗，一不小心点了进去，一看“性感女优，在线发牌”，顿时慌了起来千万不能被看到，粉身碎骨浑不怕，要留清白在人间。赶忙狂点返回键，这才留住了“清白”。
栈是一个特殊的线性表，只能在栈顶进行数据插入以及删除，特殊之处在于它限制了这个线性表的插入和删除位置，它始终只能在栈顶进行。
栈的插入操作叫做进栈，也称压栈、入栈。如同子弹一般一颗一颗压入弹夹中。
栈的删除操作叫做出栈，也称弹栈。如同弹出弹夹中的子弹。 进栈出栈变化形式 想一下，最先进栈的元素是不是就只能最后出栈呢？
是不一定的。要看是什么情况。栈对线性表的插入和删除的位置进行了限制，但没有对出栈入栈的时间进行限制。所以说并不是得所有元素都入栈了才可以出栈，可以进一个出一个也可以进多个再依次都出，但切记不能越级出。
这里有道题大家可以拿来练练手。
若进栈序列为 1,2,3,4 ，进栈过程中可以出栈，则下列不可能的一个出栈序列是（）
A 1,4,3,2
B 2,3,4,1
C 3,1,4,2
D 3,4,2,1
A选项：1入栈就出栈，接着2、3、4依次入栈，4出，3出，2出，出栈次序是：1,4,3,2。
B选项：1、2入栈，2出栈。3入栈再出栈，4入栈再出栈，最后栈中只剩下1出栈，出栈次序是：2,3,4,1。
D选项：1、2、3入栈，3出栈，4入栈再出栈，最后栈中剩下1、2。2出，1出， 出栈次序是：3,4,2,1。
而C选项：1、2、3入栈，3出了但栈中还有1、2。2是在栈顶，应先出的是2，1是在栈底，如果先出1的话就越级了。
因此这道题应该是选 C。通过这道题我们要知道栈中元素的入栈出栈操作只能在栈顶位置执行。
栈的各个接口实现： 栈的实现一般可以使用数组或者链表来实现的，相对而言使用数组的结构来实现的话会更优一点。因为数组在尾上插入删除数据的代价比较小。如果使用链表的话，首先就得遍历找到尾再进行插入或删除的操作。数组是支持下标随机访问的。
typedef int STDataType; //根据要存入的数据类型而修改 typedef struct Stack { STDataType* data;	int top;	//栈顶	int capacity;	//容量 }Stack; 栈的初始化 //初始化 void StackInit(Stack*ps) { assert(ps); ps-&gt;data = (STDataType*)malloc(sizeof(STDataType)* 3);	ps-&gt;capacity = 3; ps-&gt;top = 0; } 入栈 //入栈 void StackPush(Stack*ps,STDataType x) { assert(ps); if (ps-&gt;capacity == ps-&gt;top)	//相等表示容量不足需扩容 { STDataType* newp = (STDataType*)realloc(ps-&gt;data, sizeof(STDataType)*(ps-&gt;capacity &#43; 3)); if (newp == NULL) { printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/af4855acd8d3f387423bdfb75f0f94bf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-07T11:59:50+08:00" />
<meta property="article:modified_time" content="2022-05-07T11:59:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构——栈</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>栈的概念</h2> 
<p>        栈：是一个种特殊的线性表，只允许在固定的一端进行插入与删除元素的操作。在进行数据插入一端称为栈顶，进行删除操作的另一端成称栈底。栈中不含任何数据元素的时候称为空栈。栈中的元素遵守后进先出的原则。也叫先进后出。</p> 
<p>        举个例子：栈在我们的生活中的应用是经常见到的。我们大家在小时候应该都会玩过玩具枪，玩具枪里面的弹夹大家都不陌生吧，一颗一颗的子弹压入弹夹中，最后压入的子弹是最先被发射出来的。</p> 
<p>        在软件应用中，也是非常普遍的。比如我们在用浏览器浏览东西时，不管什么浏览器都会有一个“返回键”，点击后会按照你访问的顺序逆序后退。有时候我们在浏览一些东西的时候会弹出一个弹窗，一不小心点了进去，一看“性感女优，在线发牌”，顿时慌了起来千万不能被看到，粉身碎骨浑不怕，要留清白在人间。赶忙狂点返回键，这才留住了“清白”。</p> 
<p>                                               <img alt="" height="208" src="https://images2.imgbox.com/86/7f/wwjmiahU_o.png" width="374"></p> 
<p>        栈是一个特殊的线性表，只能在栈顶进行数据插入以及删除，特殊之处在于它限制了这个线性表的插入和删除位置，它始终只能在栈顶进行。</p> 
<p>        栈的插入操作叫做进栈，也称压栈、入栈。如同子弹一般一颗一颗压入弹夹中。</p> 
<p>        栈的删除操作叫做出栈，也称弹栈。如同弹出弹夹中的子弹。     <img alt="" height="393" src="https://images2.imgbox.com/46/ff/jZSd75LK_o.png" width="698"></p> 
<h2> 进栈出栈变化形式</h2> 
<p>        想一下，最先进栈的元素是不是就只能最后出栈呢？</p> 
<p>        是不一定的。要看是什么情况。栈对线性表的插入和删除的位置进行了限制，但没有对出栈入栈的时间进行限制。所以说并不是得所有元素都入栈了才可以出栈，可以进一个出一个也可以进多个再依次都出，但切记不能越级出。</p> 
<p>        这里有道题大家可以拿来练练手。</p> 
<blockquote> 
 <p>若进栈序列为 1,2,3,4 ，进栈过程中可以出栈，则下列不可能的一个出栈序列是（）<br>  A 1,4,3,2<br>  B 2,3,4,1<br>  C 3,1,4,2<br>  D 3,4,2,1</p> 
</blockquote> 
<p>        A选项：1入栈就出栈，接着2、3、4依次入栈，4出，3出，2出，出栈次序是：1,4,3,2。</p> 
<p>        B选项：1、2入栈，2出栈。3入栈再出栈，4入栈再出栈，最后栈中只剩下1出栈，出栈次序是：2,3,4,1。</p> 
<p>        D选项：1、2、3入栈，3出栈，4入栈再出栈，最后栈中剩下1、2。2出，1出， 出栈次序是：3,4,2,1。</p> 
<p>        而C选项：1、2、3入栈，3出了但栈中还有1、2。2是在栈顶，应先出的是2，1是在栈底，如果先出1的话就越级了。</p> 
<p>        因此这道题应该是选 C。通过这道题我们要知道栈中元素的入栈出栈操作只能在栈顶位置执行。</p> 
<h2>栈的各个接口实现：</h2> 
<p>        栈的实现一般可以使用数组或者链表来实现的，相对而言使用数组的结构来实现的话会更优一点。因为数组在尾上插入删除数据的代价比较小。如果使用链表的话，首先就得遍历找到尾再进行插入或删除的操作。数组是支持下标随机访问的。</p> 
<p>        <img alt="" height="243" src="https://images2.imgbox.com/10/1a/Nc255Tpa_o.png" width="632"></p> 
<p></p> 
<pre><code>typedef int STDataType;    //根据要存入的数据类型而修改
typedef struct Stack
{
	STDataType* data;	
	int top;	//栈顶	
	int capacity;	//容量
}Stack;</code></pre> 
<h2>栈的初始化</h2> 
<pre><code>//初始化
void StackInit(Stack*ps)
{
	assert(ps);

	ps-&gt;data = (STDataType*)malloc(sizeof(STDataType)* 3);	
	ps-&gt;capacity = 3;
	ps-&gt;top = 0;
}</code></pre> 
<h2>入栈</h2> 
<pre><code>//入栈
void StackPush(Stack*ps,STDataType x)
{
	assert(ps);

	if (ps-&gt;capacity == ps-&gt;top)	//相等表示容量不足需扩容
	{
		STDataType* newp = (STDataType*)realloc(ps-&gt;data, sizeof(STDataType)*(ps-&gt;capacity + 3));
		if (newp == NULL)
		{
			printf("realloc Fail\n");
			exit(-1);
		}
		else
		{
			ps-&gt;data = newp;
			ps-&gt;capacity += 3;	//容量增加
		}
	}

	ps-&gt;data[ps-&gt;top] = x;	//要插入的元素放入栈顶
	ps-&gt;top++;
}</code></pre> 
<h2>出栈</h2> 
<pre><code>//出栈
void StackPop(Stack* ps)
{
	assert(ps);

	if (ps-&gt;top &gt; 0)	//栈顶大于0表示栈中还有元素
	{
		ps-&gt;top--;
	}
	else
	{
		printf("栈为空\n");
	}
}</code></pre> 
<h2>获取栈顶元素</h2> 
<p><img alt="" height="230" src="https://images2.imgbox.com/d2/30/xSom21Rh_o.png" width="645"></p> 
<pre><code>STDataType StackTop(Stack*ps)
{
	assert(ps);

	if (ps-&gt;top &gt; 0)
	{
		return ps-&gt;data[ps-&gt;top - 1];
	}

	//栈空返回-1
	return -1;
}
</code></pre> 
<h2>获取栈中元素个数</h2> 
<pre><code>//获取栈个数
int StackSize(Stack *ps)
{
	assert(ps);

	return ps-&gt;top;
}</code></pre> 
<h2>判断栈是否为空</h2> 
<p>        栈如果为空返回true，不为空返回false。</p> 
<pre><code>bool StackEmpty(Stack*ps)
{
	assert(ps);

	//栈顶等于0表示空，相反则不为空
	return ps-&gt;top == 0;
}</code></pre> 
<h2>销毁栈</h2> 
<pre><code>//销毁栈
void StackDestroy(Stack*ps)
{
	assert(ps);

	free(ps-&gt;data);
	ps-&gt;capacity = 0;
	ps-&gt;top = 0;
}</code></pre> 
<p>附加一个跟栈相关的编程题：<a class="link-info" href="https://blog.csdn.net/weixin_57525369/article/details/124626701?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22124626701%22%2C%22source%22%3A%22weixin_57525369%22%7D&amp;ctrtid=ymfU4" title="有效的括号">有效的括号</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/62bcbb29a9f6685df2b0e3d1af53fff5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">nfs-kernel-server服务启动失败解决</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4dcd98323496289ee650c411813d32a0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">自然语言处理—RNN循环神经网络</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>