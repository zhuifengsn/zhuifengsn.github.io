<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>linux应用程序地址分布 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="linux应用程序地址分布" />
<meta property="og:description" content="学习linux时会经常遇到如下概念：代码段、数据段、BBS、堆、栈等，同时也会经常需要知道全局变量、局部变量有是怎么存放。本文的作用就是阐述自己对这些概念的认识。
先来说明linux中内存的分布情况和各个字段的作用，如下图所示是linux中内存中个组成部分示意图：
Text：代码段，这一部分存储的是CPU执行的机器指令，这部分是共享的，也就是在存储中只会存在一份该正文段。同时，该段需要满足可执行和只读性，这样可以防止程序遭到意外的修改。
Data：初始化数据段，这一部分存储全局作用域中明确赋初值的变量。
BBS：未初始化数据段，存放全局作用域中没有明确赋初值的变量，在程序开始执行之前，内核会将这段中数据初始化为0或者空指针。
Heap：堆，用于动态存储的分配，是从低地址到高地址。什么叫动态存储？动态存储就是变量空间大小会随程序变化、创建和消失。这一部分相关操作函数有：malloc/calloc/realloc/free
Stack：栈，用于存放局部变量已经函数执行时所需要保存的信息。每次函数调用都会创建一个新的栈帧，因此每个函数调用的过程都是单独，这也是为什么局部变量的范围只局限该函数或者改代码块的原因。栈的地址是从改地址向低地址方向增长。
代码区所在的地址空间最低，往上依次是Data区和BSS区，并且Data区和BSS区在内存中是紧挨着的。
其中，Text和Data段都是位于可执行的文件中，编译时已经分配了空间，启动程序时会从源文件中读入。而BBS段则不占用可执行文件的大小只包含BBS段的大小，然后链接器根据这个大小在数据段后面分配一块相应大小的内存空间，并在内存进入程序时全部清空为零。
下面通过程序距离来说明一下，程序如下：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int global_init_a = 1; //init global variable int global_uninit_a; //uninit global variable static int static_global_init_a = 1; //static init global variable static int static_global_uninit_a; //static uninit global variable const int const_global_a = 1; //const global variable char *global_p = &#34;abcd&#34;; //global pointer variable int main() { int local_init_a = 1; //init local variable int local_uninit_a; //uninit global variable static int static_local_init_a = 1; //static init local variable static int static_local_uninit_a; //static uninit local variable const int const_local_a = 1; //const local variable char *local_p = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/cafc034c5441ea3be614c657c01a3270/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-11-08T14:03:21+08:00" />
<meta property="article:modified_time" content="2016-11-08T14:03:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">linux应用程序地址分布</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>学习linux时会经常遇到如下概念：代码段、数据段、BBS、堆、栈等，同时也会经常需要知道全局变量、局部变量有是怎么存放。本文的作用就是阐述自己对这些概念的认识。</p> 
<p>先来说明linux中内存的分布情况和各个字段的作用，如下图所示是linux中内存中个组成部分示意图：</p> 
<p><img src="https://images2.imgbox.com/ff/a2/PbZTdTEe_o.png" alt=""><br> </p> 
<p>Text：代码段，这一部分存储的是CPU执行的机器指令，这部分是共享的，也就是在存储中只会存在一份该正文段。同时，该段需要满足可执行和只读性，这样可以防止程序遭到意外的修改。</p> 
<p>Data：初始化数据段，这一部分存储全局作用域中明确赋初值的变量。</p> 
<p>BBS：未初始化数据段，存放全局作用域中没有明确赋初值的变量，在程序开始执行之前，内核会将这段中数据初始化为0或者空指针。</p> 
<p>Heap：堆，用于动态存储的分配，是从低地址到高地址。什么叫动态存储？动态存储就是变量空间大小会随程序变化、创建和消失。这一部分相关操作函数有：malloc/calloc/realloc/free</p> 
<p>Stack：栈，用于存放局部变量已经函数执行时所需要保存的信息。每次函数调用都会创建一个新的栈帧，因此每个函数调用的过程都是单独，这也是为什么局部变量的范围只局限该函数或者改代码块的原因。栈的地址是从改地址向低地址方向增长。</p> 
<p><br> </p> 
<p>代码区所在的地址空间最低，往上依次是Data区和BSS区，并且Data区和BSS区在内存中是紧挨着的。<br> </p> 
<p><br> </p> 
<p>其中，Text和Data段都是位于可执行的文件中，编译时已经分配了空间，启动程序时会从源文件中读入。而BBS段则不占用可执行文件的大小只包含BBS段的大小，然后链接器根据这个大小在数据段后面分配一块相应大小的内存空间，并在内存进入程序时全部清空为零。</p> 
<p><br> </p> 
<p>下面通过程序距离来说明一下，程序如下：</p> 
<p></p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int global_init_a = 1; //init global variable
int global_uninit_a;  //uninit global variable
static int static_global_init_a = 1;  //static init global variable
static int static_global_uninit_a;  //static uninit global variable
const int const_global_a = 1;  //const global variable
char *global_p = "abcd";  //global pointer variable

int main()
{
    int local_init_a = 1;  //init local variable
    int local_uninit_a;  //uninit global variable
    static int static_local_init_a = 1;  //static init local variable
    static int static_local_uninit_a;  //static uninit local variable
    const int const_local_a = 1;  //const local variable
    char *local_p = "abcd";  //local pointer variable

    int *malloc_p_a;
    malloc_p_a = (int *)malloc(sizeof(int));  //heap
    
    printf("&amp;global_init_a = %p, global_init_a = %d\n", &amp;global_init_a, global_init_a);
    printf("&amp;global_uninit_a = %p, global_uninit_a = %d\n", &amp;global_uninit_a, global_uninit_a);
    printf("&amp;static_global_init_a = %p, static_global_init_a = %d\n", &amp;static_global_init_a, static_global_init_a);
    printf("&amp;static_global_uninit_a = %p, static_global_uninit_a = %d\n", &amp;static_global_uninit_a, static_global_uninit_a);
    printf("&amp;const_global_a = %p, const_global_a = %d\n", &amp;const_global_a, const_global_a);
    printf("&amp;global_p = %p, global_p = %p, *global_p = %s\n", &amp;global_p, global_p, global_p);

    printf("&amp;local_init_a = %p, local_init_a = %d\n", &amp;local_init_a, local_init_a);
    printf("&amp;local_uninit_a = %p, local_uninit_a = %d\n", &amp;local_uninit_a, local_uninit_a);
    printf("&amp;static_local_init_a = %p, static_local_init_a = %d\n", &amp;static_local_init_a, static_local_init_a);
    printf("&amp;static_local_uninit_a = %p, static_local_uninit_a = %d\n", &amp;static_local_uninit_a, static_local_uninit_a);
    printf("&amp;const_local_a = %p, const_local_a = %d\n", &amp;const_local_a, const_local_a);
    printf("&amp;local_p = %p, local_p = %p, *local_p = %s\n", &amp;local_p, local_p, local_p);
    
    printf("&amp;malloc_p_a = %p, malloc_p_a = %d\n", &amp;malloc_p_a, malloc_p_a);
    
    while(1)
        ;
    
    return 0;
}</code></pre> 
<p></p> 
<p>说明：程序末尾加上while（1）的循环的目的是保持程序一直在运行，这样就可以通过ps获取当前的实际内存映射情况。</p> 执行结果如下： 
<p><img src="https://images2.imgbox.com/f0/9d/X6J0Qspn_o.png" alt=""><br> 然后去获取当前程序和库文件在内存中的映射区域及访问权限：</p> 
<p><img src="https://images2.imgbox.com/06/4b/AfEUPES4_o.png" alt=""><br> </p> 
<p>由内存映射关系可知，只读和可执行数据区（Text&amp;Data）的地址范围是：08048000 - 08049000; 可读写数据区（Data和BBS）：08049000 - 0804a000; Heap: 08235000 - 08256000; Stack: bfb18000 - bfb2d000. 奇怪的是Text和Data以及Data和BBS合在一起，我们怎么确认那一部分是属于Text，那一部分属于Data，那一部分又属于BBS呢？</p> 
<p>下面我们通过读取section-headers的信息来具体确定Data和BBS的具体内存空间：</p> 
<p><img src="https://images2.imgbox.com/14/f3/p1bZpr5c_o.png" alt=""><br> </p> 
<p>有这部分信息可以知道：Text的空间是： 08048300 - 08048638，只读Data的空间是：08048654 - 080488DB，可读写Data的空间是：08049a4c - 08049a60(08049a4c(addr) + 14(size)), BBS的空间是：08049a60 - 08049a74, 其中off表示该段数据在整个Data空间的起始偏移量，例如：08049a4c = 08049000 + 000a4c。</p> 
<p>具体地址空间如下：</p> 
<p>Text: 08048300 - 08048638</p> 
<p>Rodata(Read only data, Data的一种): 08048654 - 080488DB</p> 
<p>Data(可读可写Data): 08049a4c - 08049a60</p> 
<p>BBS: 08049a60 - 08049a74</p> 
<p>Heap: 08235000 - 08256000</p> 
<p>Stack: bfb18000 - bfb2d000</p> 
<p>下面我们根据执行结果来确认一下各个变量都在什么区域：</p> 
<p><img src="https://images2.imgbox.com/3e/84/MvUHbxCp_o.png" alt=""><br> </p> 
<p>总结如下：</p> 
<p>read only data: 存放全局常量和字符串常量</p> 
<p>data：存放初始化的全局变量和初始化的静态变量（全局和局部）</p> 
<p>bbs：存放未初始化的全局变量和静态变量（全局和局部）</p> 
<p>stack: 局部变量（初始化和未初始化的，但不包含静态变量）以及局部只读变量</p> 
<p>heap: 动态分配的内存</p> 
<p><br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/847249eed3f277467e271b39441d2fed/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HBuilder从下载到使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3ab39a4f1c2518c65eda1443a61e921b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">常量指针和指针常量</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>