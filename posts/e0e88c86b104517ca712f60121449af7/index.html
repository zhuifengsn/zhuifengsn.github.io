<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux驱动入门 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux驱动入门" />
<meta property="og:description" content="Linux驱动入门 作者：齐波 更新时间：2005-04-14 内核版本: 2.4.22 阅读此文的目的: 学会编写Linux设备驱动。 阅读此文的方法: 阅读以下2个文件: hello.c,asdf.c。 此文假设读者: 已经能用C语言编写Linux应用程序, 理解&#34;字符设备文件, 块设备文件, 主设备号, 次设备号&#34;, 会写简单的Shell脚本和Makefile。 1. &#34;hello.c&#34; -------------------------------- /* * 这是我们的第一个源文件， * 它是一个可以加载的内核模块， * 加载时显示&#34;Hello,World!&#34;， * 卸载时显示&#34;Bye!&#34;。 * 需要说明一点，写内核或内核模块不能用写应用程序时的系统调用或函数库， * 因为我们写的就是为应用程序提供系统调用的代码。 * 内核有专用的函数库，如&lt;linux/kernel.h&gt;, &lt;linux/fs.h&gt;, &lt;linux/sche.h&gt;等, * 现在还没必要了解得很详细， * 这里用到的printk的功能类似于printf。 * &#34;/usr/src/linux&#34;是你实际的内核源码目录的一个符号链接， * 如果没有现在就创建一个,因为下面和以后都会用到。 * 编译它用&#34;gcc -c -I/usr/src/linux/include hello.c&#34;， * 如果正常会生成文件hello.o, * 加载它用&#34;insmod hello.o&#34;, * 只有在文本终端下才能看到输出。 * 卸载它用&#34;rmmod hello&#34; */ /* * 小技巧: 在用户目录的.bashrc里加上一行: * alias mkmod=&#39;gcc -c -I/usr/src/linux/include&#39; * 然后重新登陆Shell, * 以后就可以用&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/e0e88c86b104517ca712f60121449af7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2006-05-05T11:28:00+08:00" />
<meta property="article:modified_time" content="2006-05-05T11:28:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux驱动入门</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <table width="100%" cellspacing="0" cellpadding="0" border="0"><tbody><tr><td height="50" align="center" style="border-bottom: 1px dashed rgb(255, 153, 255);"><strong class="f16">Linux驱动入门</strong></td></tr><tr><td height="40" align="center"> 作者：齐波 更新时间：2005-04-14 </td><td rowspan="6" style="border-right: 1px solid rgb(255, 153, 255);"> </td></tr><tr><td height="40"> </td></tr><tr><td> 
    <table width="100%" cellspacing="0" cellpadding="0" border="0" class="pagefont"><tbody><tr><td style="padding-top: 5px;">内核版本: 2.4.22 <br> 阅读此文的目的: 学会编写Linux设备驱动。 <br> 阅读此文的方法: 阅读以下2个文件: hello.c,asdf.c。 <br> 此文假设读者: <br> 已经能用C语言编写Linux应用程序, <br> 理解"字符设备文件, 块设备文件, 主设备号, 次设备号", <br> 会写简单的Shell脚本和Makefile。 <br> <br> 1. "hello.c" <br> -------------------------------- <br> /* <br> * 这是我们的第一个源文件， <br> * 它是一个可以加载的内核模块， <br> * 加载时显示"Hello,World!"， <br> * 卸载时显示"Bye!"。 <br> <br> * 需要说明一点，写内核或内核模块不能用写应用程序时的系统调用或函数库， <br> * 因为我们写的就是为应用程序提供系统调用的代码。 <br> <br> * 内核有专用的函数库，如&lt;linux/kernel.h&gt;, &lt;linux/fs.h&gt;, &lt;linux/sche.h&gt;等, <br> * 现在还没必要了解得很详细， <br> * 这里用到的printk的功能类似于printf。 <br> <br> * "/usr/src/linux"是你实际的内核源码目录的一个符号链接， <br> * 如果没有现在就创建一个,因为下面和以后都会用到。 <br> <br> * 编译它用"gcc -c -I/usr/src/linux/include hello.c"， <br> * 如果正常会生成文件hello.o, <br> <br> * 加载它用"insmod hello.o", <br> * 只有在文本终端下才能看到输出。 <br> <br> * 卸载它用"rmmod hello" <br> */ <br> <br> /* <br> * 小技巧: 在用户目录的.bashrc里加上一行: <br> * alias mkmod='gcc -c -I/usr/src/linux/include' <br> * 然后重新登陆Shell, <br> * 以后就可以用"mkmod hello.c"的方式来编译内核模块了。 <br> */ <br> <br> /* 开始例行公事 */ <br> #ifndef __KERNEL__ <br> # define __KERNEL__ <br> #endif <br> #ifndef MODULE <br> # define MODULE <br> #endif <br> <br> #include &lt;linux/config.h&gt; <br> #include &lt;linux/module.h&gt; <br> <br> MODULE_LICENSE("GPL"); <br> #ifdef CONFIG_SMP <br> #define __SMP__ <br> #endif <br> /* 结束例行公事 */ <br> <br> #include &lt;linux/kernel.h&gt; /* printk()在这个文件里 */ <br> <br> static int <br> init_module <br> (){ <br> printk("Hello,World!/n"); <br> return 0; /* 如果初始工作失败，就返回非0 */ <br> } <br> <br> static void <br> cleanup_module <br> (){ <br> printk("Bye!/n"); <br> } <br> ------------------------------------ <br> <br> 2. "asdf.c" <br> ------------------------------------ <br> /* <br> * 这个文件是一个内核模块。 <br> * 内核模块的编译，加载和卸载在前面已经介绍了。 <br> <br> * 这个模块的功能是，创建一个字符设备。 <br> * 这个设备是一块4096字节的共享内存。 <br> * 内核分配的主设备号会在加载模块时显示。 <br> */ <br> <br> /* 开始例行公事 */ <br> #ifndef __KERNEL__ <br> # define __KERNEL__ <br> #endif <br> #ifndef MODULE <br> # define MODULE <br> #endif <br> <br> #include &lt;linux/config.h&gt; <br> #include &lt;linux/module.h&gt; <br> <br> #ifdef CONFIG_SMP <br> #define __SMP__ <br> #endif <br> MODULE_LICENSE("GPL"); <br> /* 结束例行公事 */ <br> <br> #include &lt;asm/uaccess.h&gt; /* copy_to_user(), copy_from_user */ <br> #include &lt;linux/fs.h&gt; /* struct file_operations, register_chrdev(), ... */ <br> #include &lt;linux/kernel.h&gt; /* printk()在这个文件里 */ <br> #include &lt;linux/sched.h&gt; /* 和任务调度有关 */ <br> #include &lt;linux/types.h&gt; /* u8, u16, u32 ... */ <br> <br> /* <br> * 关于内核功能库，可以去网上搜索详细资料， <br> */ <br> <br> /* 文件被操作时的回调功能 */ <br> static int asdf_open (struct inode *inode, struct file *filp); <br> static int asdf_release (struct inode *inode, struct file *filp); <br> static ssize_t asdf_read (struct file *filp, char *buf, size_t count,loff_t *f_pos); <br> static ssize_t asdf_write (struct file *filp, const char *buf, size_t count,loff_t *f_pos); <br> static loff_t asdf_lseek (struct file * file, loff_t offset, int orig); <br> <br> /* 申请主设备号时用的结构, 在linux/fs.h里定义 */ <br> struct file_operations asdf_fops = { <br> open: asdf_open, <br> release: asdf_release, <br> read: asdf_read, <br> write: asdf_write, <br> llseek: asdf_lseek, <br> }; <br> <br> static int asdf_major; /* 用来保存申请到的主设备号 */ <br> static u8 asdf_body[4096]="asdf_body/n"; /* 设备 */ <br> <br> static int <br> init_module <br> (){ <br> printk ("Hi, This' A Simple Device File!/n"); <br> asdf_major = register_chrdev (0, "A Simple Device File", &amp;asdf_fops); /* 申请字符设备的主设备号 */ <br> if (asdf_major &lt; 0) return asdf_major; /* 申请失败就直接返回错误编号 */ <br> printk ("The major is:%d/n", asdf_major); /* 显示申请到的主设备号 */ <br> return 0; /* 模块正常初始化 */ <br> } <br> <br> static void <br> cleanup_module <br> (){ <br> unregister_chrdev(asdf_major, "A Simple Device File"); /* 注销以后,设备就不存在了 */ <br> printk("A Simple Device has been removed,Bye!/n"); <br> } <br> <br> /* <br> * 编译这个模块然后加载它, <br> * 如果正常,会显示你的设备的主设备号。 <br> * 现在你的设备就建立好了,我们可以测试一下。 <br> * 假设你的模块申请到的主设备号是254, <br> * 运行"mknod abc c 254 0",就建立了我们的设备文件abc。 <br> * 可以把它当成一个4096字节的内存块来测试一下, <br> * 比如"cat abc", "cp abc image", "cp image abc", <br> * 或写几个应用程序用它来进行通讯。 <br> <br> * 介绍一下两个需要注意的事, <br> * 一是printk()的显示只有在非图形模式的终端下才能看到, <br> * 二是加载过的模块最好在不用以后卸载掉。 <br> <br> * 如果对Linux环境的系统调用很陌生,建议先看APUE这本书。 <br> */ <br> <br> static int <br> asdf_open /* open回调 */ <br> ( <br> struct inode *inode, <br> struct file *filp <br> ){ <br> printk("^_^ : open %s/n ",/ <br> current-&gt;comm); <br> /* <br> * 应用程序的运行环境由内核提供,内核的运行环境由硬件提供。 <br> * 这里的current是一个指向当前进程的指针, <br> * 现在没必要了解current的细节。 <br> * 在这里,当前进程正打开这个设备, <br> * 返回0表示打开成功,内核会给它一个文件描述符。 <br> * 这里的comm是当前进程在Shell下的command字符串。 <br> */ <br> return 0; <br> } <br> <br> static int <br> asdf_release /* close回调 */ <br> ( <br> struct inode *inode, <br> struct file *filp <br> ){ <br> printk("^_^ : close/n "); <br> return 0; <br> } <br> <br> static ssize_t <br> asdf_read /* read回调 */ <br> ( <br> struct file *filp, <br> char *buf, <br> size_t count, <br> loff_t *f_pos <br> ){ <br> loff_t pos; <br> pos = *f_pos; /* 文件的读写位置 */ <br> if ((pos==4096) || (count&gt;4096)) return 0; /* 判断是否已经到设备尾,或写的长度超过设备大小 */ <br> pos += count; <br> if (pos &gt; 4096) { <br> count -= (pos - 4096); <br> pos = 4096; <br> } <br> if (copy_to_user(buf, asdf_body+*f_pos, count)) return -EFAULT; /* 把数据写到应用程序空间 */ <br> *f_pos = pos; /* 改变文件的读写位置 */ <br> return count; /* 返回读到的字节数 */ <br> } <br> <br> static ssize_t <br> asdf_write /* write回调,和read一一对应 */ <br> ( <br> struct file *filp, <br> const char *buf, <br> size_t count, <br> loff_t *f_pos <br> ){ <br> loff_t pos; <br> pos = *f_pos; <br> if ((pos==4096) || (count&gt;4096)) return 0; <br> pos += count; <br> if (pos &gt; 4096) { <br> count -= (pos - 4096); <br> pos = 4096; <br> } <br> if (copy_from_user(asdf_body+*f_pos, buf, count)) return -EFAULT; <br> *f_pos = pos; <br> return count; <br> } <br> <br> static loff_t <br> asdf_lseek /* lseek回调 */ <br> ( <br> struct file * file, <br> loff_t offset, <br> int orig <br> ){ <br> loff_t pos; <br> pos = file-&gt;f_pos; <br> switch (orig) { <br> case 0: <br> pos = offset; <br> break; <br> case 1: <br> pos += offset; <br> break; <br> case 2: <br> pos = 4096+offset; <br> break; <br> default: <br> return -EINVAL; <br> } <br> if ((pos&gt;4096) || (pos&lt;0)) { <br> printk("^_^ : lseek error %d/n",pos); <br> return -EINVAL; <br> } <br> return file-&gt;f_pos = pos; <br> } <br></td></tr></tbody></table> </td></tr></tbody></table>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c1f0d307d490051ed75d3934ed8548c7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">h323 document</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1e596440e33a43cf6cd72c5d6ffca211/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux启动过程详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>