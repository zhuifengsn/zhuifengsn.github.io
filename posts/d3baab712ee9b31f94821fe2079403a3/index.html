<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构实验：线性表（一元多项式相加） - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构实验：线性表（一元多项式相加）" />
<meta property="og:description" content="一、【实验目的】
1、掌握线性表的链式存储结构；
2、掌握链表的基本操作，并能进行应用实践；
3、使用C/C&#43;&#43;语言和线性表实现“一元多项式相加”专题。
二、【实验内容】
结合课本第41页的例子，采用链式存储结构，将两个线性链表表示的一元多项式相加，并输出。此一元多项式遵循多项式相加运算规则：对于两个一元多项式中存在指数相同的项时，其对应系数相加：合并时系数和为零时，删除“和多项式”中此项；合并时系数和不为零时，则构成“和多项式”中的一项。对于两个一元多项式中存在的指数不相同的项，则分别复抄到“和多项式”中去，原多项式保持不变。
#include &lt;iostream&gt; using namespace std; typedef struct { float coef;//系数 int expn;//指数 }term,ElemType; typedef struct LNode { ElemType data; LNode* next; }LNode,*LinkList,*Polynomial; int InitList(LinkList&amp; P);//ok void CreatPolyn(Polynomial&amp; P, int m);//创建一个m项多项式pk int PrintPolyn(Polynomial&amp; P);//输出多项式ok int SortPolyn(Polynomial&amp; P);//按指数增序排序ok int AddPloyn(Polynomial&amp; P1, Polynomial&amp; P2, Polynomial&amp; P);//多项式相加ok void test01();//测试案例 下面是各函数的重写
int InitList(LinkList&amp; P) { P = new LNode; P-&gt;next = NULL; return 1; } int SortPolyn(Polynomial&amp; P) { //BubbleSort LNode* q = P-&gt;next; int m = 0; while (q) { q = q-&gt;next; m&#43;&#43;; } for (int i = 0; i &lt; m; i&#43;&#43;) { q = P-&gt;next; for(int j = 0; j &lt; m-i-1; j&#43;&#43;) { if (q-&gt;data." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/d3baab712ee9b31f94821fe2079403a3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-22T22:29:55+08:00" />
<meta property="article:modified_time" content="2021-11-22T22:29:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构实验：线性表（一元多项式相加）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0;text-align:justify;"><strong>一、【实验目的】</strong></p> 
<p style="margin-left:0;text-align:justify;">1、掌握线性表的链式存储结构；</p> 
<p style="margin-left:0;text-align:justify;">2、掌握链表的基本操作，并能进行应用实践；</p> 
<p style="margin-left:0;text-align:justify;">3、使用C/C++语言和线性表实现“一元多项式相加”专题。</p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"><strong>二、【实验内容】</strong></p> 
<p style="margin-left:0;text-align:justify;">结合课本第41页的例子，采用链式存储结构，将两个线性链表表示的一元多项式相加，并输出。此一元多项式遵循多项式相加运算规则：对于两个一元多项式中存在指数相同的项时，其对应系数相加：合并时系数和为零时，删除“和多项式”中此项；合并时系数和不为零时，则构成“和多项式”中的一项。对于两个一元多项式中存在的指数不相同的项，则分别复抄到“和多项式”中去，原多项式保持不变。</p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;

typedef struct {
	float coef;//系数
	int expn;//指数
}term,ElemType;

typedef struct LNode {
	ElemType data;
	LNode* next;
}LNode,*LinkList,*Polynomial;

int InitList(LinkList&amp; P);//ok

void CreatPolyn(Polynomial&amp; P, int m);//创建一个m项多项式pk

int PrintPolyn(Polynomial&amp; P);//输出多项式ok

int SortPolyn(Polynomial&amp; P);//按指数增序排序ok

int AddPloyn(Polynomial&amp; P1, Polynomial&amp; P2, Polynomial&amp; P);//多项式相加ok

void test01();//测试案例

</code></pre> 
<p>下面是各函数的重写</p> 
<pre><code>int InitList(LinkList&amp; P) {
	P = new LNode;
	P-&gt;next = NULL;
	return 1;
}

int SortPolyn(Polynomial&amp; P) {
	//BubbleSort
	LNode* q = P-&gt;next;
	int m = 0;
	while (q) {
		q = q-&gt;next;
		m++;
	}
	for (int i = 0; i &lt; m; i++) {
		q = P-&gt;next;
		for(int j = 0; j &lt; m-i-1; j++) {
			if (q-&gt;data.expn &gt; q-&gt;next-&gt;data.expn) {
				term t;
				t = q-&gt;data;
				q-&gt;data = q-&gt;next-&gt;data;
				q-&gt;next-&gt;data = t;
			}
			q = q-&gt;next;
		}
	}
	return 1;
}

void CreatPolyn(Polynomial&amp; P, int m) {
	InitList(P);
	LNode* r = P;//指向队尾
	for (int i = 0; i &lt; m; i++) {
		LNode* q = new LNode;
		q-&gt;next = NULL;
		r-&gt;next = q;
		printf("请输入第%d项的系数和指数:",i+1);
		cin &gt;&gt; q-&gt;data.coef;
		cin &gt;&gt; q-&gt;data.expn;
		cout &lt;&lt; endl;
		r = r-&gt;next;//尾指针后移
	}
	SortPolyn(P);
}

int PrintPolyn(Polynomial&amp; P) {
	LNode* q = P-&gt;next;
	//首项输出
	if (q) {//首项不为空
		if (q-&gt;data.expn == 0) {
			cout &lt;&lt; q-&gt;data.coef;
		}
		else if (q-&gt;data.coef == 1) {
			cout &lt;&lt; "x^" &lt;&lt; q-&gt;data.expn;
		}
		else if (q-&gt;data.coef == -1) {
			cout &lt;&lt; "x^" &lt;&lt; q-&gt;data.expn;
		}
		else
			cout &lt;&lt; q-&gt;data.coef &lt;&lt; "x^" &lt;&lt; q-&gt;data.expn;//输出第一项
		q = q-&gt;next;//指向下一项
	}
	else {
		cout &lt;&lt; "0" &lt;&lt; endl;
		return 1;
	}
	while (q) {
		if (q-&gt;data.coef == 1) {
			cout &lt;&lt; "+x^" &lt;&lt; q-&gt;data.expn;
		}
		else if(q-&gt;data.coef == -1) {
			cout &lt;&lt; "-x^" &lt;&lt; q-&gt;data.expn;
		}
		else if (q-&gt;data.coef &gt; 0) {
			cout &lt;&lt; "+" &lt;&lt; q-&gt;data.coef &lt;&lt; "x^" &lt;&lt;q-&gt;data.expn;
		}
		else {
			cout &lt;&lt;q-&gt;data.coef &lt;&lt; "x^" &lt;&lt; q-&gt;data.expn ;
		}
		q = q-&gt;next;
	}
	cout &lt;&lt; endl;
	return 1;
}

int AddPloyn(Polynomial&amp; P1, Polynomial&amp; P2, Polynomial&amp; P) {
	LNode* q1, * q2, * q;
	InitList(P);
	q1 = P1-&gt;next;
	q2 = P2-&gt;next;
	LNode* r=P;//指向新链尾
	while (q1 &amp;&amp; q2) {
		//q1,q2均不为空
		q = new LNode;//开辟P上下一个结点，q指向下一个结点
		if (q1-&gt;data.expn == q2-&gt;data.expn) {
			//同次数直接相加录入q
			q-&gt;data.coef = q1-&gt;data.coef + q2-&gt;data.coef;
			q-&gt;data.expn = q1-&gt;data.expn;
			q1 = q1-&gt;next;
			q2 = q2-&gt;next;
		}
		else if (q1-&gt;data.expn &gt; q2-&gt;data.expn) {
			//q1次数大，则直接将q2录入q
			q-&gt;data.coef = q2-&gt;data.coef;
			q-&gt;data.expn = q2-&gt;data.expn;
			//q2指向下一个
			q2 = q2-&gt;next;
		}
		else if (q1-&gt;data.expn &lt; q2-&gt;data.expn) {
			//q1次数小，则直接将q1录入q
			q-&gt;data.coef = q1-&gt;data.coef;
			q-&gt;data.expn = q1-&gt;data.expn;
			//q1指向下一个
			q1 = q1-&gt;next;
		}
		//判断相加后是否为零
		if (q-&gt;data.coef == 0) {
			//若是则删除q；
			delete q;
		}
		//若不是则将q接到r上
		else {
			r-&gt;next = q;
			r = q;
			q-&gt;next = NULL;
		}
	}
	//q1或q2遍历为空
	while (q1) {
		q = new LNode;
		q-&gt;data.coef = q1-&gt;data.coef;
		q-&gt;data.expn = q1-&gt;data.expn;
		q1 = q1-&gt;next;
		//q接到r后面，r后移
		r-&gt;next = q;
		r = q;
		q-&gt;next = NULL;
	}
	while (q2) {
		q = new LNode;
		q-&gt;data.coef = q2-&gt;data.coef;
		q-&gt;data.expn = q2-&gt;data.expn;
		q2 = q2-&gt;next;
		//q接到r后面，r后移
		r-&gt;next = q;
		r = q;
		q-&gt;next = NULL;
	}
	return 1;
}

void test01() {
	Polynomial P, P1, P2;
	int m1, m2;
	InitList(P1);
	InitList(P2);

	cout &lt;&lt; "请输入多项式P1项数：";
	cin &gt;&gt; m1;
	cout &lt;&lt; endl;
	cout &lt;&lt; "请输入多项式P1：" &lt;&lt; endl;
	CreatPolyn(P1, m1);

	cout &lt;&lt; "请输入多项式P2项数：";
	cin &gt;&gt; m2;
	cout &lt;&lt; endl;
	cout &lt;&lt; "请输入多项式P2：" &lt;&lt; endl;
	CreatPolyn(P2, m2);
	
	cout &lt;&lt; endl;
	AddPloyn(P1, P2, P);
	cout &lt;&lt; "P1+P2= ";
	PrintPolyn(P);
	cout &lt;&lt; "P1= ";
	PrintPolyn(P1);
	cout &lt;&lt; "P2= ";
	PrintPolyn(P2);
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c96dfcb45bd205a49b83af281a07464e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据结构实验：链表的插入与删除</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e7e862170aa6c92c70d5adfdcb50f0b6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">阿里一面面经</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>