<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java 线程池的理解_Java线程池深入理解 - 追风少年的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java 线程池的理解_Java线程池深入理解" />
<meta property="og:description" content="最近项目中进行告警模块性能优化，不少地方使用了线程池技术，整理总结如下。
package com.coshaho.threadpool;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Executors;
import java.util.concurrent.RejectedExecutionHandler;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
/**
* 线程池学习
* @author coshaho
*/
public class MyThreadPool
{
/**
* 第一章 线程池初始化
*/
// 核心线程数量
private int corePoolSize;
// 最大线程数量
private int maximumPoolSize;
// 空闲线程存活时间
private long keepAliveTime;
// 空闲线程存活时间单位
private TimeUnit unit;
// 线程阻塞队列
private BlockingQueue workQueue;
/**
* 线程创建工厂，一般自定义，用于封装传入ThreadPool的Runnable任务
* 默认：Executors.defaultThreadFactory()
* public interface ThreadFactory {
* Thread newThread(Runnable r);" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhuifengsn.github.io/posts/89c3534f466a13958805d2191d8675ba/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-07T16:53:06+08:00" />
<meta property="article:modified_time" content="2021-03-07T16:53:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="追风少年的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">追风少年的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java 线程池的理解_Java线程池深入理解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>最近项目中进行告警模块性能优化，不少地方使用了线程池技术，整理总结如下。</p> 
 <p>package com.coshaho.threadpool;</p> 
 <p>import java.util.concurrent.BlockingQueue;</p> 
 <p>import java.util.concurrent.Executors;</p> 
 <p>import java.util.concurrent.RejectedExecutionHandler;</p> 
 <p>import java.util.concurrent.ThreadFactory;</p> 
 <p>import java.util.concurrent.ThreadPoolExecutor;</p> 
 <p>import java.util.concurrent.TimeUnit;</p> 
 <p>/**</p> 
 <p>* 线程池学习</p> 
 <p>* @author coshaho</p> 
 <p>*/</p> 
 <p>public class MyThreadPool</p> 
 <p>{<!-- --></p> 
 <p>/**</p> 
 <p>* 第一章 线程池初始化</p> 
 <p>*/</p> 
 <p>// 核心线程数量</p> 
 <p>private int corePoolSize;</p> 
 <p>// 最大线程数量</p> 
 <p>private int maximumPoolSize;</p> 
 <p>// 空闲线程存活时间</p> 
 <p>private long keepAliveTime;</p> 
 <p>// 空闲线程存活时间单位</p> 
 <p>private TimeUnit unit;</p> 
 <p>// 线程阻塞队列</p> 
 <p>private BlockingQueue workQueue;</p> 
 <p>/**</p> 
 <p>* 线程创建工厂，一般自定义，用于封装传入ThreadPool的Runnable任务</p> 
 <p>* 默认：Executors.defaultThreadFactory()</p> 
 <p>* public interface ThreadFactory {<!-- --></p> 
 <p>* Thread newThread(Runnable r);</p> 
 <p>* }</p> 
 <p>*/</p> 
 <p>private ThreadFactory threadFactory;</p> 
 <p>// 线程拒绝机制</p> 
 <p>private RejectedExecutionHandler handler;</p> 
 <p>public void initThreadPoolExecutor()</p> 
 <p>{<!-- --></p> 
 <p>ThreadPoolExecutor executor = new ThreadPoolExecutor(</p> 
 <p>corePoolSize,</p> 
 <p>maximumPoolSize,</p> 
 <p>keepAliveTime,</p> 
 <p>unit,</p> 
 <p>workQueue,</p> 
 <p>threadFactory,</p> 
 <p>handler);</p> 
 <p>// 设置线程池核心线程数</p> 
 <p>executor.setCorePoolSize(corePoolSize);</p> 
 <p>// 设置线程池最大线程数</p> 
 <p>executor.setMaximumPoolSize(maximumPoolSize);</p> 
 <p>// 初始化一个核心线程</p> 
 <p>executor.prestartCoreThread();</p> 
 <p>// 初始化所有核心线程</p> 
 <p>executor.prestartAllCoreThreads();</p> 
 <p>// 不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</p> 
 <p>executor.shutdown();</p> 
 <p>// 立即终止线程池，尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务</p> 
 <p>executor.shutdownNow();</p> 
 <p>}</p> 
 <p>/**</p> 
 <p>* 第二章 线程池任务处理机制</p> 
 <p>* 来了一个任务后的处理机制</p> 
 <p>* 1、 当线程池线程数量小于corePoolSize时，立即新建一个线程执行任务；</p> 
 <p>* 2、 当线程池线程数量等于corePoolSize，workQueue不满时，任务入workQueue队列，等待调度；</p> 
 <p>* 3、 当workQueue满，线程池线程数量小于maximumPoolSize时，新建线程执行任务；</p> 
 <p>* 4、 当线程池线程数量等于maximumPoolSize，workQueue满时，采用线程拒绝机制处理任务。</p> 
 <p>*/</p> 
 <p>/**</p> 
 <p>* 第三章 线程阻塞队列</p> 
 <p>* workQueue的类型为BlockingQueue，通常可以取下面三种类型：</p> 
 <p>* 1、ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；</p> 
 <p>* 2、LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；</p> 
 <p>* 3、synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。</p> 
 <p>*/</p> 
 <p>/**</p> 
 <p>* 第四章 线程拒绝机制</p> 
 <p>*/</p> 
 <p>public void rejectedExecutionHandlerLearn()</p> 
 <p>{<!-- --></p> 
 <p>// 丢弃任务并抛出RejectedExecutionException异常</p> 
 <p>handler = new ThreadPoolExecutor.AbortPolicy();</p> 
 <p>// 也是丢弃任务，但是不抛出异常</p> 
 <p>handler = new ThreadPoolExecutor.DiscardPolicy();</p> 
 <p>// 丢弃队列最前面的任务，然后重新尝试执行任务(重复此过程)</p> 
 <p>handler = new ThreadPoolExecutor.DiscardOldestPolicy();</p> 
 <p>// 由调用线程处理该任务</p> 
 <p>handler = new ThreadPoolExecutor.CallerRunsPolicy();</p> 
 <p>}</p> 
 <p>/**</p> 
 <p>* 第五章 JDK默认线程池</p> 
 <p>*/</p> 
 <p>public void jdkThreadPool()</p> 
 <p>{<!-- --></p> 
 <p>//创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE</p> 
 <p>Executors.newCachedThreadPool();</p> 
 <p>//创建容量为1的缓冲池</p> 
 <p>Executors.newSingleThreadExecutor();</p> 
 <p>//创建固定容量大小的缓冲池</p> 
 <p>Executors.newFixedThreadPool(5);</p> 
 <p>}</p> 
 <p>/**</p> 
 <p>public static ExecutorService newFixedThreadPool(int nThreads) {<!-- --></p> 
 <p>return new ThreadPoolExecutor(nThreads, nThreads,</p> 
 <p>0L, TimeUnit.MILLISECONDS,</p> 
 <p>new LinkedBlockingQueue());</p> 
 <p>}</p> 
 <p>public static ExecutorService newSingleThreadExecutor() {<!-- --></p> 
 <p>return new FinalizableDelegatedExecutorService</p> 
 <p>(new ThreadPoolExecutor(1, 1,</p> 
 <p>0L, TimeUnit.MILLISECONDS,</p> 
 <p>new LinkedBlockingQueue()));</p> 
 <p>}</p> 
 <p>public static ExecutorService newCachedThreadPool() {<!-- --></p> 
 <p>return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</p> 
 <p>60L, TimeUnit.SECONDS,</p> 
 <p>new SynchronousQueue());</p> 
 <p>}</p> 
 <p>*/</p> 
 <p>/**</p> 
 <p>* 第六章 线程池大小设置</p> 
 <p>* 1、 如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1；</p> 
 <p>* 2、 如果是IO密集型任务，参考值可以设置为2*NCPU。</p> 
 <p>*/</p> 
 <p>/**</p> 
 <p>* 第七章 JDK源码</p> 
 <p>* Creates a new [email protected] ThreadPoolExecutor} with the given initial</p> 
 <p>* parameters.</p> 
 <p>*</p> 
 <p>* @param corePoolSize the number of threads to keep in the pool, even</p> 
 <p>* if they are idle, unless [email protected] allowCoreThreadTimeOut} is set</p> 
 <p>* @param maximumPoolSize the maximum number of threads to allow in the</p> 
 <p>* pool</p> 
 <p>* @param keepAliveTime when the number of threads is greater than</p> 
 <p>* the core, this is the maximum time that excess idle threads</p> 
 <p>* will wait for new tasks before terminating.</p> 
 <p>* @param unit the time unit for the [email protected] keepAliveTime} argument</p> 
 <p>* @param workQueue the queue to use for holding tasks before they are</p> 
 <p>* executed. This queue will hold only the [email protected] Runnable}</p> 
 <p>* tasks submitted by the [email protected] execute} method.</p> 
 <p>* @param threadFactory the factory to use when the executor</p> 
 <p>* creates a new thread</p> 
 <p>* @param handler the handler to use when execution is blocked</p> 
 <p>* because the thread bounds and queue capacities are reached</p> 
 <p>* @throws IllegalArgumentException if one of the following holds:</p> 
 <p>* [email protected] corePoolSize &lt; 0}</p> 
 <p>* [email protected] keepAliveTime &lt; 0}</p> 
 <p>* [email protected] maximumPoolSize &lt;= 0}</p> 
 <p>* [email protected] maximumPoolSize &lt; corePoolSize}</p> 
 <p>* @throws NullPointerException if [email protected] workQueue}</p> 
 <p>* or [email protected] threadFactory} or [email protected] handler} is null</p> 
 <p>public ThreadPoolExecutor(int corePoolSize,</p> 
 <p>int maximumPoolSize,</p> 
 <p>long keepAliveTime,</p> 
 <p>TimeUnit unit,</p> 
 <p>BlockingQueue workQueue,</p> 
 <p>ThreadFactory threadFactory,</p> 
 <p>RejectedExecutionHandler handler)</p> 
 <p>*/</p> 
 <p>}</p> 
 <p>原文：http://www.cnblogs.com/coshaho/p/5426887.html</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5800cd9ac4021785aa34b17dc37bfc62/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ffmpeg多种码率控制方式的实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c4b2f341712963a98dc30fd505762dd7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java 线程池的理解_java线程池深入理解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 追风少年的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>